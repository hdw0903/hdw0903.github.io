<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>한참치의 Study Blog</title>
    <link>https://hdw0903.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description> 공부 내용 정리 블로그입니다. </description>
    <pubDate>Mon, 06 Jul 2020 11:43:18 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>리덕스 라이브러리 이해하기</title>
      <link>https://hdw0903.github.io/2020/07/06/%EB%A6%AC%EB%8D%95%EC%8A%A4-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</link>
      <guid>https://hdw0903.github.io/2020/07/06/%EB%A6%AC%EB%8D%95%EC%8A%A4-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Mon, 06 Jul 2020 08:42:18 GMT</pubDate>
      <description>
      
        &lt;p&gt;리덕스를 사용하면 컴포넌트의 상태 업데이트 관련 로직을 다른 파일로 분리시켜 더욱 효율적으로 관리할 수 있습니다. 또한 컴포넌트끼리 똑같은 상태를 공유해야 할 때도 여러 컴포넌트를 거치지 않고 손쉽게 상태 값을 전달하거나 업데이트 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;단순히 전역 상태 관리만 한다면 Context API를 사용하는 것만으로도 충분합니다.&lt;br&gt;하지만 리덕스를 사용하면 상태를 더욱 체계적으로 관리할 수 있기 때문에 프로젝트의 규모가 클 경우에는 리덕스를 사용하는 편이 좋습니다.&lt;/p&gt;
&lt;p&gt;리덕스는 편리한 개발자 도구도 지원하며, &lt;u&gt;미들웨어&lt;/u&gt;라는 기능을 제공하여 &lt;u&gt;비동기 작업&lt;/u&gt;을 훨씬 효율적으로 관리할 수 있게 해줍니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/07/06/리덕스-라이브러리-이해하기/#1&quot;&gt;리덕스의 키워드&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/07/06/리덕스-라이브러리-이해하기/#2&quot;&gt;리액트 없이 쓰는 리덕스&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/07/06/리덕스-라이브러리-이해하기/#3&quot;&gt;리덕스의 세 가지 규칙&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>리덕스를 사용하면 컴포넌트의 상태 업데이트 관련 로직을 다른 파일로 분리시켜 더욱 효율적으로 관리할 수 있습니다. 또한 컴포넌트끼리 똑같은 상태를 공유해야 할 때도 여러 컴포넌트를 거치지 않고 손쉽게 상태 값을 전달하거나 업데이트 할 수 있습니다.</p><p>단순히 전역 상태 관리만 한다면 Context API를 사용하는 것만으로도 충분합니다.<br>하지만 리덕스를 사용하면 상태를 더욱 체계적으로 관리할 수 있기 때문에 프로젝트의 규모가 클 경우에는 리덕스를 사용하는 편이 좋습니다.</p><p>리덕스는 편리한 개발자 도구도 지원하며, <u>미들웨어</u>라는 기능을 제공하여 <u>비동기 작업</u>을 훨씬 효율적으로 관리할 수 있게 해줍니다.</p><ul><li><a href="/2020/07/06/리덕스-라이브러리-이해하기/#1">리덕스의 키워드</a></li><li><a href="/2020/07/06/리덕스-라이브러리-이해하기/#2">리액트 없이 쓰는 리덕스</a></li><li><a href="/2020/07/06/리덕스-라이브러리-이해하기/#3">리덕스의 세 가지 규칙</a></li></ul><a id="more"></a><hr><h2 id="1">리덕스의 키워드</h2><p>리덕스를 사용하면서 접하게 될 키워드의 개념</p><hr><h3 id="액션-action"><a href="#액션-action" class="headerlink" title="액션(action)"></a>액션(action)</h3><p>상태에 변화가 필요하면 액션(action)이란 것이 발생합니다.</p><p>이는 하나의 객체로 표현되어 아래와 같은 형식으로 이루어져 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'TOGGLE_VALUE'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>액션(action) 객체는 반드시 type 필드를 가지고 있어야 합니다</strong>.(이 값을 액션의 이름이라고 생각하면 됩니다.)</p><p>그 외의 값들은 나중에 상태 업데이트를 할 때 참고해야 할 값이며, 작성자 마음대로 작성할 수 있습니다.</p><figure class="highlight jsx"><figcaption><span>액션(action) 객체 예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    text: <span class="string">'리덕스 배우기'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'CHANGE_INPUT'</span></span><br><span class="line">  text: <span class="string">'안녕하세요'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="액션-생성-함수"><a href="#액션-생성-함수" class="headerlink" title="액션 생성 함수"></a>액션 생성 함수</h3><p>액션 생성 함수(action creator)는 말 그대로 액션 객체를 만들어 주는 함수를 말합니다.</p><figure class="highlight jsx"><figcaption><span>액션 생성 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">    data</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> changeInput = <span class="function"><span class="params">text</span> =&gt;</span> (&#123;</span><br><span class="line">  type: <span class="string">'CHANGE_INPUT'</span>,</span><br><span class="line">  text</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>주로 액션 객체를 만들 때 매번 직접 작성하기 귀찮거나, 만드는 과정에서 생기는 실수를 방지하기 위해 함수로 만들어 관리할 때 사용합니다.</p><hr><h3 id="리듀서-reducer"><a href="#리듀서-reducer" class="headerlink" title="리듀서(reducer)"></a>리듀서(reducer)</h3><p>리듀서(reducer)는 변화를 일으키는 함수입니다.<br>액션을 만들어서 발생시키면 리듀서가 현재 상태와 전달받은 액션 객체를 파라미터로 받아옵니다.<br>그리고 두 값을 참고하여 새로운 상태를 만들어 반환합니다.</p><p>리듀서 코드는 다음과 같은 형태로 이루어져 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  counter: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> INCREMENT:</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: state.counter + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="스토어-store"><a href="#스토어-store" class="headerlink" title="스토어(store)"></a>스토어(store)</h3><p>프로젝트에 리덕스를 적용하기 위해 스토어(store)를 만듭니다.</p><p>한 개의 프로젝트는 단 하나의 스토어만 가질 수 있습니다.</p><p>스토어 안에는 현재 애플리케이션 상태와 리듀서가 들어가 있으며, 그 외에도 몇 가지 중요한 내장 함수를 지닙니다.</p><hr><h3 id="디스패치-dispatch"><a href="#디스패치-dispatch" class="headerlink" title="디스패치(dispatch)"></a>디스패치(dispatch)</h3><p>디스패치(dispatch)는 스토어의 내장 함수 중 하나입니다. (액션을 발생시키는 것 이라고 이해하면 됩니다.)</p><p><code>dispatch(action)</code>과 같은 형태로 액션 객체를 파라미터로 넣어 호출합니다.</p><p>디스패치 함수가 호출되면 스토어는 리듀서 함수를 실행시켜 새로운 상태를 만들어 줍니다.</p><hr><h3 id="구독-subscribe"><a href="#구독-subscribe" class="headerlink" title="구독(subscribe)"></a>구독(subscribe)</h3><p>구독(subscribe)도 스토어의 내장 함수 중 하나입니다. subscribe 함수 안에 리스터 함수를 파라미터로 넣어서 호출해 주면, 액션이 디스패치되어 상태가 업데이트될 때마다 리스너 함수가 호출됩니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> listener = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'상태가 업데이트 되었습니다.'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> unsubscribe = store.subscribe(listener);</span><br><span class="line"></span><br><span class="line">unsubscribe(); <span class="comment">// 추후 구독을 비활성화할 때 함수를 호출</span></span><br></pre></td></tr></table></figure><hr><h2 id="2">리액트 없이 쓰는 리덕스</h2><p>리덕스는 리액트에 종속되는 라이브러리가 아닙니다.<br>리액트에서 사용하려고 만들어졌지만 실제로 다른 UI 라이브러리/프레임워크와 함께 사용할 수도 있습니다.</p><p>바닐라 자바스크립트 환경에서 리덕스를 사용하여 리덕스의 핵심 기능과 작동 원리를 이해해 보겠습니다.</p><h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><p>Parcel 이라는 도구를 사용하면 쉽고 빠르게 웹 애플리케이션 프로젝트를 구성할 수 있습니다.</p><blockquote><p>설치<br>yarn global add parcel-bundler</p><p>npm install -g parcel-bundler</p></blockquote><p>프로젝트 디렉터리를 생성한 후 package.json 파일을 생성합니다.</p><blockquote><p>package.json 파일 생성<br>yarn init -y</p><p>npm init -y</p></blockquote><p>프로젝트 디렉터리에 index.html 과 index.js 파일을 만들고 다음과 같이 수정 해줍니다.</p><figure class="highlight html"><figcaption><span>index.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>바닐라 자바스크립트<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello parcel'</span>);</span><br></pre></td></tr></table></figure><p>다 작성한 후 <code>parcel index.html</code> 명령어를 실행하면 개발용 서버가 실행됩니다.</p><p>다음으로 리덕스 모듈도 설치해줍니다.</p><blockquote><p>yarn add redux<br>npm i redux</p></blockquote><hr><h3 id="Ui-구성"><a href="#Ui-구성" class="headerlink" title="Ui 구성"></a>Ui 구성</h3><figure class="highlight css"><figcaption><span>index.css</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.toggle</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid black;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">64px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">64px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">32px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.toggle</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><figcaption><span>index.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"index.css"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toggle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>0<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"increase"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"decrease"</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="DOM-레퍼런스"><a href="#DOM-레퍼런스" class="headerlink" title="DOM 레퍼런스"></a>DOM 레퍼런스</h3><p>UI를 관리할 때 별도의 라이브러리를 사용하지 않기 때문에 DOM을 직접 수정해 줘야합니다.</p><p>기존 코드는 지우고 다음과 같이 자바스크립트 파일 상단에 수정할 DOM 노드를 가리키는 값을 미리 선언해 줍니다.</p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOM 노드 값 설정</span></span><br><span class="line"><span class="keyword">const</span> divToggle = <span class="built_in">document</span>.querySelector(<span class="string">'.toggle'</span>);</span><br><span class="line"><span class="keyword">const</span> counter = <span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>);</span><br><span class="line"><span class="keyword">const</span> btnIncrease = <span class="built_in">document</span>.querySelector(<span class="string">'#increase'</span>);</span><br><span class="line"><span class="keyword">const</span> btnDecrease = <span class="built_in">document</span>.querySelector(<span class="string">'#decrease'</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="액션-타입-정의"><a href="#액션-타입-정의" class="headerlink" title="액션 타입 정의"></a>액션 타입 정의</h3><p>프로젝트의 상태에 변화를 일으키는 것을 액션이라고 합니다.</p><p>먼저 액션 이름을 정의해 줍니다.<br>액션 이름은 문자열 형태로, 주로 대문자로 작성하고 액션 이름은 고유해야 합니다.</p><figure class="highlight js"><figcaption><span>index.js 액션 이름 정의</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOM 노드 값 설정</span></span><br><span class="line"><span class="keyword">const</span> divToggle = <span class="built_in">document</span>.querySelector(<span class="string">'.toggle'</span>);</span><br><span class="line"><span class="keyword">const</span> counter = <span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>);</span><br><span class="line"><span class="keyword">const</span> btnIncrease = <span class="built_in">document</span>.querySelector(<span class="string">'#increase'</span>);</span><br><span class="line"><span class="keyword">const</span> btnDecrease = <span class="built_in">document</span>.querySelector(<span class="string">'#decrease'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 액션 이름 정의</span></span><br><span class="line"><span class="keyword">const</span> TOGGLE_SWITCH = <span class="string">'TOGGLE_SWITCH'</span>;</span><br><span class="line"><span class="keyword">const</span> INCREASE = <span class="string">'INCREASE'</span>;</span><br><span class="line"><span class="keyword">const</span> DECREASE = <span class="string">'DECREASE'</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="액션-생성-함수-정의"><a href="#액션-생성-함수-정의" class="headerlink" title="액션 생성 함수 정의"></a>액션 생성 함수 정의</h3><p>다음으로 액션 이름을 사용하여 액션 객체를 만드는 액션 생성 함수를 작성해 줍니다.</p><p><mark>액션 객체는 type 값을 반드시 가지고 있어야 하며, 그 외의 값은 상태를 업데이트 할 때 참고할 값을 작성자가 마음대로 작성할 수 있습니다.</mark></p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOM 노드 값 설정</span></span><br><span class="line"><span class="keyword">const</span> divToggle = <span class="built_in">document</span>.querySelector(<span class="string">'.toggle'</span>);</span><br><span class="line"><span class="keyword">const</span> counter = <span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>);</span><br><span class="line"><span class="keyword">const</span> btnIncrease = <span class="built_in">document</span>.querySelector(<span class="string">'#increase'</span>);</span><br><span class="line"><span class="keyword">const</span> btnDecrease = <span class="built_in">document</span>.querySelector(<span class="string">'#decrease'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 액션 이름 정의</span></span><br><span class="line"><span class="keyword">const</span> TOGGLE_SWITCH = <span class="string">'TOGGLE_SWITCH'</span>;</span><br><span class="line"><span class="keyword">const</span> INCREASE = <span class="string">'INCREASE'</span>;</span><br><span class="line"><span class="keyword">const</span> DECREASE = <span class="string">'DECREASE'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 액션 생성 함수 작성</span></span><br><span class="line"><span class="keyword">const</span> toggleSwitch = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: TOGGLE_SWITCH &#125;);</span><br><span class="line"><span class="keyword">const</span> increase = <span class="function">(<span class="params">difference</span>) =&gt;</span> (&#123; <span class="attr">type</span>: INCREASE, difference &#125;);</span><br><span class="line"><span class="keyword">const</span> decrease = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: DECREASE &#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="초기값-설정"><a href="#초기값-설정" class="headerlink" title="초기값 설정"></a>초기값 설정</h3><p>이 프로젝트에서 사용할 초기값도 설정해 줍니다.</p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOM 노드 값 설정</span></span><br><span class="line"><span class="keyword">const</span> divToggle = <span class="built_in">document</span>.querySelector(<span class="string">'.toggle'</span>);</span><br><span class="line"><span class="keyword">const</span> counter = <span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>);</span><br><span class="line"><span class="keyword">const</span> btnIncrease = <span class="built_in">document</span>.querySelector(<span class="string">'#increase'</span>);</span><br><span class="line"><span class="keyword">const</span> btnDecrease = <span class="built_in">document</span>.querySelector(<span class="string">'#decrease'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 액션 이름 정의</span></span><br><span class="line"><span class="keyword">const</span> TOGGLE_SWITCH = <span class="string">'TOGGLE_SWITCH'</span>;</span><br><span class="line"><span class="keyword">const</span> INCREASE = <span class="string">'INCREASE'</span>;</span><br><span class="line"><span class="keyword">const</span> DECREASE = <span class="string">'DECREASE'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 액션 생성 함수 작성</span></span><br><span class="line"><span class="keyword">const</span> toggleSwitch = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: TOGGLE_SWITCH &#125;);</span><br><span class="line"><span class="keyword">const</span> increase = <span class="function">(<span class="params">difference</span>) =&gt;</span> (&#123; <span class="attr">type</span>: INCREASE, difference &#125;);</span><br><span class="line"><span class="keyword">const</span> decrease = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: DECREASE &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 초기값 설정</span></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">  toggle: <span class="literal">false</span>,</span><br><span class="line">  counter: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="리듀서-함수-정의"><a href="#리듀서-함수-정의" class="headerlink" title="리듀서 함수 정의"></a>리듀서 함수 정의</h3><p>리듀서 함수는 파라미터로 state 와 action 값을 받아옵니다.</p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(...)</span><br><span class="line"><span class="comment">// DOM 노드 값 설정</span></span><br><span class="line"><span class="keyword">const</span> divToggle = <span class="built_in">document</span>.querySelector(<span class="string">'.toggle'</span>);</span><br><span class="line"><span class="keyword">const</span> counter = <span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>);</span><br><span class="line"><span class="keyword">const</span> btnIncrease = <span class="built_in">document</span>.querySelector(<span class="string">'#increase'</span>);</span><br><span class="line"><span class="keyword">const</span> btnDecrease = <span class="built_in">document</span>.querySelector(<span class="string">'#decrease'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 액션 이름 정의</span></span><br><span class="line"><span class="keyword">const</span> TOGGLE_SWITCH = <span class="string">'TOGGLE_SWITCH'</span>;</span><br><span class="line"><span class="keyword">const</span> INCREASE = <span class="string">'INCREASE'</span>;</span><br><span class="line"><span class="keyword">const</span> DECREASE = <span class="string">'DECREASE'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 액션 생성 함수 작성</span></span><br><span class="line"><span class="keyword">const</span> toggleSwitch = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: TOGGLE_SWITCH &#125;);</span><br><span class="line"><span class="keyword">const</span> increase = <span class="function">(<span class="params">difference</span>) =&gt;</span> (&#123; <span class="attr">type</span>: INCREASE, difference &#125;);</span><br><span class="line"><span class="keyword">const</span> decrease = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: DECREASE &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 초기값 설정</span></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">  toggle: <span class="literal">false</span>,</span><br><span class="line">  counter: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 리듀서 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = initState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> TOGGLE_SWITCH:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state, <span class="comment">// 불변성 유지**</span></span><br><span class="line">        toggle: !state.toggle,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> INCREASE:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        counter: state.counter + action.difference,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> DECREASE:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        counter: state.counter - <span class="number">1</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="스토어-만들기"><a href="#스토어-만들기" class="headerlink" title="스토어 만들기"></a>스토어 만들기</h3><p>스토어를 만들 때는 <code>createStore</code> 함수를 사용합니다.</p><p><strong>createStore 함수를 사용하기 위해서는 import 구문을 넣어 리덕스에서 해당 함수를 불러와 사용하고</strong></p><p><strong>함수의 파라미터에는 리듀서 함수를 넣어 주어야 합니다.</strong></p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line">(...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br></pre></td></tr></table></figure><p>이제 스토어 생성이 완료되었으니 스토어 내장 함수들을 사용할 수 있습니다.</p><hr><h3 id="함수-만들기"><a href="#함수-만들기" class="headerlink" title="함수 만들기"></a>함수 만들기</h3><p>상태가 업데이트될 때 마다 호출시킬 render 함수를 만들어 봅니다.<br>(리액트의 render 함수가 아닙니다.)</p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line">(...)</span><br><span class="line"><span class="comment">// 스토어 만들기</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// render 함수 작성</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> state = store.getState(); <span class="comment">// 현재 상태를 불러옵니다.</span></span><br><span class="line">  <span class="comment">// 토글 처리</span></span><br><span class="line">  <span class="keyword">if</span> (state.toggle) &#123;</span><br><span class="line">    divToggle.classList.add(<span class="string">'active'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    divToggle.classList.remove(<span class="string">'active'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 카운터</span></span><br><span class="line">  counter.innerText = state.counter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><hr><h3 id="구독-subscribe-1"><a href="#구독-subscribe-1" class="headerlink" title="구독(subscribe)"></a>구독(subscribe)</h3><p>상태가 업데이트될 때마다 호출시킬 render 함수는 만들었습니다. </p><p>업데이트 때 마다 호출하는 작업은 스토어 내장 함수 subscribe를 사용하여 처리할 수 있습니다.</p><p>subscribe 함수의 파라미터로 render 함수를 전달해 주면 액션이 발생하여 상태가 업데이트될 때마다 render 함수를 호출합니다.</p><figure class="highlight js"><figcaption><span>subscribe</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.subscribe(render);</span><br></pre></td></tr></table></figure><hr><h3 id="디스패치-액션-발생시키기"><a href="#디스패치-액션-발생시키기" class="headerlink" title="디스패치 (액션 발생시키기)"></a>디스패치 (액션 발생시키기)</h3><p>스토어의 내장 함수 dispatch는 액션을 발생시키는 역활을 합니다.</p><p>파라미터에 액션 객체를 넣어 주면 됩니다.</p><p>다음과 같이 각 DOM 요소에 클릭 이벤트를 설정해 줍니다.</p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM 노드 값 설정</span></span><br><span class="line"><span class="keyword">const</span> divToggle = <span class="built_in">document</span>.querySelector(<span class="string">'.toggle'</span>);</span><br><span class="line"><span class="keyword">const</span> counter = <span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>);</span><br><span class="line"><span class="keyword">const</span> btnIncrease = <span class="built_in">document</span>.querySelector(<span class="string">'#increase'</span>);</span><br><span class="line"><span class="keyword">const</span> btnDecrease = <span class="built_in">document</span>.querySelector(<span class="string">'#decrease'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 액션 이름 정의</span></span><br><span class="line"><span class="keyword">const</span> TOGGLE_SWITCH = <span class="string">'TOGGLE_SWITCH'</span>;</span><br><span class="line"><span class="keyword">const</span> INCREASE = <span class="string">'INCREASE'</span>;</span><br><span class="line"><span class="keyword">const</span> DECREASE = <span class="string">'DECREASE'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 액션 생성 함수 작성</span></span><br><span class="line"><span class="keyword">const</span> toggleSwitch = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: TOGGLE_SWITCH &#125;);</span><br><span class="line"><span class="keyword">const</span> increase = <span class="function">(<span class="params">difference</span>) =&gt;</span> (&#123; <span class="attr">type</span>: INCREASE, difference &#125;);</span><br><span class="line"><span class="keyword">const</span> decrease = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: DECREASE &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 초기값 설정</span></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">  toggle: <span class="literal">false</span>,</span><br><span class="line">  counter: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 리듀서 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = initState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> TOGGLE_SWITCH:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state, <span class="comment">// 불변성 유지**</span></span><br><span class="line">        toggle: !state.toggle,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> INCREASE:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        counter: state.counter + action.difference,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> DECREASE:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        counter: state.counter - <span class="number">1</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 스토어 만들기</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// render 함수 작성</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> state = store.getState(); <span class="comment">// 현재 상태를 불러옵니다.</span></span><br><span class="line">  <span class="comment">// 토글 처리</span></span><br><span class="line">  <span class="keyword">if</span> (state.toggle) &#123;</span><br><span class="line">    divToggle.classList.add(<span class="string">'active'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    divToggle.classList.remove(<span class="string">'active'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 카운터</span></span><br><span class="line">  counter.innerText = state.counter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render();</span><br><span class="line"><span class="comment">// 상태 업데이트시 마다 render 함수 실행</span></span><br><span class="line">store.subscribe(render);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dispatch: 액션 발생</span></span><br><span class="line">divToggle.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  store.dispatch(toggleSwitch());</span><br><span class="line">&#125;;</span><br><span class="line">btnIncrease.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  store.dispatch(increase(<span class="number">1</span>));</span><br><span class="line">&#125;;</span><br><span class="line">btnDecrease.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  store.dispatch(decrease());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3">리덕스의 세 가지 규칙</h2><p>리덕스를 프로젝트에서 사용할 때 지켜야 하는 세 가지 규칙</p><h3 id="단일-스토어"><a href="#단일-스토어" class="headerlink" title="단일 스토어"></a>단일 스토어</h3><p>하나의 어플리케이션 안에는 하나의 스토어가 들어 있습니다.<br>여러개의 스토어를 사용하는 것이 완전 불가능 한 것은 아니나 권장하지 않습니다.</p><h3 id="읽기-전용-상태"><a href="#읽기-전용-상태" class="headerlink" title="읽기 전용 상태"></a>읽기 전용 상태</h3><p>리덕스 상태는 읽기 전용입니다. 기존에 리액트에서 불변성을 지켜준 것 처럼 리덕스도 마찬가지 입니다.</p><p>기존의 객체는 건드리지 않고 새로운 객체를 생성해 줘야 합니다.</p><h3 id="리듀서는-순수한-함수"><a href="#리듀서는-순수한-함수" class="headerlink" title="리듀서는 순수한 함수"></a>리듀서는 순수한 함수</h3><p>리듀서는 순수한 함수여야 합니다. 순수한 함수란 다음 조건을 만족합니다.</p><ul><li><p>리듀서 함수는 이전 상태와 액션 객체를 파라미터로 받습니다.</p></li><li><p>파라미터 외의 값에는 의존해면 안됩니다.</p></li><li><p>기존값을 건드리지 않고, 변화를 준 새로운 상태 객체를 만들어서 반환합니다.</p></li><li><p>똑같은 파라미터로 호출된 리듀서 함수는 언제나 같은 값을 반환해야 합니다.</p></li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/07/06/%EB%A6%AC%EB%8D%95%EC%8A%A4-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>리액트 라우터로 SPA 개발하기</title>
      <link>https://hdw0903.github.io/2020/06/12/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9A%B0%ED%84%B0%EB%A1%9C-SPA-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0/</link>
      <guid>https://hdw0903.github.io/2020/06/12/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9A%B0%ED%84%B0%EB%A1%9C-SPA-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Fri, 12 Jun 2020 11:54:50 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/12/리액트-라우터로-SPA-개발하기/#SPA&quot;&gt;SPA 란?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/12/리액트-라우터로-SPA-개발하기/#SPA_단점&quot;&gt;SPA의 단점&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/12/리액트-라우터로-SPA-개발하기/#기본적인_사용법&quot;&gt;기본적인 사용법&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/12/리액트-라우터로-SPA-개발하기/#URL&quot;&gt;URL 파라미터와 쿼리&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/12/리액트-라우터로-SPA-개발하기/#서브_라우트&quot;&gt;서브 라우트&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/12/리액트-라우터로-SPA-개발하기/#부가기능&quot;&gt;리액트 라우터 부가 기능&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<ul><li><a href="/2020/06/12/리액트-라우터로-SPA-개발하기/#SPA">SPA 란?</a></li><li><a href="/2020/06/12/리액트-라우터로-SPA-개발하기/#SPA_단점">SPA의 단점</a></li><li><a href="/2020/06/12/리액트-라우터로-SPA-개발하기/#기본적인_사용법">기본적인 사용법</a></li><li><a href="/2020/06/12/리액트-라우터로-SPA-개발하기/#URL">URL 파라미터와 쿼리</a></li><li><a href="/2020/06/12/리액트-라우터로-SPA-개발하기/#서브_라우트">서브 라우트</a></li><li><a href="/2020/06/12/리액트-라우터로-SPA-개발하기/#부가기능">리액트 라우터 부가 기능</a></li></ul><a id="more"></a><hr><h2 id='SPA'>SPA 란?</h2><p>SPA는 Single Page Application(싱글 페이지 애플리케이션)의 약어입니다.</p><p>말 그대로 한 개의 페이지로 이루어진 애플리케이션이라는 의미입니다.</p><p>싱글 페이지라고 해서 화면이 한 종류는 아닙니다.</p><p>SPA의 경우 서버에서 사용자에게 제공하는 페이지는 한 종류이지만, 해당 페이지에서 로딩된 자바스크립트와 현재 사용자 브라우저의 주소 상태에 따라 다양한 화면을 보여 줄 수 있습니다.</p><p><u>다른 주소에 다른 화면을 보여주는 것은 라우팅이라고 합니다.</u></p><hr><h2 id='SPA_단점'>SPA의 단점</h2><p>SPA의 단점은 앱의 규모가 커지면 자바스크립트 파일이 너무 커진다는 것입니다.</p><p>페이지 로딩 시 사용자가 실제로 방문하지 않을 수도 있는 페이지의 스크립트도 불러오기 때문입니다.</p><p>이러한 점은 코드 스플리팅(<code>code splitting</code>)을 사용하여 라우트별로 파일을 나누어 트래픽과 로딩 속도를 개선할 수 있습니다.</p><hr><h2 id='기본적인_사용법'>기본적인 사용법</h2><hr><h3 id="라이브러리-설치-및-적용"><a href="#라이브러리-설치-및-적용" class="headerlink" title="라이브러리 설치 및 적용"></a>라이브러리 설치 및 적용</h3><p>리액트 라우터를 설치할 때는 react-router-dom 라이브러리를 설치하면 됩니다.</p><blockquote><p>npm install react-router-dom<br>또는<br>yarn add react-router-dom</p></blockquote><p>프로젝트에 리액트 라우터를 적용할 때는 src/index.js 파일에서 react-router-dom에 내장되어 있는 BrowserRouter라는 컴포넌트를 사용하여 감싸면 됩니다.</p><p><strong>이 컴포넌트는 웹 애플리케이션에 HTML5의 History API를 사용하여 페이지를 새로고침하지 않고도 주소를 변경하고, 현재 주소에 관련된 정보를 props로 쉽게 조회하거나 사용할 수 있도록 해 줍니다.</strong></p><figure class="highlight jsx"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> serviceWorker <span class="keyword">from</span> <span class="string">'./serviceWorker'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;BrowserRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/BrowserRouter&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">serviceWorker.unregister();</span></span><br></pre></td></tr></table></figure><hr><h3 id="페이지-만들기"><a href="#페이지-만들기" class="headerlink" title="페이지 만들기"></a>페이지 만들기</h3><p>사용자가 웹 사이트에 들어왔을 때 맨 처음 보여 줄 Home 컴포넌트와 웹 사이트를 소개하는 About 컴포넌트를 만들어 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>Home.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;홈&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;홈, 가장 먼저 보여지는 페이지.&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Home;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>About.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;소개&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;이 프로젝트는 리액트 라우터 기초를 실습해 보는 예제 프로젝트입니다.&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default About;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Route-컴포넌트로-특정-주소에-컴포넌트-연결"><a href="#Route-컴포넌트로-특정-주소에-컴포넌트-연결" class="headerlink" title="Route 컴포넌트로 특정 주소에 컴포넌트 연결"></a>Route 컴포넌트로 특정 주소에 컴포넌트 연결</h3><p>Route 컴포넌트를 사용하면 규칙을 가진 경로에 어떤 컴포넌트를 보여 줄지 정의할 수 있습니다.</p><figure class="highlight jsx"><figcaption><span>Route 컴포넌트</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"주소규칙"</span> component=&#123;보여 줄 컴포넌트&#125; /&gt;</span><br></pre></td></tr></table></figure><p>Route 컴포넌트를 사용하여 Home 컴포넌트 혹은 About 컴포넌트를 보여 주도록 설정해봅니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">'./About'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./Home'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/"</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>이 상태에서 locallhost:3000/about 경로를 입력해 들어가보면 </p><p>About 컴포넌트만 나올 것 같지만 두 컴포넌트가 모두 나타납니다.</p><p>/about 경로가 / 규칙에도 일치하기 때문에 발생한 현상입니다.</p><p>이를 수정하려면 Home을 위한 Route 컴포넌트를 사용할 때 <code>exact</code>라는 props를 true로 설정하면 됩니다.</p><figure class="highlight jsx"><figcaption><span>exact</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"/"</span> component=&#123;Home&#125; exact=&#123;<span class="literal">true</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="a-태그-대신-Link-컴포넌트"><a href="#a-태그-대신-Link-컴포넌트" class="headerlink" title="a 태그 대신 Link 컴포넌트"></a>a 태그 대신 Link 컴포넌트</h3><p>Link 컴포넌트는 클릭하면 다른 주소로 이동시켜 주는 컴포넌트입니다.</p><p>일반 웹 어플리케이션에서는 a 태그를 사용하여 페이지를 전환하지만 리액트 라우터를 사용할 때는 a 태그를 직접 사용하면 안됩니다.</p><p><mark>a 태그는 페이지를 전환하는 과정에서 페이지를 새로 불러오기 때문에 애플리케이션이 들고 있던 상태들을 모두 날려 버리게 됩니다. 렌더링된 컴포넌트들도 모두 사라지고 다시 처음부터 렌더링하게 됩니다.</mark></p><p>Link 컴포넌트를 사용하여 페이지를 전환하면, 페이지를 새로 불러오지 않고 애플리케이션은 그대로 유지한 상태에서 HTML5 History API를 사용하여 페이지의 주소만 변경해 줍니다.</p><p><u>Link 컴포넌트에는 페이지 전환을 방지하는 기능이 내장돠어 있습니다.</u></p><p>다음은 App 컴포넌트에서 “/“, “/about” 경로로 이동하는 Link 컴포넌트를 만든 상태입니다.</p><figure class="highlight jsx"><figcaption><span>Link 컴포넌트</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/"</span>&gt;홈&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/about"</span>&gt;소개&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Route path="/</span><span class="string">" component=&#123;Home&#125; /&gt;</span></span><br><span class="line"><span class="string">      &lt;Route path="</span>/about<span class="string">" component=&#123;About&#125; /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Route-하나에-여러-개의-path-설정하기"><a href="#Route-하나에-여러-개의-path-설정하기" class="headerlink" title="Route 하나에 여러 개의 path 설정하기"></a>Route 하나에 여러 개의 path 설정하기</h3><p>path props를 배열로 설정해 주면 여러 경로에서 같은 컴포넌트를 보여 줄 수 있습니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">'./about'</span> component=&#123;About&#125; /&gt;</span><br><span class="line">&lt;Route path=<span class="string">'./info'</span> component=&#123;About&#125; /&gt;</span><br><span class="line"><span class="comment">// Route를 두 번 사용하는 대신, path props를 배열로 설정해</span></span><br><span class="line"><span class="comment">// 여러 경로에서 같은 컴포넌트 보여주기</span></span><br><span class="line">&lt;Route path=&#123;[<span class="string">'./about'</span>, <span class="string">'./info'</span>]&#125; component=&#123;About&#125; /&gt;</span><br></pre></td></tr></table></figure><hr><h2 id='URL'>URL 파라미터와 쿼리</h2><p>페이지 주소를 정의할 때 유동적인 값을 전달해야 할 때도 있습니다.<br>이는 파라미터와 쿼리로 나눌 수 있습니다.</p><ul><li><p>파라미터 ex) /profiles/velopert</p></li><li><p>쿼리 ex) /about?defails=true</p></li></ul><p>유동적인 값을 사용해야 하는 상황에서 파라미터를 써야 할지 쿼리를 써야 할지 정할 때, 무조건 따라야 하는 규칙은 없습니다.</p><p>일반적으로 파라미터는 특정 아이디 혹은 이름을 사용하여 조회할 때 사용하고,</p><p>쿼리는 키워드를 검색하거나 페이지에 필요한 옵션을 전달할 때 사용합니다.</p><hr><h3 id="URL-파라미터"><a href="#URL-파라미터" class="headerlink" title="URL 파라미터"></a>URL 파라미터</h3><p>Profile 페이지에서 파라미터를 사용하여 /profile/velopert와 같은 형식으로 뒷부분에 유동적인 username 값을 넣어 줄 때 해당 값을 props로 받아 와서 조회하는 방법을 알아봅니다.</p><figure class="highlight jsx"><figcaption><span>profile.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  velopert: &#123;</span><br><span class="line">    name: <span class="string">'김민준'</span>,</span><br><span class="line">    description: <span class="string">'리액트를 좋아하는 개발자'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  gildong: &#123;</span><br><span class="line">    name: <span class="string">'홍길동'</span>,</span><br><span class="line">    description: <span class="string">'고전 소설 홍길동전의 주인공'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Profile = <span class="function">(<span class="params">&#123; match &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username &#125; = match.params;</span><br><span class="line">  <span class="keyword">const</span> profile = data[username];</span><br><span class="line">  <span class="keyword">if</span> (!profile) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>존재하지 않는 사용자입니다.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;</span><br><span class="line">        &#123;username&#125;(&#123;profile.name&#125;)</span><br><span class="line">      &lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;&#123;profile.description&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Profile;</span></span><br></pre></td></tr></table></figure><p><mark>URL 파라미터를 사용할 때는 라우트로 사용되는 컴포넌트에서 받아 오는 match라는 객체 안의 params 값을 참조합니다. match 객체 안에는 현재 컴포넌트가 어떤 경로 규칙에 의해 보이는지에 대한 정보가 들어 있습니다.</mark></p><p>App 컴포넌트에서 Profile 컴포넌트를 위한 라우트를 정의해봅니다.<br>이번 path 규칙에는 /profiles/:username이라고 넣어주어 match.params.username 값을 통해 현재 username 값을 조회할 수 있게 합니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">'./About'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./Home'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./Profile'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/"</span>&gt;홈&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/about"</span>&gt;소개&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/profile/velopert"</span>&gt;velopert 프로필&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/profile/gildong"</span>&gt;gildong 프로필&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;hr /</span>&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/"</span> component=&#123;Home&#125; exact=&#123;<span class="literal">true</span>&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/profile/:username"</span> component=&#123;Profile&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><hr><h3 id="URL-쿼리"><a href="#URL-쿼리" class="headerlink" title="URL 쿼리"></a>URL 쿼리</h3><p>About 페이지에서 쿼리를 받아와봅니다.</p><p><mark>쿼리는 location 객체에 들어 있는 search 값에서 조회할 수 있습니다. location 객체는 라우트로 사용된 컴포넌트에게 props로 전달되며, 웹 애플리케이션의 현재 주소에 대한 정보를 지니고 있습니다.</mark></p><p>location의 형태는 다음과 같습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"pathname"</span>: <span class="string">"/about"</span>,</span><br><span class="line">  <span class="string">"search"</span>: <span class="string">"?detail=true"</span>,</span><br><span class="line">  <span class="string">"hash"</span>: <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 location 객체는 <a href="http://locallhost:3000/about?detail=true">http://locallhost:3000/about?detail=true</a> 주소로 들어갔을 때의 값입니다.</p><ul><li><p>URL 쿼리를 읽을 때는 search 값을 확인해야 합니다. 이 값은 문자열로 되어 있습니다.</p></li><li><p>URL 쿼리는 ?detail=ture&amp;anoter=1과 같이 문자열에 여러 가지 값을 설정해 줄 수 있습니다.</p></li><li><p>search 값에서 특정 값을 읽어 오기 위해서는 이 문자열을 객체 형태로 변환해 주어야 합니다.</p></li></ul><p><u>쿼리 문자열을 객체로 변환할 때는 qs라는 라이브러리를 사용합니다.</u></p><blockquote><p>npm install qs<br>또는<br>yarn add qs</p></blockquote><p>About 컴포넌트에서 location.search 값에 있는 detail이 ture인지 아닌지에 따라 추가 정보를 보여 주도록 만들겠습니다. </p><figure class="highlight jsx"><figcaption><span>About.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> About = <span class="function">(<span class="params">&#123; location &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> query = qs.parse(location.search, &#123;</span><br><span class="line">    ignoreQueryPrefix: <span class="literal">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> showDetail = query.detail === <span class="string">'true'</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;소개&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;이 프로젝트는 리액트 라우터 기초를 실습해 보는 예제 프로젝트입니다.&lt;/</span>p&gt;</span><br><span class="line">      &#123;showDetail &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>detail 값을 true로 설정하셨군요!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default About;</span></span><br></pre></td></tr></table></figure><p>쿼리를 사용할 때는 쿼리 문자열을 객체로 파싱하는 과정에서 결과 값은 언제나 문자열이라는 점을 주의합니다.</p><p>?value=1 혹은 ?value=true와 같이 숫자나 논리 자료형을 사용한다고 해도 “1”, “true”와 같이 문자열 형태로 받아집니다.</p><p>그렇기 때문에 숫자를 받아 와야 하면 parseInt 함수를 통해 꼭 숫자로 변환해 주고, 지금처럼 논리 자료형 값을 사용해야 하는 경우에는 정확하 “true” 문자열이랑 일치하는지 비교해 줘야합니다.</p><hr><h2 id='서브_라우트'>서브 라우트</h2><p>서브 라우트는 라우트 내부에 또 라우트를 정의하는 것을 말합니다.<br>라우트로 사용되고 있는 컴포넌트의 내부에 Route 컴포넌트를 또 사용하면 됩니다.</p><p>기존의 App 컴포넌트에서는 두 종류의 Profile 링크를 보여 주었는데, 이를 잘라내서 프로필 링크를 보여 주는 Profiles 라우트 컴포넌트를 따로 만들고, 그 안에서 Profile 컴포넌트를 서브 라우트로 사용하도록 작성해 봅니다.</p><figure class="highlight jsx"><figcaption><span>profiles</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./Profile'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Profiles = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;사용자 목록&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Link to="/</span>profiles/velopert<span class="string">"&gt;velopert&lt;/Link&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;</span></span><br><span class="line"><span class="string">          &lt;Link to="</span>/profiles/gildong<span class="string">"&gt;gildong&lt;/Link&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;Route</span></span><br><span class="line"><span class="string">        path="</span>/profiles<span class="string">"</span></span><br><span class="line"><span class="string">        exact</span></span><br><span class="line"><span class="string">        render=&#123;() =&gt; &lt;div&gt;사용자를 선택해 주세요.&lt;/div&gt;&#125;</span></span><br><span class="line"><span class="string">      /&gt;</span></span><br><span class="line"><span class="string">      &lt;Route path="</span>/profiles/:username<span class="string">" component=&#123;Profile&#125; /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default Profiles;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">'./About'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./Home'</span>;</span><br><span class="line"><span class="keyword">import</span> Profiles <span class="keyword">from</span> <span class="string">'./Profiles'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/"</span>&gt;홈&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/about"</span>&gt;소개&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/profiles"</span>&gt;프로필&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;hr /</span>&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/"</span> component=&#123;Home&#125; exact=&#123;<span class="literal">true</span>&#125; /&gt;</span><br><span class="line">      &lt;Route path=&#123;[<span class="string">'/about'</span>, <span class="string">'/info'</span>]&#125; component=&#123;About&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/profiles"</span> component=&#123;Profiles&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><hr><h2 id='부가기능'>리액트 라우터 부가 기능</h2><hr><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history 객체는 라우트로 사용된 컴포넌트에 match, location과 함께 전달되는 props 중 하나로, 이 객체를 통해 컴포넌트 내에 구현하는 메서드에서 라우터 API를 호출할 수 있습니다.</p><p>예를 들어 특정 버튼을 눌렀을 때 뒤로 가거나, 로그인후 화면을 전환하거나, 다른 페이지로 이탈하는 것을 방지해야 할 때 history를 활용합니다.</p><figure class="highlight jsx"><figcaption><span>HistorySample.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HistorySample</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 뒤로가기</span></span><br><span class="line">  handleGoBack = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.history.goBack();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 홈으로 이동</span></span><br><span class="line">  handleGoHome = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.history.push(<span class="string">'/'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props);</span><br><span class="line">    <span class="comment">// 이걸 설정하고 나면 페이지에 변화가 생기려고 할 때 마다 정말 나갈거냐고 질문</span></span><br><span class="line">    <span class="keyword">this</span>.unblock = <span class="keyword">this</span>.props.history.block(<span class="string">'정말 떠나실건가요?'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="comment">// 컴포넌트가 언마운트 되면 질문을 멈춤</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.unblock) &#123;</span><br><span class="line">      <span class="keyword">this</span>.unblock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleGoBack&#125;&gt;뒤로&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleGoHome&#125;&gt;홈으로&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default HistorySample;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">'./About'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./Home'</span>;</span><br><span class="line"><span class="keyword">import</span> Profiles <span class="keyword">from</span> <span class="string">'./Profiles'</span>;</span><br><span class="line"><span class="keyword">import</span> HistorySample <span class="keyword">from</span> <span class="string">'./HistorySample'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/"</span>&gt;홈&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/about"</span>&gt;소개&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/profiles"</span>&gt;프로필&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/history"</span>&gt;History 예제&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;hr /</span>&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/"</span> component=&#123;Home&#125; exact=&#123;<span class="literal">true</span>&#125; /&gt;</span><br><span class="line">      &lt;Route path=&#123;[<span class="string">'/about'</span>, <span class="string">'/info'</span>]&#125; component=&#123;About&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/profiles"</span> component=&#123;Profiles&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/history"</span> component=&#123;HistorySample&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>링크를 눌러서 현재 페이지를 이탈하려고 할 때 마다 “정말 떠나실 건가요?” 메서지 창이 뜨게됩니다.</p><hr><h3 id="WithRouter"><a href="#WithRouter" class="headerlink" title="WithRouter"></a>WithRouter</h3><p>WithRouter 함수는 HoC (Higher-order Component)입니다.</p><p>라우트로 사용된 컴포넌트가 아니어도 match, location, history 객체를 접근할 수 있게 해 줍니다.</p><figure class="highlight jsx"><figcaption><span>WithRouterSample.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">const</span> WithRouterSample = <span class="function">(<span class="params">&#123; location, match, history &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h4&gt;location&lt;<span class="regexp">/h4&gt;</span></span><br><span class="line"><span class="regexp">      &lt;textarea</span></span><br><span class="line"><span class="regexp">        value=&#123;JSON.stringify(location, null, 2)&#125;</span></span><br><span class="line"><span class="regexp">        rows=&#123;7&#125;</span></span><br><span class="line"><span class="regexp">        readOnly=&#123;true&#125;</span></span><br><span class="line"><span class="regexp">      /</span>&gt;</span><br><span class="line">      &lt;h4&gt;match&lt;<span class="regexp">/h4&gt;</span></span><br><span class="line"><span class="regexp">      &lt;textarea</span></span><br><span class="line"><span class="regexp">        value=&#123;JSON.stringify(match, null, 2)&#125;</span></span><br><span class="line"><span class="regexp">        rows=&#123;7&#125;</span></span><br><span class="line"><span class="regexp">        readOnly=&#123;true&#125;</span></span><br><span class="line"><span class="regexp">      /</span>&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; history.push(<span class="string">'/'</span>)&#125;&gt;홈으로&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(WithRouterSample);</span><br></pre></td></tr></table></figure><p>withRouter를 사용할 때는 위 코드처럼 컴포넌트를 내보내 줄 때 함수로 감싸줍니다.</p><p>withRouter를 사용하면 현재 자신을 보여 주고 있는 라우트 컴포넌트를 기준으로 match가 전달됩니다.</p><p>따라서 WithRouterSample 컴포넌트를 Profile 컴포넌트에 넣으면 match 쪽에 URL 파라미터가 정상적으로 표시됩니다.</p><figure class="highlight jsx"><figcaption><span>Profile.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> WithRouterSample <span class="keyword">from</span> <span class="string">'./WithRouterSample'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  velopert: &#123;</span><br><span class="line">    name: <span class="string">'김민준'</span>,</span><br><span class="line">    description: <span class="string">'리액트를 좋아하는 개발자'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  gildong: &#123;</span><br><span class="line">    name: <span class="string">'홍길동'</span>,</span><br><span class="line">    description: <span class="string">'고전 소설 홍길동전의 주인공'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Profile = <span class="function">(<span class="params">&#123; match &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username &#125; = match.params;</span><br><span class="line">  <span class="keyword">const</span> profile = data[username];</span><br><span class="line">  <span class="keyword">if</span> (!profile) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>존재하지 않는 사용자입니다.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;</span><br><span class="line">        &#123;username&#125;(&#123;profile.name&#125;)</span><br><span class="line">      &lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;&#123;profile.description&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;WithRouterSample /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(Profile);</span></span><br></pre></td></tr></table></figure><hr><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p>Swith 컴포넌트는 <strong>여러 Router를 감싸서 그중 일치하는 단 하나의 라우트만을 렌더링</strong>시켜 줍니다. </p><p>Swith를 사용하면 모든 규칙과 일치하지 않을 때 보여 줄 <strong>Not Found 페이지도 구현할 수 있습니다</strong>.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Link, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">'./About'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./Home'</span>;</span><br><span class="line"><span class="keyword">import</span> Profiles <span class="keyword">from</span> <span class="string">'./Profiles'</span>;</span><br><span class="line"><span class="keyword">import</span> HistorySample <span class="keyword">from</span> <span class="string">'./HistorySample'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/"</span>&gt;홈&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/about"</span>&gt;소개&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/profiles"</span>&gt;프로필&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"/history"</span>&gt;History 예제&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;hr /</span>&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/"</span> component=&#123;Home&#125; exact=&#123;<span class="literal">true</span>&#125; /&gt;</span><br><span class="line">        &lt;Route path=&#123;[<span class="string">'/about'</span>, <span class="string">'/info'</span>]&#125; component=&#123;About&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/profiles"</span> component=&#123;Profiles&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/history"</span> component=&#123;HistorySample&#125; /&gt;</span><br><span class="line">        &lt;Route</span><br><span class="line">          <span class="comment">// path를 따로 정의하지 않으면 모든 상황에 렌더링됨</span></span><br><span class="line">          render=&#123;(&#123; location &#125;) =&gt; (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;h2&gt;이 페이지는 존재하지 않습니다:&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">              &lt;p&gt;&#123;location.pathname&#125;&lt;/</span>p&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">          )&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>이제 http: //locallhost:3000/경로의 아무 주소나 들어가보면</p><p>“이 페이지는 존재하지 않습니다:” 문구와 접속한 주소의 이름이 나타납니다.</p><hr><h3 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h3><p>NavLink는 현재 경로와 Link에서 사용하는 경로가 일치하는 경우 특정 스타일 혹은 CSS 클래스를 적용할 수 있는 컴포넌트입니다.</p><p>NavLink에서 링크가 활성화되었을 때의 스타일을 적용할 때는 activeStyle 값을, CSS 클래스를 적용할 때는 activeClassName 값을 props로 넣어줍니다.</p><figure class="highlight jsx"><figcaption><span>Profiles.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NavLink, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./Profile'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Profiles = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> activeStyle = &#123;</span><br><span class="line">    background: <span class="string">'black'</span>,</span><br><span class="line">    color: <span class="string">'white'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;사용자 목록:&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li&gt;</span></span><br><span class="line"><span class="regexp">          &lt;NavLink activeStyle=&#123;activeStyle&#125; to="/</span>profiles/velopert<span class="string">" active&gt;</span></span><br><span class="line"><span class="string">            velopert</span></span><br><span class="line"><span class="string">          &lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;</span></span><br><span class="line"><span class="string">          &lt;NavLink activeStyle=&#123;activeStyle&#125; to="</span>/profiles/gildong<span class="string">"&gt;</span></span><br><span class="line"><span class="string">            gildong</span></span><br><span class="line"><span class="string">          &lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      &lt;Route</span></span><br><span class="line"><span class="string">        path="</span>/profiles<span class="string">"</span></span><br><span class="line"><span class="string">        exact</span></span><br><span class="line"><span class="string">        render=&#123;() =&gt; &lt;div&gt;유저를 선택해주세요.&lt;/div&gt;&#125;</span></span><br><span class="line"><span class="string">      /&gt;</span></span><br><span class="line"><span class="string">      &lt;Route path="</span>/profiles/:username<span class="string">" component=&#123;Profile&#125; /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default Profiles;</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/06/12/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9A%B0%ED%84%B0%EB%A1%9C-SPA-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>컴포넌트 스타일링 방식</title>
      <link>https://hdw0903.github.io/2020/06/07/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81-%EB%B0%A9%EC%8B%9D/</link>
      <guid>https://hdw0903.github.io/2020/06/07/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81-%EB%B0%A9%EC%8B%9D/</guid>
      <pubDate>Sun, 07 Jun 2020 06:21:16 GMT</pubDate>
      <description>
      
        &lt;p&gt;리액트에서 컴포넌트를 스타일링할 때는 다양한 방식을 사용할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/07/컴포넌트-스타일링-방식/#CSS&quot;&gt;일반 CSS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/07/컴포넌트-스타일링-방식/#Sass&quot;&gt;Sass 사용하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/07/컴포넌트-스타일링-방식/#Module&quot;&gt;CSS Module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/07/컴포넌트-스타일링-방식/#styled-components&quot;&gt;styled-components&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>리액트에서 컴포넌트를 스타일링할 때는 다양한 방식을 사용할 수 있습니다.</p><ul><li><a href="/2020/06/07/컴포넌트-스타일링-방식/#CSS">일반 CSS</a></li><li><a href="/2020/06/07/컴포넌트-스타일링-방식/#Sass">Sass 사용하기</a></li><li><a href="/2020/06/07/컴포넌트-스타일링-방식/#Module">CSS Module</a></li><li><a href="/2020/06/07/컴포넌트-스타일링-방식/#styled-components">styled-components</a></li></ul><a id="more"></a><hr><h2 id ="CSS">일반 CSS</h2><p>프로젝트는 일반 CSS 방식으로 만들어져 있습니다.</p><ul><li>CSS를 작성할 때 가장 중요한 점은 CSS 클래스를 중복되지 않게 만드는 것입니다.</li></ul><hr><h3 id="이름-짓는-규칙"><a href="#이름-짓는-규칙" class="headerlink" title="이름 짓는 규칙"></a>이름 짓는 규칙</h3><p>프로젝트에 자동 생성된 App.css를 읽어 보면 클래스 이름이 컴포넌트 이름-클래스 형태로 지어져 있습니다.<br>(예 : App-header) 클래스 이름에 컴포넌트 이름을 포함시켜 다른 컴포넌트에서 실수로 중복되는 클래스를 만들어 사용하는 것을 방지합니다.</p><p>비슷한 방식으로 BEM 네이밍 방식도 있습니다. BEM 네이밍은 CSS 방법론 중 하나로 해당 클래스가 어디에서 어떤 용도로 사용되는지 명확하게 작성합니다. (예: .card_title-primary)</p><hr><h3 id="CSS-Selector"><a href="#CSS-Selector" class="headerlink" title="CSS Selector"></a>CSS Selector</h3><p>CSS Selector를 사용하면 CSS 클래스가 특정 클래스 내부에 있는 경우에만 스타일을 적용합니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* App 클래스 내부의 logo 클래스에만 스타일 적용 */</span></span><br><span class="line"><span class="selector-class">.App</span> <span class="selector-class">.logo</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id ="Sass">Sass 사용하기</h2><p>Sass(Syntactically Awesome Style Sheets)는 CSS 전처리기로 스타일 코드의 재활용성을 높여주고 복잡한 작업을 쉽게하여 가독성을 높여 줍니다.</p><p>Sass는 두 가지 확장자 .sass와 .scss를 지원합니다.</p><figure class="highlight scss"><figcaption><span>.sass</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$font-stack</span>: Helvetica, sans-serif</span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span></span><br><span class="line"></span><br><span class="line">body</span><br><span class="line">  font: <span class="number">100%</span> <span class="variable">$font-stack</span></span><br><span class="line">  color: <span class="variable">$primary-color</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><figcaption><span>.scss</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$font-stack</span>: Helvetica, sans-serif;</span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">100%</span> <span class="variable">$font-stack</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.sass 확장자는 중괄호{}와 세미콜론;을 사용하지 않습니다.</p><ul><li>또한 Sass에서는 믹스인 기능을 사용하여 재사용되는 스타일 블록을 함수처럼 사용할 수 있습니다.</li></ul><figure class="highlight scss"><figcaption><span>mixin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수 사용하기</span></span><br><span class="line"><span class="variable">$red</span>: <span class="number">#fa5252</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 믹스인 사용하기</span></span><br><span class="line"><span class="keyword">@mixin</span> square(<span class="variable">$size</span>) &#123;</span><br><span class="line">  <span class="variable">$calculated</span>: <span class="number">32px</span> * <span class="variable">$size</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$calculated</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$calculated</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//클래스에 적용하기</span></span><br><span class="line"><span class="selector-class">.red</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="variable">$red</span>;</span><br><span class="line">  <span class="keyword">@include</span> square(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="함수-분리하기"><a href="#함수-분리하기" class="headerlink" title="함수 분리하기"></a>함수 분리하기</h3><p>Sass 변수 및 믹스인은 다른 파일로 분리하여 작성한 뒤 필요한 파일에서 불러와 여러 파일에 적용시킬 수 있습니다.</p><figure class="highlight scss"><figcaption><span>utils.scss</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수 사용하기</span></span><br><span class="line"><span class="variable">$red</span>: <span class="number">#fa5252</span>;</span><br><span class="line"><span class="variable">$orange</span>: <span class="number">#fd7e14</span>;</span><br><span class="line"><span class="variable">$yellow</span>: <span class="number">#fcc419</span>;</span><br><span class="line"><span class="variable">$green</span>: <span class="number">#40c057</span>;</span><br><span class="line"><span class="variable">$blue</span>: <span class="number">#339af0</span>;</span><br><span class="line"><span class="variable">$indigo</span>: <span class="number">#5c7cfa</span>;</span><br><span class="line"><span class="variable">$violet</span>: <span class="number">#7950f2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 믹스인 만들기 (재사용되는 스타일 블록을 함수처럼 사용 할 수 있음)</span></span><br><span class="line"><span class="keyword">@mixin</span> square(<span class="variable">$size</span>) &#123;</span><br><span class="line">  <span class="variable">$calculated</span>: <span class="number">32px</span> * <span class="variable">$size</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$calculated</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$calculated</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>선언한 변수 파일과 믹스인을 따로 빼네어 utils.scss 파일에 저장했습니다.<br>다른 파일에서 불러올 때는 @import 구문을 사용하여 불러오면 됩니다.</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">'./styles/utils'</span>;</span><br><span class="line">(...)</span><br></pre></td></tr></table></figure><hr><h3 id="node-modules에서-라이브러리-불러오기"><a href="#node-modules에서-라이브러리-불러오기" class="headerlink" title="node_modules에서 라이브러리 불러오기"></a>node_modules에서 라이브러리 불러오기</h3><p>Sass의 장점 중 하나는 라이브러리를 쉽게 불러와서 사용할 수 있다는 점입니다.</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">'../../../node_modules/library/styles'</span>;</span><br></pre></td></tr></table></figure><p>위와 같이 상대 경로를 사용하여 node_modules까지 들어가서 불러올 필요없이 물결 문자(~) 을 사용하여 불러올수 있습니다.</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">'~library/styles'</span>;</span><br></pre></td></tr></table></figure><p>물결 문자(~)를 사용하면 자동으로 node_modules에서 라이브러리 디렉터리를 탐지하여 스타일을 불러옵니다.</p><hr><h2 id ="Module">CSS Module</h2><p>CSS Module은 CSS를 불러와서 사용할 때 클래스 이름을 고유한 값으로 자동으로 만들어 컴포넌트 스타일 클래스 이름이 중첩되는 현상을 방지해 주는 기술입니다.</p><p><code>[파일 이름]_[클래스 이름]_[해시값]</code> 형태로 만듭니다.</p><p>create-react-app v2 버전 이상 부터 .module.css 확장자로 파일을 저장하기만 하면 CSS Module이 적용됩니다.</p><p>CSSModule.module.css라는 파일을 만들어 보겠습니다.</p><figure class="highlight scss"><figcaption><span>CSSModule.module.css</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 자동으로 고유해질 것이므로 흔히 사용되는 단어를 클래스 이름으로 마음대로 사용가능*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: black;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 글로벌 CSS 를 작성하고 싶다면 */</span></span><br><span class="line">:global &#123;</span><br><span class="line">  // :global &#123;&#125; 로 감싸기</span><br><span class="line">  .something &#123;</span><br><span class="line">    font-weight: <span class="number">800</span>;</span><br><span class="line">    <span class="attribute">color</span>: aqua;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 여기에 다른 클래스를 만들 수도 있습니다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CSS Module이 적용된 스타일을 불러오면 객체를 전달받게 되는데 CSS Module에서 사용한 클래스 이름이 고유화된 값으로 들어있습니다.</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ex )</span></span><br><span class="line">&#123; wrapper : <span class="string">"CSSModule_wrapper_1SbdQ"</span> &#125;</span><br></pre></td></tr></table></figure><p>지정해준 클래스 이름 앞뒤로 파일 이름(CSSModule)과 해쉬값(1SbdQ)이 붙은 형태입니다.</p><p>이 고유한 클래스 이름을 사용하는 리엑트 컴포넌트를 작성해 보겠습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./CSSModule.module.scss'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CSSModule = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;styles.wrapper&#125;&gt;</span><br><span class="line">      안녕하세요, 저는 &lt;span className=<span class="string">"something"</span>&gt;CSS Module!&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> CSSModule;</span><br></pre></td></tr></table></figure><p>위와 같이 </p><ul><li><p>고유한 클래스 이름을 사용하려면 클래스를 적용하고 싶은 JSX 엘리먼트에 <code>className={styles.[클래스 이름]}</code> 형태로 전달.</p></li><li><p>:global을 사용하여 전역적으로 선언한 클래스의 경우 일반적으로 사용하던 방법과 똑같이 그냥 클래스이름을 넣어주면됩니다. <code>className=&quot;something&quot;</code></p></li></ul><hr><h3 id="클래스-이름-두-개-이상-적용"><a href="#클래스-이름-두-개-이상-적용" class="headerlink" title="클래스 이름 두 개 이상 적용"></a>클래스 이름 두 개 이상 적용</h3><p>CSS Module로 만든 클래스 이름을 두 개 이상 적용할 때</p><p>ES6의 문법 템플릿 리터럴을 사용하여 문자열을 합침으로 간단히 처리할 수 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CSSModule.module.css</span></span><br><span class="line">.wrapper &#123;...&#125;</span><br><span class="line">.inverted &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsx</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'.CSSModule.module.css'</span></span><br><span class="line"></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span> <span class="title">name</span></span>= &#123;<span class="string">`<span class="subst">$&#123;styles.wrapper&#125;</span> <span class="subst">$&#123;styles.inverted&#125;</span>`</span>&#125;&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>템플릿 리터럴 문법으로 작성하고 싶지 않다면 다음과 같은 방식도 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">className=&#123;[styles.wrapper, styles.inverted].join(<span class="string">' '</span>)&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="classnames-라이브러리"><a href="#classnames-라이브러리" class="headerlink" title="classnames 라이브러리"></a>classnames 라이브러리</h3><p>classnames 라이브러리는 CSS 클래스를 조건부로 설정할 때 매우 유용한 라이브러리입니다.</p><blockquote><p>npm으로 설치 시 : npm install classnames<br>yarn으로 설치 시 : yarn add classnames</p></blockquote><p>classnames의 기본적인 사용법을 살펴봅니다.</p><figure class="highlight jsx"><figcaption><span>classnames 기본적인 사용법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">'classnames'</span>;</span><br><span class="line"></span><br><span class="line">classNames(<span class="string">'one'</span>, <span class="string">'two'</span>); <span class="comment">// = 'one two'</span></span><br><span class="line">classNames(<span class="string">'one'</span>, &#123; <span class="attr">two</span> : <span class="literal">true</span> &#125;); <span class="comment">// = 'one two'</span></span><br><span class="line">classNames(<span class="string">'one'</span>, &#123; <span class="attr">two</span> : <span class="literal">false</span> &#125;); <span class="comment">// = 'one'</span></span><br><span class="line">classNames(<span class="string">'one'</span>, [<span class="string">'two'</span>, <span class="string">'three'</span>]); <span class="comment">// = 'one two three'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myClass = <span class="string">'hello'</span>;</span><br><span class="line">classNames(<span class="string">'one'</span>, myClass, &#123; <span class="attr">myCondition</span>: <span class="literal">true</span> &#125;); <span class="comment">// = 'one hello myCondition'</span></span><br></pre></td></tr></table></figure><p>이런 식으로 여러 가지 종류의 파라미터를 조합해 CSS 클래스를 설정할 수 있기 때문에 컴포넌트에서 조건부로 클래스를 설정할 때 매우 편합니다. 예를 들어 props 값에 따라 다른 스타일을 주기 편합니다.</p><figure class="highlight jsx"><figcaption><span>예시 코드</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// classnames 등의 라이브러리 도움없이 작성한다면</span></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">&#123; highlighted, theme &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div className =&#123;<span class="string">`MyComponent <span class="subst">$&#123;theme&#125;</span> <span class="subst">$&#123;highlighted ? <span class="string">'highlighted'</span> : <span class="string">''</span>&#125;</span>`</span>&#125;&gt;</span><br><span class="line">    Hello</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ classnames 라이브러리 사용 시</span></span><br><span class="line"><span class="regexp">const MyComponent = (&#123; highlighted, theme &#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;div className =&#123;classNames('MyComponent', &#123;highlighted&#125;, theme)&#125;&gt;</span></span><br><span class="line"><span class="regexp">    Hello</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>classnames 라이브러리 사용 시 엘리먼트의 클래스에 highlighted 값이 true이면 highlighted 클래스가 적용되고, false이면 적용되지 않습니다. 추가로 theme으로 전달받는 문자열은 내용 그대로 클래스에 적용됩니다.</p><ul><li>classnames 라이브러리는 CSS Module과 함께 사용하면 CSS Module 사용이 훨씬 쉬워집니다.</li></ul><p>classnames에 내장되어 있는 <code>bind</code> 함수를 사용하면 클래스를 넣어 줄 때마다 <code>styles.[클래스 이름]</code> 형태를 사용할 필요가 없습니다. </p><p>사전에 미리 styles에서 받아 온 후 사용하게 설정해 주고 <code>cx(&#39;클래스 이름1&#39;, &#39;클래스 이름2&#39;)</code> 형태로 사용할 수 있습니다.</p><figure class="highlight jsx"><figcaption><span>CSSModule 컴포넌트에 classnames의 bind 함수 적용한 예</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">'classnames/bind'</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./CSSModule.module.scss'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cx = classNames.bind(styles); <span class="comment">// 미리 styles 에서 클래스를 받아오도록 설정하고</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CSSModule = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;cx(<span class="string">'wrapper'</span>, <span class="string">'inverted'</span>)&#125;&gt;</span><br><span class="line">      안녕하세요, 저는 &lt;span className=<span class="string">"something"</span>&gt;CSS Module!&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> CSSModule;</span><br></pre></td></tr></table></figure><p>classnames의 bind를 사용하여 CSS Module을 사용할 때 클래스를 여러 개 설정하거나, 조건부로 클래스를 설정할 때 편리하게 작성할 수 있습니다.</p><hr><h2 id ="styled-components">styled-components</h2><p>컴포넌트 스타일링 중 <strong>자바스크립트 파일 안에 스타일을 선언하는 방식</strong>을 <code>CSS-in-JS</code>라고 부릅니다.</p><ul><li>CSS-in-JS 라이브러리 종류 (<a href="https://github.com/MicheleBertoli/css-in-js">https://github.com/MicheleBertoli/css-in-js</a>)</li></ul><p><code>styled-components</code> 는 ‘CSS-in-JS’ 라이브러리 중에서 개발자들이 가장 선호하는 라이브러리입니다.</p><blockquote><p>npm 으로 설치 시 : npm i styled-components<br>yarn 으로 설치 시 : yarn add styled-components</p></blockquote><p>styled-components를 사용하면 자바스크립트 파일 하나에 스타일까지 작성할 수 있기 때문에<br>별도의 스타일 파일을 만들지 않아도 된다는 이점이 있습니다.</p><p>styled-components를 사용한 예제 코드를 작성해 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>styled-components</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> styled, &#123; css &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Box = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  /* props 로 넣어준 값을 직접 전달해줄 수 있습니다. */</span></span><br><span class="line"><span class="string">  background: <span class="subst">$&#123;(props) =&gt; props.color || <span class="string">'blue'</span>&#125;</span>;</span></span><br><span class="line"><span class="string">  padding: 1rem;</span></span><br><span class="line"><span class="string">  display: flex;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  background: white;</span></span><br><span class="line"><span class="string">  color: black;</span></span><br><span class="line"><span class="string">  border-radius: 4px;</span></span><br><span class="line"><span class="string">  padding: 0.5rem;</span></span><br><span class="line"><span class="string">  display: flex;</span></span><br><span class="line"><span class="string">  align-items: center;</span></span><br><span class="line"><span class="string">  justify-content: center;</span></span><br><span class="line"><span class="string">  box-sizing: border-box;</span></span><br><span class="line"><span class="string">  font-size: 1rem;</span></span><br><span class="line"><span class="string">  font-weight: 600;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /* &amp; 문자를 사용하여 Sass 처럼 자기 자신 선택 가능 */</span></span><br><span class="line"><span class="string">  &amp;:hover &#123;</span></span><br><span class="line"><span class="string">    background: rgba(255, 255, 255, 0.9);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /* 다음 코드는 inverted 값이 true 일 때 특정 스타일을 부여해줍니다. */</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;props =&gt;</span></span></span><br><span class="line"><span class="string"><span class="subst">    props.inverted &amp;&amp;</span></span></span><br><span class="line"><span class="string"><span class="subst">    css`</span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">      <span class="selector-tag">background</span>: <span class="selector-tag">none</span>;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">      <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">white</span>;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">      <span class="selector-tag">color</span>: <span class="selector-tag">white</span>;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">      &amp;<span class="selector-pseudo">:hover</span> &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-tag">white</span>;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-tag">black</span>;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">      &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">    `</span>&#125;</span>;</span></span><br><span class="line"><span class="string">  &amp; + button &#123;</span></span><br><span class="line"><span class="string">    margin-left: 1rem;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StyledComponent = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Box color=<span class="string">"black"</span>&gt;</span><br><span class="line">    &lt;Button&gt;안녕하세요&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Button inverted=&#123;true&#125;&gt;테두리만&lt;/</span>Button&gt;</span><br><span class="line">  &lt;<span class="regexp">/Box&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default StyledComponent;</span></span><br></pre></td></tr></table></figure><p>styled-components의 가장 큰 장점은 props 값으로 전달해 주는 값을 쉽게 스타일에 적용할 수 있다는 것입니다.</p><hr><h3 id="Tagged-템플릿-리터럴"><a href="#Tagged-템플릿-리터럴" class="headerlink" title="Tagged 템플릿 리터럴"></a>Tagged 템플릿 리터럴</h3><p>스타일을 작성할 때 ` 을 사용하여 만든 문자열에 스타일 정보를 넣어 주었습니다.<br>여기서 사용한 문법을 Tagged 템플릿 리터럴 이라고 부릅니다.</p><p><mark>CSS Module을 배울 때 나온 일반 템플릿 리터럴과 다른 점은 템플릿 안에 자바스크립트 객체나 함수를 전달 할 때 리터럴 안에 넣어준 값을 알아낼 수 있다는 것입니다.</mark></p><figure class="highlight jsx"><figcaption><span>일반 템플릿 리터럴</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`hello <span class="subst">$&#123;&#123;foo: <span class="string">'bar'</span> &#125;</span>&#125; <span class="subst">$&#123;() =&gt; <span class="string">'world'</span>&#125;</span>!`</span></span><br><span class="line"><span class="comment">// 결과: "hello [object Object] () =&gt; 'world'!"</span></span><br></pre></td></tr></table></figure><p>위 코드는 [object Object] 이런식으로 문자열로 들어가게되면서 형태를 잃어버리게 되는데요,<br>만약에 함수를 다음과 같이 만들어서 사용하면 이 템플릿 리터럴 안에 넣어준 값들을 온전히 알아낼 수 있게 됩니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tagged</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">tagged<span class="string">`hello <span class="subst">$&#123;&#123;foo: <span class="string">'bar'</span> &#125;</span>&#125; <span class="subst">$&#123;() =&gt; <span class="string">'world'</span>&#125;</span>!`</span></span><br><span class="line"><span class="comment">// (3) [Array(3), &#123;…&#125;, ƒ]</span></span><br><span class="line"><span class="comment">//   0: (3) ["hello ", " ", "!", raw: Array(3)]</span></span><br><span class="line"><span class="comment">//   1: &#123;foo: "bar"&#125;</span></span><br><span class="line"><span class="comment">//   2: () =&gt; 'world'</span></span><br></pre></td></tr></table></figure><p>styled-components는 이러한 속성을 사용하여 styled-components로 만든 컴포넌트의 props를 스타일 쪽에서 쉽게 조회할 수 있게 해줍니다.</p><hr><h3 id="스타일링-된-엘리먼트-만들기"><a href="#스타일링-된-엘리먼트-만들기" class="headerlink" title="스타일링 된 엘리먼트 만들기"></a>스타일링 된 엘리먼트 만들기</h3><p>스타일링 된 엘리먼트를 만들 땐, 상단에서 styled 를 불러오고 styled.태그명 을 사용하여 구현합니다:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  font-size: 2rem;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>이렇게 <code>styled.div</code> 뒤에 Tagged 템플릿 리터럴 문법을 통해 스타일을 넣어 주면, </p><p>해당 스타일이 적용된 div로 이루어진 리액트 컴포넌트가 생성됩니다.</p><p>그래서 나중에 <code>&lt;MyComponent&gt;</code>Hello<code>&lt;/MyComponent&gt;</code>와 같은 형태로 사용할 수 있습니다.</p><p><code>.div</code> 자리에 button 이던, input 이던, 원하는걸 넣으시면 됩니다.</p><p>하지만, 만약에 보여줘야 할 태그 형식이 유동적이거나,<br>특정 컴포넌트에 스타일링을 해야 하는 상황이라면 다음과 같은 형태로 구현 할 수 있습니다</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열로 styled 의 인자로 전달</span></span><br><span class="line"><span class="keyword">const</span> MyInput = styled(<span class="string">'input'</span>)<span class="string">`</span></span><br><span class="line"><span class="string">  background: gray;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="comment">// 아예 컴포넌트 형식의 값을 넣어줌</span></span><br><span class="line"><span class="keyword">const</span> StyledLink = styled(Link)<span class="string">`</span></span><br><span class="line"><span class="string">  color: blue;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><hr><h3 id="스타일에서-props-조회하기"><a href="#스타일에서-props-조회하기" class="headerlink" title="스타일에서 props 조회하기"></a>스타일에서 props 조회하기</h3><p>styled-components를 사용하면 스타일링 한 컴포넌트에 전달하는 props 값을 스타일쪽에서 그대로 사용할 수 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Box = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  /* props 로 넣어준 값을 직접 전달해줄 수 있습니다. */</span></span><br><span class="line"><span class="string">  background: <span class="subst">$&#123;props =&gt; props.color || <span class="string">'blue'</span>&#125;</span>;</span></span><br><span class="line"><span class="string">  padding: 1rem;</span></span><br><span class="line"><span class="string">  display: flex;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>background 값에 props를 조회해서 props.color의 값을 사용하게 하고 color 값이 주어지지 않았을 때는 blue를 기본 색상으로 설정했습니다.</p><p>이렇게 만들어진 코드는 JSX에서 사용될 때 다음과 같이 color 값을 props로 사용할 수 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Box color=<span class="string">"black"</span>&gt;(...)&lt;<span class="regexp">/Box&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="props-에-따른-조건부-스타일링"><a href="#props-에-따른-조건부-스타일링" class="headerlink" title="props 에 따른 조건부 스타일링"></a>props 에 따른 조건부 스타일링</h3><p>일반 CSS 클래스를 사용했더라면 주로 클래스이름으로 조건부 스타일링을 해왔었을텐데요,<br>styled-components 에서는 그냥 props 로도 처리 가능합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styled, &#123; css &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span>;</span><br><span class="line"><span class="comment">/* 단순 변수의 형태가 아니라 여러줄의 스타일 구문을 조건부로 설정해야 하는 경우엔</span></span><br><span class="line"><span class="comment">css 를 불러와야합니다. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  background: white;</span></span><br><span class="line"><span class="string">  color: black;</span></span><br><span class="line"><span class="string">  border-radius: 4px;</span></span><br><span class="line"><span class="string">  padding: 0.5rem;</span></span><br><span class="line"><span class="string">  display: flex;</span></span><br><span class="line"><span class="string">  align-items: center;</span></span><br><span class="line"><span class="string">  justify-content: center;</span></span><br><span class="line"><span class="string">  box-sizing: border-box;</span></span><br><span class="line"><span class="string">  font-size: 1rem;</span></span><br><span class="line"><span class="string">  font-weight: 600;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /* &amp; 문자를 사용하여 Sass 처럼 자기 자신 선택 가능 */</span></span><br><span class="line"><span class="string">  &amp;:hover &#123;</span></span><br><span class="line"><span class="string">    background: rgba(255, 255, 255, 0.9);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /* 다음 코드는 inverted 값이 true 일 때 특정 스타일을 부여해줍니다. */</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;props =&gt;</span></span></span><br><span class="line"><span class="string"><span class="subst">    props.inverted &amp;&amp;</span></span></span><br><span class="line"><span class="string"><span class="subst">    css`</span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">      <span class="selector-tag">background</span>: <span class="selector-tag">none</span>;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">      <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">white</span>;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">      <span class="selector-tag">color</span>: <span class="selector-tag">white</span>;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">      &amp;<span class="selector-pseudo">:hover</span> &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-tag">white</span>;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-tag">black</span>;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">      &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="css">    `</span>&#125;</span>;</span></span><br><span class="line"><span class="string">  &amp; + button &#123;</span></span><br><span class="line"><span class="string">    margin-left: 1rem;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>이렇게 만든 컴포넌트는 다음과 같이 props를 사용하여 서로 다른 스타일을 적용할 수 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button&gt;안녕하세요&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">&lt;Button inverted=&#123;ture&#125;&gt;테두리만&lt;/</span>Button&gt;</span><br></pre></td></tr></table></figure><p>CSS를 사용하지 않고 다음과 같이 바로 문자열을 넣어도 작동하기는 합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$&#123;props =&gt;</span><br><span class="line">    props.inverted &amp;&amp;</span><br><span class="line">    css`</span><br><span class="line"><span class="css">      <span class="selector-tag">background</span>: <span class="selector-tag">none</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">white</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">color</span>: <span class="selector-tag">white</span>;</span></span><br><span class="line"><span class="css">      &amp;<span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-tag">white</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-tag">black</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    `</span>&#125;;</span><br><span class="line">  &amp; + button &#123;</span><br><span class="line">    margin-left: <span class="number">1</span>rem;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="string">`;</span></span><br></pre></td></tr></table></figure><p>이렇게 CSS를 제외하고 작성하면 Tagged 템플릿 리터럴이 아니기 때문에 함수를 받아 사용하지 못해 해당 부분에서는 props 값을 사용하지 못합니다.</p><hr><h3 id="반응형-디자인"><a href="#반응형-디자인" class="headerlink" title="반응형 디자인"></a>반응형 디자인</h3><p>styled-components를 사용할 때 반응형 디자인을 어떻게 하는지 알아봅니다.</p><p>우선 브라우저의 가로 크기에 따라 다른 스타일을 적용하기 위해선 일반 CSS를 사용할 때와 똑같이 media 쿼리(query)를 사용하면 됩니다.</p><figure class="highlight jsx"><figcaption><span>StyledComponent.js - box</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Box = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  /* props 로 넣어준 값을 직접 전달해줄 수 있습니다. */</span></span><br><span class="line"><span class="string">  background: <span class="subst">$&#123;props =&gt; props.color || <span class="string">'blue'</span>&#125;</span>;</span></span><br><span class="line"><span class="string">  padding: 1rem;</span></span><br><span class="line"><span class="string">  display: flex;</span></span><br><span class="line"><span class="string">  /* 기본적으로는 1024px 에 가운데 정렬을 하고</span></span><br><span class="line"><span class="string">    가로 크기가 작아짐에 따라 사이즈를 줄이고</span></span><br><span class="line"><span class="string">    768px 미만으로 되면 꽉 채웁니다 */</span></span><br><span class="line"><span class="string">  width: 1024px;</span></span><br><span class="line"><span class="string">  margin: 0 auto;</span></span><br><span class="line"><span class="string">  @media (max-width: 1024px) &#123;</span></span><br><span class="line"><span class="string">    width: 768px;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  @media (max-width: 768px) &#123;</span></span><br><span class="line"><span class="string">    width: 100%;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>일반 CSS에서와 큰차이가 없습니다.</p><p>만약 여러 컴포넌트에서 이작업을 반복해야 한다면 함수화하여 간편하게 사용할 수 있습니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> styled, &#123; css &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sizes = &#123;</span><br><span class="line">  desktop: <span class="number">1024</span>,</span><br><span class="line">  tablet: <span class="number">768</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 위에있는 size 객체에 따라 자동으로 media 쿼리 함수를 만들어줍니다.</span></span><br><span class="line"><span class="comment">// 참고: https://www.styled-components.com/docs/advanced#media-templates</span></span><br><span class="line"><span class="keyword">const</span> media = <span class="built_in">Object</span>.keys(sizes).reduce(<span class="function">(<span class="params">acc, label</span>) =&gt;</span> &#123;</span><br><span class="line">  acc[label] = <span class="function">(<span class="params">...args</span>) =&gt;</span> css`</span><br><span class="line"><span class="css">    <span class="keyword">@media</span> (<span class="attribute">max-width:</span> </span><span class="subst">$&#123;sizes[label] <span class="regexp">/ 16&#125;em) &#123;</span></span></span><br><span class="line"><span class="subst"><span class="regexp">      $&#123;css(...args)&#125;;</span></span></span><br><span class="line"><span class="subst"><span class="regexp">    &#125;</span></span></span><br><span class="line"><span class="subst"><span class="regexp">  `;</span></span></span><br><span class="line"><span class="subst"><span class="regexp"></span></span></span><br><span class="line"><span class="subst"><span class="regexp">  return acc;</span></span></span><br><span class="line"><span class="subst"><span class="regexp">&#125;, &#123;&#125;);</span></span></span><br><span class="line"><span class="subst"><span class="regexp"></span></span></span><br><span class="line"><span class="subst"><span class="regexp">const Box = styled.div`</span></span></span><br><span class="line"><span class="subst"><span class="regexp">  /</span>* props 로 넣어준 값을 직접 전달해줄 수 있습니다. *<span class="regexp">/</span></span></span><br><span class="line"><span class="subst"><span class="regexp">  background: $&#123;props =&gt; props.color || 'blue'&#125;;</span></span></span><br><span class="line"><span class="subst"><span class="regexp">  padding: 1rem;</span></span></span><br><span class="line"><span class="subst"><span class="regexp">  display: flex;</span></span></span><br><span class="line"><span class="subst"><span class="regexp">  width: 1024px;</span></span></span><br><span class="line"><span class="subst"><span class="regexp">  margin: 0 auto;</span></span></span><br><span class="line"><span class="subst"><span class="regexp">  $&#123;media.desktop`width: 768px;`&#125;</span></span></span><br><span class="line"><span class="subst"><span class="regexp">  $&#123;media.tablet`width: 768px;`&#125;;</span></span></span><br><span class="line"><span class="subst"><span class="regexp">`;</span></span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/06/07/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81-%EB%B0%A9%EC%8B%9D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hooks</title>
      <link>https://hdw0903.github.io/2020/06/03/Hooks/</link>
      <guid>https://hdw0903.github.io/2020/06/03/Hooks/</guid>
      <pubDate>Wed, 03 Jun 2020 09:23:21 GMT</pubDate>
      <description>
      
        &lt;p&gt;Hooks는 리액트 v16.8에 새로 도입된 기능으로 &lt;strong&gt;함수형 컴포넌트에서도 상태 관리&lt;/strong&gt;를 할 수 있는 useState, useEffect등의 기능을 제공합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/03/Hooks/#useState&quot;&gt;useState&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/03/Hooks/#useEffect&quot;&gt;useEffect&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/03/Hooks/#useReducer&quot;&gt;useReducer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/03/Hooks/#useMemo&quot;&gt;useMemo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/03/Hooks/#useCallback&quot;&gt;useCallback&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/03/Hooks/#useRef&quot;&gt;useRef&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/03/Hooks/#커스텀_Hooks&quot;&gt;커스텀 Hooks 만들기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/03/Hooks/#Hooks_Link&quot;&gt;다른 개발자가 만든 Hooks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Hooks는 리액트 v16.8에 새로 도입된 기능으로 <strong>함수형 컴포넌트에서도 상태 관리</strong>를 할 수 있는 useState, useEffect등의 기능을 제공합니다.</p><ul><li><a href="/2020/06/03/Hooks/#useState">useState</a></li><li><a href="/2020/06/03/Hooks/#useEffect">useEffect</a></li><li><a href="/2020/06/03/Hooks/#useReducer">useReducer</a></li><li><a href="/2020/06/03/Hooks/#useMemo">useMemo</a></li><li><a href="/2020/06/03/Hooks/#useCallback">useCallback</a></li><li><a href="/2020/06/03/Hooks/#useRef">useRef</a></li><li><a href="/2020/06/03/Hooks/#커스텀_Hooks">커스텀 Hooks 만들기</a></li><li><a href="/2020/06/03/Hooks/#Hooks_Link">다른 개발자가 만든 Hooks</a></li></ul><a id="more"></a><hr><h2 id="useState">useState</h2><p>useState는 가장 기본적인 Hooks이며, 함수형 컴포넌트에서도 가변적인 상태를 지닐 수 있게 해줍니다.</p><p>useState 기능을 사용하여 숫자 카운터를 구현해 봅니다.</p><figure class="highlight jsx"><figcaption><span>Counter.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        현재 카운터 값은 &lt;b&gt;&#123;value&#125;&lt;<span class="regexp">/b&gt;입니다.</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setValue(value + <span class="number">1</span>)&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setValue(value - 1)&#125;&gt;-1&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Counter;</span></span><br></pre></td></tr></table></figure><p>useState는 코드 상단에서 import 구문으로 불러오고 다음과 같이 사용합니다.</p><figure class="highlight jsx"><figcaption><span>useState</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [value, setValue] = useState(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>useState 함수의 파라미터에는 상태의 기본값을 넣어 줍니다. (카운터의 기본값을 0으로 잡음)</li></ul><ul><li><strong>useState 함수가 호출되면 배열을 반환하고, 배열의 첫 번째 요소는 상태값, 두 번째 요소는 상태를 설정하는 함수입니다.</strong></li></ul><ul><li>useState() 함수를 호출하면 파라미터로 넘긴 값으로 값이 바뀌고 컴포넌트가 리렌더링됩니다.</li></ul><hr><h3 id="useState-여러-상태-값-관리"><a href="#useState-여러-상태-값-관리" class="headerlink" title="useState 여러 상태 값 관리"></a>useState 여러 상태 값 관리</h3><p>하나의 useState 함수는 하나의 상태 값만 관리할 수 있습니다.</p><p>컴포넌트에서 상태를 관리해야할 대상이 여러 개라면 useState를 여러번 사용해야 합니다.</p><figure class="highlight jsx"><figcaption><span>info.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Info = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [nickname, setNickname] = useState(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onChangeName = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    setName(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onChangeNickname = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    setNickname(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input value=&#123;name&#125; onChange=&#123;onChangeName&#125;&gt;&lt;<span class="regexp">/input&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input value=&#123;nickname&#125; onChange=&#123;onChangeNickname&#125;&gt;&lt;/i</span>nput&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;b&gt;이름:&lt;/</span>b&gt;</span><br><span class="line">          &#123;name&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;b&gt;닉네임:&lt;/</span>b&gt;</span><br><span class="line">          &#123;nickname&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Info;</span></span><br></pre></td></tr></table></figure><p>관리할 상태가 2개인 (이름, 닉네임) 예시입니다. useState도 마찬가지로 2개를 사용하여 관리해줬습니다.</p><hr><h2 id="useEffect">useEffect</h2><p><mark>useEffect는 리액트 컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정해 주는 Hooks 입니다.</mark></p><p>클래스형 컴포넌트의 <code>componentDidMount</code> 와 <code>componentDidUpdate</code>를 합친 형태와 비슷합니다.</p><p>위에 만든 Info 컴포넌트에 useEffect를 적용해 봅니다.</p><figure class="highlight jsx"><figcaption><span>Info.js - useEffect</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Info = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [nickname, setNickname] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="comment">//useEffect</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'렌더링이 완료되었습니다!'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(&#123; name, nickname &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> onChangeName = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    setName(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onChangeNickname = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    setNickname(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input value=&#123;name&#125; onChange=&#123;onChangeName&#125;&gt;&lt;<span class="regexp">/input&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input value=&#123;nickname&#125; onChange=&#123;onChangeNickname&#125;&gt;&lt;/i</span>nput&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;b&gt;이름:&lt;/</span>b&gt;</span><br><span class="line">          &#123;name&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;b&gt;닉네임:&lt;/</span>b&gt;</span><br><span class="line">          &#123;nickname&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Info;</span></span><br></pre></td></tr></table></figure><p>컴포넌트가 렌더링될 때마다 <code>&#39;렌더링이 완료되었습니다!&#39;</code> 문구와 <code>name</code>, <code>nickname</code> 값을 출력합니다.<br>개발자도구의 콘솔창에서 확인할 수 있습니다.</p><hr><h3 id="마운트될-때만-실행하고-싶을-때"><a href="#마운트될-때만-실행하고-싶을-때" class="headerlink" title="마운트될 때만 실행하고 싶을 때"></a>마운트될 때만 실행하고 싶을 때</h3><p><strong>useEffect에서 설정한 함수를 컴포넌트가 화면에 맨 처음 렌더링될 때만 실행</strong>하고, </p><p>업데이트 때는 실행하고 싶지 않다면 </p><p><strong>함수의 두 번째 파라미터로 빈 배열 []을 넣어 주면 됩니다.</strong></p><figure class="highlight jsx"><figcaption><span>info.js - useEffect 마운트될 때만 실행</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect (<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'마운트될 때만 실행됩니다.'</span>)</span><br><span class="line">&#125;, [] ); <span class="comment">// 두 번째 파라미터에 []</span></span><br></pre></td></tr></table></figure><p>위와 같이 수정해주면 컴포넌트가 맨 처음 렌더링될 때만 콘솔에 <code>&#39;마운트될 때만 실행됩니다&#39;</code> 문구가 출력되고 그 이후에는 나타나지 않습니다.</p><hr><h3 id="특정-값이-변경될-때만-실행"><a href="#특정-값이-변경될-때만-실행" class="headerlink" title="특정 값이 변경될 때만 실행"></a>특정 값이 변경될 때만 실행</h3><p>특정 값이 업데이트될 때만 실행하고 싶은 경우</p><p>클래스형 컴포넌트라면 다음과 같이 작성할 것입니다.</p><figure class="highlight jsx"><figcaption><span>클래스형 컴포넌트 componentDidUpdate</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate (prevProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevProps.value !== <span class="keyword">this</span>.props.value) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>props의 value 값이 변할 때 마다 특정 함수를 실행하는 클래스형 컴포넌트에서의 예시입니다.</p><p><strong>useEffect를 사용하여 작성하려면 두 번째 파라미터에 검사하고 싶은 값을 []로 감싸 넣어 주면 됩니다.</strong></p><figure class="highlight jsx"><figcaption><span>info - useEffect</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//두 번째 파라미터에 검사하고 싶은 값을 작성</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;, [name] );</span><br></pre></td></tr></table></figure><p>이렇게 작성하면 name 값을 검사하여 name 값이 변경되지 않으면 실행되지 않습니다.</p><p>배열 안에는 useState로 관리하고 있는 상태를 넣어줘도 되고, props로 전달받은 값을 넣어줘도 됩니다.</p><p><mark>useEffect는 기본적으로 렌더링이되고 난 직후마다 실행되며, 두 번째 파라미터 배열에 무엇을 넣는지에 따라 실행되는 조건이 달라집니다.</mark></p><hr><h3 id="뒷정리-함수"><a href="#뒷정리-함수" class="headerlink" title="뒷정리 함수"></a>뒷정리 함수</h3><p>컴포넌트가 언마운트되기 전이나 업데이트되기 직전에 어떠한 작업을 수행하고 싶다면 useEffect에서 뒷정리(cleanup)함수를 반환해 줘야 합니다.</p><ul><li>App 컴포넌트에서 Info 컴포넌트의 가시성을 바꿀수 있게 하는 예제<figure class="highlight jsx"><figcaption><span>info.js - useEffect</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'effect'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'cleanup'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li></ul><p>Info 컴포넌트의 useEffect 부분을 위와 같이 수정하고</p><p>이제 App 컴포넌트에서 Info 컴포넌트의 가시성을 바꿀 수 있게 해봅니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">App.js</span><br><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Info <span class="keyword">from</span> <span class="string">'./info'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [visible, setVisible] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; &#123;</span><br><span class="line">          setVisible(!visible);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;visible ? <span class="string">'숨기기'</span> : <span class="string">'보이기'</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;hr /</span>&gt;</span><br><span class="line">      &#123;visible &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Info</span> /&gt;</span></span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>브라우저에서 보이기/숨기기 버튼을 눌러보면</p><p>컴포넌트가 나타날 때 useEffect 함수가 실행되어 콘솔에 effect가 출력되고, 사라질 때 뒷정리 함수가 호출되어 cleanup이 출력됩니다.</p><p>인풋에 작성해보면 콘솔에 렌더링될 때마다 뒷정리 함수가 계속 나타나는 것을 확인할 수 있습니다.</p><p><strong>뒷정리 함수가 호출될 때는 업데이트 직전의 값을 보여 줍니다.</strong></p><hr><h2 id="useReducer">useReducer</h2><p><code>useReducer</code>는 컴포넌트 상황에 따라 다양한 상태를 다른 값으로 업데이트 해줄 때 사용하는 Hook입니다.</p><p>리듀서는 현재 상태, 업데이트를 위해 필요한 정보를 담은 액션(action) 값을 전달받아 새로운 상태를 반환하는 함수입니다.</p><p><mark>리듀서 함수에서 새로운 상태를 만들 때는 반드시 불변성을 지켜줘야합니다.</mark></p><figure class="highlight jsx"><figcaption><span>리듀서</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;...&#125; <span class="comment">// 불변성을 지키면서 업데이트한 새로운 상태를 반환</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 액션 값은 주로 다음과 같은 형태로 이루어져 있습니다.</span></span><br><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'INCREMENT'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>리덕스</code>에서 사용하는 액션 객체는 어떤 액션인지 알려주는 type 필드가 꼭 필요하지만,<br><code>useReducer</code>에서 사용하는 액션 객체는 객체가 아니라 문자열, 숫자여도 상관없고 반드시 type을 지니고 있을 필요도 없습니다.</p><hr><h3 id="카운터-구현"><a href="#카운터-구현" class="headerlink" title="카운터 구현"></a>카운터 구현</h3><p>useReducer를 사용하여 Counter 컴포넌트를 구현해봅니다.</p><figure class="highlight jsx"><figcaption><span>Counter.js -useReducer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//action.type에 따라 다른 작업 수행</span></span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'INCREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">value</span>: state.value + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DECREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">value</span>: state.value - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        현재 카운터 값은 &lt;b&gt;&#123;state.value&#125;&lt;<span class="regexp">/b&gt;입니다.</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'DECREMENT' &#125;)&#125;&gt;-1&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Counter;</span></span><br></pre></td></tr></table></figure><p>useReducer 함수의 첫 번째 파라마터에는 리듀서 함수를 넣고, 두 번째 파라미터에는 해당 리듀서의 기본값을 넣어줍니다.</p><p>이 useReducer Hook을 사용하면 <code>state</code> 값과 <code>dispatch</code> 함수를 받아옵니다.</p><p>state는 현재 가리키는 상태이고, dispatch는 액션을 발생시키는 함수입니다.<br>dispatch(action)과 같은 형태로, 함수 안에 파라미터로 액션 값을 넣어 주면 리듀서 함수가 호출되는 구조입니다.</p><p>useReducer를 사용했을 때 가장 큰 장점은 컴포넌트 업데이트 로직을 컴포넌트 바깥으로 빼낼 수 있다는 점입니다.</p><p>App 컴포넌트에서 Counter를 렌더링해주고 브라우저에서 실행시 카운터가 잘 작동합니다.</p><hr><h3 id="input-상태-관리"><a href="#input-상태-관리" class="headerlink" title="input 상태 관리"></a>input 상태 관리</h3><p>input이 여러 개 일때 상태 관리하려면 useState를 여러 개 사용해 줬었습니다.</p><p>이번에는 useReducer를 사용하여 Info 컴포넌트에서 input 상태 관리를 해봅니다.</p><p>useReducer를 사용하면 클래스형 컴포넌트에서 input 태그에 name 값을 할당하고 e.target.name을 참조하여 setState 해 준 것과 유사한 방식으로 처리할 수 있습니다.</p><figure class="highlight jsx"><figcaption><span>Info.js -useReducer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...state,</span><br><span class="line">    [action.name]: action.value,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Info = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, &#123; <span class="attr">name</span>: <span class="string">''</span>, <span class="attr">nickname</span>: <span class="string">''</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> &#123; name, nickname &#125; = state;</span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(e.target);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input name=<span class="string">"name"</span> value=&#123;name&#125; onChange=&#123;onChange&#125;&gt;&lt;<span class="regexp">/input&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input name="nickname" value=&#123;nickname&#125; onChange=&#123;onChange&#125;&gt;&lt;/i</span>nput&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;b&gt;이름:&lt;/</span>b&gt;</span><br><span class="line">          &#123;name&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;b&gt;닉네임:&lt;/</span>b&gt;</span><br><span class="line">          &#123;nickname&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Info;</span></span><br></pre></td></tr></table></figure><p>useReducer에서의 액션은 그 어떤 값도 사용 가능합니다. (이번에는 이벤트 객체가 가지고 있는 e.target 값 자체가 액션 값으로 사용되었습니다.)</p><p>이런 식으로 input을 관리하면 input 개수가 많아져도 코드를 짧고 깔끔하게 유지할 수 있습니다.</p><hr><h2 id="useMemo">useMemo</h2><p>useMemo를 사용하면 함수형 컴포넌트에서 <strong>연산을 최적화</strong>할 수 있습니다.</p><p>우선 숫자를 추가하고 추가된 숫자들의 평균값을 구해주는 함수형 컴포넌트 예제를 작성해봅니다.</p><figure class="highlight jsx"><figcaption><span>Average.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getAverage = <span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'평균값 계산중..'</span>);</span><br><span class="line">  <span class="keyword">if</span> (number.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> sum = number.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">  <span class="keyword">return</span> sum / number.length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Average = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState([]);</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = useState(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    setNumber(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onInsert = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nextList = list.concat(<span class="built_in">parseInt</span>(number));</span><br><span class="line">    setList(nextList);</span><br><span class="line">    setNumber(<span class="string">''</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input value=&#123;number&#125; onChange=&#123;onChange&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onInsert&#125;&gt;등록&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;list.map((value, index) =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li key=&#123;index&#125;&gt;&#123;value&#125;&lt;/</span>li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;b&gt;평균값:&lt;/</span>b&gt;</span><br><span class="line">        &#123;getAverage(list)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Average;</span><br></pre></td></tr></table></figure><p>브라우저에서 실행해보면 숫자를 등록할 때뿐만 아니라 input 내용이 수정될 때도 getAverage 함수가 호출되는 것을 확인할 수 있습니다.</p><p><code>useMemo</code> 를 사용하면 렌더링 과정에서 특정 값이 바뀌었을 때만 연산을 실행하고, 원하는 값이 바뀌지 않았다면 이전에 연산했던 결과를 다시 사용하는 방식으로 최적화할 수 있습니다. </p><figure class="highlight jsx"><figcaption><span>Average -useMemo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useMemo &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getAverage = <span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'평균값 계산중..'</span>);</span><br><span class="line">  <span class="keyword">if</span> (number.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> sum = number.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">  <span class="keyword">return</span> sum / number.length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Average = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState([]);</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = useState(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    setNumber(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onInsert = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nextList = list.concat(<span class="built_in">parseInt</span>(number));</span><br><span class="line">    setList(nextList);</span><br><span class="line">    setNumber(<span class="string">''</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// useMemo 사용</span></span><br><span class="line">  <span class="keyword">const</span> avg = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> getAverage(list), [list]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input value=&#123;number&#125; onChange=&#123;onChange&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onInsert&#125;&gt;등록&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;list.map((value, index) =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li key=&#123;index&#125;&gt;&#123;value&#125;&lt;/</span>li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;b&gt;평균값:&lt;/</span>b&gt;</span><br><span class="line">        &#123;avg&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Average;</span><br></pre></td></tr></table></figure><p>useMemo 함수의 첫 번째 인자로 getAverage 함수를 넘기고, 두 번째 인자로 list prop을 사용하여 달라질 경우에만 호출하고 동일하다면 이전 결과값을 사용하게 합니다.</p><p>이제 list 배열의 내용이 바뀔 때만 getAverage 함수가 호출됩니다.</p><h3 id="useMemo-특징"><a href="#useMemo-특징" class="headerlink" title="useMemo 특징"></a>useMemo 특징</h3><ul><li><mark>useMemo가 적용된 레퍼런스는 재활용을 위해 GC에서 제외됩니다.</mark><br> 즉, 재사용을 통해 중복 연산을 줄여 성능 최적화에 많이 사용되지만, 메모리를 더 잡아먹는 점도 있습니다.</li></ul><ul><li>수 초 이상 걸리는 로직이 프론트엔드에 흔하지 않으므로 useMemo 사용할 일이 잘 없습니다.<br>있다해도 useEffect 등으로 비동기 처리하는 방안을 먼저 고려하게 됩니다.</li></ul><hr><h2 id="useCallback">useCallback</h2><p>useCallback은 useMemo와 상당히 비슷한 함수입니다.</p><p>주로 렌더링 성능을 최적화해야 하는 상황에 사용합니다. (ex 이벤트 핸들러 함수를 필요할 때만 생성)</p><p>Average 컴포넌트를 살펴보면 작성된 onChange와 onInsert라는 함수는 <strong>컴포넌트가 리렌더링될 때마다 이 함수들이 새로 생성됩니다.</strong></p><p>컴포넌트의 렌더링이 자주 발생하거나 렌더링해야 할 컴포넌트의 개수가 많아지면 이부분을 최적화해 주는 것이 좋습니다.</p><figure class="highlight jsx"><figcaption><span>useCallback</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useMemo, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getAverage = <span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'평균값 계산중..'</span>);</span><br><span class="line">  <span class="keyword">if</span> (number.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> sum = number.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">  <span class="keyword">return</span> sum / number.length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Average = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState([]);</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = useState(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onChange = useCallback(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    setNumber(e.target.value);</span><br><span class="line">  &#125;, []); <span class="comment">// 컴포넌트가 처음 렌더링될 때만 함수 생성</span></span><br><span class="line">  <span class="keyword">const</span> onInsert = useCallback(</span><br><span class="line">    (e) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> nextList = list.concat(<span class="built_in">parseInt</span>(number));</span><br><span class="line">      setList(nextList);</span><br><span class="line">      setNumber(<span class="string">''</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    [number, list]</span><br><span class="line">  ); <span class="comment">// number 혹은 list가 바뀌었을 때만 함수 생성</span></span><br><span class="line">  <span class="comment">// useMemo 사용</span></span><br><span class="line">  <span class="keyword">const</span> avg = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> getAverage(list), [list]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input value=&#123;number&#125; onChange=&#123;onChange&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onInsert&#125;&gt;등록&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;list.map((value, index) =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li key=&#123;index&#125;&gt;&#123;value&#125;&lt;/</span>li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;b&gt;평균값:&lt;/</span>b&gt;</span><br><span class="line">        &#123;avg&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Average;</span><br></pre></td></tr></table></figure><p><code>useCallback</code>의 첫 번째 파라미터에는 <u>생성하고 싶은 함수</u>를 작성하고, 두 번째 파라미터에는 배열을 작성합니다. <strong>이 배열 값에는 어떤 값이 바뀌었을 때 함수를 새로 생성해야하는지 명시합니다.</strong></p><p>onChange 처럼 빈 배열 []을 넣게 되면 컴포넌트가 렌더링될 때 단 한번만 함수가 생성되며,<br>onInsert 처럼 배열 안에 number 와 list를 넣게 되면 input내용이 바뀌거나 새로운 항목이 추가될 때마다 함수가 생성됩니다.</p><hr><h3 id="useCallback-과-useMemo"><a href="#useCallback-과-useMemo" class="headerlink" title="useCallback 과 useMemo"></a>useCallback 과 useMemo</h3><p>다음의 useCallback 과 useMemo는 완전히 같은 코드입니다.</p><figure class="highlight jsx"><figcaption><span>useCallback 과 useMemo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello world!'</span>);</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line">useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world!'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><p>useCallback은 결국 useMemo로 함수를 반환하는 상황에서 더 간단히 사용할 수 있는 Hook입니다.</p><p>숫자, 문자열, 객체 등 일반 값을 재사용하려면 useMemo를<br>함수를 재활용 하려면 useCallback을 사용합니다.</p><hr><h2 id="useRef">useRef</h2><p><strong>useRef Hook은 함수형 컴포넌트에서 ref을 쉽게 사용할 수 있게 해 줍니다.</strong></p><p>Average 컴포넌트에서 등록 버튼을 눌렀을 때 포커스가 input 쪽으로 넘어가도록 코드를 작성해 봅니다.</p><figure class="highlight jsx"><figcaption><span>Average.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useMemo, useCallback, useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getAverage = <span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'평균값 계산중..'</span>);</span><br><span class="line">  <span class="keyword">if</span> (number.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> sum = number.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">  <span class="keyword">return</span> sum / number.length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Average = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState([]);</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="comment">//useRef 사용</span></span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onChange = useCallback(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    setNumber(e.target.value);</span><br><span class="line">  &#125;, []); <span class="comment">// 컴포넌트가 처음 렌더링될 때만 함수 생성</span></span><br><span class="line">  <span class="keyword">const</span> onInsert = useCallback(</span><br><span class="line">    (e) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> nextList = list.concat(<span class="built_in">parseInt</span>(number));</span><br><span class="line">      setList(nextList);</span><br><span class="line">      setNumber(<span class="string">''</span>);</span><br><span class="line">      <span class="comment">// 실제 엘리먼트 input을 가리킴</span></span><br><span class="line">      inputEl.current.focus();</span><br><span class="line">    &#125;,</span><br><span class="line">    [number, list]</span><br><span class="line">  ); <span class="comment">// number 혹은 list가 바뀌었을 때만 함수 생성</span></span><br><span class="line">  <span class="comment">// useMemo 사용</span></span><br><span class="line">  <span class="keyword">const</span> avg = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> getAverage(list), [list]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input value=&#123;number&#125; onChange=&#123;onChange&#125; ref=&#123;inputEl&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onInsert&#125;&gt;등록&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;list.map((value, index) =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li key=&#123;index&#125;&gt;&#123;value&#125;&lt;/</span>li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;b&gt;평균값:&lt;/</span>b&gt;</span><br><span class="line">        &#123;avg&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Average;</span><br></pre></td></tr></table></figure><p>useRef을 사용하여 ref을 설정하면 useRef를 통해 만든 객체(inputEl) 안의 current 값이 실제 엘리먼트(input)를 가리킵니다.</p><blockquote><p>HTMLElement.focus(option) </p></blockquote><p>HTML 요소에 포커스를 줌</p><ul><li>option<br>preventScroll : focus를 맞춘 후 요소를 보기위해 브라우저가 스크롤 해야하는 지에 대한 boolean 값<br>기본값은 false, false는 focus를 맞춘 후 브라우저가 요소를 보기위해 스크롤 함을 의미</li></ul><hr><h3 id="로컬-변수-사용하기"><a href="#로컬-변수-사용하기" class="headerlink" title="로컬 변수 사용하기"></a>로컬 변수 사용하기</h3><p>컴포넌트 로컬 변수를 사용해야 할 때도 useRef를 활용할 수 있습니다.</p><p>여기서 로컬 변수란 렌더링과 상관없이 바뀔 수 있는 값을 의미합니다.</p><p>클래스형 컴포넌트로 작성된 로컬 변수 사용해야 할 때</p><figure class="highlight jsx"><figcaption><span>클래스형</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  id = <span class="number">1</span></span><br><span class="line">  setID = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = n</span><br><span class="line">  &#125;</span><br><span class="line">  printId = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">      Mycomponet</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><p>함수형 컴포넌트로 작성시</p><figure class="highlight jsx"><figcaption><span>함수형 컴포넌트</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RefSample = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = useRef(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> setId = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id.current);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    RefSample</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>이렇게 ref 안의 값이 바뀌어도 컴포넌트가 렌더링되지 않는다는 점을 주의하여 렌더링과 관련되지 않은 값을 관리할 때만 이러한 방식으로 코드를 작성합니다. </p><hr><h2 id="커스텀_Hooks">커스텀 Hooks 만들기</h2><p>여러 컴포넌트에서 비슷한 기능을 공유할 경우, 커스텀 Hook으로 작성하여 로직을 재사용할 수 있습니다.</p><p>useReducer로 작성했던 로직을 useInputs라는 Hook으로 따로 분리해 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>useInputs.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...state,</span><br><span class="line">    [action.name]: action.value</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useInputs</span>(<span class="params">initialForm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialForm);</span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    dispatch(e.target);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> [state, onChange];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 Hook을 info 컴포넌트에서 사용해 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>info.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> useInputs <span class="keyword">from</span> <span class="string">'./useInputs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Info = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, onChange] = useInputs(&#123;</span><br><span class="line">    name: <span class="string">''</span>,</span><br><span class="line">    nickname: <span class="string">''</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> &#123; name, nickname &#125; = state;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input name=<span class="string">"name"</span> value=&#123;name&#125; onChange=&#123;onChange&#125; /&gt;</span><br><span class="line">        &lt;input name=<span class="string">"nickname"</span> value=&#123;nickname&#125; onChange=&#123;onChange&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;b&gt;이름:&lt;/</span>b&gt; &#123;name&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;b&gt;닉네임: &lt;/</span>b&gt; &#123;nickname&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Info;</span></span><br></pre></td></tr></table></figure><hr><h2 id="Hooks_Link">다른 개발자가 만든 Hooks</h2><p>커스텀 Hooks를 만들어서 사용했던 것처럼, 다른 개발자가 만든 Hooks도 라이브러리로 설치하여 사용할 수 있습니다.</p><p>다른 개발자가 만든 다양한 Hooks 리스트</p><ul><li><a href="https://nikgraf.github.io/react-hooks/">https://nikgraf.github.io/react-hooks/</a></li><li><a href="https://github.com/rehooks/awesome-react-hooks">https://github.com/rehooks/awesome-react-hooks</a></li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/06/03/Hooks/#disqus_thread</comments>
    </item>
    
    <item>
      <title>라이프사이클 메서드</title>
      <link>https://hdw0903.github.io/2020/06/02/%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EB%A9%94%EC%84%9C%EB%93%9C/</link>
      <guid>https://hdw0903.github.io/2020/06/02/%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EB%A9%94%EC%84%9C%EB%93%9C/</guid>
      <pubDate>Tue, 02 Jun 2020 07:37:44 GMT</pubDate>
      <description>
      
        &lt;p&gt;모든 리액트 컴포넌트에는 라이프사이클(수명 주기)이 존재합니다.&lt;/p&gt;
&lt;p&gt;컴포넌트의 수명은 페이지에 렌더링되기 전인 준비 과정에서 시작하여 페이지에서 사라질 때 끝납니다.&lt;/p&gt;
&lt;p&gt;컴포넌트를 처음으로 렌더링할 때 어떤 작업을 처리하거나, 컴포넌트를 업데이트하기 전후로 어떤 작업을 처리해야 할 때 등에 컴포넌트 라이프사이클 메서드를 사용합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;라이프사이클 메서드는 클래스형 컴포넌트에서만 사용할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/02/라이프사이클-메서드/#이해&quot;&gt;라이프사이클 메서드의 이해&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/02/라이프사이클-메서드/#살펴보기&quot;&gt;라이프사이클 메서드 살펴보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/02/라이프사이클-메서드/#사용하기&quot;&gt;라이프사이클 메서드 사용하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>모든 리액트 컴포넌트에는 라이프사이클(수명 주기)이 존재합니다.</p><p>컴포넌트의 수명은 페이지에 렌더링되기 전인 준비 과정에서 시작하여 페이지에서 사라질 때 끝납니다.</p><p>컴포넌트를 처음으로 렌더링할 때 어떤 작업을 처리하거나, 컴포넌트를 업데이트하기 전후로 어떤 작업을 처리해야 할 때 등에 컴포넌트 라이프사이클 메서드를 사용합니다.</p><p><strong>라이프사이클 메서드는 클래스형 컴포넌트에서만 사용할 수 있습니다.</strong></p><ul><li><a href="/2020/06/02/라이프사이클-메서드/#이해">라이프사이클 메서드의 이해</a></li><li><a href="/2020/06/02/라이프사이클-메서드/#살펴보기">라이프사이클 메서드 살펴보기</a></li><li><a href="/2020/06/02/라이프사이클-메서드/#사용하기">라이프사이클 메서드 사용하기</a></li></ul><a id="more"></a><hr><h2 id="이해">라이프사이클 메서드의 이해</h2><p>라이프사이클 메서드의 종류는 총 아홉 가지 입니다.<br>  <code>Will</code> 접두사가 붙은 메서드는 어떤 작업을 작동하기 전에 실행되는 메서드이고<br>  <code>Did</code> 접두사가 붙은 메서드는 어떤 작업을 작동한 후에 실행되는 메서드입니다.<br>이 메서드들은 우리가 컴포넌트 클래스에 덮어 써 선언함으로 사용할 수 있습니다.</p><p>라이프사이클은 총 세 가지 : <code>마운트</code>, <code>업데이트</code>, <code>언마운트</code>로 분류할 수 있습니다.</p><p><code>마운트</code>(페이지에 컴포넌트가 나타남) -&gt; <code>업데이트</code>(리렌더링) -&gt; <code>언마운트</code>(페이지에서 컴포넌트가 사라짐)</p><hr><h3 id="마운트"><a href="#마운트" class="headerlink" title="마운트"></a>마운트</h3><p><strong>DOM이 생성되고 웹 브라우저상에 나타나는 것을 마운트(mount)라고 합니다.</strong><br>이때 호출하는 메서드는 다음과 같습니다.</p><p><img src="/images/%EB%A7%88%EC%9A%B4%ED%8A%B8.png" alt="마운트할 때 호출하는 메서드"></p><ul><li><code>constuctor</code>: 컴포넌트를 새로 만들 때마다 호출되는 클래스 생성자 메서드</li></ul><ul><li><code>getDerivedStateFromProps</code>: props에 있는 값을 state에 넣을 때 사용하는 메서드</li></ul><ul><li><code>render</code>: 준비한 UI를 렌더링하는 메서드</li></ul><ul><li><code>componentDidMount</code>: 컴포넌트가 웹 브라우저상에 나타난 후 호출하는 메서드</li></ul><hr><h3 id="업데이트"><a href="#업데이트" class="headerlink" title="업데이트"></a>업데이트</h3><p><strong>컴포넌트는 다음과 같은 총 네 가지 경우에 업데이트합니다.</strong></p><ol><li>props가 바뀔 때</li><li>state가 바뀔 때</li><li>부모 컴포넌트가 리렌더링될 때</li><li>this.forceUpdate로 강제로 렌더링을 트리거할 때</li></ol><p>이렇게 컴포넌트를 업데이트할 때는 다음 메서드를 호출합니다.</p><p><img src="/images/%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8.png" alt="업데이트할 때 호출하는 메서드"></p><ul><li><code>getDerivedStateFromProps</code>: 이 메서드는 마운트 과정에서도 호출되며, 업데이트가 시작하기 전에도 호출됩니다. props의 변화에 따라 state 값에도 변화를 주고싶을때 사용합니다.</li></ul><ul><li><code>shouldComponentUpdate</code>: 컴포넌트가 리렌더링을 해야 할지 말아야 할지 결정하는 메서드<br>이 메서드에서는 true 혹은 false 값을 반환해야 하며, true 반환시 라이프사이클 메서드를 계속 실행하고, false 반환시 작업 중지. 만약 특정 함수에서 <code>this.forceUpdate()</code>함수를 호출한다면 이 과정이 생략되고 바로 render 함수를 호출함.</li></ul><ul><li><code>render</code>: 컴포넌트 리렌더링</li></ul><ul><li><code>getSnapshotBeforeUpdate</code>: 컴포넌트 변화를 DOM에 반영하기 바로 직전에 호출하는 메서드</li></ul><ul><li><code>componentDidUpdate</code>: 컴포넌트의 업데이트 작업이 끝난 후 호출하는 메서드</li></ul><hr><h3 id="언마운트"><a href="#언마운트" class="headerlink" title="언마운트"></a>언마운트</h3><p>마운트의 반대 과정, 즉 <strong>컴포넌트를 DOM에서 제거하는 것을 언마운트(unmount)라고 합니다.</strong></p><p><img src="/images/%EC%96%B8%EB%A7%88%EC%9A%B4%ED%8A%B8.png" alt="언마운트할 때 호출하는 메서드"></p><ul><li><code>componentWillUnmount</code>: 컴포넌트가 웹 브라우저상에서 사라지기 전에 호출하는 메서드</li></ul><hr><h2 id="살펴보기">라이프사이클 메서드 살펴보기</h2><p>라이프사이클 메서드를 더 자세히 살펴봅니다.</p><hr><h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><figure class="highlight jsx"><figcaption><span>render</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;...&#125;</span><br></pre></td></tr></table></figure><p>render은 컴포넌트의 모양새를 정의합니다. 라이프사이클 메서드 중 유일한 필수 메서드입니다.</p><p>render()에서 this.props와 this.state에 접근할 수 있으며 리액트 요소를 반환합니다. (아무것도 보여 주고 싶지 않다면 null 값이나 false값을 반환하면됨)</p><ul><li>주의사항: <ul><li>render 안에서는 이벤트 설정이 아닌 곳에서 setState를 사용하면 안됨.</li><li>브라우저의 DOM에 접근해서도 안됨.</li><li>DOM 정보를 가저오거나 state에 변화를 줄 때는 componentDidMount에서 처리해야 함.</li></ul></li></ul><hr><h3 id="constuctor"><a href="#constuctor" class="headerlink" title="constuctor"></a>constuctor</h3><figure class="highlight jsx"><figcaption><span>constuctor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>컴포넌트의 생성자 메서드로 컴포넌트를 만들 때 처음으로 실행됨.<br>초기 state를 지정할 수 있음.</p><hr><h3 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h3><p>리액트 v16.3 이후에 새로 만든 라이프사이클 메서드</p><p><strong>props로 받아 온 값을 state에 동기화시키는 용도로 사용</strong></p><p>컴포넌트가 마운트될 때와 업데이트될 때 호출됩니다.</p><figure class="highlight jsx"><figcaption><span>getDerivedStateFromProps</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span>(nextProps.value !=== prevState.value) &#123; <span class="comment">// 조건에 따라 특정 값 동기화</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: nextProps.value &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// state를 변경할 필요가 없으면 null 반환</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;...&#125;</span><br></pre></td></tr></table></figure><p>컴포넌트를 만들고, 첫 렌더링을 다 마친 후 실행합니다.</p><p>자바스크립트 라이브러리, 프레임워크, 이벤트 등록, setTimeout, 네트워크 요청등의 비동기 작업을 처리할 때 사용합니다.</p><hr><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><figure class="highlight jsx"><figcaption><span>shouldComponentUpdate</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>props 또는 state를 변경했을 때, 리렌더링을 할지 여부를 지정하는 메서드.<br><code>shouldComponentUpdate</code> 메서드는 반드시 true 또는 false 값을 반환해야 하며 컴포넌트 생성시 shouldComponentUpdate 메서드를 따로 생성하지 않으면 <strong>기본적으로 true</strong> 값입니다.</p><p><code>shouldComponentUpdate</code> 메서드 안에서 props와 state는 this.props와 this.state로 접근하고, 새로 생성될 props와 state는 nextProps와 nextState로 접근할 수 있습니다.</p><p><mark>false를 반환하는 경우 업데이트 과정이 중지되기 때문에 상황에 맞게 false 값을 반환하게 하여 리렌더링을 방지함으로 프로젝트 성능을 최적화할 때 사용합니다.</mark></p><hr><h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h3><p>리액트 v16.3 이후 새로 만든 메서드</p><p><code>getSnapshotBeforeUpdate</code> 메서드는 render에서 만들어진 결과물이 <strong>브라우저에 실제로 반영되기 직전 호출됩니다.</strong></p><p>주로 업데이트 직전의 값을 참고할 일이 있을 떄 활용됩니다. (ex: 스크롤바 위치 유지)</p><ul><li>반환값을 <code>componentDidUpdate</code>의 세 번째 파라미터 <code>snapshot</code> 값으로 전달받을 수 있습니다.</li></ul><figure class="highlight jsx"><figcaption><span>getSnapshotBeforeUpdate</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span>(prevState.array !== <span class="keyword">this</span>.state.array) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; scrollTop, scrollHeight &#125; = <span class="keyword">this</span>.list</span><br><span class="line">    <span class="keyword">return</span> &#123; scrollTop, scrollHeight&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><figure class="highlight jsx"><figcaption><span>componentDidUpdate</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState, snapshot) &#123;...&#125;</span><br></pre></td></tr></table></figure><p><code>componentDidUpdate</code> 메서드는 리렌더링을 완료한 후 실행합니다.<br>업데이트가 끝난 직후이므로, DOM 관련 처리를 해도 무방합니다.<br>prevProps 또는 prevState를 사용하여 컴포넌트가 이전에 가졌던 데이터에 접근할 수 있습니다.<br>또한 <code>getSnapshotBeforeUpdate</code>에서 반환한 값이 있다면 세 번째 파라미터 <code>snapshot</code>으로 값을 전달받을 수 있습니다.</p><hr><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><figure class="highlight jsx"><figcaption><span>componentWillUnmount</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;...&#125;</span><br></pre></td></tr></table></figure><p><code>componentWillUnmount</code> 메서드는 컴포넌트를 DOM에서 제거할 때 사용합니다.<br>componentDidMount에서 등록한 이벤트, 타이머, 직접 생성한 DOM을 여기서 제거 작업합니다.</p><hr><h3 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch"></a>componentDidCatch</h3><p>리액트 v16에서 새로 도입되었습니다.</p><p><strong>컴포넌트 렌더링 도중에 에러가 발생했을 때 어플리케이션이 먹통 되지 않고 오류 UI를 보여 줄 수 있게합니다.</strong></p><p>사용 방법은 다음과 같습니다.</p><figure class="highlight jsx"><figcaption><span>componentDidCatch</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    error: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(&#123; error, info &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>파라미터 error는 어떤 에러가 밸생했는지 알려줍니다. info는 어디에 있는 코드에서 오류가 발생했는지에 대한 정보를 줍니다.</p><p>실제로 사용할 때 오류가 발생하면 <code>console.log</code>가 아니라 서버 API를 호출하여 따로 수집할 수도 있습니다.</p><p><mark>주의사항으로 componentDidCatch 메서드를 사용할 때는 컴포넌트 자신에게 발생하는 에러는 잡아낼 수 없고 자신의 this.props.children으로 전달되는 컴포넌트에서 발생하는 에러만 잡아낼 수 있는 점이 있습니다.</mark></p><hr><h2 id="사용하기">라이프사이클 메서드 사용하기</h2><p>라이프사이클 메서드 직접 사용해보기 실습</p><hr><h3 id="예제-컴포넌트-생성"><a href="#예제-컴포넌트-생성" class="headerlink" title="예제 컴포넌트 생성"></a>예제 컴포넌트 생성</h3><p>lifeCycleSample.js 컴포넌트를 만듭니다.</p><figure class="highlight jsx"><figcaption><span>lifeCycleSample.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifeCycleSample</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    number: <span class="number">0</span>,</span><br><span class="line">    color: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  myRef = <span class="literal">null</span>; <span class="comment">// ref를 설정할 부분</span></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'getDerivedStateFromProps'</span>);</span><br><span class="line">    <span class="keyword">if</span> (nextProps.color !== prevState.color) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">color</span>: nextProps.color &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'shouldComponentUpdate'</span>, nextProps, nextState);</span><br><span class="line">    <span class="comment">// 숫자의 마지막 자리가 4면 리렌더링하지 않습니다.</span></span><br><span class="line">    <span class="keyword">return</span> nextState.number % <span class="number">10</span> !== <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUnmount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      number: <span class="keyword">this</span>.state.number + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'getSnapshotBeforeUpdate'</span>);</span><br><span class="line">    <span class="keyword">if</span> (prevProps.color !== <span class="keyword">this</span>.props.color) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.myRef.style.color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>, prevProps, prevState);</span><br><span class="line">    <span class="keyword">if</span> (snapshot) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'업데이트되기 직전 색상: '</span>, snapshot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">const</span> style = &#123;</span><br><span class="line">      color: <span class="keyword">this</span>.props.color,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1 style=&#123;style&#125; ref=&#123;(ref) =&gt; (<span class="keyword">this</span>.myRef = ref)&#125;&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.state.number&#125;</span><br><span class="line">        &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;color: &#123;this.state.color&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;더하기&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> LifeCycleSample;</span><br></pre></td></tr></table></figure><p>각 라이프사이클 메서드가 실행될 때마다 콘솔에 출력하고 부모 컴포넌트에서 props로 color를 받습니다.</p><ul><li><p>getDerivedStateFromProps : 부모에게 받은 color 값을 state에 동기화 합니다.</p></li><li><p>shouldComponentUpdate : state.number 값의 마지막 자리 수가 4이면 리렌더링을 취소합니다.</p></li><li><p>handleClick : 버튼을 누르면 state.number 값을 1씩 증가시킵니다.</p></li><li><p>getSnapshotBeforeUpdate : DOM에 변화가 일어나기 직전의 color 속성을 snapshot 값으로 반환하여 componentDidUpdate에서 조회할 수 있게 했습니다.</p></li></ul><hr><h3 id="App-컴포넌트에서-예제-컴포넌트-사용"><a href="#App-컴포넌트에서-예제-컴포넌트-사용" class="headerlink" title="App 컴포넌트에서 예제 컴포넌트 사용"></a>App 컴포넌트에서 예제 컴포넌트 사용</h3><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> LifeCycleSample <span class="keyword">from</span> <span class="string">'./LifeCycleSample'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//랜덤 색상 생성</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'#'</span> + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">16777215</span>).toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    color: <span class="string">'#000000'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      color: getRandomColor(),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;랜덤 색상&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;LifeCycleSample color=&#123;this.state.color&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><ul><li><p>getRandomColor 함수는 state의 color값을 랜덤 색상으로 설정합니다.<br>16777215를 hex로 표현하면 ffffff 이므로 해당 코드는 000000~ffffff 값을 반환합니다.</p></li><li><p>버튼을 누를 때 마다 handleClick 메서드가 호출되며, 불러온 LifeCycleSample 컴포넌트에 color 값을 props로 설정합니다.</p></li></ul><hr><h3 id="에러-잡아내기"><a href="#에러-잡아내기" class="headerlink" title="에러 잡아내기"></a>에러 잡아내기</h3><p>render 함수에서 에러는 주로 존재하지 않는 함수를 사용하려고 하거나, 존재하지 않는 객체의 값을 조회할 때 발생합니다.</p><p>LifeCycleSample 컴포넌트를 수정하여 render 함수에서 의도적으로 에러를 발생시킵니다.</p><figure class="highlight jsx"><figcaption><span>LifeCycleSample</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">const</span> style = &#123;</span><br><span class="line">      color: <span class="keyword">this</span>.props.color,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.missing.value&#125;</span><br><span class="line">        &lt;h1 style=&#123;style&#125; ref=&#123;(ref) =&gt; (<span class="keyword">this</span>.myRef = ref)&#125;&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.state.number&#125;</span><br><span class="line">        &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;color: &#123;this.state.color&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;더하기&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><code>{this.props.missing.value}</code> 존재하지 않는 props인 missing 객체의 value를 조회해서 렌더링하려면 당연히 에러가 발생합니다.</p><p>사용자에게는 빈 화면만 나타나게 될 것입니다.</p><p>이럴 때 에러가 발생했다고 알려주기 위한<br>에러를 잡아주는 ErrorBoundary라는 컴포넌트를 생성해 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>ErrorBoundary.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    error: <span class="literal">false</span></span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      error: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(&#123; error, info &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.error) <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>에러가 발생했습니다!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ErrorBoundary;</span><br></pre></td></tr></table></figure><p><code>componentDidCatch</code> 메서드는 에러가 발생하면 실행되며 this.state.error 값을 true로 업데이트 해주었습니다.</p><p>render 함수에서 this.state.error 값이 true일 때 에러가 발생했음을 알리는 문구를 보여줍니다.</p><p>이제 ErrorBoundary 컴포넌트를 이용해 App.js에서 LifeCycleSample 컴포넌트를 감싸줍니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> LifeCycleSample <span class="keyword">from</span> <span class="string">'./LifeCycleSample'</span>;</span><br><span class="line"><span class="keyword">import</span> ErrorBoundary <span class="keyword">from</span> <span class="string">'./ErrorBoundary'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 랜덤 색상을 생성합니다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'#'</span> + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">16777215</span>).toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    color: <span class="string">'#000000'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      color: getRandomColor(),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;랜덤 색상&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ErrorBoundary&gt;</span></span><br><span class="line"><span class="regexp">          &lt;LifeCycleSample color=&#123;this.state.color&#125; /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/ErrorBoundary&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>이제 에러가 발생하면 “에러가 발생했습니다!” 문구가 출력됩니다.</p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/06/02/%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EB%A9%94%EC%84%9C%EB%93%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>컴포넌트 반복</title>
      <link>https://hdw0903.github.io/2020/06/01/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%B0%98%EB%B3%B5/</link>
      <guid>https://hdw0903.github.io/2020/06/01/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%B0%98%EB%B3%B5/</guid>
      <pubDate>Mon, 01 Jun 2020 10:06:36 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/01/컴포넌트-반복/#컴포넌트-배열&quot;&gt;컴포넌트 배열&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/01/컴포넌트-반복/#key&quot;&gt;key&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/01/컴포넌트-반복/#응용&quot;&gt;응용&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<ul><li><a href="/2020/06/01/컴포넌트-반복/#컴포넌트-배열">컴포넌트 배열</a></li></ul><ul><li><a href="/2020/06/01/컴포넌트-반복/#key">key</a></li></ul><ul><li><a href="/2020/06/01/컴포넌트-반복/#응용">응용</a></li></ul><a id="more"></a><hr><h2 id="컴포넌트-배열">컴포넌트 배열</h2><p>리액트 프로젝트를 작성하다 보면 반복되는 코드를 작성할 때가 있습니다.</p><ul><li>반복되는 코드 예시<figure class="highlight jsx"><figcaption><span>IterationSample.js </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IterationSample = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;눈사람&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;얼음&lt;/</span>li&gt;</span><br><span class="line">      &lt;li&gt;눈&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;바람&lt;/</span>li&gt;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default IterationSample;</span></span><br></pre></td></tr></table></figure></li></ul><p>위는 하나의 예시이며 <code>&lt;li&gt;</code> 태그 하나만 반복되는 것이 아니라 코드가 조금더 복잡해 진다면 코드양이 더더욱 늘어날 것이며 관리하기 힘들어 집니다.</p><p>리액트에서는 자바스크립트의 <code>Map</code> 메서드를 사용하여 더욱 간단하게 표현할 수 있습니다.</p><figure class="highlight jsx"><figcaption><span>IterationSample.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IterationSample = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">'눈사람'</span>, <span class="string">'얼음'</span>, <span class="string">'눈'</span>, <span class="string">'바람'</span>];</span><br><span class="line">  <span class="keyword">const</span> nameList = names.map(<span class="function"><span class="params">name</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;nameList&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> IterationSample;</span><br></pre></td></tr></table></figure><ul><li>문자열로 구성된 배열을 선언합니다.</li></ul><ul><li>그 배열 값을 사용하여 <code>&lt;li&gt;...&lt;/li&gt;</code> JSX 코드로 된 배열을 새로 생성한 후 nameList에 담습니다.</li></ul><hr><h3 id="App-컴포넌트에서-렌더링-시"><a href="#App-컴포넌트에서-렌더링-시" class="headerlink" title="App 컴포넌트에서 렌더링 시"></a>App 컴포넌트에서 렌더링 시</h3><p>App 컴포넌트에서 IterationSample.js 컴포넌트를 불러와 렌더링 하면</p><p>브라우저 화면에는 잘 표시되는 듯 보이나 <strong>개발자 도구에서 경고 메세지가 표시됩니다.</strong> </p><p><img src="/images/key_prop.png" alt="Warning: Each child in a list should have a unique &quot;key&quot; prop."></p><p>“key” prop이 없다는 경고 메서지입니다.</p><p>key가 무엇인지 알아봅시다.</p><hr><h2 id="key">key</h2><p>리액트에서 key는 컴포넌트 배열을 렌더링했을 때 어떤 요소에 변동이 있었는지 알아내려고 사용합니다.</p><p>key가 없을 때는 Virtual DOM을 비교하는 과정에서 리스트를 순차적으로 비교하면서 변화를 감지합니다.</p><p>하지만 key가 있다면 이 값을 사용하여 어떤 변화가 일어났는지 더욱 빠르게 알아낼 수 있습니다.</p><hr><h3 id="key-설정"><a href="#key-설정" class="headerlink" title="key 설정"></a>key 설정</h3><p><strong>key 값을 설정할 때는 map 함수의 인자로 전달되는 함수 내부에서 컴포넌트 props를 설정하듯이 설정하면 됩니다.</strong></p><ul><li>key 값은 언제나 유일해야 합니다. (따라서 데이터가 가진 고유값을 key 값으로 설정해야 합니다.)</li></ul><p>예를 들어 게시판의 게시물을 렌더링한다면 게시물 번호를 key 값으로 설정해야 합니다.</p><figure class="highlight jsx"><figcaption><span>key 값 예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> articleList = articles.map(article) =&gt; (</span><br><span class="line">  &lt;Article</span><br><span class="line">    title=&#123;article.title&#125;</span><br><span class="line">    writer=&#123;article.writer&#125;</span><br><span class="line">    key=&#123;article.id&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>하지만 앞에서 만든 IterationSample 예제 컴포넌트에는 이런 고유 번호가 없습니다.</p><p>이때는 map 함수에 전달되는 콜백 함수의 인수인 index 값을 사용하면 됩니다.</p><figure class="highlight jsx"><figcaption><span>IterationSample.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IterationSample = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">'눈사람'</span>, <span class="string">'얼음'</span>, <span class="string">'눈'</span>, <span class="string">'바람'</span>];</span><br><span class="line">  <span class="keyword">const</span> nameList = names.map(<span class="function">(<span class="params">name, index</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;nameList&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> IterationSample;</span><br></pre></td></tr></table></figure><p>이제 개발자 도구에서 경고 메세지를 표시하지 않습니다.</p><p><strong>고유한 값이 없을 때만 index 값을 key로 사용해야 합니다.</strong></p><p>index를 key로 사용하면 배열이 변경될 때 효율적으로 리렌더링하지 못합니다.</p><hr><h2 id="응용">응용</h2><p>고정된 배열을 렌더링하는 것이 아닌, 동적인 배열을 렌더링하여 구현해 봅니다.</p><p>또한 index값을 key로 사용하면 리렌더링이 비효율적이라 하였는데, 이러한 상황에 고유값을 만드는 방법도 알아봅니다.</p><hr><h3 id="초기-상태-설정"><a href="#초기-상태-설정" class="headerlink" title="초기 상태 설정"></a>초기 상태 설정</h3><p>IterationSample 컴포넌트에서 useState를 사용하여 3가지 상태를 설정합니다.</p><ol><li><p>데이터 배열</p></li><li><p>텍스트를 입력할 수 있는 input 상태</p></li><li><p>데이터 배열에서 새로운 항목을 추가할 때 사용할 고유 id 상태</p></li></ol><p>우선 배열을 작성할 때 <u>객체 형태로 이루어진 배열로</u> 만들어 <strong>문자열과 고유 id</strong>를 작성합니다.</p><figure class="highlight jsx"><figcaption><span>IterationSample.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IterationSample = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [names, setNames] = useState([</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'눈사람'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'얼음'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">'눈'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">text</span>: <span class="string">'바람'</span> &#125;,</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">const</span> [inputText, setInputText] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [nextId, setNextId] = useState(<span class="number">5</span>); <span class="comment">// 새 항목을 추가할 때 사용할 id</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nameList = names.map(<span class="function">(<span class="params">name</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;name.id&#125;</span>&gt;</span>&#123;name.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;nameList&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> IterationSample;</span><br></pre></td></tr></table></figure><p>이번에는 map 함수를 사용할 때 key 값을 index 대신 <code>name.id</code> 값으로 지정해 주었습니다.</p><hr><h3 id="데이터-추가-기능-구현"><a href="#데이터-추가-기능-구현" class="headerlink" title="데이터 추가 기능 구현"></a>데이터 추가 기능 구현</h3><p>새로운 이름을 등록할 수 있는 기능을 구현해 봅니다.</p><p>ul 태그 상단에 input 과 button을 렌더링하고 상태를 관리합니다.</p><figure class="highlight jsx"><figcaption><span>IterationSample.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IterationSample = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [names, setNames] = useState([</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'눈사람'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'얼음'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">'눈'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">text</span>: <span class="string">'바람'</span> &#125;,</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">const</span> [inputText, setInputText] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [nextId, setNextId] = useState(<span class="number">5</span>); <span class="comment">// 새 항목을 추가할 때 사용할 id</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> setInputText(e.target.value);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nextNames = names.concat(&#123;</span><br><span class="line">      id: nextId, <span class="comment">//nextId 값을 id로 설정</span></span><br><span class="line">      text: inputText, <span class="comment">//input 안에 작성된 값</span></span><br><span class="line">    &#125;);</span><br><span class="line">    setNextId(nextId + <span class="number">1</span>); <span class="comment">//nextId 값에 1을 더해줌</span></span><br><span class="line">    setNames(nextNames); <span class="comment">//names 값을 업데이트</span></span><br><span class="line">    setInputText(<span class="string">''</span>); <span class="comment">// inputText를 비움</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> nameList = names.map(<span class="function">(<span class="params">name</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;name.id&#125;</span>&gt;</span>&#123;name.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input value=&#123;inputText&#125; onChange=&#123;onChange&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onClick&#125;&gt;추가&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;&#123;nameList&#125;&lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default IterationSample;</span></span><br></pre></td></tr></table></figure><ul><li><code>onClick</code> 함수에서 <code>concat</code>을 사용하여 새로운 항목을 추가한 배열을 만들고, setNames를 통해 상태를 업데이트 해줬습니다.</li></ul><ul><li><p>배열에 새 항목을 추가할 때 <code>push</code>메서드 대신 <code>concat</code>을 사용한 이유 :<br><code>push</code> 메서드는 기본 배열 자체를 변경해 주는 반면<br><code>concat</code> 메서드는 새로운 배열을 만들어 준다는 차이점이 있습니다.</p><p><mark>리액트에서 상태를 업데이트할 때는 기존 상태를 그대로 두면서 새로운 값을 상태로 설정해야 합니다.<br>이를 불변성 유지라고 하며, 불변성 유지를 해줘야 리액트 컴포넌트의 성능을 최적화할 수 있습니다.</mark></p></li></ul><hr><h3 id="데이터-제거-기능-구현"><a href="#데이터-제거-기능-구현" class="headerlink" title="데이터 제거 기능 구현"></a>데이터 제거 기능 구현</h3><p>각 항목을 더블클릭했을 때 해당 항목이 화면에서 사라지는 기능을 구현해 봅니다.<br>이번에도 마찬가지로 <strong>불변성을 유지하면서</strong> 업데이트 해줍니다.</p><p>불변성을 유지하면서 배열의 특정 항목을 제거할 때는 <code>filter</code> 메서드를 사용합니다.</p><p>HTML 요소를 더블클릭할 때 사용하는 이벤트는 <code>onDoubleClick</code>입니다.<br>onRemove 라는 임의 메서드를 <code>filter</code>를 사용하여 만들어 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>IterationSample.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IterationSample = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [names, setNames] = useState([</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'눈사람'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'얼음'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">'눈'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">text</span>: <span class="string">'바람'</span> &#125;,</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">const</span> [inputText, setInputText] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [nextId, setNextId] = useState(<span class="number">5</span>); <span class="comment">// 새 항목을 추가할 때 사용할 id</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> setInputText(e.target.value);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nextNames = names.concat(&#123;</span><br><span class="line">      id: nextId, <span class="comment">//nextId 값을 id로 설정</span></span><br><span class="line">      text: inputText, <span class="comment">//input 안에 작성된 값</span></span><br><span class="line">    &#125;);</span><br><span class="line">    setNextId(nextId + <span class="number">1</span>); <span class="comment">//nextId 값에 1을 더해줌</span></span><br><span class="line">    setNames(nextNames); <span class="comment">//names 값을 업데이트</span></span><br><span class="line">    setInputText(<span class="string">''</span>); <span class="comment">// inputText를 비움</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onRemove = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123; <span class="comment">// 임의 메서드 onRemove 작성</span></span><br><span class="line">    <span class="keyword">const</span> nextNames = names.filter(<span class="function">(<span class="params">name</span>) =&gt;</span> name.id !== id);</span><br><span class="line">    setNames(nextNames);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> nameList = names.map(<span class="function">(<span class="params">name</span>) =&gt;</span> ( <span class="comment">// 더블클릭시 onRemove 메서드 실행</span></span><br><span class="line">    &lt;li key=&#123;name.id&#125; onDoubleClick=&#123;() =&gt; onRemove(name.id)&#125;&gt; </span><br><span class="line">      &#123;name.text&#125;</span><br><span class="line">    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  ));</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input value=&#123;inputText&#125; onChange=&#123;onChange&#125; /</span>&gt;</span><br><span class="line">      &lt;button onClick=&#123;onClick&#125;&gt;추가&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;&#123;nameList&#125;&lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default IterationSample;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;li&gt;</code> 태그 요소를 더블클릭시 onRemove 메서드를 실행하고 해당 배열의 id 값을 파라미터로 넘겨줍니다.</li></ul><ul><li>onRemove 메서드는 <code>filter</code>를 사용하여 더블클릭한 요소의 id값과 다른 요소들만 true를 반환하도록 하여, true를 반환한 요소들만 모아 새 배열로 반환하고 nextNames에 할당합니다.</li></ul><ul><li><code>setNames(nextNames)</code>로 업데이트 합니다.</li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/06/01/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%B0%98%EB%B3%B5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ref : DOM에 이름 달기</title>
      <link>https://hdw0903.github.io/2020/05/28/ref-DOM%EC%97%90-%EC%9D%B4%EB%A6%84-%EB%8B%AC%EA%B8%B0/</link>
      <guid>https://hdw0903.github.io/2020/05/28/ref-DOM%EC%97%90-%EC%9D%B4%EB%A6%84-%EB%8B%AC%EA%B8%B0/</guid>
      <pubDate>Thu, 28 May 2020 10:13:10 GMT</pubDate>
      <description>
      
        &lt;p&gt;HTML에서 id를 사용하여 DOM에 이름을 다는 것처럼 리액트 프로젝트 내부에서 DOM에 이름을 다는 방법이 있습니다. 바로 &lt;code&gt;ref&lt;/code&gt;(reference의 줄임말) 개념입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/28/ref-DOM에-이름-달기/#ref&quot;&gt;ref는 어떤 상황에서 사용해야 할까?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/28/ref-DOM에-이름-달기/#ref_use&quot;&gt;ref 사용&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/28/ref-DOM에-이름-달기/#ref_component&quot;&gt;컴포넌트에 ref 달기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;참고 :&lt;br&gt;리액트 컴포넌트 안에서도 id를 사용할 수 있지만, 특수한 경우가 아니라면 사용을 권장하지 않음.&lt;br&gt;예를 들어 같은 컴포넌트를 여러 번 사용한다면 중복 id를 가진 DOM이 여러 개 생기니 잘못된 사용이 됨.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ref는 전역적으로 작동하지 않고 컴포넌트 내부에서만 작동하기 때문에 이런 문제가 생기지 않음.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>HTML에서 id를 사용하여 DOM에 이름을 다는 것처럼 리액트 프로젝트 내부에서 DOM에 이름을 다는 방법이 있습니다. 바로 <code>ref</code>(reference의 줄임말) 개념입니다.</p><ul><li><a href="/2020/05/28/ref-DOM에-이름-달기/#ref">ref는 어떤 상황에서 사용해야 할까?</a></li></ul><ul><li><a href="/2020/05/28/ref-DOM에-이름-달기/#ref_use">ref 사용</a></li></ul><ul><li><a href="/2020/05/28/ref-DOM에-이름-달기/#ref_component">컴포넌트에 ref 달기</a></li></ul><ul><li><p>참고 :<br>리액트 컴포넌트 안에서도 id를 사용할 수 있지만, 특수한 경우가 아니라면 사용을 권장하지 않음.<br>예를 들어 같은 컴포넌트를 여러 번 사용한다면 중복 id를 가진 DOM이 여러 개 생기니 잘못된 사용이 됨.</p><p><strong>ref는 전역적으로 작동하지 않고 컴포넌트 내부에서만 작동하기 때문에 이런 문제가 생기지 않음.</strong></p></li></ul><a id="more"></a><hr><h2 id="ref">ref는 어떤 상황에서 사용해야 할까?</h2><p><strong>ref는 DOM을 꼭 직접적으로 건드려야 할 때 사용합니다.</strong></p><ol><li><p>특정 <code>&lt;input&gt;</code>태그에 포커스를 주는 경우</p></li><li><p>스크롤 박스를 조작하는 경우</p></li><li><p><code>&lt;Canvas&gt;</code>태그에 그림을 그리는 경우</p></li></ol><hr><h2 id="ref_use">ref 사용</h2><p>프로젝트에서 ref를 사용해 봅시다. <strong>ref를 사용하는 방법은 두 가지가 있습니다.</strong></p><hr><h3 id="콜백-함수를-통한-ref-설정"><a href="#콜백-함수를-통한-ref-설정" class="headerlink" title="콜백 함수를 통한 ref 설정"></a>콜백 함수를 통한 ref 설정</h3><p><strong>ref를 만드는 가장 기본적인 방법은 콜백 함수를 사용하는 것입니다.</strong></p><p>ref를 달고자 하는 요소에 <strong>ref라는 콜백 함수를 props로 전달해 주면 됩니다</strong>.</p><p>이 콜백 함수는 ref 값을 파라미터로 전달받습니다.<br>그리고 함수 내부에서 파라미터로 받은 ref를 컴포넌트의 멤버 변수로 설정해 줍니다.</p><figure class="highlight jsx"><figcaption><span>ref 값으로 콜백 함수 전달</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&#123; (ref) =&gt; &#123; <span class="keyword">this</span>.input=ref &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><p>이렇게 하면 앞으로 this.input은 input 요소의 DOM을 가리킵니다.<br>ref의 이름은 원하는 것으로 자유롭게 지정할 수 있습니다.</p><hr><h3 id="createRef를-통한-ref-설정"><a href="#createRef를-통한-ref-설정" class="headerlink" title="createRef를 통한 ref 설정"></a>createRef를 통한 ref 설정</h3><p>ref를 만드는 또 다른 방법은 리액트에 내장되어 있는 <code>createRef</code> 함수를 사용하는 것입니다.</p><p>이 기능은 리액트 v16.3부터 도입되었으며 이전 버전에서는 작동하지 않습니다.</p><figure class="highlight jsx"><figcaption><span>createRef 사용 예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefSample</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  input = React.createRef();</span><br><span class="line"></span><br><span class="line">  handleFocus = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.input.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input ref=&#123;<span class="keyword">this</span>.input&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default RefSample;</span></span><br></pre></td></tr></table></figure><p><code>createRef</code>를 사용하여 ref를 만들려면 우선 컴포넌트 내부에서 멤버 변수로 React.createRef()를 담아 줘야 합니다.</p><p>해당 멤버 변수를 ref를 달고자 하는 요소에 ref props로 넣어 주면 ref 설정이 완료됩니다.</p><p>설정한 뒤 나중에 ref를 설정해 준 DOM에 접근하려면 this.input.current를 조회하면 됩니다.</p><p><strong>콜백 함수를 사용할 때와 다른 점은 이렇게 뒷부분에 .current를 넣어 줘야 한다는 것입니다.</strong></p><hr><h2 id="ref_component">컴포넌트에 ref 달기</h2><p>리액트에서는 컴포넌트에도 ref를 달 수 있습니다.</p><p>이 방법은 주로 컴포넌트 내부에 있는 DOM을 컴포넌트 외부에서 사용할 때 씁니다.</p><hr><h3 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent</span><br><span class="line">  ref= &#123;(ref) =&gt; &#123;<span class="keyword">this</span>.myComponent=ref&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><p>이렇게 하면 MyComponent 내부의 메서드 및 맴버 변수에 접근할 수 있습니다.<br>즉 내부의 ref에도 접근할 수 있습니다.</p><hr><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><p><strong>부모 컴포넌트에서 스크롤바 내리기</strong></p><p>ScrollBox.js 컴포넌트 파일을 만들고 스크롤 박스를 만들어 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>ScrollBox.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollBox</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> style = &#123;</span><br><span class="line">      border: <span class="string">'1px solid black'</span>,</span><br><span class="line">      height: <span class="string">'300px'</span>,</span><br><span class="line">      width: <span class="string">'300px'</span>,</span><br><span class="line">      overflow: <span class="string">'auto'</span>,</span><br><span class="line">      position: <span class="string">'relative'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> innerStyle = &#123;</span><br><span class="line">      width: <span class="string">'100%'</span>,</span><br><span class="line">      height: <span class="string">'650px'</span>,</span><br><span class="line">      background: <span class="string">'linear-gradient(white, black)'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div</span><br><span class="line">        style=&#123;style&#125;</span><br><span class="line">        ref=&#123;(ref) =&gt; &#123;</span><br><span class="line">          <span class="keyword">this</span>.box = ref;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;div style=&#123;innerStyle&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default ScrollBox;</span></span><br></pre></td></tr></table></figure><hr><h4 id="컴포넌트에-메서드-생성"><a href="#컴포넌트에-메서드-생성" class="headerlink" title="컴포넌트에 메서드 생성"></a>컴포넌트에 메서드 생성</h4><p>컴포넌트에 스크롤바를 맨 아래쪽으로 내리는 메서드를 만들겠습니다.</p><p>자바스크립트로 스크롤바를 내릴 때는 DOM 노드가 가진 다음 값들을 사용합니다.</p><ul><li><p>scrollTop: 세로 스크롤바 위치 (0~350)</p></li><li><p>scrollHeight: 스크롤이 있는 박스 안의 div 높이 (650)</p></li><li><p>clientHeight: 스크롤이 있는 박스의 높이 (300)</p></li></ul><figure class="highlight jsx"><figcaption><span>ScrollBox.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollBox</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  scrollToBottom = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; scrollHeight, clientHeight &#125; = <span class="keyword">this</span>.box;</span><br><span class="line">    <span class="comment">/* 앞 코드에는 비구조화 할당 문법을 사용했습니다.</span></span><br><span class="line"><span class="comment">    다음 코드와 같은 의미입니다.</span></span><br><span class="line"><span class="comment">    const scrollHeight = this.box.scrollHeight;</span></span><br><span class="line"><span class="comment">    const clientHeight = this.box.cliengHeight;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">this</span>.box.scrollTop = scrollHeight - clientHeight;</span><br><span class="line">  &#125;;</span><br><span class="line">(...)</span><br></pre></td></tr></table></figure><p>이렇게 만든 메서드는 부모 컴포넌트인 App 컴포넌트에서 ScrollBox에 ref를 달면 사용할 수 있습니다.</p><hr><h4 id="컴포넌트에-ref-달고-내부-메서드-사용"><a href="#컴포넌트에-ref-달고-내부-메서드-사용" class="headerlink" title="컴포넌트에 ref 달고 내부 메서드 사용"></a>컴포넌트에 ref 달고 내부 메서드 사용</h4><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ScrollBox <span class="keyword">from</span> <span class="string">'./ScrollBox'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ScrollBox ref=&#123;(ref) =&gt; (<span class="keyword">this</span>.scrollBox = ref)&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.scrollBox.scrollToBottom()&#125;&gt;</span><br><span class="line">          맨 밑으로</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>App 컴포넌트에서 ScrollBox에 ref를 달고 버튼을 만들어 누르면, ScrollBox 컴포넌트의 scrollToBottom 메서드가 실행됩니다.</p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/28/ref-DOM%EC%97%90-%EC%9D%B4%EB%A6%84-%EB%8B%AC%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이벤트 -React</title>
      <link>https://hdw0903.github.io/2020/05/27/%EC%9D%B4%EB%B2%A4%ED%8A%B8-React/</link>
      <guid>https://hdw0903.github.io/2020/05/27/%EC%9D%B4%EB%B2%A4%ED%8A%B8-React/</guid>
      <pubDate>Wed, 27 May 2020 09:23:01 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/27/이벤트-React/#React_event&quot;&gt;리액트의 이벤트 시스템&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;이벤트 사용 시 주의사항&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/27/이벤트-React/#event_handling&quot;&gt;이벤트 핸들링 익히기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/27/이벤트-React/#3&quot;&gt;함수형 컴포넌트로 구현&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<ul><li><a href="/2020/05/27/이벤트-React/#React_event">리액트의 이벤트 시스템</a><ul><li>이벤트 사용 시 주의사항</li></ul></li></ul><ul><li><a href="/2020/05/27/이벤트-React/#event_handling">이벤트 핸들링 익히기</a></li></ul><ul><li><a href="/2020/05/27/이벤트-React/#3">함수형 컴포넌트로 구현</a></li></ul><a id="more"></a><hr><h2 id="React_event">리액트의 이벤트 시스템</h2><p>리액트의 이벤트 시스템은 웹 브라우저의 HTML 이벤트와 인터페이스가 동일하기 때문에 사용법이 비슷한데,</p><p>주의해야할 몇가지 사항이 있습니다.</p><hr><h3 id="이벤트-사용-시-주의-사항"><a href="#이벤트-사용-시-주의-사항" class="headerlink" title="이벤트 사용 시 주의 사항"></a>이벤트 사용 시 주의 사항</h3><ol><li>이벤트 이름은 카멜 표기법으로 작성합니다.<br>ex) onclick -&gt; onClick, onchange -&gt; onChange</li></ol><ol start="2"><li>이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, <strong>함수 형태의 객체를 전달합니다.</strong></li></ol><ol start="3"><li><p>DOM 요소에만 이벤트를 설정할 수 있습니다.</p><p><code>&lt;div&gt;</code>, <code>&lt;button&gt;</code>, <code>&lt;input&gt;</code>, <code>&lt;form&gt;</code>, <code>&lt;span&gt;</code>등 DOM요소에만 이벤트를 사용할 수 있습니다.</p><p>직접 만든 컴포넌트에는 이벤트를 자체적으로 설정할 수 없습니다.</p><figure class="highlight jsx"><figcaption><span>컴포넌트에 이벤트 설정 불가</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Mycomponent onClick=&#123;something&#125; /&gt;</span><br></pre></td></tr></table></figure><p>위 코드는 Mycomponent를 클릭할 때 something 함수를 실행하는 것이 아니라, 그냥 이름이 onClick인 props를 Mycomponent에게 전달해 줍니다. 이벤트가 발생하지 않습니다.</p></li></ol><hr><h3 id="이벤트-종류"><a href="#이벤트-종류" class="headerlink" title="이벤트 종류"></a>이벤트 종류</h3><p>리액트에서 지원하는 이벤트 종류는 다음과 같습니다.</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>Clipboard</td><td>Touch</td><td>Composition</td></tr><tr><td>UI</td><td>Keyboard</td><td>Wheel</td></tr><tr><td>Focus</td><td>Media</td><td>Form</td></tr><tr><td>Image</td><td>Mouse</td><td>Animation</td></tr><tr><td>Selection</td><td>Transition</td><td></td></tr></tbody></table><ul><li>더 자세한 이벤트 정보는 <a href="https://facebook.github.io/react/docs/events.html">리액트 메뉴얼을 참고합니다.</a></li></ul><hr><h2 id="event_handling">이벤트 핸들링 익히기</h2><p>다음 단계에 맞춰 이벤트 핸들링을 익혀봅니다.<br><img src="/images/%EC%9D%B4%EB%B2%A4%ED%8A%B8_%ED%95%B8%EB%93%A4%EB%A7%81_%EC%98%88%EC%A0%9C_%EC%88%9C%EC%84%9C.png" alt="이벤트 핸들링 예제 순서"></p><p>먼저 EventPractice.js 파일을 만들고 클래스형 컴포넌트로 작성 후 App 컴포넌트에서 불러와 렌더링하겠습니다.</p><figure class="highlight jsx"><figcaption><span>EventPractice.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventPractice;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> EventPractice <span class="keyword">from</span> <span class="string">"./EventPractice"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">EventPractice</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><hr><h3 id="onChange-이벤트-핸들링"><a href="#onChange-이벤트-핸들링" class="headerlink" title="onChange 이벤트 핸들링"></a>onChange 이벤트 핸들링</h3><h4 id="onChange-이벤트-설정"><a href="#onChange-이벤트-설정" class="headerlink" title="onChange 이벤트 설정"></a>onChange 이벤트 설정</h4><p>EventPractice 컴포넌트에 input 요소를 렌더링하는 코드와 해당 요소에 onChange 이벤트를 설정하는 코드를 작성합니다.</p><figure class="highlight jsx"><figcaption><span>EventPractice.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="text"</span></span><br><span class="line"><span class="regexp">          name="message"</span></span><br><span class="line"><span class="regexp">          placeholder="아무거나 입력하세요"</span></span><br><span class="line"><span class="regexp">          onChange=&#123;(e) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            console.log(e);</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default EventPractice;</span></span><br></pre></td></tr></table></figure><p>웹 브라우저에서 개발자 도구를 열어 인풋에 아무거나 입력해보면 이벤트 객체가 콘솔에 나타납니다.</p><p>콘솔에 기록되는 e 객체는 <code>SyntheticEvent</code>로 웹 브라우저에서 네이티브 이벤트를 감싸는 객체입니다.</p><ul><li><code>SyntheticEvent</code>는 네이티브 이벤트와 달리 이벤트가 끝나고 나면 이벤트가 초기화되므로 정보를 참조할 수 없습니다. ex) 0.5초뒤 e 객체를 참조하면 e 객체 내부의 모든 값이 비워져있어 참조 불가능.</li></ul><ul><li>비동기적으로 이벤트 객체를 참조할 일이 있다면 e.persist() 함수를 호출해 줘야합니다.</li></ul><p>onChange 이벤트가 발생할 때, 변할 input 값을 콘솔에 기록하려면 <code>e.target.value</code>를 콘솔에 넣어주면 됩니다.</p><figure class="highlight jsx"><figcaption><span>EventPractice.js onChange 코드 수정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onChange=&#123;</span><br><span class="line">  (e) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input 값이 변할 때 마다 콘솔에 기록됩니다.</p><hr><h4 id="state에-input-값-담기"><a href="#state에-input-값-담기" class="headerlink" title="state에 input 값 담기"></a>state에 input 값 담기</h4><ul><li><p>state 초기값을 설정하고</p></li><li><p>이벤트 핸들링 함수 내부에서 this.setState 메서드를 호출하여 state를 업데이트합니다.</p></li><li><p>input의 <code>value</code> 값을 <code>state</code>에 있는 값으로 설정합니다.</p></li></ul><figure class="highlight jsx"><figcaption><span>EventPractice.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state =&#123;</span><br><span class="line">    message: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="text"</span></span><br><span class="line"><span class="regexp">          name="message"</span></span><br><span class="line"><span class="regexp">          placeholder="아무거나 입력하세요"</span></span><br><span class="line"><span class="regexp">          value=&#123;this.state.message&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;(e) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            this.setState(&#123;</span></span><br><span class="line"><span class="regexp">              message: e.target.value</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default EventPractice;</span></span><br></pre></td></tr></table></figure><p>브라우저에서 인풋에 입력했을 때 오류가 발생하지 않고 재대로 입력할 수 있다면 state에 텍스트를 잘 담은 것입니다.</p><hr><h4 id="클릭-이벤트시-state-값-출력-후-초기화"><a href="#클릭-이벤트시-state-값-출력-후-초기화" class="headerlink" title="클릭 이벤트시 state 값 출력 후 초기화"></a>클릭 이벤트시 state 값 출력 후 초기화</h4><p><code>&lt;button&gt;</code>을 하나 만들고 클릭 이벤트가 발생 시 현재 comment(state로 담은 값)값을 alert 창으로 띄운 후 초기값으로 설정합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    message: <span class="string">""</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="text"</span></span><br><span class="line"><span class="regexp">          name="message"</span></span><br><span class="line"><span class="regexp">          placeholder="아무거나 입력하세요"</span></span><br><span class="line"><span class="regexp">          value=&#123;this.state.message&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;(e) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            this.setState(&#123;</span></span><br><span class="line"><span class="regexp">              message: e.target.value,</span></span><br><span class="line"><span class="regexp">            &#125;);</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;() =&gt; &#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.state.message);</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">              message: <span class="string">""</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          확인</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventPractice;</span><br></pre></td></tr></table></figure><p>input에 아무거나 입력 후 확인 버튼을 누르면 state에 담은 값이 alert창으로 출력되고 확인버튼을 누르면 input 값이 초기화 됩니다.</p><hr><h3 id="임의-메서드-만들기"><a href="#임의-메서드-만들기" class="headerlink" title="임의 메서드 만들기"></a>임의 메서드 만들기</h3><p>앞서 onChange와 onClick에 전달한 함수를 따로 빼내어 컴포넌트 임의 메서드를 만들어 봅니다.</p><figure class="highlight jsx"><figcaption><span>EventPractice.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    message: <span class="string">""</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      message: e.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.state.message);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      message: <span class="string">""</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="text"</span></span><br><span class="line"><span class="regexp">          name="message"</span></span><br><span class="line"><span class="regexp">          placeholder="아무거나 입력하세요"</span></span><br><span class="line"><span class="regexp">          value=&#123;this.state.message&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;this.handleChange&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;확인&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventPractice;</span><br></pre></td></tr></table></figure><hr><h4 id="Property-Initializer-Syntax를-사용한-메서드-작성"><a href="#Property-Initializer-Syntax를-사용한-메서드-작성" class="headerlink" title="Property Initializer Syntax를 사용한 메서드 작성"></a>Property Initializer Syntax를 사용한 메서드 작성</h4><p>메서드 바인딩은 생성자 메서드에서 바인딩 하는 방법이 정석이지만,<br>새로운 메서드를 만들 때마다 constructor를 수정해야하는 번거로움이 있습니다.</p><p>바벨의 <code>transform-class-properties</code> 문법을 사용하여 화살표 함수 형태로 작성하면<br><strong>생성자 함수를 사용하지 않고 동적으로 바인딩이 가능합니다.</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    message: <span class="string">""</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      message: e.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.state.message);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      message: <span class="string">""</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><code>transform-class-properties</code>을 사용하여 이처럼 사용할 수 있습니다.</p><hr><h3 id="input-여러-개-다루기"><a href="#input-여러-개-다루기" class="headerlink" title="input 여러 개 다루기"></a>input 여러 개 다루기</h3><p><strong>동일한 여러 태그 다뤄보기</strong></p><p>동일한 태그 여러 개를 작업할 때 메서드를 여러개 만드는 방법보다 쉬운 방법이 있습니다.</p><ul><li><strong>event 객체를 활용하여 처리할 수 있습니다.</strong></li></ul><p>onChange 이벤트 핸들러에서 e.target.name은 해당 인풋의 name을 가리킵니다. (현재 message)</p><p>이 값을 사용하여 state를 설정해 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>e.target.name 사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    username: <span class="string">''</span>,</span><br><span class="line">    message: <span class="string">''</span></span><br><span class="line">  &#125;;</span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      [e.target.name]: e.target.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.state.username + <span class="string">': '</span> + <span class="keyword">this</span>.state.message);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      username: <span class="string">''</span>,</span><br><span class="line">      message: <span class="string">''</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="text"</span></span><br><span class="line"><span class="regexp">          name="username"</span></span><br><span class="line"><span class="regexp">          placeholder="유저명"</span></span><br><span class="line"><span class="regexp">          value=&#123;this.state.username&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;this.handleChange&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          name=<span class="string">"message"</span></span><br><span class="line">          placeholder=<span class="string">"아무거나 입력해보세요"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.message&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.handleChange&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;확인&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventPractice;</span><br></pre></td></tr></table></figure><p><strong>객체 안에서 key를 []로 감싸면 그 안에 넣은 레퍼런스가 가리키는 실제 값이 key 값으로 사용됩니다.</strong></p><hr><h3 id="onKeyPress-이벤트-핸들링"><a href="#onKeyPress-이벤트-핸들링" class="headerlink" title="onKeyPress 이벤트 핸들링"></a>onKeyPress 이벤트 핸들링</h3><p>comment 인풋에서 enter를 눌렀을 때 KeyPress 이벤트를 처리하는 handleClick 메서드를 호출하도록 해봅니다.</p><figure class="highlight jsx"><figcaption><span>KeyPress</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    username: <span class="string">""</span>,</span><br><span class="line">    message: <span class="string">""</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      [e.target.name]: e.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.state.username + <span class="string">": "</span> + <span class="keyword">this</span>.state.message);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      username: <span class="string">""</span>,</span><br><span class="line">      message: <span class="string">""</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleKeyPress = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.key === <span class="string">"Enter"</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.handleClick();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="text"</span></span><br><span class="line"><span class="regexp">          name="username"</span></span><br><span class="line"><span class="regexp">          placeholder="유저명"</span></span><br><span class="line"><span class="regexp">          value=&#123;this.state.username&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;this.handleChange&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          name=<span class="string">"message"</span></span><br><span class="line">          placeholder=<span class="string">"아무거나 입력해보세요"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.message&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.handleChange&#125;</span><br><span class="line">          onKeyPress=&#123;<span class="keyword">this</span>.handleKeyPress&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;확인&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventPractice;</span><br></pre></td></tr></table></figure><p>두 번째 텍스트 인풋에서 텍스트를 입력하고 enter를 누르면 handleClick 메서드가 실행됩니다.</p><hr><h2 id="3">함수형 컴포넌트로 구현</h2><p>여태 한 작업을 함수형 컴포넌트로 똑같이 구현할 수 있습니다.</p><p>함수형 컴포넌트로 구현 시 </p><figure class="highlight jsx"><figcaption><span>함수형 컴포넌트로 작성</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EventPractice = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [username, setUsername] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [message, setMessage] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> onChangeUsername = <span class="function">(<span class="params">e</span>) =&gt;</span> setUsername(e.target.value);</span><br><span class="line">  <span class="keyword">const</span> onChangeMessage = <span class="function">(<span class="params">e</span>) =&gt;</span> setMessage(e.target.value);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(username + <span class="string">': '</span> + message);</span><br><span class="line">    setUsername(<span class="string">''</span>);</span><br><span class="line">    setMessage(<span class="string">''</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onKeyPress = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.key === <span class="string">'Enter'</span>) &#123;</span><br><span class="line">      onClick();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input</span></span><br><span class="line"><span class="regexp">        type="text"</span></span><br><span class="line"><span class="regexp">        name="username"</span></span><br><span class="line"><span class="regexp">        placeholder="유저명"</span></span><br><span class="line"><span class="regexp">        value=&#123;username&#125;</span></span><br><span class="line"><span class="regexp">        onChange=&#123;onChangeUsername&#125;</span></span><br><span class="line"><span class="regexp">      /</span>&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        name=<span class="string">"message"</span></span><br><span class="line">        placeholder=<span class="string">"아무거나 입력해보세요"</span></span><br><span class="line">        value=&#123;message&#125;</span><br><span class="line">        onChange=&#123;onChangeMessage&#125;</span><br><span class="line">        onKeyPress=&#123;onKeyPress&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onClick&#125;&gt;확인&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventPractice;</span><br></pre></td></tr></table></figure><p>위 코드에서는 e.target.name을 활용하지 않고 onChange 관련 함수 두 개를 따로 만들어 주었습니다.</p><p>이번에는 useState를 통해 사용하는 상태에 문자열이 아닌 객체를 넣어 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>EventPractice.js 수정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EventPractice = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [form, setForm] = useState(&#123;</span><br><span class="line">    username: <span class="string">''</span>,</span><br><span class="line">    message: <span class="string">''</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> &#123; username, message &#125; = form;</span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nextForm = &#123;</span><br><span class="line">      ...form, <span class="comment">// 기존의 form 내용을 이 자리에 복사 한 뒤</span></span><br><span class="line">      [e.target.name]: e.target.value, <span class="comment">// 원하는 값을 덮어씌우기</span></span><br><span class="line">    &#125;;</span><br><span class="line">    setForm(nextForm);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(username + <span class="string">': '</span> + message);</span><br><span class="line">    setForm(&#123;</span><br><span class="line">      username: <span class="string">''</span>,</span><br><span class="line">      message: <span class="string">''</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onKeyPress = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.key === <span class="string">'Enter'</span>) &#123;</span><br><span class="line">      onClick();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input</span></span><br><span class="line"><span class="regexp">        type="text"</span></span><br><span class="line"><span class="regexp">        name="username"</span></span><br><span class="line"><span class="regexp">        placeholder="유저명"</span></span><br><span class="line"><span class="regexp">        value=&#123;username&#125;</span></span><br><span class="line"><span class="regexp">        onChange=&#123;onChange&#125;</span></span><br><span class="line"><span class="regexp">      /</span>&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        name=<span class="string">"message"</span></span><br><span class="line">        placeholder=<span class="string">"아무거나 입력해보세요"</span></span><br><span class="line">        value=&#123;message&#125;</span><br><span class="line">        onChange=&#123;onChange&#125;</span><br><span class="line">        onKeyPress=&#123;onKeyPress&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onClick&#125;&gt;확인&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventPractice;</span><br></pre></td></tr></table></figure><p>e.target.name 값을 활용하려면, 위와 같이 useState를 쓸 때 인풋 값들이 들어있는 form 객체를 사용해 주면 됩니다.</p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/27/%EC%9D%B4%EB%B2%A4%ED%8A%B8-React/#disqus_thread</comments>
    </item>
    
    <item>
      <title>컴포넌트(component)</title>
      <link>https://hdw0903.github.io/2020/05/24/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-component/</link>
      <guid>https://hdw0903.github.io/2020/05/24/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-component/</guid>
      <pubDate>Sun, 24 May 2020 09:53:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;컴포넌트를 선언하는 방식은 두 가지입니다.&lt;br&gt;하나는 함수형 컴포넌트이고 또 다른 하나는 클래스형 컴포넌트입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/24/컴포넌트-component/#component&quot;&gt;클래스형 컴포넌트&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;함수형 컴포넌트&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/24/컴포넌트-component/#New_component&quot;&gt;컴포넌트 생성&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;src 디렉터리에 MyComponent.js 파일 생성&lt;/li&gt;
&lt;li&gt;코드 작성&lt;/li&gt;
&lt;li&gt;모듈 내보내기(export) 및 불러오기(import)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/24/컴포넌트-component/#props&quot;&gt;props&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSX 내부에서 props 렌더링&lt;/li&gt;
&lt;li&gt;컴포넌트를 사용할 때 props 값 지정하기&lt;/li&gt;
&lt;li&gt;props 기본값 설정: defaultProps&lt;/li&gt;
&lt;li&gt;컴포넌트 태그 사이의 내용을 보여주는 children&lt;/li&gt;
&lt;li&gt;비구조화 할당 문법을 통한 props 내부 값 추출&lt;/li&gt;
&lt;li&gt;propTypes를 통한 props 검증&lt;/li&gt;
&lt;li&gt;클래스형 컴포넌트에서 props 사용하기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/24/컴포넌트-component/#state&quot;&gt;state&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클래스형 컴포넌트의 state&lt;/li&gt;
&lt;li&gt;함수형 컴포넌트에서 useState 사용하기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/24/컴포넌트-component/#state_주의사항&quot;&gt;state 사용시 주의 사항&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>컴포넌트를 선언하는 방식은 두 가지입니다.<br>하나는 함수형 컴포넌트이고 또 다른 하나는 클래스형 컴포넌트입니다.</p><ul><li><a href="/2020/05/24/컴포넌트-component/#component">클래스형 컴포넌트</a><ul><li>함수형 컴포넌트</li></ul></li></ul><ul><li><a href="/2020/05/24/컴포넌트-component/#New_component">컴포넌트 생성</a><ul><li>src 디렉터리에 MyComponent.js 파일 생성</li><li>코드 작성</li><li>모듈 내보내기(export) 및 불러오기(import)</li></ul></li></ul><ul><li><p><a href="/2020/05/24/컴포넌트-component/#props">props</a></p><ul><li>JSX 내부에서 props 렌더링</li><li>컴포넌트를 사용할 때 props 값 지정하기</li><li>props 기본값 설정: defaultProps</li><li>컴포넌트 태그 사이의 내용을 보여주는 children</li><li>비구조화 할당 문법을 통한 props 내부 값 추출</li><li>propTypes를 통한 props 검증</li><li>클래스형 컴포넌트에서 props 사용하기</li></ul></li><li><p><a href="/2020/05/24/컴포넌트-component/#state">state</a></p><ul><li>클래스형 컴포넌트의 state</li><li>함수형 컴포넌트에서 useState 사용하기</li></ul></li></ul><ul><li><a href="/2020/05/24/컴포넌트-component/#state_주의사항">state 사용시 주의 사항</a></li></ul><a id="more"></a><hr><h2 id="component">클래스형 컴포넌트</h2><p>아래 App 컴포넌트는 함수형 컴포넌트이며, 코드가 다음과 같은 구조로 이루어져 있습니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"react"</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>App.js 코드를 수정하여 클래스형 컴포넌트로 만들면</p><figure class="highlight jsx"><figcaption><span>클래스형 컴포넌트</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">"react"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"react"</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>클래스형 컴포넌트로 작성하였지만 역활은 이전의 함수형 컴포넌트와 똑같습니다.</p><ul><li>클래스형 컴포넌트와 함수형 컴포넌트의 차이점은 <strong>클래스형 컴포넌트의 경우 <code>state</code> 기능 및 <code>라이프사이클</code> 기능을 사용할 수 있다는 것과 임의 메서드를 정의할 수 있다는 것입니다.</strong></li></ul><ul><li>클래스형 컴포넌트에서는 <code>render</code>함수가 꼭 있어야 하고, 그 안에서 보여 주어야 할 JSX를 반환해야 합니다.</li></ul><hr><h3 id="함수형-컴포넌트"><a href="#함수형-컴포넌트" class="headerlink" title="함수형 컴포넌트"></a>함수형 컴포넌트</h3><ul><li><p><strong>함수형 컴포넌트 장점</strong></p><ul><li>클래스형 컴포넌트보다 선언하기 훨씬 편리하다.</li><li>메모리 자원도 클래스형 컴포넌트보다 덜 사용한다.</li><li>프로젝트를 완성하여 빌드한 후 배포시에도 함수형 컴포넌트 결과물의 파일 크기가 더 작다.</li></ul></li></ul><ul><li><p><strong>함수형 컴포넌트 주요 단점</strong></p><ul><li>함수형 컴포넌트의 주요 단점은 <code>state</code>와 <code>라이플사이클 API</code>의 사용이 불가능하다는 점이었으나,<br><strong>이 단점은 리액트 v16.8 업데이트 이후 <code>Hooks</code>라는 기능이 도입되면서 해결되었습니다.</strong><br>완전히 클래스형 컴포넌트와 똑같이 사용할 수 있는 것은 아니지만 조금 다른 방식으로 비슷한 작업을 할 수 있게 되었습니다. </li></ul></li></ul><p><u>리액트 공식 메뉴얼에서는</u> 컴포넌트를 새로 작성할 때 <code>함수형 컴포넌트</code>와 <code>Hooks</code>를 사용하도록 권장합니다. 하지만 클래스형 컴포넌트가 없어진 것은 아니므로 클래스형 컴포넌트의 기능도 꼭 알아 두어야합니다.</p><hr><h2 id="New_component">컴포넌트 생성</h2><p><img src="/images/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%83%9D%EC%84%B1.png" alt="컴포넌트 생성 과정"></p><h3 id="src-디렉터리에-MyComponent-js-파일-생성"><a href="#src-디렉터리에-MyComponent-js-파일-생성" class="headerlink" title="src 디렉터리에 MyComponent.js 파일 생성"></a>src 디렉터리에 MyComponent.js 파일 생성</h3><p>컴포넌트를 만들려면 <strong>컴포넌트 코드를 선언할 파일을 만들고 내부에 컴포넌트 코드를 선언해야 합니다</strong>.</p><p>파일 목록 중 src 디렉터리 내부에 새 파일을 만들고 파일 이름을 MyComponent.js라고 입력합니다.</p><hr><h3 id="코드-작성하기"><a href="#코드-작성하기" class="headerlink" title="코드 작성하기"></a>코드 작성하기</h3><p>MyComponent.js 파일을 열고 새 컴포넌트의 코드를 작성합니다.</p><figure class="highlight jsx"><figcaption><span>MyComponent.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>새 컴포넌트<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyComponent;</span><br></pre></td></tr></table></figure><hr><h3 id="모듈-내보내기-export-및-불러오기-import"><a href="#모듈-내보내기-export-및-불러오기-import" class="headerlink" title="모듈 내보내기(export) 및 불러오기(import)"></a>모듈 내보내기(export) 및 불러오기(import)</h3><ul><li>모듈 내보내기(export)<figure class="highlight jsx"><figcaption><span>내보내기 (export)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyComponent;</span><br></pre></td></tr></table></figure></li></ul><p>위 코드가 다른파일에서 이 파일을 불러오기(<code>import</code>)할 때, 선언한 <code>MyComponent</code> 클래스를 불러오도록 설정해줍니다.</p><ul><li>모듈 불러오기(import)<figure class="highlight jsx"><figcaption><span>불러오기(import)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./MyComponent'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></li></ul><p>다른 컴포넌트에서 <code>MyComponent</code> 컴포넌트를 불러와서 사용하려면 위와 같이 두 번째줄에 <code>import</code> 구문 처럼 사용합니다.</p><hr><h2 id="props">props</h2><p><code>props</code>는 <code>properties</code>를 줄인 표현으로 <strong>컴포넌트 속성을 설정할 때 사용하는 요소입니다.</strong></p><p><code>props 값</code>은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트(App 컴포넌트에서 MyComponent 컴포넌트를 불러와 사용한다면 App 컴포넌트가 부모 컴포넌트입니다.)에서 설정할 수 있습니다.</p><hr><h3 id="JSX-내부에서-props-렌더링"><a href="#JSX-내부에서-props-렌더링" class="headerlink" title="JSX 내부에서 props 렌더링"></a>JSX 내부에서 props 렌더링</h3><p>props 값은 컴포넌트 함수의 파라미터로 받아와 사용할 수 있습니다.</p><p>props를 렌더링할 때 JSX 내부에서 중괄호{}로 감싸 주면 됩니다.</p><figure class="highlight jsx"><figcaption><span>MyComponent.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>제 이름은 &#123;props.name&#125;입니다.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyComponent;</span><br></pre></td></tr></table></figure><hr><h3 id="컴포넌트를-사용할-때-props-값-지정하기"><a href="#컴포넌트를-사용할-때-props-값-지정하기" class="headerlink" title="컴포넌트를 사용할 때 props 값 지정하기"></a>컴포넌트를 사용할 때 props 값 지정하기</h3><p>App 컴포넌트(부모 컴포넌트)에서 MyComponent의 props 값을 지정해 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./MyComponent'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">name</span>=<span class="string">"React"</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>코드를 저장하고 브라우저를 확인해 보면 “제 이름은 React입니다.”가 출력됩니다.</p><hr><h3 id="props-기본값-설정-defaultProps"><a href="#props-기본값-설정-defaultProps" class="headerlink" title="props 기본값 설정: defaultProps"></a>props 기본값 설정: defaultProps</h3><p>설정한 name 값을 지우고 다시 실행하면</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">name</span>=<span class="string">"React"</span> /&gt;</span></span>;</span><br><span class="line"><span class="comment">// name 값 삭제</span></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>브라우저에 “제 이름은 입니다.”가 출력될 것입니다.</p><p><code>defaultProps</code>는 이 처럼 props 값을 따로 지정하지 않았을 때 보여줄 기본값을 설정해줍니다.</p><figure class="highlight jsx"><figcaption><span>defaultProps</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>제 이름은 &#123;props.name&#125;입니다.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyComponent.defaultProps = &#123;</span><br><span class="line">  name: <span class="string">"기본 이름"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyComponent;</span><br></pre></td></tr></table></figure><p>이 처럼 <code>MyComponent.defaultProps</code>에 <code>name</code> 값으로 “기본 이름”을 지정해주면<br>props 값이 지정되있지 않을 때 “제 이름은 기본이름 입니다”라고 출력됩니다.</p><hr><h3 id="태그-사이의-내용을-보여-주는-children"><a href="#태그-사이의-내용을-보여-주는-children" class="headerlink" title="태그 사이의 내용을 보여 주는 children"></a>태그 사이의 내용을 보여 주는 children</h3><p>리액트 컴포넌트를 사용할 때 컴포넌트 태그 사이의 내용을 보여 주는 props가 바로 <code>children</code>입니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">"./MyComponent"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span>리액트<span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>위 코드에서 MyComponent 태그 사이에 작성한 “리액트”라는 문자열을 MyComponent 내부에서 보여 주려면 <code>props.children</code> 값을 보여 주어야 합니다.</p><p>MyComponent.js 파일을 다음과 같이 수정합니다.</p><figure class="highlight jsx"><figcaption><span>MyComponent.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      제 이름은 &#123;props.name&#125;입니다. &lt;br /&gt;</span><br><span class="line">      children 값은 &#123;props.children&#125;입니다.</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  name: "기본 이름",</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><ul><li>브라우저에 결과물로 다음과 같이 나타납니다.<br><img src="/images/props_children.png" alt="defaultProps, props.children"></li></ul><hr><h3 id="비구조화-할당-문법을-통해-props-내부-값-추출"><a href="#비구조화-할당-문법을-통해-props-내부-값-추출" class="headerlink" title="비구조화 할당 문법을 통해 props 내부 값 추출"></a>비구조화 할당 문법을 통해 props 내부 값 추출</h3><p>현재 MyComponent.js에서 props 값을 조회할 때 마다 props.name, props.children 형태로 <code>props.</code> 키워드를 앞에 붙여 주고 있습니다. </p><p>이러한 작업을 더 편하기 위해 <strong>ES6의 비구조화 할당 문법을 사용하여 내부 값을 바로 추출하는 방법</strong>이 있습니다.</p><figure class="highlight jsx"><figcaption><span>MyComponent.js 수정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, children &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      제 이름은 &#123;name&#125;입니다. &lt;br /&gt;</span><br><span class="line">      children 값은 &#123;children&#125;입니다.</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  name: "기본 이름",</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><p>이렇게 코드를 작성하면 name, children 값을 더 짧은 코드로 작성할 수 있습니다.</p><p>이렇게 사용하는 방법을(객체에서 값을 추출하는 문법) 비구조화 할당(destructuring assignment)라고 부릅니다.</p><ul><li>비구조화 할당 문법은 <strong>함수의 파라미터 부분에서도 사용할 수 있습니다.</strong><br>만약 함수의 파라미터가 객체라면 그 값을 바로 비구조화해서 사용하는 것입니다.</li></ul><figure class="highlight jsx"><figcaption><span>함수의 파라미터에서 사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">&#123; name, children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      제 이름은 &#123;name&#125;입니다. &lt;br /&gt;</span><br><span class="line">      children 값은 &#123;children&#125;입니다.</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  name: "기본 이름",</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><hr><h3 id="propTypes를-통한-props-검증"><a href="#propTypes를-통한-props-검증" class="headerlink" title="propTypes를 통한 props 검증"></a>propTypes를 통한 props 검증</h3><ul><li><code>propTypes</code>:<br>컴포넌트의 필수 props를 지정하거나 props의 타입(type)을 지정할 때 사용</li></ul><ul><li>propTypes를 사용하려면 코드 상단에 import 구문을 사용하여 불러와야 합니다.</li></ul><figure class="highlight jsx"><figcaption><span>propTypes 사용하여 type 값 지정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">&#123; name, children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      제 이름은 &#123;name&#125;입니다. &lt;br /&gt;</span><br><span class="line">      children 값은 &#123;children&#125;입니다.</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  name: "기본 이름",</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  name: PropTypes.string</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><p>import 구문으로 propTypes를 불러와 <code>MyComponent.propTypes</code>를 위와 같이 설정해 주면<br>name 값은 무조건 문자열(string) 형태로 전달해야 된다는 것을 의미합니다.</p><p>App 컴포넌트 (부모 컴포넌트)에서 name 값을 문자열이 아닌 숫자로 전달하면 값은 표시되지만 콘솔창에 경고 메세지가 출력되며 개발자에게 propTypes이 잘못되었다는 것을 알려줍니다.</p><hr><h4 id="isRequired를-사용하여-필수-propTypes-설정"><a href="#isRequired를-사용하여-필수-propTypes-설정" class="headerlink" title="isRequired를 사용하여 필수 propTypes 설정"></a>isRequired를 사용하여 필수 propTypes 설정</h4><p>isRequired를 사용하여 propTypes를 지정하지 않았을 때 경고 메세지를 띄워 주는 작업을 해봅니다.</p><ul><li>propTypes를 지정할 때 뒤에 isRequired를 붙여 사용하면 됩니다.</li></ul><figure class="highlight jsx"><figcaption><span>isRequired 사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">&#123; name, children, favoriteNumber &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      제 이름은 &#123;name&#125;입니다. &lt;br /&gt;</span><br><span class="line">      children 값은 &#123;children&#125;입니다. &lt;br /&gt;</span><br><span class="line">      제가 좋아하는 숫자는 &#123;favoriteNumber&#125;입니다.</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  name: "기본 이름",</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  name: PropTypes.string,</span></span><br><span class="line"><span class="regexp">  favoriteNumber: PropTypes.number.isRequired,</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><p>favoriteNumber 값을 설정하지 않고 실행하면 에러가 발생합니다.<br><code>Warnig Failed prop type: The prop &#39;favoriteNumber&#39; is markes as requires in &#39;MyComponent&#39;, but its value is &#39;undefined&#39;.</code></p><p>MyComponent.js에게 favoriteNumber 값을 전달할 App.js에서 값을 전달해 줍니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(...)</span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;MyComponent name=<span class="string">"React"</span> favoriteNumber =&#123;<span class="number">1</span>&#125;&gt;</span><br><span class="line">    리액트</span><br><span class="line">    &lt;<span class="regexp">/MyComponent&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">(...)</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/facebook/prop-types">더 많은 PropTypes 종류 참고: https://github.com/facebook/prop-types</a></li></ul><hr><h3 id="클래스형-컴포넌트에서-props-사용하기"><a href="#클래스형-컴포넌트에서-props-사용하기" class="headerlink" title="클래스형 컴포넌트에서 props 사용하기"></a>클래스형 컴포넌트에서 props 사용하기</h3><p>클래스형 컴포넌트에서 props를 사용할 때는 render 함수에서 <code>this.props</code>를 조회하면 됩니다.</p><p>defaultProps와 propTypes는 똑같은 방식으로 설정할 수 있습니다.</p><figure class="highlight jsx"><figcaption><span>MyComponent 클래스형 컴포넌트로 변환</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, favoriteNumber, children &#125; = <span class="keyword">this</span>.props; <span class="comment">// 비구조화 할당</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        안녕하세요, 제 이름은 &#123;name&#125; 입니다. &lt;br /&gt;</span><br><span class="line">        children 값은 &#123;children&#125;입니다. &lt;br /&gt;</span><br><span class="line">        제가 좋아하는 숫자는 &#123;favoriteNumber&#125;입니다.</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  name: '기본 이름'</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  name: PropTypes.string,</span></span><br><span class="line"><span class="regexp">  favoriteNumber: PropTypes.number.isRequired</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><p><strong>defaultProps와 propTypes을 설정할 때 class 내부에서 지정하는 방법</strong>도 있습니다.</p><figure class="highlight jsx"><figcaption><span>defaultProps, propTypes class 내부에서 지정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123; <span class="comment">// class 내부에서 지정</span></span><br><span class="line">    name: <span class="string">'기본 이름'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    name: PropTypes.string,</span><br><span class="line">    favoriteNumber: PropTypes.number.isRequired</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, favoriteNumber, children &#125; = <span class="keyword">this</span>.props; <span class="comment">// 비구조화 할당</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        안녕하세요, 제 이름은 &#123;name&#125; 입니다. &lt;br /&gt;</span><br><span class="line">        children 값은 &#123;children&#125;입니다. &lt;br /&gt;</span><br><span class="line">        제가 좋아하는 숫자는 &#123;favoriteNumber&#125;입니다.</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><hr><h2 id="state">state</h2><p>리액트에서 state는 <strong>컴포넌트 내부에서 바뀔 수 있는 값을 의미합니다.</strong></p><ul><li>참고:<ul><li>props는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값입니다.</li><li>컴포넌트 자신은 props를 읽기 전용으로만 사용할 수 있습니다.</li><li>props를 바꾸려면 부모 컴포넌트에서 바꾸어 주어야 합니다.<br>(예를 들어 App 컴포넌트에서 MyComponent를 사용할 때 props를 바꾸어 주어야 값이 변경될 수 있습니다. MyComponent에서는 전달받은 값을 직접 바꿀 수 없습니다.)</li></ul></li></ul><p><strong>리액트에는 두 가지 종류의 state가 있습니다.</strong></p><ul><li><u>클래스형 컴포넌트가 지니고 있는 state</u></li><li><u>함수형 컴포넌트에서 useState 함수를 통해 사용하는 state</u></li></ul><hr><h3 id="클래스형-컴포넌트의-state"><a href="#클래스형-컴포넌트의-state" class="headerlink" title="클래스형 컴포넌트의 state"></a>클래스형 컴포넌트의 state</h3><figure class="highlight jsx"><figcaption><span>Counter 컴포넌트 만들어 보기 예제</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123; <span class="comment">// 클래스형 컴포넌트에서 constructor를 작성할 때는 반드시</span></span><br><span class="line">    <span class="keyword">super</span>(props); <span class="comment">// super(props)를 호출해 줘야함.</span></span><br><span class="line">    <span class="comment">// state 초기값 설정</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="comment">// 컴포넌트의 state는 객체 형식이어야함.</span></span><br><span class="line">      number = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; number &#125; = <span class="keyword">this</span>.state; <span class="comment">// state 를 조회 할 때에는 this.state 로 조회합니다.</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;number&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button </span></span><br><span class="line"><span class="regexp">          /</span><span class="regexp">/ onClick을 통해 버튼이 클릭되었을 때 호출할 함수를 지정합니다.</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          /</span><span class="regexp">/ this.setState를 사용하여 state에 새로운 값을 넣을 수 있습니다.</span></span><br><span class="line"><span class="regexp">          this.setState(&#123; number: number + 1 &#125;);</span></span><br><span class="line"><span class="regexp">        &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          +1</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Counter;</span></span><br></pre></td></tr></table></figure><ul><li><p>컴포넌트에 state를 설정할 때는 <code>constructor</code>(컴포넌트의 생성자 메서드) 메서드를 작성하여 설정합니다.</p><ul><li><p><strong>클래스형 컴포넌트에서 <code>constructor</code>를 작성할 때는 반드시 <code>super(props)</code>를 호출해 주어야 합니다.</strong></p></li><li><p><strong><code>super(props)</code>함수가 호출되면 현재 클래스형 컴포넌트가 상속받고 있는 리액트의 <code>Component 클래스</code>가 지닌 생성자 함수를 호출해 줍니다.</strong></p></li><li><p>그 다음에 this.state 값에 초기값을 설정해 줬습니다.<br><strong>컴포넌트의 state는 객체 형식이어야 합니다.</strong></p></li></ul></li><li><p>render() 함수에서 현재 state를 조회할 때는 <code>this.state</code>를 조회하면 됩니다.</p></li><li><p>button 안에 props로 넣어준 onClick 값은 버튼이 클릭될 때 호출시킬 함수를 설정할 수 있게 해줍니다. 이를 “이벤트를 설정한다”라고 합니다.</p></li><li><p>이벤트로 설정할 함수를 넣어줄 때는 화살표 함수를 사용해 넣어줍니다.</p></li><li><p>함수 내부에 사용된 <code>this.setState</code> 함수가 <code>state</code>값을 바꿀 수 있게 해 줍니다.</p></li></ul><p>작성된 Counter 컴포넌트를 App에서 불러와 렌더링합니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./Counter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><hr><h4 id="state를-constructor에서-꺼내기"><a href="#state를-constructor에서-꺼내기" class="headerlink" title="state를 constructor에서 꺼내기"></a>state를 constructor에서 꺼내기</h4><p><code>constructor</code>메서드를 선언하지 않고도 state 초깃값을 설정할 수 있는 방법이 있습니다.</p><figure class="highlight jsx"><figcaption><span>constructor 메서드 사용 x</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//constructor 선언 안하고 사용</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    number: <span class="number">0</span>,</span><br><span class="line">    fixedNumber: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">(...)</span><br><span class="line"><span class="comment">// constructor 메서드 사용시에는</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123; </span><br><span class="line">    <span class="keyword">super</span>(props); </span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      number = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">(...)</span><br></pre></td></tr></table></figure><p>이렇게 사용하면 constructor 메서드를 선언하지 않고도 state 초깃값을 설정할 수 있습니다.</p><hr><h4 id="this-setState에-객체-대신-함수-인자-전달"><a href="#this-setState에-객체-대신-함수-인자-전달" class="headerlink" title="this.setState에 객체 대신 함수 인자 전달"></a>this.setState에 객체 대신 함수 인자 전달</h4><p>this.setState를 사용하여 state 값을 업데이트할 때는 <u>상태가 비동기적으로 업데이트됩니다.</u></p><figure class="highlight jsx"><figcaption><span>onClick 내부에서 this.setState 두 번 호출</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onClick=&#123;() =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">number</span>: number + <span class="number">1</span>  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">number</span>: <span class="keyword">this</span>.state.number + <span class="number">1</span>  &#125;);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>이 처럼 작성하면 <code>this.setState</code>를 두 번 사용했음에도 버튼을 클릭할 때 숫자가 1씩 더해집니다.</p><p><code>this.setState</code>를 사용할 때 객체 대신에 함수를 인자로 넣어주어야 합니다.</p><figure class="highlight jsx"><figcaption><span>this.setState의 인자로 함수를 넣어주는 형태</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 업데이트할 내용</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>prevState</code>는 기존 상태를 의미하고, <code>props</code>는 현재 지니고 있는 props를 가리킵니다. (업데이트하는 과정에서 props가 필요하지 않다면 생략할 수 있습니다.)</p><p>코드를 수정하여 작성하면 다음과 같이 됩니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(...)</span><br><span class="line">onClick=&#123;() =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      number: prevState.number + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">    number: prevState.number + <span class="number">1</span></span><br><span class="line">  <span class="comment">// 위 코드와 아래 코드는 완전히 똑같은 기능을 하는 코드입니다.</span></span><br><span class="line">  <span class="comment">// 아래 코드는 함수에서 바로 객체를 반환한다는 의미입니다.</span></span><br><span class="line">  &#125;));</span><br><span class="line">(...)</span><br></pre></td></tr></table></figure><p>버튼을 클릭하면 이제 값이 2씩 올라갑니다.</p><hr><h4 id="this-setState가-끝난-후-특정-작업"><a href="#this-setState가-끝난-후-특정-작업" class="headerlink" title="this.setState가 끝난 후 특정 작업"></a>this.setState가 끝난 후 특정 작업</h4><p>setState를 사용하여 값을 업데이트하고 난 다음에 특정 작업을 하고 싶을 때</p><p><strong>setState의 두 번째 파라미터로 콜백(callback)함수를 등록하여 처리할 수 있습니다.</strong></p><figure class="highlight jsx"><figcaption><span>예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">onClick=&#123;() =&gt;&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(</span><br><span class="line">      &#123;</span><br><span class="line">        number: number + <span class="number">1</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 두 번째 파라미터로 콜백 함수 등록</span></span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'방금 setState 가 호출되었습니다.'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="함수형-컴포넌트에서-useState-사용"><a href="#함수형-컴포넌트에서-useState-사용" class="headerlink" title="함수형 컴포넌트에서 useState 사용"></a>함수형 컴포넌트에서 useState 사용</h3><p>리액트 16.8 이전 버전에서는 함수형 컴포넌트에서 state를 사용할 수 없었습니다. 하지만 16.8이후부터는 useState라는 함수를 사용하여 함수형 컴포넌트에서도 state를 사용할 수 있게 되었습니다.</p><p>이 과정에서 <code>Hooks</code>를 사용하게 되는데 <code>Hooks</code>의 종류는 다양하지만 여기서는 <code>useState</code>를 사용합니다.</p><hr><h3 id="useState-사용하기"><a href="#useState-사용하기" class="headerlink" title="useState 사용하기"></a>useState 사용하기</h3><figure class="highlight jsx"><figcaption><span>Say.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Say = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [message, setMessage] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> onClickEnter = <span class="function"><span class="params">()</span> =&gt;</span> setMessage(<span class="string">'안녕하세요!'</span>);</span><br><span class="line">  <span class="keyword">const</span> onClickLeave = <span class="function"><span class="params">()</span> =&gt;</span> setMessage(<span class="string">'안녕히 가세요!'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;onClickEnter&#125;&gt;입장&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;onClickLeave&#125;&gt;퇴장&lt;/</span>button&gt;</span><br><span class="line">      &lt;h1&gt;&#123;message&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Say;</span><br></pre></td></tr></table></figure><ol><li><p><code>useState</code> 함수의 인자에는 상태의 초깃값을 넣어줍니다.(‘’)</p><ul><li><p><strong>클래스형 컴포넌트에서 state 초깃값은 객체 형태로 넣어줘야합니다.</strong></p></li><li><p><strong>useState 에서는 객체가 아니어도 상관없습니다. 값 형태가 자유입니다.</strong></p></li></ul></li><li><p>useState 함수 호출시 배열이 반환됩니다. 배열의 첫 번째 요소는 현재 상태이고, 두 번째 요소는 상태를 바꿔주는 함수입니다. <strong>이 함수를 세터(Setter)함수라고 부릅니다.</strong></p></li></ol><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Say <span class="keyword">from</span> <span class="string">'./Say'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Say</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p><img src="/images/useState0.png" alt=""> <img src="/images/useState1.png" alt=""></p><p>클릭한 입장 버튼과 퇴장버튼에 따라 문구가 변하게 됩니다.</p><hr><h2 id="state_주의사항">state 사용시 주의 사항</h2><p>클래스형 컴포넌트든 함수형 컴포넌트든 state를 사용할 때는 주의해야 할 사항이 있습니다.</p><p><strong>state 값을 바꿔야 할 때는 setState 혹은 useState를 통해 전달받은 세터 함수를 사용해야 합니다.</strong></p><ul><li>배열이나 객체를 업데이트 할 때는<ol><li>사본을 생성하고 </li><li>사본에 값을 업데이트한 후</li><li>그 사본의 상태를 setState 혹은 세터 함수를 통해 업데이트합니다.</li></ol></li></ul><figure class="highlight jsx"><figcaption><span>사본을 만들어 업데이트하는 예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체</span></span><br><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> nextObject = &#123;...object, <span class="attr">b</span> : <span class="number">2</span>&#125;; <span class="comment">// 사본을 만들어 b 값만 덮어씀</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//배열</span></span><br><span class="line"><span class="keyword">const</span> array = &#123;</span><br><span class="line">  &#123; <span class="attr">id</span>:<span class="number">1</span>, <span class="attr">value</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>:<span class="number">2</span>, <span class="attr">value</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>:<span class="number">3</span>, <span class="attr">value</span>: <span class="literal">false</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextArray = array.concat(&#123; <span class="attr">id</span>: <span class="number">4</span> &#125;); <span class="comment">// 새 항목 추가</span></span><br><span class="line">nextArray.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.id !==<span class="number">2</span>); <span class="comment">// id가 2인 항목 제거</span></span><br><span class="line">nextArray.map(<span class="function"><span class="params">item</span> =&gt;</span> (item.id === <span class="number">1</span> ? &#123;...item, <span class="attr">value</span>: <span class="literal">false</span> &#125; : item)); </span><br><span class="line"><span class="comment">//id가 1인 항목의 value를 false로 설정</span></span><br></pre></td></tr></table></figure><ul><li>객체의 사본을 만들 때는 <code>spread</code> 연산자를 사용하여 처리합니다.</li></ul><ul><li>배열의 사본을 만들 때는 배열의 내장 함수들을 활용합니다.</li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/24/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-component/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JSX</title>
      <link>https://hdw0903.github.io/2020/05/22/JSX/</link>
      <guid>https://hdw0903.github.io/2020/05/22/JSX/</guid>
      <pubDate>Fri, 22 May 2020 09:28:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;리액트 컴포넌트에서 사용하는 JSX 문법&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/22/JSX/#JSX&quot;&gt;JSX란?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/22/JSX/#JSX_장점&quot;&gt;JSX의 장점&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/22/JSX/#JSX_문법&quot;&gt;JSX 문법&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;감싸인 요소&lt;/li&gt;
&lt;li&gt;자바스크립트 표현&lt;/li&gt;
&lt;li&gt;if 문 대신 조건부 연산자(삼항 연산자)&lt;/li&gt;
&lt;li&gt;AND 연산자(&amp;amp;&amp;amp;)를 사용한 조건부 렌더링&lt;/li&gt;
&lt;li&gt;undefined를 렌더링하지 않기&lt;/li&gt;
&lt;li&gt;인라인 스타일링&lt;/li&gt;
&lt;li&gt;class 대신 className&lt;/li&gt;
&lt;li&gt;꼭 닫아야 하는 태그&lt;/li&gt;
&lt;li&gt;주석&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>리액트 컴포넌트에서 사용하는 JSX 문법</p><ul><li><p><a href="/2020/05/22/JSX/#JSX">JSX란?</a></p></li><li><p><a href="/2020/05/22/JSX/#JSX_장점">JSX의 장점</a></p></li><li><p><a href="/2020/05/22/JSX/#JSX_문법">JSX 문법</a></p><ul><li>감싸인 요소</li><li>자바스크립트 표현</li><li>if 문 대신 조건부 연산자(삼항 연산자)</li><li>AND 연산자(&amp;&amp;)를 사용한 조건부 렌더링</li><li>undefined를 렌더링하지 않기</li><li>인라인 스타일링</li><li>class 대신 className</li><li>꼭 닫아야 하는 태그</li><li>주석</li></ul></li></ul><a id="more"></a><hr><h2 id="JSX">JSX란?</h2><p>JSX는 자바스크립트의 확장 문법이며 XML과 매우 비슷하게 생겼습니다.<br>이런 형식으로 작성한 코드는 브라우저에서 실행되기 전에 코드가 번들링되는 과정에서 바벨을 사용하여 일반 자바스크립트 형태의 코드로 변환됩니다.</p><figure class="highlight jsx"><figcaption><span>형태</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Hello &lt;b&gt;react&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 작성된 코드는 다음과 같이 변환됩니다.</p><figure class="highlight js"><figcaption><span>일반(ES5) 자바스크립트 형태의 코드로 변환</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">APP</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.creatElement(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="string">"Hello "</span>, React.creatElement(<span class="string">"b"</span>, <span class="literal">null</span>, <span class="string">"react"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 처럼 매번 <code>React.creatElement</code> 함수를 사용해야 한다면 불편할 것입니다.<br>JSX를 사용하여 더욱 편하게 UI를 렌더링할 수 있습니다.</p><hr><h2 id="JSX_장점">JSX의 장점</h2><ul><li>보기 쉽고 익숙함.<br>위의 자바스크립트를 사용한 코드와 JSX로 작성한 코드를 비교해 보면<br>JSX로 작성한 코드는 HTML과 비슷하므로 가독성이 높고 작성하기도 쉽습니다.</li></ul><ul><li>더욱 높은 활용도<br>JSX에서는 HTML 태그를 사용할 수 있을 뿐만 아니라, 앞으로 만들 컴포넌트도 JSX 안에서 작성할 수 있습니다.<br>컴포넌트를 마치 HTML 태그 쓰듯 그냥 작성합니다.</li></ul><figure class="highlight jsx"><figcaption><span>예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> serviceWorker <span class="keyword">from</span> <span class="string">'./serviceWorker'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line">serviceWorker.unregister();</span><br></pre></td></tr></table></figure><ul><li><p>참고: ReactDOM.render<br>이 코드는 컴포넌트를 페이지에 렌더링하는 역활을 하며, render-dom 모듈을 불러와 사용할 수 있습니다.<br>이 함수의 <strong>첫 번째 파라미터에는 페이지에 렌더링할 내용을 JSX형태로 작성</strong>하고, <strong>두 번째 파라미터에는 해당 JSX를 렌더링할 document 내부 요소를 설정합니다.</strong></p><p>여기서는 id가 root인 요소 안에 렌더링하게 설정된 것입니다.</p></li></ul><hr><h2 id="JSX_문법">JSX 문법</h2><p>JSX를 올바르게 사용하려면 몇 가지 규칙을 준수해야 합니다.</p><hr><h3 id="감싸인-요소"><a href="#감싸인-요소" class="headerlink" title="감싸인 요소"></a>감싸인 요소</h3><p><strong>컴포넌트에 여러 요소가 있다면 반드시 부모 요소 하나로 감싸야 합니다.</strong></p><figure class="highlight jsx"><figcaption><span>요소 여러 개가 부모요소로 감싸져 있지 않다면 오류 발생</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;리액트 안녕&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;잘 작동하니?&lt;/</span>h2&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p><strong>요소 여러 개가 부모 요소 하나에 의하여 감싸져 있지 않으면 오류가 발생합니다.</strong></p><ul><li>이런 오류가 나는 이유는 <strong>Virtual DOM에서 컴포넌트 변화를 감지할 때 효율적으로 비교할 수 있도록 리액트 컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져야 한다는 규칙이 있기 때문입니다.</strong>  </li></ul><figure class="highlight jsx"><figcaption><span>div로 감싼 해결법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;리액트 안녕&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;잘 작동하니?&lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>이렇듯 요소를 <code>div</code>태그로 감싸주면 에러를 해결할 수 있습니다.<br>하지만 <code>div</code>태그를 사용하고 싶지 않은 경우에는 리액트 v16 이상 부터 도입된 <code>Fragment</code> 기능을 사용하면 됩니다.</p><figure class="highlight jsx"><figcaption><span>Fragment 사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;h1&gt;리액트 안녕&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;잘 작동하니?&lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>코드 상단 <code>import</code>구문에서 <code>react</code> 모듈에 들어 있는 <code>Fragment</code>라는 컴포넌트를 추가로 불러옵니다.<br><code>Fragment</code>는 다음과 같은 형태로도 표현할 수 있습니다.</p><figure class="highlight jsx"><figcaption><span>Fragment 생략</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;리액트 안녕&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;잘 작동하니?&lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>위 예시 모두 정상적으로 작동하는 경우는 다음과 같은 화면이 브라우저에 출력될 것입니다.</p><p><img src="/images/React_app.png" alt="정상 작동 결과물"></p><hr><h3 id="자바스크립트-표현"><a href="#자바스크립트-표현" class="headerlink" title="자바스크립트 표현"></a>자바스크립트 표현</h3><p>JSX 안에서는 자바스크립트 표현식을 쓸 수 있습니다.<br>자바스크립트 표현식을 작성하려면 JSX 내부에서 코드를 중괄호{}로 감싸면 됩니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;name&#125; 안녕&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;잘 작동하니?&lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p><code>const name= &quot;리액트&quot;;</code>로 선언해주고 중괄호{}안에 <code>name</code>을 작성하여 표현식으로 사용했습니다.</p><hr><h3 id="if-문-대신-조건부-연산자-삼항-연산자"><a href="#if-문-대신-조건부-연산자-삼항-연산자" class="headerlink" title="if 문 대신 조건부 연산자(삼항 연산자)"></a>if 문 대신 조건부 연산자(삼항 연산자)</h3><p><strong>JSX 내부의 자바스크립트 표현식에서 if 문을 사용할 수 없습니다.</strong></p><p>따라서 조건에 따라 다른 내용을 렌더링해야 할 때는 </p><ul><li><p>JSX 밖에서 if 문을 사용하여 사전에 값을 설정하거나</p></li><li><p>{ } 안에 조건부 연산자를 사용하면 됩니다. (조건부 연산자 === 삼항 연산자)</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;name === <span class="string">"리액트"</span> ?(</span><br><span class="line">        &lt;h1&gt;리액트입니다.&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      ):(</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;리액트가 아닙니다.&lt;/</span>h2&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>이렇게 코드를 작성한 후 저장하면 브라우저에서 ‘리액트입니다.’라는 문구를 볼 수 있습니다.</p><p>여기서 <code>name</code> 값을 바꾸면(!===리액트) ‘리액트가 아닙니다.’ 문구가 나타날 것입니다.</p><hr><h3 id="AND-연산자-amp-amp-를-사용한-조건부-렌더링"><a href="#AND-연산자-amp-amp-를-사용한-조건부-렌더링" class="headerlink" title="AND 연산자(&amp;&amp;)를 사용한 조건부 렌더링"></a>AND 연산자(&amp;&amp;)를 사용한 조건부 렌더링</h3><p>특정 조건을 만족할 때 내용을 보여주고, 만족하지 않을 때는 아무것도 렌더링 하지 않고자 할 때 사용하는 법</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;name === "리액트" &amp;&amp; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>리액트입니다.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>물론 삼항 연산자로 <code>{name === &quot;리액트&quot; ? &lt;h1&gt;리액트입니다.&lt;/h1&gt; : null}</code> 형태로 작성할 수도 있지만<br>&amp;&amp; 연산자로는 예제 처럼 더 짧은 코드로 작업할 수 있습니다.</p><ul><li>&amp;&amp; 연산자로 조건부 렌더링을 할 수 있는 이유는 <strong>리액트에서 false를 렌더링할 때는 null과 마찬가지로 아무것도 나타나지 않기 때문입니다.</strong></li></ul><ul><li>한가지 주의할 점은 0값은 예외적으로 화면에 나타난다는 것입니다.</li></ul><hr><h3 id="undefined를-렌더링하지-않기"><a href="#undefined를-렌더링하지-않기" class="headerlink" title="undefined를 렌더링하지 않기"></a>undefined를 렌더링하지 않기</h3><p>리액트 컴포넌트에서는 함수에서 undefined만 반환하여 렌더링 하는 상황을 만들면 안 됩니다.</p><p>다음과 같은 코드는 오류를 발생시킵니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"><span class="comment">// App(...): Nothing was returned from render. ......</span></span><br></pre></td></tr></table></figure><p>값이 undefined일 수도 있다면 OR(||)연산자를 사용하면 해당 값이 undefined일 때 사용할 값을 지정해 줄 수 있으므로 간단히 오류를 방지할 수 있습니다.</p><p><code>return name;</code> &gt; <code>return name || &quot;값이 undefined입니다&quot;;</code></p><ul><li><strong>반면 JSX 내부에서 undefined를 렌더링하는 것은 괜찮습니다.</strong></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><hr><h3 id="인라인-스타일링"><a href="#인라인-스타일링" class="headerlink" title="인라인 스타일링"></a>인라인 스타일링</h3><p>리액트에서 DOM 요소에 스타일을 적용할 때는 객체 형태로 넣어 주어야 합니다.<br>스타일 이름 중에 background-color 처럼 하이픈(-) 문자가 포함되어 있는 경우<br>카멜 표기법(camelCase)으로 작성합니다. backgroundColor</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">const</span> style = &#123;</span><br><span class="line">    backgroundColor: <span class="string">"black"</span>, <span class="comment">// background-color -&gt; backgroundColor</span></span><br><span class="line">    color: <span class="string">"aqua"</span>,</span><br><span class="line">    fontSize: <span class="string">"48px"</span>, <span class="comment">// font-size -&gt; fontSize</span></span><br><span class="line">    fontWeight: <span class="string">"bold"</span>, <span class="comment">// font-weight -&gt; fontWeight</span></span><br><span class="line">    padding: <span class="number">16</span> <span class="comment">// 단위 생략시 px로 지정됨</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>style 객체를 미리 선언하고 div의 style 값으로 지정해 주었습니다.<br>만약 미리 선언하지 않고 div에 style 값을 바로 지정하고 싶다면 아래와 같이 작성합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div</span><br><span class="line">      style=&#123;&#123;</span><br><span class="line">        backgroundColor: <span class="string">"black"</span>, <span class="comment">// background-color -&gt; backgroundColor</span></span><br><span class="line">        color: <span class="string">"aqua"</span>,</span><br><span class="line">        fontSize: <span class="string">"48px"</span>, <span class="comment">// font-size -&gt; fontSize</span></span><br><span class="line">        fontWeight: <span class="string">"bold"</span>, <span class="comment">// font-weight -&gt; fontWeight</span></span><br><span class="line">        padding: <span class="number">16</span>, <span class="comment">// 단위 생략시 px로 지정됨</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;name&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p><img src="/images/divStyle.png" alt="결과물"></p><hr><h3 id="class-대신-className"><a href="#class-대신-className" class="headerlink" title="class 대신 className"></a>class 대신 className</h3><p>일반 HTML에서 CSS 클래스를 사용할 때는 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"myclass"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>와 같이 class라는 속성을 설정합니다.</p><p><strong>하지만 JSX에서는 class가 아닌 className으로 설정해 줘야합니다.</strong></p><ul><li>우선 App.css 파일을 열어 새 css 클래스를 작성해줬습니다.</li></ul><figure class="highlight css"><figcaption><span>App.css</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.react</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: aqua;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>이제 App.js 파일에서 상단에 App.css를 불러온 뒤 div 요소에 className값을 지정해줍니다.</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./App.css"</span>; <span class="comment">// CSS 불러옴</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"react"</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>; <span class="comment">// class가 아닌 className</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><ul><li><p>결과물<br><img src="/images/JSX4.png" alt="결과물"></p></li><li><p>JSX를 작성할 때 CSS 클래스를 설정하는 과정에서 <strong>className이 아닌 class 값을 설정해도 스타일이 적용되지만 브라우저 개발자 도구에서 경고가 나타납니다.</strong><br><img src="/images/Warningclass.png" alt="className이 아닌 class값 설정시"></p></li></ul><p><del>이전에는 오류만 발생하고 CSS 클래스가 적용되지 않았지만,</del><br><u>리액트 v16 이상부터는 class를 className으로 변환시켜 주고 경고를 띄웁니다.</u></p><hr><h3 id="꼭-닫아야-하는-태그"><a href="#꼭-닫아야-하는-태그" class="headerlink" title="꼭 닫아야 하는 태그"></a>꼭 닫아야 하는 태그</h3><p>HTML 코드를 작성할 때는 닫지 않는 상태로 코드를 작성하기도 합니다.<br>ex) <code>&lt;input&gt;&lt;/input&gt;</code>으로 입력하지 않고 <code>&lt;input&gt;</code></p><p><strong>JSX에서는 태그를 닫지 않으면 오류가 발생합니다.</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./App.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div className=<span class="string">"react"</span>&gt;&#123;name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input&gt; </span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>이러한 닫혀있지 않은 태그(input)는 <code>&lt;input&gt;&lt;/input&gt;</code> 이나 <code>&lt;input /&gt;</code> 형태로 닫아줘야 합니다.</p><hr><h3 id="주석"><a href="#주석" class="headerlink" title="주석"></a>주석</h3><p>JSX 안에서 주석을 작성하는 방법은 일반 자바스크립트에서 주석을 작성하는 방법과 조금 다릅니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">'리액트'</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;<span class="comment">/* 주석은 이렇게 작성합니다. */</span>&#125;</span><br><span class="line">      &lt;div</span><br><span class="line">        className=<span class="string">"react"</span> <span class="comment">// 시작 태그를 여러 줄로 작성하게 된다면 여기에 주석을 작성 할 수 있습니다.</span></span><br><span class="line">      &gt;</span><br><span class="line">        &#123;name&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 하지만 이런 주석이나 </span></span><br><span class="line"><span class="regexp">      /</span>* 이런 주석은 페이지에 그대로 나타나게 됩니다. *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">      &lt;input /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><ul><li>JSX 내부에서 주석을 작성할 때는 {/* … */}와 같은 형식으로 작성합니다.</li></ul><ul><li>시작 태그를 여러 줄로 작성할 때는 그 내부에서 //…과 같은 형태의 주석도 작성할 수 있습니다.</li></ul><ul><li>일반 자바스크립트에서 주석을 작성할 때처럼 아무 데나 주석을 작성하면 페이지에 고스란히 나타납니다.</li></ul><ul><li>브라우저 창에 출력시<br><img src="/images/React_%EC%A3%BC%EC%84%9D.png" alt="React 주석"></li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/22/JSX/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 이해, 특징</title>
      <link>https://hdw0903.github.io/2020/05/21/React-%EC%9D%B4%ED%95%B4-%ED%8A%B9%EC%A7%95/</link>
      <guid>https://hdw0903.github.io/2020/05/21/React-%EC%9D%B4%ED%95%B4-%ED%8A%B9%EC%A7%95/</guid>
      <pubDate>Thu, 21 May 2020 13:12:41 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;리액트-기초&quot;&gt;&lt;a href=&quot;#리액트-기초&quot; class=&quot;headerlink&quot; title=&quot;리액트 기초&quot;&gt;&lt;/a&gt;리액트 기초&lt;/h2&gt;&lt;p&gt;리액트는 페이스북 개발 팀이 만든 자바스크립트 라이브러리입니다.&lt;/p&gt;
&lt;p&gt;기존의 어떤 데이터가 변할 때마다 어떤 변화를 주는 방식이 아닌 기존 뷰를 날려 버리고 새로 렌더링하는 방식입니다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="리액트-기초"><a href="#리액트-기초" class="headerlink" title="리액트 기초"></a>리액트 기초</h2><p>리액트는 페이스북 개발 팀이 만든 자바스크립트 라이브러리입니다.</p><p>기존의 어떤 데이터가 변할 때마다 어떤 변화를 주는 방식이 아닌 기존 뷰를 날려 버리고 새로 렌더링하는 방식입니다.</p><a id="more"></a><hr><h3 id="리액트-이해"><a href="#리액트-이해" class="headerlink" title="리액트 이해"></a>리액트 이해</h3><p>리액트는 자바스크립트 라이브러리로 사용자 인터페이스를 만드는 데 사용합니다.</p><p>구조가 MVC(Model-View-Controller), MVW(Model-View-Whatever) 등인 프레임워크와 달리,</p><p><strong>오직 V(View)만 신경 쓰는 라이브러리입니다.</strong></p><hr><h4 id="컴포넌트-component"><a href="#컴포넌트-component" class="headerlink" title="컴포넌트(component)"></a>컴포넌트(component)</h4><p>리액트 프로젝트에는 <strong>특정 부분이 어떻게 생길지 정하는 선언체가 있는데, 이를 컴포넌트(component)라고 합니다.</strong></p><p>컴포넌트는 다른 프레임워크에서 사용자 인터페이스를 다룰 때 사용하는 템플릿과는 다른 개념입니다.<br>템플릿은 보통 데이터셋이 주어지면 HTML 태그 형식을 문자열로 반환하는데,</p><p>컴포넌트는 재사용이 가능한 API로 수만은 기능을 내장하고 있고, 컴포넌트 하나에서 해당 컴포넌트의 생김새와 작동 방식을 정의합니다. </p><hr><h4 id="렌더링-rendering"><a href="#렌더링-rendering" class="headerlink" title="렌더링(rendering)"></a>렌더링(rendering)</h4><p><strong>사용자 화면에 뷰를 보여주는 것을 렌더링이라고 합니다.</strong></p><p>리액트 라이브러리는 데이터가 변할 때마다 새롭게 리렌더링 하면서도 성능을 아끼는 렌더링 방식을 사용하는데 이를 이해하려면 </p><ul><li><p><strong>리액트 컴포넌트가 최초로 실행한 “초기 렌더링”</strong>과 </p></li><li><p><strong>컴포넌트의 데이터 변경으로 다시 실행되는 “리렌더링”</strong>을 이해해야 합니다.</p></li></ul><hr><h4 id="초기-렌더링"><a href="#초기-렌더링" class="headerlink" title="초기 렌더링"></a>초기 렌더링</h4><p>어떤 UI 관련 프레임워크, 라이브러리를 사용하든지 맨 처음 어떻게 보일지를 정하는 초기 렌더링이 필요합니다.</p><p>리액트에서는 이를 다루는 <code>render</code> 함수가 있습니다.</p><blockquote><p>render() {…}</p></blockquote><ul><li><code>render()</code> 함수는 <strong>컴포넌트가 어떻게 생겼는지 정의하는 역활</strong>을 합니다.</li></ul><ul><li><code>render()</code> 함수는 HTML 형식의 문자열을 반환하는 것이 아닌 <strong>뷰가 어떻게 생겼고 어떻게 작동하는지에 대한 정보를 지닌 객체를 반환합니다.</strong></li></ul><hr><h4 id="조화-과정"><a href="#조화-과정" class="headerlink" title="조화 과정"></a>조화 과정</h4><p>리액트에서 뷰를 업데이트할 때는 “업데이트 과정을 거친다”라고 하기보다 “조화 과정(reconsiliation)을 거친다”라고 합니다.</p><p><strong>컴포넌트에서 데이터에 변화가 있을 때 변화에 따라 뷰가 변형되는 것처럼 보이지만, 사실은 새로운 요소로 갈아 끼우기 때문입니다.</strong></p><p>이 작업 또한 render 함수가 맡아서 합니다.<br>컴포넌트는 데이터를 업데이트했을 때 업데이트한 값을 수정하는 것이 아니라, 새로운 데이터를 가지고 render 함수를 또다시 호출합니다.</p><p>이 작업에서 render 함수가 반환하는 결과를 곧바로 DOM에 반영하지 않고<br><strong>이전에 render 함수가 만들었던 컴포넌트 정보와 현재 render 함수가 만든 컴포넌트 정보를 비교합니다.</strong></p><hr><h3 id="리액트-특징"><a href="#리액트-특징" class="headerlink" title="리액트 특징"></a>리액트 특징</h3><p>리액트의 주요 특징 중 하나는 Virtual DOM을 사용하는 것입니다.</p><hr><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>DOM(Document Object Model)은 문자 그대로 문서 객체 모델입니다. </p><p>객체로 문서 구조를 표현하는 방법으로 XML이나 HTML로 작성합니다.</p><p><strong>DOM은 트리 구조</strong>이므로 특정 노드를 찾거나, 수정, 제거, 원하는 곳에 삽입할 수 있습니다.</p><p><img src="/images/DOM.png" alt="DOM 트리"></p><p>웹에서 DOM에 변화가 일어나면 웹 브라우저는 CSS를 다시 연산하고, 레이아웃을 구성하고, 페이지를 리페인트하게 되고 성능 저하가 일어날 수 있습니다.</p><p>이러한 DOM을 최소한으로 조작하여 처리하는 방식으로 나온 방법이 <code>Virtual DOM</code>입니다.</p><hr><h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p>리액트는 Virtual DOM 방식을 사용하여 실제 DOM에 접근하여 조작하는 대신 <strong>DOM 업데이트를 추상화한 자바스크립트 객체를 구성하여 사용함으로써 DOM 처리 횟수를 최소화하고 효율적으로 진행합니다.</strong></p><ul><li><p>리액트에서 데이터가 변하여 웹 브라우저에 실제 DOM을 업데이트를할 때는 다음 3가지 과정을 거칩니다.</p><ol><li><p>데이터를 업데이트하면 전체 UI를 Virtual DOM에 리렌더링합니다.</p></li><li><p>이전 Virtual DOM에 있던 내용과 현제 내용을 비교합니다.</p></li><li><p>바뀐 부분만 실제 DOM에 적용합니다.</p></li></ol></li></ul><p><img src="/images/VirtualDOM.png" alt="이전 DOM 트리, 새로운 DOM 트리"></p><p>오른쪽의 “새로운 DOM 트리”가 바로 <code>Virtual DOM</code>입니다.</p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/21/React-%EC%9D%B4%ED%95%B4-%ED%8A%B9%EC%A7%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>VS Code Extension Prettier 설치와 예외 처리</title>
      <link>https://hdw0903.github.io/2020/05/21/VS-Code-Extension-Prettier-%EC%84%A4%EC%B9%98%EC%99%80-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC/</link>
      <guid>https://hdw0903.github.io/2020/05/21/VS-Code-Extension-Prettier-%EC%84%A4%EC%B9%98%EC%99%80-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC/</guid>
      <pubDate>Thu, 21 May 2020 12:13:56 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Prettier-란&quot;&gt;&lt;a href=&quot;#Prettier-란&quot; class=&quot;headerlink&quot; title=&quot;Prettier 란?&quot;&gt;&lt;/a&gt;Prettier 란?&lt;/h3&gt;&lt;p&gt;VS Code Extension 중의 하나인 Prettier는 코드 스타일을 자동으로 정리해주는 도구입니다.&lt;/p&gt;
&lt;p&gt;들여쓰기(공백 문자), 세미콜론(;)이 빠진곳, 작은따옴표(‘’)등을 자동으로 추가 및 변경해줍니다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="Prettier-란"><a href="#Prettier-란" class="headerlink" title="Prettier 란?"></a>Prettier 란?</h3><p>VS Code Extension 중의 하나인 Prettier는 코드 스타일을 자동으로 정리해주는 도구입니다.</p><p>들여쓰기(공백 문자), 세미콜론(;)이 빠진곳, 작은따옴표(‘’)등을 자동으로 추가 및 변경해줍니다.</p><a id="more"></a><hr><h3 id="Prettier-설치"><a href="#Prettier-설치" class="headerlink" title="Prettier 설치"></a>Prettier 설치</h3><p>VS Code 마켓플레이스에서 Prettier를 검색하여 설치해 줍니다.</p><p><img src="/images/Prettier.png" alt="Prettier"></p><p>설치 후 정리를 원하는 파일에서 F1을 누르고 format을 입력한다음 엔터를 누르면 Prettier가 자동으로 코드를 정리해 줍니다.</p><hr><h4 id="저장할-때-자동으로-코드-정리하기"><a href="#저장할-때-자동으로-코드-정리하기" class="headerlink" title="저장할 때 자동으로 코드 정리하기"></a>저장할 때 자동으로 코드 정리하기</h4><p>매번 F1을 눌러 format을 입력하거나 단축키를 이용해 정리하는 것보다 편한 저장할 때 정리하게 만드는 법이 있습니다.</p><p>VS Code의 설정에 들어가 format on save를 검색하여 체크 박스를 체크해주면 됩니다.</p><p><img src="/images/Prettier_OnSave.png" alt="Prettier 저장할 때 자동으로 코드 정리"></p><hr><h3 id="Prettier-예외-설정"><a href="#Prettier-예외-설정" class="headerlink" title="Prettier 예외 설정"></a>Prettier 예외 설정</h3><p>편하게 사용하려고 format on save 설정을 켜놨더니 원치 않은 경우에도 적용되어 곤란해졌습니다.</p><p>저의 경우에는 블로그 작성시 사용하는 MarkDown(.md)파일들의 공백이 원치 않게 변경되어 예외 처리가 필요해졌습니다.</p><ul><li>예외 처리</li></ul><p>예외 처리할 폴더의 root 폴더에 .prettierignore 파일을 만들어 줍니다.<br>저의 경우 <code>..\..\myblog\source\_posts</code> 경로와 <code>..\..\myblog\scaffolds</code> 경로의 .md 파일들을 예외 처리 하기위해 myblog 내부에 .prettierignore 파일을 만들었습니다.</p><p>.prettierignore 파일 안에 *.md를 작성하면 끝입니다.</p><p><img src="/images/prettierignore.png" alt="Prettier MarkDown예외 설정"></p><p>이제 더이상 Prettier가 MarkDown 파일을 변경하지 않습니다.</p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/21/VS-Code-Extension-Prettier-%EC%84%A4%EC%B9%98%EC%99%80-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC/#disqus_thread</comments>
    </item>
    
    <item>
      <title>VS Code 유용한 Extension -ESLint</title>
      <link>https://hdw0903.github.io/2020/05/21/VS-Code-%EC%9C%A0%EC%9A%A9%ED%95%9C-Extension-ESLint/</link>
      <guid>https://hdw0903.github.io/2020/05/21/VS-Code-%EC%9C%A0%EC%9A%A9%ED%95%9C-Extension-ESLint/</guid>
      <pubDate>Thu, 21 May 2020 11:39:03 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;ESLint란&quot;&gt;&lt;a href=&quot;#ESLint란&quot; class=&quot;headerlink&quot; title=&quot;ESLint란?&quot;&gt;&lt;/a&gt;ESLint란?&lt;/h3&gt;&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt; 문법 검사 도구로 사용자가 직접 정의한대로 코드를 점검하고, 에러가 있으면 표시해줍니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;에디터에 &lt;span style=&quot;color: green;&quot;&gt;초록색&lt;/span&gt;으로 줄이 그어진 코드는 고치기 싫으면 무시할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;하지만 &lt;span style= &quot;color: red;&quot;&gt;빨간색&lt;/span&gt; 줄이 그어진 코드는 반드시 고쳐야합니다.&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="ESLint란"><a href="#ESLint란" class="headerlink" title="ESLint란?"></a>ESLint란?</h3><p><code>JavaScript</code> 문법 검사 도구로 사용자가 직접 정의한대로 코드를 점검하고, 에러가 있으면 표시해줍니다.</p><ul><li>에디터에 <span style="color: green;">초록색</span>으로 줄이 그어진 코드는 고치기 싫으면 무시할 수 있습니다.</li></ul><ul><li>하지만 <span style= "color: red;">빨간색</span> 줄이 그어진 코드는 반드시 고쳐야합니다.</li></ul><a id="more"></a><hr><h3 id="ESLint-설치"><a href="#ESLint-설치" class="headerlink" title="ESLint 설치"></a>ESLint 설치</h3><p>VS Code 마켓플레이스 에서 ESLint를 검색하여 설치해 줍니다.</p><p><img src="/images/ESLint.png" alt="ESLint"></p><ul><li>설치 후 에디터를 재실행하고 나면 JavaScript 문법을 점검하여 오류가 있으면 알려줍니다.</li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/21/VS-Code-%EC%9C%A0%EC%9A%A9%ED%95%9C-Extension-ESLint/#disqus_thread</comments>
    </item>
    
    <item>
      <title>VS Code 터미널 관리자모드로 실행</title>
      <link>https://hdw0903.github.io/2020/05/21/VS-Code-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%B4%80%EB%A6%AC%EC%9E%90%EB%AA%A8%EB%93%9C%EB%A1%9C-%EC%8B%A4%ED%96%89/</link>
      <guid>https://hdw0903.github.io/2020/05/21/VS-Code-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%B4%80%EB%A6%AC%EC%9E%90%EB%AA%A8%EB%93%9C%EB%A1%9C-%EC%8B%A4%ED%96%89/</guid>
      <pubDate>Thu, 21 May 2020 11:21:07 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;이-시스템에서-스크립트를-실행할-수-없으므로-해결법&quot;&gt;&lt;a href=&quot;#이-시스템에서-스크립트를-실행할-수-없으므로-해결법&quot; class=&quot;headerlink&quot; title=&quot;이 시스템에서 스크립트를 실행할 수 없으므로 해결법&quot;&gt;&lt;/a&gt;이 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="이-시스템에서-스크립트를-실행할-수-없으므로-해결법"><a href="#이-시스템에서-스크립트를-실행할-수-없으므로-해결법" class="headerlink" title="이 시스템에서 스크립트를 실행할 수 없으므로 해결법"></a>이 시스템에서 스크립트를 실행할 수 없으므로 해결법</h3><p>VSCode 의 터미널(Terminal)로 Hexo server등을 실행하면<br>이 시스템에서 스크립트를 실행할 수 없으므로 어쩌구 저쩌구 오류가 나온다.</p><ol><li>windows PowerShell 프로그램을 관리자 권한으로 실행한다.</li></ol><ol start="2"><li>Set-ExecutionPolicy RemoteSigned 입력후 엔터</li></ol><p><img src="/images/powerShell.png" alt="스크립트 실행 규칙 변경"></p><ol start="3"><li>y 엔터</li></ol><p>이제 VS Code로 돌아가 터미널에서 실행해보면 잘 작동한다.</p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/21/VS-Code-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%B4%80%EB%A6%AC%EC%9E%90%EB%AA%A8%EB%93%9C%EB%A1%9C-%EC%8B%A4%ED%96%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>VS Code 단축키 변경, 자동 저장 기능</title>
      <link>https://hdw0903.github.io/2020/05/21/VS-Code-%EB%8B%A8%EC%B6%95%ED%82%A4-%EB%B3%80%EA%B2%BD-%EC%9E%90%EB%8F%99-%EC%A0%80%EC%9E%A5-%EA%B8%B0%EB%8A%A5/</link>
      <guid>https://hdw0903.github.io/2020/05/21/VS-Code-%EB%8B%A8%EC%B6%95%ED%82%A4-%EB%B3%80%EA%B2%BD-%EC%9E%90%EB%8F%99-%EC%A0%80%EC%9E%A5-%EA%B8%B0%EB%8A%A5/</guid>
      <pubDate>Thu, 21 May 2020 11:00:28 GMT</pubDate>
      <description>
      
        &lt;p&gt;VS Code의 제안 기능? (Ctrl +Space) 단축키가 불편하여 변경했다.&lt;/p&gt;
&lt;p&gt;추가로 자동 저장 기능도 설정한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>VS Code의 제안 기능? (Ctrl +Space) 단축키가 불편하여 변경했다.</p><p>추가로 자동 저장 기능도 설정한다.</p><a id="more"></a><hr><h3 id="단축키-설정"><a href="#단축키-설정" class="headerlink" title="단축키 설정"></a>단축키 설정</h3><p>단축키 설정은 <img src="/images/%EB%8B%A8%EC%B6%95%ED%82%A4.png" alt="VS Code 단축키 설정"></p><p>VS Code 에디터 좌측 하단 톱니바퀴를 누르거나 Ctrl+k Ctrl+S로 들어갈 수 있다.</p><p>내가 변경 하고자한 단축키의 이름은 제안 항목 트리거 라고 한다..</p><p><img src="/images/%EC%A0%9C%EC%95%88%ED%95%AD%EB%AA%A9%ED%8A%B8%EB%A6%AC%EA%B1%B0.png" alt="제안 항목 트리거 단축키 변경"></p><p>단축키 부분을 더블 클릭하여 기존의 Ctrl + Space를 Shift + 2로 변경해 줬다.<br>새끼 손가락이 덜아파 행복하다.</p><p><del>특수문자 @를 쓸때마다 아주 곤란하다… 하지만 자주 쓸일이 없으니 대충 쓴다.</del></p><hr><h3 id="VS-Code-자동-저장-기능"><a href="#VS-Code-자동-저장-기능" class="headerlink" title="VS Code 자동 저장 기능"></a>VS Code 자동 저장 기능</h3><p>한번 설정해 놓으면 아주 편한 자동 저장 기능</p><p>이제 매번 Ctrl + S로 저장해줄 필요가 없다.</p><p>마찬가지로 VS Code 에디터에서 톱니바퀴를 누르고 이번에는 <code>설정</code>으로 들어간다.</p><p><img src="/images/autoSave.png" alt="AutoSave"></p><ul><li><p>일반적으로 사용되는 설정 &gt; onFocusChange 항목에서 원하는 항목으로 설정한다.<br><del>개인적으로 onFocusChage가 편해서 사용중</del></p></li><li><p>Auto Save Delay<br>afterDelay로 설정시 지연시간 (ms) 설정</p></li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/21/VS-Code-%EB%8B%A8%EC%B6%95%ED%82%A4-%EB%B3%80%EA%B2%BD-%EC%9E%90%EB%8F%99-%EC%A0%80%EC%9E%A5-%EA%B8%B0%EB%8A%A5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>VS Code 한글 설정</title>
      <link>https://hdw0903.github.io/2020/05/21/VS-Code-%ED%95%9C%EA%B8%80-%EC%84%A4%EC%A0%95/</link>
      <guid>https://hdw0903.github.io/2020/05/21/VS-Code-%ED%95%9C%EA%B8%80-%EC%84%A4%EC%A0%95/</guid>
      <pubDate>Thu, 21 May 2020 10:08:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;VS-Code-언어-한국어로-설정하기&quot;&gt;&lt;a href=&quot;#VS-Code-언어-한국어로-설정하기&quot; class=&quot;headerlink&quot; title=&quot;VS Code 언어 한국어로 설정하기&quot;&gt;&lt;/a&gt;VS Code 언어 한국어로 설정하기&lt;/h3&gt;&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="VS-Code-언어-한국어로-설정하기"><a href="#VS-Code-언어-한국어로-설정하기" class="headerlink" title="VS Code 언어 한국어로 설정하기"></a>VS Code 언어 한국어로 설정하기</h3><p>VS Code를 열어 좌측에 확장 마켓플레이스를 클릭해 줍니다.</p><p><img src="/images/market.png" alt="VS Code 마켓플레이스"></p><p>Korean Language Pack for Visual Studio Code를 검색하여 설치합니다.</p><p><img src="/images/Language_Pack.png" alt="Korean Language Pack for Visual Studio Code"></p><p>설치 후 F1을 누른 후 Configure Display Language를 입력하여 “ko” 값으로 설정 후 재시작 해주면 끝</p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/21/VS-Code-%ED%95%9C%EA%B8%80-%EC%84%A4%EC%A0%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Array.prototype. map, filter, reduce 구현하기</title>
      <link>https://hdw0903.github.io/2020/05/19/Array-prototype-map-filter-reduce-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/</link>
      <guid>https://hdw0903.github.io/2020/05/19/Array-prototype-map-filter-reduce-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Tue, 19 May 2020 12:53:01 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;code&gt;React&lt;/code&gt; 입문전에 &lt;code&gt;Array&lt;/code&gt; 메소드 &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;를 확실히 알고&lt;br&gt;구현해 만들어보는 것이 도움이 된다길래 한번 만들어 봤습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/19/Array-prototype-map-filter-reduce-구현하기/#map&quot;&gt;Array.prototype.map&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;map 원리&lt;/li&gt;
&lt;li&gt;map 메소드 만들어보기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/19/Array-prototype-map-filter-reduce-구현하기/#filter&quot;&gt;Array.prototype.filter&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filter 원리&lt;/li&gt;
&lt;li&gt;filter 메소드 만들어보기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/19/Array-prototype-map-filter-reduce-구현하기/#reduce&quot;&gt;Array.prototype.reduce&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;reduce 원리&lt;/li&gt;
&lt;li&gt;reduce 메소드 만들어보기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p><code>React</code> 입문전에 <code>Array</code> 메소드 <code>map</code>, <code>filter</code>, <code>reduce</code>를 확실히 알고<br>구현해 만들어보는 것이 도움이 된다길래 한번 만들어 봤습니다.</p><ul><li><p><a href="/2020/05/19/Array-prototype-map-filter-reduce-구현하기/#map">Array.prototype.map</a></p><ul><li>map 원리</li><li>map 메소드 만들어보기</li></ul></li><li><p><a href="/2020/05/19/Array-prototype-map-filter-reduce-구현하기/#filter">Array.prototype.filter</a></p><ul><li>filter 원리</li><li>filter 메소드 만들어보기</li></ul></li><li><p><a href="/2020/05/19/Array-prototype-map-filter-reduce-구현하기/#reduce">Array.prototype.reduce</a></p><ul><li>reduce 원리</li><li>reduce 메소드 만들어보기</li></ul></li></ul><a id="more"></a><hr><h2 id="map">Array.prototype.map</h2><hr><h3 id="map-원리"><a href="#map-원리" class="headerlink" title="map 원리"></a>map 원리</h3><ul><li><code>map()</code> 메서드는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 실행합니다.</li></ul><ul><li>결과를 모아 생성된 새로운 배열을 반환합니다. (<strong>원본값 수정X</strong>)</li></ul><blockquote><p>Array.prototype.map(callback,thisArg)<br>callback : currentValue, index, array</p></blockquote><ul><li><code>map</code> 메서드는 <code>callback</code> 함수와 <code>thisArg</code> 두가지 인자를 받고<br>(thisArg는 callback을 실행할 때 this로 사용하는 값입니다.) <strong>지정해 주지 않을시 <code>this</code>는 전역객체</strong></li></ul><ul><li><p><code>callback</code> 함수는 아래 3가지 인자를 받습니다.</p><ul><li><strong>currentValue</strong><br>처리할 현재 요소.</li><li><strong>index</strong> (Optional)<br>처리할 현재 요소의 인덱스.</li><li><strong>array</strong> (Optional)<br>map()을 호출한 배열.</li></ul></li></ul><ul><li><strong>반환 값</strong><br>각 요소에 함수를 호출하여 반환된 새로운 배열</li></ul><hr><h3 id="map-만들어보기"><a href="#map-만들어보기" class="headerlink" title="map 만들어보기"></a>map 만들어보기</h3><figure class="highlight js"><figcaption><span>map 메서드 구현</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="keyword">debugger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 기존 map</span></span><br><span class="line"><span class="keyword">const</span> result = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [ 'a1', 'b1', 'c1' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// map1 메소드 생성</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.map1 = <span class="function"><span class="keyword">function</span>(<span class="params">callback,thisArg</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mapping = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i ++) &#123;</span><br><span class="line">    <span class="keyword">var</span> mappedValue = callback.call(thisArg || Window, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>);</span><br><span class="line">    mapping[i] = mappedValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mapping;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result1 = a.map1(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result1); <span class="comment">// [ 'a1', 'b1', 'c1' ]</span></span><br></pre></td></tr></table></figure><hr><h2 id="filter">Array.prototype.filter</h2><hr><h3 id="filter-원리"><a href="#filter-원리" class="headerlink" title="filter 원리"></a>filter 원리</h3><ul><li><code>filter()</code> 메서드는 주어진 함수의 테스트를 통과(<code>true</code>)하는 모든 요소를 모아 <strong>새로운 배열로 반환합니다</strong>.</li></ul><ul><li><code>false</code>를 반환하는 요소는 버립니다.</li></ul><blockquote><p>Array.prototype.filter(callback, thisArg)<br>callback : currentValue, index, array</p></blockquote><ul><li><code>filter</code> 메서드는 <code>callback</code>, <code>thisArg</code> 두가지 인자를 받고<br>(thisArg는 callback을 실행할 때 this로 사용하는 값입니다.) <strong>지정해 주지 않을시 <code>this</code>는 전역객체</strong></li></ul><ul><li><p><code>callback</code> 함수는 아래 3가지 인자를 받습니다.</p><ul><li><p><strong>currentValue</strong><br>처리할 현재 요소.</p></li><li><p><strong>index</strong> (Optional)<br>처리할 현재 요소의 인덱스.</p></li><li><p><strong>array</strong> (Optional)<br>filter()를 호출한 배열.</p></li></ul></li></ul><ul><li><strong>반환 값</strong><br>각 요소에 함수를 테스트하여 true를 반환한 요소만 모은 새 배열</li></ul><hr><h3 id="filter-만들어보기"><a href="#filter-만들어보기" class="headerlink" title="filter 만들어보기"></a>filter 만들어보기</h3><figure class="highlight js"><figcaption><span>filter 메서드 구현</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="keyword">debugger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> words = [<span class="string">'spray'</span>, <span class="string">'limit'</span>, <span class="string">'elite'</span>, <span class="string">'exuberant'</span>, <span class="string">'destruction'</span>, <span class="string">'present'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기본 filter 사용</span></span><br><span class="line"><span class="keyword">const</span> result = words.filter(<span class="function"><span class="params">word</span> =&gt;</span> word.length &gt; <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//[ 'exuberant', 'destruction', 'present' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter1 메서드 생성하여 사용</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.filter1 = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> filtermapping = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> filterValue = callback.call(thisArg || Window, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (filterValue === <span class="literal">true</span>)&#123;</span><br><span class="line">        filtermapping.push(<span class="keyword">this</span>[i])</span><br><span class="line">      &#125;      </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> filtermapping;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result1 = words.filter1(<span class="function"><span class="params">word</span> =&gt;</span> word.length &gt; <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result1);<span class="comment">//[ 'exuberant', 'destruction', 'present' ]</span></span><br></pre></td></tr></table></figure><hr><h2 id="reduce">Array.prototype.reduce</h2><hr><h3 id="reduce-원리"><a href="#reduce-원리" class="headerlink" title="reduce 원리"></a>reduce 원리</h3><ul><li><code>reduce()</code> 메서드는 배열의 각 요소에 대해 주어진 리듀서(reducer) 함수를 실행하고, 하나의 결과값을 반환합니다.</li></ul><blockquote><p>Array.prototype.reduce(callback, initialValue)<br>callback : accumulator, currentValue, currentIndex, array</p></blockquote><ul><li><p><code>callback</code><br>배열의 각 요소에 대해 실행할 함수. 다음 네 가지 인수를 받습니다.</p><ul><li><p><strong>accumulator</strong><br>누산기accmulator는 <strong>콜백의 반환값을 누적합니다</strong>. 콜백의 이전 반환값 또는, 콜백의 첫 번째 호출이면서 <code>initialValue</code>를 제공한 경우에는  <code>initialValue</code>의 값입니다.</p></li><li><p><strong>currentValue</strong><br>처리할 현재 요소.</p></li><li><p><strong>currentIndex</strong> (Optional)<br>처리할 현재 요소의 인덱스. <code>initialValue</code>를 제공한 경우 0, 아니면 1부터 시작합니다.</p></li><li><p><strong>array</strong> (Optional)<br>reduce()를 호출한 배열.</p></li></ul></li></ul><ul><li><code>initialValue</code><br>callback의 최초 호출에서 첫 번째 인수에 제공하는 값. <strong>초기값을 제공하지 않으면 배열의 첫 번째 요소</strong>를 사용합니다.<br><strong>빈 배열에서 초기값 없이 reduce()를 호출하면 오류가 발생합니다.</strong></li></ul><ul><li><strong>반환 값</strong><br>누적 계산의 결과 값.</li></ul><hr><h3 id="reduce-만들어보기"><a href="#reduce-만들어보기" class="headerlink" title="reduce 만들어보기"></a>reduce 만들어보기</h3><p style="font-size: 2.4rem;"> 수정중. 에러사항 많음</p><figure class="highlight js"><figcaption><span>reduce 메서드 구현</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="keyword">debugger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">const</span> emptyArray = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존 reduce</span></span><br><span class="line"><span class="built_in">console</span>.log(array1.reduce(reducer, <span class="number">5</span>)); <span class="comment">//22</span></span><br><span class="line"><span class="built_in">console</span>.log(array1.reduce(reducer)); <span class="comment">//17</span></span><br><span class="line"><span class="comment">// 빈 배열에서 초기값 없이 reduce()를 호출하면 오류</span></span><br><span class="line"><span class="built_in">console</span>.log(emptyArray.reduce(reducer));</span><br><span class="line"><span class="comment">//TypeError: Reduce of empty array with no initial value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce1 메서드 생성하여 사용</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.reduce1 = <span class="function"><span class="keyword">function</span>(<span class="params">callback,initialValue</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reduceValue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(initialValue === <span class="literal">undefined</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.length === <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Reduce of empty array with no initial value"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    reduceValue += callback(<span class="keyword">this</span>[<span class="number">0</span>], <span class="keyword">this</span>[<span class="number">1</span>], <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">2</span>; i &lt; <span class="keyword">this</span>.length; i ++)&#123;</span><br><span class="line">      reduceValue =+ callback(reduceValue, <span class="keyword">this</span>[i], <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    reduceValue += callback(initialValue, <span class="keyword">this</span>[<span class="number">0</span>], <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.length; i ++)&#123;</span><br><span class="line">      reduceValue =+ callback(reduceValue, <span class="keyword">this</span>[i], <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> reduceValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.reduce1(reducer, <span class="number">5</span>)); <span class="comment">//22</span></span><br><span class="line"><span class="built_in">console</span>.log(array1.reduce1(reducer)); <span class="comment">//17</span></span><br><span class="line"><span class="built_in">console</span>.log(emptyArray.reduce1(reducer));</span><br><span class="line"><span class="comment">//TypeError: Reduce of empty array with no initial value</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/19/Array-prototype-map-filter-reduce-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>클래스(Class) -Core JavaScript</title>
      <link>https://hdw0903.github.io/2020/05/11/%ED%81%B4%EB%9E%98%EC%8A%A4-Class-Core-JavaScript/</link>
      <guid>https://hdw0903.github.io/2020/05/11/%ED%81%B4%EB%9E%98%EC%8A%A4-Class-Core-JavaScript/</guid>
      <pubDate>Mon, 11 May 2020 10:13:14 GMT</pubDate>
      <description>
      
        &lt;p&gt;다른 언어의 상속 개념을 흉내 내기위해 자바스크립트 ES6에서 추가된 &lt;code&gt;Class&lt;/code&gt; 문법&lt;br&gt;(&lt;strong&gt;내부적으로는 프로토타입을 따름&lt;/strong&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/11/클래스-Class-Core-JavaScript/#Class&quot;&gt;클래스와 인스턴스의 개념 이해&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/11/클래스-Class-Core-JavaScript/#JavaScript_Class&quot;&gt;자바스크립트의 클래스&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/11/클래스-Class-Core-JavaScript/#Class_상속&quot;&gt;클래스 상속&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;기본 구현&lt;/li&gt;
&lt;li&gt;클래스가 구체적인 데이터를 지니지 않게 하는법&lt;/li&gt;
&lt;li&gt;constructor 복구하기&lt;/li&gt;
&lt;li&gt;상위 클래스에 접근 수단&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/11/클래스-Class-Core-JavaScript/#ES6_Class&quot;&gt;ES6의 클래스 및 클래스 상속&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/11/클래스-Class-Core-JavaScript/#point&quot;&gt;정리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>다른 언어의 상속 개념을 흉내 내기위해 자바스크립트 ES6에서 추가된 <code>Class</code> 문법<br>(<strong>내부적으로는 프로토타입을 따름</strong>)</p><ul><li><a href="/2020/05/11/클래스-Class-Core-JavaScript/#Class">클래스와 인스턴스의 개념 이해</a></li><li><a href="/2020/05/11/클래스-Class-Core-JavaScript/#JavaScript_Class">자바스크립트의 클래스</a></li><li><a href="/2020/05/11/클래스-Class-Core-JavaScript/#Class_상속">클래스 상속</a><ul><li>기본 구현</li><li>클래스가 구체적인 데이터를 지니지 않게 하는법</li><li>constructor 복구하기</li><li>상위 클래스에 접근 수단</li></ul></li><li><a href="/2020/05/11/클래스-Class-Core-JavaScript/#ES6_Class">ES6의 클래스 및 클래스 상속</a></li><li><a href="/2020/05/11/클래스-Class-Core-JavaScript/#point">정리</a></li></ul><a id="more"></a><hr><h2 id="Class">클래스와 인스턴스의 개념 이해</h2><p>상위(<code>superior</code>), 하위(<code>subordinate</code>) 개념의 앞글자를 따서<br>상위 클래스(<code>superclass</code>), 하위 클래스(<code>subclass</code>)로 표현합니다.</p><p>자바스크립트를 기준으로 하위 클래스(<code>subclass</code>)를 <code>Array</code>로 생각해 본다면 상위 클래스(<code>superclass</code>)는 <code>__proto__</code>와 <code>Array.prototype</code>에 따라 <code>Object</code>가 되겠습니다.</p><p><img src="/images/Class.png" alt="superClass 와 subClass"></p><p>클래스의 속성을 지니는 실존하는 개체를 <code>instance</code>라고 합니다.<br><code>instance</code>는 <strong>“해당 클래스의 조건을 만족하는 구체적인 예시”</strong>라고 해석 할 수도 있습니다.</p><ul><li><p><code>Class</code>를 바탕으로 <code>instance</code>를 만들 때 생성된 개체가 <code>Class</code>의 속성을 지니게 됩니다.</p></li><li><p>또한 한 <code>instance</code>는 <strong>하나의 클래스만을 바탕으로 만들어 집니다.</strong><br>인스턴스가 다양한 클래스에 속할 수는 있지만 인스턴스 입장에서는 모두 ‘직계존속’클래스들 입니다.<br>결국 인스턴스를 생성할 때 호출할 수 있는 클래스는 오직 하나뿐 이기 떄문입니다.<br><img src="/images/superClass_subClass.jpg" alt="superClass subClass"><br><a href="https://coding-restaurant.tistory.com/239">도식 그림 출처: 코딩맛집</a></p></li></ul><hr><h2 id="JavaScript_Class">자바스크립트의 클래스</h2><p>생성자 함수 <code>Array</code>를 <code>new</code> 연산자와 함께 호출하면 <code>instance</code>가 생성됩니다. 이 때 <code>Array</code>를 일종의 <code>클래스</code>라고 하면 <code>Array</code>의 <code>prototype</code> 객체 내부 요소들이 <code>instance</code>에 <strong>‘상속’</strong>된다고 볼수 있습니다. (내부적으로는 상속이 아닌 프로토 타입 체이닝에 의한 참조 입니다.)</p><ul><li><p>한편 <code>Array</code> 내부 프로퍼티들 중 <code>prototype</code> 프로퍼티를 제외한 나머지는 <code>instance</code>에 상속되지 않습니다.</p></li><li><p><code>instance</code>가 참조하는지 여부에 따라 </p><ul><li>스태틱 맴버(<code>static member</code>) 와</li><li>인스턴스 맴버(<code>instance member</code>)로 나뉩니다.<br><img src="/images/static_member.png" alt="static member, instance member"></li></ul></li><li><p><code>prototype</code>에 있는 내부 메서드는 <code>instance</code>가 직접 호출할 수 있습니다.</p></li><li><p>반대로 <code>prototype</code>에 없는 메서드는 <code>instance</code>가 참조하지 않으므로 호출할 수 없습니다.</p></li><li><p>이렇게 <code>instance</code><strong>에서 직접 접근할 수 없는 메서드를 스태틱 메서드라고 합니다.</strong></p></li></ul><hr><h2 id="Class_상속">클래스 상속</h2><hr><h3 id="기본-구현"><a href="#기본-구현" class="headerlink" title="기본 구현"></a>기본 구현</h3><p>클래스 상속은 객체지향에서 가장 중요한 요소 중 하나입니다, 하지만 자바스크립트는 ES5까지 클래스가 없었기 때문에 프로토 타입 체인을 활용해 클래스 상속을 흉내내었었습니다.</p><p>이에 대해 가볍게 알아보겠습니다.</p><hr><h4 id="length-프로퍼티-삭제-가능"><a href="#length-프로퍼티-삭제-가능" class="headerlink" title="length 프로퍼티 삭제 가능"></a>length 프로퍼티 삭제 가능</h4><figure class="highlight js"><figcaption><span>length 삭제</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Grade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>[i] = args[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.length = args.length;</span><br><span class="line">&#125;;</span><br><span class="line">Grade.prototype = [];</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Grade(<span class="number">100</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">g.push(<span class="number">90</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// Grade &#123; 0: 100, 1: 80, 2: 90, length: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> g.length;</span><br><span class="line">g.push(<span class="number">70</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// Grade &#123; 0: 70, 1: 80, 2: 90, length: 1 &#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>length</code>프로퍼티를 삭제하고 다시 <code>push</code> 했더니, <code>push</code>한 값이 0번째 <code>index</code>에 들어가고, <code>length</code>가 1이 됐습니다.</li></ul><ul><li>내장객체인 <code>배열 instance</code>의 <code>length</code> 프로퍼티는 <code>{ configurable : false }</code>라서 삭제가 불가능하지만,<br><code>Grade</code> 클래스의 <code>instance</code>는 <strong>배열 메서드를 상속(참조)하지만 기본적으로는 일반 객체의 성질을 그대로 지니므로 삭제가 가능</strong>해서 문제가 됩니다.</li></ul><hr><h4 id="빈-배열"><a href="#빈-배열" class="headerlink" title="빈 배열"></a>빈 배열</h4><ul><li><code>push</code>했을 때 0번째 <code>index</code>에 70이 들어가고 <code>length</code>가 1이 된 이유:<br><code>g.__proto__</code>, 즉 <code>Grade.prototype</code>이 <strong>빈 배열을 가리키고 있기 때문</strong></li></ul><ul><li><code>push</code> 명령에 의해 엔진이 <code>g.length</code>를 읽으려 하는데 <code>g.length</code>가 <strong>존재하지 않으므로 프로토 타입 체이닝을 타고</strong> <code>g.__proto__.length</code>을 읽어옴.</li></ul><ul><li>빈 배열의 <code>length</code>는 0 이므로 여기에 값을 할당하고 <code>length</code>는 1 만큼 증가합니다.</li></ul><hr><h4 id="요소가-있는-배열을-prototype에-매칭한-경우"><a href="#요소가-있는-배열을-prototype에-매칭한-경우" class="headerlink" title="요소가 있는 배열을 prototype에 매칭한 경우"></a>요소가 있는 배열을 prototype에 매칭한 경우</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Grade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>[i] = args[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.length = args.length;</span><br><span class="line">&#125;;</span><br><span class="line">Grade.prototype = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]; <span class="comment">// 빈 배열 아님</span></span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Grade(<span class="number">100</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">g.push(<span class="number">90</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// Grade &#123; 0: 100, 1: 80, 2: 90, length: 3 &#125;</span></span><br><span class="line"><span class="comment">// length 삭제 후</span></span><br><span class="line"><span class="keyword">delete</span> g.length;</span><br><span class="line">g.push(<span class="number">70</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// Grade &#123; 0: 100, 1: 80, 2: 90, ___ 4: 70, length: 5 &#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>Grade.prototype</code>에 빈 배열이 아닌 <code>length</code>가 4인 배열을 할당했습니다.</li></ul><ul><li><code>length</code>를 삭제 후 <code>push</code>한 값이 <code>Grade.prototype</code>에 빈 배열을 할당했을 때와는 다르게 동작합니다.</li></ul><ul><li><code>push</code>명령에 의해 엔진이 <code>g.length</code>를 읽으려 하는데 존재하지 않으므로 <code>g.__proto__.length</code>를 읽어오는데 <code>length</code>값이 4인 배열입니다.</li></ul><ul><li>그러므로 여기에 (<code>index : 4</code>) 70값을 할당하고 <code>length</code> 값을 1증가시켜 5가 되는것 입니다.</li></ul><p><strong>이처럼 <code>class</code>에 있는 값이 <code>instance</code>의 동작에 영향을 줘서는 안됩니다.</strong>(이런 영향을 줄 수 있다는 것 자체가 이미 클래스의 추상성을 해치는 것입니다.)</p><p><code>class</code>는 <code>instance</code>와의 관계에서는 <strong>구체적인 데이터를 지니지 않고</strong> 오직 <code>instance</code>가 <strong>사용할 메서드만을 지니는 추상적인 틀</strong>로만 작용해야 합니다.</p><hr><h4 id="사용자가-정의한-두-클래스-사이에서의-상속관계-구현"><a href="#사용자가-정의한-두-클래스-사이에서의-상속관계-구현" class="headerlink" title="사용자가 정의한 두 클래스 사이에서의 상속관계 구현"></a>사용자가 정의한 두 클래스 사이에서의 상속관계 구현</h4><p>직사각형 클래스와 정사각형 클래스를 만듭니다.</p><ul><li><p>직사각형: 두 쌍의 마주 보는 변이 평행이고 그 길이가 같습니다.</p></li><li><p>정사각형: 직사각형이며(직사각형의 조건을 충족) 네 변의 길이가 모두 같습니다.</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rect.getArea()); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Square = <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">&#125;;</span><br><span class="line">Square.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.width;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> sq = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sq.getArea()); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><ul><li><code>Rectangle</code>과 <code>Square</code>클래스에 공통 요소가 보입니다. <code>width</code> 프로퍼티가 공통이고, <code>getArea</code>메서드는 다른 부분이 있으나 비슷합니다.</li></ul><ul><li><code>Square</code>에서 <code>width</code>프로퍼티만 쓰지 않고 <code>height</code>프로퍼티에 <code>width</code>값을 부여하는 형태로 변경한다면 <code>getArea</code>도 동일하게 쓸 수 있겠습니다.</li></ul><figure class="highlight js"><figcaption><span>Square 수정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Square = <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = width;</span><br><span class="line">&#125;;</span><br><span class="line">Square.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>Square</code>를 위와같이 수정해 주면 <code>Square</code>를 <code>Rectangle</code>의 하위 클래스로 삼을 수 있습니다.</li></ul><ul><li><code>getArea</code> 메서드는 동일한 동작을 하므로 <strong>상위 클래스에서만 정의하고, 하위 클래스에서는 해당 메서드를 상속</strong>하면서 <code>height</code> 대신 <code>width</code>를 넣어주면 되겠습니다.</li></ul><figure class="highlight js"><figcaption><span>Rectangle을 상속하는 Square 클래스</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Square = <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  Rectangle.call(<span class="keyword">this</span>, width, width);</span><br><span class="line">&#125;;</span><br><span class="line">Square.prototype = <span class="keyword">new</span> Rectangle();</span><br></pre></td></tr></table></figure><ul><li><code>Square</code> 생성자 함수 내부에서 <code>Rectangle</code> 생성자 함수를 함수로 호출하고 <strong>인자 height 자리에 width를 전달합니다.</strong></li></ul><ul><li><code>Square.prototype = new Rectangle();</code>  : 메서드를 상속하기 위해 프로토타입 객체에 <code>Rectangle</code>의 <code>instance</code>를 부여했습니다.</li></ul><p>하지만 위 코드만으로 <strong>완벽한 클래스 체계가 구축됐다고 볼 수는 없습니다.</strong></p><p><strong>아직 클래스에 있는 값이 인스턴스에 영향을 줄 수 있는 구조이기 때문입니다.</strong></p><ul><li><code>console.dir(sq);</code>로 sq <code>instance</code>에 대하여 콘솔로 출력해보면<br><img src="/images/dir_sq.png" alt="console.dir(sq);"><br>첫 줄에서 <code>Square</code>의 <code>instance</code>을 표시하고 있고 <code>width</code>와 <code>height</code>에 5가 잘 들어있습니다. <code>__proto__</code>는 <code>Rectangle</code>의 <code>instance</code>임을 표시하고 이어서 <code>width</code>, <code>height</code>에 모두 <code>undefined</code>가 할당되어 있습니다. <code>Square.prototype</code>에 값이 존재하여 이후에 임의로 <code>Square.prototype.width (또는 height)</code>에 값을 부여하고 <code>sq.width(또는 height)</code>의 값을 지워버린다면 프로토타입 체이닝에 의해 엉뚱한 결과가 나오는 문제가 생길 수 있습니다.</li></ul><p><img src="/images/Square%EB%8F%84%EC%8B%9D.jfif" alt="Rectangle -&gt; Square 상속 관계 구현 도식"><br><a href="https://coding-restaurant.tistory.com/239">도식 그림 출처: 코딩맛집</a></p><p>나아가 <code>constructor</code>가 여전히 <code>Rectangle</code>을 바라보고 있는 문제도 있습니다. <code>sq.constructor</code>로 접근하면 프로토타입 체이닝을 따라 <code>sq.__proto__.__proto__,</code> 즉 <code>Rectangle.prototype</code>에서 찾게 되며 이는 <code>Rectangle</code>을 가리키고 있기 때문입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect2 = <span class="keyword">new</span> sq.constructor(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rect2); <span class="comment">// Rectangle &#123;width: 2, height: 3&#125;</span></span><br></pre></td></tr></table></figure><p>이처럼 하위 클래스로 삼을 생성자 함수의 <code>prototype</code> 에 상위 클래스의 <code>instance</code>를 부여하는 것만으로도 기본적 메서드 상속은 가능하지만 다양한 문제가 발생할 여지가 있어 구조적 안정성이 떨어집니다.</p><hr><h3 id="클래스가-구체적인-데이터를-지니지-않게-하는법"><a href="#클래스가-구체적인-데이터를-지니지-않게-하는법" class="headerlink" title="클래스가 구체적인 데이터를 지니지 않게 하는법"></a>클래스가 구체적인 데이터를 지니지 않게 하는법</h3><p>클래스 (prototype)가 구체적인 데이터를 지니지 않게 하는 방법 중<br>가장 쉬운 방법은 일단 만들고 나서 프로퍼티들을 일일히 지우고 더는 <strong>새로운 프로퍼티를 추가할 수 없게 하는 것</strong>입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> Square.prototype.width; </span><br><span class="line"><span class="keyword">delete</span> Square.prototype.height; </span><br><span class="line"><span class="built_in">Object</span>.freeze(Square.prototype);</span><br></pre></td></tr></table></figure><p>프로퍼티가 많다면 반복 작업이 될테니 반복을 없애고 좀 더 범용적으로 이런 동작을 하는 함수를 만들면 좋겠습니다.</p><figure class="highlight js"><figcaption><span>인스턴스 생성 후 프로퍼티 제거</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass1 = <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">  SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> SubClass.prototype) &#123;</span><br><span class="line">    <span class="keyword">if</span> (SubClass.prototype.hasOwnProperty(prop)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> SubClass.prototype[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">      SubClass.prototype[method] = subMethods[method];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">  <span class="keyword">return</span> SubClass;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Square = extendClass1(Rectangle, <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  Rectangle.call(<span class="keyword">this</span>, width, width);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> sq = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sq.getArea()); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><ul><li><code>extendClass1</code> 함수는 <code>SuperClass</code>와 <code>SubClass</code>, <code>SubClass</code>에 추가할 메서드들이 정의된 객체를 받아 <code>SubClass</code>의 <code>prototype</code> 내용을 정리하고 <code>freeze</code>하는 내용으로 구성돼있습니다.</li></ul><hr><h4 id="두-번째-방법-빈-함수"><a href="#두-번째-방법-빈-함수" class="headerlink" title="두 번째 방법(빈 함수)"></a>두 번째 방법(빈 함수)</h4><p>더글라스 크락포드가 제시하여 대중적으로 알려진 방법입니다.<br><code>SubClass</code>의 <code>prototype</code>에 직접 <code>SubClass</code>의 <code>instance</code>를 할당하는 대신</p><p><strong>아무런 프로퍼티를 생성하지 않는 빈 생성자 함수(<code>Bridge</code>)를 하나 더 만들어서</strong> 그 <code>prototype</code>이 <code>SubClass</code>의 <code>prototype</code>을 바라보게 한 다음,<code>SubClass</code>의 <code>prototype</code>에는 <code>Bridge</code>의 <code>instance</code>를 할당하게 하는 것입니다.<br>(<strong>빈 함수에 다리 역활을 부여</strong>)</p><p><img src="/images/Class2.png" alt="클래스 상속 및 추상화 방법(2)- 빈 함수 활용"></p><ul><li><code>Bridge</code>라는 빈 함수를 만들고, <code>Bridge.prototype</code>이 <code>Rectangle.prototype</code>을 참조하게 한 다음, <code>Square.prototype</code>에 <code>new Bridge()</code>로 할당하면, 우측 그림처럼 <code>Rectangle</code> 자리에 <code>Bridge</code>가 대체됩니다.</li></ul><ul><li>이로써 <code>instance</code>를 제외한 <strong>프로토타입 체인 경로상에는 더는 구체적인 데이터가 남아있지 않게 됩니다</strong>.</li></ul><p>마찬가지로 반복작업을 없애기 위해 범용적으로 이런 동작을 하는 함수를 만들어 보겠습니다.</p><figure class="highlight js"><figcaption><span>빈 함수를 활용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass2 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Bridge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">    Bridge.prototype = SuperClass.prototype;</span><br><span class="line">    SubClass.prototype = <span class="keyword">new</span> Bridge();</span><br><span class="line">    <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">        SubClass.prototype[method] = subMethods[method];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">    <span class="keyword">return</span> SubClass;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Square = extendClass2(Rectangle, <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  Rectangle.call(<span class="keyword">this</span>, width, width);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> sq = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sq.getArea()); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><ul><li><p>즉시실행함수 내부에서 <code>Bridge</code>를 선언하여 이를 클로저로 활용함으로써 메모리에 불필요한 함수 선언을 줄였습니다.</p></li><li><p><code>subMethods</code>에는 <code>SubClass</code>의 <code>prototype</code>이 담길 메서드들을 객체로 전달하게 했습니다.</p></li></ul><hr><h4 id="세-번째-방법-Object-create"><a href="#세-번째-방법-Object-create" class="headerlink" title="세 번째 방법(Object.create)"></a>세 번째 방법(Object.create)</h4><p>세 번째 방법은 ES5에서 도입된 <code>Object.create</code>를 이용한 방법으로 이 방법은</p><p><code>SubClass</code>의 <code>prototype</code>의 <code>__proto__</code>가 <code>SuperClass</code>의 <code>prototype</code>을 바라보되, <code>SuperClass</code>의 <code>instance</code>가 되지는 않으므로 앞서 소개한 두 방법보다 간편하면서 안전합니다.</p><figure class="highlight js"><figcaption><span>Object.create 활용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Square = <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  Rectangle.call(<span class="keyword">this</span>, width, width);</span><br><span class="line">&#125;;</span><br><span class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype);</span><br><span class="line"><span class="built_in">Object</span>.freeze(Square.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sq = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sq.getArea()); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p><del>클래스 상속 및 추상화를 흉내 내기 위한 라이브러리가 많이 있지만 기본적인 접근 방법은 위 세가지 아이디어를 크게 벗어나지 않습니다.</del></p><p>결론적으로 <code>SubClass.prototype</code>의 <code>__proto__</code>가 <code>SuperClass.prototype</code>을 참조하고, <code>SubClass.prototype</code>에는 불필요한 <code>instance 프로퍼티</code>가 남아있으면 안되기 때문입니다.</p><hr><h3 id="constructor-복구하기"><a href="#constructor-복구하기" class="headerlink" title="constructor 복구하기"></a>constructor 복구하기</h3><p>위 세 가지 방법 모두 기본적인 상속에는 성공했지만, <code>SubClass</code> <code>instance</code>의 <code>constructor</code>는 여전히 <code>Superclass</code>를 가리키는 상태입니다.</p><ul><li>엄밀히는 <code>SubClass</code>의 <code>instance</code>에는 <code>constructor</code>가 없고, <code>SubClass.prototype</code>에도 없는 상태입니다.</li></ul><ul><li>프로토타입 체인상에 가장 먼저 등장하는 <code>SuperClass.prototype</code>의 <code>constructor</code>가 가리키는 대상인 <code>SuperClass</code>가 출력되는 것입니다.</li></ul><p>따라서 <code>SubClass.prototype.constructor</code>가 원래의 <code>SubClass</code>를 바라보도록 해주겠습니다.</p><figure class="highlight js"><figcaption><span>인스턴스 생성 후 프로퍼티 제거 + constructor 복구</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass1 = <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">  SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> SubClass.prototype) &#123;</span><br><span class="line">    <span class="keyword">if</span> (SubClass.prototype.hasOwnProperty(prop)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> SubClass.prototype[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//SubClass.prototype.constructor가 원래의 SubClass를 바라보도록 함</span></span><br><span class="line">  SubClass.prototype.consturctor = SubClass;</span><br><span class="line">  <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">      SubClass.prototype[method] = subMethods[method];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">  <span class="keyword">return</span> SubClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>빈 함수 활용 + constructor 복구</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass2 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Bridge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">    Bridge.prototype = SuperClass.prototype;</span><br><span class="line">    SubClass.prototype = <span class="keyword">new</span> Bridge();</span><br><span class="line">    SubClass.prototype.consturctor = SubClass;</span><br><span class="line">    <span class="comment">//SuperClass와의 관계를 복구하기 위해</span></span><br><span class="line">    <span class="comment">//Bridge.prototype.constructor가 SuperClass를 바라보게 하는 작업 추가</span></span><br><span class="line">    Bridge.prototype.constructor = SuperClass;</span><br><span class="line">    <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">        SubClass.prototype[method] = subMethods[method];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">    <span class="keyword">return</span> SubClass;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>빈 함수(<code>Bridge</code>)를 이용한 두 번째 방법의 경우 <code>SubClass.prototype</code>이 <code>SuperClass</code> 대신 <code>Bridge</code>의 <code>instance</code>를 바라보는 상태이므로 <code>SuperClass</code>와의 관계를 복구하기 위해 <code>Bridge.prototype.constructor</code>가 <code>SuperClass</code>를 바라보게 하는 작업이 추가돼야 합니다. </p><figure class="highlight js"><figcaption><span>Object.create 활용 + constructor 복구</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass3 = <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">  SubClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line">  <span class="comment">//SubClass.prototype.constructor가 원래의 SubClass를 바라보도록 함</span></span><br><span class="line">  SubClass.prototype.constructor = SubClass;</span><br><span class="line">  <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">      SubClass.prototype[method] = subMethods[method];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">  <span class="keyword">return</span> SubClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="상위-클래스에-접근-수단"><a href="#상위-클래스에-접근-수단" class="headerlink" title="상위 클래스에 접근 수단"></a>상위 클래스에 접근 수단</h3><p>하위 클래스의 메서드에서 <strong>상위 클래스의 메서드 실행 결과를 바탕으로 추가적인 작업을 수행하고 싶을 때</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass.prototype.method.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure><p>매번 이런식으로 코드를 추가해서 해결하는 것은 상당히 번거롭고 가독성이 떨어지는 방식입니다.</p><p>하위 클래스에서 <strong>상위 클래스의 프로토타입 메서드에 접근하기 위한 별도의 수단</strong>이 있다면 편리할 것 같습니다.</p><p>이런 <strong>별도의 수단</strong>인 다른 객체지향 언어들의 클래스 문법 중 하나인 <code>super</code>를 흉내 내보겠습니다.</p><figure class="highlight js"><figcaption><span>상위 클래스 접근 수단 super 메서드 추가</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass = <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">  SubClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line">  SubClass.prototype.constructor = SubClass;</span><br><span class="line">  SubClass.prototype.super = <span class="function"><span class="keyword">function</span>(<span class="params">propName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 추가된 부분 시작</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!propName) <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//인자가 비어있을 경우 </span></span><br><span class="line">        SuperClass.apply(self, <span class="built_in">arguments</span>);<span class="comment">// SuperClass 생성자 함수에 접근하는 것으로 간주</span></span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">var</span> prop = SuperClass.prototype[propName]; <span class="comment">//SuperClass.prototype 내부의 propName에 해당하는 값이     </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> prop !== <span class="string">'function'</span>) <span class="keyword">return</span> prop;<span class="comment">//함수가 아닌 경우 해당값을 그대로 반환합니다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//함수인 경우</span></span><br><span class="line">      <span class="keyword">return</span> prop.apply(self, <span class="built_in">arguments</span>); <span class="comment">//메서드에 접근하는 것으로 여김</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;; <span class="comment">// 추가된 부분 끝</span></span><br><span class="line">  <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">      SubClass.prototype[method] = subMethods[method];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">  <span class="keyword">return</span> SubClass;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Square = extendClass(Rectangle, <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.super()(width, width); <span class="comment">// super 사용 (1)</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    getArea: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'size is :'</span>, <span class="keyword">this</span>.super(<span class="string">'getArea'</span>)()); <span class="comment">// super 사용 (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> sq = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line">sq.getArea(); <span class="comment">// size is : 100</span></span><br><span class="line"><span class="built_in">console</span>.log(sq.super(<span class="string">'getArea'</span>)()); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><ul><li>추가된 부분에서 <code>super</code> 메서드의 동작을 정의하고 있습니다.</li></ul><ul><li>7번째 줄에서 인자가 비어있을 경우 <code>SuperClass</code> 생성자 함수에 접근하는 것으로 간주했습니다.</li></ul><ul><li><code>this</code>가 달라지는 것을 막기 위해 클로저를 활용했습니다.</li></ul><ul><li>11번째 줄은 <code>SuperClass</code>의 <code>prototype</code> 내부의 <code>propName</code>에 해당하는 값이 함수가 아닌 경우 해당값을 그대로 반환합니다.</li></ul><ul><li>12번째 줄은 함수인 경우이므로 마찬가지로 클로저를 활용해 메서드에 접근하는 것으로 여기도록 했습니다.</li></ul><p>이제 <code>SuperClass</code>의 <strong>생성자 함수에 접근하고자 할 때는</strong> <code>this.super()</code>, <code>SuperClass</code>의 <strong>프로토타입 메서드에 접근하고자 할 때는</strong> <code>this.super(propName)</code>과 같이 사용할 수 있습니다.</p><hr><h2 id="ES6_Class">ES6의 클래스 및 클래스 상속</h2><ul><li><p><code>ES6</code>에서는 본격적으로 클래스 문법이 도입됐습니다.</p></li><li><p><code>ES5</code>에서의 생성자 함수 및 프로토타입 과 <code>ES6</code>의 클래스 문법을 비교해봅니다.</p></li></ul><hr><h4 id="ES5-ES6-클래스-문법-비교"><a href="#ES5-ES6-클래스-문법-비교" class="headerlink" title="ES5 / ES6 클래스 문법 비교"></a>ES5 / ES6 클래스 문법 비교</h4><figure class="highlight js"><figcaption><span>ES5와 ES6 클래스 문법 비교</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ES5 = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">ES5.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' staticMethod'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">ES5.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' method'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> es5Instance = <span class="keyword">new</span> ES5(<span class="string">'es5'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ES5.staticMethod()); <span class="comment">// es5 staticMethod</span></span><br><span class="line"><span class="built_in">console</span>.log(es5Instance.method()); <span class="comment">// es5 method</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ES6 = <span class="class"><span class="keyword">class</span> </span>&#123; <span class="comment">//중괄호 &#123;&#125;내부가 클래스 본문 영역입니다.</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123; <span class="comment">//클래스 본문에서는 'function'키워드를 생략하더라도</span></span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">//모두 메서드로 인식합니다.</span></span><br><span class="line">  &#125; <span class="comment">//메서드와 다음 메서드 사이에는 콤마(,)로 구분하지 않습니다.</span></span><br><span class="line">  <span class="keyword">static</span> staticMethod() &#123; <span class="comment">//static 키워드는 해당 메서드가 static 메서드라는 뜻입니다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' staticMethod'</span>; <span class="comment">//ES5의 생성자 함수에 바로 할당하는 메서드와 동일하게</span></span><br><span class="line">  &#125;                                     <span class="comment">//생성자 함수(클래스) 자신만이 호출할 수 있습니다.</span></span><br><span class="line">  method() &#123; <span class="comment">//method는 자동으로 prototype 객체 내부에 할당되는 메서드입니다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' method'</span>;<span class="comment">//ES5.prototype.method와 동일하게, </span></span><br><span class="line">  &#125; <span class="comment">//instance가 프로토타입 체이닝을 통해 자신의 것처럼 직접 호출가능합니다.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> es6Instance = <span class="keyword">new</span> ES6(<span class="string">'es6'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ES6.staticMethod()); <span class="comment">// es6 staticMethod</span></span><br><span class="line"><span class="built_in">console</span>.log(es6Instance.method()); <span class="comment">// es6 method</span></span><br></pre></td></tr></table></figure><hr><h4 id="ES6의-클래스-상속"><a href="#ES6의-클래스-상속" class="headerlink" title="ES6의 클래스 상속"></a>ES6의 클래스 상속</h4><figure class="highlight js"><figcaption><span>ES6의 클래스 상속</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Rectangle = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(width, height) &#123;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Square = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(width) &#123;</span><br><span class="line">    <span class="keyword">super</span>(width, width);</span><br><span class="line">  &#125;</span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'size is :'</span>, <span class="keyword">super</span>.getArea());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>Square</code>를 <code>Rectangle</code> 클래스를 상속받게 하기위해 <code>class</code>명렁어 뒤에 <code>extends Rectangle</code>을 추가합니다.<br>이것으로 상속 관계 설정이 완료됩니다.</li></ul><ul><li><code>constructor</code> 내부에서는 <code>super</code>라는 키워드를 함수처럼 사용할 수 있습니다. 이 함수는 <code>SuperClass</code>의 <code>constructor</code>를 실행합니다.</li></ul><ul><li><code>constructor</code> 메서드를 제외한 다른 메서드에서는 <code>super</code>키워드를 마치 객체처럼 사용할 수 있고, 이때 객체는 <code>SuperClass.prototype</code>을 바라보는데, <strong>호출한 메서드의 <code>this</code>는 <code>super</code>가 아닌 원래의 <code>this</code>를 그대로 따릅니다.</strong></li></ul><p><a href="https://hdw0903.github.io/2020/04/01/Class%20%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%20-ECMAScript/">ES6의 Class 오브젝트 더 자세히 알아보기</a></p><hr><h2 id="point">정리</h2><ul><li>클래스는 어떤 사물의 공통 속성을 모아 정의한 추상적인 개념, <code>instance</code>는 클래스의 속성을 갖는 구체적인 사례<br>상위 클래스(<code>SuperClass</code>)의 조건을 충족하면서 더욱 구체적인 조건이 추가된 것을 하위 클래스(<code>SubClass</code>)라고 함.</li></ul><ul><li>클래스의 <code>prototype</code> 내부에 정의된 메서드를 <code>프로토타입 메서드</code>라고 하며, 이들은 <code>instance</code>가 마치 자신의 것처럼 호출할 수 있습니다.</li></ul><ul><li>클래스(생성자 함수)에 직접 정의한 메서드를 <code>스태틱 메서드</code>라고 하며, 이들은 <code>instance</code>가 직접 호출할 수 없고 클래스(생성자 함수)에 의해서만 호출할 수 있음.</li></ul><ul><li><p>클래스 상속을 흉내 내기 위한 세 가지 방법</p><ul><li><p><code>SubClass.prototype</code>에 <code>Superclass</code>의 <code>instance</code>를 할당하고 프로퍼티를 모두 삭제하는 방법.</p></li><li><p>빈 함수(<code>Bridge</code>)를 할용하는 방법</p></li><li><p>Object.create를 이용하는 방법</p></li></ul><p><strong>세 방법 모두 <code>constructor</code> 프로퍼티가 원래의 생성자 함수를 바라보도록 조정해 줘야함</strong> </p></li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/11/%ED%81%B4%EB%9E%98%EC%8A%A4-Class-Core-JavaScript/#disqus_thread</comments>
    </item>
    
    <item>
      <title>prototype -Core JavaScript</title>
      <link>https://hdw0903.github.io/2020/05/05/prototype-Core-JavaScript/</link>
      <guid>https://hdw0903.github.io/2020/05/05/prototype-Core-JavaScript/</guid>
      <pubDate>Tue, 05 May 2020 08:57:53 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;프로토타입 (prototype)&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/05/prototype-Core-JavaScript/#프로토타입의-개념-이해&quot;&gt;프로토타입의 개념 이해&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;constructor, prototype, instance&lt;/li&gt;
&lt;li&gt;constructor 프로퍼티&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/05/prototype-Core-JavaScript/#prototype_chain&quot;&gt;프로토타입 체인&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;메서드 오버라이드&lt;/li&gt;
&lt;li&gt;프로토타입 체인&lt;/li&gt;
&lt;li&gt;객체 전용 메서드의 예외사항&lt;/li&gt;
&lt;li&gt;다중 프로토타입 체인&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/05/prototype-Core-JavaScript/#point&quot;&gt;정리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<ul><li>프로토타입 (prototype)<ul><li><a href="/2020/05/05/prototype-Core-JavaScript/#프로토타입의-개념-이해">프로토타입의 개념 이해</a><ul><li>constructor, prototype, instance</li><li>constructor 프로퍼티</li></ul></li><li><a href="/2020/05/05/prototype-Core-JavaScript/#prototype_chain">프로토타입 체인</a><ul><li>메서드 오버라이드</li><li>프로토타입 체인</li><li>객체 전용 메서드의 예외사항</li><li>다중 프로토타입 체인</li></ul></li><li><a href="/2020/05/05/prototype-Core-JavaScript/#point">정리</a></li></ul></li></ul><a id="more"></a><hr><h2 id="프로포타입의-개념-이해">프로토타입의 개념 이해</h2><h3 id="constructor-prototype-instance"><a href="#constructor-prototype-instance" class="headerlink" title="constructor, prototype, instance"></a>constructor, prototype, instance</h3><blockquote><p>var instance = new Constructor();</p></blockquote><p>위 코드를 추상화 하여 나타내면 다음과 같습니다.</p><p><img src="/images/prototype_schematic.png" alt="prototype schematic"></p><p>윗변(실선)의 왼쪽 꼭지점에는 <code>Constructor</code>(생성자 함수)를, 오른쪽 꼭짓점에는 <code>Constructor.prototype</code>이라는 프로퍼티를 위치시켰습니다.<br>왼쪽 꼭짓점부터 아래를 향한 화살표 중간에 <code>new</code>가 있고, 화살표의 종점에는 <code>instance</code>가 있습니다.<br>오른쪽 꼭짓점으로부터 대각선 아래로 향하는 화살표의 종점에는 <code>instance.__proto__</code>이라는 프로퍼티를 위치시켰습니다. </p><hr><ul><li><p>어떤 생성자 함수(<code>Constructor</code>)를 <code>new</code> 연산자와 함께 호출하면</p></li><li><p><code>Constructor</code>에서 정의된 내용을 바탕으로 새로운 인스턴스(<code>instance</code>)가 생성됩니다.</p></li><li><p>이떄 <code>instance</code>에는 <code>__proto__</code>라는 프로퍼티가 자동으로 부여되는데,</p></li><li><p>이 프로퍼티는 <code>Constructor</code>의 <code>prototype</code>이라는 프로퍼티를 참조합니다.</p></li></ul><p><code>prototype</code>이라는 프로퍼티와 <code>__proto__</code> <mark>이 둘의 관계가 프로토타입 개념의 핵심입니다.</mark></p><p><code>prototype</code>은 객체입니다. 이를 참조하는 <code>__proto__</code> 역시 객체입니다.</p><p><code>prototype</code> 객체 내부에는 <code>instance</code>가 사용할 메서드를 저장합니다. 그러면 <code>instance</code>에서도 숨겨진 프로퍼티인 <code>__proto__</code>를 통해 이 메서드들에 접근할 수 있게 됩니다.</p><hr><figure class="highlight js"><figcaption><span>Person이라는 생성자 함수의 prototype에 getName이라는 메서드를 지정한 예제</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이제 <code>Person</code>의 <code>instance</code>는 <code>__proto__</code>프로퍼티를 통해 <code>getName</code>을 호출할 수 있습니다.<br><code>instance</code>의 <code>__proto__</code>가 <code>Constructor</code>의 <code>prototype</code>프로퍼티를 참조하므로 결국 둘은 같은 객체를 바라보기 때문입니다.</p><figure class="highlight js"><figcaption><span>this 바인딩 값</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suzi = <span class="keyword">new</span> Person(<span class="string">'Suzi'</span>);</span><br><span class="line">suzi.__proto__.getName(); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">Person.prototype === suzi.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><code>suzi.__proto__.getName();</code>를 실행해 <code>undefined</code>가 나왔다는 것은 이 변수가 “호출할 수 있는 함수”에 해당한다는 것을 의미합니다. </li></ul><ul><li>만약 함수가 아닌 다른 데이터 값이었다면 <code>TypeError</code>가 발생했을 것입니다. 에러가 아닌 <code>undefined</code>를 반환했으므로 <code>getName</code>이 실제로 실행됐고 <code>getName</code>이 함수라는 것이 입증됐습니다.</li></ul><ul><li><code>undefined</code>를 반환한 이유는 <code>this</code>의 바인딩 값이 잘못됐음을 의미합니다.</li></ul><ul><li><code>suzi.__proto__.getName();</code>에서 <code>getName</code> 함수 내부에서의 <code>this</code>는 <code>suzi</code>가 아니라 메서드명 바로앞의 객체 즉, <code>suzi.__proto__</code>를 참조하게 되는 것입니다. </li></ul><ul><li><code>suzi.__proto__</code> 내부에 <code>name</code>프로퍼티가 없으므로 엔진이 “데이터 영역에 지정되지 않은 식별자에 접근할 때”를 뜻하는 <code>undefined</code>를 반환하게 됩니다. </li></ul><hr><p><code>__proto__</code> 객체에 <code>name</code> 프로퍼티가 있다면 <code>undefined</code>가 아니라 프로퍼티 값이 출력 되겠죠?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suzi = <span class="keyword">new</span> Person(<span class="string">'Suzi'</span>);</span><br><span class="line">suzi.__proto__._name = <span class="string">'SUZI__proto__'</span>;</span><br><span class="line">suzi.__proto__.getName(); <span class="comment">// SUZI__proto__</span></span><br></pre></td></tr></table></figure><p>위 예제 코드들의 관건은 <code>this</code>가 어떤 값을 참조하게 되는가 였습니다.<br><code>this</code>가 <code>instance</code>를 참조하게 하는 방법은 간단합니다.<br><code>__proto__</code>를 생략하고 <code>instance</code>뒤에 바로 메서드를 작성하면 됩니다.</p><figure class="highlight js"><figcaption><span>__proto__ 생략</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suzi = <span class="keyword">new</span> Person(<span class="string">'Suzi'</span>, <span class="number">28</span>);</span><br><span class="line">suzi.getName(); <span class="comment">// Suzi</span></span><br></pre></td></tr></table></figure><p>이런 코드가 실행되는 이유는 <code>__proto__</code>가 생략 가능한 프로퍼티이기 때문입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suzi.__proto__.getName</span><br><span class="line">&gt; suzi(.__proto__).getName</span><br><span class="line">== suzi.getName</span><br></pre></td></tr></table></figure><ul><li><p>정리하면 </p><ul><li><code>__proto__</code>를 생략하지 않으면 <code>this</code>는 <code>suzi.__proto__</code>를 참조 (내부에 name프로퍼티 존재하지 않음)</li><li>생략하면 <code>suzi</code>를 참조 가능해짐. (suzi.getName 형태, name 프로퍼티 존재)</li></ul><p><img src="/images/prototype_schematic2.png" alt="prototype schematic2"></p><ul><li>new 연산자로 <code>Constructor</code> 호출시 <code>instance</code> 생성되고<br><code>instance</code>의 생략가능한 프로퍼티인 <code>__proto__</code>는<br><code>Constructor</code>의 <code>prototype</code>을 참조</li></ul></li></ul><figure class="highlight js"><figcaption><span>prototype과 __proto__</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Constructor = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Constructor.prototype.method1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Constructor.prototype.property1 = <span class="string">'Constructor Prototype Property'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Constructor(<span class="string">'Instance'</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(Constructor); <span class="comment">//Constructor의 디렉터리 구조 출력</span></span><br><span class="line"><span class="built_in">console</span>.dir(instance); <span class="comment">//instance의 디렉터리 구조 출력</span></span><br></pre></td></tr></table></figure><ul><li>위 예제를 크롬 개발자도구에서 실행한 결과</li></ul><p><img src="/images/prototype_Constructor.png" alt="prototype Constructor"></p><ul><li><code>Constructor</code>의 디렉터리 구조를 출력한<ul><li>첫 번째 줄에 함수라는 의미의 <code>f</code> 와 함수이름 <code>Constructor</code>, 인자 <code>name</code>이 출력되었습니다.</li><li>그 내부에는 <mark>옅은 색</mark>의 argument, caller, length, name, <code>prototype</code>, &#95;&#95;proto&#95;&#95;등의 프로퍼티들이 나타납니다.</li><li>내부 프로퍼티중 <code>prototype</code>을 열면 개발자가 직접 추가한 <code>metod1</code>, <code>property1</code>등의 값은 <mark>짙은 색</mark>으로 보이고, constructor, &#95;&#95;proto&#95;&#95; 등은 <mark>옅은 색</mark>으로 보입니다.<pre><code>이런 색상의 차이는 { enumerable: false } 속성이 부여된 프로퍼티인지 여부에 따릅니다.짙은 색은 enumerable, 즉 열거 가능한 프로퍼티임을 의미하고, 옅은 색은 innumerable, 즉 열거할 수 없는 프로퍼티입니다.for in 문 등으로 객체의 프로퍼티 전체에 접근할 때 접근 가능 여부를 색상으로 구분지어 표기하는 것입니다.</code></pre></li></ul></li></ul><div align="center"><p><img src="/images/prototype_Instance.png" alt="prototype Instance"></p></div><ul><li><code>instance</code>의 디렉터리 구조를 출력한<ul><li>첫 번째 줄에 <code>Constructor</code>가 출력됩니다.<br>생성자 함수의 <code>instance</code>는 해당 생성자 함수의 이름을 표기함으로<br>해당 함수의 <code>instance</code>임을 나타냅니다.</li><li><code>Constructor</code>를 열어보면 <code>name</code>프로퍼티가 짙은 색으로 표기되고, <code>__proto__</code>프로퍼티가 옅은 색으로 표기됩니다.</li><li><code>__proto__</code>를 열어보면 <code>method1</code>, <code>property1</code>, <code>constructor</code>, <code>__proto__</code> 등이 있으므로,<br><code>Constructor</code>의 <code>prototype</code>과 동일한 내용으로 구성돼 있음을 확인할 수 있습니다.</li></ul></li></ul><hr><h4 id="내장-built-in-생성자-함수-Array-구조"><a href="#내장-built-in-생성자-함수-Array-구조" class="headerlink" title="내장(built-in) 생성자 함수 Array 구조"></a>내장(built-in) 생성자 함수 Array 구조</h4><figure class="highlight js"><figcaption><span>Array</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.dir(arr);</span><br><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">Array</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/prototype_arr_Array.png" alt="prototype arr and Array"></p><ul><li><p>arr</p><ul><li>첫 줄에 <code>Array(2)</code>가 표기됩니다.</li><li><code>Array</code> 생성자 함수를 원본으로 생성됐고, <code>length</code> 값 2를 알 수 있습니다.</li><li><code>index 0, 1</code>은 짙은 색으로 length와 &#95;&#95;proto&#95;&#95;는 옅은 색으로 표기됩니다.</li><li>&#95;&#95;proto&#95;&#95; 에는 Array 메서드 들이 포함되어 있습니다.</li></ul></li><li><p>Array</p><ul><li>첫 줄에 함수를 뜻하는 <code>f</code>가 표시됩니다.</li><li>함수의 프로퍼티인 <code>argument</code>, <code>caller</code>, <code>length</code>, <code>name</code>등이 표기됩니다.</li><li>또한 <code>Array</code> 함수의 정적 메서드 <code>from</code>, <code>isArray</code> <code>of</code> 등도 있습니다.</li><li><code>prototype</code>을 열어보면 왼쪽(arr)의 &#95;&#95;proto&#95;&#95;와 동일한 구성임을 확인할 수 있습니다.</li></ul></li></ul><ul><li><p>위 결과를 도식으로 나타면 다음과 같습니다.<br><img src="/images/prototype_Array_schematic.png" alt="prototype Array schematic"></p></li><li><p>Array를 new 연산자와 함께 호출하든, 배열 리터럴을 생성하든 <code>instance</code>인 [1, 2]가 만들어집니다.</p></li></ul><ul><li><code>instance</code>의 <code>__proto__</code>은 Array.prototype을 참조함으로 <code>instance</code>가 push, pop, forEach 등 Array 메서드를 자신의 것처럼 호출할 수 있습니다.(<code>__proto__</code>가 생략 가능하도록 설계돼 있기 때문에)</li></ul><ul><li><strong>한편 <code>Array의 prototype 프로퍼티 내부</code>에 있지 않은 <code>from, isArray</code> 등의 메서드들은 <code>instance</code>가 직접 호출할 수 없습니다. 이들은 <code>Array 생성자 함수</code>에서 직접 접근해야 실행 가능합니다.</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array 생성자 함수를 원본으로하는 instance인 arr</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// __proto__ 생략 가능으로 인한 Array 메서드 직접 호출 </span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;); <span class="comment">// (o)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array의 prototype 프로퍼티 내부에 없는 메서드는</span></span><br><span class="line"><span class="comment">// instance가 직접 호출 불가능</span></span><br><span class="line">arr.isArray(); <span class="comment">// (x) TypeError: arr.isArray is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array 생성자 함수에서 직접 접근하여 실행해야 됨</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr); <span class="comment">// (o) true</span></span><br></pre></td></tr></table></figure><hr><h3 id="constructor-프로퍼티"><a href="#constructor-프로퍼티" class="headerlink" title="constructor 프로퍼티"></a>constructor 프로퍼티</h3><p><code>생성자 함수</code>의 프로퍼티인 <code>prototype</code> 객체 내부에는 <code>constructor</code> 프로퍼티가 있습니다.<br><code>instance</code>의 <code>__proto__</code> 객체 내부에도 마찬가지로 존재합니다.<br><code>constructor</code> 프로퍼티는 원래의 생성자 함수(자기 자신)를 참조하고,<br><code>instance</code>로부터 그 원형을 알 수 있는 수단으로 <code>instance</code>와의 관계에 있어 필요한 정보입니다.</p><figure class="highlight js"><figcaption><span>constructor 프로퍼티 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">arr.__proto__.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">arr.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> arr.constructor(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [3, 4]</span></span><br></pre></td></tr></table></figure><hr><h4 id="다양한-constructor-접근-방법"><a href="#다양한-constructor-접근-방법" class="headerlink" title="다양한 constructor 접근 방법"></a>다양한 constructor 접근 방법</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'사람1'</span>); <span class="comment">// Person &#123; name: "사람1" &#125; true</span></span><br><span class="line"><span class="keyword">var</span> p1Proto = <span class="built_in">Object</span>.getPrototypeOf(p1);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person.prototype.constructor(<span class="string">'사람2'</span>); <span class="comment">// Person &#123; name: "사람2" &#125; true</span></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> p1Proto.constructor(<span class="string">'사람3'</span>); <span class="comment">// Person &#123; name: "사람3" &#125; true</span></span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> p1.__proto__.constructor(<span class="string">'사람4'</span>); <span class="comment">// Person &#123; name: "사람4" &#125; true</span></span><br><span class="line"><span class="keyword">var</span> p5 = <span class="keyword">new</span> p1.constructor(<span class="string">'사람5'</span>); <span class="comment">// Person &#123; name: "사람5" &#125; true</span></span><br><span class="line"></span><br><span class="line">[p1, p2, p3, p4, p5].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p, p <span class="keyword">instanceof</span> Person);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>다음은 모두 동일한 대상을 가리키게 됩니다.</strong></li></ul><pre><code>1. [Constructor]2. [instance].__proto__.constructor3. [instance].constructor4. Object.getPrototypeOf([instance]).constructor5. [Constructor].prototype.constructor</code></pre><ul><li><strong>다음은 모두 동일한 객체에 접근할 수 있습니다.</strong></li></ul><pre><code>1. [Constructor].prototype2. [instance].__proto__3. [instance]4. Object.getPrototypeOf([instance])</code></pre><ul><li>따라서 p1 부터 p5까지 모두 Person의 instance입니다.</li></ul><hr><h2 id="prototype_chain">프로토타입 체인</h2><hr><h3 id="메서드-오버라이드"><a href="#메서드-오버라이드" class="headerlink" title="메서드 오버라이드"></a>메서드 오버라이드</h3><p><code>instance</code>가 동일한 이름의 프로퍼티 또는 메서드를 가지고 있는 상황이라면</p><p><code>instance.method()</code> 형태로 호출했을 때<br><code>instance.__proto__.method</code>가 아닌 <code>instance</code>객체에 있는 해당 <code>method</code>가 호출됩니다.<br>여기서 일어난 현상을 메서드 위에 메서드를 덮어씌웠다고 하여 <mark>메서드 오버라이드</mark>라고합니다.</p><ul><li>자바스크립트 엔진은 프로퍼티(혹은 메서드)를 찾을 때 가장 가까운 대상인 자신의 프로퍼티를 먼저 검색하고, 없으면 그다음으로 가까운 대상인 &#95;&#95;proto&#95;&#95;를 검색합니다.<br>그러므로 메서드 오버라이드 됐을 때 &#95;&#95;proto&#95;&#95;에 있는 메서드는 우선 순위에서 밀려 호출되지 않는 것입니다.</li></ul><hr><h4 id="메서드-오버라이드된-상태에서-prototype에-있는-메서드에-접근법"><a href="#메서드-오버라이드된-상태에서-prototype에-있는-메서드에-접근법" class="headerlink" title="메서드 오버라이드된 상태에서 prototype에 있는 메서드에 접근법"></a>메서드 오버라이드된 상태에서 prototype에 있는 메서드에 접근법</h4><blockquote><p>instance.&#95;&#95;proto&#95;&#95;.method()</p></blockquote><p>형태로 호출하면 정상적으로 <code>prototype</code>에 있는 <code>method</code>에 접근할 수 있습니다.<br>하지만 <code>this</code>가 <code>instance</code>를 바라보지 않고 있습니다.</p><p><code>call</code>이나 <code>apply</code>를 사용하면</p><blockquote><p>instance.&#95;&#95;proto&#95;&#95;.method.call(thisArg) 형태로 작성하여 <code>this</code> 대상을 지정합니다.</p></blockquote><hr><h3 id="프로토타입-체인"><a href="#프로토타입-체인" class="headerlink" title="프로토타입 체인"></a>프로토타입 체인</h3><p><mark>자바스크립트의 모든 객체의 최상위 객체에는 Object 객체가 존재합니다.</mark></p><p>따라서 모든 객체의 <code>__proto__</code>에는 <code>Object.prototype</code>이 연결됩니다.</p><p><strong>Array 객체를 예시로 든 최상위 객체 Object와의 구조 도식(<del>prototype 역시 객체입니다.</del>)</strong></p><p><img src="/images/%EA%B0%9D%EC%B2%B4%EC%9D%98_%EC%B5%9C%EC%83%81%EC%9C%84_%EA%B0%9D%EC%B2%B4_Object.png" alt="객체의 최상위 객체 Object"></p><ul><li><p>앞에서 <code>__proto__</code>는 생략가능한 프로퍼티이므로 <code>배열[]</code>에서 <code>Array.prototype</code> 내부의 메서드를 직접 호출할 수 있었습니다. </p></li><li><p>마찬가지로 <code>배열[]</code>의 <code>__proto__</code>를 계속 따라가다 보면 <code>Object.prototype</code>이 있으므로 <code>Object.prototype</code>의 내부 메서드도 직접 호출할 수 있습니다.</p></li></ul><hr><p>이러한 <code>__proto__</code> 프로퍼티 내부에 다시 <code>__proto__</code>프로퍼티가 연쇄적으로 이어진 것을<br><strong>프로토타입 체인</strong>(<code>prototype chain</code>)이라 하고, </p><p>이 체인을 따라 검색하는 것을 <strong>프로토타입 체이닝</strong>(<code>prototype chaining</code>)이라고 합니다.</p><hr><h3 id="객체-전용-메서드의-예외사항"><a href="#객체-전용-메서드의-예외사항" class="headerlink" title="객체 전용 메서드의 예외사항"></a>객체 전용 메서드의 예외사항</h3><p>어떤 생성자 함수이든 <code>prototype</code>은 객체이기 때문에 <code>Object.prototype</code>이 언제나 프로토타입 체인의 최상단에 존재하게 됩니다.</p><p>따라서 <strong>객체에서만 사용할 메서드는 다른 데이터 타입처럼 프로토타입 객체 안에 정의할 수 없습니다.</strong></p><p><strong>객체에서만 사용할 메서드를 <code>Object.prototype</code>내부에 정의한다면 다른 데이터 타입도 해당 메서드를 사용할 수 있게 되기 때문입니다.</strong>(참조형 데이터뿐 아니라 기본형 데이터도 &#95;&#95;proto&#95;&#95;에 반복적으로 접근하여 도달하는 최상위 객체가 Object.prototype이 됨)</p><ul><li>이 같은 이유로 객체만을 대상으로 동작하는 <strong>Object 전용 메서드</strong>들은 부득이 <code>Object.prototype</code>이 아닌 <code>Object</code>에 정적(<code>static</code>)메서드로 구현돼 있습니다.</li></ul><p><img src="/images/Object_prototype.png" alt="Object-prototype"></p><ul><li>한편 <code>Object.prototype</code>에는 어떤 데이터에서도 활용할 수 있는 범용적인 메서드들만 있습니다.<br>toString, hasOwnProperty, valueOf, isPrototypeOf 등은 모든 <code>instance</code>가 직접 호출할 수 있습니다.</li></ul><hr><h3 id="다중-프로토타입-체인"><a href="#다중-프로토타입-체인" class="headerlink" title="다중 프로토타입 체인"></a>다중 프로토타입 체인</h3><p>자바스크립트의 기본 내장 데이터 타입들은 모두 프로토타입 체인 1단계(객체), 2단계(나머지)로 끝나는 경우가 있지만 <strong>사용자가 새롭게 만드는 경우 계속해서 단계를 추가할 수 있습니다.</strong></p><p><code>__proto__</code>를 연결하는 방법은 <code>__proto__</code>가 가리키는 대상을<br>생성자 함수의 <code>prototype</code>이 연결하고자 하는 상위 생성자 함수의 <code>instance</code>를 지정해 주면됩니다.</p><figure class="highlight js"><figcaption><span>다중 프로토타입 체인</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Grade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>[i] = args[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.length = args.length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Grade(<span class="number">100</span>, <span class="number">80</span>);</span><br><span class="line">Grade.prototype = [];</span><br></pre></td></tr></table></figure><ul><li><code>Grade</code>의 <code>instance</code>는 여러개의 인자를 받아 각 순서대로 인덱싱해서 저장합니다. (<code>유사배열객체</code>)</li></ul><ul><li><code>변수 g</code> 가 <code>Grade</code>의 <code>instance</code>를 바라봅니다.</li></ul><ul><li><code>유사배열객체</code>지만 <strong>배열 메서드를 직접 호출할 수 있게</strong> 만들고자 합니다.</li></ul><ul><li><code>g.__proto__</code> 즉, <code>Grade.prototype</code>이 배열의 <code>instance</code>를 바라보게 해주면 됩니다.<br><code>Grade.prototype = [];</code></li></ul><ul><li><code>Grade</code>의 <code>instance</code>인 <code>g</code>에서 직접 배열 메서드를 사용할수 있게됩니다.</li></ul><p><code>g</code>의 <code>instance</code>는 프로토타입 체인을 따라 <code>Grade.prototype</code>, <code>Array.prototype</code>, <code>Object.prototype</code>에 접근할 수 있는 <strong>3단계 다중프로토타입 체인 형식</strong>입니다.</p><hr><h2 id="point">정리</h2><ul><li><code>__proto__</code>는 생략 가능한 속성이므로 <code>instance</code>에서 상위 객체의 <code>prototype</code>에 있는 메서드를 직접호출할 수 있습니다.</li></ul><ul><li><code>Constructor</code> <strong>프로퍼티는 생성자 함수 자기 자신을 가리킵니다.</strong><br><code>instance</code>에서 <strong>자신의 생성자 함수가 무엇인지 알고자할 때 필요한 수단입니다.</strong></li></ul><ul><li><strong>참조형 데이터뿐 아니라 기본형 데이터도 &#95;&#95;proto&#95;&#95;에 반복적으로 접근하면 최상위 객체 <code>Object.prototype</code>에 도달하게 됩니다.</strong></li></ul><ul><li><code>Object.prototype</code>에는 <strong>모든 데이터 타입에서 사용할 수 있는 범용적인 메서드만 존재합니다.</strong><br><code>Object</code> 전용 메서드는 <code>Object</code> 생성자 함수에 정적(<code>static</code>)하게 담겨있습니다.</li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/05/prototype-Core-JavaScript/#disqus_thread</comments>
    </item>
    
    <item>
      <title>클로저 -Core JavaScript</title>
      <link>https://hdw0903.github.io/2020/05/03/%ED%81%B4%EB%A1%9C%EC%A0%80-Core-JavaScript/</link>
      <guid>https://hdw0903.github.io/2020/05/03/%ED%81%B4%EB%A1%9C%EC%A0%80-Core-JavaScript/</guid>
      <pubDate>Sun, 03 May 2020 06:56:17 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;클로저 (Closure)&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/03/클로저-Core-JavaScript/#closure&quot;&gt;클로저의 의미 및 원리 이해&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/03/클로저-Core-JavaScript/#closure_memory&quot;&gt;클로저와 메모리 관리&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/03/클로저-Core-JavaScript/#closure_ex&quot;&gt;클로저 활용 사례&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;콜백 함수 내부에서 외부 데이터를 사용하고자 할 때&lt;/li&gt;
&lt;li&gt;접근 권한 제어 (정보 은닉)&lt;/li&gt;
&lt;li&gt;부분 적용 함수&lt;/li&gt;
&lt;li&gt;커링 함수&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/03/클로저-Core-JavaScript/#&quot;&gt;정리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<ul><li>클로저 (Closure)<ul><li><a href="/2020/05/03/클로저-Core-JavaScript/#closure">클로저의 의미 및 원리 이해</a></li><li><a href="/2020/05/03/클로저-Core-JavaScript/#closure_memory">클로저와 메모리 관리</a></li><li><a href="/2020/05/03/클로저-Core-JavaScript/#closure_ex">클로저 활용 사례</a><ul><li>콜백 함수 내부에서 외부 데이터를 사용하고자 할 때</li><li>접근 권한 제어 (정보 은닉)</li><li>부분 적용 함수</li><li>커링 함수</li></ul></li><li><a href="/2020/05/03/클로저-Core-JavaScript/#">정리</a></li></ul></li></ul><a id="more"></a><hr><h2 id="closure">클로저의 의미 및 원리 이해</h2><p>클로저(<code>Closure</code>)는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성입니다.<br>자바스크립트 고유의 개념이 아니라서 <code>ECMAScript</code> 명세에서도 클로저의 정의를 다루지 않고 있고, 다양한 문헌에서 제각각 클로저를 다르게 정의 또는 설명하고 있습니다.</p><p>다양한 서적에서 클로저를 한 문장으로 요약해서 설명하는 부분들을 소개하면 다음과 같습니다.</p><pre><code>* 자신을 내포하는 함수의 컨텍스트에 접근할 수 있는 함수* 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 것* 함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수* 이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수* 자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합* 로컬 변수를 참조하고 있는 함수 내의 함수* 자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수</code></pre><p><strong>MDN</strong> 에서는 클로저를 함수와 그 함수가 선언될 당시의 <code>LexicalEnvironment</code>의 조합이라고 소개하고,<br>다른 말로 클로저는 내부 함수에서 외부 함수의 범위로 접근할 수 있게 해주는 함수라고 합니다.</p><p>선언될 당시의 <code>LexicalEnvironment</code>는 실행 컨텍스트의 구성 요소 중 하나인 <code>outerEnvironmentReference</code>에 해당합니다.<br><code>LexicalEnvironment</code>의 <code>environmentRecord</code>와 <code>outerEnvironmentReference</code>에 의해 변수의 유효범위인 스코프가 결정되고 스코프 체인이 가능해집니다.</p><ul><li><code>컨텍스트 A</code>에서 선언한 <code>내부 함수B</code>의 실행 컨텍스트가 활성화된 시점에서는 B의 <code>outerEnvironmentReference</code>가 참조하는 대상인 A의 <code>LexicalEnvironment</code>에도 접근이 가능해 집니다. A에서는 B에서 선언한 변수에 접근할 수 없지만 B에서는 A에 선언한 변수에 접근이 가능해집니다.</li></ul><ul><li>이런 내부함수에서 외부 변수를 참조하게 되는 경우가, 선언될 당시의 <code>LexicalEnvironment</code>와의 상호관계(조합)의 의미가 됩니다.</li></ul><figure class="highlight js"><figcaption><span>외부 함수의 변수를 참조하는 내부 함수 -1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++a);</span><br><span class="line">  &#125;;</span><br><span class="line">  inner();</span><br><span class="line">&#125;;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><ol><li><code>outer</code> 함수에 변수 a를 선언했고 1을 할당했습니다.</li></ol><ol start="2"><li><code>outer</code>의 내부함수인 <code>inner</code> 함수에서 a의 값을 1 증가시키고 출력합니다.</li></ol><ul><li><code>inner</code>함수 내부에서는 a를 선언하지 않았기 때문에 <code>environmentRecord</code>에서 값을 찾지 못하므로 <code>outerEnvironmentReference</code>에 지정된 상위 컨텍스트인 <code>outer</code>의 <code>LexicalEnvironment</code>에 접근하여 다시 a를 찾습니다.</li></ul><ul><li><code>outer</code> 함수의 실행 컨텍스트가 종료되면 <code>LexicalEnvironment</code>에 저장된 식별자들(a,inner)에 대한 참조를 지웁니다. 그러면 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 <code>가비지컬렉터(GC)</code>의 수집 대상이 됩니다.</li></ul><figure class="highlight js"><figcaption><span>외부 함수의 변수를 참조하는 내부 함수 -2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> inner();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> outer2 = outer();</span><br><span class="line"><span class="built_in">console</span>.log(outer2); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>이 예제 역시 <code>inner</code>함수 내부에서 외부변수인 a를 사용했습니다.<br><code>inner</code> 함수를 실행한 결과를 <code>return</code> 하고 나면 <code>outer</code>함수의 실행 컨텍스트가 종료된 시점에는 a변수를 참조하는 대상이 없어집니다. 그러므로 예제1과 마찬가지로 식별자들의(a,inner) 값들은 <code>가비지컬렉터(GC)</code>에 의해 소멸됩니다.</li></ul><ul><li>예제1과 예제2는 <code>outer</code>함수의 실행 컨텍스트가 종료되기 이전에 <code>inner</code> 함수의 실행 컨텍스트가 종료돼 있으며, 이후 별도로 <code>inner</code> 함수를 호출할 수 없다는 공통점을 가지고 있습니다.</li></ul><p><mark>그렇다면 outer의 실행 컨텍스트가 종료된 후에도 inner 함수를 호출할 수 있게 만들면 어떨까요?</mark></p><figure class="highlight js"><figcaption><span>외부 함수의 변수를 참조하는 내부 함수 -3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> outer2 = outer();</span><br><span class="line"><span class="built_in">console</span>.log(outer2()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(outer2()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ol><li><code>return inner()</code> 함수의 실행 결과가 아닌 <code>return inner</code> 함수 자체를 반환했습니다.</li></ol><ol start="2"><li><code>outer2</code> 변수는 <code>outer</code>함수의 실행 결과인 <code>inner</code>함수 자체를 참조하게 됩니다.<br><code>outer2</code> 호출시 <code>inner</code> 함수가 실행됨.</li></ol><ol start="3"><li><code>inner</code> 함수의 실행 컨텍스트의 <code>environmentRecord</code>에는 수집할 정보가 없습니다. <code>outerEnvironmentReference</code>에는 <code>inner</code> 함수가 선언된 위치의 <code>LexicalEnvironment</code>가 참조복사 됩니다. <code>inner</code>함수는 <code>outer</code> 함수 내부에서 선언됐으므로, <code>outer</code> 함수의 <code>LexicalEnvironment</code>가 담깁니다.</li></ol><ol start="4"><li>스코프체이닝에 따라 <code>outer</code>에서 선언한 변수 a에 접근해 1만큼 증가시킨후 결과 값인 2를 반환하고, <code>inner</code>함수의 실행 컨텍스트가 종료됩니다.</li></ol><ol start="5"><li><code>outer2</code><u>를 다시 호출하면 같은 방식으로 a의 값을 2에서 1만큼 증가시켜 그 결과 값인 3을 반환합니다.</u></li></ol><p><strong>중요 포인트</strong></p><ul><li><code>outer</code>함수의 실행 컨텍스트는 종료된 상태인데 어떻게 외부 함수의 변수(<code>outer</code> 함수의 <code>LexicalEnvironment</code>)에 접근할 수 있는 걸까?</li></ul><ul><li>이는 가비지컬렉터의 동작 방식 때문입니다.</li></ul><ul><li><mark>어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 가비지컬렉터(GC)의 대상이 되지 않습니다.</mark></li></ul><ul><li><code>outer</code> 함수는 실행 종료 시점에 <code>inner</code> 함수를 반환했습니다. <code>outer</code> 함수는 <code>inner</code>함수를 참조하게 되고 외부함수인 <code>outer</code>의 실행이 종료되었지만 내부함수인 <code>inner</code>함수는 언젠가 <code>outer()</code>형식 (변수 outer2와 같은)으로 호출될 수 있습니다.</li></ul><ul><li><code>inner</code> 함수 역시 <code>outer</code>의 변수를 참조하므로 실행 컨텍스트가 활성화 되면 <code>outerEnvironmentReference</code>가 <code>outer</code> 함수의 <code>LexicalEnvironment</code>를 필요로 하게되므로 <code>가비지컬렉터(GC)</code>의 대상에서 제외됩니다. 그 덕에 <code>inner</code>함수가 외부함수의 변수에 접근할 수 있는 것입니다.</li></ul><ul><li>클로저란 :<br><mark>외부 함수에서 선언한 변수를 참조하는 내부 함수를 외부로 전달할 경우 외부 함수의 실행 컨텍스트가 종료된 이후에도 변수가 사라지지 않는 현상</mark></li></ul><ul><li>“내부함수를 외부로 전달”이 return만을 의미하는 것은 아님. 다른 경우도 존재</li></ul><figure class="highlight js"><figcaption><span>return 없이 클로저가 발생하는 경우</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) setInterval/setTimeout</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>; <span class="comment">// 외부 함수의 변수를 내부 함수에서</span></span><br><span class="line">  <span class="keyword">var</span> intervalId = <span class="literal">null</span>; <span class="comment">// 참조하고 있으므로 GC의 대상이 되지 않음. </span></span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++a &gt;= <span class="number">10</span>) &#123; <span class="comment">// 외부 함수의 변수a 참조</span></span><br><span class="line">      clearInterval(intervalId); <span class="comment">// 외부 함수의 변수 intervalId 참조</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;;</span><br><span class="line">  intervalId = setInterval(inner, <span class="number">1000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>별도의 외부객체인 window의 메서드(setTimeout 또는 setInterval)에 전달할 콜백 함수 내부에서 지역변수를 참조합니다.</p><figure class="highlight js"><figcaption><span>return 없이 클로저가 발생하는 경우</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (2) eventListener</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>);</span><br><span class="line">  button.innerText = <span class="string">'click'</span>;</span><br><span class="line">  button.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++count, <span class="string">'times clicked'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>별도의 외부 객체인 DOM의 메서드 (addEventListener)에 등록할 handler 함수 내부에서 지역변수를 참조합니다.</p><p><mark>두 상황 모두 두 지역변수를 참조하는 내부함수를 외부에 전달했기 때문에 클로저(closure)입니다.</mark></p><hr><h2 id="closure_memory">클로저와 메모리 관리</h2><ul><li><p><mark>클로저는 객체지향과 함수형 모두를 아우르는 매우 중요한 개념입니다.</mark></p></li><li><p>메모리 누수:<br>개발자의 의도와 달리 어떤 값의 참조 카운트가 0이 되지 않아 GC의 수거 대상이 되지 않는 경우 발생할 수 있습니다.<br>(개발자가 의도적으로 참조 카운트가 0이 되지 않게 설계한 경우는 ‘누수’라는 표현은 맞지 않습니다.)</p></li><li><p><mark>클로저는 의도대로 설계한 “메모리 소모”에 대한 관리법을 잘 파악해서 적용하는 것이 중요합니다.</mark></p></li></ul><hr><h3 id="메모리-관리-방법"><a href="#메모리-관리-방법" class="headerlink" title="메모리 관리 방법"></a>메모리 관리 방법</h3><p>클로저는 필요에 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생합니다.<br>그렇다면 <u>필요성이 사라진 시점</u>에는 더는 메모리를 소모하지 않게 해주면 됩니다.</p><p>참조 카운트를 0으로 만들면(GC의 작동원리) GC가 수거해 갈것이고, 이때 소모됐던 메모리가 회수됩니다.</p><ul><li>참조 카운트를 0으로 만드는 방법 ?<br>식별자에 참조형이 아닌 기본형 데이터(보통 <code>null</code>이나 <code>undefined</code>)를 할당하면 됩니다.</li></ul><figure class="highlight js"><figcaption><span>클로저의 메모리 관리 - return</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) return에 의한 클로저의 메모리 해제</span></span><br><span class="line"><span class="keyword">var</span> outer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(outer());</span><br><span class="line"><span class="built_in">console</span>.log(outer());</span><br><span class="line">outer = <span class="literal">null</span>; <span class="comment">// outer 식별자의 inner 함수 참조를 끊음</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>클로저의 메모리 관리 - setInterval</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (2) setInterval에 의한 클로저의 메모리 해제</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> intervalId = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++a &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      clearInterval(intervalId);</span><br><span class="line">      inner = <span class="literal">null</span>; <span class="comment">// inner 식별자의 함수 참조를 끊음</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;;</span><br><span class="line">  intervalId = setInterval(inner, <span class="number">1000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>클로저의 메모리 관리 - eventListener</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (3) eventListener에 의한 클로저의 메모리 해제</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>);</span><br><span class="line">  button.innerText = <span class="string">'click'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> clickHandler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++count, <span class="string">'times clicked'</span>);</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      button.removeEventListener(<span class="string">'click'</span>, clickHandler);</span><br><span class="line">      clickHandler = <span class="literal">null</span>; <span class="comment">// clickHandler 식별자의 함수 참조를 끊음</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  button.addEventListener(<span class="string">'click'</span>, clickHandler);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><hr><h2 id="closure_ex">클로저 활용 사례</h2><p>클로저가 실제로 등장하는 활용 사례</p><h3 id="콜백-함수-내부에서-외부-데이터를-사용하고자-할-때"><a href="#콜백-함수-내부에서-외부-데이터를-사용하고자-할-때" class="headerlink" title="콜백 함수 내부에서 외부 데이터를 사용하고자 할 때"></a>콜백 함수 내부에서 외부 데이터를 사용하고자 할 때</h3><p>대표적인 콜백 함수 중 하나인 이벤트 리스너에 관한 예시</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'peach'</span>];</span><br><span class="line"><span class="keyword">var</span> $ul = <span class="built_in">document</span>.createElement(<span class="string">'ul'</span>); <span class="comment">// (공통 코드)</span></span><br><span class="line"></span><br><span class="line">fruits.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// (A)</span></span><br><span class="line">  <span class="keyword">var</span> $li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  $li.innerText = fruit;</span><br><span class="line">  $li.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// (B)</span></span><br><span class="line">    alert(<span class="string">'your choice is '</span> + fruit);</span><br><span class="line">  &#125;);</span><br><span class="line">  $ul.appendChild($li);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild($ul);</span><br></pre></td></tr></table></figure><ol><li><code>fruits</code> 변수를 순회하며 <code>li</code>를 생성하고 각 <code>li</code>를 클릭하면 해당 리스너의 콜백 함수가 실행됩니다.</li></ol><ol start="2"><li><code>forEach</code>메서드에 넘겨준 익명의 콜백 함수(A)는 내부에서 외부 변수를 사용하지 않으므로 클로저가 없습니다.</li></ol><ol start="3"><li><code>addEventListener</code>에 넘겨준 콜백 함수(B)에는 함수내의 <code>fruit</code>라는 외부 변수를 참조하고 있으므로 클로저가 있습니다.</li></ol><ol start="4"><li>(A)는 <code>fruits</code>의 개수만큼 실행되며, 그때마다 새로운 실행 컨텍스트가 생성됩니다.</li></ol><ol start="5"><li>(A)의 실행 종료 여부와 무관하게 클릭 이벤트에 의해 각 컨텍스트의 (B)가 실행될 때는 (B)의 <code>outerEnvironmentReference</code>가 (A)의 <code>LexicalEnvironment</code>를 참조하게 됩니다.</li></ol><ol start="6"><li>따라서 (B)함수가 참조할 예정인 변수 <code>fruit</code>에 대해서는 (A)함수가 종료된 후에도 <code>CG</code> 대상에서 제외되어 계속 참조 가능하게 됩니다.</li></ol><p>그런데 (B)함수의 쓰임이 콜백 함수에 국한되지 않는 경우라면 반복을 줄이기 위해 (B)함수를 외부로 분리하는 편이 나을 수 있습니다.</p><p>따라서 다음은 <code>fruit</code>을 인자로 받아 출력하는 형태입니다.</p><figure class="highlight js"><figcaption><span>콜백 함수 외부로꺼내어 공통 함수로 사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'peach'</span>];</span><br><span class="line"><span class="keyword">var</span> $ul = <span class="built_in">document</span>.createElement(<span class="string">'ul'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> alertFruit = <span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'your choice is '</span> + fruit);</span><br><span class="line">&#125;;</span><br><span class="line">fruits.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  $li.innerText = fruit;</span><br><span class="line">  $li.addEventListener(<span class="string">'click'</span>, alertFruit);</span><br><span class="line">  $ul.appendChild($li);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild($ul);</span><br><span class="line">alertFruit(fruits[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><ul><li><p>공통 함수로 사용하고자 콜백 함수를 외부로 꺼내어 <code>alertFruit</code>라는 변수에 담았습니다.<br><code>alertFruit</code>를 직접 실행할 수 있게 되었습니다.</p></li><li><p>하지만 각 <code>li</code>를 클릭하면 클릭한 대상의 과일명이 아닌 <code>[object MouseEvent]</code>라는 값이 출력됩니다.<br>이는 콜백 함수의 인자에 대한 제어권을 <code>addEventListener</code>가 가진 상태이며, <code>addEventListener</code>는 콜백 함수를 호출할 때 첫 번째 인자에 “이벤트 객체”를 주입하기 때문입니다.</p></li></ul><p>이 문제는 <code>bind</code>메서드를 활용하면 해결할 수 있습니다.</p><figure class="highlight js"><figcaption><span>bind 메서드 사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'peach'</span>];</span><br><span class="line"><span class="keyword">var</span> $ul = <span class="built_in">document</span>.createElement(<span class="string">'ul'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> alertFruit = <span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'your choice is '</span> + fruit);</span><br><span class="line">&#125;;</span><br><span class="line">fruits.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  $li.innerText = fruit;</span><br><span class="line">  $li.addEventListener(<span class="string">'click'</span>, alertFruit.bind(<span class="literal">null</span>, fruit));</span><br><span class="line">  $ul.appendChild($li);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild($ul);</span><br></pre></td></tr></table></figure><ul><li><p>하지만 <code>bind</code>를 활용하면 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점과,<br>함수 내부에서 <code>this</code>가 참조하는 값이 달라지는점을 감안해야 합니다.</p></li><li><p>이러한 변경사항 마저 발생하지 않게 만들려면 <code>bind</code>메서드가 아닌 다른 방식으로 만들어야 합니다.</p></li></ul><figure class="highlight js"><figcaption><span>고차함수를 사용하여 클로저를 적극적으로 활용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'peach'</span>];</span><br><span class="line"><span class="keyword">var</span> $ul = <span class="built_in">document</span>.createElement(<span class="string">'ul'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> alertFruitBuilder = <span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'your choice is '</span> + fruit);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">fruits.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  $li.innerText = fruit;</span><br><span class="line">  $li.addEventListener(<span class="string">'click'</span>, alertFruitBuilder(fruit));</span><br><span class="line">  $ul.appendChild($li);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild($ul);</span><br></pre></td></tr></table></figure><ul><li>고차함수란 함수를 인자로 받거나 함수를 리턴하는 함수입니다.</li></ul><ol><li><code>alertFruit</code> 함수 대신 <code>alertFruitBuilder</code>라는 이름의 함수를 작성했습니다.<br><code>alertFruitBuilder</code> 함수 내부에서는 다시 익명함수를 반환합니다.</li></ol><ol start="2"><li>이 익명함수 내부의 코드가 기존의 <code>alertFruit</code> 함수의 코드입니다. </li></ol><ol start="3"><li><code>alertFruitBuilder</code> 함수를 실행하면서 <code>fruit</code> 값을 인자로 전달하면, 함수의 실행 결과가<br>다시 함수(<code>return function</code>)가 되며, 이렇게 반환된 함수를 리스너의 콜백 함수로써 전달할 것입니다.</li></ol><ol start="4"><li>클릭 이벤트가 발생하면 이 함수의 실행 컨텍스트가 열리면서 <code>alertFruitBuilder</code>의 파라미터로 넘어온 <code>fruit</code>를 <code>outerEnvironmentReference</code>에 의해 참조할 수 있게됩니다.<br>즉, <code>alertFruitBuilder</code>의 실행 결과로 반환된 함수에는 클로저가 존재합니다.</li></ol><hr><h4 id="콜백-함수-내부에서-외부변수를-참조하기-위한-방법-정리"><a href="#콜백-함수-내부에서-외부변수를-참조하기-위한-방법-정리" class="headerlink" title="콜백 함수 내부에서 외부변수를 참조하기 위한 방법 정리."></a>콜백 함수 내부에서 외부변수를 참조하기 위한 방법 정리.</h4><ol><li>콜백 함수를 내부함수로 선언하여 외부변수를 직접 참조하는 방법.(<code>GC의 참조카운트</code> 이용)</li></ol><ol start="2"><li><code>bind</code>메서드를 활용하여 값을 직접넘겨주는 방법. 클로저는 발생하지 않지만 몇가지 제약이 생김</li></ol><ol start="3"><li>콜백 함수를 고차함수로 바꿔서 클로저를 적극적으로 활용하는 방법. </li></ol><hr><h3 id="접근-권한-제어-은닉"><a href="#접근-권한-제어-은닉" class="headerlink" title="접근 권한 제어(은닉)"></a>접근 권한 제어(은닉)</h3><p>정보은닉(information hiding)은 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈간의 결합도를 낮추고 유연성을 높이고자 하는 현대 프로그래밍 언어의 중요한 개념 중 하나입니다.</p><p>흔히 접근 권한에는 <code>public</code>, <code>private</code>, <code>protected</code> 세 종류가 있습니다.</p><ul><li><p><code>public</code> : 외부에서 접근 가능한 것</p></li><li><p><code>private</code> : 내부에서만 사용하며 외부에 노출되지 않는 것</p></li></ul><p>자바스크립트는 기본적으로 변수 자체에 이러한 접근 권한을 직접 부여하도록 설계돼 있지 않습니다. 하지만 접근 권한 제어가 불가능한 것은 아닙니다. 클로저를 이용하면 함수 차원에서 <code>public</code>한 값과 <code>private</code>한 값을 구분하는 것이 가능합니다.</p><figure class="highlight js"><figcaption><span>public/private -return</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> outer2 = outer();</span><br><span class="line"><span class="built_in">console</span>.log(outer2());</span><br><span class="line"><span class="built_in">console</span>.log(outer2());</span><br></pre></td></tr></table></figure><p>이전에 본 클로저 예제 입니다.</p><ul><li><code>outer</code>함수를 종료할 때 <code>inner</code> 함수를 반환함으로써 <code>outer</code>함수의 지역변수 a의 값을 외부에서도 읽을 수 있게 되었습니다.</li></ul><ul><li>이처럼 클로저를 활용하면 외부 스코프에서 함수 내부의 변수들 중 선택적으로 일부 변수에 대한 접근 권환을 부여할 수 있습니다. (<code>return</code>을 활용하여)</li></ul><ul><li><code>outer</code>함수는 외부(전역 스코프)로 부터 철저하게 격리된 닫힌 공간입니다.<br>외부에서는 외부 공간에 노출돼 있는 <code>outer</code>라는 변수를 통해 <code>outer</code>함수를 실행할 수는 있지만, <code>outer</code>함수 내부에는 어떠한 개입도 할 수 없습니다.<br>외부에는 오직 <code>outer</code>함수가 <code>return</code>한 정보에만 접근할 수 있습니다.<br><code>return</code>값이 외부에 정보를 제공하는 유일한 수단이 됩니다.</li></ul><ul><li>외부에 제공하고자 하는 정보들을 모아서 <code>return</code>하고, 내부에서만 사용할 정보들은 <code>return</code>하지 않는 것으로 접근 권한 제어가 가능한 것입니다.</li></ul><ul><li><code>return</code>한 변수들은 공개 맴버(<code>public member</code>)가 되고, 그렇지 않은 변수들은 비공개 맴버(<code>private member</code>)가 되는 것입니다.</li></ul><hr><h4 id="접근-권한-제어를-통한-보드-게임-예시"><a href="#접근-권한-제어를-통한-보드-게임-예시" class="headerlink" title="접근 권한 제어를 통한 보드 게임 예시"></a>접근 권한 제어를 통한 보드 게임 예시</h4><p>자동차 경주 보드 게임.</p><p>규칙</p><pre><code>1. 각 턴마다 주사위를 굴려 나온 숫자(km)만큼 이동.2. 차량별로 연료량(fuel)과 연비(power)는 무작위로 생성.3. 남은 연료가 이동할 거리에 필요한 연료보다 부족하면 이동 불가.4. 모든 유저가 이동할 수 없는 턴에 게임이 종료됨.5. 게임 종료 시 가장 멀리 이동해 있는 사람이 승리.</code></pre><figure class="highlight js"><figcaption><span>규칙에 따른 간단한 자동차 객체</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = &#123;</span><br><span class="line">  fuel: <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">10</span>), <span class="comment">// 연료(L)</span></span><br><span class="line">  power: <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">3</span> + <span class="number">2</span>), <span class="comment">// 연비(km/L)</span></span><br><span class="line">  moved: <span class="number">0</span>, <span class="comment">// 총 이동거리</span></span><br><span class="line">  run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> km = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">var</span> wasteFuel = km / <span class="keyword">this</span>.power;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fuel &lt; wasteFuel) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'이동불가'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.fuel -= wasteFuel;</span><br><span class="line">    <span class="keyword">this</span>.moved += km;</span><br><span class="line">    <span class="built_in">console</span>.log(km + <span class="string">'km 이동 (총 '</span> + <span class="keyword">this</span>.moved + <span class="string">'km)'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>위 코드는 <code>run</code> 메서드를 실행할 때마다 <code>car</code>객체의 <code>fuel</code>, <code>moved</code> 값이 변합니다.</p><p>하지만 자바스크립트를 아는사람이 <code>car</code>객체의 <code>fuel</code>, <code>power</code>, <code>moved</code>값을 직접 지정해 버린다면 공평한 게임이 되지 못합니다. </p><ul><li>이렇게 값을 바꾸지 못하도록 객체가 아닌 함수로 만들고, 필요한 맴버만을 <code>return</code>할 필요가 있습니다.</li></ul><figure class="highlight js"><figcaption><span>함수를 실행함으로써 객체 생성</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createCar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fuel = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">10</span>); <span class="comment">// 연료(L)</span></span><br><span class="line">  <span class="keyword">var</span> power = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">3</span> + <span class="number">2</span>); <span class="comment">// 연비(km / L)</span></span><br><span class="line">  <span class="keyword">var</span> moved = <span class="number">0</span>; <span class="comment">// 총 이동거리</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> moved() &#123;</span><br><span class="line">      <span class="keyword">return</span> moved;</span><br><span class="line">    &#125;,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> km = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">6</span>);</span><br><span class="line">      <span class="keyword">var</span> wasteFuel = km / power;</span><br><span class="line">      <span class="keyword">if</span> (fuel &lt; wasteFuel) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'이동불가'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      fuel -= wasteFuel;</span><br><span class="line">      moved += km;</span><br><span class="line">      <span class="built_in">console</span>.log(km + <span class="string">'km 이동 (총 '</span> + moved + <span class="string">'km). 남은 연료: '</span> + fuel);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> car = createCar();</span><br></pre></td></tr></table></figure><ul><li><p><code>createCar</code>라는 함수를 실행함으로써 객체를 생성하게 했습니다. <code>fuel</code>, <code>power</code> 변수는 비공개 맴버로 지정해 외부에서의 접근을 제한했고, <code>moved</code>변수는 <code>getter</code>만을 부여함으로써 “읽기전용” 속성을 부여했습니다.</p></li><li><p>이제 외부에서는 오직 <code>run</code>메서드를 실행하는 것과 현재의 <code>moved</code>값을 확인하는 두 가지 동작만 할 수 있습니다.</p></li><li><p><code>run</code>메서드를 다른 내용으로 덮어씌우는 어뷰징은 여전히 가능한 상태이긴 하지만 앞서의 코드보다 훨씬 안전한 코드가 됐습니다. 이런 어뷰징까지 막기 위해서는 객체를 <code>return</code>하기 전에 미리 변경할 수 없게끔 조치를 취해야 합니다.</p></li></ul><figure class="highlight js"><figcaption><span>Object.freeze</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createCar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fuel = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">10</span>); <span class="comment">// 연료(L)</span></span><br><span class="line">  <span class="keyword">var</span> power = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">3</span> + <span class="number">2</span>); <span class="comment">// 연비(km / L)</span></span><br><span class="line">  <span class="keyword">var</span> moved = <span class="number">0</span>; <span class="comment">// 총 이동거리</span></span><br><span class="line">  <span class="keyword">var</span> publicMembers = &#123;</span><br><span class="line">    <span class="keyword">get</span> moved() &#123;</span><br><span class="line">      <span class="keyword">return</span> moved;</span><br><span class="line">    &#125;,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> km = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">6</span>);</span><br><span class="line">      <span class="keyword">var</span> wasteFuel = km / power;</span><br><span class="line">      <span class="keyword">if</span> (fuel &lt; wasteFuel) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'이동불가'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      fuel -= wasteFuel;</span><br><span class="line">      moved += km;</span><br><span class="line">      <span class="built_in">console</span>.log(km + <span class="string">'km 이동 (총 '</span> + moved + <span class="string">'km). 남은 연료: '</span> + fuel);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(publicMembers);</span><br><span class="line">  <span class="keyword">return</span> publicMembers;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> car = createCar();</span><br></pre></td></tr></table></figure><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">Object.freeze</a>를 사용하여 <code>publicMembers</code>객체를 동결객체로 만들었습니다.</li></ul><ul><li><code>Object.freeze</code>메서드는 호출된 객체의 직속 속성만 동결하며 내부의 속성 값이 객체라면 그 객체는 동결되지 않아 추가/제거/재할당의 대상이 될 수 있으므로 (얕은동결) 주의하여야 합니다.</li></ul><hr><h4 id="클로저를-활용해-접근권한-제어-방법-정리"><a href="#클로저를-활용해-접근권한-제어-방법-정리" class="headerlink" title="클로저를 활용해 접근권한 제어 방법 정리"></a>클로저를 활용해 접근권한 제어 방법 정리</h4><ol><li><p>함수에서 지역변수 및 내부함수 등을 생성</p></li><li><p>외부에 접근권한을 주고자 하는 대상들로 구성된 참조형 데이터(대상이 여럿일 경우 객체 또는 배열, 하나일 경우 함수)를 return 합니다.</p></li><li><p>return한 변수들은 공개 맴버가 되고, 그렇지 않은 변수들은 비공개 맴버가 됩니다.</p></li></ol><hr><h3 id="부분-적용-함수"><a href="#부분-적용-함수" class="headerlink" title="부분 적용 함수"></a>부분 적용 함수</h3><p>부분 적용 함수(<code>partially applied function</code>)란 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가. 나중에 나머지 인자를 넘길 때 원래 함수의 실행 결과를 얻을 수 있게 하는 함수입니다.</p><p><code>this</code>를 바인딩해야 하는 점을 제외하면 <code>bind</code>메서드의 실행 결과가 바로 부분 적용 함수입니다.</p><figure class="highlight js"><figcaption><span>bind - 부분 적용 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    result += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> addPartial = add.bind(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(addPartial(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure><p><code>addPartial</code> 함수에 <code>this</code>값 <code>null</code>과 인자 5개를 미리 적용하고, 대기합니다.<br>추후에 추가적으로 인자들을 전달하며 호출하면 대기중이던 인자들과 차례대로 적용되어 실행합니다.</p><p><code>add</code>함수는 <code>this</code>값을 사용하지 않지만, <code>bind</code>메서드는 <code>this</code>값을 변경할 수 밖에 없기 때문에 메서드에서는 사용할 수 없을 것 같습니다.<br><code>this</code>에 관여하지 않는 다른 방법의 부분 적용 함수가 필요합니다.</p><figure class="highlight js"><figcaption><span>부분 적용 함수 구현(1)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> partial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> originalPartialArgs = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">var</span> func = originalPartialArgs[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'첫 번째 인자가 함수가 아닙니다.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> partialArgs = <span class="built_in">Array</span>.prototype.slice.call(originalPartialArgs, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> restArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, partialArgs.concat(restArgs));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    result += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> addPartial = partial(add, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(addPartial(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)); <span class="comment">// 55</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = &#123;</span><br><span class="line">  name: <span class="string">'강아지'</span>,</span><br><span class="line">  greet: partial(<span class="function"><span class="keyword">function</span>(<span class="params">prefix, suffix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prefix + <span class="keyword">this</span>.name + suffix;</span><br><span class="line">  &#125;, <span class="string">'왈왈, '</span>),</span><br><span class="line">&#125;;</span><br><span class="line">dog.greet(<span class="string">'입니다!'</span>); <span class="comment">// 왈왈, 강아지입니다.</span></span><br></pre></td></tr></table></figure><ul><li>첫 번째 인자에 원본 함수를, 두 번째 인자 이후부터는 미리 적용할 인자들을 전달하고, 반환할 함수(부분 적용 함수)에서는 다시 나머지 인자들을 받아 이들은 한곳으로 모아(<code>concat</code>) 원본 함수를 호출(<code>apply</code>)합니다. 또한 실행 시점의 <code>this</code>를 그대로 반영함으로써 <code>this</code>에는 아무런 영향을 주지 않게 되었습니다.</li></ul><hr><h4 id="디바운스-debounce"><a href="#디바운스-debounce" class="headerlink" title="디바운스(debounce)"></a>디바운스(debounce)</h4><p>실무에서 부분 함수를 사용하기에 적합한 예로 디바운스(<code>debounce</code>)가 있습니다.</p><p>디바운스(<code>debounce</code>)는 짧은 시간 동안 동일한 이벤트가 많이 발생한 경우 이를 전부 처리하지 않고 처음 또는 마지막에 발생한 이벤트에 대해 한 번만 처리하는 것으로, <code>scroll</code>, <code>wheel</code>, <code>mousemove</code>, <code>resize</code>등에 적용하기 좋습니다.</p><figure class="highlight js"><figcaption><span>부분 적용 함수 - 디바운스</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeoutId = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(eventName, <span class="string">'event 발생'</span>);</span><br><span class="line">    clearTimeout(timeoutId);</span><br><span class="line">    timeoutId = setTimeout(func.bind(self, event), wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> moveHandler = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'move event 처리'</span>); &#125;;</span><br><span class="line"><span class="keyword">var</span> wheelHandler = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'wheel event 처리'</span>); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(</span><br><span class="line">  <span class="string">'mousemove'</span>,</span><br><span class="line">  debounce(<span class="string">'move'</span>, moveHandler, <span class="number">500</span>));</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(</span><br><span class="line">  <span class="string">'mousewheel'</span>,</span><br><span class="line">  debounce(<span class="string">'wheel'</span>, wheelHandler, <span class="number">700</span>));</span><br></pre></td></tr></table></figure><ul><li><code>debounce</code> 함수는 출력 용도로 지정한 <code>eventName</code>과 실행할 함수(<code>func</code>),마지막으로 발생한 이벤트인지 여부를 판단하기 위한 대기시간 (<code>wait(</code>(ms))을 받습니다.</li></ul><ul><li>내부에서는 <code>timeoutId</code> 변수를 생성하고, 클로저로 <code>EventListener</code>에 의해 호출될 함수를 반환합니다. 반환될 함수 내부에서는 <code>setTimeout</code>을 사용하기 위해 <code>this</code>를 별도의 변수에 담고 <code>clearTimeout</code>으로 대기큐를 초기화하게 했습니다.</li></ul><ul><li>마지막으로 <code>setTimeout</code>으로 <code>wait</code> 시간만큼 지연시킨 다음, 원래의 <code>func</code>를 호출하는 형태입니다.</li></ul><ul><li>최초의 event가 발생하면 <code>timeoutId = setTimeout(func,bind(self,event),wait)</code>에 의해 timeout의 대기열에 ‘wait 시간 뒤에 func를 실행 함’이라는 내용이 담깁니다. 그런데 <code>wait</code>시간이 경과하기 전에 동일한 event가 발생하게 되면 앞의 <code>clearTimeout(timeoutId)</code>에 의해 앞에 저장했던 대기열을 초기화하고, 다시 <code>timeoutId = setTimeout(func,bind(self,event),wait)</code>에서 새로운 대기열을 등록합니다.</li></ul><ul><li>결국 각 동일한 이벤트가 이전 이벤트로 부터 <code>wait</code>시간 내에 다시 발생하는 한 마지막에 발생한 이벤트만이 초기화되지 않고 실행됩니다.</li></ul><ul><li><code>debounce</code>함수에서 클로저로 처리되는 변수는 <code>eventName</code>, <code>func</code>, <code>wait</code>, <code>timeoutId</code>입니다.</li></ul><hr><h3 id="커링-함수-currying-function"><a href="#커링-함수-currying-function" class="headerlink" title="커링 함수(currying function)"></a>커링 함수(currying function)</h3><p>커링 함수(currying function)란 <mark>여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서</mark><br><strong>순차적으로 호출될 수 있게 체인 형태로 구성한 것을 말합니다.</strong><br><del>(앞서 살펴본 부분 적용 함수와 기본적인 맥락은 일치하지만 몇 가지 다른 점이 있습니다.)</del></p><ul><li><p>커링은 <strong>한 번에 하나의 인자만 전달하는 것을 원칙으로 합니다.</strong></p></li><li><p><u>중간 과정상의 함수를 실행한 결과는 그다음 인자를 받기 위해 대기만 할 뿐으로</u>, <strong>마지막 인자가 전달되기 전까지는 원본 함수가 실행되지 않습니다.</strong></p></li><li><p>부분 적용 함수와 달리 커링 함수는 필요한 상황에 직접 만들어 쓰기 용이합니다. 필요한 인자 개수만큼 함수를 만들어 계속 <code>return</code>해 주다가 마지막에 조합해서 <code>return</code>해주면 되기 때문이죠.</p></li></ul><figure class="highlight js"><figcaption><span>ES5 커링 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> curry5 = <span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> func(a, b, c, d, e);</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getMax = curry5(<span class="built_in">Math</span>.max);</span><br><span class="line"><span class="built_in">console</span>.log(getMax(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><ul><li><p>5개의 인자를 받아서 처리하기위해 코드가 길어졌습니다.</p></li><li><p><code>ES6</code>의 화살표 함수를 사용하면 다음과 같이 처리할 수 있습니다.</p></li></ul><figure class="highlight js"><figcaption><span>ES6 커링처리</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> curry5 = <span class="function"><span class="params">func</span> =&gt;</span> <span class="function"><span class="params">a</span> =&gt;</span> <span class="function"><span class="params">b</span> =&gt;</span> <span class="function"><span class="params">c</span> =&gt;</span> <span class="function"><span class="params">d</span> =&gt;</span> <span class="function"><span class="params">e</span> =&gt;</span> func(a,b,c,d,e);</span><br></pre></td></tr></table></figure><ul><li><p><strong>참고 :</strong></p><ul><li><p>각 단계에서 받은 인자들은 모두 마지막 단계에서 참조할 것이므로 <code>GC</code>의 대상이 되지않고<br>메모리 저장되었다가, 마지막에 호출되어 실행 컨텍스트가 종료된 이후에 한꺼번에 <code>GC</code>의 수거 대상이됩니다.</p></li><li><p><strong>커링 함수가 유용한 경우</strong>는 <u>당장 필요한 정보만 받아 전달하고 또 필요한 정보가 들어오면 전달하는 식으로 결국 마지막 인자가 넘어갈 때까지 함수 실행을 미루는 셈이 됩니다.</u><br><strong>이를 함수형 프로그래밍에서 지연실행(<code>lazy execution</code>)이라고 합니다.</strong><br>즉, 원하는 시점까지 지연시켰다가 실행하는 것이 유용한 상황이라면 커링을 쓰기에 적합할 수 있습니다.</p></li></ul></li></ul><hr><h2 id="closure">정리</h2><ul><li>클로저란 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상입니다.</li></ul><ul><li>내부 함수를 외부로 전달하는 방법에는 함수를 return하는 경우뿐아니라 콜백으로 전달하는 경우도 포함됩니다.</li></ul><ul><li>클로저는 그 본질이 메모리를 계속 차지하는 개념이므로 더는 사용하지 않게 된 클로저에 대해서는 메모리를 차지하지 않도록 관리해줄 필요가 있습니다.</li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/03/%ED%81%B4%EB%A1%9C%EC%A0%80-Core-JavaScript/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
