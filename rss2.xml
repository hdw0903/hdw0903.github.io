<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>한참치의 Study Blog</title>
    <link>https://hdw0903.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description> 공부 내용 정리 블로그입니다. </description>
    <pubDate>Tue, 02 Jun 2020 12:14:39 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>라이프사이클 메서드</title>
      <link>https://hdw0903.github.io/2020/06/02/%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EB%A9%94%EC%84%9C%EB%93%9C/</link>
      <guid>https://hdw0903.github.io/2020/06/02/%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EB%A9%94%EC%84%9C%EB%93%9C/</guid>
      <pubDate>Tue, 02 Jun 2020 07:37:44 GMT</pubDate>
      <description>
      
        &lt;p&gt;모든 리액트 컴포넌트에는 라이프사이클(수명 주기)이 존재합니다.&lt;/p&gt;
&lt;p&gt;컴포넌트의 수명은 페이지에 렌더링되기 전인 준비 과정에서 시작하여 페이지에서 사라질 때 끝납니다.&lt;/p&gt;
&lt;p&gt;컴포넌트를 처음으로 렌더링할 때 어떤 작업을 처리하거나, 컴포넌트를 업데이트하기 전후로 어떤 작업을 처리해야 할 때 등에 컴포넌트 라이프사이클 메서드를 사용합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;라이프사이클 메서드는 클래스형 컴포넌트에서만 사용할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/02/라이프사이클-메서드/#이해&quot;&gt;라이프사이클 메서드의 이해&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/02/라이프사이클-메서드/#살펴보기&quot;&gt;라이프사이클 메서드 살펴보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/02/라이프사이클-메서드/#사용하기&quot;&gt;라이프사이클 메서드 사용하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>모든 리액트 컴포넌트에는 라이프사이클(수명 주기)이 존재합니다.</p><p>컴포넌트의 수명은 페이지에 렌더링되기 전인 준비 과정에서 시작하여 페이지에서 사라질 때 끝납니다.</p><p>컴포넌트를 처음으로 렌더링할 때 어떤 작업을 처리하거나, 컴포넌트를 업데이트하기 전후로 어떤 작업을 처리해야 할 때 등에 컴포넌트 라이프사이클 메서드를 사용합니다.</p><p><strong>라이프사이클 메서드는 클래스형 컴포넌트에서만 사용할 수 있습니다.</strong></p><ul><li><a href="/2020/06/02/라이프사이클-메서드/#이해">라이프사이클 메서드의 이해</a></li><li><a href="/2020/06/02/라이프사이클-메서드/#살펴보기">라이프사이클 메서드 살펴보기</a></li><li><a href="/2020/06/02/라이프사이클-메서드/#사용하기">라이프사이클 메서드 사용하기</a></li></ul><a id="more"></a><hr><h2 id="이해">라이프사이클 메서드의 이해</h2><p>라이프사이클 메서드의 종류는 총 아홉 가지 입니다.<br>  <code>Will</code> 접두사가 붙은 메서드는 어떤 작업을 작동하기 전에 실행되는 메서드이고<br>  <code>Did</code> 접두사가 붙은 메서드는 어떤 작업을 작동한 후에 실행되는 메서드입니다.<br>이 메서드들은 우리가 컴포넌트 클래스에 덮어 써 선언함으로 사용할 수 있습니다.</p><p>라이프사이클은 총 세 가지 : <code>마운트</code>, <code>업데이트</code>, <code>언마운트</code>로 분류할 수 있습니다.</p><p><code>마운트</code>(페이지에 컴포넌트가 나타남) -&gt; <code>업데이트</code>(리렌더링) -&gt; <code>언마운트</code>(페이지에서 컴포넌트가 사라짐)</p><hr><h3 id="마운트"><a href="#마운트" class="headerlink" title="마운트"></a>마운트</h3><p><strong>DOM이 생성되고 웹 브라우저상에 나타나는 것을 마운트(mount)라고 합니다.</strong><br>이때 호출하는 메서드는 다음과 같습니다.</p><p><img src="/images/%EB%A7%88%EC%9A%B4%ED%8A%B8.png" alt="마운트할 때 호출하는 메서드"></p><ul><li><code>constuctor</code>: 컴포넌트를 새로 만들 때마다 호출되는 클래스 생성자 메서드</li></ul><ul><li><code>getDerivedStateFromProps</code>: props에 있는 값을 state에 넣을 때 사용하는 메서드</li></ul><ul><li><code>render</code>: 준비한 UI를 렌더링하는 메서드</li></ul><ul><li><code>componentDidMount</code>: 컴포넌트가 웹 브라우저상에 나타난 후 호출하는 메서드</li></ul><hr><h3 id="업데이트"><a href="#업데이트" class="headerlink" title="업데이트"></a>업데이트</h3><p><strong>컴포넌트는 다음과 같은 총 네 가지 경우에 업데이트합니다.</strong></p><ol><li>props가 바뀔 때</li><li>state가 바뀔 때</li><li>부모 컴포넌트가 리렌더링될 때</li><li>this.forceUpdate로 강제로 렌더링을 트리거할 때</li></ol><p>이렇게 컴포넌트를 업데이트할 때는 다음 메서드를 호출합니다.</p><p><img src="/images/%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8.png" alt="업데이트할 때 호출하는 메서드"></p><ul><li><code>getDerivedStateFromProps</code>: 이 메서드는 마운트 과정에서도 호출되며, 업데이트가 시작하기 전에도 호출됩니다. props의 변화에 따라 state 값에도 변화를 주고싶을때 사용합니다.</li></ul><ul><li><code>shouldComponentUpdate</code>: 컴포넌트가 리렌더링을 해야 할지 말아야 할지 결정하는 메서드<br>이 메서드에서는 true 혹은 false 값을 반환해야 하며, true 반환시 라이프사이클 메서드를 계속 실행하고, false 반환시 작업 중지. 만약 특정 함수에서 <code>this.forceUpdate()</code>함수를 호출한다면 이 과정이 생략되고 바로 render 함수를 호출함.</li></ul><ul><li><code>render</code>: 컴포넌트 리렌더링</li></ul><ul><li><code>getSnapshotBeforeUpdate</code>: 컴포넌트 변화를 DOM에 반영하기 바로 직전에 호출하는 메서드</li></ul><ul><li><code>componentDidUpdate</code>: 컴포넌트의 업데이트 작업이 끝난 후 호출하는 메서드</li></ul><hr><h3 id="언마운트"><a href="#언마운트" class="headerlink" title="언마운트"></a>언마운트</h3><p>마운트의 반대 과정, 즉 <strong>컴포넌트를 DOM에서 제거하는 것을 언마운트(unmount)라고 합니다.</strong></p><p><img src="/images/%EC%96%B8%EB%A7%88%EC%9A%B4%ED%8A%B8.png" alt="언마운트할 때 호출하는 메서드"></p><ul><li><code>componentWillUnmount</code>: 컴포넌트가 웹 브라우저상에서 사라지기 전에 호출하는 메서드</li></ul><hr><h2 id="살펴보기">라이프사이클 메서드 살펴보기</h2><p>라이프사이클 메서드를 더 자세히 살펴봅니다.</p><hr><h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><figure class="highlight jsx"><figcaption><span>render</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;...&#125;</span><br></pre></td></tr></table></figure><p>render은 컴포넌트의 모양새를 정의합니다. 라이프사이클 메서드 중 유일한 필수 메서드입니다.</p><p>render()에서 this.props와 this.state에 접근할 수 있으며 리액트 요소를 반환합니다. (아무것도 보여 주고 싶지 않다면 null 값이나 false값을 반환하면됨)</p><ul><li>주의사항: <ul><li>render 안에서는 이벤트 설정이 아닌 곳에서 setState를 사용하면 안됨.</li><li>브라우저의 DOM에 접근해서도 안됨.</li><li>DOM 정보를 가저오거나 state에 변화를 줄 때는 componentDidMount에서 처리해야 함.</li></ul></li></ul><hr><h3 id="constuctor"><a href="#constuctor" class="headerlink" title="constuctor"></a>constuctor</h3><figure class="highlight jsx"><figcaption><span>constuctor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>컴포넌트의 생성자 메서드로 컴포넌트를 만들 때 처음으로 실행됨.<br>초기 state를 지정할 수 있음.</p><hr><h3 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h3><p>리액트 v16.3 이후에 새로 만든 라이프사이클 메서드</p><p><strong>props로 받아 온 값을 state에 동기화시키는 용도로 사용</strong></p><p>컴포넌트가 마운트될 때와 업데이트될 때 호출됩니다.</p><figure class="highlight jsx"><figcaption><span>getDerivedStateFromProps</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span>(nextProps.value !=== prevState.value) &#123; <span class="comment">// 조건에 따라 특정 값 동기화</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: nextProps.value &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// state를 변경할 필요가 없으면 null 반환</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;...&#125;</span><br></pre></td></tr></table></figure><p>컴포넌트를 만들고, 첫 렌더링을 다 마친 후 실행합니다.</p><p>자바스크립트 라이브러리, 프레임워크, 이벤트 등록, setTimeout, 네트워크 요청등의 비동기 작업을 처리할 때 사용합니다.</p><hr><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><figure class="highlight jsx"><figcaption><span>shouldComponentUpdate</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>props 또는 state를 변경했을 때, 리렌더링을 할지 여부를 지정하는 메서드.<br><code>shouldComponentUpdate</code> 메서드는 반드시 true 또는 false 값을 반환해야 하며 컴포넌트 생성시 shouldComponentUpdate 메서드를 따로 생성하지 않으면 <strong>기본적으로 true</strong> 값입니다.</p><p><code>shouldComponentUpdate</code> 메서드 안에서 props와 state는 this.props와 this.state로 접근하고, 새로 생성될 props와 state는 nextProps와 nextState로 접근할 수 있습니다.</p><p><mark>false를 반환하는 경우 업데이트 과정이 중지되기 때문에 상황에 맞게 false 값을 반환하게 하여 리렌더링을 방지함으로 프로젝트 성능을 최적화할 때 사용합니다.</mark></p><hr><h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h3><p>리액트 v16.3 이후 새로 만든 메서드</p><p><code>getSnapshotBeforeUpdate</code> 메서드는 render에서 만들어진 결과물이 <strong>브라우저에 실제로 반영되기 직전 호출됩니다.</strong></p><p>주로 업데이트 직전의 값을 참고할 일이 있을 떄 활용됩니다. (ex: 스크롤바 위치 유지)</p><ul><li>반환값을 <code>componentDidUpdate</code>의 세 번째 파라미터 <code>snapshot</code> 값으로 전달받을 수 있습니다.</li></ul><figure class="highlight jsx"><figcaption><span>getSnapshotBeforeUpdate</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span>(prevState.array !== <span class="keyword">this</span>.state.array) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; scrollTop, scrollHeight &#125; = <span class="keyword">this</span>.list</span><br><span class="line">    <span class="keyword">return</span> &#123; scrollTop, scrollHeight&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><figure class="highlight jsx"><figcaption><span>componentDidUpdate</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState, snapshot) &#123;...&#125;</span><br></pre></td></tr></table></figure><p><code>componentDidUpdate</code> 메서드는 리렌더링을 완료한 후 실행합니다.<br>업데이트가 끝난 직후이므로, DOM 관련 처리를 해도 무방합니다.<br>prevProps 또는 prevState를 사용하여 컴포넌트가 이전에 가졌던 데이터에 접근할 수 있습니다.<br>또한 <code>getSnapshotBeforeUpdate</code>에서 반환한 값이 있다면 세 번째 파라미터 <code>snapshot</code>으로 값을 전달받을 수 있습니다.</p><hr><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><figure class="highlight jsx"><figcaption><span>componentWillUnmount</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;...&#125;</span><br></pre></td></tr></table></figure><p><code>componentWillUnmount</code> 메서드는 컴포넌트를 DOM에서 제거할 때 사용합니다.<br>componentDidMount에서 등록한 이벤트, 타이머, 직접 생성한 DOM을 여기서 제거 작업합니다.</p><hr><h3 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch"></a>componentDidCatch</h3><p>리액트 v16에서 새로 도입되었습니다.</p><p><strong>컴포넌트 렌더링 도중에 에러가 발생했을 때 어플리케이션이 먹통 되지 않고 오류 UI를 보여 줄 수 있게합니다.</strong></p><p>사용 방법은 다음과 같습니다.</p><figure class="highlight jsx"><figcaption><span>componentDidCatch</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    error: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(&#123; error, info &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>파라미터 error는 어떤 에러가 밸생했는지 알려줍니다. info는 어디에 있는 코드에서 오류가 발생했는지에 대한 정보를 줍니다.</p><p>실제로 사용할 때 오류가 발생하면 <code>console.log</code>가 아니라 서버 API를 호출하여 따로 수집할 수도 있습니다.</p><p><mark>주의사항으로 componentDidCatch 메서드를 사용할 때는 컴포넌트 자신에게 발생하는 에러는 잡아낼 수 없고 자신의 this.props.children으로 전달되는 컴포넌트에서 발생하는 에러만 잡아낼 수 있는 점이 있습니다.</mark></p><hr><h2 id="사용하기">라이프사이클 메서드 사용하기</h2><p>라이프사이클 메서드 직접 사용해보기 실습</p><hr><h3 id="예제-컴포넌트-생성"><a href="#예제-컴포넌트-생성" class="headerlink" title="예제 컴포넌트 생성"></a>예제 컴포넌트 생성</h3><p>lifeCycleSample.js 컴포넌트를 만듭니다.</p><figure class="highlight jsx"><figcaption><span>lifeCycleSample.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifeCycleSample</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    number: <span class="number">0</span>,</span><br><span class="line">    color: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  myRef = <span class="literal">null</span>; <span class="comment">// ref를 설정할 부분</span></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'getDerivedStateFromProps'</span>);</span><br><span class="line">    <span class="keyword">if</span> (nextProps.color !== prevState.color) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">color</span>: nextProps.color &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidMount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'shouldComponentUpdate'</span>, nextProps, nextState);</span><br><span class="line">    <span class="comment">// 숫자의 마지막 자리가 4면 리렌더링하지 않습니다.</span></span><br><span class="line">    <span class="keyword">return</span> nextState.number % <span class="number">10</span> !== <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUnmount'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      number: <span class="keyword">this</span>.state.number + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'getSnapshotBeforeUpdate'</span>);</span><br><span class="line">    <span class="keyword">if</span> (prevProps.color !== <span class="keyword">this</span>.props.color) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.myRef.style.color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>, prevProps, prevState);</span><br><span class="line">    <span class="keyword">if</span> (snapshot) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'업데이트되기 직전 색상: '</span>, snapshot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">const</span> style = &#123;</span><br><span class="line">      color: <span class="keyword">this</span>.props.color,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1 style=&#123;style&#125; ref=&#123;(ref) =&gt; (<span class="keyword">this</span>.myRef = ref)&#125;&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.state.number&#125;</span><br><span class="line">        &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;color: &#123;this.state.color&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;더하기&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> LifeCycleSample;</span><br></pre></td></tr></table></figure><p>각 라이프사이클 메서드가 실행될 때마다 콘솔에 출력하고 부모 컴포넌트에서 props로 color를 받습니다.</p><ul><li><p>getDerivedStateFromProps : 부모에게 받은 color 값을 state에 동기화 합니다.</p></li><li><p>shouldComponentUpdate : state.number 값의 마지막 자리 수가 4이면 리렌더링을 취소합니다.</p></li><li><p>handleClick : 버튼을 누르면 state.number 값을 1씩 증가시킵니다.</p></li><li><p>getSnapshotBeforeUpdate : DOM에 변화가 일어나기 직전의 color 속성을 snapshot 값으로 반환하여 componentDidUpdate에서 조회할 수 있게 했습니다.</p></li></ul><hr><h3 id="App-컴포넌트에서-예제-컴포넌트-사용"><a href="#App-컴포넌트에서-예제-컴포넌트-사용" class="headerlink" title="App 컴포넌트에서 예제 컴포넌트 사용"></a>App 컴포넌트에서 예제 컴포넌트 사용</h3><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> LifeCycleSample <span class="keyword">from</span> <span class="string">'./LifeCycleSample'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//랜덤 색상 생성</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'#'</span> + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">16777215</span>).toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    color: <span class="string">'#000000'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      color: getRandomColor(),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;랜덤 색상&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;LifeCycleSample color=&#123;this.state.color&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><ul><li><p>getRandomColor 함수는 state의 color값을 랜덤 색상으로 설정합니다.<br>16777215를 hex로 표현하면 ffffff 이므로 해당 코드는 000000~ffffff 값을 반환합니다.</p></li><li><p>버튼을 누를 때 마다 handleClick 메서드가 호출되며, 불러온 LifeCycleSample 컴포넌트에 color 값을 props로 설정합니다.</p></li></ul><hr><h3 id="에러-잡아내기"><a href="#에러-잡아내기" class="headerlink" title="에러 잡아내기"></a>에러 잡아내기</h3><p>render 함수에서 에러는 주로 존재하지 않는 함수를 사용하려고 하거나, 존재하지 않는 객체의 값을 조회할 때 발생합니다.</p><p>LifeCycleSample 컴포넌트를 수정하여 render 함수에서 의도적으로 에러를 발생시킵니다.</p><figure class="highlight jsx"><figcaption><span>LifeCycleSample</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">const</span> style = &#123;</span><br><span class="line">      color: <span class="keyword">this</span>.props.color,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.missing.value&#125;</span><br><span class="line">        &lt;h1 style=&#123;style&#125; ref=&#123;(ref) =&gt; (<span class="keyword">this</span>.myRef = ref)&#125;&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.state.number&#125;</span><br><span class="line">        &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;color: &#123;this.state.color&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;더하기&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><code>{this.props.missing.value}</code> 존재하지 않는 props인 missing 객체의 value를 조회해서 렌더링하려면 당연히 에러가 발생합니다.</p><p>사용자에게는 빈 화면만 나타나게 될 것입니다.</p><p>이럴 때 에러가 발생했다고 알려주기 위한<br>에러를 잡아주는 ErrorBoundary라는 컴포넌트를 생성해 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>ErrorBoundary.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    error: <span class="literal">false</span></span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      error: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(&#123; error, info &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.error) <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>에러가 발생했습니다!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ErrorBoundary;</span><br></pre></td></tr></table></figure><p><code>componentDidCatch</code> 메서드는 에러가 발생하면 실행되며 this.state.error 값을 true로 업데이트 해주었습니다.</p><p>render 함수에서 this.state.error 값이 true일 때 에러가 발생했음을 알리는 문구를 보여줍니다.</p><p>이제 ErrorBoundary 컴포넌트를 이용해 App.js에서 LifeCycleSample 컴포넌트를 감싸줍니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> LifeCycleSample <span class="keyword">from</span> <span class="string">'./LifeCycleSample'</span>;</span><br><span class="line"><span class="keyword">import</span> ErrorBoundary <span class="keyword">from</span> <span class="string">'./ErrorBoundary'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 랜덤 색상을 생성합니다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'#'</span> + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">16777215</span>).toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    color: <span class="string">'#000000'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      color: getRandomColor(),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;랜덤 색상&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ErrorBoundary&gt;</span></span><br><span class="line"><span class="regexp">          &lt;LifeCycleSample color=&#123;this.state.color&#125; /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/ErrorBoundary&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>이제 에러가 발생하면 “에러가 발생했습니다!” 문구가 출력됩니다.</p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/06/02/%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EB%A9%94%EC%84%9C%EB%93%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>컴포넌트 반복</title>
      <link>https://hdw0903.github.io/2020/06/01/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%B0%98%EB%B3%B5/</link>
      <guid>https://hdw0903.github.io/2020/06/01/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%B0%98%EB%B3%B5/</guid>
      <pubDate>Mon, 01 Jun 2020 10:06:36 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/01/컴포넌트-반복/#컴포넌트-배열&quot;&gt;컴포넌트 배열&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/01/컴포넌트-반복/#key&quot;&gt;key&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/06/01/컴포넌트-반복/#응용&quot;&gt;응용&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<ul><li><a href="/2020/06/01/컴포넌트-반복/#컴포넌트-배열">컴포넌트 배열</a></li></ul><ul><li><a href="/2020/06/01/컴포넌트-반복/#key">key</a></li></ul><ul><li><a href="/2020/06/01/컴포넌트-반복/#응용">응용</a></li></ul><a id="more"></a><hr><h2 id="컴포넌트-배열">컴포넌트 배열</h2><p>리액트 프로젝트를 작성하다 보면 반복되는 코드를 작성할 때가 있습니다.</p><ul><li>반복되는 코드 예시<figure class="highlight jsx"><figcaption><span>IterationSample.js </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IterationSample = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;눈사람&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;얼음&lt;/</span>li&gt;</span><br><span class="line">      &lt;li&gt;눈&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;바람&lt;/</span>li&gt;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default IterationSample;</span></span><br></pre></td></tr></table></figure></li></ul><p>위는 하나의 예시이며 <code>&lt;li&gt;</code> 태그 하나만 반복되는 것이 아니라 코드가 조금더 복잡해 진다면 코드양이 더더욱 늘어날 것이며 관리하기 힘들어 집니다.</p><p>리액트에서는 자바스크립트의 <code>Map</code> 메서드를 사용하여 더욱 간단하게 표현할 수 있습니다.</p><figure class="highlight jsx"><figcaption><span>IterationSample.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IterationSample = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">'눈사람'</span>, <span class="string">'얼음'</span>, <span class="string">'눈'</span>, <span class="string">'바람'</span>];</span><br><span class="line">  <span class="keyword">const</span> nameList = names.map(<span class="function"><span class="params">name</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;nameList&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> IterationSample;</span><br></pre></td></tr></table></figure><ul><li>문자열로 구성된 배열을 선언합니다.</li></ul><ul><li>그 배열 값을 사용하여 <code>&lt;li&gt;...&lt;/li&gt;</code> JSX 코드로 된 배열을 새로 생성한 후 nameList에 담습니다.</li></ul><hr><h3 id="App-컴포넌트에서-렌더링-시"><a href="#App-컴포넌트에서-렌더링-시" class="headerlink" title="App 컴포넌트에서 렌더링 시"></a>App 컴포넌트에서 렌더링 시</h3><p>App 컴포넌트에서 IterationSample.js 컴포넌트를 불러와 렌더링 하면</p><p>브라우저 화면에는 잘 표시되는 듯 보이나 <strong>개발자 도구에서 경고 메세지가 표시됩니다.</strong> </p><p><img src="/images/key_prop.png" alt="Warning: Each child in a list should have a unique &quot;key&quot; prop."></p><p>“key” prop이 없다는 경고 메서지입니다.</p><p>key가 무엇인지 알아봅시다.</p><hr><h2 id="key">key</h2><p>리액트에서 key는 컴포넌트 배열을 렌더링했을 때 어떤 요소에 변동이 있었는지 알아내려고 사용합니다.</p><p>key가 없을 때는 Virtual DOM을 비교하는 과정에서 리스트를 순차적으로 비교하면서 변화를 감지합니다.</p><p>하지만 key가 있다면 이 값을 사용하여 어떤 변화가 일어났는지 더욱 빠르게 알아낼 수 있습니다.</p><hr><h3 id="key-설정"><a href="#key-설정" class="headerlink" title="key 설정"></a>key 설정</h3><p><strong>key 값을 설정할 때는 map 함수의 인자로 전달되는 함수 내부에서 컴포넌트 props를 설정하듯이 설정하면 됩니다.</strong></p><ul><li>key 값은 언제나 유일해야 합니다. (따라서 데이터가 가진 고유값을 key 값으로 설정해야 합니다.)</li></ul><p>예를 들어 게시판의 게시물을 렌더링한다면 게시물 번호를 key 값으로 설정해야 합니다.</p><figure class="highlight jsx"><figcaption><span>key 값 예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> articleList = articles.map(article) =&gt; (</span><br><span class="line">  &lt;Article</span><br><span class="line">    title=&#123;article.title&#125;</span><br><span class="line">    writer=&#123;article.writer&#125;</span><br><span class="line">    key=&#123;article.id&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>하지만 앞에서 만든 IterationSample 예제 컴포넌트에는 이런 고유 번호가 없습니다.</p><p>이때는 map 함수에 전달되는 콜백 함수의 인수인 index 값을 사용하면 됩니다.</p><figure class="highlight jsx"><figcaption><span>IterationSample.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IterationSample = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">'눈사람'</span>, <span class="string">'얼음'</span>, <span class="string">'눈'</span>, <span class="string">'바람'</span>];</span><br><span class="line">  <span class="keyword">const</span> nameList = names.map(<span class="function">(<span class="params">name, index</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;nameList&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> IterationSample;</span><br></pre></td></tr></table></figure><p>이제 개발자 도구에서 경고 메세지를 표시하지 않습니다.</p><p><strong>고유한 값이 없을 때만 index 값을 key로 사용해야 합니다.</strong></p><p>index를 key로 사용하면 배열이 변경될 때 효율적으로 리렌더링하지 못합니다.</p><hr><h2 id="응용">응용</h2><p>고정된 배열을 렌더링하는 것이 아닌, 동적인 배열을 렌더링하여 구현해 봅니다.</p><p>또한 index값을 key로 사용하면 리렌더링이 비효율적이라 하였는데, 이러한 상황에 고유값을 만드는 방법도 알아봅니다.</p><hr><h3 id="초기-상태-설정"><a href="#초기-상태-설정" class="headerlink" title="초기 상태 설정"></a>초기 상태 설정</h3><p>IterationSample 컴포넌트에서 useState를 사용하여 3가지 상태를 설정합니다.</p><ol><li><p>데이터 배열</p></li><li><p>텍스트를 입력할 수 있는 input 상태</p></li><li><p>데이터 배열에서 새로운 항목을 추가할 때 사용할 고유 id 상태</p></li></ol><p>우선 배열을 작성할 때 <u>객체 형태로 이루어진 배열로</u> 만들어 <strong>문자열과 고유 id</strong>를 작성합니다.</p><figure class="highlight jsx"><figcaption><span>IterationSample.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IterationSample = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [names, setNames] = useState([</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'눈사람'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'얼음'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">'눈'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">text</span>: <span class="string">'바람'</span> &#125;,</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">const</span> [inputText, setInputText] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [nextId, setNextId] = useState(<span class="number">5</span>); <span class="comment">// 새 항목을 추가할 때 사용할 id</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nameList = names.map(<span class="function">(<span class="params">name</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;name.id&#125;</span>&gt;</span>&#123;name.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;nameList&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> IterationSample;</span><br></pre></td></tr></table></figure><p>이번에는 map 함수를 사용할 때 key 값을 index 대신 <code>name.id</code> 값으로 지정해 주었습니다.</p><hr><h3 id="데이터-추가-기능-구현"><a href="#데이터-추가-기능-구현" class="headerlink" title="데이터 추가 기능 구현"></a>데이터 추가 기능 구현</h3><p>새로운 이름을 등록할 수 있는 기능을 구현해 봅니다.</p><p>ul 태그 상단에 input 과 button을 렌더링하고 상태를 관리합니다.</p><figure class="highlight jsx"><figcaption><span>IterationSample.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IterationSample = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [names, setNames] = useState([</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'눈사람'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'얼음'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">'눈'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">text</span>: <span class="string">'바람'</span> &#125;,</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">const</span> [inputText, setInputText] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [nextId, setNextId] = useState(<span class="number">5</span>); <span class="comment">// 새 항목을 추가할 때 사용할 id</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> setInputText(e.target.value);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nextNames = names.concat(&#123;</span><br><span class="line">      id: nextId, <span class="comment">//nextId 값을 id로 설정</span></span><br><span class="line">      text: inputText, <span class="comment">//input 안에 작성된 값</span></span><br><span class="line">    &#125;);</span><br><span class="line">    setNextId(nextId + <span class="number">1</span>); <span class="comment">//nextId 값에 1을 더해줌</span></span><br><span class="line">    setNames(nextNames); <span class="comment">//names 값을 업데이트</span></span><br><span class="line">    setInputText(<span class="string">''</span>); <span class="comment">// inputText를 비움</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> nameList = names.map(<span class="function">(<span class="params">name</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;name.id&#125;</span>&gt;</span>&#123;name.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input value=&#123;inputText&#125; onChange=&#123;onChange&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onClick&#125;&gt;추가&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;&#123;nameList&#125;&lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default IterationSample;</span></span><br></pre></td></tr></table></figure><ul><li><code>onClick</code> 함수에서 <code>concat</code>을 사용하여 새로운 항목을 추가한 배열을 만들고, setNames를 통해 상태를 업데이트 해줬습니다.</li></ul><ul><li><p>배열에 새 항목을 추가할 때 <code>push</code>메서드 대신 <code>concat</code>을 사용한 이유 :<br><code>push</code> 메서드는 기본 배열 자체를 변경해 주는 반면<br><code>concat</code> 메서드는 새로운 배열을 만들어 준다는 차이점이 있습니다.</p><p><mark>리액트에서 상태를 업데이트할 때는 기존 상태를 그대로 두면서 새로운 값을 상태로 설정해야 합니다.<br>이를 불변성 유지라고 하며, 불변성 유지를 해줘야 리액트 컴포넌트의 성능을 최적화할 수 있습니다.</mark></p></li></ul><hr><h3 id="데이터-제거-기능-구현"><a href="#데이터-제거-기능-구현" class="headerlink" title="데이터 제거 기능 구현"></a>데이터 제거 기능 구현</h3><p>각 항목을 더블클릭했을 때 해당 항목이 화면에서 사라지는 기능을 구현해 봅니다.<br>이번에도 마찬가지로 <strong>불변성을 유지하면서</strong> 업데이트 해줍니다.</p><p>불변성을 유지하면서 배열의 특정 항목을 제거할 때는 <code>filter</code> 메서드를 사용합니다.</p><p>HTML 요소를 더블클릭할 때 사용하는 이벤트는 <code>onDoubleClick</code>입니다.<br>onRemove 라는 임의 메서드를 <code>filter</code>를 사용하여 만들어 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>IterationSample.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IterationSample = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [names, setNames] = useState([</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'눈사람'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'얼음'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">'눈'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">text</span>: <span class="string">'바람'</span> &#125;,</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">const</span> [inputText, setInputText] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [nextId, setNextId] = useState(<span class="number">5</span>); <span class="comment">// 새 항목을 추가할 때 사용할 id</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> setInputText(e.target.value);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nextNames = names.concat(&#123;</span><br><span class="line">      id: nextId, <span class="comment">//nextId 값을 id로 설정</span></span><br><span class="line">      text: inputText, <span class="comment">//input 안에 작성된 값</span></span><br><span class="line">    &#125;);</span><br><span class="line">    setNextId(nextId + <span class="number">1</span>); <span class="comment">//nextId 값에 1을 더해줌</span></span><br><span class="line">    setNames(nextNames); <span class="comment">//names 값을 업데이트</span></span><br><span class="line">    setInputText(<span class="string">''</span>); <span class="comment">// inputText를 비움</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onRemove = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123; <span class="comment">// 임의 메서드 onRemove 작성</span></span><br><span class="line">    <span class="keyword">const</span> nextNames = names.filter(<span class="function">(<span class="params">name</span>) =&gt;</span> name.id !== id);</span><br><span class="line">    setNames(nextNames);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> nameList = names.map(<span class="function">(<span class="params">name</span>) =&gt;</span> ( <span class="comment">// 더블클릭시 onRemove 메서드 실행</span></span><br><span class="line">    &lt;li key=&#123;name.id&#125; onDoubleClick=&#123;() =&gt; onRemove(name.id)&#125;&gt; </span><br><span class="line">      &#123;name.text&#125;</span><br><span class="line">    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  ));</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input value=&#123;inputText&#125; onChange=&#123;onChange&#125; /</span>&gt;</span><br><span class="line">      &lt;button onClick=&#123;onClick&#125;&gt;추가&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;&#123;nameList&#125;&lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default IterationSample;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;li&gt;</code> 태그 요소를 더블클릭시 onRemove 메서드를 실행하고 해당 배열의 id 값을 파라미터로 넘겨줍니다.</li></ul><ul><li>onRemove 메서드는 <code>filter</code>를 사용하여 더블클릭한 요소의 id값과 다른 요소들만 true를 반환하도록 하여, true를 반환한 요소들만 모아 새 배열로 반환하고 nextNames에 할당합니다.</li></ul><ul><li><code>setNames(nextNames)</code>로 업데이트 합니다.</li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/06/01/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%B0%98%EB%B3%B5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ref : DOM에 이름 달기</title>
      <link>https://hdw0903.github.io/2020/05/28/ref-DOM%EC%97%90-%EC%9D%B4%EB%A6%84-%EB%8B%AC%EA%B8%B0/</link>
      <guid>https://hdw0903.github.io/2020/05/28/ref-DOM%EC%97%90-%EC%9D%B4%EB%A6%84-%EB%8B%AC%EA%B8%B0/</guid>
      <pubDate>Thu, 28 May 2020 10:13:10 GMT</pubDate>
      <description>
      
        &lt;p&gt;HTML에서 id를 사용하여 DOM에 이름을 다는 것처럼 리액트 프로젝트 내부에서 DOM에 이름을 다는 방법이 있습니다. 바로 &lt;code&gt;ref&lt;/code&gt;(reference의 줄임말) 개념입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/28/ref-DOM에-이름-달기/#ref&quot;&gt;ref는 어떤 상황에서 사용해야 할까?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/28/ref-DOM에-이름-달기/#ref_use&quot;&gt;ref 사용&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/28/ref-DOM에-이름-달기/#ref_component&quot;&gt;컴포넌트에 ref 달기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;참고 :&lt;br&gt;리액트 컴포넌트 안에서도 id를 사용할 수 있지만, 특수한 경우가 아니라면 사용을 권장하지 않음.&lt;br&gt;예를 들어 같은 컴포넌트를 여러 번 사용한다면 중복 id를 가진 DOM이 여러 개 생기니 잘못된 사용이 됨.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ref는 전역적으로 작동하지 않고 컴포넌트 내부에서만 작동하기 때문에 이런 문제가 생기지 않음.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>HTML에서 id를 사용하여 DOM에 이름을 다는 것처럼 리액트 프로젝트 내부에서 DOM에 이름을 다는 방법이 있습니다. 바로 <code>ref</code>(reference의 줄임말) 개념입니다.</p><ul><li><a href="/2020/05/28/ref-DOM에-이름-달기/#ref">ref는 어떤 상황에서 사용해야 할까?</a></li></ul><ul><li><a href="/2020/05/28/ref-DOM에-이름-달기/#ref_use">ref 사용</a></li></ul><ul><li><a href="/2020/05/28/ref-DOM에-이름-달기/#ref_component">컴포넌트에 ref 달기</a></li></ul><ul><li><p>참고 :<br>리액트 컴포넌트 안에서도 id를 사용할 수 있지만, 특수한 경우가 아니라면 사용을 권장하지 않음.<br>예를 들어 같은 컴포넌트를 여러 번 사용한다면 중복 id를 가진 DOM이 여러 개 생기니 잘못된 사용이 됨.</p><p><strong>ref는 전역적으로 작동하지 않고 컴포넌트 내부에서만 작동하기 때문에 이런 문제가 생기지 않음.</strong></p></li></ul><a id="more"></a><hr><h2 id="ref">ref는 어떤 상황에서 사용해야 할까?</h2><p><strong>ref는 DOM을 꼭 직접적으로 건드려야 할 때 사용합니다.</strong></p><ol><li><p>특정 <code>&lt;input&gt;</code>태그에 포커스를 주는 경우</p></li><li><p>스크롤 박스를 조작하는 경우</p></li><li><p><code>&lt;Canvas&gt;</code>태그에 그림을 그리는 경우</p></li></ol><hr><h2 id="ref_use">ref 사용</h2><p>프로젝트에서 ref를 사용해 봅시다. <strong>ref를 사용하는 방법은 두 가지가 있습니다.</strong></p><hr><h3 id="콜백-함수를-통한-ref-설정"><a href="#콜백-함수를-통한-ref-설정" class="headerlink" title="콜백 함수를 통한 ref 설정"></a>콜백 함수를 통한 ref 설정</h3><p><strong>ref를 만드는 가장 기본적인 방법은 콜백 함수를 사용하는 것입니다.</strong></p><p>ref를 달고자 하는 요소에 <strong>ref라는 콜백 함수를 props로 전달해 주면 됩니다</strong>.</p><p>이 콜백 함수는 ref 값을 파라미터로 전달받습니다.<br>그리고 함수 내부에서 파라미터로 받은 ref를 컴포넌트의 멤버 변수로 설정해 줍니다.</p><figure class="highlight jsx"><figcaption><span>ref 값으로 콜백 함수 전달</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&#123; (ref) =&gt; &#123; <span class="keyword">this</span>.input=ref &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><p>이렇게 하면 앞으로 this.input은 input 요소의 DOM을 가리킵니다.<br>ref의 이름은 원하는 것으로 자유롭게 지정할 수 있습니다.</p><hr><h3 id="createRef를-통한-ref-설정"><a href="#createRef를-통한-ref-설정" class="headerlink" title="createRef를 통한 ref 설정"></a>createRef를 통한 ref 설정</h3><p>ref를 만드는 또 다른 방법은 리액트에 내장되어 있는 <code>createRef</code> 함수를 사용하는 것입니다.</p><p>이 기능은 리액트 v16.3부터 도입되었으며 이전 버전에서는 작동하지 않습니다.</p><figure class="highlight jsx"><figcaption><span>createRef 사용 예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefSample</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  input = React.createRef();</span><br><span class="line"></span><br><span class="line">  handleFocus = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.input.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input ref=&#123;<span class="keyword">this</span>.input&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default RefSample;</span></span><br></pre></td></tr></table></figure><p><code>createRef</code>를 사용하여 ref를 만들려면 우선 컴포넌트 내부에서 멤버 변수로 React.createRef()를 담아 줘야 합니다.</p><p>해당 멤버 변수를 ref를 달고자 하는 요소에 ref props로 넣어 주면 ref 설정이 완료됩니다.</p><p>설정한 뒤 나중에 ref를 설정해 준 DOM에 접근하려면 this.input.current를 조회하면 됩니다.</p><p><strong>콜백 함수를 사용할 때와 다른 점은 이렇게 뒷부분에 .current를 넣어 줘야 한다는 것입니다.</strong></p><hr><h2 id="ref_component">컴포넌트에 ref 달기</h2><p>리액트에서는 컴포넌트에도 ref를 달 수 있습니다.</p><p>이 방법은 주로 컴포넌트 내부에 있는 DOM을 컴포넌트 외부에서 사용할 때 씁니다.</p><hr><h3 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent</span><br><span class="line">  ref= &#123;(ref) =&gt; &#123;<span class="keyword">this</span>.myComponent=ref&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><p>이렇게 하면 MyComponent 내부의 메서드 및 맴버 변수에 접근할 수 있습니다.<br>즉 내부의 ref에도 접근할 수 있습니다.</p><hr><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><p><strong>부모 컴포넌트에서 스크롤바 내리기</strong></p><p>ScrollBox.js 컴포넌트 파일을 만들고 스크롤 박스를 만들어 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>ScrollBox.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollBox</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> style = &#123;</span><br><span class="line">      border: <span class="string">'1px solid black'</span>,</span><br><span class="line">      height: <span class="string">'300px'</span>,</span><br><span class="line">      width: <span class="string">'300px'</span>,</span><br><span class="line">      overflow: <span class="string">'auto'</span>,</span><br><span class="line">      position: <span class="string">'relative'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> innerStyle = &#123;</span><br><span class="line">      width: <span class="string">'100%'</span>,</span><br><span class="line">      height: <span class="string">'650px'</span>,</span><br><span class="line">      background: <span class="string">'linear-gradient(white, black)'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div</span><br><span class="line">        style=&#123;style&#125;</span><br><span class="line">        ref=&#123;(ref) =&gt; &#123;</span><br><span class="line">          <span class="keyword">this</span>.box = ref;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;div style=&#123;innerStyle&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default ScrollBox;</span></span><br></pre></td></tr></table></figure><hr><h4 id="컴포넌트에-메서드-생성"><a href="#컴포넌트에-메서드-생성" class="headerlink" title="컴포넌트에 메서드 생성"></a>컴포넌트에 메서드 생성</h4><p>컴포넌트에 스크롤바를 맨 아래쪽으로 내리는 메서드를 만들겠습니다.</p><p>자바스크립트로 스크롤바를 내릴 때는 DOM 노드가 가진 다음 값들을 사용합니다.</p><ul><li><p>scrollTop: 세로 스크롤바 위치 (0~350)</p></li><li><p>scrollHeight: 스크롤이 있는 박스 안의 div 높이 (650)</p></li><li><p>clientHeight: 스크롤이 있는 박스의 높이 (300)</p></li></ul><figure class="highlight jsx"><figcaption><span>ScrollBox.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollBox</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  scrollToBottom = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; scrollHeight, clientHeight &#125; = <span class="keyword">this</span>.box;</span><br><span class="line">    <span class="comment">/* 앞 코드에는 비구조화 할당 문법을 사용했습니다.</span></span><br><span class="line"><span class="comment">    다음 코드와 같은 의미입니다.</span></span><br><span class="line"><span class="comment">    const scrollHeight = this.box.scrollHeight;</span></span><br><span class="line"><span class="comment">    const clientHeight = this.box.cliengHeight;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">this</span>.box.scrollTop = scrollHeight - clientHeight;</span><br><span class="line">  &#125;;</span><br><span class="line">(...)</span><br></pre></td></tr></table></figure><p>이렇게 만든 메서드는 부모 컴포넌트인 App 컴포넌트에서 ScrollBox에 ref를 달면 사용할 수 있습니다.</p><hr><h4 id="컴포넌트에-ref-달고-내부-메서드-사용"><a href="#컴포넌트에-ref-달고-내부-메서드-사용" class="headerlink" title="컴포넌트에 ref 달고 내부 메서드 사용"></a>컴포넌트에 ref 달고 내부 메서드 사용</h4><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ScrollBox <span class="keyword">from</span> <span class="string">'./ScrollBox'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ScrollBox ref=&#123;(ref) =&gt; (<span class="keyword">this</span>.scrollBox = ref)&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.scrollBox.scrollToBottom()&#125;&gt;</span><br><span class="line">          맨 밑으로</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>App 컴포넌트에서 ScrollBox에 ref를 달고 버튼을 만들어 누르면, ScrollBox 컴포넌트의 scrollToBottom 메서드가 실행됩니다.</p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/28/ref-DOM%EC%97%90-%EC%9D%B4%EB%A6%84-%EB%8B%AC%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이벤트 -React</title>
      <link>https://hdw0903.github.io/2020/05/27/%EC%9D%B4%EB%B2%A4%ED%8A%B8-React/</link>
      <guid>https://hdw0903.github.io/2020/05/27/%EC%9D%B4%EB%B2%A4%ED%8A%B8-React/</guid>
      <pubDate>Wed, 27 May 2020 09:23:01 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/27/이벤트-React/#React_event&quot;&gt;리액트의 이벤트 시스템&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;이벤트 사용 시 주의사항&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/27/이벤트-React/#event_handling&quot;&gt;이벤트 핸들링 익히기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/27/이벤트-React/#3&quot;&gt;함수형 컴포넌트로 구현&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<ul><li><a href="/2020/05/27/이벤트-React/#React_event">리액트의 이벤트 시스템</a><ul><li>이벤트 사용 시 주의사항</li></ul></li></ul><ul><li><a href="/2020/05/27/이벤트-React/#event_handling">이벤트 핸들링 익히기</a></li></ul><ul><li><a href="/2020/05/27/이벤트-React/#3">함수형 컴포넌트로 구현</a></li></ul><a id="more"></a><hr><h2 id="React_event">리액트의 이벤트 시스템</h2><p>리액트의 이벤트 시스템은 웹 브라우저의 HTML 이벤트와 인터페이스가 동일하기 때문에 사용법이 비슷한데,</p><p>주의해야할 몇가지 사항이 있습니다.</p><hr><h3 id="이벤트-사용-시-주의-사항"><a href="#이벤트-사용-시-주의-사항" class="headerlink" title="이벤트 사용 시 주의 사항"></a>이벤트 사용 시 주의 사항</h3><ol><li>이벤트 이름은 카멜 표기법으로 작성합니다.<br>ex) onclick -&gt; onClick, onchange -&gt; onChange</li></ol><ol start="2"><li>이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, <strong>함수 형태의 객체를 전달합니다.</strong></li></ol><ol start="3"><li><p>DOM 요소에만 이벤트를 설정할 수 있습니다.</p><p><code>&lt;div&gt;</code>, <code>&lt;button&gt;</code>, <code>&lt;input&gt;</code>, <code>&lt;form&gt;</code>, <code>&lt;span&gt;</code>등 DOM요소에만 이벤트를 사용할 수 있습니다.</p><p>직접 만든 컴포넌트에는 이벤트를 자체적으로 설정할 수 없습니다.</p><figure class="highlight jsx"><figcaption><span>컴포넌트에 이벤트 설정 불가</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Mycomponent onClick=&#123;something&#125; /&gt;</span><br></pre></td></tr></table></figure><p>위 코드는 Mycomponent를 클릭할 때 something 함수를 실행하는 것이 아니라, 그냥 이름이 onClick인 props를 Mycomponent에게 전달해 줍니다. 이벤트가 발생하지 않습니다.</p></li></ol><hr><h3 id="이벤트-종류"><a href="#이벤트-종류" class="headerlink" title="이벤트 종류"></a>이벤트 종류</h3><p>리액트에서 지원하는 이벤트 종류는 다음과 같습니다.</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>Clipboard</td><td>Touch</td><td>Composition</td></tr><tr><td>UI</td><td>Keyboard</td><td>Wheel</td></tr><tr><td>Focus</td><td>Media</td><td>Form</td></tr><tr><td>Image</td><td>Mouse</td><td>Animation</td></tr><tr><td>Selection</td><td>Transition</td><td></td></tr></tbody></table><ul><li>더 자세한 이벤트 정보는 <a href="https://facebook.github.io/react/docs/events.html">리액트 메뉴얼을 참고합니다.</a></li></ul><hr><h2 id="event_handling">이벤트 핸들링 익히기</h2><p>다음 단계에 맞춰 이벤트 핸들링을 익혀봅니다.<br><img src="/images/%EC%9D%B4%EB%B2%A4%ED%8A%B8_%ED%95%B8%EB%93%A4%EB%A7%81_%EC%98%88%EC%A0%9C_%EC%88%9C%EC%84%9C.png" alt="이벤트 핸들링 예제 순서"></p><p>먼저 EventPractice.js 파일을 만들고 클래스형 컴포넌트로 작성 후 App 컴포넌트에서 불러와 렌더링하겠습니다.</p><figure class="highlight jsx"><figcaption><span>EventPractice.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventPractice;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> EventPractice <span class="keyword">from</span> <span class="string">"./EventPractice"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">EventPractice</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><hr><h3 id="onChange-이벤트-핸들링"><a href="#onChange-이벤트-핸들링" class="headerlink" title="onChange 이벤트 핸들링"></a>onChange 이벤트 핸들링</h3><h4 id="onChange-이벤트-설정"><a href="#onChange-이벤트-설정" class="headerlink" title="onChange 이벤트 설정"></a>onChange 이벤트 설정</h4><p>EventPractice 컴포넌트에 input 요소를 렌더링하는 코드와 해당 요소에 onChange 이벤트를 설정하는 코드를 작성합니다.</p><figure class="highlight jsx"><figcaption><span>EventPractice.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="text"</span></span><br><span class="line"><span class="regexp">          name="message"</span></span><br><span class="line"><span class="regexp">          placeholder="아무거나 입력하세요"</span></span><br><span class="line"><span class="regexp">          onChange=&#123;(e) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            console.log(e);</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default EventPractice;</span></span><br></pre></td></tr></table></figure><p>웹 브라우저에서 개발자 도구를 열어 인풋에 아무거나 입력해보면 이벤트 객체가 콘솔에 나타납니다.</p><p>콘솔에 기록되는 e 객체는 <code>SyntheticEvent</code>로 웹 브라우저에서 네이티브 이벤트를 감싸는 객체입니다.</p><ul><li><code>SyntheticEvent</code>는 네이티브 이벤트와 달리 이벤트가 끝나고 나면 이벤트가 초기화되므로 정보를 참조할 수 없습니다. ex) 0.5초뒤 e 객체를 참조하면 e 객체 내부의 모든 값이 비워져있어 참조 불가능.</li></ul><ul><li>비동기적으로 이벤트 객체를 참조할 일이 있다면 e.persist() 함수를 호출해 줘야합니다.</li></ul><p>onChange 이벤트가 발생할 때, 변할 input 값을 콘솔에 기록하려면 <code>e.target.value</code>를 콘솔에 넣어주면 됩니다.</p><figure class="highlight jsx"><figcaption><span>EventPractice.js onChange 코드 수정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onChange=&#123;</span><br><span class="line">  (e) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input 값이 변할 때 마다 콘솔에 기록됩니다.</p><hr><h4 id="state에-input-값-담기"><a href="#state에-input-값-담기" class="headerlink" title="state에 input 값 담기"></a>state에 input 값 담기</h4><ul><li><p>state 초기값을 설정하고</p></li><li><p>이벤트 핸들링 함수 내부에서 this.setState 메서드를 호출하여 state를 업데이트합니다.</p></li><li><p>input의 <code>value</code> 값을 <code>state</code>에 있는 값으로 설정합니다.</p></li></ul><figure class="highlight jsx"><figcaption><span>EventPractice.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state =&#123;</span><br><span class="line">    message: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="text"</span></span><br><span class="line"><span class="regexp">          name="message"</span></span><br><span class="line"><span class="regexp">          placeholder="아무거나 입력하세요"</span></span><br><span class="line"><span class="regexp">          value=&#123;this.state.message&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;(e) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            this.setState(&#123;</span></span><br><span class="line"><span class="regexp">              message: e.target.value</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default EventPractice;</span></span><br></pre></td></tr></table></figure><p>브라우저에서 인풋에 입력했을 때 오류가 발생하지 않고 재대로 입력할 수 있다면 state에 텍스트를 잘 담은 것입니다.</p><hr><h4 id="클릭-이벤트시-state-값-출력-후-초기화"><a href="#클릭-이벤트시-state-값-출력-후-초기화" class="headerlink" title="클릭 이벤트시 state 값 출력 후 초기화"></a>클릭 이벤트시 state 값 출력 후 초기화</h4><p><code>&lt;button&gt;</code>을 하나 만들고 클릭 이벤트가 발생 시 현재 comment(state로 담은 값)값을 alert 창으로 띄운 후 초기값으로 설정합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    message: <span class="string">""</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="text"</span></span><br><span class="line"><span class="regexp">          name="message"</span></span><br><span class="line"><span class="regexp">          placeholder="아무거나 입력하세요"</span></span><br><span class="line"><span class="regexp">          value=&#123;this.state.message&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;(e) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            this.setState(&#123;</span></span><br><span class="line"><span class="regexp">              message: e.target.value,</span></span><br><span class="line"><span class="regexp">            &#125;);</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;() =&gt; &#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.state.message);</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">              message: <span class="string">""</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          확인</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventPractice;</span><br></pre></td></tr></table></figure><p>input에 아무거나 입력 후 확인 버튼을 누르면 state에 담은 값이 alert창으로 출력되고 확인버튼을 누르면 input 값이 초기화 됩니다.</p><hr><h3 id="임의-메서드-만들기"><a href="#임의-메서드-만들기" class="headerlink" title="임의 메서드 만들기"></a>임의 메서드 만들기</h3><p>앞서 onChange와 onClick에 전달한 함수를 따로 빼내어 컴포넌트 임의 메서드를 만들어 봅니다.</p><figure class="highlight jsx"><figcaption><span>EventPractice.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    message: <span class="string">""</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      message: e.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.state.message);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      message: <span class="string">""</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="text"</span></span><br><span class="line"><span class="regexp">          name="message"</span></span><br><span class="line"><span class="regexp">          placeholder="아무거나 입력하세요"</span></span><br><span class="line"><span class="regexp">          value=&#123;this.state.message&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;this.handleChange&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;확인&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventPractice;</span><br></pre></td></tr></table></figure><hr><h4 id="Property-Initializer-Syntax를-사용한-메서드-작성"><a href="#Property-Initializer-Syntax를-사용한-메서드-작성" class="headerlink" title="Property Initializer Syntax를 사용한 메서드 작성"></a>Property Initializer Syntax를 사용한 메서드 작성</h4><p>메서드 바인딩은 생성자 메서드에서 바인딩 하는 방법이 정석이지만,<br>새로운 메서드를 만들 때마다 constructor를 수정해야하는 번거로움이 있습니다.</p><p>바벨의 <code>transform-class-properties</code> 문법을 사용하여 화살표 함수 형태로 작성하면<br><strong>생성자 함수를 사용하지 않고 동적으로 바인딩이 가능합니다.</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    message: <span class="string">""</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      message: e.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.state.message);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      message: <span class="string">""</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><code>transform-class-properties</code>을 사용하여 이처럼 사용할 수 있습니다.</p><hr><h3 id="input-여러-개-다루기"><a href="#input-여러-개-다루기" class="headerlink" title="input 여러 개 다루기"></a>input 여러 개 다루기</h3><p><strong>동일한 여러 태그 다뤄보기</strong></p><p>동일한 태그 여러 개를 작업할 때 메서드를 여러개 만드는 방법보다 쉬운 방법이 있습니다.</p><ul><li><strong>event 객체를 활용하여 처리할 수 있습니다.</strong></li></ul><p>onChange 이벤트 핸들러에서 e.target.name은 해당 인풋의 name을 가리킵니다. (현재 message)</p><p>이 값을 사용하여 state를 설정해 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>e.target.name 사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    username: <span class="string">''</span>,</span><br><span class="line">    message: <span class="string">''</span></span><br><span class="line">  &#125;;</span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      [e.target.name]: e.target.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.state.username + <span class="string">': '</span> + <span class="keyword">this</span>.state.message);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      username: <span class="string">''</span>,</span><br><span class="line">      message: <span class="string">''</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="text"</span></span><br><span class="line"><span class="regexp">          name="username"</span></span><br><span class="line"><span class="regexp">          placeholder="유저명"</span></span><br><span class="line"><span class="regexp">          value=&#123;this.state.username&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;this.handleChange&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          name=<span class="string">"message"</span></span><br><span class="line">          placeholder=<span class="string">"아무거나 입력해보세요"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.message&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.handleChange&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;확인&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventPractice;</span><br></pre></td></tr></table></figure><p><strong>객체 안에서 key를 []로 감싸면 그 안에 넣은 레퍼런스가 가리키는 실제 값이 key 값으로 사용됩니다.</strong></p><hr><h3 id="onKeyPress-이벤트-핸들링"><a href="#onKeyPress-이벤트-핸들링" class="headerlink" title="onKeyPress 이벤트 핸들링"></a>onKeyPress 이벤트 핸들링</h3><p>comment 인풋에서 enter를 눌렀을 때 KeyPress 이벤트를 처리하는 handleClick 메서드를 호출하도록 해봅니다.</p><figure class="highlight jsx"><figcaption><span>KeyPress</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPractice</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    username: <span class="string">""</span>,</span><br><span class="line">    message: <span class="string">""</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      [e.target.name]: e.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.state.username + <span class="string">": "</span> + <span class="keyword">this</span>.state.message);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      username: <span class="string">""</span>,</span><br><span class="line">      message: <span class="string">""</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleKeyPress = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.key === <span class="string">"Enter"</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.handleClick();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="text"</span></span><br><span class="line"><span class="regexp">          name="username"</span></span><br><span class="line"><span class="regexp">          placeholder="유저명"</span></span><br><span class="line"><span class="regexp">          value=&#123;this.state.username&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;this.handleChange&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          name=<span class="string">"message"</span></span><br><span class="line">          placeholder=<span class="string">"아무거나 입력해보세요"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.message&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.handleChange&#125;</span><br><span class="line">          onKeyPress=&#123;<span class="keyword">this</span>.handleKeyPress&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;확인&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventPractice;</span><br></pre></td></tr></table></figure><p>두 번째 텍스트 인풋에서 텍스트를 입력하고 enter를 누르면 handleClick 메서드가 실행됩니다.</p><hr><h2 id="3">함수형 컴포넌트로 구현</h2><p>여태 한 작업을 함수형 컴포넌트로 똑같이 구현할 수 있습니다.</p><p>함수형 컴포넌트로 구현 시 </p><figure class="highlight jsx"><figcaption><span>함수형 컴포넌트로 작성</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EventPractice = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [username, setUsername] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [message, setMessage] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> onChangeUsername = <span class="function">(<span class="params">e</span>) =&gt;</span> setUsername(e.target.value);</span><br><span class="line">  <span class="keyword">const</span> onChangeMessage = <span class="function">(<span class="params">e</span>) =&gt;</span> setMessage(e.target.value);</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(username + <span class="string">': '</span> + message);</span><br><span class="line">    setUsername(<span class="string">''</span>);</span><br><span class="line">    setMessage(<span class="string">''</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onKeyPress = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.key === <span class="string">'Enter'</span>) &#123;</span><br><span class="line">      onClick();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input</span></span><br><span class="line"><span class="regexp">        type="text"</span></span><br><span class="line"><span class="regexp">        name="username"</span></span><br><span class="line"><span class="regexp">        placeholder="유저명"</span></span><br><span class="line"><span class="regexp">        value=&#123;username&#125;</span></span><br><span class="line"><span class="regexp">        onChange=&#123;onChangeUsername&#125;</span></span><br><span class="line"><span class="regexp">      /</span>&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        name=<span class="string">"message"</span></span><br><span class="line">        placeholder=<span class="string">"아무거나 입력해보세요"</span></span><br><span class="line">        value=&#123;message&#125;</span><br><span class="line">        onChange=&#123;onChangeMessage&#125;</span><br><span class="line">        onKeyPress=&#123;onKeyPress&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onClick&#125;&gt;확인&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventPractice;</span><br></pre></td></tr></table></figure><p>위 코드에서는 e.target.name을 활용하지 않고 onChange 관련 함수 두 개를 따로 만들어 주었습니다.</p><p>이번에는 useState를 통해 사용하는 상태에 문자열이 아닌 객체를 넣어 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>EventPractice.js 수정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EventPractice = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [form, setForm] = useState(&#123;</span><br><span class="line">    username: <span class="string">''</span>,</span><br><span class="line">    message: <span class="string">''</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> &#123; username, message &#125; = form;</span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nextForm = &#123;</span><br><span class="line">      ...form, <span class="comment">// 기존의 form 내용을 이 자리에 복사 한 뒤</span></span><br><span class="line">      [e.target.name]: e.target.value, <span class="comment">// 원하는 값을 덮어씌우기</span></span><br><span class="line">    &#125;;</span><br><span class="line">    setForm(nextForm);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(username + <span class="string">': '</span> + message);</span><br><span class="line">    setForm(&#123;</span><br><span class="line">      username: <span class="string">''</span>,</span><br><span class="line">      message: <span class="string">''</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onKeyPress = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.key === <span class="string">'Enter'</span>) &#123;</span><br><span class="line">      onClick();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;이벤트 연습&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input</span></span><br><span class="line"><span class="regexp">        type="text"</span></span><br><span class="line"><span class="regexp">        name="username"</span></span><br><span class="line"><span class="regexp">        placeholder="유저명"</span></span><br><span class="line"><span class="regexp">        value=&#123;username&#125;</span></span><br><span class="line"><span class="regexp">        onChange=&#123;onChange&#125;</span></span><br><span class="line"><span class="regexp">      /</span>&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        name=<span class="string">"message"</span></span><br><span class="line">        placeholder=<span class="string">"아무거나 입력해보세요"</span></span><br><span class="line">        value=&#123;message&#125;</span><br><span class="line">        onChange=&#123;onChange&#125;</span><br><span class="line">        onKeyPress=&#123;onKeyPress&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onClick&#125;&gt;확인&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventPractice;</span><br></pre></td></tr></table></figure><p>e.target.name 값을 활용하려면, 위와 같이 useState를 쓸 때 인풋 값들이 들어있는 form 객체를 사용해 주면 됩니다.</p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/27/%EC%9D%B4%EB%B2%A4%ED%8A%B8-React/#disqus_thread</comments>
    </item>
    
    <item>
      <title>컴포넌트(component)</title>
      <link>https://hdw0903.github.io/2020/05/24/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-component/</link>
      <guid>https://hdw0903.github.io/2020/05/24/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-component/</guid>
      <pubDate>Sun, 24 May 2020 09:53:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;컴포넌트를 선언하는 방식은 두 가지입니다.&lt;br&gt;하나는 함수형 컴포넌트이고 또 다른 하나는 클래스형 컴포넌트입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/24/컴포넌트-component/#component&quot;&gt;클래스형 컴포넌트&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;함수형 컴포넌트&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/24/컴포넌트-component/#New_component&quot;&gt;컴포넌트 생성&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;src 디렉터리에 MyComponent.js 파일 생성&lt;/li&gt;
&lt;li&gt;코드 작성&lt;/li&gt;
&lt;li&gt;모듈 내보내기(export) 및 불러오기(import)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/24/컴포넌트-component/#props&quot;&gt;props&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSX 내부에서 props 렌더링&lt;/li&gt;
&lt;li&gt;컴포넌트를 사용할 때 props 값 지정하기&lt;/li&gt;
&lt;li&gt;props 기본값 설정: defaultProps&lt;/li&gt;
&lt;li&gt;컴포넌트 태그 사이의 내용을 보여주는 children&lt;/li&gt;
&lt;li&gt;비구조화 할당 문법을 통한 props 내부 값 추출&lt;/li&gt;
&lt;li&gt;propTypes를 통한 props 검증&lt;/li&gt;
&lt;li&gt;클래스형 컴포넌트에서 props 사용하기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/24/컴포넌트-component/#state&quot;&gt;state&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클래스형 컴포넌트의 state&lt;/li&gt;
&lt;li&gt;함수형 컴포넌트에서 useState 사용하기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/24/컴포넌트-component/#state_주의사항&quot;&gt;state 사용시 주의 사항&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>컴포넌트를 선언하는 방식은 두 가지입니다.<br>하나는 함수형 컴포넌트이고 또 다른 하나는 클래스형 컴포넌트입니다.</p><ul><li><a href="/2020/05/24/컴포넌트-component/#component">클래스형 컴포넌트</a><ul><li>함수형 컴포넌트</li></ul></li></ul><ul><li><a href="/2020/05/24/컴포넌트-component/#New_component">컴포넌트 생성</a><ul><li>src 디렉터리에 MyComponent.js 파일 생성</li><li>코드 작성</li><li>모듈 내보내기(export) 및 불러오기(import)</li></ul></li></ul><ul><li><p><a href="/2020/05/24/컴포넌트-component/#props">props</a></p><ul><li>JSX 내부에서 props 렌더링</li><li>컴포넌트를 사용할 때 props 값 지정하기</li><li>props 기본값 설정: defaultProps</li><li>컴포넌트 태그 사이의 내용을 보여주는 children</li><li>비구조화 할당 문법을 통한 props 내부 값 추출</li><li>propTypes를 통한 props 검증</li><li>클래스형 컴포넌트에서 props 사용하기</li></ul></li><li><p><a href="/2020/05/24/컴포넌트-component/#state">state</a></p><ul><li>클래스형 컴포넌트의 state</li><li>함수형 컴포넌트에서 useState 사용하기</li></ul></li></ul><ul><li><a href="/2020/05/24/컴포넌트-component/#state_주의사항">state 사용시 주의 사항</a></li></ul><a id="more"></a><hr><h2 id="component">클래스형 컴포넌트</h2><p>아래 App 컴포넌트는 함수형 컴포넌트이며, 코드가 다음과 같은 구조로 이루어져 있습니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"react"</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>App.js 코드를 수정하여 클래스형 컴포넌트로 만들면</p><figure class="highlight jsx"><figcaption><span>클래스형 컴포넌트</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">"react"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"react"</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>클래스형 컴포넌트로 작성하였지만 역활은 이전의 함수형 컴포넌트와 똑같습니다.</p><ul><li>클래스형 컴포넌트와 함수형 컴포넌트의 차이점은 <strong>클래스형 컴포넌트의 경우 <code>state</code> 기능 및 <code>라이프사이클</code> 기능을 사용할 수 있다는 것과 임의 메서드를 정의할 수 있다는 것입니다.</strong></li></ul><ul><li>클래스형 컴포넌트에서는 <code>render</code>함수가 꼭 있어야 하고, 그 안에서 보여 주어야 할 JSX를 반환해야 합니다.</li></ul><hr><h3 id="함수형-컴포넌트"><a href="#함수형-컴포넌트" class="headerlink" title="함수형 컴포넌트"></a>함수형 컴포넌트</h3><ul><li><p><strong>함수형 컴포넌트 장점</strong></p><ul><li>클래스형 컴포넌트보다 선언하기 훨씬 편리하다.</li><li>메모리 자원도 클래스형 컴포넌트보다 덜 사용한다.</li><li>프로젝트를 완성하여 빌드한 후 배포시에도 함수형 컴포넌트 결과물의 파일 크기가 더 작다.</li></ul></li></ul><ul><li><p><strong>함수형 컴포넌트 주요 단점</strong></p><ul><li>함수형 컴포넌트의 주요 단점은 <code>state</code>와 <code>라이플사이클 API</code>의 사용이 불가능하다는 점이었으나,<br><strong>이 단점은 리액트 v16.8 업데이트 이후 <code>Hooks</code>라는 기능이 도입되면서 해결되었습니다.</strong><br>완전히 클래스형 컴포넌트와 똑같이 사용할 수 있는 것은 아니지만 조금 다른 방식으로 비슷한 작업을 할 수 있게 되었습니다. </li></ul></li></ul><p><u>리액트 공식 메뉴얼에서는</u> 컴포넌트를 새로 작성할 때 <code>함수형 컴포넌트</code>와 <code>Hooks</code>를 사용하도록 권장합니다. 하지만 클래스형 컴포넌트가 없어진 것은 아니므로 클래스형 컴포넌트의 기능도 꼭 알아 두어야합니다.</p><hr><h2 id="New_component">컴포넌트 생성</h2><p><img src="/images/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%83%9D%EC%84%B1.png" alt="컴포넌트 생성 과정"></p><h3 id="src-디렉터리에-MyComponent-js-파일-생성"><a href="#src-디렉터리에-MyComponent-js-파일-생성" class="headerlink" title="src 디렉터리에 MyComponent.js 파일 생성"></a>src 디렉터리에 MyComponent.js 파일 생성</h3><p>컴포넌트를 만들려면 <strong>컴포넌트 코드를 선언할 파일을 만들고 내부에 컴포넌트 코드를 선언해야 합니다</strong>.</p><p>파일 목록 중 src 디렉터리 내부에 새 파일을 만들고 파일 이름을 MyComponent.js라고 입력합니다.</p><hr><h3 id="코드-작성하기"><a href="#코드-작성하기" class="headerlink" title="코드 작성하기"></a>코드 작성하기</h3><p>MyComponent.js 파일을 열고 새 컴포넌트의 코드를 작성합니다.</p><figure class="highlight jsx"><figcaption><span>MyComponent.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>새 컴포넌트<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyComponent;</span><br></pre></td></tr></table></figure><hr><h3 id="모듈-내보내기-export-및-불러오기-import"><a href="#모듈-내보내기-export-및-불러오기-import" class="headerlink" title="모듈 내보내기(export) 및 불러오기(import)"></a>모듈 내보내기(export) 및 불러오기(import)</h3><ul><li>모듈 내보내기(export)<figure class="highlight jsx"><figcaption><span>내보내기 (export)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyComponent;</span><br></pre></td></tr></table></figure></li></ul><p>위 코드가 다른파일에서 이 파일을 불러오기(<code>import</code>)할 때, 선언한 <code>MyComponent</code> 클래스를 불러오도록 설정해줍니다.</p><ul><li>모듈 불러오기(import)<figure class="highlight jsx"><figcaption><span>불러오기(import)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./MyComponent'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></li></ul><p>다른 컴포넌트에서 <code>MyComponent</code> 컴포넌트를 불러와서 사용하려면 위와 같이 두 번째줄에 <code>import</code> 구문 처럼 사용합니다.</p><hr><h2 id="props">props</h2><p><code>props</code>는 <code>properties</code>를 줄인 표현으로 <strong>컴포넌트 속성을 설정할 때 사용하는 요소입니다.</strong></p><p><code>props 값</code>은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트(App 컴포넌트에서 MyComponent 컴포넌트를 불러와 사용한다면 App 컴포넌트가 부모 컴포넌트입니다.)에서 설정할 수 있습니다.</p><hr><h3 id="JSX-내부에서-props-렌더링"><a href="#JSX-내부에서-props-렌더링" class="headerlink" title="JSX 내부에서 props 렌더링"></a>JSX 내부에서 props 렌더링</h3><p>props 값은 컴포넌트 함수의 파라미터로 받아와 사용할 수 있습니다.</p><p>props를 렌더링할 때 JSX 내부에서 중괄호{}로 감싸 주면 됩니다.</p><figure class="highlight jsx"><figcaption><span>MyComponent.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>제 이름은 &#123;props.name&#125;입니다.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyComponent;</span><br></pre></td></tr></table></figure><hr><h3 id="컴포넌트를-사용할-때-props-값-지정하기"><a href="#컴포넌트를-사용할-때-props-값-지정하기" class="headerlink" title="컴포넌트를 사용할 때 props 값 지정하기"></a>컴포넌트를 사용할 때 props 값 지정하기</h3><p>App 컴포넌트(부모 컴포넌트)에서 MyComponent의 props 값을 지정해 보겠습니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./MyComponent'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">name</span>=<span class="string">"React"</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>코드를 저장하고 브라우저를 확인해 보면 “제 이름은 React입니다.”가 출력됩니다.</p><hr><h3 id="props-기본값-설정-defaultProps"><a href="#props-기본값-설정-defaultProps" class="headerlink" title="props 기본값 설정: defaultProps"></a>props 기본값 설정: defaultProps</h3><p>설정한 name 값을 지우고 다시 실행하면</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">name</span>=<span class="string">"React"</span> /&gt;</span></span>;</span><br><span class="line"><span class="comment">// name 값 삭제</span></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>브라우저에 “제 이름은 입니다.”가 출력될 것입니다.</p><p><code>defaultProps</code>는 이 처럼 props 값을 따로 지정하지 않았을 때 보여줄 기본값을 설정해줍니다.</p><figure class="highlight jsx"><figcaption><span>defaultProps</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>제 이름은 &#123;props.name&#125;입니다.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyComponent.defaultProps = &#123;</span><br><span class="line">  name: <span class="string">"기본 이름"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyComponent;</span><br></pre></td></tr></table></figure><p>이 처럼 <code>MyComponent.defaultProps</code>에 <code>name</code> 값으로 “기본 이름”을 지정해주면<br>props 값이 지정되있지 않을 때 “제 이름은 기본이름 입니다”라고 출력됩니다.</p><hr><h3 id="태그-사이의-내용을-보여-주는-children"><a href="#태그-사이의-내용을-보여-주는-children" class="headerlink" title="태그 사이의 내용을 보여 주는 children"></a>태그 사이의 내용을 보여 주는 children</h3><p>리액트 컴포넌트를 사용할 때 컴포넌트 태그 사이의 내용을 보여 주는 props가 바로 <code>children</code>입니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">"./MyComponent"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span>리액트<span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>위 코드에서 MyComponent 태그 사이에 작성한 “리액트”라는 문자열을 MyComponent 내부에서 보여 주려면 <code>props.children</code> 값을 보여 주어야 합니다.</p><p>MyComponent.js 파일을 다음과 같이 수정합니다.</p><figure class="highlight jsx"><figcaption><span>MyComponent.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      제 이름은 &#123;props.name&#125;입니다. &lt;br /&gt;</span><br><span class="line">      children 값은 &#123;props.children&#125;입니다.</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  name: "기본 이름",</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><ul><li>브라우저에 결과물로 다음과 같이 나타납니다.<br><img src="/images/props_children.png" alt="defaultProps, props.children"></li></ul><hr><h3 id="비구조화-할당-문법을-통해-props-내부-값-추출"><a href="#비구조화-할당-문법을-통해-props-내부-값-추출" class="headerlink" title="비구조화 할당 문법을 통해 props 내부 값 추출"></a>비구조화 할당 문법을 통해 props 내부 값 추출</h3><p>현재 MyComponent.js에서 props 값을 조회할 때 마다 props.name, props.children 형태로 <code>props.</code> 키워드를 앞에 붙여 주고 있습니다. </p><p>이러한 작업을 더 편하기 위해 <strong>ES6의 비구조화 할당 문법을 사용하여 내부 값을 바로 추출하는 방법</strong>이 있습니다.</p><figure class="highlight jsx"><figcaption><span>MyComponent.js 수정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, children &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      제 이름은 &#123;name&#125;입니다. &lt;br /&gt;</span><br><span class="line">      children 값은 &#123;children&#125;입니다.</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  name: "기본 이름",</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><p>이렇게 코드를 작성하면 name, children 값을 더 짧은 코드로 작성할 수 있습니다.</p><p>이렇게 사용하는 방법을(객체에서 값을 추출하는 문법) 비구조화 할당(destructuring assignment)라고 부릅니다.</p><ul><li>비구조화 할당 문법은 <strong>함수의 파라미터 부분에서도 사용할 수 있습니다.</strong><br>만약 함수의 파라미터가 객체라면 그 값을 바로 비구조화해서 사용하는 것입니다.</li></ul><figure class="highlight jsx"><figcaption><span>함수의 파라미터에서 사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">&#123; name, children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      제 이름은 &#123;name&#125;입니다. &lt;br /&gt;</span><br><span class="line">      children 값은 &#123;children&#125;입니다.</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  name: "기본 이름",</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><hr><h3 id="propTypes를-통한-props-검증"><a href="#propTypes를-통한-props-검증" class="headerlink" title="propTypes를 통한 props 검증"></a>propTypes를 통한 props 검증</h3><ul><li><code>propTypes</code>:<br>컴포넌트의 필수 props를 지정하거나 props의 타입(type)을 지정할 때 사용</li></ul><ul><li>propTypes를 사용하려면 코드 상단에 import 구문을 사용하여 불러와야 합니다.</li></ul><figure class="highlight jsx"><figcaption><span>propTypes 사용하여 type 값 지정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">&#123; name, children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      제 이름은 &#123;name&#125;입니다. &lt;br /&gt;</span><br><span class="line">      children 값은 &#123;children&#125;입니다.</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  name: "기본 이름",</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  name: PropTypes.string</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><p>import 구문으로 propTypes를 불러와 <code>MyComponent.propTypes</code>를 위와 같이 설정해 주면<br>name 값은 무조건 문자열(string) 형태로 전달해야 된다는 것을 의미합니다.</p><p>App 컴포넌트 (부모 컴포넌트)에서 name 값을 문자열이 아닌 숫자로 전달하면 값은 표시되지만 콘솔창에 경고 메세지가 출력되며 개발자에게 propTypes이 잘못되었다는 것을 알려줍니다.</p><hr><h4 id="isRequired를-사용하여-필수-propTypes-설정"><a href="#isRequired를-사용하여-필수-propTypes-설정" class="headerlink" title="isRequired를 사용하여 필수 propTypes 설정"></a>isRequired를 사용하여 필수 propTypes 설정</h4><p>isRequired를 사용하여 propTypes를 지정하지 않았을 때 경고 메세지를 띄워 주는 작업을 해봅니다.</p><ul><li>propTypes를 지정할 때 뒤에 isRequired를 붙여 사용하면 됩니다.</li></ul><figure class="highlight jsx"><figcaption><span>isRequired 사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">&#123; name, children, favoriteNumber &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      제 이름은 &#123;name&#125;입니다. &lt;br /&gt;</span><br><span class="line">      children 값은 &#123;children&#125;입니다. &lt;br /&gt;</span><br><span class="line">      제가 좋아하는 숫자는 &#123;favoriteNumber&#125;입니다.</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  name: "기본 이름",</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  name: PropTypes.string,</span></span><br><span class="line"><span class="regexp">  favoriteNumber: PropTypes.number.isRequired,</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><p>favoriteNumber 값을 설정하지 않고 실행하면 에러가 발생합니다.<br><code>Warnig Failed prop type: The prop &#39;favoriteNumber&#39; is markes as requires in &#39;MyComponent&#39;, but its value is &#39;undefined&#39;.</code></p><p>MyComponent.js에게 favoriteNumber 값을 전달할 App.js에서 값을 전달해 줍니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(...)</span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;MyComponent name=<span class="string">"React"</span> favoriteNumber =&#123;<span class="number">1</span>&#125;&gt;</span><br><span class="line">    리액트</span><br><span class="line">    &lt;<span class="regexp">/MyComponent&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">(...)</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/facebook/prop-types">더 많은 PropTypes 종류 참고: https://github.com/facebook/prop-types</a></li></ul><hr><h3 id="클래스형-컴포넌트에서-props-사용하기"><a href="#클래스형-컴포넌트에서-props-사용하기" class="headerlink" title="클래스형 컴포넌트에서 props 사용하기"></a>클래스형 컴포넌트에서 props 사용하기</h3><p>클래스형 컴포넌트에서 props를 사용할 때는 render 함수에서 <code>this.props</code>를 조회하면 됩니다.</p><p>defaultProps와 propTypes는 똑같은 방식으로 설정할 수 있습니다.</p><figure class="highlight jsx"><figcaption><span>MyComponent 클래스형 컴포넌트로 변환</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, favoriteNumber, children &#125; = <span class="keyword">this</span>.props; <span class="comment">// 비구조화 할당</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        안녕하세요, 제 이름은 &#123;name&#125; 입니다. &lt;br /&gt;</span><br><span class="line">        children 값은 &#123;children&#125;입니다. &lt;br /&gt;</span><br><span class="line">        제가 좋아하는 숫자는 &#123;favoriteNumber&#125;입니다.</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  name: '기본 이름'</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  name: PropTypes.string,</span></span><br><span class="line"><span class="regexp">  favoriteNumber: PropTypes.number.isRequired</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><p><strong>defaultProps와 propTypes을 설정할 때 class 내부에서 지정하는 방법</strong>도 있습니다.</p><figure class="highlight jsx"><figcaption><span>defaultProps, propTypes class 내부에서 지정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123; <span class="comment">// class 내부에서 지정</span></span><br><span class="line">    name: <span class="string">'기본 이름'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    name: PropTypes.string,</span><br><span class="line">    favoriteNumber: PropTypes.number.isRequired</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, favoriteNumber, children &#125; = <span class="keyword">this</span>.props; <span class="comment">// 비구조화 할당</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        안녕하세요, 제 이름은 &#123;name&#125; 입니다. &lt;br /&gt;</span><br><span class="line">        children 값은 &#123;children&#125;입니다. &lt;br /&gt;</span><br><span class="line">        제가 좋아하는 숫자는 &#123;favoriteNumber&#125;입니다.</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default MyComponent;</span></span><br></pre></td></tr></table></figure><hr><h2 id="state">state</h2><p>리액트에서 state는 <strong>컴포넌트 내부에서 바뀔 수 있는 값을 의미합니다.</strong></p><ul><li>참고:<ul><li>props는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값입니다.</li><li>컴포넌트 자신은 props를 읽기 전용으로만 사용할 수 있습니다.</li><li>props를 바꾸려면 부모 컴포넌트에서 바꾸어 주어야 합니다.<br>(예를 들어 App 컴포넌트에서 MyComponent를 사용할 때 props를 바꾸어 주어야 값이 변경될 수 있습니다. MyComponent에서는 전달받은 값을 직접 바꿀 수 없습니다.)</li></ul></li></ul><p><strong>리액트에는 두 가지 종류의 state가 있습니다.</strong></p><ul><li><u>클래스형 컴포넌트가 지니고 있는 state</u></li><li><u>함수형 컴포넌트에서 useState 함수를 통해 사용하는 state</u></li></ul><hr><h3 id="클래스형-컴포넌트의-state"><a href="#클래스형-컴포넌트의-state" class="headerlink" title="클래스형 컴포넌트의 state"></a>클래스형 컴포넌트의 state</h3><figure class="highlight jsx"><figcaption><span>Counter 컴포넌트 만들어 보기 예제</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123; <span class="comment">// 클래스형 컴포넌트에서 constructor를 작성할 때는 반드시</span></span><br><span class="line">    <span class="keyword">super</span>(props); <span class="comment">// super(props)를 호출해 줘야함.</span></span><br><span class="line">    <span class="comment">// state 초기값 설정</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="comment">// 컴포넌트의 state는 객체 형식이어야함.</span></span><br><span class="line">      number = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; number &#125; = <span class="keyword">this</span>.state; <span class="comment">// state 를 조회 할 때에는 this.state 로 조회합니다.</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;number&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button </span></span><br><span class="line"><span class="regexp">          /</span><span class="regexp">/ onClick을 통해 버튼이 클릭되었을 때 호출할 함수를 지정합니다.</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          /</span><span class="regexp">/ this.setState를 사용하여 state에 새로운 값을 넣을 수 있습니다.</span></span><br><span class="line"><span class="regexp">          this.setState(&#123; number: number + 1 &#125;);</span></span><br><span class="line"><span class="regexp">        &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          +1</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Counter;</span></span><br></pre></td></tr></table></figure><ul><li><p>컴포넌트에 state를 설정할 때는 <code>constructor</code>(컴포넌트의 생성자 메서드) 메서드를 작성하여 설정합니다.</p><ul><li><p><strong>클래스형 컴포넌트에서 <code>constructor</code>를 작성할 때는 반드시 <code>super(props)</code>를 호출해 주어야 합니다.</strong></p></li><li><p><strong><code>super(props)</code>함수가 호출되면 현재 클래스형 컴포넌트가 상속받고 있는 리액트의 <code>Component 클래스</code>가 지닌 생성자 함수를 호출해 줍니다.</strong></p></li><li><p>그 다음에 this.state 값에 초기값을 설정해 줬습니다.<br><strong>컴포넌트의 state는 객체 형식이어야 합니다.</strong></p></li></ul></li><li><p>render() 함수에서 현재 state를 조회할 때는 <code>this.state</code>를 조회하면 됩니다.</p></li><li><p>button 안에 props로 넣어준 onClick 값은 버튼이 클릭될 때 호출시킬 함수를 설정할 수 있게 해줍니다. 이를 “이벤트를 설정한다”라고 합니다.</p></li><li><p>이벤트로 설정할 함수를 넣어줄 때는 화살표 함수를 사용해 넣어줍니다.</p></li><li><p>함수 내부에 사용된 <code>this.setState</code> 함수가 <code>state</code>값을 바꿀 수 있게 해 줍니다.</p></li></ul><p>작성된 Counter 컴포넌트를 App에서 불러와 렌더링합니다.</p><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./Counter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><hr><h4 id="state를-constructor에서-꺼내기"><a href="#state를-constructor에서-꺼내기" class="headerlink" title="state를 constructor에서 꺼내기"></a>state를 constructor에서 꺼내기</h4><p><code>constructor</code>메서드를 선언하지 않고도 state 초깃값을 설정할 수 있는 방법이 있습니다.</p><figure class="highlight jsx"><figcaption><span>constructor 메서드 사용 x</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//constructor 선언 안하고 사용</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    number: <span class="number">0</span>,</span><br><span class="line">    fixedNumber: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">(...)</span><br><span class="line"><span class="comment">// constructor 메서드 사용시에는</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123; </span><br><span class="line">    <span class="keyword">super</span>(props); </span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      number = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">(...)</span><br></pre></td></tr></table></figure><p>이렇게 사용하면 constructor 메서드를 선언하지 않고도 state 초깃값을 설정할 수 있습니다.</p><hr><h4 id="this-setState에-객체-대신-함수-인자-전달"><a href="#this-setState에-객체-대신-함수-인자-전달" class="headerlink" title="this.setState에 객체 대신 함수 인자 전달"></a>this.setState에 객체 대신 함수 인자 전달</h4><p>this.setState를 사용하여 state 값을 업데이트할 때는 <u>상태가 비동기적으로 업데이트됩니다.</u></p><figure class="highlight jsx"><figcaption><span>onClick 내부에서 this.setState 두 번 호출</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onClick=&#123;() =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">number</span>: number + <span class="number">1</span>  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">number</span>: <span class="keyword">this</span>.state.number + <span class="number">1</span>  &#125;);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>이 처럼 작성하면 <code>this.setState</code>를 두 번 사용했음에도 버튼을 클릭할 때 숫자가 1씩 더해집니다.</p><p><code>this.setState</code>를 사용할 때 객체 대신에 함수를 인자로 넣어주어야 합니다.</p><figure class="highlight jsx"><figcaption><span>this.setState의 인자로 함수를 넣어주는 형태</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 업데이트할 내용</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>prevState</code>는 기존 상태를 의미하고, <code>props</code>는 현재 지니고 있는 props를 가리킵니다. (업데이트하는 과정에서 props가 필요하지 않다면 생략할 수 있습니다.)</p><p>코드를 수정하여 작성하면 다음과 같이 됩니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(...)</span><br><span class="line">onClick=&#123;() =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      number: prevState.number + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">    number: prevState.number + <span class="number">1</span></span><br><span class="line">  <span class="comment">// 위 코드와 아래 코드는 완전히 똑같은 기능을 하는 코드입니다.</span></span><br><span class="line">  <span class="comment">// 아래 코드는 함수에서 바로 객체를 반환한다는 의미입니다.</span></span><br><span class="line">  &#125;));</span><br><span class="line">(...)</span><br></pre></td></tr></table></figure><p>버튼을 클릭하면 이제 값이 2씩 올라갑니다.</p><hr><h4 id="this-setState가-끝난-후-특정-작업"><a href="#this-setState가-끝난-후-특정-작업" class="headerlink" title="this.setState가 끝난 후 특정 작업"></a>this.setState가 끝난 후 특정 작업</h4><p>setState를 사용하여 값을 업데이트하고 난 다음에 특정 작업을 하고 싶을 때</p><p><strong>setState의 두 번째 파라미터로 콜백(callback)함수를 등록하여 처리할 수 있습니다.</strong></p><figure class="highlight jsx"><figcaption><span>예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">onClick=&#123;() =&gt;&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(</span><br><span class="line">      &#123;</span><br><span class="line">        number: number + <span class="number">1</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 두 번째 파라미터로 콜백 함수 등록</span></span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'방금 setState 가 호출되었습니다.'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="함수형-컴포넌트에서-useState-사용"><a href="#함수형-컴포넌트에서-useState-사용" class="headerlink" title="함수형 컴포넌트에서 useState 사용"></a>함수형 컴포넌트에서 useState 사용</h3><p>리액트 16.8 이전 버전에서는 함수형 컴포넌트에서 state를 사용할 수 없었습니다. 하지만 16.8이후부터는 useState라는 함수를 사용하여 함수형 컴포넌트에서도 state를 사용할 수 있게 되었습니다.</p><p>이 과정에서 <code>Hooks</code>를 사용하게 되는데 <code>Hooks</code>의 종류는 다양하지만 여기서는 <code>useState</code>를 사용합니다.</p><hr><h3 id="useState-사용하기"><a href="#useState-사용하기" class="headerlink" title="useState 사용하기"></a>useState 사용하기</h3><figure class="highlight jsx"><figcaption><span>Say.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Say = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [message, setMessage] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> onClickEnter = <span class="function"><span class="params">()</span> =&gt;</span> setMessage(<span class="string">'안녕하세요!'</span>);</span><br><span class="line">  <span class="keyword">const</span> onClickLeave = <span class="function"><span class="params">()</span> =&gt;</span> setMessage(<span class="string">'안녕히 가세요!'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;onClickEnter&#125;&gt;입장&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;onClickLeave&#125;&gt;퇴장&lt;/</span>button&gt;</span><br><span class="line">      &lt;h1&gt;&#123;message&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Say;</span><br></pre></td></tr></table></figure><ol><li><p><code>useState</code> 함수의 인자에는 상태의 초깃값을 넣어줍니다.(‘’)</p><ul><li><p><strong>클래스형 컴포넌트에서 state 초깃값은 객체 형태로 넣어줘야합니다.</strong></p></li><li><p><strong>useState 에서는 객체가 아니어도 상관없습니다. 값 형태가 자유입니다.</strong></p></li></ul></li><li><p>useState 함수 호출시 배열이 반환됩니다. 배열의 첫 번째 요소는 현재 상태이고, 두 번째 요소는 상태를 바꿔주는 함수입니다. <strong>이 함수를 세터(Setter)함수라고 부릅니다.</strong></p></li></ol><figure class="highlight jsx"><figcaption><span>App.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Say <span class="keyword">from</span> <span class="string">'./Say'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Say</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p><img src="/images/useState0.png" alt=""> <img src="/images/useState1.png" alt=""></p><p>클릭한 입장 버튼과 퇴장버튼에 따라 문구가 변하게 됩니다.</p><hr><h2 id="state_주의사항">state 사용시 주의 사항</h2><p>클래스형 컴포넌트든 함수형 컴포넌트든 state를 사용할 때는 주의해야 할 사항이 있습니다.</p><p><strong>state 값을 바꿔야 할 때는 setState 혹은 useState를 통해 전달받은 세터 함수를 사용해야 합니다.</strong></p><ul><li>배열이나 객체를 업데이트 할 때는<ol><li>사본을 생성하고 </li><li>사본에 값을 업데이트한 후</li><li>그 사본의 상태를 setState 혹은 세터 함수를 통해 업데이트합니다.</li></ol></li></ul><figure class="highlight jsx"><figcaption><span>사본을 만들어 업데이트하는 예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체</span></span><br><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> nextObject = &#123;...object, <span class="attr">b</span> : <span class="number">2</span>&#125;; <span class="comment">// 사본을 만들어 b 값만 덮어씀</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//배열</span></span><br><span class="line"><span class="keyword">const</span> array = &#123;</span><br><span class="line">  &#123; <span class="attr">id</span>:<span class="number">1</span>, <span class="attr">value</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>:<span class="number">2</span>, <span class="attr">value</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>:<span class="number">3</span>, <span class="attr">value</span>: <span class="literal">false</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextArray = array.concat(&#123; <span class="attr">id</span>: <span class="number">4</span> &#125;); <span class="comment">// 새 항목 추가</span></span><br><span class="line">nextArray.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.id !==<span class="number">2</span>); <span class="comment">// id가 2인 항목 제거</span></span><br><span class="line">nextArray.map(<span class="function"><span class="params">item</span> =&gt;</span> (item.id === <span class="number">1</span> ? &#123;...item, <span class="attr">value</span>: <span class="literal">false</span> &#125; : item)); </span><br><span class="line"><span class="comment">//id가 1인 항목의 value를 false로 설정</span></span><br></pre></td></tr></table></figure><ul><li>객체의 사본을 만들 때는 <code>spread</code> 연산자를 사용하여 처리합니다.</li></ul><ul><li>배열의 사본을 만들 때는 배열의 내장 함수들을 활용합니다.</li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/24/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-component/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JSX</title>
      <link>https://hdw0903.github.io/2020/05/22/JSX/</link>
      <guid>https://hdw0903.github.io/2020/05/22/JSX/</guid>
      <pubDate>Fri, 22 May 2020 09:28:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;리액트 컴포넌트에서 사용하는 JSX 문법&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/22/JSX/#JSX&quot;&gt;JSX란?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/22/JSX/#JSX_장점&quot;&gt;JSX의 장점&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/22/JSX/#JSX_문법&quot;&gt;JSX 문법&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;감싸인 요소&lt;/li&gt;
&lt;li&gt;자바스크립트 표현&lt;/li&gt;
&lt;li&gt;if 문 대신 조건부 연산자(삼항 연산자)&lt;/li&gt;
&lt;li&gt;AND 연산자(&amp;amp;&amp;amp;)를 사용한 조건부 렌더링&lt;/li&gt;
&lt;li&gt;undefined를 렌더링하지 않기&lt;/li&gt;
&lt;li&gt;인라인 스타일링&lt;/li&gt;
&lt;li&gt;class 대신 className&lt;/li&gt;
&lt;li&gt;꼭 닫아야 하는 태그&lt;/li&gt;
&lt;li&gt;주석&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>리액트 컴포넌트에서 사용하는 JSX 문법</p><ul><li><p><a href="/2020/05/22/JSX/#JSX">JSX란?</a></p></li><li><p><a href="/2020/05/22/JSX/#JSX_장점">JSX의 장점</a></p></li><li><p><a href="/2020/05/22/JSX/#JSX_문법">JSX 문법</a></p><ul><li>감싸인 요소</li><li>자바스크립트 표현</li><li>if 문 대신 조건부 연산자(삼항 연산자)</li><li>AND 연산자(&amp;&amp;)를 사용한 조건부 렌더링</li><li>undefined를 렌더링하지 않기</li><li>인라인 스타일링</li><li>class 대신 className</li><li>꼭 닫아야 하는 태그</li><li>주석</li></ul></li></ul><a id="more"></a><hr><h2 id="JSX">JSX란?</h2><p>JSX는 자바스크립트의 확장 문법이며 XML과 매우 비슷하게 생겼습니다.<br>이런 형식으로 작성한 코드는 브라우저에서 실행되기 전에 코드가 번들링되는 과정에서 바벨을 사용하여 일반 자바스크립트 형태의 코드로 변환됩니다.</p><figure class="highlight jsx"><figcaption><span>형태</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Hello &lt;b&gt;react&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 작성된 코드는 다음과 같이 변환됩니다.</p><figure class="highlight js"><figcaption><span>일반(ES5) 자바스크립트 형태의 코드로 변환</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">APP</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.creatElement(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="string">"Hello "</span>, React.creatElement(<span class="string">"b"</span>, <span class="literal">null</span>, <span class="string">"react"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 처럼 매번 <code>React.creatElement</code> 함수를 사용해야 한다면 불편할 것입니다.<br>JSX를 사용하여 더욱 편하게 UI를 렌더링할 수 있습니다.</p><hr><h2 id="JSX_장점">JSX의 장점</h2><ul><li>보기 쉽고 익숙함.<br>위의 자바스크립트를 사용한 코드와 JSX로 작성한 코드를 비교해 보면<br>JSX로 작성한 코드는 HTML과 비슷하므로 가독성이 높고 작성하기도 쉽습니다.</li></ul><ul><li>더욱 높은 활용도<br>JSX에서는 HTML 태그를 사용할 수 있을 뿐만 아니라, 앞으로 만들 컴포넌트도 JSX 안에서 작성할 수 있습니다.<br>컴포넌트를 마치 HTML 태그 쓰듯 그냥 작성합니다.</li></ul><figure class="highlight jsx"><figcaption><span>예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> serviceWorker <span class="keyword">from</span> <span class="string">'./serviceWorker'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line">serviceWorker.unregister();</span><br></pre></td></tr></table></figure><ul><li><p>참고: ReactDOM.render<br>이 코드는 컴포넌트를 페이지에 렌더링하는 역활을 하며, render-dom 모듈을 불러와 사용할 수 있습니다.<br>이 함수의 <strong>첫 번째 파라미터에는 페이지에 렌더링할 내용을 JSX형태로 작성</strong>하고, <strong>두 번째 파라미터에는 해당 JSX를 렌더링할 document 내부 요소를 설정합니다.</strong></p><p>여기서는 id가 root인 요소 안에 렌더링하게 설정된 것입니다.</p></li></ul><hr><h2 id="JSX_문법">JSX 문법</h2><p>JSX를 올바르게 사용하려면 몇 가지 규칙을 준수해야 합니다.</p><hr><h3 id="감싸인-요소"><a href="#감싸인-요소" class="headerlink" title="감싸인 요소"></a>감싸인 요소</h3><p><strong>컴포넌트에 여러 요소가 있다면 반드시 부모 요소 하나로 감싸야 합니다.</strong></p><figure class="highlight jsx"><figcaption><span>요소 여러 개가 부모요소로 감싸져 있지 않다면 오류 발생</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;리액트 안녕&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;잘 작동하니?&lt;/</span>h2&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p><strong>요소 여러 개가 부모 요소 하나에 의하여 감싸져 있지 않으면 오류가 발생합니다.</strong></p><ul><li>이런 오류가 나는 이유는 <strong>Virtual DOM에서 컴포넌트 변화를 감지할 때 효율적으로 비교할 수 있도록 리액트 컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져야 한다는 규칙이 있기 때문입니다.</strong>  </li></ul><figure class="highlight jsx"><figcaption><span>div로 감싼 해결법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;리액트 안녕&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;잘 작동하니?&lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>이렇듯 요소를 <code>div</code>태그로 감싸주면 에러를 해결할 수 있습니다.<br>하지만 <code>div</code>태그를 사용하고 싶지 않은 경우에는 리액트 v16 이상 부터 도입된 <code>Fragment</code> 기능을 사용하면 됩니다.</p><figure class="highlight jsx"><figcaption><span>Fragment 사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;h1&gt;리액트 안녕&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;잘 작동하니?&lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>코드 상단 <code>import</code>구문에서 <code>react</code> 모듈에 들어 있는 <code>Fragment</code>라는 컴포넌트를 추가로 불러옵니다.<br><code>Fragment</code>는 다음과 같은 형태로도 표현할 수 있습니다.</p><figure class="highlight jsx"><figcaption><span>Fragment 생략</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;리액트 안녕&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;잘 작동하니?&lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>위 예시 모두 정상적으로 작동하는 경우는 다음과 같은 화면이 브라우저에 출력될 것입니다.</p><p><img src="/images/React_app.png" alt="정상 작동 결과물"></p><hr><h3 id="자바스크립트-표현"><a href="#자바스크립트-표현" class="headerlink" title="자바스크립트 표현"></a>자바스크립트 표현</h3><p>JSX 안에서는 자바스크립트 표현식을 쓸 수 있습니다.<br>자바스크립트 표현식을 작성하려면 JSX 내부에서 코드를 중괄호{}로 감싸면 됩니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;name&#125; 안녕&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;잘 작동하니?&lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p><code>const name= &quot;리액트&quot;;</code>로 선언해주고 중괄호{}안에 <code>name</code>을 작성하여 표현식으로 사용했습니다.</p><hr><h3 id="if-문-대신-조건부-연산자-삼항-연산자"><a href="#if-문-대신-조건부-연산자-삼항-연산자" class="headerlink" title="if 문 대신 조건부 연산자(삼항 연산자)"></a>if 문 대신 조건부 연산자(삼항 연산자)</h3><p><strong>JSX 내부의 자바스크립트 표현식에서 if 문을 사용할 수 없습니다.</strong></p><p>따라서 조건에 따라 다른 내용을 렌더링해야 할 때는 </p><ul><li><p>JSX 밖에서 if 문을 사용하여 사전에 값을 설정하거나</p></li><li><p>{ } 안에 조건부 연산자를 사용하면 됩니다. (조건부 연산자 === 삼항 연산자)</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;name === <span class="string">"리액트"</span> ?(</span><br><span class="line">        &lt;h1&gt;리액트입니다.&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      ):(</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;리액트가 아닙니다.&lt;/</span>h2&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>이렇게 코드를 작성한 후 저장하면 브라우저에서 ‘리액트입니다.’라는 문구를 볼 수 있습니다.</p><p>여기서 <code>name</code> 값을 바꾸면(!===리액트) ‘리액트가 아닙니다.’ 문구가 나타날 것입니다.</p><hr><h3 id="AND-연산자-amp-amp-를-사용한-조건부-렌더링"><a href="#AND-연산자-amp-amp-를-사용한-조건부-렌더링" class="headerlink" title="AND 연산자(&amp;&amp;)를 사용한 조건부 렌더링"></a>AND 연산자(&amp;&amp;)를 사용한 조건부 렌더링</h3><p>특정 조건을 만족할 때 내용을 보여주고, 만족하지 않을 때는 아무것도 렌더링 하지 않고자 할 때 사용하는 법</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;name === "리액트" &amp;&amp; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>리액트입니다.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>물론 삼항 연산자로 <code>{name === &quot;리액트&quot; ? &lt;h1&gt;리액트입니다.&lt;/h1&gt; : null}</code> 형태로 작성할 수도 있지만<br>&amp;&amp; 연산자로는 예제 처럼 더 짧은 코드로 작업할 수 있습니다.</p><ul><li>&amp;&amp; 연산자로 조건부 렌더링을 할 수 있는 이유는 <strong>리액트에서 false를 렌더링할 때는 null과 마찬가지로 아무것도 나타나지 않기 때문입니다.</strong></li></ul><ul><li>한가지 주의할 점은 0값은 예외적으로 화면에 나타난다는 것입니다.</li></ul><hr><h3 id="undefined를-렌더링하지-않기"><a href="#undefined를-렌더링하지-않기" class="headerlink" title="undefined를 렌더링하지 않기"></a>undefined를 렌더링하지 않기</h3><p>리액트 컴포넌트에서는 함수에서 undefined만 반환하여 렌더링 하는 상황을 만들면 안 됩니다.</p><p>다음과 같은 코드는 오류를 발생시킵니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"><span class="comment">// App(...): Nothing was returned from render. ......</span></span><br></pre></td></tr></table></figure><p>값이 undefined일 수도 있다면 OR(||)연산자를 사용하면 해당 값이 undefined일 때 사용할 값을 지정해 줄 수 있으므로 간단히 오류를 방지할 수 있습니다.</p><p><code>return name;</code> &gt; <code>return name || &quot;값이 undefined입니다&quot;;</code></p><ul><li><strong>반면 JSX 내부에서 undefined를 렌더링하는 것은 괜찮습니다.</strong></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><hr><h3 id="인라인-스타일링"><a href="#인라인-스타일링" class="headerlink" title="인라인 스타일링"></a>인라인 스타일링</h3><p>리액트에서 DOM 요소에 스타일을 적용할 때는 객체 형태로 넣어 주어야 합니다.<br>스타일 이름 중에 background-color 처럼 하이픈(-) 문자가 포함되어 있는 경우<br>카멜 표기법(camelCase)으로 작성합니다. backgroundColor</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">const</span> style = &#123;</span><br><span class="line">    backgroundColor: <span class="string">"black"</span>, <span class="comment">// background-color -&gt; backgroundColor</span></span><br><span class="line">    color: <span class="string">"aqua"</span>,</span><br><span class="line">    fontSize: <span class="string">"48px"</span>, <span class="comment">// font-size -&gt; fontSize</span></span><br><span class="line">    fontWeight: <span class="string">"bold"</span>, <span class="comment">// font-weight -&gt; fontWeight</span></span><br><span class="line">    padding: <span class="number">16</span> <span class="comment">// 단위 생략시 px로 지정됨</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>style 객체를 미리 선언하고 div의 style 값으로 지정해 주었습니다.<br>만약 미리 선언하지 않고 div에 style 값을 바로 지정하고 싶다면 아래와 같이 작성합니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div</span><br><span class="line">      style=&#123;&#123;</span><br><span class="line">        backgroundColor: <span class="string">"black"</span>, <span class="comment">// background-color -&gt; backgroundColor</span></span><br><span class="line">        color: <span class="string">"aqua"</span>,</span><br><span class="line">        fontSize: <span class="string">"48px"</span>, <span class="comment">// font-size -&gt; fontSize</span></span><br><span class="line">        fontWeight: <span class="string">"bold"</span>, <span class="comment">// font-weight -&gt; fontWeight</span></span><br><span class="line">        padding: <span class="number">16</span>, <span class="comment">// 단위 생략시 px로 지정됨</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;name&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p><img src="/images/divStyle.png" alt="결과물"></p><hr><h3 id="class-대신-className"><a href="#class-대신-className" class="headerlink" title="class 대신 className"></a>class 대신 className</h3><p>일반 HTML에서 CSS 클래스를 사용할 때는 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"myclass"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>와 같이 class라는 속성을 설정합니다.</p><p><strong>하지만 JSX에서는 class가 아닌 className으로 설정해 줘야합니다.</strong></p><ul><li>우선 App.css 파일을 열어 새 css 클래스를 작성해줬습니다.</li></ul><figure class="highlight css"><figcaption><span>App.css</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.react</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: aqua;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>이제 App.js 파일에서 상단에 App.css를 불러온 뒤 div 요소에 className값을 지정해줍니다.</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./App.css"</span>; <span class="comment">// CSS 불러옴</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"react"</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>; <span class="comment">// class가 아닌 className</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><ul><li><p>결과물<br><img src="/images/JSX4.png" alt="결과물"></p></li><li><p>JSX를 작성할 때 CSS 클래스를 설정하는 과정에서 <strong>className이 아닌 class 값을 설정해도 스타일이 적용되지만 브라우저 개발자 도구에서 경고가 나타납니다.</strong><br><img src="/images/Warningclass.png" alt="className이 아닌 class값 설정시"></p></li></ul><p><del>이전에는 오류만 발생하고 CSS 클래스가 적용되지 않았지만,</del><br><u>리액트 v16 이상부터는 class를 className으로 변환시켜 주고 경고를 띄웁니다.</u></p><hr><h3 id="꼭-닫아야-하는-태그"><a href="#꼭-닫아야-하는-태그" class="headerlink" title="꼭 닫아야 하는 태그"></a>꼭 닫아야 하는 태그</h3><p>HTML 코드를 작성할 때는 닫지 않는 상태로 코드를 작성하기도 합니다.<br>ex) <code>&lt;input&gt;&lt;/input&gt;</code>으로 입력하지 않고 <code>&lt;input&gt;</code></p><p><strong>JSX에서는 태그를 닫지 않으면 오류가 발생합니다.</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./App.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">"리액트"</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div className=<span class="string">"react"</span>&gt;&#123;name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input&gt; </span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>이러한 닫혀있지 않은 태그(input)는 <code>&lt;input&gt;&lt;/input&gt;</code> 이나 <code>&lt;input /&gt;</code> 형태로 닫아줘야 합니다.</p><hr><h3 id="주석"><a href="#주석" class="headerlink" title="주석"></a>주석</h3><p>JSX 안에서 주석을 작성하는 방법은 일반 자바스크립트에서 주석을 작성하는 방법과 조금 다릅니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">'리액트'</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;<span class="comment">/* 주석은 이렇게 작성합니다. */</span>&#125;</span><br><span class="line">      &lt;div</span><br><span class="line">        className=<span class="string">"react"</span> <span class="comment">// 시작 태그를 여러 줄로 작성하게 된다면 여기에 주석을 작성 할 수 있습니다.</span></span><br><span class="line">      &gt;</span><br><span class="line">        &#123;name&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 하지만 이런 주석이나 </span></span><br><span class="line"><span class="regexp">      /</span>* 이런 주석은 페이지에 그대로 나타나게 됩니다. *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">      &lt;input /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><ul><li>JSX 내부에서 주석을 작성할 때는 {/* … */}와 같은 형식으로 작성합니다.</li></ul><ul><li>시작 태그를 여러 줄로 작성할 때는 그 내부에서 //…과 같은 형태의 주석도 작성할 수 있습니다.</li></ul><ul><li>일반 자바스크립트에서 주석을 작성할 때처럼 아무 데나 주석을 작성하면 페이지에 고스란히 나타납니다.</li></ul><ul><li>브라우저 창에 출력시<br><img src="/images/React_%EC%A3%BC%EC%84%9D.png" alt="React 주석"></li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/22/JSX/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 이해, 특징</title>
      <link>https://hdw0903.github.io/2020/05/21/React-%EC%9D%B4%ED%95%B4-%ED%8A%B9%EC%A7%95/</link>
      <guid>https://hdw0903.github.io/2020/05/21/React-%EC%9D%B4%ED%95%B4-%ED%8A%B9%EC%A7%95/</guid>
      <pubDate>Thu, 21 May 2020 13:12:41 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;리액트-기초&quot;&gt;&lt;a href=&quot;#리액트-기초&quot; class=&quot;headerlink&quot; title=&quot;리액트 기초&quot;&gt;&lt;/a&gt;리액트 기초&lt;/h2&gt;&lt;p&gt;리액트는 페이스북 개발 팀이 만든 자바스크립트 라이브러리입니다.&lt;/p&gt;
&lt;p&gt;기존의 어떤 데이터가 변할 때마다 어떤 변화를 주는 방식이 아닌 기존 뷰를 날려 버리고 새로 렌더링하는 방식입니다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="리액트-기초"><a href="#리액트-기초" class="headerlink" title="리액트 기초"></a>리액트 기초</h2><p>리액트는 페이스북 개발 팀이 만든 자바스크립트 라이브러리입니다.</p><p>기존의 어떤 데이터가 변할 때마다 어떤 변화를 주는 방식이 아닌 기존 뷰를 날려 버리고 새로 렌더링하는 방식입니다.</p><a id="more"></a><hr><h3 id="리액트-이해"><a href="#리액트-이해" class="headerlink" title="리액트 이해"></a>리액트 이해</h3><p>리액트는 자바스크립트 라이브러리로 사용자 인터페이스를 만드는 데 사용합니다.</p><p>구조가 MVC(Model-View-Controller), MVW(Model-View-Whatever) 등인 프레임워크와 달리,</p><p><strong>오직 V(View)만 신경 쓰는 라이브러리입니다.</strong></p><hr><h4 id="컴포넌트-component"><a href="#컴포넌트-component" class="headerlink" title="컴포넌트(component)"></a>컴포넌트(component)</h4><p>리액트 프로젝트에는 <strong>특정 부분이 어떻게 생길지 정하는 선언체가 있는데, 이를 컴포넌트(component)라고 합니다.</strong></p><p>컴포넌트는 다른 프레임워크에서 사용자 인터페이스를 다룰 때 사용하는 템플릿과는 다른 개념입니다.<br>템플릿은 보통 데이터셋이 주어지면 HTML 태그 형식을 문자열로 반환하는데,</p><p>컴포넌트는 재사용이 가능한 API로 수만은 기능을 내장하고 있고, 컴포넌트 하나에서 해당 컴포넌트의 생김새와 작동 방식을 정의합니다. </p><hr><h4 id="렌더링-rendering"><a href="#렌더링-rendering" class="headerlink" title="렌더링(rendering)"></a>렌더링(rendering)</h4><p><strong>사용자 화면에 뷰를 보여주는 것을 렌더링이라고 합니다.</strong></p><p>리액트 라이브러리는 데이터가 변할 때마다 새롭게 리렌더링 하면서도 성능을 아끼는 렌더링 방식을 사용하는데 이를 이해하려면 </p><ul><li><p><strong>리액트 컴포넌트가 최초로 실행한 “초기 렌더링”</strong>과 </p></li><li><p><strong>컴포넌트의 데이터 변경으로 다시 실행되는 “리렌더링”</strong>을 이해해야 합니다.</p></li></ul><hr><h4 id="초기-렌더링"><a href="#초기-렌더링" class="headerlink" title="초기 렌더링"></a>초기 렌더링</h4><p>어떤 UI 관련 프레임워크, 라이브러리를 사용하든지 맨 처음 어떻게 보일지를 정하는 초기 렌더링이 필요합니다.</p><p>리액트에서는 이를 다루는 <code>render</code> 함수가 있습니다.</p><blockquote><p>render() {…}</p></blockquote><ul><li><code>render()</code> 함수는 <strong>컴포넌트가 어떻게 생겼는지 정의하는 역활</strong>을 합니다.</li></ul><ul><li><code>render()</code> 함수는 HTML 형식의 문자열을 반환하는 것이 아닌 <strong>뷰가 어떻게 생겼고 어떻게 작동하는지에 대한 정보를 지닌 객체를 반환합니다.</strong></li></ul><hr><h4 id="조화-과정"><a href="#조화-과정" class="headerlink" title="조화 과정"></a>조화 과정</h4><p>리액트에서 뷰를 업데이트할 때는 “업데이트 과정을 거친다”라고 하기보다 “조화 과정(reconsiliation)을 거친다”라고 합니다.</p><p><strong>컴포넌트에서 데이터에 변화가 있을 때 변화에 따라 뷰가 변형되는 것처럼 보이지만, 사실은 새로운 요소로 갈아 끼우기 때문입니다.</strong></p><p>이 작업 또한 render 함수가 맡아서 합니다.<br>컴포넌트는 데이터를 업데이트했을 때 업데이트한 값을 수정하는 것이 아니라, 새로운 데이터를 가지고 render 함수를 또다시 호출합니다.</p><p>이 작업에서 render 함수가 반환하는 결과를 곧바로 DOM에 반영하지 않고<br><strong>이전에 render 함수가 만들었던 컴포넌트 정보와 현재 render 함수가 만든 컴포넌트 정보를 비교합니다.</strong></p><hr><h3 id="리액트-특징"><a href="#리액트-특징" class="headerlink" title="리액트 특징"></a>리액트 특징</h3><p>리액트의 주요 특징 중 하나는 Virtual DOM을 사용하는 것입니다.</p><hr><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>DOM(Document Object Model)은 문자 그대로 문서 객체 모델입니다. </p><p>객체로 문서 구조를 표현하는 방법으로 XML이나 HTML로 작성합니다.</p><p><strong>DOM은 트리 구조</strong>이므로 특정 노드를 찾거나, 수정, 제거, 원하는 곳에 삽입할 수 있습니다.</p><p><img src="/images/DOM.png" alt="DOM 트리"></p><p>웹에서 DOM에 변화가 일어나면 웹 브라우저는 CSS를 다시 연산하고, 레이아웃을 구성하고, 페이지를 리페인트하게 되고 성능 저하가 일어날 수 있습니다.</p><p>이러한 DOM을 최소한으로 조작하여 처리하는 방식으로 나온 방법이 <code>Virtual DOM</code>입니다.</p><hr><h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p>리액트는 Virtual DOM 방식을 사용하여 실제 DOM에 접근하여 조작하는 대신 <strong>DOM 업데이트를 추상화한 자바스크립트 객체를 구성하여 사용함으로써 DOM 처리 횟수를 최소화하고 효율적으로 진행합니다.</strong></p><ul><li><p>리액트에서 데이터가 변하여 웹 브라우저에 실제 DOM을 업데이트를할 때는 다음 3가지 과정을 거칩니다.</p><ol><li><p>데이터를 업데이트하면 전체 UI를 Virtual DOM에 리렌더링합니다.</p></li><li><p>이전 Virtual DOM에 있던 내용과 현제 내용을 비교합니다.</p></li><li><p>바뀐 부분만 실제 DOM에 적용합니다.</p></li></ol></li></ul><p><img src="/images/VirtualDOM.png" alt="이전 DOM 트리, 새로운 DOM 트리"></p><p>오른쪽의 “새로운 DOM 트리”가 바로 <code>Virtual DOM</code>입니다.</p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/21/React-%EC%9D%B4%ED%95%B4-%ED%8A%B9%EC%A7%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>VS Code Extension Prettier 설치와 예외 처리</title>
      <link>https://hdw0903.github.io/2020/05/21/VS-Code-Extension-Prettier-%EC%84%A4%EC%B9%98%EC%99%80-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC/</link>
      <guid>https://hdw0903.github.io/2020/05/21/VS-Code-Extension-Prettier-%EC%84%A4%EC%B9%98%EC%99%80-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC/</guid>
      <pubDate>Thu, 21 May 2020 12:13:56 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;Prettier-란&quot;&gt;&lt;a href=&quot;#Prettier-란&quot; class=&quot;headerlink&quot; title=&quot;Prettier 란?&quot;&gt;&lt;/a&gt;Prettier 란?&lt;/h3&gt;&lt;p&gt;VS Code Extension 중의 하나인 Prettier는 코드 스타일을 자동으로 정리해주는 도구입니다.&lt;/p&gt;
&lt;p&gt;들여쓰기(공백 문자), 세미콜론(;)이 빠진곳, 작은따옴표(‘’)등을 자동으로 추가 및 변경해줍니다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="Prettier-란"><a href="#Prettier-란" class="headerlink" title="Prettier 란?"></a>Prettier 란?</h3><p>VS Code Extension 중의 하나인 Prettier는 코드 스타일을 자동으로 정리해주는 도구입니다.</p><p>들여쓰기(공백 문자), 세미콜론(;)이 빠진곳, 작은따옴표(‘’)등을 자동으로 추가 및 변경해줍니다.</p><a id="more"></a><hr><h3 id="Prettier-설치"><a href="#Prettier-설치" class="headerlink" title="Prettier 설치"></a>Prettier 설치</h3><p>VS Code 마켓플레이스에서 Prettier를 검색하여 설치해 줍니다.</p><p><img src="/images/Prettier.png" alt="Prettier"></p><p>설치 후 정리를 원하는 파일에서 F1을 누르고 format을 입력한다음 엔터를 누르면 Prettier가 자동으로 코드를 정리해 줍니다.</p><hr><h4 id="저장할-때-자동으로-코드-정리하기"><a href="#저장할-때-자동으로-코드-정리하기" class="headerlink" title="저장할 때 자동으로 코드 정리하기"></a>저장할 때 자동으로 코드 정리하기</h4><p>매번 F1을 눌러 format을 입력하거나 단축키를 이용해 정리하는 것보다 편한 저장할 때 정리하게 만드는 법이 있습니다.</p><p>VS Code의 설정에 들어가 format on save를 검색하여 체크 박스를 체크해주면 됩니다.</p><p><img src="/images/Prettier_OnSave.png" alt="Prettier 저장할 때 자동으로 코드 정리"></p><hr><h3 id="Prettier-예외-설정"><a href="#Prettier-예외-설정" class="headerlink" title="Prettier 예외 설정"></a>Prettier 예외 설정</h3><p>편하게 사용하려고 format on save 설정을 켜놨더니 원치 않은 경우에도 적용되어 곤란해졌습니다.</p><p>저의 경우에는 블로그 작성시 사용하는 MarkDown(.md)파일들의 공백이 원치 않게 변경되어 예외 처리가 필요해졌습니다.</p><ul><li>예외 처리</li></ul><p>예외 처리할 폴더의 root 폴더에 .prettierignore 파일을 만들어 줍니다.<br>저의 경우 <code>..\..\myblog\source\_posts</code> 경로와 <code>..\..\myblog\scaffolds</code> 경로의 .md 파일들을 예외 처리 하기위해 myblog 내부에 .prettierignore 파일을 만들었습니다.</p><p>.prettierignore 파일 안에 *.md를 작성하면 끝입니다.</p><p><img src="/images/prettierignore.png" alt="Prettier MarkDown예외 설정"></p><p>이제 더이상 Prettier가 MarkDown 파일을 변경하지 않습니다.</p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/21/VS-Code-Extension-Prettier-%EC%84%A4%EC%B9%98%EC%99%80-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC/#disqus_thread</comments>
    </item>
    
    <item>
      <title>VS Code 유용한 Extension -ESLint</title>
      <link>https://hdw0903.github.io/2020/05/21/VS-Code-%EC%9C%A0%EC%9A%A9%ED%95%9C-Extension-ESLint/</link>
      <guid>https://hdw0903.github.io/2020/05/21/VS-Code-%EC%9C%A0%EC%9A%A9%ED%95%9C-Extension-ESLint/</guid>
      <pubDate>Thu, 21 May 2020 11:39:03 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;ESLint란&quot;&gt;&lt;a href=&quot;#ESLint란&quot; class=&quot;headerlink&quot; title=&quot;ESLint란?&quot;&gt;&lt;/a&gt;ESLint란?&lt;/h3&gt;&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt; 문법 검사 도구로 사용자가 직접 정의한대로 코드를 점검하고, 에러가 있으면 표시해줍니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;에디터에 &lt;span style=&quot;color: green;&quot;&gt;초록색&lt;/span&gt;으로 줄이 그어진 코드는 고치기 싫으면 무시할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;하지만 &lt;span style= &quot;color: red;&quot;&gt;빨간색&lt;/span&gt; 줄이 그어진 코드는 반드시 고쳐야합니다.&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="ESLint란"><a href="#ESLint란" class="headerlink" title="ESLint란?"></a>ESLint란?</h3><p><code>JavaScript</code> 문법 검사 도구로 사용자가 직접 정의한대로 코드를 점검하고, 에러가 있으면 표시해줍니다.</p><ul><li>에디터에 <span style="color: green;">초록색</span>으로 줄이 그어진 코드는 고치기 싫으면 무시할 수 있습니다.</li></ul><ul><li>하지만 <span style= "color: red;">빨간색</span> 줄이 그어진 코드는 반드시 고쳐야합니다.</li></ul><a id="more"></a><hr><h3 id="ESLint-설치"><a href="#ESLint-설치" class="headerlink" title="ESLint 설치"></a>ESLint 설치</h3><p>VS Code 마켓플레이스 에서 ESLint를 검색하여 설치해 줍니다.</p><p><img src="/images/ESLint.png" alt="ESLint"></p><ul><li>설치 후 에디터를 재실행하고 나면 JavaScript 문법을 점검하여 오류가 있으면 알려줍니다.</li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/21/VS-Code-%EC%9C%A0%EC%9A%A9%ED%95%9C-Extension-ESLint/#disqus_thread</comments>
    </item>
    
    <item>
      <title>VS Code 터미널 관리자모드로 실행</title>
      <link>https://hdw0903.github.io/2020/05/21/VS-Code-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%B4%80%EB%A6%AC%EC%9E%90%EB%AA%A8%EB%93%9C%EB%A1%9C-%EC%8B%A4%ED%96%89/</link>
      <guid>https://hdw0903.github.io/2020/05/21/VS-Code-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%B4%80%EB%A6%AC%EC%9E%90%EB%AA%A8%EB%93%9C%EB%A1%9C-%EC%8B%A4%ED%96%89/</guid>
      <pubDate>Thu, 21 May 2020 11:21:07 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;이-시스템에서-스크립트를-실행할-수-없으므로-해결법&quot;&gt;&lt;a href=&quot;#이-시스템에서-스크립트를-실행할-수-없으므로-해결법&quot; class=&quot;headerlink&quot; title=&quot;이 시스템에서 스크립트를 실행할 수 없으므로 해결법&quot;&gt;&lt;/a&gt;이 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="이-시스템에서-스크립트를-실행할-수-없으므로-해결법"><a href="#이-시스템에서-스크립트를-실행할-수-없으므로-해결법" class="headerlink" title="이 시스템에서 스크립트를 실행할 수 없으므로 해결법"></a>이 시스템에서 스크립트를 실행할 수 없으므로 해결법</h3><p>VSCode 의 터미널(Terminal)로 Hexo server등을 실행하면<br>이 시스템에서 스크립트를 실행할 수 없으므로 어쩌구 저쩌구 오류가 나온다.</p><ol><li>windows PowerShell 프로그램을 관리자 권한으로 실행한다.</li></ol><ol start="2"><li>Set-ExecutionPolicy RemoteSigned 입력후 엔터</li></ol><p><img src="/images/powerShell.png" alt="스크립트 실행 규칙 변경"></p><ol start="3"><li>y 엔터</li></ol><p>이제 VS Code로 돌아가 터미널에서 실행해보면 잘 작동한다.</p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/21/VS-Code-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%B4%80%EB%A6%AC%EC%9E%90%EB%AA%A8%EB%93%9C%EB%A1%9C-%EC%8B%A4%ED%96%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>VS Code 단축키 변경, 자동 저장 기능</title>
      <link>https://hdw0903.github.io/2020/05/21/VS-Code-%EB%8B%A8%EC%B6%95%ED%82%A4-%EB%B3%80%EA%B2%BD-%EC%9E%90%EB%8F%99-%EC%A0%80%EC%9E%A5-%EA%B8%B0%EB%8A%A5/</link>
      <guid>https://hdw0903.github.io/2020/05/21/VS-Code-%EB%8B%A8%EC%B6%95%ED%82%A4-%EB%B3%80%EA%B2%BD-%EC%9E%90%EB%8F%99-%EC%A0%80%EC%9E%A5-%EA%B8%B0%EB%8A%A5/</guid>
      <pubDate>Thu, 21 May 2020 11:00:28 GMT</pubDate>
      <description>
      
        &lt;p&gt;VS Code의 제안 기능? (Ctrl +Space) 단축키가 불편하여 변경했다.&lt;/p&gt;
&lt;p&gt;추가로 자동 저장 기능도 설정한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>VS Code의 제안 기능? (Ctrl +Space) 단축키가 불편하여 변경했다.</p><p>추가로 자동 저장 기능도 설정한다.</p><a id="more"></a><hr><h3 id="단축키-설정"><a href="#단축키-설정" class="headerlink" title="단축키 설정"></a>단축키 설정</h3><p>단축키 설정은 <img src="/images/%EB%8B%A8%EC%B6%95%ED%82%A4.png" alt="VS Code 단축키 설정"></p><p>VS Code 에디터 좌측 하단 톱니바퀴를 누르거나 Ctrl+k Ctrl+S로 들어갈 수 있다.</p><p>내가 변경 하고자한 단축키의 이름은 제안 항목 트리거 라고 한다..</p><p><img src="/images/%EC%A0%9C%EC%95%88%ED%95%AD%EB%AA%A9%ED%8A%B8%EB%A6%AC%EA%B1%B0.png" alt="제안 항목 트리거 단축키 변경"></p><p>단축키 부분을 더블 클릭하여 기존의 Ctrl + Space를 Shift + 2로 변경해 줬다.<br>새끼 손가락이 덜아파 행복하다.</p><p><del>특수문자 @를 쓸때마다 아주 곤란하다… 하지만 자주 쓸일이 없으니 대충 쓴다.</del></p><hr><h3 id="VS-Code-자동-저장-기능"><a href="#VS-Code-자동-저장-기능" class="headerlink" title="VS Code 자동 저장 기능"></a>VS Code 자동 저장 기능</h3><p>한번 설정해 놓으면 아주 편한 자동 저장 기능</p><p>이제 매번 Ctrl + S로 저장해줄 필요가 없다.</p><p>마찬가지로 VS Code 에디터에서 톱니바퀴를 누르고 이번에는 <code>설정</code>으로 들어간다.</p><p><img src="/images/autoSave.png" alt="AutoSave"></p><ul><li><p>일반적으로 사용되는 설정 &gt; onFocusChange 항목에서 원하는 항목으로 설정한다.<br><del>개인적으로 onFocusChage가 편해서 사용중</del></p></li><li><p>Auto Save Delay<br>afterDelay로 설정시 지연시간 (ms) 설정</p></li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/21/VS-Code-%EB%8B%A8%EC%B6%95%ED%82%A4-%EB%B3%80%EA%B2%BD-%EC%9E%90%EB%8F%99-%EC%A0%80%EC%9E%A5-%EA%B8%B0%EB%8A%A5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>VS Code 한글 설정</title>
      <link>https://hdw0903.github.io/2020/05/21/VS-Code-%ED%95%9C%EA%B8%80-%EC%84%A4%EC%A0%95/</link>
      <guid>https://hdw0903.github.io/2020/05/21/VS-Code-%ED%95%9C%EA%B8%80-%EC%84%A4%EC%A0%95/</guid>
      <pubDate>Thu, 21 May 2020 10:08:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;VS-Code-언어-한국어로-설정하기&quot;&gt;&lt;a href=&quot;#VS-Code-언어-한국어로-설정하기&quot; class=&quot;headerlink&quot; title=&quot;VS Code 언어 한국어로 설정하기&quot;&gt;&lt;/a&gt;VS Code 언어 한국어로 설정하기&lt;/h3&gt;&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="VS-Code-언어-한국어로-설정하기"><a href="#VS-Code-언어-한국어로-설정하기" class="headerlink" title="VS Code 언어 한국어로 설정하기"></a>VS Code 언어 한국어로 설정하기</h3><p>VS Code를 열어 좌측에 확장 마켓플레이스를 클릭해 줍니다.</p><p><img src="/images/market.png" alt="VS Code 마켓플레이스"></p><p>Korean Language Pack for Visual Studio Code를 검색하여 설치합니다.</p><p><img src="/images/Language_Pack.png" alt="Korean Language Pack for Visual Studio Code"></p><p>설치 후 F1을 누른 후 Configure Display Language를 입력하여 “ko” 값으로 설정 후 재시작 해주면 끝</p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/21/VS-Code-%ED%95%9C%EA%B8%80-%EC%84%A4%EC%A0%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Array.prototype. map, filter, reduce 구현하기</title>
      <link>https://hdw0903.github.io/2020/05/19/Array-prototype-map-filter-reduce-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/</link>
      <guid>https://hdw0903.github.io/2020/05/19/Array-prototype-map-filter-reduce-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Tue, 19 May 2020 12:53:01 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;code&gt;React&lt;/code&gt; 입문전에 &lt;code&gt;Array&lt;/code&gt; 메소드 &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;를 확실히 알고&lt;br&gt;구현해 만들어보는 것이 도움이 된다길래 한번 만들어 봤습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/19/Array-prototype-map-filter-reduce-구현하기/#map&quot;&gt;Array.prototype.map&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;map 원리&lt;/li&gt;
&lt;li&gt;map 메소드 만들어보기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/19/Array-prototype-map-filter-reduce-구현하기/#filter&quot;&gt;Array.prototype.filter&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filter 원리&lt;/li&gt;
&lt;li&gt;filter 메소드 만들어보기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/19/Array-prototype-map-filter-reduce-구현하기/#reduce&quot;&gt;Array.prototype.reduce&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;reduce 원리&lt;/li&gt;
&lt;li&gt;reduce 메소드 만들어보기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p><code>React</code> 입문전에 <code>Array</code> 메소드 <code>map</code>, <code>filter</code>, <code>reduce</code>를 확실히 알고<br>구현해 만들어보는 것이 도움이 된다길래 한번 만들어 봤습니다.</p><ul><li><p><a href="/2020/05/19/Array-prototype-map-filter-reduce-구현하기/#map">Array.prototype.map</a></p><ul><li>map 원리</li><li>map 메소드 만들어보기</li></ul></li><li><p><a href="/2020/05/19/Array-prototype-map-filter-reduce-구현하기/#filter">Array.prototype.filter</a></p><ul><li>filter 원리</li><li>filter 메소드 만들어보기</li></ul></li><li><p><a href="/2020/05/19/Array-prototype-map-filter-reduce-구현하기/#reduce">Array.prototype.reduce</a></p><ul><li>reduce 원리</li><li>reduce 메소드 만들어보기</li></ul></li></ul><a id="more"></a><hr><h2 id="map">Array.prototype.map</h2><hr><h3 id="map-원리"><a href="#map-원리" class="headerlink" title="map 원리"></a>map 원리</h3><ul><li><code>map()</code> 메서드는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 실행합니다.</li></ul><ul><li>결과를 모아 생성된 새로운 배열을 반환합니다. (<strong>원본값 수정X</strong>)</li></ul><blockquote><p>Array.prototype.map(callback,thisArg)<br>callback : currentValue, index, array</p></blockquote><ul><li><code>map</code> 메서드는 <code>callback</code> 함수와 <code>thisArg</code> 두가지 인자를 받고<br>(thisArg는 callback을 실행할 때 this로 사용하는 값입니다.) <strong>지정해 주지 않을시 <code>this</code>는 전역객체</strong></li></ul><ul><li><p><code>callback</code> 함수는 아래 3가지 인자를 받습니다.</p><ul><li><strong>currentValue</strong><br>처리할 현재 요소.</li><li><strong>index</strong> (Optional)<br>처리할 현재 요소의 인덱스.</li><li><strong>array</strong> (Optional)<br>map()을 호출한 배열.</li></ul></li></ul><ul><li><strong>반환 값</strong><br>각 요소에 함수를 호출하여 반환된 새로운 배열</li></ul><hr><h3 id="map-만들어보기"><a href="#map-만들어보기" class="headerlink" title="map 만들어보기"></a>map 만들어보기</h3><figure class="highlight js"><figcaption><span>map 메서드 구현</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="keyword">debugger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 기존 map</span></span><br><span class="line"><span class="keyword">const</span> result = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [ 'a1', 'b1', 'c1' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// map1 메소드 생성</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.map1 = <span class="function"><span class="keyword">function</span>(<span class="params">callback,thisArg</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mapping = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i ++) &#123;</span><br><span class="line">    <span class="keyword">var</span> mappedValue = callback.call(thisArg || Window, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>);</span><br><span class="line">    mapping[i] = mappedValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mapping;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result1 = a.map1(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result1); <span class="comment">// [ 'a1', 'b1', 'c1' ]</span></span><br></pre></td></tr></table></figure><hr><h2 id="filter">Array.prototype.filter</h2><hr><h3 id="filter-원리"><a href="#filter-원리" class="headerlink" title="filter 원리"></a>filter 원리</h3><ul><li><code>filter()</code> 메서드는 주어진 함수의 테스트를 통과(<code>true</code>)하는 모든 요소를 모아 <strong>새로운 배열로 반환합니다</strong>.</li></ul><ul><li><code>false</code>를 반환하는 요소는 버립니다.</li></ul><blockquote><p>Array.prototype.filter(callback, thisArg)<br>callback : currentValue, index, array</p></blockquote><ul><li><code>filter</code> 메서드는 <code>callback</code>, <code>thisArg</code> 두가지 인자를 받고<br>(thisArg는 callback을 실행할 때 this로 사용하는 값입니다.) <strong>지정해 주지 않을시 <code>this</code>는 전역객체</strong></li></ul><ul><li><p><code>callback</code> 함수는 아래 3가지 인자를 받습니다.</p><ul><li><p><strong>currentValue</strong><br>처리할 현재 요소.</p></li><li><p><strong>index</strong> (Optional)<br>처리할 현재 요소의 인덱스.</p></li><li><p><strong>array</strong> (Optional)<br>filter()를 호출한 배열.</p></li></ul></li></ul><ul><li><strong>반환 값</strong><br>각 요소에 함수를 테스트하여 true를 반환한 요소만 모은 새 배열</li></ul><hr><h3 id="filter-만들어보기"><a href="#filter-만들어보기" class="headerlink" title="filter 만들어보기"></a>filter 만들어보기</h3><figure class="highlight js"><figcaption><span>filter 메서드 구현</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="keyword">debugger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> words = [<span class="string">'spray'</span>, <span class="string">'limit'</span>, <span class="string">'elite'</span>, <span class="string">'exuberant'</span>, <span class="string">'destruction'</span>, <span class="string">'present'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기본 filter 사용</span></span><br><span class="line"><span class="keyword">const</span> result = words.filter(<span class="function"><span class="params">word</span> =&gt;</span> word.length &gt; <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//[ 'exuberant', 'destruction', 'present' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter1 메서드 생성하여 사용</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.filter1 = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> filtermapping = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> filterValue = callback.call(thisArg || Window, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (filterValue === <span class="literal">true</span>)&#123;</span><br><span class="line">        filtermapping.push(<span class="keyword">this</span>[i])</span><br><span class="line">      &#125;      </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> filtermapping;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result1 = words.filter1(<span class="function"><span class="params">word</span> =&gt;</span> word.length &gt; <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result1);<span class="comment">//[ 'exuberant', 'destruction', 'present' ]</span></span><br></pre></td></tr></table></figure><hr><h2 id="reduce">Array.prototype.reduce</h2><hr><h3 id="reduce-원리"><a href="#reduce-원리" class="headerlink" title="reduce 원리"></a>reduce 원리</h3><ul><li><code>reduce()</code> 메서드는 배열의 각 요소에 대해 주어진 리듀서(reducer) 함수를 실행하고, 하나의 결과값을 반환합니다.</li></ul><blockquote><p>Array.prototype.reduce(callback, initialValue)<br>callback : accumulator, currentValue, currentIndex, array</p></blockquote><ul><li><p><code>callback</code><br>배열의 각 요소에 대해 실행할 함수. 다음 네 가지 인수를 받습니다.</p><ul><li><p><strong>accumulator</strong><br>누산기accmulator는 <strong>콜백의 반환값을 누적합니다</strong>. 콜백의 이전 반환값 또는, 콜백의 첫 번째 호출이면서 <code>initialValue</code>를 제공한 경우에는  <code>initialValue</code>의 값입니다.</p></li><li><p><strong>currentValue</strong><br>처리할 현재 요소.</p></li><li><p><strong>currentIndex</strong> (Optional)<br>처리할 현재 요소의 인덱스. <code>initialValue</code>를 제공한 경우 0, 아니면 1부터 시작합니다.</p></li><li><p><strong>array</strong> (Optional)<br>reduce()를 호출한 배열.</p></li></ul></li></ul><ul><li><code>initialValue</code><br>callback의 최초 호출에서 첫 번째 인수에 제공하는 값. <strong>초기값을 제공하지 않으면 배열의 첫 번째 요소</strong>를 사용합니다.<br><strong>빈 배열에서 초기값 없이 reduce()를 호출하면 오류가 발생합니다.</strong></li></ul><ul><li><strong>반환 값</strong><br>누적 계산의 결과 값.</li></ul><hr><h3 id="reduce-만들어보기"><a href="#reduce-만들어보기" class="headerlink" title="reduce 만들어보기"></a>reduce 만들어보기</h3><p style="font-size: 2.4rem;"> 수정중. 에러사항 많음</p><figure class="highlight js"><figcaption><span>reduce 메서드 구현</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="keyword">debugger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">const</span> emptyArray = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기존 reduce</span></span><br><span class="line"><span class="built_in">console</span>.log(array1.reduce(reducer, <span class="number">5</span>)); <span class="comment">//22</span></span><br><span class="line"><span class="built_in">console</span>.log(array1.reduce(reducer)); <span class="comment">//17</span></span><br><span class="line"><span class="comment">// 빈 배열에서 초기값 없이 reduce()를 호출하면 오류</span></span><br><span class="line"><span class="built_in">console</span>.log(emptyArray.reduce(reducer));</span><br><span class="line"><span class="comment">//TypeError: Reduce of empty array with no initial value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce1 메서드 생성하여 사용</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.reduce1 = <span class="function"><span class="keyword">function</span>(<span class="params">callback,initialValue</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reduceValue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(initialValue === <span class="literal">undefined</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.length === <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Reduce of empty array with no initial value"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    reduceValue += callback(<span class="keyword">this</span>[<span class="number">0</span>], <span class="keyword">this</span>[<span class="number">1</span>], <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">2</span>; i &lt; <span class="keyword">this</span>.length; i ++)&#123;</span><br><span class="line">      reduceValue =+ callback(reduceValue, <span class="keyword">this</span>[i], <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    reduceValue += callback(initialValue, <span class="keyword">this</span>[<span class="number">0</span>], <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.length; i ++)&#123;</span><br><span class="line">      reduceValue =+ callback(reduceValue, <span class="keyword">this</span>[i], <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> reduceValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.reduce1(reducer, <span class="number">5</span>)); <span class="comment">//22</span></span><br><span class="line"><span class="built_in">console</span>.log(array1.reduce1(reducer)); <span class="comment">//17</span></span><br><span class="line"><span class="built_in">console</span>.log(emptyArray.reduce1(reducer));</span><br><span class="line"><span class="comment">//TypeError: Reduce of empty array with no initial value</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/19/Array-prototype-map-filter-reduce-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>클래스(Class) -Core JavaScript</title>
      <link>https://hdw0903.github.io/2020/05/11/%ED%81%B4%EB%9E%98%EC%8A%A4-Class-Core-JavaScript/</link>
      <guid>https://hdw0903.github.io/2020/05/11/%ED%81%B4%EB%9E%98%EC%8A%A4-Class-Core-JavaScript/</guid>
      <pubDate>Mon, 11 May 2020 10:13:14 GMT</pubDate>
      <description>
      
        &lt;p&gt;다른 언어의 상속 개념을 흉내 내기위해 자바스크립트 ES6에서 추가된 &lt;code&gt;Class&lt;/code&gt; 문법&lt;br&gt;(&lt;strong&gt;내부적으로는 프로토타입을 따름&lt;/strong&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/11/클래스-Class-Core-JavaScript/#Class&quot;&gt;클래스와 인스턴스의 개념 이해&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/11/클래스-Class-Core-JavaScript/#JavaScript_Class&quot;&gt;자바스크립트의 클래스&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/11/클래스-Class-Core-JavaScript/#Class_상속&quot;&gt;클래스 상속&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;기본 구현&lt;/li&gt;
&lt;li&gt;클래스가 구체적인 데이터를 지니지 않게 하는법&lt;/li&gt;
&lt;li&gt;constructor 복구하기&lt;/li&gt;
&lt;li&gt;상위 클래스에 접근 수단&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/11/클래스-Class-Core-JavaScript/#ES6_Class&quot;&gt;ES6의 클래스 및 클래스 상속&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/11/클래스-Class-Core-JavaScript/#point&quot;&gt;정리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>다른 언어의 상속 개념을 흉내 내기위해 자바스크립트 ES6에서 추가된 <code>Class</code> 문법<br>(<strong>내부적으로는 프로토타입을 따름</strong>)</p><ul><li><a href="/2020/05/11/클래스-Class-Core-JavaScript/#Class">클래스와 인스턴스의 개념 이해</a></li><li><a href="/2020/05/11/클래스-Class-Core-JavaScript/#JavaScript_Class">자바스크립트의 클래스</a></li><li><a href="/2020/05/11/클래스-Class-Core-JavaScript/#Class_상속">클래스 상속</a><ul><li>기본 구현</li><li>클래스가 구체적인 데이터를 지니지 않게 하는법</li><li>constructor 복구하기</li><li>상위 클래스에 접근 수단</li></ul></li><li><a href="/2020/05/11/클래스-Class-Core-JavaScript/#ES6_Class">ES6의 클래스 및 클래스 상속</a></li><li><a href="/2020/05/11/클래스-Class-Core-JavaScript/#point">정리</a></li></ul><a id="more"></a><hr><h2 id="Class">클래스와 인스턴스의 개념 이해</h2><p>상위(<code>superior</code>), 하위(<code>subordinate</code>) 개념의 앞글자를 따서<br>상위 클래스(<code>superclass</code>), 하위 클래스(<code>subclass</code>)로 표현합니다.</p><p>자바스크립트를 기준으로 하위 클래스(<code>subclass</code>)를 <code>Array</code>로 생각해 본다면 상위 클래스(<code>superclass</code>)는 <code>__proto__</code>와 <code>Array.prototype</code>에 따라 <code>Object</code>가 되겠습니다.</p><p><img src="/images/Class.png" alt="superClass 와 subClass"></p><p>클래스의 속성을 지니는 실존하는 개체를 <code>instance</code>라고 합니다.<br><code>instance</code>는 <strong>“해당 클래스의 조건을 만족하는 구체적인 예시”</strong>라고 해석 할 수도 있습니다.</p><ul><li><p><code>Class</code>를 바탕으로 <code>instance</code>를 만들 때 생성된 개체가 <code>Class</code>의 속성을 지니게 됩니다.</p></li><li><p>또한 한 <code>instance</code>는 <strong>하나의 클래스만을 바탕으로 만들어 집니다.</strong><br>인스턴스가 다양한 클래스에 속할 수는 있지만 인스턴스 입장에서는 모두 ‘직계존속’클래스들 입니다.<br>결국 인스턴스를 생성할 때 호출할 수 있는 클래스는 오직 하나뿐 이기 떄문입니다.<br><img src="/images/superClass_subClass.jpg" alt="superClass subClass"><br><a href="https://coding-restaurant.tistory.com/239">도식 그림 출처: 코딩맛집</a></p></li></ul><hr><h2 id="JavaScript_Class">자바스크립트의 클래스</h2><p>생성자 함수 <code>Array</code>를 <code>new</code> 연산자와 함께 호출하면 <code>instance</code>가 생성됩니다. 이 때 <code>Array</code>를 일종의 <code>클래스</code>라고 하면 <code>Array</code>의 <code>prototype</code> 객체 내부 요소들이 <code>instance</code>에 <strong>‘상속’</strong>된다고 볼수 있습니다. (내부적으로는 상속이 아닌 프로토 타입 체이닝에 의한 참조 입니다.)</p><ul><li><p>한편 <code>Array</code> 내부 프로퍼티들 중 <code>prototype</code> 프로퍼티를 제외한 나머지는 <code>instance</code>에 상속되지 않습니다.</p></li><li><p><code>instance</code>가 참조하는지 여부에 따라 </p><ul><li>스태틱 맴버(<code>static member</code>) 와</li><li>인스턴스 맴버(<code>instance member</code>)로 나뉩니다.<br><img src="/images/static_member.png" alt="static member, instance member"></li></ul></li><li><p><code>prototype</code>에 있는 내부 메서드는 <code>instance</code>가 직접 호출할 수 있습니다.</p></li><li><p>반대로 <code>prototype</code>에 없는 메서드는 <code>instance</code>가 참조하지 않으므로 호출할 수 없습니다.</p></li><li><p>이렇게 <code>instance</code><strong>에서 직접 접근할 수 없는 메서드를 스태틱 메서드라고 합니다.</strong></p></li></ul><hr><h2 id="Class_상속">클래스 상속</h2><hr><h3 id="기본-구현"><a href="#기본-구현" class="headerlink" title="기본 구현"></a>기본 구현</h3><p>클래스 상속은 객체지향에서 가장 중요한 요소 중 하나입니다, 하지만 자바스크립트는 ES5까지 클래스가 없었기 때문에 프로토 타입 체인을 활용해 클래스 상속을 흉내내었었습니다.</p><p>이에 대해 가볍게 알아보겠습니다.</p><hr><h4 id="length-프로퍼티-삭제-가능"><a href="#length-프로퍼티-삭제-가능" class="headerlink" title="length 프로퍼티 삭제 가능"></a>length 프로퍼티 삭제 가능</h4><figure class="highlight js"><figcaption><span>length 삭제</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Grade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>[i] = args[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.length = args.length;</span><br><span class="line">&#125;;</span><br><span class="line">Grade.prototype = [];</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Grade(<span class="number">100</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">g.push(<span class="number">90</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// Grade &#123; 0: 100, 1: 80, 2: 90, length: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> g.length;</span><br><span class="line">g.push(<span class="number">70</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// Grade &#123; 0: 70, 1: 80, 2: 90, length: 1 &#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>length</code>프로퍼티를 삭제하고 다시 <code>push</code> 했더니, <code>push</code>한 값이 0번째 <code>index</code>에 들어가고, <code>length</code>가 1이 됐습니다.</li></ul><ul><li>내장객체인 <code>배열 instance</code>의 <code>length</code> 프로퍼티는 <code>{ configurable : false }</code>라서 삭제가 불가능하지만,<br><code>Grade</code> 클래스의 <code>instance</code>는 <strong>배열 메서드를 상속(참조)하지만 기본적으로는 일반 객체의 성질을 그대로 지니므로 삭제가 가능</strong>해서 문제가 됩니다.</li></ul><hr><h4 id="빈-배열"><a href="#빈-배열" class="headerlink" title="빈 배열"></a>빈 배열</h4><ul><li><code>push</code>했을 때 0번째 <code>index</code>에 70이 들어가고 <code>length</code>가 1이 된 이유:<br><code>g.__proto__</code>, 즉 <code>Grade.prototype</code>이 <strong>빈 배열을 가리키고 있기 때문</strong></li></ul><ul><li><code>push</code> 명령에 의해 엔진이 <code>g.length</code>를 읽으려 하는데 <code>g.length</code>가 <strong>존재하지 않으므로 프로토 타입 체이닝을 타고</strong> <code>g.__proto__.length</code>을 읽어옴.</li></ul><ul><li>빈 배열의 <code>length</code>는 0 이므로 여기에 값을 할당하고 <code>length</code>는 1 만큼 증가합니다.</li></ul><hr><h4 id="요소가-있는-배열을-prototype에-매칭한-경우"><a href="#요소가-있는-배열을-prototype에-매칭한-경우" class="headerlink" title="요소가 있는 배열을 prototype에 매칭한 경우"></a>요소가 있는 배열을 prototype에 매칭한 경우</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Grade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>[i] = args[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.length = args.length;</span><br><span class="line">&#125;;</span><br><span class="line">Grade.prototype = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]; <span class="comment">// 빈 배열 아님</span></span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Grade(<span class="number">100</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">g.push(<span class="number">90</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// Grade &#123; 0: 100, 1: 80, 2: 90, length: 3 &#125;</span></span><br><span class="line"><span class="comment">// length 삭제 후</span></span><br><span class="line"><span class="keyword">delete</span> g.length;</span><br><span class="line">g.push(<span class="number">70</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// Grade &#123; 0: 100, 1: 80, 2: 90, ___ 4: 70, length: 5 &#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>Grade.prototype</code>에 빈 배열이 아닌 <code>length</code>가 4인 배열을 할당했습니다.</li></ul><ul><li><code>length</code>를 삭제 후 <code>push</code>한 값이 <code>Grade.prototype</code>에 빈 배열을 할당했을 때와는 다르게 동작합니다.</li></ul><ul><li><code>push</code>명령에 의해 엔진이 <code>g.length</code>를 읽으려 하는데 존재하지 않으므로 <code>g.__proto__.length</code>를 읽어오는데 <code>length</code>값이 4인 배열입니다.</li></ul><ul><li>그러므로 여기에 (<code>index : 4</code>) 70값을 할당하고 <code>length</code> 값을 1증가시켜 5가 되는것 입니다.</li></ul><p><strong>이처럼 <code>class</code>에 있는 값이 <code>instance</code>의 동작에 영향을 줘서는 안됩니다.</strong>(이런 영향을 줄 수 있다는 것 자체가 이미 클래스의 추상성을 해치는 것입니다.)</p><p><code>class</code>는 <code>instance</code>와의 관계에서는 <strong>구체적인 데이터를 지니지 않고</strong> 오직 <code>instance</code>가 <strong>사용할 메서드만을 지니는 추상적인 틀</strong>로만 작용해야 합니다.</p><hr><h4 id="사용자가-정의한-두-클래스-사이에서의-상속관계-구현"><a href="#사용자가-정의한-두-클래스-사이에서의-상속관계-구현" class="headerlink" title="사용자가 정의한 두 클래스 사이에서의 상속관계 구현"></a>사용자가 정의한 두 클래스 사이에서의 상속관계 구현</h4><p>직사각형 클래스와 정사각형 클래스를 만듭니다.</p><ul><li><p>직사각형: 두 쌍의 마주 보는 변이 평행이고 그 길이가 같습니다.</p></li><li><p>정사각형: 직사각형이며(직사각형의 조건을 충족) 네 변의 길이가 모두 같습니다.</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rect.getArea()); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Square = <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">&#125;;</span><br><span class="line">Square.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.width;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> sq = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sq.getArea()); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><ul><li><code>Rectangle</code>과 <code>Square</code>클래스에 공통 요소가 보입니다. <code>width</code> 프로퍼티가 공통이고, <code>getArea</code>메서드는 다른 부분이 있으나 비슷합니다.</li></ul><ul><li><code>Square</code>에서 <code>width</code>프로퍼티만 쓰지 않고 <code>height</code>프로퍼티에 <code>width</code>값을 부여하는 형태로 변경한다면 <code>getArea</code>도 동일하게 쓸 수 있겠습니다.</li></ul><figure class="highlight js"><figcaption><span>Square 수정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Square = <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = width;</span><br><span class="line">&#125;;</span><br><span class="line">Square.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>Square</code>를 위와같이 수정해 주면 <code>Square</code>를 <code>Rectangle</code>의 하위 클래스로 삼을 수 있습니다.</li></ul><ul><li><code>getArea</code> 메서드는 동일한 동작을 하므로 <strong>상위 클래스에서만 정의하고, 하위 클래스에서는 해당 메서드를 상속</strong>하면서 <code>height</code> 대신 <code>width</code>를 넣어주면 되겠습니다.</li></ul><figure class="highlight js"><figcaption><span>Rectangle을 상속하는 Square 클래스</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Square = <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  Rectangle.call(<span class="keyword">this</span>, width, width);</span><br><span class="line">&#125;;</span><br><span class="line">Square.prototype = <span class="keyword">new</span> Rectangle();</span><br></pre></td></tr></table></figure><ul><li><code>Square</code> 생성자 함수 내부에서 <code>Rectangle</code> 생성자 함수를 함수로 호출하고 <strong>인자 height 자리에 width를 전달합니다.</strong></li></ul><ul><li><code>Square.prototype = new Rectangle();</code>  : 메서드를 상속하기 위해 프로토타입 객체에 <code>Rectangle</code>의 <code>instance</code>를 부여했습니다.</li></ul><p>하지만 위 코드만으로 <strong>완벽한 클래스 체계가 구축됐다고 볼 수는 없습니다.</strong></p><p><strong>아직 클래스에 있는 값이 인스턴스에 영향을 줄 수 있는 구조이기 때문입니다.</strong></p><ul><li><code>console.dir(sq);</code>로 sq <code>instance</code>에 대하여 콘솔로 출력해보면<br><img src="/images/dir_sq.png" alt="console.dir(sq);"><br>첫 줄에서 <code>Square</code>의 <code>instance</code>을 표시하고 있고 <code>width</code>와 <code>height</code>에 5가 잘 들어있습니다. <code>__proto__</code>는 <code>Rectangle</code>의 <code>instance</code>임을 표시하고 이어서 <code>width</code>, <code>height</code>에 모두 <code>undefined</code>가 할당되어 있습니다. <code>Square.prototype</code>에 값이 존재하여 이후에 임의로 <code>Square.prototype.width (또는 height)</code>에 값을 부여하고 <code>sq.width(또는 height)</code>의 값을 지워버린다면 프로토타입 체이닝에 의해 엉뚱한 결과가 나오는 문제가 생길 수 있습니다.</li></ul><p><img src="/images/Square%EB%8F%84%EC%8B%9D.jfif" alt="Rectangle -&gt; Square 상속 관계 구현 도식"><br><a href="https://coding-restaurant.tistory.com/239">도식 그림 출처: 코딩맛집</a></p><p>나아가 <code>constructor</code>가 여전히 <code>Rectangle</code>을 바라보고 있는 문제도 있습니다. <code>sq.constructor</code>로 접근하면 프로토타입 체이닝을 따라 <code>sq.__proto__.__proto__,</code> 즉 <code>Rectangle.prototype</code>에서 찾게 되며 이는 <code>Rectangle</code>을 가리키고 있기 때문입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect2 = <span class="keyword">new</span> sq.constructor(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rect2); <span class="comment">// Rectangle &#123;width: 2, height: 3&#125;</span></span><br></pre></td></tr></table></figure><p>이처럼 하위 클래스로 삼을 생성자 함수의 <code>prototype</code> 에 상위 클래스의 <code>instance</code>를 부여하는 것만으로도 기본적 메서드 상속은 가능하지만 다양한 문제가 발생할 여지가 있어 구조적 안정성이 떨어집니다.</p><hr><h3 id="클래스가-구체적인-데이터를-지니지-않게-하는법"><a href="#클래스가-구체적인-데이터를-지니지-않게-하는법" class="headerlink" title="클래스가 구체적인 데이터를 지니지 않게 하는법"></a>클래스가 구체적인 데이터를 지니지 않게 하는법</h3><p>클래스 (prototype)가 구체적인 데이터를 지니지 않게 하는 방법 중<br>가장 쉬운 방법은 일단 만들고 나서 프로퍼티들을 일일히 지우고 더는 <strong>새로운 프로퍼티를 추가할 수 없게 하는 것</strong>입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> Square.prototype.width; </span><br><span class="line"><span class="keyword">delete</span> Square.prototype.height; </span><br><span class="line"><span class="built_in">Object</span>.freeze(Square.prototype);</span><br></pre></td></tr></table></figure><p>프로퍼티가 많다면 반복 작업이 될테니 반복을 없애고 좀 더 범용적으로 이런 동작을 하는 함수를 만들면 좋겠습니다.</p><figure class="highlight js"><figcaption><span>인스턴스 생성 후 프로퍼티 제거</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass1 = <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">  SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> SubClass.prototype) &#123;</span><br><span class="line">    <span class="keyword">if</span> (SubClass.prototype.hasOwnProperty(prop)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> SubClass.prototype[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">      SubClass.prototype[method] = subMethods[method];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">  <span class="keyword">return</span> SubClass;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Square = extendClass1(Rectangle, <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  Rectangle.call(<span class="keyword">this</span>, width, width);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> sq = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sq.getArea()); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><ul><li><code>extendClass1</code> 함수는 <code>SuperClass</code>와 <code>SubClass</code>, <code>SubClass</code>에 추가할 메서드들이 정의된 객체를 받아 <code>SubClass</code>의 <code>prototype</code> 내용을 정리하고 <code>freeze</code>하는 내용으로 구성돼있습니다.</li></ul><hr><h4 id="두-번째-방법-빈-함수"><a href="#두-번째-방법-빈-함수" class="headerlink" title="두 번째 방법(빈 함수)"></a>두 번째 방법(빈 함수)</h4><p>더글라스 크락포드가 제시하여 대중적으로 알려진 방법입니다.<br><code>SubClass</code>의 <code>prototype</code>에 직접 <code>SubClass</code>의 <code>instance</code>를 할당하는 대신</p><p><strong>아무런 프로퍼티를 생성하지 않는 빈 생성자 함수(<code>Bridge</code>)를 하나 더 만들어서</strong> 그 <code>prototype</code>이 <code>SubClass</code>의 <code>prototype</code>을 바라보게 한 다음,<code>SubClass</code>의 <code>prototype</code>에는 <code>Bridge</code>의 <code>instance</code>를 할당하게 하는 것입니다.<br>(<strong>빈 함수에 다리 역활을 부여</strong>)</p><p><img src="/images/Class2.png" alt="클래스 상속 및 추상화 방법(2)- 빈 함수 활용"></p><ul><li><code>Bridge</code>라는 빈 함수를 만들고, <code>Bridge.prototype</code>이 <code>Rectangle.prototype</code>을 참조하게 한 다음, <code>Square.prototype</code>에 <code>new Bridge()</code>로 할당하면, 우측 그림처럼 <code>Rectangle</code> 자리에 <code>Bridge</code>가 대체됩니다.</li></ul><ul><li>이로써 <code>instance</code>를 제외한 <strong>프로토타입 체인 경로상에는 더는 구체적인 데이터가 남아있지 않게 됩니다</strong>.</li></ul><p>마찬가지로 반복작업을 없애기 위해 범용적으로 이런 동작을 하는 함수를 만들어 보겠습니다.</p><figure class="highlight js"><figcaption><span>빈 함수를 활용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass2 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Bridge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">    Bridge.prototype = SuperClass.prototype;</span><br><span class="line">    SubClass.prototype = <span class="keyword">new</span> Bridge();</span><br><span class="line">    <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">        SubClass.prototype[method] = subMethods[method];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">    <span class="keyword">return</span> SubClass;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Square = extendClass2(Rectangle, <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  Rectangle.call(<span class="keyword">this</span>, width, width);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> sq = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sq.getArea()); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><ul><li><p>즉시실행함수 내부에서 <code>Bridge</code>를 선언하여 이를 클로저로 활용함으로써 메모리에 불필요한 함수 선언을 줄였습니다.</p></li><li><p><code>subMethods</code>에는 <code>SubClass</code>의 <code>prototype</code>이 담길 메서드들을 객체로 전달하게 했습니다.</p></li></ul><hr><h4 id="세-번째-방법-Object-create"><a href="#세-번째-방법-Object-create" class="headerlink" title="세 번째 방법(Object.create)"></a>세 번째 방법(Object.create)</h4><p>세 번째 방법은 ES5에서 도입된 <code>Object.create</code>를 이용한 방법으로 이 방법은</p><p><code>SubClass</code>의 <code>prototype</code>의 <code>__proto__</code>가 <code>SuperClass</code>의 <code>prototype</code>을 바라보되, <code>SuperClass</code>의 <code>instance</code>가 되지는 않으므로 앞서 소개한 두 방법보다 간편하면서 안전합니다.</p><figure class="highlight js"><figcaption><span>Object.create 활용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Square = <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  Rectangle.call(<span class="keyword">this</span>, width, width);</span><br><span class="line">&#125;;</span><br><span class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype);</span><br><span class="line"><span class="built_in">Object</span>.freeze(Square.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sq = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sq.getArea()); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p><del>클래스 상속 및 추상화를 흉내 내기 위한 라이브러리가 많이 있지만 기본적인 접근 방법은 위 세가지 아이디어를 크게 벗어나지 않습니다.</del></p><p>결론적으로 <code>SubClass.prototype</code>의 <code>__proto__</code>가 <code>SuperClass.prototype</code>을 참조하고, <code>SubClass.prototype</code>에는 불필요한 <code>instance 프로퍼티</code>가 남아있으면 안되기 때문입니다.</p><hr><h3 id="constructor-복구하기"><a href="#constructor-복구하기" class="headerlink" title="constructor 복구하기"></a>constructor 복구하기</h3><p>위 세 가지 방법 모두 기본적인 상속에는 성공했지만, <code>SubClass</code> <code>instance</code>의 <code>constructor</code>는 여전히 <code>Superclass</code>를 가리키는 상태입니다.</p><ul><li>엄밀히는 <code>SubClass</code>의 <code>instance</code>에는 <code>constructor</code>가 없고, <code>SubClass.prototype</code>에도 없는 상태입니다.</li></ul><ul><li>프로토타입 체인상에 가장 먼저 등장하는 <code>SuperClass.prototype</code>의 <code>constructor</code>가 가리키는 대상인 <code>SuperClass</code>가 출력되는 것입니다.</li></ul><p>따라서 <code>SubClass.prototype.constructor</code>가 원래의 <code>SubClass</code>를 바라보도록 해주겠습니다.</p><figure class="highlight js"><figcaption><span>인스턴스 생성 후 프로퍼티 제거 + constructor 복구</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass1 = <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">  SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> SubClass.prototype) &#123;</span><br><span class="line">    <span class="keyword">if</span> (SubClass.prototype.hasOwnProperty(prop)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> SubClass.prototype[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//SubClass.prototype.constructor가 원래의 SubClass를 바라보도록 함</span></span><br><span class="line">  SubClass.prototype.consturctor = SubClass;</span><br><span class="line">  <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">      SubClass.prototype[method] = subMethods[method];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">  <span class="keyword">return</span> SubClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>빈 함수 활용 + constructor 복구</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass2 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Bridge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">    Bridge.prototype = SuperClass.prototype;</span><br><span class="line">    SubClass.prototype = <span class="keyword">new</span> Bridge();</span><br><span class="line">    SubClass.prototype.consturctor = SubClass;</span><br><span class="line">    <span class="comment">//SuperClass와의 관계를 복구하기 위해</span></span><br><span class="line">    <span class="comment">//Bridge.prototype.constructor가 SuperClass를 바라보게 하는 작업 추가</span></span><br><span class="line">    Bridge.prototype.constructor = SuperClass;</span><br><span class="line">    <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">        SubClass.prototype[method] = subMethods[method];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">    <span class="keyword">return</span> SubClass;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>빈 함수(<code>Bridge</code>)를 이용한 두 번째 방법의 경우 <code>SubClass.prototype</code>이 <code>SuperClass</code> 대신 <code>Bridge</code>의 <code>instance</code>를 바라보는 상태이므로 <code>SuperClass</code>와의 관계를 복구하기 위해 <code>Bridge.prototype.constructor</code>가 <code>SuperClass</code>를 바라보게 하는 작업이 추가돼야 합니다. </p><figure class="highlight js"><figcaption><span>Object.create 활용 + constructor 복구</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass3 = <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">  SubClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line">  <span class="comment">//SubClass.prototype.constructor가 원래의 SubClass를 바라보도록 함</span></span><br><span class="line">  SubClass.prototype.constructor = SubClass;</span><br><span class="line">  <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">      SubClass.prototype[method] = subMethods[method];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">  <span class="keyword">return</span> SubClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="상위-클래스에-접근-수단"><a href="#상위-클래스에-접근-수단" class="headerlink" title="상위 클래스에 접근 수단"></a>상위 클래스에 접근 수단</h3><p>하위 클래스의 메서드에서 <strong>상위 클래스의 메서드 실행 결과를 바탕으로 추가적인 작업을 수행하고 싶을 때</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass.prototype.method.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure><p>매번 이런식으로 코드를 추가해서 해결하는 것은 상당히 번거롭고 가독성이 떨어지는 방식입니다.</p><p>하위 클래스에서 <strong>상위 클래스의 프로토타입 메서드에 접근하기 위한 별도의 수단</strong>이 있다면 편리할 것 같습니다.</p><p>이런 <strong>별도의 수단</strong>인 다른 객체지향 언어들의 클래스 문법 중 하나인 <code>super</code>를 흉내 내보겠습니다.</p><figure class="highlight js"><figcaption><span>상위 클래스 접근 수단 super 메서드 추가</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass = <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">  SubClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line">  SubClass.prototype.constructor = SubClass;</span><br><span class="line">  SubClass.prototype.super = <span class="function"><span class="keyword">function</span>(<span class="params">propName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 추가된 부분 시작</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!propName) <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//인자가 비어있을 경우 </span></span><br><span class="line">        SuperClass.apply(self, <span class="built_in">arguments</span>);<span class="comment">// SuperClass 생성자 함수에 접근하는 것으로 간주</span></span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">var</span> prop = SuperClass.prototype[propName]; <span class="comment">//SuperClass.prototype 내부의 propName에 해당하는 값이     </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> prop !== <span class="string">'function'</span>) <span class="keyword">return</span> prop;<span class="comment">//함수가 아닌 경우 해당값을 그대로 반환합니다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//함수인 경우</span></span><br><span class="line">      <span class="keyword">return</span> prop.apply(self, <span class="built_in">arguments</span>); <span class="comment">//메서드에 접근하는 것으로 여김</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;; <span class="comment">// 추가된 부분 끝</span></span><br><span class="line">  <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">      SubClass.prototype[method] = subMethods[method];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">  <span class="keyword">return</span> SubClass;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Square = extendClass(Rectangle, <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.super()(width, width); <span class="comment">// super 사용 (1)</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    getArea: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'size is :'</span>, <span class="keyword">this</span>.super(<span class="string">'getArea'</span>)()); <span class="comment">// super 사용 (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> sq = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line">sq.getArea(); <span class="comment">// size is : 100</span></span><br><span class="line"><span class="built_in">console</span>.log(sq.super(<span class="string">'getArea'</span>)()); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><ul><li>추가된 부분에서 <code>super</code> 메서드의 동작을 정의하고 있습니다.</li></ul><ul><li>7번째 줄에서 인자가 비어있을 경우 <code>SuperClass</code> 생성자 함수에 접근하는 것으로 간주했습니다.</li></ul><ul><li><code>this</code>가 달라지는 것을 막기 위해 클로저를 활용했습니다.</li></ul><ul><li>11번째 줄은 <code>SuperClass</code>의 <code>prototype</code> 내부의 <code>propName</code>에 해당하는 값이 함수가 아닌 경우 해당값을 그대로 반환합니다.</li></ul><ul><li>12번째 줄은 함수인 경우이므로 마찬가지로 클로저를 활용해 메서드에 접근하는 것으로 여기도록 했습니다.</li></ul><p>이제 <code>SuperClass</code>의 <strong>생성자 함수에 접근하고자 할 때는</strong> <code>this.super()</code>, <code>SuperClass</code>의 <strong>프로토타입 메서드에 접근하고자 할 때는</strong> <code>this.super(propName)</code>과 같이 사용할 수 있습니다.</p><hr><h2 id="ES6_Class">ES6의 클래스 및 클래스 상속</h2><ul><li><p><code>ES6</code>에서는 본격적으로 클래스 문법이 도입됐습니다.</p></li><li><p><code>ES5</code>에서의 생성자 함수 및 프로토타입 과 <code>ES6</code>의 클래스 문법을 비교해봅니다.</p></li></ul><hr><h4 id="ES5-ES6-클래스-문법-비교"><a href="#ES5-ES6-클래스-문법-비교" class="headerlink" title="ES5 / ES6 클래스 문법 비교"></a>ES5 / ES6 클래스 문법 비교</h4><figure class="highlight js"><figcaption><span>ES5와 ES6 클래스 문법 비교</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ES5 = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">ES5.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' staticMethod'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">ES5.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' method'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> es5Instance = <span class="keyword">new</span> ES5(<span class="string">'es5'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ES5.staticMethod()); <span class="comment">// es5 staticMethod</span></span><br><span class="line"><span class="built_in">console</span>.log(es5Instance.method()); <span class="comment">// es5 method</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ES6 = <span class="class"><span class="keyword">class</span> </span>&#123; <span class="comment">//중괄호 &#123;&#125;내부가 클래스 본문 영역입니다.</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123; <span class="comment">//클래스 본문에서는 'function'키워드를 생략하더라도</span></span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">//모두 메서드로 인식합니다.</span></span><br><span class="line">  &#125; <span class="comment">//메서드와 다음 메서드 사이에는 콤마(,)로 구분하지 않습니다.</span></span><br><span class="line">  <span class="keyword">static</span> staticMethod() &#123; <span class="comment">//static 키워드는 해당 메서드가 static 메서드라는 뜻입니다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' staticMethod'</span>; <span class="comment">//ES5의 생성자 함수에 바로 할당하는 메서드와 동일하게</span></span><br><span class="line">  &#125;                                     <span class="comment">//생성자 함수(클래스) 자신만이 호출할 수 있습니다.</span></span><br><span class="line">  method() &#123; <span class="comment">//method는 자동으로 prototype 객체 내부에 할당되는 메서드입니다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' method'</span>;<span class="comment">//ES5.prototype.method와 동일하게, </span></span><br><span class="line">  &#125; <span class="comment">//instance가 프로토타입 체이닝을 통해 자신의 것처럼 직접 호출가능합니다.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> es6Instance = <span class="keyword">new</span> ES6(<span class="string">'es6'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ES6.staticMethod()); <span class="comment">// es6 staticMethod</span></span><br><span class="line"><span class="built_in">console</span>.log(es6Instance.method()); <span class="comment">// es6 method</span></span><br></pre></td></tr></table></figure><hr><h4 id="ES6의-클래스-상속"><a href="#ES6의-클래스-상속" class="headerlink" title="ES6의 클래스 상속"></a>ES6의 클래스 상속</h4><figure class="highlight js"><figcaption><span>ES6의 클래스 상속</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Rectangle = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(width, height) &#123;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Square = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(width) &#123;</span><br><span class="line">    <span class="keyword">super</span>(width, width);</span><br><span class="line">  &#125;</span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'size is :'</span>, <span class="keyword">super</span>.getArea());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>Square</code>를 <code>Rectangle</code> 클래스를 상속받게 하기위해 <code>class</code>명렁어 뒤에 <code>extends Rectangle</code>을 추가합니다.<br>이것으로 상속 관계 설정이 완료됩니다.</li></ul><ul><li><code>constructor</code> 내부에서는 <code>super</code>라는 키워드를 함수처럼 사용할 수 있습니다. 이 함수는 <code>SuperClass</code>의 <code>constructor</code>를 실행합니다.</li></ul><ul><li><code>constructor</code> 메서드를 제외한 다른 메서드에서는 <code>super</code>키워드를 마치 객체처럼 사용할 수 있고, 이때 객체는 <code>SuperClass.prototype</code>을 바라보는데, <strong>호출한 메서드의 <code>this</code>는 <code>super</code>가 아닌 원래의 <code>this</code>를 그대로 따릅니다.</strong></li></ul><p><a href="https://hdw0903.github.io/2020/04/01/Class%20%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%20-ECMAScript/">ES6의 Class 오브젝트 더 자세히 알아보기</a></p><hr><h2 id="point">정리</h2><ul><li>클래스는 어떤 사물의 공통 속성을 모아 정의한 추상적인 개념, <code>instance</code>는 클래스의 속성을 갖는 구체적인 사례<br>상위 클래스(<code>SuperClass</code>)의 조건을 충족하면서 더욱 구체적인 조건이 추가된 것을 하위 클래스(<code>SubClass</code>)라고 함.</li></ul><ul><li>클래스의 <code>prototype</code> 내부에 정의된 메서드를 <code>프로토타입 메서드</code>라고 하며, 이들은 <code>instance</code>가 마치 자신의 것처럼 호출할 수 있습니다.</li></ul><ul><li>클래스(생성자 함수)에 직접 정의한 메서드를 <code>스태틱 메서드</code>라고 하며, 이들은 <code>instance</code>가 직접 호출할 수 없고 클래스(생성자 함수)에 의해서만 호출할 수 있음.</li></ul><ul><li><p>클래스 상속을 흉내 내기 위한 세 가지 방법</p><ul><li><p><code>SubClass.prototype</code>에 <code>Superclass</code>의 <code>instance</code>를 할당하고 프로퍼티를 모두 삭제하는 방법.</p></li><li><p>빈 함수(<code>Bridge</code>)를 할용하는 방법</p></li><li><p>Object.create를 이용하는 방법</p></li></ul><p><strong>세 방법 모두 <code>constructor</code> 프로퍼티가 원래의 생성자 함수를 바라보도록 조정해 줘야함</strong> </p></li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/11/%ED%81%B4%EB%9E%98%EC%8A%A4-Class-Core-JavaScript/#disqus_thread</comments>
    </item>
    
    <item>
      <title>prototype -Core JavaScript</title>
      <link>https://hdw0903.github.io/2020/05/05/prototype-Core-JavaScript/</link>
      <guid>https://hdw0903.github.io/2020/05/05/prototype-Core-JavaScript/</guid>
      <pubDate>Tue, 05 May 2020 08:57:53 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;프로토타입 (prototype)&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/05/prototype-Core-JavaScript/#프로토타입의-개념-이해&quot;&gt;프로토타입의 개념 이해&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;constructor, prototype, instance&lt;/li&gt;
&lt;li&gt;constructor 프로퍼티&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/05/prototype-Core-JavaScript/#prototype_chain&quot;&gt;프로토타입 체인&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;메서드 오버라이드&lt;/li&gt;
&lt;li&gt;프로토타입 체인&lt;/li&gt;
&lt;li&gt;객체 전용 메서드의 예외사항&lt;/li&gt;
&lt;li&gt;다중 프로토타입 체인&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/05/prototype-Core-JavaScript/#point&quot;&gt;정리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<ul><li>프로토타입 (prototype)<ul><li><a href="/2020/05/05/prototype-Core-JavaScript/#프로토타입의-개념-이해">프로토타입의 개념 이해</a><ul><li>constructor, prototype, instance</li><li>constructor 프로퍼티</li></ul></li><li><a href="/2020/05/05/prototype-Core-JavaScript/#prototype_chain">프로토타입 체인</a><ul><li>메서드 오버라이드</li><li>프로토타입 체인</li><li>객체 전용 메서드의 예외사항</li><li>다중 프로토타입 체인</li></ul></li><li><a href="/2020/05/05/prototype-Core-JavaScript/#point">정리</a></li></ul></li></ul><a id="more"></a><hr><h2 id="프로포타입의-개념-이해">프로토타입의 개념 이해</h2><h3 id="constructor-prototype-instance"><a href="#constructor-prototype-instance" class="headerlink" title="constructor, prototype, instance"></a>constructor, prototype, instance</h3><blockquote><p>var instance = new Constructor();</p></blockquote><p>위 코드를 추상화 하여 나타내면 다음과 같습니다.</p><p><img src="/images/prototype_schematic.png" alt="prototype schematic"></p><p>윗변(실선)의 왼쪽 꼭지점에는 <code>Constructor</code>(생성자 함수)를, 오른쪽 꼭짓점에는 <code>Constructor.prototype</code>이라는 프로퍼티를 위치시켰습니다.<br>왼쪽 꼭짓점부터 아래를 향한 화살표 중간에 <code>new</code>가 있고, 화살표의 종점에는 <code>instance</code>가 있습니다.<br>오른쪽 꼭짓점으로부터 대각선 아래로 향하는 화살표의 종점에는 <code>instance.__proto__</code>이라는 프로퍼티를 위치시켰습니다. </p><hr><ul><li><p>어떤 생성자 함수(<code>Constructor</code>)를 <code>new</code> 연산자와 함께 호출하면</p></li><li><p><code>Constructor</code>에서 정의된 내용을 바탕으로 새로운 인스턴스(<code>instance</code>)가 생성됩니다.</p></li><li><p>이떄 <code>instance</code>에는 <code>__proto__</code>라는 프로퍼티가 자동으로 부여되는데,</p></li><li><p>이 프로퍼티는 <code>Constructor</code>의 <code>prototype</code>이라는 프로퍼티를 참조합니다.</p></li></ul><p><code>prototype</code>이라는 프로퍼티와 <code>__proto__</code> <mark>이 둘의 관계가 프로토타입 개념의 핵심입니다.</mark></p><p><code>prototype</code>은 객체입니다. 이를 참조하는 <code>__proto__</code> 역시 객체입니다.</p><p><code>prototype</code> 객체 내부에는 <code>instance</code>가 사용할 메서드를 저장합니다. 그러면 <code>instance</code>에서도 숨겨진 프로퍼티인 <code>__proto__</code>를 통해 이 메서드들에 접근할 수 있게 됩니다.</p><hr><figure class="highlight js"><figcaption><span>Person이라는 생성자 함수의 prototype에 getName이라는 메서드를 지정한 예제</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이제 <code>Person</code>의 <code>instance</code>는 <code>__proto__</code>프로퍼티를 통해 <code>getName</code>을 호출할 수 있습니다.<br><code>instance</code>의 <code>__proto__</code>가 <code>Constructor</code>의 <code>prototype</code>프로퍼티를 참조하므로 결국 둘은 같은 객체를 바라보기 때문입니다.</p><figure class="highlight js"><figcaption><span>this 바인딩 값</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suzi = <span class="keyword">new</span> Person(<span class="string">'Suzi'</span>);</span><br><span class="line">suzi.__proto__.getName(); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">Person.prototype === suzi.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><code>suzi.__proto__.getName();</code>를 실행해 <code>undefined</code>가 나왔다는 것은 이 변수가 “호출할 수 있는 함수”에 해당한다는 것을 의미합니다. </li></ul><ul><li>만약 함수가 아닌 다른 데이터 값이었다면 <code>TypeError</code>가 발생했을 것입니다. 에러가 아닌 <code>undefined</code>를 반환했으므로 <code>getName</code>이 실제로 실행됐고 <code>getName</code>이 함수라는 것이 입증됐습니다.</li></ul><ul><li><code>undefined</code>를 반환한 이유는 <code>this</code>의 바인딩 값이 잘못됐음을 의미합니다.</li></ul><ul><li><code>suzi.__proto__.getName();</code>에서 <code>getName</code> 함수 내부에서의 <code>this</code>는 <code>suzi</code>가 아니라 메서드명 바로앞의 객체 즉, <code>suzi.__proto__</code>를 참조하게 되는 것입니다. </li></ul><ul><li><code>suzi.__proto__</code> 내부에 <code>name</code>프로퍼티가 없으므로 엔진이 “데이터 영역에 지정되지 않은 식별자에 접근할 때”를 뜻하는 <code>undefined</code>를 반환하게 됩니다. </li></ul><hr><p><code>__proto__</code> 객체에 <code>name</code> 프로퍼티가 있다면 <code>undefined</code>가 아니라 프로퍼티 값이 출력 되겠죠?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suzi = <span class="keyword">new</span> Person(<span class="string">'Suzi'</span>);</span><br><span class="line">suzi.__proto__._name = <span class="string">'SUZI__proto__'</span>;</span><br><span class="line">suzi.__proto__.getName(); <span class="comment">// SUZI__proto__</span></span><br></pre></td></tr></table></figure><p>위 예제 코드들의 관건은 <code>this</code>가 어떤 값을 참조하게 되는가 였습니다.<br><code>this</code>가 <code>instance</code>를 참조하게 하는 방법은 간단합니다.<br><code>__proto__</code>를 생략하고 <code>instance</code>뒤에 바로 메서드를 작성하면 됩니다.</p><figure class="highlight js"><figcaption><span>__proto__ 생략</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suzi = <span class="keyword">new</span> Person(<span class="string">'Suzi'</span>, <span class="number">28</span>);</span><br><span class="line">suzi.getName(); <span class="comment">// Suzi</span></span><br></pre></td></tr></table></figure><p>이런 코드가 실행되는 이유는 <code>__proto__</code>가 생략 가능한 프로퍼티이기 때문입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suzi.__proto__.getName</span><br><span class="line">&gt; suzi(.__proto__).getName</span><br><span class="line">== suzi.getName</span><br></pre></td></tr></table></figure><ul><li><p>정리하면 </p><ul><li><code>__proto__</code>를 생략하지 않으면 <code>this</code>는 <code>suzi.__proto__</code>를 참조 (내부에 name프로퍼티 존재하지 않음)</li><li>생략하면 <code>suzi</code>를 참조 가능해짐. (suzi.getName 형태, name 프로퍼티 존재)</li></ul><p><img src="/images/prototype_schematic2.png" alt="prototype schematic2"></p><ul><li>new 연산자로 <code>Constructor</code> 호출시 <code>instance</code> 생성되고<br><code>instance</code>의 생략가능한 프로퍼티인 <code>__proto__</code>는<br><code>Constructor</code>의 <code>prototype</code>을 참조</li></ul></li></ul><figure class="highlight js"><figcaption><span>prototype과 __proto__</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Constructor = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Constructor.prototype.method1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Constructor.prototype.property1 = <span class="string">'Constructor Prototype Property'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Constructor(<span class="string">'Instance'</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(Constructor); <span class="comment">//Constructor의 디렉터리 구조 출력</span></span><br><span class="line"><span class="built_in">console</span>.dir(instance); <span class="comment">//instance의 디렉터리 구조 출력</span></span><br></pre></td></tr></table></figure><ul><li>위 예제를 크롬 개발자도구에서 실행한 결과</li></ul><p><img src="/images/prototype_Constructor.png" alt="prototype Constructor"></p><ul><li><code>Constructor</code>의 디렉터리 구조를 출력한<ul><li>첫 번째 줄에 함수라는 의미의 <code>f</code> 와 함수이름 <code>Constructor</code>, 인자 <code>name</code>이 출력되었습니다.</li><li>그 내부에는 <mark>옅은 색</mark>의 argument, caller, length, name, <code>prototype</code>, &#95;&#95;proto&#95;&#95;등의 프로퍼티들이 나타납니다.</li><li>내부 프로퍼티중 <code>prototype</code>을 열면 개발자가 직접 추가한 <code>metod1</code>, <code>property1</code>등의 값은 <mark>짙은 색</mark>으로 보이고, constructor, &#95;&#95;proto&#95;&#95; 등은 <mark>옅은 색</mark>으로 보입니다.<pre><code>이런 색상의 차이는 { enumerable: false } 속성이 부여된 프로퍼티인지 여부에 따릅니다.짙은 색은 enumerable, 즉 열거 가능한 프로퍼티임을 의미하고, 옅은 색은 innumerable, 즉 열거할 수 없는 프로퍼티입니다.for in 문 등으로 객체의 프로퍼티 전체에 접근할 때 접근 가능 여부를 색상으로 구분지어 표기하는 것입니다.</code></pre></li></ul></li></ul><div align="center"><p><img src="/images/prototype_Instance.png" alt="prototype Instance"></p></div><ul><li><code>instance</code>의 디렉터리 구조를 출력한<ul><li>첫 번째 줄에 <code>Constructor</code>가 출력됩니다.<br>생성자 함수의 <code>instance</code>는 해당 생성자 함수의 이름을 표기함으로<br>해당 함수의 <code>instance</code>임을 나타냅니다.</li><li><code>Constructor</code>를 열어보면 <code>name</code>프로퍼티가 짙은 색으로 표기되고, <code>__proto__</code>프로퍼티가 옅은 색으로 표기됩니다.</li><li><code>__proto__</code>를 열어보면 <code>method1</code>, <code>property1</code>, <code>constructor</code>, <code>__proto__</code> 등이 있으므로,<br><code>Constructor</code>의 <code>prototype</code>과 동일한 내용으로 구성돼 있음을 확인할 수 있습니다.</li></ul></li></ul><hr><h4 id="내장-built-in-생성자-함수-Array-구조"><a href="#내장-built-in-생성자-함수-Array-구조" class="headerlink" title="내장(built-in) 생성자 함수 Array 구조"></a>내장(built-in) 생성자 함수 Array 구조</h4><figure class="highlight js"><figcaption><span>Array</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.dir(arr);</span><br><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">Array</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/prototype_arr_Array.png" alt="prototype arr and Array"></p><ul><li><p>arr</p><ul><li>첫 줄에 <code>Array(2)</code>가 표기됩니다.</li><li><code>Array</code> 생성자 함수를 원본으로 생성됐고, <code>length</code> 값 2를 알 수 있습니다.</li><li><code>index 0, 1</code>은 짙은 색으로 length와 &#95;&#95;proto&#95;&#95;는 옅은 색으로 표기됩니다.</li><li>&#95;&#95;proto&#95;&#95; 에는 Array 메서드 들이 포함되어 있습니다.</li></ul></li><li><p>Array</p><ul><li>첫 줄에 함수를 뜻하는 <code>f</code>가 표시됩니다.</li><li>함수의 프로퍼티인 <code>argument</code>, <code>caller</code>, <code>length</code>, <code>name</code>등이 표기됩니다.</li><li>또한 <code>Array</code> 함수의 정적 메서드 <code>from</code>, <code>isArray</code> <code>of</code> 등도 있습니다.</li><li><code>prototype</code>을 열어보면 왼쪽(arr)의 &#95;&#95;proto&#95;&#95;와 동일한 구성임을 확인할 수 있습니다.</li></ul></li></ul><ul><li><p>위 결과를 도식으로 나타면 다음과 같습니다.<br><img src="/images/prototype_Array_schematic.png" alt="prototype Array schematic"></p></li><li><p>Array를 new 연산자와 함께 호출하든, 배열 리터럴을 생성하든 <code>instance</code>인 [1, 2]가 만들어집니다.</p></li></ul><ul><li><code>instance</code>의 <code>__proto__</code>은 Array.prototype을 참조함으로 <code>instance</code>가 push, pop, forEach 등 Array 메서드를 자신의 것처럼 호출할 수 있습니다.(<code>__proto__</code>가 생략 가능하도록 설계돼 있기 때문에)</li></ul><ul><li><strong>한편 <code>Array의 prototype 프로퍼티 내부</code>에 있지 않은 <code>from, isArray</code> 등의 메서드들은 <code>instance</code>가 직접 호출할 수 없습니다. 이들은 <code>Array 생성자 함수</code>에서 직접 접근해야 실행 가능합니다.</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array 생성자 함수를 원본으로하는 instance인 arr</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// __proto__ 생략 가능으로 인한 Array 메서드 직접 호출 </span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;); <span class="comment">// (o)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array의 prototype 프로퍼티 내부에 없는 메서드는</span></span><br><span class="line"><span class="comment">// instance가 직접 호출 불가능</span></span><br><span class="line">arr.isArray(); <span class="comment">// (x) TypeError: arr.isArray is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array 생성자 함수에서 직접 접근하여 실행해야 됨</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr); <span class="comment">// (o) true</span></span><br></pre></td></tr></table></figure><hr><h3 id="constructor-프로퍼티"><a href="#constructor-프로퍼티" class="headerlink" title="constructor 프로퍼티"></a>constructor 프로퍼티</h3><p><code>생성자 함수</code>의 프로퍼티인 <code>prototype</code> 객체 내부에는 <code>constructor</code> 프로퍼티가 있습니다.<br><code>instance</code>의 <code>__proto__</code> 객체 내부에도 마찬가지로 존재합니다.<br><code>constructor</code> 프로퍼티는 원래의 생성자 함수(자기 자신)를 참조하고,<br><code>instance</code>로부터 그 원형을 알 수 있는 수단으로 <code>instance</code>와의 관계에 있어 필요한 정보입니다.</p><figure class="highlight js"><figcaption><span>constructor 프로퍼티 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">arr.__proto__.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">arr.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> arr.constructor(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [3, 4]</span></span><br></pre></td></tr></table></figure><hr><h4 id="다양한-constructor-접근-방법"><a href="#다양한-constructor-접근-방법" class="headerlink" title="다양한 constructor 접근 방법"></a>다양한 constructor 접근 방법</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'사람1'</span>); <span class="comment">// Person &#123; name: "사람1" &#125; true</span></span><br><span class="line"><span class="keyword">var</span> p1Proto = <span class="built_in">Object</span>.getPrototypeOf(p1);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person.prototype.constructor(<span class="string">'사람2'</span>); <span class="comment">// Person &#123; name: "사람2" &#125; true</span></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> p1Proto.constructor(<span class="string">'사람3'</span>); <span class="comment">// Person &#123; name: "사람3" &#125; true</span></span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> p1.__proto__.constructor(<span class="string">'사람4'</span>); <span class="comment">// Person &#123; name: "사람4" &#125; true</span></span><br><span class="line"><span class="keyword">var</span> p5 = <span class="keyword">new</span> p1.constructor(<span class="string">'사람5'</span>); <span class="comment">// Person &#123; name: "사람5" &#125; true</span></span><br><span class="line"></span><br><span class="line">[p1, p2, p3, p4, p5].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p, p <span class="keyword">instanceof</span> Person);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>다음은 모두 동일한 대상을 가리키게 됩니다.</strong></li></ul><pre><code>1. [Constructor]2. [instance].__proto__.constructor3. [instance].constructor4. Object.getPrototypeOf([instance]).constructor5. [Constructor].prototype.constructor</code></pre><ul><li><strong>다음은 모두 동일한 객체에 접근할 수 있습니다.</strong></li></ul><pre><code>1. [Constructor].prototype2. [instance].__proto__3. [instance]4. Object.getPrototypeOf([instance])</code></pre><ul><li>따라서 p1 부터 p5까지 모두 Person의 instance입니다.</li></ul><hr><h2 id="prototype_chain">프로토타입 체인</h2><hr><h3 id="메서드-오버라이드"><a href="#메서드-오버라이드" class="headerlink" title="메서드 오버라이드"></a>메서드 오버라이드</h3><p><code>instance</code>가 동일한 이름의 프로퍼티 또는 메서드를 가지고 있는 상황이라면</p><p><code>instance.method()</code> 형태로 호출했을 때<br><code>instance.__proto__.method</code>가 아닌 <code>instance</code>객체에 있는 해당 <code>method</code>가 호출됩니다.<br>여기서 일어난 현상을 메서드 위에 메서드를 덮어씌웠다고 하여 <mark>메서드 오버라이드</mark>라고합니다.</p><ul><li>자바스크립트 엔진은 프로퍼티(혹은 메서드)를 찾을 때 가장 가까운 대상인 자신의 프로퍼티를 먼저 검색하고, 없으면 그다음으로 가까운 대상인 &#95;&#95;proto&#95;&#95;를 검색합니다.<br>그러므로 메서드 오버라이드 됐을 때 &#95;&#95;proto&#95;&#95;에 있는 메서드는 우선 순위에서 밀려 호출되지 않는 것입니다.</li></ul><hr><h4 id="메서드-오버라이드된-상태에서-prototype에-있는-메서드에-접근법"><a href="#메서드-오버라이드된-상태에서-prototype에-있는-메서드에-접근법" class="headerlink" title="메서드 오버라이드된 상태에서 prototype에 있는 메서드에 접근법"></a>메서드 오버라이드된 상태에서 prototype에 있는 메서드에 접근법</h4><blockquote><p>instance.&#95;&#95;proto&#95;&#95;.method()</p></blockquote><p>형태로 호출하면 정상적으로 <code>prototype</code>에 있는 <code>method</code>에 접근할 수 있습니다.<br>하지만 <code>this</code>가 <code>instance</code>를 바라보지 않고 있습니다.</p><p><code>call</code>이나 <code>apply</code>를 사용하면</p><blockquote><p>instance.&#95;&#95;proto&#95;&#95;.method.call(thisArg) 형태로 작성하여 <code>this</code> 대상을 지정합니다.</p></blockquote><hr><h3 id="프로토타입-체인"><a href="#프로토타입-체인" class="headerlink" title="프로토타입 체인"></a>프로토타입 체인</h3><p><mark>자바스크립트의 모든 객체의 최상위 객체에는 Object 객체가 존재합니다.</mark></p><p>따라서 모든 객체의 <code>__proto__</code>에는 <code>Object.prototype</code>이 연결됩니다.</p><p><strong>Array 객체를 예시로 든 최상위 객체 Object와의 구조 도식(<del>prototype 역시 객체입니다.</del>)</strong></p><p><img src="/images/%EA%B0%9D%EC%B2%B4%EC%9D%98_%EC%B5%9C%EC%83%81%EC%9C%84_%EA%B0%9D%EC%B2%B4_Object.png" alt="객체의 최상위 객체 Object"></p><ul><li><p>앞에서 <code>__proto__</code>는 생략가능한 프로퍼티이므로 <code>배열[]</code>에서 <code>Array.prototype</code> 내부의 메서드를 직접 호출할 수 있었습니다. </p></li><li><p>마찬가지로 <code>배열[]</code>의 <code>__proto__</code>를 계속 따라가다 보면 <code>Object.prototype</code>이 있으므로 <code>Object.prototype</code>의 내부 메서드도 직접 호출할 수 있습니다.</p></li></ul><hr><p>이러한 <code>__proto__</code> 프로퍼티 내부에 다시 <code>__proto__</code>프로퍼티가 연쇄적으로 이어진 것을<br><strong>프로토타입 체인</strong>(<code>prototype chain</code>)이라 하고, </p><p>이 체인을 따라 검색하는 것을 <strong>프로토타입 체이닝</strong>(<code>prototype chaining</code>)이라고 합니다.</p><hr><h3 id="객체-전용-메서드의-예외사항"><a href="#객체-전용-메서드의-예외사항" class="headerlink" title="객체 전용 메서드의 예외사항"></a>객체 전용 메서드의 예외사항</h3><p>어떤 생성자 함수이든 <code>prototype</code>은 객체이기 때문에 <code>Object.prototype</code>이 언제나 프로토타입 체인의 최상단에 존재하게 됩니다.</p><p>따라서 <strong>객체에서만 사용할 메서드는 다른 데이터 타입처럼 프로토타입 객체 안에 정의할 수 없습니다.</strong></p><p><strong>객체에서만 사용할 메서드를 <code>Object.prototype</code>내부에 정의한다면 다른 데이터 타입도 해당 메서드를 사용할 수 있게 되기 때문입니다.</strong>(참조형 데이터뿐 아니라 기본형 데이터도 &#95;&#95;proto&#95;&#95;에 반복적으로 접근하여 도달하는 최상위 객체가 Object.prototype이 됨)</p><ul><li>이 같은 이유로 객체만을 대상으로 동작하는 <strong>Object 전용 메서드</strong>들은 부득이 <code>Object.prototype</code>이 아닌 <code>Object</code>에 정적(<code>static</code>)메서드로 구현돼 있습니다.</li></ul><p><img src="/images/Object_prototype.png" alt="Object-prototype"></p><ul><li>한편 <code>Object.prototype</code>에는 어떤 데이터에서도 활용할 수 있는 범용적인 메서드들만 있습니다.<br>toString, hasOwnProperty, valueOf, isPrototypeOf 등은 모든 <code>instance</code>가 직접 호출할 수 있습니다.</li></ul><hr><h3 id="다중-프로토타입-체인"><a href="#다중-프로토타입-체인" class="headerlink" title="다중 프로토타입 체인"></a>다중 프로토타입 체인</h3><p>자바스크립트의 기본 내장 데이터 타입들은 모두 프로토타입 체인 1단계(객체), 2단계(나머지)로 끝나는 경우가 있지만 <strong>사용자가 새롭게 만드는 경우 계속해서 단계를 추가할 수 있습니다.</strong></p><p><code>__proto__</code>를 연결하는 방법은 <code>__proto__</code>가 가리키는 대상을<br>생성자 함수의 <code>prototype</code>이 연결하고자 하는 상위 생성자 함수의 <code>instance</code>를 지정해 주면됩니다.</p><figure class="highlight js"><figcaption><span>다중 프로토타입 체인</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Grade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>[i] = args[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.length = args.length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Grade(<span class="number">100</span>, <span class="number">80</span>);</span><br><span class="line">Grade.prototype = [];</span><br></pre></td></tr></table></figure><ul><li><code>Grade</code>의 <code>instance</code>는 여러개의 인자를 받아 각 순서대로 인덱싱해서 저장합니다. (<code>유사배열객체</code>)</li></ul><ul><li><code>변수 g</code> 가 <code>Grade</code>의 <code>instance</code>를 바라봅니다.</li></ul><ul><li><code>유사배열객체</code>지만 <strong>배열 메서드를 직접 호출할 수 있게</strong> 만들고자 합니다.</li></ul><ul><li><code>g.__proto__</code> 즉, <code>Grade.prototype</code>이 배열의 <code>instance</code>를 바라보게 해주면 됩니다.<br><code>Grade.prototype = [];</code></li></ul><ul><li><code>Grade</code>의 <code>instance</code>인 <code>g</code>에서 직접 배열 메서드를 사용할수 있게됩니다.</li></ul><p><code>g</code>의 <code>instance</code>는 프로토타입 체인을 따라 <code>Grade.prototype</code>, <code>Array.prototype</code>, <code>Object.prototype</code>에 접근할 수 있는 <strong>3단계 다중프로토타입 체인 형식</strong>입니다.</p><hr><h2 id="point">정리</h2><ul><li><code>__proto__</code>는 생략 가능한 속성이므로 <code>instance</code>에서 상위 객체의 <code>prototype</code>에 있는 메서드를 직접호출할 수 있습니다.</li></ul><ul><li><code>Constructor</code> <strong>프로퍼티는 생성자 함수 자기 자신을 가리킵니다.</strong><br><code>instance</code>에서 <strong>자신의 생성자 함수가 무엇인지 알고자할 때 필요한 수단입니다.</strong></li></ul><ul><li><strong>참조형 데이터뿐 아니라 기본형 데이터도 &#95;&#95;proto&#95;&#95;에 반복적으로 접근하면 최상위 객체 <code>Object.prototype</code>에 도달하게 됩니다.</strong></li></ul><ul><li><code>Object.prototype</code>에는 <strong>모든 데이터 타입에서 사용할 수 있는 범용적인 메서드만 존재합니다.</strong><br><code>Object</code> 전용 메서드는 <code>Object</code> 생성자 함수에 정적(<code>static</code>)하게 담겨있습니다.</li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/05/prototype-Core-JavaScript/#disqus_thread</comments>
    </item>
    
    <item>
      <title>클로저 -Core JavaScript</title>
      <link>https://hdw0903.github.io/2020/05/03/%ED%81%B4%EB%A1%9C%EC%A0%80-Core-JavaScript/</link>
      <guid>https://hdw0903.github.io/2020/05/03/%ED%81%B4%EB%A1%9C%EC%A0%80-Core-JavaScript/</guid>
      <pubDate>Sun, 03 May 2020 06:56:17 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;클로저 (Closure)&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/03/클로저-Core-JavaScript/#closure&quot;&gt;클로저의 의미 및 원리 이해&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/03/클로저-Core-JavaScript/#closure_memory&quot;&gt;클로저와 메모리 관리&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/03/클로저-Core-JavaScript/#closure_ex&quot;&gt;클로저 활용 사례&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;콜백 함수 내부에서 외부 데이터를 사용하고자 할 때&lt;/li&gt;
&lt;li&gt;접근 권한 제어 (정보 은닉)&lt;/li&gt;
&lt;li&gt;부분 적용 함수&lt;/li&gt;
&lt;li&gt;커링 함수&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/05/03/클로저-Core-JavaScript/#&quot;&gt;정리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<ul><li>클로저 (Closure)<ul><li><a href="/2020/05/03/클로저-Core-JavaScript/#closure">클로저의 의미 및 원리 이해</a></li><li><a href="/2020/05/03/클로저-Core-JavaScript/#closure_memory">클로저와 메모리 관리</a></li><li><a href="/2020/05/03/클로저-Core-JavaScript/#closure_ex">클로저 활용 사례</a><ul><li>콜백 함수 내부에서 외부 데이터를 사용하고자 할 때</li><li>접근 권한 제어 (정보 은닉)</li><li>부분 적용 함수</li><li>커링 함수</li></ul></li><li><a href="/2020/05/03/클로저-Core-JavaScript/#">정리</a></li></ul></li></ul><a id="more"></a><hr><h2 id="closure">클로저의 의미 및 원리 이해</h2><p>클로저(<code>Closure</code>)는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성입니다.<br>자바스크립트 고유의 개념이 아니라서 <code>ECMAScript</code> 명세에서도 클로저의 정의를 다루지 않고 있고, 다양한 문헌에서 제각각 클로저를 다르게 정의 또는 설명하고 있습니다.</p><p>다양한 서적에서 클로저를 한 문장으로 요약해서 설명하는 부분들을 소개하면 다음과 같습니다.</p><pre><code>* 자신을 내포하는 함수의 컨텍스트에 접근할 수 있는 함수* 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 것* 함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수* 이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수* 자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합* 로컬 변수를 참조하고 있는 함수 내의 함수* 자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수</code></pre><p><strong>MDN</strong> 에서는 클로저를 함수와 그 함수가 선언될 당시의 <code>LexicalEnvironment</code>의 조합이라고 소개하고,<br>다른 말로 클로저는 내부 함수에서 외부 함수의 범위로 접근할 수 있게 해주는 함수라고 합니다.</p><p>선언될 당시의 <code>LexicalEnvironment</code>는 실행 컨텍스트의 구성 요소 중 하나인 <code>outerEnvironmentReference</code>에 해당합니다.<br><code>LexicalEnvironment</code>의 <code>environmentRecord</code>와 <code>outerEnvironmentReference</code>에 의해 변수의 유효범위인 스코프가 결정되고 스코프 체인이 가능해집니다.</p><ul><li><code>컨텍스트 A</code>에서 선언한 <code>내부 함수B</code>의 실행 컨텍스트가 활성화된 시점에서는 B의 <code>outerEnvironmentReference</code>가 참조하는 대상인 A의 <code>LexicalEnvironment</code>에도 접근이 가능해 집니다. A에서는 B에서 선언한 변수에 접근할 수 없지만 B에서는 A에 선언한 변수에 접근이 가능해집니다.</li></ul><ul><li>이런 내부함수에서 외부 변수를 참조하게 되는 경우가, 선언될 당시의 <code>LexicalEnvironment</code>와의 상호관계(조합)의 의미가 됩니다.</li></ul><figure class="highlight js"><figcaption><span>외부 함수의 변수를 참조하는 내부 함수 -1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++a);</span><br><span class="line">  &#125;;</span><br><span class="line">  inner();</span><br><span class="line">&#125;;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><ol><li><code>outer</code> 함수에 변수 a를 선언했고 1을 할당했습니다.</li></ol><ol start="2"><li><code>outer</code>의 내부함수인 <code>inner</code> 함수에서 a의 값을 1 증가시키고 출력합니다.</li></ol><ul><li><code>inner</code>함수 내부에서는 a를 선언하지 않았기 때문에 <code>environmentRecord</code>에서 값을 찾지 못하므로 <code>outerEnvironmentReference</code>에 지정된 상위 컨텍스트인 <code>outer</code>의 <code>LexicalEnvironment</code>에 접근하여 다시 a를 찾습니다.</li></ul><ul><li><code>outer</code> 함수의 실행 컨텍스트가 종료되면 <code>LexicalEnvironment</code>에 저장된 식별자들(a,inner)에 대한 참조를 지웁니다. 그러면 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 <code>가비지컬렉터(GC)</code>의 수집 대상이 됩니다.</li></ul><figure class="highlight js"><figcaption><span>외부 함수의 변수를 참조하는 내부 함수 -2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> inner();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> outer2 = outer();</span><br><span class="line"><span class="built_in">console</span>.log(outer2); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>이 예제 역시 <code>inner</code>함수 내부에서 외부변수인 a를 사용했습니다.<br><code>inner</code> 함수를 실행한 결과를 <code>return</code> 하고 나면 <code>outer</code>함수의 실행 컨텍스트가 종료된 시점에는 a변수를 참조하는 대상이 없어집니다. 그러므로 예제1과 마찬가지로 식별자들의(a,inner) 값들은 <code>가비지컬렉터(GC)</code>에 의해 소멸됩니다.</li></ul><ul><li>예제1과 예제2는 <code>outer</code>함수의 실행 컨텍스트가 종료되기 이전에 <code>inner</code> 함수의 실행 컨텍스트가 종료돼 있으며, 이후 별도로 <code>inner</code> 함수를 호출할 수 없다는 공통점을 가지고 있습니다.</li></ul><p><mark>그렇다면 outer의 실행 컨텍스트가 종료된 후에도 inner 함수를 호출할 수 있게 만들면 어떨까요?</mark></p><figure class="highlight js"><figcaption><span>외부 함수의 변수를 참조하는 내부 함수 -3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> outer2 = outer();</span><br><span class="line"><span class="built_in">console</span>.log(outer2()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(outer2()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ol><li><code>return inner()</code> 함수의 실행 결과가 아닌 <code>return inner</code> 함수 자체를 반환했습니다.</li></ol><ol start="2"><li><code>outer2</code> 변수는 <code>outer</code>함수의 실행 결과인 <code>inner</code>함수 자체를 참조하게 됩니다.<br><code>outer2</code> 호출시 <code>inner</code> 함수가 실행됨.</li></ol><ol start="3"><li><code>inner</code> 함수의 실행 컨텍스트의 <code>environmentRecord</code>에는 수집할 정보가 없습니다. <code>outerEnvironmentReference</code>에는 <code>inner</code> 함수가 선언된 위치의 <code>LexicalEnvironment</code>가 참조복사 됩니다. <code>inner</code>함수는 <code>outer</code> 함수 내부에서 선언됐으므로, <code>outer</code> 함수의 <code>LexicalEnvironment</code>가 담깁니다.</li></ol><ol start="4"><li>스코프체이닝에 따라 <code>outer</code>에서 선언한 변수 a에 접근해 1만큼 증가시킨후 결과 값인 2를 반환하고, <code>inner</code>함수의 실행 컨텍스트가 종료됩니다.</li></ol><ol start="5"><li><code>outer2</code><u>를 다시 호출하면 같은 방식으로 a의 값을 2에서 1만큼 증가시켜 그 결과 값인 3을 반환합니다.</u></li></ol><p><strong>중요 포인트</strong></p><ul><li><code>outer</code>함수의 실행 컨텍스트는 종료된 상태인데 어떻게 외부 함수의 변수(<code>outer</code> 함수의 <code>LexicalEnvironment</code>)에 접근할 수 있는 걸까?</li></ul><ul><li>이는 가비지컬렉터의 동작 방식 때문입니다.</li></ul><ul><li><mark>어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 가비지컬렉터(GC)의 대상이 되지 않습니다.</mark></li></ul><ul><li><code>outer</code> 함수는 실행 종료 시점에 <code>inner</code> 함수를 반환했습니다. <code>outer</code> 함수는 <code>inner</code>함수를 참조하게 되고 외부함수인 <code>outer</code>의 실행이 종료되었지만 내부함수인 <code>inner</code>함수는 언젠가 <code>outer()</code>형식 (변수 outer2와 같은)으로 호출될 수 있습니다.</li></ul><ul><li><code>inner</code> 함수 역시 <code>outer</code>의 변수를 참조하므로 실행 컨텍스트가 활성화 되면 <code>outerEnvironmentReference</code>가 <code>outer</code> 함수의 <code>LexicalEnvironment</code>를 필요로 하게되므로 <code>가비지컬렉터(GC)</code>의 대상에서 제외됩니다. 그 덕에 <code>inner</code>함수가 외부함수의 변수에 접근할 수 있는 것입니다.</li></ul><ul><li>클로저란 :<br><mark>외부 함수에서 선언한 변수를 참조하는 내부 함수를 외부로 전달할 경우 외부 함수의 실행 컨텍스트가 종료된 이후에도 변수가 사라지지 않는 현상</mark></li></ul><ul><li>“내부함수를 외부로 전달”이 return만을 의미하는 것은 아님. 다른 경우도 존재</li></ul><figure class="highlight js"><figcaption><span>return 없이 클로저가 발생하는 경우</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) setInterval/setTimeout</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>; <span class="comment">// 외부 함수의 변수를 내부 함수에서</span></span><br><span class="line">  <span class="keyword">var</span> intervalId = <span class="literal">null</span>; <span class="comment">// 참조하고 있으므로 GC의 대상이 되지 않음. </span></span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++a &gt;= <span class="number">10</span>) &#123; <span class="comment">// 외부 함수의 변수a 참조</span></span><br><span class="line">      clearInterval(intervalId); <span class="comment">// 외부 함수의 변수 intervalId 참조</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;;</span><br><span class="line">  intervalId = setInterval(inner, <span class="number">1000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>별도의 외부객체인 window의 메서드(setTimeout 또는 setInterval)에 전달할 콜백 함수 내부에서 지역변수를 참조합니다.</p><figure class="highlight js"><figcaption><span>return 없이 클로저가 발생하는 경우</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (2) eventListener</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>);</span><br><span class="line">  button.innerText = <span class="string">'click'</span>;</span><br><span class="line">  button.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++count, <span class="string">'times clicked'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>별도의 외부 객체인 DOM의 메서드 (addEventListener)에 등록할 handler 함수 내부에서 지역변수를 참조합니다.</p><p><mark>두 상황 모두 두 지역변수를 참조하는 내부함수를 외부에 전달했기 때문에 클로저(closure)입니다.</mark></p><hr><h2 id="closure_memory">클로저와 메모리 관리</h2><ul><li><p><mark>클로저는 객체지향과 함수형 모두를 아우르는 매우 중요한 개념입니다.</mark></p></li><li><p>메모리 누수:<br>개발자의 의도와 달리 어떤 값의 참조 카운트가 0이 되지 않아 GC의 수거 대상이 되지 않는 경우 발생할 수 있습니다.<br>(개발자가 의도적으로 참조 카운트가 0이 되지 않게 설계한 경우는 ‘누수’라는 표현은 맞지 않습니다.)</p></li><li><p><mark>클로저는 의도대로 설계한 “메모리 소모”에 대한 관리법을 잘 파악해서 적용하는 것이 중요합니다.</mark></p></li></ul><hr><h3 id="메모리-관리-방법"><a href="#메모리-관리-방법" class="headerlink" title="메모리 관리 방법"></a>메모리 관리 방법</h3><p>클로저는 필요에 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생합니다.<br>그렇다면 <u>필요성이 사라진 시점</u>에는 더는 메모리를 소모하지 않게 해주면 됩니다.</p><p>참조 카운트를 0으로 만들면(GC의 작동원리) GC가 수거해 갈것이고, 이때 소모됐던 메모리가 회수됩니다.</p><ul><li>참조 카운트를 0으로 만드는 방법 ?<br>식별자에 참조형이 아닌 기본형 데이터(보통 <code>null</code>이나 <code>undefined</code>)를 할당하면 됩니다.</li></ul><figure class="highlight js"><figcaption><span>클로저의 메모리 관리 - return</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) return에 의한 클로저의 메모리 해제</span></span><br><span class="line"><span class="keyword">var</span> outer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(outer());</span><br><span class="line"><span class="built_in">console</span>.log(outer());</span><br><span class="line">outer = <span class="literal">null</span>; <span class="comment">// outer 식별자의 inner 함수 참조를 끊음</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>클로저의 메모리 관리 - setInterval</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (2) setInterval에 의한 클로저의 메모리 해제</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> intervalId = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++a &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      clearInterval(intervalId);</span><br><span class="line">      inner = <span class="literal">null</span>; <span class="comment">// inner 식별자의 함수 참조를 끊음</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;;</span><br><span class="line">  intervalId = setInterval(inner, <span class="number">1000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>클로저의 메모리 관리 - eventListener</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (3) eventListener에 의한 클로저의 메모리 해제</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>);</span><br><span class="line">  button.innerText = <span class="string">'click'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> clickHandler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++count, <span class="string">'times clicked'</span>);</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      button.removeEventListener(<span class="string">'click'</span>, clickHandler);</span><br><span class="line">      clickHandler = <span class="literal">null</span>; <span class="comment">// clickHandler 식별자의 함수 참조를 끊음</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  button.addEventListener(<span class="string">'click'</span>, clickHandler);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><hr><h2 id="closure_ex">클로저 활용 사례</h2><p>클로저가 실제로 등장하는 활용 사례</p><h3 id="콜백-함수-내부에서-외부-데이터를-사용하고자-할-때"><a href="#콜백-함수-내부에서-외부-데이터를-사용하고자-할-때" class="headerlink" title="콜백 함수 내부에서 외부 데이터를 사용하고자 할 때"></a>콜백 함수 내부에서 외부 데이터를 사용하고자 할 때</h3><p>대표적인 콜백 함수 중 하나인 이벤트 리스너에 관한 예시</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'peach'</span>];</span><br><span class="line"><span class="keyword">var</span> $ul = <span class="built_in">document</span>.createElement(<span class="string">'ul'</span>); <span class="comment">// (공통 코드)</span></span><br><span class="line"></span><br><span class="line">fruits.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// (A)</span></span><br><span class="line">  <span class="keyword">var</span> $li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  $li.innerText = fruit;</span><br><span class="line">  $li.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// (B)</span></span><br><span class="line">    alert(<span class="string">'your choice is '</span> + fruit);</span><br><span class="line">  &#125;);</span><br><span class="line">  $ul.appendChild($li);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild($ul);</span><br></pre></td></tr></table></figure><ol><li><code>fruits</code> 변수를 순회하며 <code>li</code>를 생성하고 각 <code>li</code>를 클릭하면 해당 리스너의 콜백 함수가 실행됩니다.</li></ol><ol start="2"><li><code>forEach</code>메서드에 넘겨준 익명의 콜백 함수(A)는 내부에서 외부 변수를 사용하지 않으므로 클로저가 없습니다.</li></ol><ol start="3"><li><code>addEventListener</code>에 넘겨준 콜백 함수(B)에는 함수내의 <code>fruit</code>라는 외부 변수를 참조하고 있으므로 클로저가 있습니다.</li></ol><ol start="4"><li>(A)는 <code>fruits</code>의 개수만큼 실행되며, 그때마다 새로운 실행 컨텍스트가 생성됩니다.</li></ol><ol start="5"><li>(A)의 실행 종료 여부와 무관하게 클릭 이벤트에 의해 각 컨텍스트의 (B)가 실행될 때는 (B)의 <code>outerEnvironmentReference</code>가 (A)의 <code>LexicalEnvironment</code>를 참조하게 됩니다.</li></ol><ol start="6"><li>따라서 (B)함수가 참조할 예정인 변수 <code>fruit</code>에 대해서는 (A)함수가 종료된 후에도 <code>CG</code> 대상에서 제외되어 계속 참조 가능하게 됩니다.</li></ol><p>그런데 (B)함수의 쓰임이 콜백 함수에 국한되지 않는 경우라면 반복을 줄이기 위해 (B)함수를 외부로 분리하는 편이 나을 수 있습니다.</p><p>따라서 다음은 <code>fruit</code>을 인자로 받아 출력하는 형태입니다.</p><figure class="highlight js"><figcaption><span>콜백 함수 외부로꺼내어 공통 함수로 사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'peach'</span>];</span><br><span class="line"><span class="keyword">var</span> $ul = <span class="built_in">document</span>.createElement(<span class="string">'ul'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> alertFruit = <span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'your choice is '</span> + fruit);</span><br><span class="line">&#125;;</span><br><span class="line">fruits.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  $li.innerText = fruit;</span><br><span class="line">  $li.addEventListener(<span class="string">'click'</span>, alertFruit);</span><br><span class="line">  $ul.appendChild($li);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild($ul);</span><br><span class="line">alertFruit(fruits[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><ul><li><p>공통 함수로 사용하고자 콜백 함수를 외부로 꺼내어 <code>alertFruit</code>라는 변수에 담았습니다.<br><code>alertFruit</code>를 직접 실행할 수 있게 되었습니다.</p></li><li><p>하지만 각 <code>li</code>를 클릭하면 클릭한 대상의 과일명이 아닌 <code>[object MouseEvent]</code>라는 값이 출력됩니다.<br>이는 콜백 함수의 인자에 대한 제어권을 <code>addEventListener</code>가 가진 상태이며, <code>addEventListener</code>는 콜백 함수를 호출할 때 첫 번째 인자에 “이벤트 객체”를 주입하기 때문입니다.</p></li></ul><p>이 문제는 <code>bind</code>메서드를 활용하면 해결할 수 있습니다.</p><figure class="highlight js"><figcaption><span>bind 메서드 사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'peach'</span>];</span><br><span class="line"><span class="keyword">var</span> $ul = <span class="built_in">document</span>.createElement(<span class="string">'ul'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> alertFruit = <span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'your choice is '</span> + fruit);</span><br><span class="line">&#125;;</span><br><span class="line">fruits.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  $li.innerText = fruit;</span><br><span class="line">  $li.addEventListener(<span class="string">'click'</span>, alertFruit.bind(<span class="literal">null</span>, fruit));</span><br><span class="line">  $ul.appendChild($li);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild($ul);</span><br></pre></td></tr></table></figure><ul><li><p>하지만 <code>bind</code>를 활용하면 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점과,<br>함수 내부에서 <code>this</code>가 참조하는 값이 달라지는점을 감안해야 합니다.</p></li><li><p>이러한 변경사항 마저 발생하지 않게 만들려면 <code>bind</code>메서드가 아닌 다른 방식으로 만들어야 합니다.</p></li></ul><figure class="highlight js"><figcaption><span>고차함수를 사용하여 클로저를 적극적으로 활용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'peach'</span>];</span><br><span class="line"><span class="keyword">var</span> $ul = <span class="built_in">document</span>.createElement(<span class="string">'ul'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> alertFruitBuilder = <span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'your choice is '</span> + fruit);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">fruits.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  $li.innerText = fruit;</span><br><span class="line">  $li.addEventListener(<span class="string">'click'</span>, alertFruitBuilder(fruit));</span><br><span class="line">  $ul.appendChild($li);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild($ul);</span><br></pre></td></tr></table></figure><ul><li>고차함수란 함수를 인자로 받거나 함수를 리턴하는 함수입니다.</li></ul><ol><li><code>alertFruit</code> 함수 대신 <code>alertFruitBuilder</code>라는 이름의 함수를 작성했습니다.<br><code>alertFruitBuilder</code> 함수 내부에서는 다시 익명함수를 반환합니다.</li></ol><ol start="2"><li>이 익명함수 내부의 코드가 기존의 <code>alertFruit</code> 함수의 코드입니다. </li></ol><ol start="3"><li><code>alertFruitBuilder</code> 함수를 실행하면서 <code>fruit</code> 값을 인자로 전달하면, 함수의 실행 결과가<br>다시 함수(<code>return function</code>)가 되며, 이렇게 반환된 함수를 리스너의 콜백 함수로써 전달할 것입니다.</li></ol><ol start="4"><li>클릭 이벤트가 발생하면 이 함수의 실행 컨텍스트가 열리면서 <code>alertFruitBuilder</code>의 파라미터로 넘어온 <code>fruit</code>를 <code>outerEnvironmentReference</code>에 의해 참조할 수 있게됩니다.<br>즉, <code>alertFruitBuilder</code>의 실행 결과로 반환된 함수에는 클로저가 존재합니다.</li></ol><hr><h4 id="콜백-함수-내부에서-외부변수를-참조하기-위한-방법-정리"><a href="#콜백-함수-내부에서-외부변수를-참조하기-위한-방법-정리" class="headerlink" title="콜백 함수 내부에서 외부변수를 참조하기 위한 방법 정리."></a>콜백 함수 내부에서 외부변수를 참조하기 위한 방법 정리.</h4><ol><li>콜백 함수를 내부함수로 선언하여 외부변수를 직접 참조하는 방법.(<code>GC의 참조카운트</code> 이용)</li></ol><ol start="2"><li><code>bind</code>메서드를 활용하여 값을 직접넘겨주는 방법. 클로저는 발생하지 않지만 몇가지 제약이 생김</li></ol><ol start="3"><li>콜백 함수를 고차함수로 바꿔서 클로저를 적극적으로 활용하는 방법. </li></ol><hr><h3 id="접근-권한-제어-은닉"><a href="#접근-권한-제어-은닉" class="headerlink" title="접근 권한 제어(은닉)"></a>접근 권한 제어(은닉)</h3><p>정보은닉(information hiding)은 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈간의 결합도를 낮추고 유연성을 높이고자 하는 현대 프로그래밍 언어의 중요한 개념 중 하나입니다.</p><p>흔히 접근 권한에는 <code>public</code>, <code>private</code>, <code>protected</code> 세 종류가 있습니다.</p><ul><li><p><code>public</code> : 외부에서 접근 가능한 것</p></li><li><p><code>private</code> : 내부에서만 사용하며 외부에 노출되지 않는 것</p></li></ul><p>자바스크립트는 기본적으로 변수 자체에 이러한 접근 권한을 직접 부여하도록 설계돼 있지 않습니다. 하지만 접근 권한 제어가 불가능한 것은 아닙니다. 클로저를 이용하면 함수 차원에서 <code>public</code>한 값과 <code>private</code>한 값을 구분하는 것이 가능합니다.</p><figure class="highlight js"><figcaption><span>public/private -return</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> outer2 = outer();</span><br><span class="line"><span class="built_in">console</span>.log(outer2());</span><br><span class="line"><span class="built_in">console</span>.log(outer2());</span><br></pre></td></tr></table></figure><p>이전에 본 클로저 예제 입니다.</p><ul><li><code>outer</code>함수를 종료할 때 <code>inner</code> 함수를 반환함으로써 <code>outer</code>함수의 지역변수 a의 값을 외부에서도 읽을 수 있게 되었습니다.</li></ul><ul><li>이처럼 클로저를 활용하면 외부 스코프에서 함수 내부의 변수들 중 선택적으로 일부 변수에 대한 접근 권환을 부여할 수 있습니다. (<code>return</code>을 활용하여)</li></ul><ul><li><code>outer</code>함수는 외부(전역 스코프)로 부터 철저하게 격리된 닫힌 공간입니다.<br>외부에서는 외부 공간에 노출돼 있는 <code>outer</code>라는 변수를 통해 <code>outer</code>함수를 실행할 수는 있지만, <code>outer</code>함수 내부에는 어떠한 개입도 할 수 없습니다.<br>외부에는 오직 <code>outer</code>함수가 <code>return</code>한 정보에만 접근할 수 있습니다.<br><code>return</code>값이 외부에 정보를 제공하는 유일한 수단이 됩니다.</li></ul><ul><li>외부에 제공하고자 하는 정보들을 모아서 <code>return</code>하고, 내부에서만 사용할 정보들은 <code>return</code>하지 않는 것으로 접근 권한 제어가 가능한 것입니다.</li></ul><ul><li><code>return</code>한 변수들은 공개 맴버(<code>public member</code>)가 되고, 그렇지 않은 변수들은 비공개 맴버(<code>private member</code>)가 되는 것입니다.</li></ul><hr><h4 id="접근-권한-제어를-통한-보드-게임-예시"><a href="#접근-권한-제어를-통한-보드-게임-예시" class="headerlink" title="접근 권한 제어를 통한 보드 게임 예시"></a>접근 권한 제어를 통한 보드 게임 예시</h4><p>자동차 경주 보드 게임.</p><p>규칙</p><pre><code>1. 각 턴마다 주사위를 굴려 나온 숫자(km)만큼 이동.2. 차량별로 연료량(fuel)과 연비(power)는 무작위로 생성.3. 남은 연료가 이동할 거리에 필요한 연료보다 부족하면 이동 불가.4. 모든 유저가 이동할 수 없는 턴에 게임이 종료됨.5. 게임 종료 시 가장 멀리 이동해 있는 사람이 승리.</code></pre><figure class="highlight js"><figcaption><span>규칙에 따른 간단한 자동차 객체</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = &#123;</span><br><span class="line">  fuel: <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">10</span>), <span class="comment">// 연료(L)</span></span><br><span class="line">  power: <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">3</span> + <span class="number">2</span>), <span class="comment">// 연비(km/L)</span></span><br><span class="line">  moved: <span class="number">0</span>, <span class="comment">// 총 이동거리</span></span><br><span class="line">  run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> km = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">var</span> wasteFuel = km / <span class="keyword">this</span>.power;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fuel &lt; wasteFuel) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'이동불가'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.fuel -= wasteFuel;</span><br><span class="line">    <span class="keyword">this</span>.moved += km;</span><br><span class="line">    <span class="built_in">console</span>.log(km + <span class="string">'km 이동 (총 '</span> + <span class="keyword">this</span>.moved + <span class="string">'km)'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>위 코드는 <code>run</code> 메서드를 실행할 때마다 <code>car</code>객체의 <code>fuel</code>, <code>moved</code> 값이 변합니다.</p><p>하지만 자바스크립트를 아는사람이 <code>car</code>객체의 <code>fuel</code>, <code>power</code>, <code>moved</code>값을 직접 지정해 버린다면 공평한 게임이 되지 못합니다. </p><ul><li>이렇게 값을 바꾸지 못하도록 객체가 아닌 함수로 만들고, 필요한 맴버만을 <code>return</code>할 필요가 있습니다.</li></ul><figure class="highlight js"><figcaption><span>함수를 실행함으로써 객체 생성</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createCar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fuel = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">10</span>); <span class="comment">// 연료(L)</span></span><br><span class="line">  <span class="keyword">var</span> power = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">3</span> + <span class="number">2</span>); <span class="comment">// 연비(km / L)</span></span><br><span class="line">  <span class="keyword">var</span> moved = <span class="number">0</span>; <span class="comment">// 총 이동거리</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> moved() &#123;</span><br><span class="line">      <span class="keyword">return</span> moved;</span><br><span class="line">    &#125;,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> km = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">6</span>);</span><br><span class="line">      <span class="keyword">var</span> wasteFuel = km / power;</span><br><span class="line">      <span class="keyword">if</span> (fuel &lt; wasteFuel) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'이동불가'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      fuel -= wasteFuel;</span><br><span class="line">      moved += km;</span><br><span class="line">      <span class="built_in">console</span>.log(km + <span class="string">'km 이동 (총 '</span> + moved + <span class="string">'km). 남은 연료: '</span> + fuel);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> car = createCar();</span><br></pre></td></tr></table></figure><ul><li><p><code>createCar</code>라는 함수를 실행함으로써 객체를 생성하게 했습니다. <code>fuel</code>, <code>power</code> 변수는 비공개 맴버로 지정해 외부에서의 접근을 제한했고, <code>moved</code>변수는 <code>getter</code>만을 부여함으로써 “읽기전용” 속성을 부여했습니다.</p></li><li><p>이제 외부에서는 오직 <code>run</code>메서드를 실행하는 것과 현재의 <code>moved</code>값을 확인하는 두 가지 동작만 할 수 있습니다.</p></li><li><p><code>run</code>메서드를 다른 내용으로 덮어씌우는 어뷰징은 여전히 가능한 상태이긴 하지만 앞서의 코드보다 훨씬 안전한 코드가 됐습니다. 이런 어뷰징까지 막기 위해서는 객체를 <code>return</code>하기 전에 미리 변경할 수 없게끔 조치를 취해야 합니다.</p></li></ul><figure class="highlight js"><figcaption><span>Object.freeze</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createCar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fuel = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">10</span>); <span class="comment">// 연료(L)</span></span><br><span class="line">  <span class="keyword">var</span> power = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">3</span> + <span class="number">2</span>); <span class="comment">// 연비(km / L)</span></span><br><span class="line">  <span class="keyword">var</span> moved = <span class="number">0</span>; <span class="comment">// 총 이동거리</span></span><br><span class="line">  <span class="keyword">var</span> publicMembers = &#123;</span><br><span class="line">    <span class="keyword">get</span> moved() &#123;</span><br><span class="line">      <span class="keyword">return</span> moved;</span><br><span class="line">    &#125;,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> km = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">6</span>);</span><br><span class="line">      <span class="keyword">var</span> wasteFuel = km / power;</span><br><span class="line">      <span class="keyword">if</span> (fuel &lt; wasteFuel) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'이동불가'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      fuel -= wasteFuel;</span><br><span class="line">      moved += km;</span><br><span class="line">      <span class="built_in">console</span>.log(km + <span class="string">'km 이동 (총 '</span> + moved + <span class="string">'km). 남은 연료: '</span> + fuel);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(publicMembers);</span><br><span class="line">  <span class="keyword">return</span> publicMembers;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> car = createCar();</span><br></pre></td></tr></table></figure><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">Object.freeze</a>를 사용하여 <code>publicMembers</code>객체를 동결객체로 만들었습니다.</li></ul><ul><li><code>Object.freeze</code>메서드는 호출된 객체의 직속 속성만 동결하며 내부의 속성 값이 객체라면 그 객체는 동결되지 않아 추가/제거/재할당의 대상이 될 수 있으므로 (얕은동결) 주의하여야 합니다.</li></ul><hr><h4 id="클로저를-활용해-접근권한-제어-방법-정리"><a href="#클로저를-활용해-접근권한-제어-방법-정리" class="headerlink" title="클로저를 활용해 접근권한 제어 방법 정리"></a>클로저를 활용해 접근권한 제어 방법 정리</h4><ol><li><p>함수에서 지역변수 및 내부함수 등을 생성</p></li><li><p>외부에 접근권한을 주고자 하는 대상들로 구성된 참조형 데이터(대상이 여럿일 경우 객체 또는 배열, 하나일 경우 함수)를 return 합니다.</p></li><li><p>return한 변수들은 공개 맴버가 되고, 그렇지 않은 변수들은 비공개 맴버가 됩니다.</p></li></ol><hr><h3 id="부분-적용-함수"><a href="#부분-적용-함수" class="headerlink" title="부분 적용 함수"></a>부분 적용 함수</h3><p>부분 적용 함수(<code>partially applied function</code>)란 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가. 나중에 나머지 인자를 넘길 때 원래 함수의 실행 결과를 얻을 수 있게 하는 함수입니다.</p><p><code>this</code>를 바인딩해야 하는 점을 제외하면 <code>bind</code>메서드의 실행 결과가 바로 부분 적용 함수입니다.</p><figure class="highlight js"><figcaption><span>bind - 부분 적용 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    result += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> addPartial = add.bind(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(addPartial(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure><p><code>addPartial</code> 함수에 <code>this</code>값 <code>null</code>과 인자 5개를 미리 적용하고, 대기합니다.<br>추후에 추가적으로 인자들을 전달하며 호출하면 대기중이던 인자들과 차례대로 적용되어 실행합니다.</p><p><code>add</code>함수는 <code>this</code>값을 사용하지 않지만, <code>bind</code>메서드는 <code>this</code>값을 변경할 수 밖에 없기 때문에 메서드에서는 사용할 수 없을 것 같습니다.<br><code>this</code>에 관여하지 않는 다른 방법의 부분 적용 함수가 필요합니다.</p><figure class="highlight js"><figcaption><span>부분 적용 함수 구현(1)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> partial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> originalPartialArgs = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">var</span> func = originalPartialArgs[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'첫 번째 인자가 함수가 아닙니다.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> partialArgs = <span class="built_in">Array</span>.prototype.slice.call(originalPartialArgs, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> restArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, partialArgs.concat(restArgs));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    result += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> addPartial = partial(add, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(addPartial(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)); <span class="comment">// 55</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = &#123;</span><br><span class="line">  name: <span class="string">'강아지'</span>,</span><br><span class="line">  greet: partial(<span class="function"><span class="keyword">function</span>(<span class="params">prefix, suffix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prefix + <span class="keyword">this</span>.name + suffix;</span><br><span class="line">  &#125;, <span class="string">'왈왈, '</span>),</span><br><span class="line">&#125;;</span><br><span class="line">dog.greet(<span class="string">'입니다!'</span>); <span class="comment">// 왈왈, 강아지입니다.</span></span><br></pre></td></tr></table></figure><ul><li>첫 번째 인자에 원본 함수를, 두 번째 인자 이후부터는 미리 적용할 인자들을 전달하고, 반환할 함수(부분 적용 함수)에서는 다시 나머지 인자들을 받아 이들은 한곳으로 모아(<code>concat</code>) 원본 함수를 호출(<code>apply</code>)합니다. 또한 실행 시점의 <code>this</code>를 그대로 반영함으로써 <code>this</code>에는 아무런 영향을 주지 않게 되었습니다.</li></ul><hr><h4 id="디바운스-debounce"><a href="#디바운스-debounce" class="headerlink" title="디바운스(debounce)"></a>디바운스(debounce)</h4><p>실무에서 부분 함수를 사용하기에 적합한 예로 디바운스(<code>debounce</code>)가 있습니다.</p><p>디바운스(<code>debounce</code>)는 짧은 시간 동안 동일한 이벤트가 많이 발생한 경우 이를 전부 처리하지 않고 처음 또는 마지막에 발생한 이벤트에 대해 한 번만 처리하는 것으로, <code>scroll</code>, <code>wheel</code>, <code>mousemove</code>, <code>resize</code>등에 적용하기 좋습니다.</p><figure class="highlight js"><figcaption><span>부분 적용 함수 - 디바운스</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeoutId = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(eventName, <span class="string">'event 발생'</span>);</span><br><span class="line">    clearTimeout(timeoutId);</span><br><span class="line">    timeoutId = setTimeout(func.bind(self, event), wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> moveHandler = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'move event 처리'</span>); &#125;;</span><br><span class="line"><span class="keyword">var</span> wheelHandler = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'wheel event 처리'</span>); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(</span><br><span class="line">  <span class="string">'mousemove'</span>,</span><br><span class="line">  debounce(<span class="string">'move'</span>, moveHandler, <span class="number">500</span>));</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(</span><br><span class="line">  <span class="string">'mousewheel'</span>,</span><br><span class="line">  debounce(<span class="string">'wheel'</span>, wheelHandler, <span class="number">700</span>));</span><br></pre></td></tr></table></figure><ul><li><code>debounce</code> 함수는 출력 용도로 지정한 <code>eventName</code>과 실행할 함수(<code>func</code>),마지막으로 발생한 이벤트인지 여부를 판단하기 위한 대기시간 (<code>wait(</code>(ms))을 받습니다.</li></ul><ul><li>내부에서는 <code>timeoutId</code> 변수를 생성하고, 클로저로 <code>EventListener</code>에 의해 호출될 함수를 반환합니다. 반환될 함수 내부에서는 <code>setTimeout</code>을 사용하기 위해 <code>this</code>를 별도의 변수에 담고 <code>clearTimeout</code>으로 대기큐를 초기화하게 했습니다.</li></ul><ul><li>마지막으로 <code>setTimeout</code>으로 <code>wait</code> 시간만큼 지연시킨 다음, 원래의 <code>func</code>를 호출하는 형태입니다.</li></ul><ul><li>최초의 event가 발생하면 <code>timeoutId = setTimeout(func,bind(self,event),wait)</code>에 의해 timeout의 대기열에 ‘wait 시간 뒤에 func를 실행 함’이라는 내용이 담깁니다. 그런데 <code>wait</code>시간이 경과하기 전에 동일한 event가 발생하게 되면 앞의 <code>clearTimeout(timeoutId)</code>에 의해 앞에 저장했던 대기열을 초기화하고, 다시 <code>timeoutId = setTimeout(func,bind(self,event),wait)</code>에서 새로운 대기열을 등록합니다.</li></ul><ul><li>결국 각 동일한 이벤트가 이전 이벤트로 부터 <code>wait</code>시간 내에 다시 발생하는 한 마지막에 발생한 이벤트만이 초기화되지 않고 실행됩니다.</li></ul><ul><li><code>debounce</code>함수에서 클로저로 처리되는 변수는 <code>eventName</code>, <code>func</code>, <code>wait</code>, <code>timeoutId</code>입니다.</li></ul><hr><h3 id="커링-함수-currying-function"><a href="#커링-함수-currying-function" class="headerlink" title="커링 함수(currying function)"></a>커링 함수(currying function)</h3><p>커링 함수(currying function)란 <mark>여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서</mark><br><strong>순차적으로 호출될 수 있게 체인 형태로 구성한 것을 말합니다.</strong><br><del>(앞서 살펴본 부분 적용 함수와 기본적인 맥락은 일치하지만 몇 가지 다른 점이 있습니다.)</del></p><ul><li><p>커링은 <strong>한 번에 하나의 인자만 전달하는 것을 원칙으로 합니다.</strong></p></li><li><p><u>중간 과정상의 함수를 실행한 결과는 그다음 인자를 받기 위해 대기만 할 뿐으로</u>, <strong>마지막 인자가 전달되기 전까지는 원본 함수가 실행되지 않습니다.</strong></p></li><li><p>부분 적용 함수와 달리 커링 함수는 필요한 상황에 직접 만들어 쓰기 용이합니다. 필요한 인자 개수만큼 함수를 만들어 계속 <code>return</code>해 주다가 마지막에 조합해서 <code>return</code>해주면 되기 때문이죠.</p></li></ul><figure class="highlight js"><figcaption><span>ES5 커링 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> curry5 = <span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> func(a, b, c, d, e);</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getMax = curry5(<span class="built_in">Math</span>.max);</span><br><span class="line"><span class="built_in">console</span>.log(getMax(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><ul><li><p>5개의 인자를 받아서 처리하기위해 코드가 길어졌습니다.</p></li><li><p><code>ES6</code>의 화살표 함수를 사용하면 다음과 같이 처리할 수 있습니다.</p></li></ul><figure class="highlight js"><figcaption><span>ES6 커링처리</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> curry5 = <span class="function"><span class="params">func</span> =&gt;</span> <span class="function"><span class="params">a</span> =&gt;</span> <span class="function"><span class="params">b</span> =&gt;</span> <span class="function"><span class="params">c</span> =&gt;</span> <span class="function"><span class="params">d</span> =&gt;</span> <span class="function"><span class="params">e</span> =&gt;</span> func(a,b,c,d,e);</span><br></pre></td></tr></table></figure><ul><li><p><strong>참고 :</strong></p><ul><li><p>각 단계에서 받은 인자들은 모두 마지막 단계에서 참조할 것이므로 <code>GC</code>의 대상이 되지않고<br>메모리 저장되었다가, 마지막에 호출되어 실행 컨텍스트가 종료된 이후에 한꺼번에 <code>GC</code>의 수거 대상이됩니다.</p></li><li><p><strong>커링 함수가 유용한 경우</strong>는 <u>당장 필요한 정보만 받아 전달하고 또 필요한 정보가 들어오면 전달하는 식으로 결국 마지막 인자가 넘어갈 때까지 함수 실행을 미루는 셈이 됩니다.</u><br><strong>이를 함수형 프로그래밍에서 지연실행(<code>lazy execution</code>)이라고 합니다.</strong><br>즉, 원하는 시점까지 지연시켰다가 실행하는 것이 유용한 상황이라면 커링을 쓰기에 적합할 수 있습니다.</p></li></ul></li></ul><hr><h2 id="closure">정리</h2><ul><li>클로저란 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상입니다.</li></ul><ul><li>내부 함수를 외부로 전달하는 방법에는 함수를 return하는 경우뿐아니라 콜백으로 전달하는 경우도 포함됩니다.</li></ul><ul><li>클로저는 그 본질이 메모리를 계속 차지하는 개념이므로 더는 사용하지 않게 된 클로저에 대해서는 메모리를 차지하지 않도록 관리해줄 필요가 있습니다.</li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/05/03/%ED%81%B4%EB%A1%9C%EC%A0%80-Core-JavaScript/#disqus_thread</comments>
    </item>
    
    <item>
      <title>콜백 함수 -Core JavaScript</title>
      <link>https://hdw0903.github.io/2020/04/30/%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98-Core-JavaScript/</link>
      <guid>https://hdw0903.github.io/2020/04/30/%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98-Core-JavaScript/</guid>
      <pubDate>Thu, 30 Apr 2020 11:03:50 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;콜백 함수&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/30/콜백-함수-Core-JavaScript/#callback&quot;&gt;콜백 함수란?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/30/콜백-함수-Core-JavaScript/#callback_제어권&quot;&gt;제어권&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;인자&lt;/li&gt;
&lt;li&gt;this&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/30/콜백-함수-Core-JavaScript/#callback_function&quot;&gt;콜백 함수는 함수다.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/30/콜백-함수-Core-JavaScript/#callback_this_binding&quot;&gt;콜백 함수 내부의 this에 다른 값 바인딩하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/30/콜백-함수-Core-JavaScript/#callback_hell&quot;&gt;콜백 지옥과 비동기 제어&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<ul><li>콜백 함수<ul><li><a href="/2020/04/30/콜백-함수-Core-JavaScript/#callback">콜백 함수란?</a></li><li><a href="/2020/04/30/콜백-함수-Core-JavaScript/#callback_제어권">제어권</a><ul><li>인자</li><li>this</li></ul></li><li><a href="/2020/04/30/콜백-함수-Core-JavaScript/#callback_function">콜백 함수는 함수다.</a></li><li><a href="/2020/04/30/콜백-함수-Core-JavaScript/#callback_this_binding">콜백 함수 내부의 this에 다른 값 바인딩하기</a></li><li><a href="/2020/04/30/콜백-함수-Core-JavaScript/#callback_hell">콜백 지옥과 비동기 제어</a></li></ul></li></ul><a id="more"></a><hr><h2 id="callback">콜백 함수란?</h2><p>콜백 함수(<code>callback function</code>)는 다른 코드의 인자로 넘겨주는 함수 입니다.</p><p><code>callback</code>은 부르다, 호출하다, 실행하다의 의미인 <code>call</code> 과 되돌아오다 <code>back</code>의 합성어로,<br>되돌아 호출하다라는 의미로 이해할 수 있습니다.</p><p>특정 <code>함수a</code>를 호출하면서 ‘특정 조건일때 <code>함수b</code>를 실행해서 알려달라는’요청을 보내는 것입니다.<br><code>함수a</code>의 입장에서는 해당 조건이 갖춰졌는지 여부를 스스로 판단하고 <code>함수b</code>를 직접 호출합니다.</p><p>이처럼 콜백 함수는 다른 코드(함수 또는 메서드)에게 인자를 넘겨줌으로써 그 <mark>제어권도 함께 위임한 함수</mark>입니다. (<strong>콜백 함수를 위임받은 코드는 자체적인 내부 로직에 의해 이 콜백 함수를 적절한 시점에 실행합니다</strong>.)</p><hr><h2 id="callback_제어권">제어권</h2><p>몇 가지 예제</p><hr><h3 id="호출-시점"><a href="#호출-시점" class="headerlink" title="호출 시점"></a>호출 시점</h3><figure class="highlight js"><figcaption><span>setInterval</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="number">2.</span> <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">  <span class="keyword">if</span> (++count &gt; <span class="number">4</span>) clearInterval(timer);</span><br><span class="line">&#125;, <span class="number">300</span>);</span><br></pre></td></tr></table></figure><p>우선 <code>setInterval</code> 메서드의 형태를 살펴보면 다음과 같습니다.</p><blockquote><p>var 참조변수(interval ID) = scope.setInterval(func, delay[, param1, param2, …]);</p></blockquote><ul><li>scope :<br><code>Window</code> 객체 또는 <code>Worker</code>의 인스턴스가 들어올 수 있습니다. 두 객체 모두 <code>setInterval</code> 메서드를 제공하기 때문입니다. 일반적인 브라우저 환경에서는 <code>window</code>를 생략하고 함수처럼 사용할 수 있습니다.</li></ul><ul><li>매개변수<br><code>func</code>, <code>delay</code> 값을 반드시 전달해야 합니다.<br>세 번째 매개변수 부터는 선택적 파라미터로 <code>func</code> 함수를 실행할때 전달할 파라미터입니다.<br><code>func</code>에 넘겨준 함수는 매 <code>delay(ms)</code>마다 실행되며, 그 결과로 어떤 값도 반환하지 않습니다.</li></ul><ul><li><code>setInterval</code>을 실행하면 반복적으로 실행되는 내용 자체를 특정할 수 있는 고유 ID 값이 반환됩니다.<br>이를 변수에 담는 이유는 반복 실행되는 중간에 종료(<code>clearInterval</code>)할 수 있게 하기 위해서 입니다.</li></ul><ol><li><p><code>count</code> 변수를 선언하고 0을 할당합니다.</p></li><li><p><code>timer</code> 변수를 선언하고 setInterval 결과를 할당했습니다.</p></li></ol><p><strong>위에 코드를 콜백 함수를 확인하기 쉽게 수정했습니다.</strong></p><figure class="highlight js"><figcaption><span>callback - setInterval</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> cbFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">  <span class="keyword">if</span> (++count &gt; <span class="number">4</span>) clearInterval(timer);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> timer = setInterval(cbFunc, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- 실행 결과 --</span></span><br><span class="line"><span class="comment">// 0  (0.3초)</span></span><br><span class="line"><span class="comment">// 1  (0.6초)</span></span><br><span class="line"><span class="comment">// 2  (0.9초)</span></span><br><span class="line"><span class="comment">// 3  (1.2초)</span></span><br><span class="line"><span class="comment">// 4  (1.5초)</span></span><br></pre></td></tr></table></figure><ul><li><code>timer</code>변수에는 <code>setInterval</code>의 ID 값이 담기게 됩니다.</li></ul><ul><li><code>setInterval</code>에 전달한 첫 번째 인자인 <code>cbFunc</code>함수(이 함수가 곧 콜백함수입니다.)는 0.3초마다 자동으로 실행될 것입니다. </li></ul><ul><li>콜백 함수 내부에서는 <code>count</code> 값을 출력하고 1씩 증가시키며, <code>count</code>값이 4보다 크면 반복 실행이 종료됩니다.</li></ul><ul><li>제어권<br><code>setInterval</code> 메서드에 첫 번째 인자로 <code>cbFunc</code> 함수를 넘겨주자 제어권을 넘겨받은 <code>setInterval</code> 메서드는 0.3초마다 (지정된 시점) 이 익명 함수를 실행했습니다. 이처럼 <u>콜백 함수의 제어권을 넘겨받은 코드</u>는 <mark>콜백 함수 호출 시점에 대한 제어권</mark>을 가집니다.</li></ul><h3 id="인자-파라미터"><a href="#인자-파라미터" class="headerlink" title="인자 (파라미터)"></a>인자 (파라미터)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(currentValue, index);</span><br><span class="line">  <span class="keyword">return</span> currentValue + <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- 실행 결과 --</span></span><br><span class="line"><span class="comment">// 10 0</span></span><br><span class="line"><span class="comment">// 20 1</span></span><br><span class="line"><span class="comment">// 30 2</span></span><br><span class="line"><span class="comment">// [15, 25, 35]</span></span><br></pre></td></tr></table></figure><ol><li><p><code>newArr</code> 변수를 선언하고 오른쪽에 배열 <code>[10, 20, 30]</code>에 <code>map</code> 메서드를 호출하고 그 결과를 할당합니다.</p><p><code>map</code>메서드의 동작 방식부터 살펴보도록 하겠습니다.</p><blockquote><p>Array.prototype.map(callback[, thisArg])<br>callback : function(currentValue, index, array)</p></blockquote><p><code>map</code> 메서드는 Array.prototype에 담긴 메서드입니다.</p><ul><li><p>파라미터</p><ul><li>첫 번째 인자: <code>callback</code> 함수를 받습니다</li><li>두 번째 인자: 생략가능한 파라미터이며, 콜백 함수 내부에서 <code>this</code>로 인식할 대상을 지정합니다. 생략시 일반적인 함수와 마찬가지로 전역객체를 참조하게 됩니다.</li></ul></li><li><p>반환 값</p><ul><li><code>map</code>메서드는 메서드의 대상이 되는 배열의 모든 요소들을 차례대로 불러와 콜백 함수를 반복 호출하고, <u>콜백 함수의 실행 결과를 모아 새로운 배열</u>을 반환합니다.</li></ul></li><li><p><code>callback</code>함수<br>콜백 함수의 첫 번째 인자에는 배열의 요소중 <code>현재값</code>, 두 번째 인자에는 <code>현재값의 index</code>, 세 번째 인자에는 <code>map</code>메서드의 <code>대상이 되는 배열</code>이 담깁니다.</p></li></ul></li></ol><ol start="2"><li><code>map</code> 메서드는 배열<code>[10, 20, 30]</code>의 각 요소를 차례대로 꺼내어 콜백 함수를 실행합니다.</li></ol><ol start="3"><li>첫 번째 요소에 대한 콜백 함수는 <code>currentValue</code>에 10이, <code>index</code>에는 index 0이 담긴 채 실행됩니다 <code>return currentValue + 5;</code> 코드를 실행하여 <code>(10 + 5)</code> 값인 <code>15</code>가 반환됩니다.</li></ol><ol start="4"><li>두 번째 요소에 대한 콜백 함수는 <code>currentValue</code>에 20이, <code>index</code>에는 index 1이 담긴 채 실행됩니다 <code>return currentValue + 5;</code> 코드를 실행하여 <code>(20 + 5)</code> 값인 <code>25</code>가 반환됩니다.</li></ol><ol start="5"><li>세 번째 요소에 대한 콜백 함수는 <code>currentValue</code>에 30이, <code>index</code>에는 index 2이 담긴 채 실행됩니다 <code>return currentValue + 5;</code> 코드를 실행하여 <code>(30 + 5)</code> 값인 <code>35</code>가 반환됩니다.</li></ol><ol start="6"><li>모든 요소에 대한 콜백 함수를 마치고 나면 <code>[15, 25, 35]</code>라는 새로운 배열이 만들어져 <code>newArr</code>변수에 할당됩니다.</li></ol><ol start="7"><li><code>console.log(newArr)</code> 코드에서 <code>newArr</code>변수에 할당된 새로운 배열이 출력됩니다.</li></ol><p><strong>중요 포인트</strong></p><p><code>콜백 함수</code>의 파라미터 순서를 바꾸면 안됩니다. <code>currentValue</code>, <code>index</code>순 이어야하며<br>바뀐다면 전혀 다른 값을 반환할 것입니다.</p><p><del>엔진은 파라미터로 받은 값의 단어(name)를 인식하는 것이 아니라 순서(첫 번째, 두 번째)에 의해서만 각각을 구분하고 인식합니다.</del> </p><hr><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>콜백 함수 내부에서의 <code>this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;, <span class="number">300</span>); <span class="comment">// (1) Window &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// (2) Window &#123; ... &#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML += <span class="string">'&lt;button id="a"&gt;클릭&lt;/button&gt;'</span>;</span><br><span class="line"><span class="number">3.</span> <span class="built_in">document</span>.body.querySelector(<span class="string">'#a'</span>).addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, e); <span class="comment">// (3) &lt;button id="a"&gt;클릭&lt;/button&gt;</span></span><br><span class="line">  &#125; <span class="comment">// MouseEvent &#123; isTrusted: true, ... &#125;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li><code>setTimeout</code>은 내부에서 콜백 함수를 호출할 때 <code>call</code>메서드의 첫 번째 인자로 전역객체를 넘기게 됩니다. 콜백 함수 내부에서 <code>this</code>가 전역객체를 가리키게됩니다. </li></ol><ol start="2"><li><code>forEach</code>는 ‘별도의 인자로 this를 받는 경우’에 해당하지만 별도로 <code>this</code>를 지정해주지 않았기 때문에 전역객체를 가리키게됩니다.</li></ol><ol start="3"><li><code>addEventListener</code>는 내부에서 콜백 함수를 호출할 때 <code>call</code>메서드의 첫 번째 인자에 <code>addEventListener</code>메서드의 <code>this</code>를 넘기도록 정의되어 있습니다. 때문에 콜백 함수 내부에서의 <code>this</code>는 <code>addEventListener</code>를 호출한 주체 <code>HTML</code> 엘리먼트를 가리키게 됩니다. </li></ol><hr><h2 id="callback_function">콜백 함수는 함수다.</h2><p><strong>콜백 함수로 객체의 메서드를 전달하더라도 그 메서드는 메서드가 아닌 함수로 호출됩니다.</strong></p><figure class="highlight js"><figcaption><span>메서드를 콜백 함수로 전달한 경우</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">  vals: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  logValues: <span class="function"><span class="keyword">function</span>(<span class="params">v, i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, v, i);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">2.</span> obj.logValues(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// &#123; vals: [1, 2, 3], logValues: f &#125; 1 2</span></span><br><span class="line"><span class="number">3.</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>].forEach(obj.logValues); <span class="comment">// Window &#123; ... &#125; 4 0</span></span><br><span class="line"><span class="comment">// Window &#123; ... &#125; 5 1</span></span><br><span class="line"><span class="comment">// Window &#123; ... &#125; 6 2</span></span><br></pre></td></tr></table></figure><ol><li><code>obj</code> 객체의 <code>logValues</code>는 메서드로 정의됐습니다.</li></ol><ol start="2"><li>메서드의 이름 앞에 점(.)이 있으니 메서드로서 호출한 것 입니다. <code>this</code>는 <code>obj</code>를 가리키고 파라미터로 넘겨준 1, 2와 함께 출력됩니다.</li></ol><ol start="3"><li><code>obj.logValues</code>메서드를 <code>forEach</code> 함수의 콜백 함수로서 지정했습니다.<br><code>obj</code>를 <code>this</code>로 하는 메서드를 그대로 전달한 것이 아니라, <code>obj.logValues</code>가 가리키는 함수만 전달한 것입니다.<br>이 함수는 메서드로서 호출할 때가 아닌 한 <code>obj</code>와의 직접적인 연관이 없어집니다.<br><code>forEach</code>에 의해 콜백이 함수로서 호출되고, 별도로 <code>this</code>를 지정하지 않았으므로 <code>this</code>는 전역객체를 참조합니다.</li></ol><p><strong>중요 포인트</strong></p><p>어떤 함수의 인자(파라미터)에 객체의 메서드를 전달하더라도 메서드가 아닌 함수일 뿐입니다.<br>이 차이를 정확히 이해하는 것이 중요합니다.</p><hr><h2 id="callback_this_binding">콜백 함수 내부의 this에 다른 값 바인딩 하기</h2><p>콜백 함수에서 <code>this</code>를 지정하지 않으면 전역객체를 참조하게 되므로<br>객체의 메서드를 콜백 함수로 전달하면 해당 객체를 <code>this</code>로 참조할 수 없게됩니다.</p><p>별도의 인자(<code>thisArg</code>)로 <code>this</code>를 받는 함수의 경우에는 원하는 값을 넘겨주면 되지만 그렇지 않은 경우에는 <code>this</code>의 제어권도 넘겨주게 되므로 사용자가 임의로 값을 변경할 수 없습니다.</p><p>그래서 <makr>전통적으로는 <code>this</code>를 다른 변수에 담아 콜백 함수로 활용할 함수에서는 <code>this</code>대신 그 변수를 사용하게 하고, 이를 클로저로 만드는 방식이 많이 쓰였습니다.</mark></p><figure class="highlight js"><figcaption><span>콜백 함수 내부의 this에 다른 값을 바인딩 - 전통적인 방법(변수 사용)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">'obj1'</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(self.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> callback = obj1.func();</span><br><span class="line">setTimeout(callback, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><ol><li><code>obj1.func</code> 메서드 내부에서 <code>self</code> 변수에 <code>this</code>를 담고, 익명 함수를 선언하고 반환했습니다.</li></ol><ol start="2"><li><code>obj1.func</code>를 호출하면 앞서 선언한 내부함수가 반환되어 <code>callback</code> 변수에 할당됩니다.</li></ol><ol start="3"><li>이 <code>callback</code>변수를 <code>setTimeout</code> 함수에 인자로 전달하면 1초(1000ms) 뒤 <code>callback</code>이 실행되면서 <code>&quot;obj1&quot;</code>을 반환할 것입니다.</li></ol><p><strong>중요 포인트</strong><br>이 방식은 <code>this</code>를 다른 변수에 담아 함수내에서 <code>this</code> 대신 그 변수를 사용하게하여 실제로는 <code>this</code>를 사용하지 않을뿐더러 번거롭습니다.</p><ul><li><p>ES5에 등장한 <code>bind</code>메서드를 사용하면 더욱 간편히 <code>this</code>를 바인딩할 수 있습니다.</p><figure class="highlight js"><figcaption><span>콜백 함수 내부의 this에 다른 값 바인딩 - bind 메서드 사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">'obj1'</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">setTimeout(obj1.func.bind(obj1), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">'obj2'</span> &#125;;</span><br><span class="line">setTimeout(obj1.func.bind(obj2), <span class="number">1500</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>bind</code> 메서드의 첫 번째 인자(<code>thisArg</code>)로 <code>this</code>로 지정할 값을 전달합니다.<br>함수가 실행될때 <code>this</code>는 <code>thisArg</code>로 전달받은 값을 참조하게 됩니다.</p></li></ul><hr><h2 id="callback_hell">콜백 지옥과 비동기 제어</h2><ul><li><p>콜백 지옥(<code>callback hell</code>)이란?</p><p>콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상.<br>주로 이벤트 처리나 서버 통신과 같이 비동기적인 작업을 수행하기 위해 이런 형태가 자주 등장하곤 하는데, 가독성이 떨어질 뿐더러 코드를 수정하기도 힘들다.</p></li></ul><ul><li><p>비동기(<code>asynchronous</code>)란?</p><p>동기(<code>synchronous</code>)의 반대말로 <mark>동기적인 코드는 현재 실행 중인 코드가 완료된 후에야 다음 코드를 실행하는 방식</mark><br>비동기적 코드는 <mark>현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어갑니다.</mark></p></li></ul><ol><li><p>사용자의 요청에 의해 특정 시간이 경과되기 전까지 어떤 함수의 실행을 보류한다거나 -<code>setTimeout</code></p></li><li><p>사용자의 직접적인 개입이 있을 때 어떤 함수를 실행하도록 대기한다거나 -<code>addEventListener</code></p></li><li><p>웹브라우저 자체가 아닌 별도의 대상에 무언가를 요청하고 그에 대한 응답이 왔을 때 어떤 함수를 실행하도록 대기하는 등 -<code>XMLHttpRequest</code></p><p><del>CPU의 계산에 의해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드입니다.</del><br><mark>별도의 요청, 실행 대기, 보류 등과 관련된 코드는 비동기적인 코드입니다.</mark></p></li></ol><ul><li>현대의 자바스크립트는 웹의 복잡도가 높아진 만큼 비동기적인 코드의 비중이 예전보다 훨씬 높아진 상황입니다. (콜백 지옥에 빠지기도 훨씬 쉬워졌습니다.)</li></ul><hr><p><strong>간단한 콜백 지옥 예시를 살펴봅시다.</strong></p><figure class="highlight js"><figcaption><span>callback-hell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coffeeList = name;</span><br><span class="line">    <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        coffeeList += <span class="string">', '</span> + name;</span><br><span class="line">        <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line"></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">            coffeeList += <span class="string">', '</span> + name;</span><br><span class="line">            <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line"></span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">                coffeeList += <span class="string">', '</span> + name;</span><br><span class="line">                <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">              &#125;, <span class="number">500</span>, <span class="string">'카페라떼'</span>);</span><br><span class="line">          &#125;, <span class="number">500</span>, <span class="string">'카페모카'</span>);</span><br><span class="line">      &#125;, <span class="number">500</span>, <span class="string">'아메리카노'</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>, <span class="string">'에스프레소'</span>);</span><br></pre></td></tr></table></figure><ul><li><p>0.5 초마다 커피 목록을 수집하고 출력합니다. 각 콜백은 커피 이름을 전달하고 <code>coffeeList</code>에 추가합니다. </p></li><li><p>실행에는 지장이 없는 코드입니다만, 들여쓰기 수준이 과도하게 깊어졌을 뿐더러 수정하기도 불편하고 값이 전달되는 순서가 아래에서 위로 향하고 있어 어색하게도 느껴집니다.</p></li></ul><p>가독성 문제와 어색함을 동시에 해결하는 방법은 익명 콜백함수를 모두 기명함수로 전환하는 방법이 있습니다…?!</p><hr><figure class="highlight js"><figcaption><span>기명함수로 변환</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coffeeList = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addEspresso = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  coffeeList = name;</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">  setTimeout(addAmericano, <span class="number">500</span>, <span class="string">'아메리카노'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> addAmericano = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  coffeeList += <span class="string">', '</span> + name;</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">  setTimeout(addMocha, <span class="number">500</span>, <span class="string">'카페모카'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> addMocha = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  coffeeList += <span class="string">', '</span> + name;</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">  setTimeout(addLatte, <span class="number">500</span>, <span class="string">'카페라떼'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> addLatte = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  coffeeList += <span class="string">', '</span> + name;</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setTimeout(addEspresso, <span class="number">500</span>, <span class="string">'에스프레소'</span>);</span><br></pre></td></tr></table></figure><ul><li>익명함수를 기명함수로 변환하므로서 콜백 지옥을 해결한 예시입니다.</li></ul><p>함수 선언과 함수 호출을 구분한다면 코드의 가독성을 높여 코드를 위에서 아래로 읽어내려가는데 어려움이 없습니다. 변수가 전역으로 전개되긴 했지만 즉시 실행 함수 등으로 감싸면 해결할 수 있는 문제입니다.</p><p>하지만 코드명을 일일이 따라다녀야 하므로 오히려 헷갈릴 여지도 있습니다.</p><ul><li>자바스크립트는 비동기적인 작업들을 동기적으로(혹은 동기적인 것처럼 보이도록) 처리해주는 방법을 고안했고, 그 결과 <code>ES6</code>에서 <code>Promise</code>, <code>Generator</code>등이 도입됐으며, <code>ES8(ES2017)</code>에서는 <code>async</code>, <code>wait</code>가 도입됐습니다.</li></ul><hr><p><strong>이들을 활용한 표현법도 알아봅시다.</strong></p><figure class="highlight js"><figcaption><span>비동기 작업의 동기적 표현 -Promise</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'에스프레소'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    resolve(name);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">prevName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name = prevName + <span class="string">', 아메리카노'</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">        resolve(name);</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">prevName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name = prevName + <span class="string">', 카페모카'</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">        resolve(name);</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">prevName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name = prevName + <span class="string">', 카페라떼'</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">        resolve(name);</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>ES6</code>의 <code>Promise</code>를 이용한 방법입니다. <code>new</code>연산자와 함께 호출한 <code>Promise</code>의 인자로 넘겨주는 콜백 함수는 호출할 때 바로 실행되지만 내부에 <code>resolve</code> 또는 <code>reject</code> 함수를 호출하는 구문이 있을 경우 둘 중하나가 충족되어 실행되기 전까지는 <code>.then</code> 또는 <code>.catch</code> 구문으로 넘어가지 않습니다.</p><p>따라서 비동기 작업이 완료될 때 <code>resolve</code> 또는 <code>reject</code>를 호출하는 방법으로 비동기 작업의 동기적 표현이 가능합니다.</p><hr><p>다음은 위에 코드의 반복적인 내용을 함수화 하여 더욱 짧게 표현한 것입니다.</p><figure class="highlight js"><figcaption><span>Promise 동기적표현 함수화</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addCoffee = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">prevName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> newName = prevName ? prevName + <span class="string">', '</span> + name : name;</span><br><span class="line">        <span class="built_in">console</span>.log(newName);</span><br><span class="line">        resolve(newName);</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">addCoffee(<span class="string">'에스프레소'</span>)()</span><br><span class="line">  .then(addCoffee(<span class="string">'아메리카노'</span>))</span><br><span class="line">  .then(addCoffee(<span class="string">'카페모카'</span>))</span><br><span class="line">  .then(addCoffee(<span class="string">'카페라떼'</span>));</span><br></pre></td></tr></table></figure><hr><ul><li>Generator 활용</li></ul><figure class="highlight js"><figcaption><span>비동기 작업의 동기적 표현 -Generator</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addCoffee = <span class="function"><span class="keyword">function</span>(<span class="params">prevName, name</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    coffeeMaker.next(prevName ? prevName + <span class="string">', '</span> + name : name);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> coffeeGenerator = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> espresso = <span class="keyword">yield</span> addCoffee(<span class="string">''</span>, <span class="string">'에스프레소'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(espresso);</span><br><span class="line">  <span class="keyword">var</span> americano = <span class="keyword">yield</span> addCoffee(espresso, <span class="string">'아메리카노'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(americano);</span><br><span class="line">  <span class="keyword">var</span> mocha = <span class="keyword">yield</span> addCoffee(americano, <span class="string">'카페모카'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(mocha);</span><br><span class="line">  <span class="keyword">var</span> latte = <span class="keyword">yield</span> addCoffee(mocha, <span class="string">'카페라떼'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(latte);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> coffeeMaker = coffeeGenerator();</span><br><span class="line">coffeeMaker.next();</span><br></pre></td></tr></table></figure><p><code>ES6</code>의 <code>Generator</code>를 이용한 방법입니다.<br><code>Generator</code> 함수를 실행하여 <code>Iterator</code>을 반환받고 <code>Iterator</code>의 메서드 <code>next</code>를 사용할 수 있습니다</p><p><code>next</code> 메서드를 호출하면 <code>Generator</code> 함수 내부에서 첫 번째 <code>yield</code>를 만나면 함수 실행을 멈추게 되고 다시 <code>next</code>를 호출하면 멈춘 부분부터 그 다음에 등장하는 <code>yield</code>에서 함수 실행을 멈추게 됩니다.</p><p>즉, 비동기 작업이 완료되는 시점마다 <code>next</code> 메서드를 호출해준다면 <code>Generator</code> 함수 내부의 소스가 순차적으로 진행되게 합니다.</p><hr><ul><li>Promise + async/await</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addCoffee = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(name);</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> coffeeMaker = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> coffeeList = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">var</span> _addCoffee = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    coffeeList += (coffeeList ? <span class="string">','</span> : <span class="string">''</span>) + (<span class="keyword">await</span> addCoffee(name));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">await</span> _addCoffee(<span class="string">'에스프레소'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">  <span class="keyword">await</span> _addCoffee(<span class="string">'아메리카노'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">  <span class="keyword">await</span> _addCoffee(<span class="string">'카페모카'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">  <span class="keyword">await</span> _addCoffee(<span class="string">'카페라떼'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">&#125;;</span><br><span class="line">coffeeMaker();</span><br></pre></td></tr></table></figure><p><code>ES8(ES2017)</code>에서 추가된 <code>async/await</code>는 비동기 작업을 수행하고자 하는 함수 앞에 <code>async</code>를 표기하고, 함수 내부에서 비동기 작업이 필요한 위치마다 <code>await</code>를 표기하는 것만으로 뒤의 내용을 <code>Promise</code>로 자동 전환하고, 해당 내용이 <code>resolve</code>된 이후에야 다음으로 진행합니다.</p><p><code>Promise</code>의 <code>then</code>과 비슷한 효과를 얻을 수 있습니다.</p><hr><h2 id="callback">정리</h2><ul><li>콜백 함수는 다른 코드에 인자를 넘겨줌으로써 <mark>제어권도 함께 위임</mark>.</li></ul><ul><li><p>제어권을 넘겨받은 코드는 </p><ol><li><p>콜백 함수를 호출하는 시점을 지정.</p></li><li><p>콜백 함수를 호출할 때 <mark>인자로 넘겨줄 값의 순서를 변경하지 말 것.</mark></p></li><li><p>콜백 함수는 <code>this</code>를 지정하여 사용할 수 있는 함수가 존재, 지정하지 않을 경우 전역객체를 참조<br>사용자 임의로 <code>this</code>를 변경하고 싶은 경우 <code>bind</code> 메서드 활용</p></li></ol></li></ul><ul><li>함수에 인자로 메서드를 전달하더라도 이는 <mark>함수로서 실행됨</mark>.</li></ul><ul><li>비동기 제어를 위해 콜백 함수를 사용하다 보면 콜백 지옥에 빠지기 쉬움.<br>최근의 자바스크립트에서는 <mark>Promise, Generator, async/await</mark> 등 콜백 지옥을 벗어날 수 있는 방법들이 등장함.</li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/04/30/%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98-Core-JavaScript/#disqus_thread</comments>
    </item>
    
    <item>
      <title>this -Core JavaScript</title>
      <link>https://hdw0903.github.io/2020/04/27/this-Core-JavaScript/</link>
      <guid>https://hdw0903.github.io/2020/04/27/this-Core-JavaScript/</guid>
      <pubDate>Mon, 27 Apr 2020 12:50:04 GMT</pubDate>
      <description>
      
        &lt;p&gt;자바스크립트에서의 &lt;code&gt;this&lt;/code&gt;는 어디서든 사용할 수 있습니다.&lt;br&gt;&lt;code&gt;this&lt;/code&gt;는 상황에 따라 참조하는 대상이 달라질 수 있습니다.&lt;br&gt;함수와 객체(메서드) 구분이 느슨한 자바스크립트에서 이 둘을 구분하는 유일한 기능입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;this&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/27/this-Core-JavaScript/#this&quot;&gt;상황에 따라 달라지는 this&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;전역 공간에서의 this&lt;/li&gt;
&lt;li&gt;메서드로서 호출할 때 메서드 내부의 this&lt;ul&gt;
&lt;li&gt;함수 vs 메서드&lt;/li&gt;
&lt;li&gt;메서드 내부에서의 this&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;함수로서 호출할 때 그 함수 내부에서의 this&lt;ul&gt;
&lt;li&gt;함수 내부에서의 this&lt;/li&gt;
&lt;li&gt;메서드의 내부함수에서의 this&lt;/li&gt;
&lt;li&gt;메서드 내부 함수에서의 this를 우회하는 방법&lt;/li&gt;
&lt;li&gt;this를 바인딩하지 않는 함수&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;콜백 함수 호출시 그 함수 내부에서의 this&lt;/li&gt;
&lt;li&gt;Class 함수 내부에서의 this &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/27/this-Core-JavaScript/#this_binding&quot;&gt;명시적으로 this를 바인딩하는 방법&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;call 메서드&lt;/li&gt;
&lt;li&gt;apply 메서드&lt;/li&gt;
&lt;li&gt;call / apply 메서드의 활용&lt;ul&gt;
&lt;li&gt;생성자 내부에서 다른 생성자를 호출&lt;/li&gt;
&lt;li&gt;여러 인수를 묶어 하나의 배열로 전달&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;bind 메서드&lt;ul&gt;
&lt;li&gt;name 프로퍼티&lt;/li&gt;
&lt;li&gt;상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;화살표 =&amp;gt; 함수의 예외사항&lt;/li&gt;
&lt;li&gt;별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/27/this-Core-JavaScript/#this_point&quot;&gt;this 정리&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>자바스크립트에서의 <code>this</code>는 어디서든 사용할 수 있습니다.<br><code>this</code>는 상황에 따라 참조하는 대상이 달라질 수 있습니다.<br>함수와 객체(메서드) 구분이 느슨한 자바스크립트에서 이 둘을 구분하는 유일한 기능입니다.</p><ul><li>this<ul><li><a href="/2020/04/27/this-Core-JavaScript/#this">상황에 따라 달라지는 this</a><ul><li>전역 공간에서의 this</li><li>메서드로서 호출할 때 메서드 내부의 this<ul><li>함수 vs 메서드</li><li>메서드 내부에서의 this</li></ul></li><li>함수로서 호출할 때 그 함수 내부에서의 this<ul><li>함수 내부에서의 this</li><li>메서드의 내부함수에서의 this</li><li>메서드 내부 함수에서의 this를 우회하는 방법</li><li>this를 바인딩하지 않는 함수</li></ul></li><li>콜백 함수 호출시 그 함수 내부에서의 this</li><li>Class 함수 내부에서의 this </li></ul></li><li><a href="/2020/04/27/this-Core-JavaScript/#this_binding">명시적으로 this를 바인딩하는 방법</a><ul><li>call 메서드</li><li>apply 메서드</li><li>call / apply 메서드의 활용<ul><li>생성자 내부에서 다른 생성자를 호출</li><li>여러 인수를 묶어 하나의 배열로 전달</li></ul></li><li>bind 메서드<ul><li>name 프로퍼티</li><li>상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기</li></ul></li><li>화살표 =&gt; 함수의 예외사항</li><li>별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)</li></ul></li><li><a href="/2020/04/27/this-Core-JavaScript/#this_point">this 정리</a> </li></ul></li></ul><a id="more"></a><hr><h2 id="this">상황에 따라 달라지는 this</h2><ul><li><code>this</code>는 기본적으로 <mark>실행 컨텍스트가 생성될 때 함께 결정됩니다.</mark><br>실행 컨텍스트는 함수를 호출할 때 생성되므로, <code>this</code><mark>는 함수를 호출할 때 결정된다고 할 수 있습니다.</mark></li></ul><hr><h3 id="전역-공간에서의-this"><a href="#전역-공간에서의-this" class="headerlink" title="전역 공간에서의 this"></a>전역 공간에서의 this</h3><p>전역 공간에서 <code>this</code>는 전역 객체를 가리킵니다. 브라우저 환경에서 전역객체는 <code>window</code>이고 Node.js 환경에서는 <code>global</code>입니다.</p><ul><li>참고 : 전역 변수<br>전역 변수를 선언하면 자바스크립트 엔진은 전역객체의 프로퍼티로 할당시킴.<figure class="highlight js"><figcaption><span>전역객체 window의 프로퍼티</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 1 (전역객체의 프로퍼티)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">// 1 (this는 현재 전역객체 참조)</span></span><br></pre></td></tr></table></figure></li></ul><p><mark>사실 자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로 동작합니다.</mark></p><p>이 특정 객체란 실행 컨텍스트의 <code>LexicalEnvironment</code>를 말합니다.<br>실행 컨텍스트는 변수를 수집하여 <code>LexicalEnvironment</code>의 프로퍼티로 지정합니다.<br>이후 변수를 호출하면 <code>LexicalEnvironment</code>를 조회하여 일치하는 프로퍼티가 있을 경우 그 값을 반환합니다.</p><p>  전역 컨텍스트의 <code>LexicalEnvironment</code>는 전역객체를 참조하므로 var a 선언/할당 이후 <code>window.a</code> 와 <code>this.a</code>가 1이 나오는 이유는 당연합니다.</p><p><mark>a를 직접 호출했을 때도 1이 나오는 이유는 무엇일까요?</mark></p><p>변수 a에 접근하려고 하면 스코프 체인에서 a를 검색하다가 가장 마지막에 도달하는 전역 스코프의 <code>LexicalEnvironment</code>에서 해당 프로퍼티 a를 조회하여 그 값을 반환하기 때문입니다.</p><ul><li><p>전역 공간에서 var로 변수를 선언하는 대신 window의 프로퍼티에 직접 할당하더라도 결과적으로 똑같이 동작합니다. 하지만 <code>delete</code> 연산자를 사용하는 경우 다른 결과를 반환합니다.</p><ul><li><p><code>var</code> 변수로 선언한 경우 : delete window 형식으로 삭제 불가,<br>delete 변수명 형식으로도 삭제 불가</p></li><li><p><code>window</code> 프로퍼티에 직접 할당한 경우: delete window 형식으로 삭제 가능,<br>delete 변수명 형식으로도 삭제 가능</p></li></ul></li></ul><hr><h3 id="메서드로서-호출할-때-그-메서드-내부에서의-this"><a href="#메서드로서-호출할-때-그-메서드-내부에서의-this" class="headerlink" title="메서드로서 호출할 때 그 메서드 내부에서의 this"></a>메서드로서 호출할 때 그 메서드 내부에서의 this</h3><h4 id="함수-vs-메서드"><a href="#함수-vs-메서드" class="headerlink" title="함수 vs 메서드"></a>함수 vs 메서드</h4><p>함수를 실행하는 방법 중에는 함수로 호출하는 경우와 메서드로서 호출하는 경우가 있습니다.<br>함수와 메서드를 구분하는 유일한 차이는 <u>독립성</u>에 있습니다.</p><ul><li><p>함수는 그 자체로 독립적인 기능을 수행합니다.</p></li><li><p>메서드는 자신을 호출한 대상 객체에 관한 동작을 수행합니다.</p></li></ul><p><mark>어떤 함수를 객체의 프로퍼티에 할당한다고 해서 무조건 메서드가 되는 것이 아니라<br>객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작합니다.</mark></p><figure class="highlight js"><figcaption><span>메서드로 호출 (점 표기법, 대괄호 표기법)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, x);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.method(<span class="number">1</span>); <span class="comment">// &#123; method: f &#125; 1</span></span><br><span class="line">obj[<span class="string">'method'</span>](<span class="number">2</span>); <span class="comment">// &#123; method: f &#125; 2</span></span><br></pre></td></tr></table></figure><p>다시 말해 점 표기법이든 대괄호 표기법이든, 어떤 함수를 호출할 때 그 함수 이름 앞에<br>객체가 명시돼 있는 경우 메서드로 호출한 것이고, 그렇지 않은 경우에는 함수로 호출한 것입니다.</p><h4 id="메서드-내부에서의-this"><a href="#메서드-내부에서의-this" class="headerlink" title="메서드 내부에서의 this"></a>메서드 내부에서의 this</h4><p><code>this</code>에는 호출한 주체에 대한 정보가 담깁니다. 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티 명)앞의 객체입니다. 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 <code>this</code>가 됩니다.</p><figure class="highlight js"><figcaption><span>메서드 내부에서의 this</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  methodA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  inner: &#123;</span><br><span class="line">    methodB: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.methodA(); <span class="comment">// &#123; methodA: f, inner: &#123;...&#125; &#125;    ( === obj)</span></span><br><span class="line">obj[<span class="string">'methodA'</span>](); <span class="comment">// &#123; methodA: f, inner: &#123;...&#125; &#125; ( === obj)</span></span><br><span class="line"></span><br><span class="line">obj.inner.methodB(); <span class="comment">// &#123; methodB: f &#125;            ( === obj.inner)</span></span><br><span class="line">obj.inner[<span class="string">'methodB'</span>](); <span class="comment">// &#123; methodB: f &#125;         ( === obj.inner)</span></span><br><span class="line">obj[<span class="string">'inner'</span>].methodB(); <span class="comment">// &#123; methodB: f &#125;         ( === obj.inner)</span></span><br><span class="line">obj[<span class="string">'inner'</span>][<span class="string">'methodB'</span>](); <span class="comment">// &#123; methodB: f &#125;      ( === obj.inner)</span></span><br></pre></td></tr></table></figure><hr><h3 id="함수로서-호출할-때-그-함수-내부에서의-this"><a href="#함수로서-호출할-때-그-함수-내부에서의-this" class="headerlink" title="함수로서 호출할 때 그 함수 내부에서의 this"></a>함수로서 호출할 때 그 함수 내부에서의 this</h3><hr><h4 id="함수-내부에서의-this"><a href="#함수-내부에서의-this" class="headerlink" title="함수 내부에서의 this"></a>함수 내부에서의 this</h4><p>어떤 함수를 함수로서 호출할 경우 <code>this</code>가 지정되지 않습니다.(this는 호출한 주체에 대한 정보가 담깁니다.)<br>함수로서 호출하는 것은 호출 주체(객체지향 언어에서의 객체)를 명시하지 않고 실행한 것이기 때문에 호출 주체의 정보를 알 수 없는 것입니다.<br><mark>this가 지정되지 않은 경우 this는 전역 객체를 참조합니다.</mark><br>따라서 함수에서의 <code>this</code>는 전역 객체를 가리킵니다.</p><hr><h4 id="메서드의-내부함수에서의-this"><a href="#메서드의-내부함수에서의-this" class="headerlink" title="메서드의 내부함수에서의 this"></a>메서드의 내부함수에서의 this</h4><p>메서드 내부에서 정의하고 실행한 함수에서의 this는 자바스크립트 초심자들이 this에 관해 가장 자주 혼란을 느끼는 점입니다.</p><p><mark>내부함수 역시 이를 함수로 호출했는지 메서드로 호출했는지만 파악하면 this의 값을 정확히 맞출 수 있습니다.</mark></p><figure class="highlight js"><figcaption><span>내부함수에서의 this</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="number">3.</span> outer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="number">4.</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// (1)</span></span><br><span class="line">    <span class="number">5.</span> <span class="number">7.</span> <span class="keyword">var</span> innerFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="number">8.</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// (2) (3)</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="number">6.</span> innerFunc();</span><br><span class="line"></span><br><span class="line">    <span class="number">9.</span> <span class="number">11.</span> <span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">      <span class="number">12.</span> innerMethod: innerFunc,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="number">10.</span> obj2.innerMethod();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">2.</span> obj1.outer();</span><br><span class="line"><span class="comment">// (1): obj1</span></span><br><span class="line"><span class="comment">// (2): 전역객체(window)</span></span><br><span class="line"><span class="comment">// (3): obj2</span></span><br></pre></td></tr></table></figure><p>(2)는 <code>innerFunc</code>를 호출한 결과를, (3)은 <code>obj2.innerMethod</code>를 호출한 결과입니다.</p><ol><li>객체를 생성하는데 내부에 outer 프로퍼티가 있습니다. outer 프로퍼티에 익명함수가 연결되고 생성된 객체를 변수 <code>obj1</code>에 할당합니다.</li></ol><ol start="2"><li><code>obj1.outer()</code>를 호출합니다.</li></ol><ol start="3"><li><code>obj1.outer</code> 함수의 실행 컨텍스트가 생성되면서 호이스팅하고, 스코프 체인 정보를 수집하고, this를 바인딩합니다.<br>이 함수는 호출될 때 함수명 <code>outer</code> 앞에 점(.)이 있었으므로 메서드로서 호출된 것입니다.<br>따라서 <code>this</code>는 점(.)앞에 객체인 <code>obj1</code>을 바인딩합니다.</li></ol><ol start="4"><li><code>this</code>가 바인딩된 <code>obj1</code> 객체 정보가 출력됩니다.</li></ol><ol start="5"><li>호이스팅된 변수 <code>innerFunc</code>는 outer 스코프 내에서만 접근할 수 있는 지역변수 입니다. 이 변수에 익명 함수를 할당합니다.</li></ol><ol start="6"><li><code>innerFunc()</code>를 호출합니다.</li></ol><ol start="7"><li><code>innerFunc</code> 함수의 실행 컨텍스트가 생성되면서 호이스팅,스코프 체인 수집, this 바인딩 등을 수행합니다.<br>이 함수는 호출될 때 <del>함수명 앞에 점(.)이 없었습니다.</del> 함수로서 호출되었습니다.<br>따라서 this가 지정되지 않았고, 자동으로 스코프 체인상의 최상위 객체인 전역객체(window)가 바인딩 됩니다.</li></ol><ol start="8"><li><code>this</code>가 바인딩된 <code>window</code> 객체 정보가 출력됩니다.</li></ol><ol start="9"><li><code>obj2</code> 역시 outer 스코프 내부에서만 접근할 수 있는 지역변수 입니다.<br><code>obj2</code> 변수에는 <code>object</code>를 할당하는데, object 안에 <code>innerMethod</code>라는 프로퍼티가 존재하고, 프로퍼티 값으로 앞서 정의된 변수 <code>innerFunc</code>와 연결된 익명 함수가 지정됩니다.</li></ol><ol start="10"><li><code>obj2.innerMethod()</code>를 호출합니다.</li></ol><ol start="11"><li><code>obj2. innerMethod</code> 함수의 실행 컨텍스트가 생성됩니다. 이 함수는 호출할 때 함수명인 <code>innerMethod</code> 앞에 점(.)이 있었으므로 메서드로서 호출한 것입니다.<br>따라서 <code>this</code>에는 마지막 점 앞의 객체인 <code>obj2</code>가 바인딩 됩니다.</li></ol><ol start="12"><li><code>obj2</code> 객체 정보가 출력됩니다.</li></ol><ul><li>정리하자면<br><mark>this 바인딩에 관해서는 함수를 실행하는 당시의 주변 환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고 오직 해당 함수를 호출하는 구문 앞에 점(.) 또는 대괄호[] 표기가 있는지 없는지가 관건입니다.</mark></li></ul><hr><h4 id="메서드의-내부-함수에서의-this를-우회하는-방법"><a href="#메서드의-내부-함수에서의-this를-우회하는-방법" class="headerlink" title="메서드의 내부 함수에서의 this를 우회하는 방법"></a>메서드의 내부 함수에서의 this를 우회하는 방법</h4><p>호출 주체가 없을 때 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변 환경의 <code>this</code>를 그대로 상속받아 사용하고 싶다면<br>간단하고 대표적인 방법으로 변수를 활용하는 방법이 있습니다.</p><figure class="highlight js"><figcaption><span>내부함수에서의 this를 변수를 활용하여 우회하기</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  outer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// (1) &#123; outer: f &#125;</span></span><br><span class="line">    <span class="keyword">var</span> innerFunc1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// (2) Window &#123; ... &#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    innerFunc1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> innerFunc2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(self); <span class="comment">// (3) &#123; outer: f &#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    innerFunc2();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.outer();</span><br></pre></td></tr></table></figure><ol><li><p><code>innerFunc1</code> 내부에서 <code>this</code>는 전역객체를 가리킵니다.</p></li><li><p>outer 스코프에서 <code>self</code>라는 변수에 <code>this</code>를 저장한 상태에서 호출한 <code>innerFunc2</code>의 경우 <code>self</code>에는 객체 obj가 출력됩니다.</p></li></ol><p><del>그저 상위 스코프의 this를 저장해서 내부함수에서 활용하려는 수단이므로 변수명은 달라도 무관합니다.</del></p><hr><h4 id="this를-바인딩하지-않는-함수"><a href="#this를-바인딩하지-않는-함수" class="headerlink" title="this를 바인딩하지 않는 함수"></a>this를 바인딩하지 않는 함수</h4><p>ES6에서는 함수 내부에서 <code>this</code>가 전역객체를 바라보는 문제를 보안하고자,<br><code>this</code>를 바인딩하지 않는 <mark>화살표 함수(Arrow function)</mark>를 새로 도입했습니다. </p><p>화살표 함수는 실행 컨텍스트를 생성할 때 <code>this</code> 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 <code>this</code>를 그대로 활용할 수 있습니다.</p><figure class="highlight js"><figcaption><span>화살표 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  outer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// (1) &#123; outer: f &#125;</span></span><br><span class="line">    <span class="keyword">var</span> innerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// (2) &#123; outer: f &#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    innerFunc();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.outer();</span><br></pre></td></tr></table></figure><p>이 밖에도 <code>call</code>, <code>apply</code> 등의 메서드를 활용해 함수를 호출할 때 명시적으로 <code>this</code>를 지정하는 방법이 있습니다.</p><hr><h3 id="콜백-함수-호출-시-그-함수-내부에서의-this"><a href="#콜백-함수-호출-시-그-함수-내부에서의-this" class="headerlink" title="콜백 함수 호출 시 그 함수 내부에서의 this"></a>콜백 함수 호출 시 그 함수 내부에서의 this</h3><ul><li><p><code>함수 A</code>의 제어권을 <code>다른 함수(또는 메서드) B</code>에게 넘겨주는 경우 <code>함수 A</code>를 <code>콜백 함수</code>라고 합니다.</p></li><li><p>이때 <code>함수 A</code>는 <code>함수 B</code>의 내부 로직에 따라 실행되며, <code>this</code> 역시 <code>함수 B</code> 내부 로직에서 정한 규칙에 따라 값이 결정됩니다.</p></li><li><p><code>콜백 함수</code> 역시 함수이므로 기본적으로 <code>this</code>가 전역객체를 참조하지만, 제어권을 받은 함수 (함수 B)에서 <code>콜백 함수</code>에 별도로 <code>this</code>가 될 대상을 지정한 경우에는 그 대상을 참조하게 됩니다.</p></li></ul><figure class="highlight js"><figcaption><span>콜백 함수 내부에서의 this</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;, <span class="number">300</span>); <span class="comment">// (1) window</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// (2) window</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, x);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML += <span class="string">'&lt;button id="a"&gt;클릭&lt;/button&gt;'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.querySelector(<span class="string">'#a'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// (3) &lt;button id="a"&gt;클릭&lt;/button&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li><p>0.3초 뒤 전역객체가 출력됩니다.</p></li><li><p>배열의 각 요소를 차례대로 콜백 함수의 첫 번째 인자로 삼아 전역객체와 배열의 각 요소가 총 5회 출력됩니다.</p></li><li><p>지정한 <code>HTML</code> 엘리먼트에 <code>&#39;click&#39;</code> 이벤트가 발생할 때 마다 그 이벤트 정보를 콜백 함수의 첫 번째 인자로 삼아 함수를 실행합니다. 버튼을 클릭하면 앞서 지정한 엘리먼트와 클릭 이벤트에 관한 정보가 담긴 객체가 출력됩니다.</p></li></ol><p>이 처럼 콜백 함수에서의 <code>this</code>는 한가지로 정의할 수 없습니다.<br><mark>콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 정할지 결정하며</mark>,<br>따로 정의하지 않은 경우 기본적으로 전역객체를 참조합니다.</p><hr><h3 id="Class-함수-내부에서의-this"><a href="#Class-함수-내부에서의-this" class="headerlink" title="Class 함수 내부에서의 this"></a>Class 함수 내부에서의 this</h3><p>객체지향 언어에서 생성자를 클래스(<code>class</code>),<br>클래스를 통해 만든 객체를 인스턴스 (<code>instance</code>)라고 합니다.</p><p>프로그래밍적으로 <code>class</code>는 구체적인 <code>instance</code>를 만들기 위한 일종의 틀입니다.<br>틀 안에는 해당 <code>class</code>의 공통 속성들이 준비되어 있고, 추가로 개별 <code>instance</code>를 만들 수 있습니다.</p><p><code>new</code> 키워드와 함께 함수를 호출하면 해당 함수가 <code>class</code>로서 동작합니다.<br><code>class</code>로서 함수가 호출된 경우 내부에서의 <code>this</code>는 <code>instance</code>가 됩니다.</p><ul><li><code>class</code> 함수를 <code>new</code>키워드로 호출 하면 엔진은 <code>class</code>의 <code>prototype</code> 프로퍼티를 참조하는 <code>__proto__</code> 프로퍼티 <code>instance</code>를 만들고 공통 속성 및 특성 들을 해당 객체(<code>this</code>)에 부여합니다.<br><code>instance</code>가 생성됩니다.</li></ul><figure class="highlight js"><figcaption><span>class 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Cat = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.bark = <span class="string">'야옹'</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> choco = <span class="keyword">new</span> Cat(<span class="string">'초코'</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">var</span> nabi = <span class="keyword">new</span> Cat(<span class="string">'나비'</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(choco, nabi);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 결과</span></span><br><span class="line"><span class="comment">Cat &#123; bark: '야옹', name: '초코', age: 7 &#125;</span></span><br><span class="line"><span class="comment">Cat &#123; bark: '야옹', name: '나비', age: 5 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol><li><p><code>new</code> 키워드와 함께 Cat 함수를 호출하여 변수 choco, nabi에 각각 할당 했습니다.</p></li><li><p><code>console.log</code> 출력 결과 <code>this</code>가 각각 Cat <code>class</code>의 <code>instance</code>를 참조하여 반환합니다.<br>(<code>choco instance</code>, <code>nabi instance</code>)</p></li></ol><hr><h2 id="this_binding">명시적으로 this를 바인딩하는 방법</h2><p>상황에 따라 this에 바인딩 되는 값들을 살펴봤지만 이런 규칙을 무시?하고 this에 대상을 지정하여 바인딩하는 방법도 있습니다.</p><hr><h3 id="call-메서드"><a href="#call-메서드" class="headerlink" title="call 메서드"></a>call 메서드</h3><blockquote><p>Function.prototype.call(thisArg[, arg1[, arg2[, …]]])</p></blockquote><p><code>call</code> 메서드는 호출 주체인 함수를 즉시 실행하도록 합니다.<br><code>call</code> 메서드의 첫 번째 인자를 <code>this</code>로 바인딩 하고, 이후에 인자들을 호출할 함수의 매개변수로 사용합니다.</p><p><code>call</code>메서드를 이용하여 <code>this</code> 값으로 참조할 객체를 지정할 수 있습니다. </p><figure class="highlight js"><figcaption><span>call 메서드</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, a, b, c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// Window&#123; ... &#125; 1 2 3</span></span><br><span class="line">func.call(&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>); <span class="comment">// &#123; x: 1 &#125; 4 5 6</span></span><br></pre></td></tr></table></figure><ul><li><p><code>func.call</code>에서 메서드의 첫 번째 인자 <code>{x : 1}</code>를 <code>this</code>가 참조할 값으로 던져줍니다.</p></li><li><p>객체의 메서드를 호출하면 <code>this</code>는 객체를 참조하게 되지만, <code>call</code> 메서드는 이렇듯 임의의 객체를 <code>this</code>로 지정할 수 있습니다.</p></li></ul><hr><h3 id="apply-메서드"><a href="#apply-메서드" class="headerlink" title="apply 메서드"></a>apply 메서드</h3><blockquote><p>Function.prototype.apply(thisArg[, argsArray])</p></blockquote><p><code>apply</code> 메서드는 기능적으로 <code>call</code> 메서드와 완전히 동일합니다.</p><p><code>apply</code>메서드는 <mark>두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 점에서 차이가 있습니다.</mark></p><figure class="highlight js"><figcaption><span>apply 메서드</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, a, b, c);</span><br><span class="line">&#125;;</span><br><span class="line">func.apply(&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]); <span class="comment">// &#123; x: 1 &#125; 4 5 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, x, y);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.method.apply(&#123; <span class="attr">a</span>: <span class="number">4</span> &#125;, [<span class="number">5</span>, <span class="number">6</span>]); <span class="comment">// 4 5 6</span></span><br></pre></td></tr></table></figure><hr><h3 id="call-apply-메서드의-활용"><a href="#call-apply-메서드의-활용" class="headerlink" title="call / apply 메서드의 활용"></a>call / apply 메서드의 활용</h3><p><code>call</code> 과 <code>apply</code> 메서드의 활용 사례</p><hr><h4 id="유사-배열객체에-배열-메서드-적용"><a href="#유사-배열객체에-배열-메서드-적용" class="headerlink" title="유사 배열객체에 배열 메서드 적용"></a>유사 배열객체에 배열 메서드 적용</h4><figure class="highlight js"><figcaption><span>유사 배열객체에서 배열 메서드 사용하기</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(obj, <span class="string">'d'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; 0: 'a', 1: 'b', 2: 'c', 3: 'd', length: 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(obj);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 'a', 'b', 'c', 'd' ]</span></span><br></pre></td></tr></table></figure><ul><li><p>유사배열객체인 경우 <code>call</code> 또는 <code>apply</code> 메서드를 이용해 배열 메서드를 사용할 수 있습니다.</p></li><li><p>배열 메서드인 <code>push</code>를 <code>객체 obj</code>에 적용해 프로퍼티 3에 ‘d’를 추가했습니다.</p></li><li><p>배열 메서드인 <code>slice</code>로 얕은 복사하여 객체를 배열로 반환했습니다.</p></li></ul><p>이 밖에도 유사배열객체에는 <code>call</code>, <code>apply</code> 메서드를 이용해 모든 배열 메서드를 적용할 수 있습니다.<br>단, 문자열의 경우 <code>length</code> 프로퍼티가 읽기 전용이기 때문에 원본 문자열에 변경을 가하는 메서드(<code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>splice</code> 등)는 에러를 던지며, <code>concat</code> 처럼 대상이 반드시 배열이어야 하는 경우에는 에러는 나지 않지만 재대로 된 결과를 얻을 수 없습니다.</p><ul><li>사실 <code>call</code>, <code>apply</code>를 이용해 형변환하는 것은 ‘<code>this</code>를 원하는 값으로 지정해서 호출한다’라는 본래의 메서드의 의도와는 어긋나는 활용법이라고 할 수 있습니다.<br>또한 코드만 봐서는 어떤 의도인지 파악하기 쉽지 않습니다.</li></ul><ul><li><mark>ES6 에서는 유사배열객체 또는 이터러블한 모든 종류의 데이터 타입을 배열로 전환</mark>하는 <code>Array.from</code>메서드가 추가되었습니다.</li></ul><hr><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h4><p>Array 오브젝트를 생성하고 콜백 함수에서 반환된 값을 엘리먼트 값으로 설정하여 새로운 Array 객체를 반환합니다.</p><blockquote><p>Array.from(arrayLike[, mapFn[, thisArg]])</p></blockquote><ul><li><p>arrayLike<br>배열로 변환하고자 하는 유사 배열 객체(Array-like)나 반복 가능한 객체(이터러블 오브젝트).</p></li><li><p>mapFn (선택적 파라미터)<br>배열의 모든 엘리먼트 마다 호출할 함수.</p></li><li><p>thisArg (선택적 파라미터)<br>두 번째 파라미터 함수 실행 시에 this로 참조할 값.</p></li><li><p>반환 값<br>새로운 Array 인스턴스.</p></li></ul><figure class="highlight js"><figcaption><span>ES6의 Array.from</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(obj);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure><hr><h4 id="class-내부에서-다른-class를-호출"><a href="#class-내부에서-다른-class를-호출" class="headerlink" title="class 내부에서 다른 class를 호출"></a>class 내부에서 다른 class를 호출</h4><p><code>class</code> 내부에 다른 <code>class</code>와 공통된 내용이 있을 경우 <code>call</code> 또는 <code>apply</code>를 이용해 다른 <code>class</code>를 호출하면 간단하게 반복을 줄일 수 있습니다.</p><figure class="highlight js"><figcaption><span>class 내부에서 다른 class 호출</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, gender, school</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, gender);</span><br><span class="line">  <span class="keyword">this</span>.school = school;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">name, gender, company</span>) </span>&#123;</span><br><span class="line">  Person.apply(<span class="keyword">this</span>, [name, gender]);</span><br><span class="line">  <span class="keyword">this</span>.company = company;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> by = <span class="keyword">new</span> Student(<span class="string">'보영'</span>, <span class="string">'female'</span>, <span class="string">'단국대'</span>);</span><br><span class="line"><span class="keyword">var</span> jn = <span class="keyword">new</span> Employee(<span class="string">'재난'</span>, <span class="string">'male'</span>, <span class="string">'구골'</span>);</span><br></pre></td></tr></table></figure><p>Student, Employee class함수 내부에서 Person 함수를 호출해서 instance 속성을 정의하게 했습니다.</p><hr><h4 id="여러-인수를-묶어-하나의-배열로-전달하고-싶을-때"><a href="#여러-인수를-묶어-하나의-배열로-전달하고-싶을-때" class="headerlink" title="여러 인수를 묶어 하나의 배열로 전달하고 싶을 때"></a>여러 인수를 묶어 하나의 배열로 전달하고 싶을 때</h4><p><code>apply</code>메서드를 사용해 하나의 배열로 인수들을 전달할 수 있습니다.</p><figure class="highlight js"><figcaption><span>여러 인수를 받는 메서드(Math.max/Math.min)에 apply 적용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">45</span>];</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, numbers);</span><br><span class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, numbers);</span><br><span class="line"><span class="built_in">console</span>.log(max, min); <span class="comment">// 45 3</span></span><br></pre></td></tr></table></figure><p>ES6에서는 <code>spread</code> 연산자를 이용하면 <code>apply</code>를 적용하는 것보다 더욱 간편하게 작성할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">45</span>];</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max(...numbers);</span><br><span class="line"><span class="keyword">const</span> min = <span class="built_in">Math</span>.min(...numbers);</span><br><span class="line"><span class="built_in">console</span>.log(max, min); <span class="comment">// 45 3</span></span><br></pre></td></tr></table></figure><hr><h3 id="bind-메서드"><a href="#bind-메서드" class="headerlink" title="bind 메서드"></a>bind 메서드</h3><blockquote><p>Function.prototype.bind(thisArg[,arg1[, arg2[, …]]])</p></blockquote><p><code>bind</code> 메서드는 ES5에서 추가된 기능으로, call과 비슷하지만 즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드입니다.<br>다시 새로운 함수를 호출할 때 인수를 넘기면 그 인수들은 기존 <code>bind</code> 메서드를 호출할 때 전달했던 인수들의 뒤에 이어서 등록됩니다.<br>즉 <code>bind</code>메서드는 함수에 this를 미리 적용하는 것과 부분 적용 함수를 구현하는 두 가지 목적을 모두 지닙니다.</p><figure class="highlight js"><figcaption><span>bind메서드의 this 지정과 부분 적용 함수 구현</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, a, b, c, d);</span><br><span class="line">&#125;;</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// Window&#123; ... &#125; 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="keyword">var</span> bindFunc1 = func.bind(&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;);</span><br><span class="line">bindFunc1(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>); <span class="comment">// &#123; x: 1 &#125; 5 6 7 8</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">var</span> bindFunc2 = func.bind(&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">bindFunc2(<span class="number">6</span>, <span class="number">7</span>); <span class="comment">// &#123; x: 1 &#125; 4 5 6 7</span></span><br><span class="line">bindFunc2(<span class="number">8</span>, <span class="number">9</span>); <span class="comment">// &#123; x: 1 &#125; 4 5 8 9</span></span><br></pre></td></tr></table></figure><ol><li><p><code>bindFunc1</code> 변수에 <code>func</code> 변수에 <code>this</code>를 <code>{x : 1}</code>로 지정하는 새로운 함수가 할당됩니다.<br>다음 줄에서 <code>bindFunc1</code>을 호출하면 지정된 <code>this</code>값과 함께 반환됩니다.</p></li><li><p><code>bindFunc2</code> 변수에는 <code>func</code> 변수에 <code>this</code>를 <code>{x : 1}</code>로 지정하고, 파라미터를 차례대로 4, 5로 지정한 함수 새로운 함수가 할당됩니다. 다음 코드를 호출하면 <code>this</code>로 지정해준 값과 파라미터에 지정해준 값이 적용되고 그 다음 함수를 호출하며 넘겨준 파라미터 값이 붙습니다 <code>{x : 1} 4 5 6 7</code>, <code>{x : 1} 4 5 8 9</code> 형태로 반환됩니다.<br><mark>이것이 bind의 부분 적용 함수 구현법입니다.</mark></p></li></ol><hr><h4 id="name-프로퍼티"><a href="#name-프로퍼티" class="headerlink" title="name 프로퍼티"></a>name 프로퍼티</h4><p><u>bind 메서드를 적용해서 새로 만든 함수는 한 가지 독특한 성질이 있습니다.</u><br>name 프로퍼티에 동사 bind의 수동태인 <code>bound</code>라는 접두어가 붙습니다.</p><p>함수의 name 프로퍼티가 <code>bound xxx</code>이라면 함수명이 xxx인 원본 함수에 <code>bind</code>메서드를 적용한 새로운 함수라는 의미가 되므로 call 과 apply 메서드에 비해 코드 추적이 용이한 점이 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, a, b, c, d);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bindFunc = func.bind(&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(func.name); <span class="comment">// func</span></span><br><span class="line"><span class="built_in">console</span>.log(bindFunc.name); <span class="comment">// bound func</span></span><br></pre></td></tr></table></figure><hr><h4 id="상위-컨텍스트의-this를-내부함수나-콜백-함수에-전달하기"><a href="#상위-컨텍스트의-this를-내부함수나-콜백-함수에-전달하기" class="headerlink" title="상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기"></a>상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기</h4><p>메서드의 내부함수에서 메서드의 <code>this</code>를 그대로 바라보게 하기 위한 방법으로<br>self 등의 변수를 활용하거나 화살표 함수를 이용한 우회법이 있었는데<br><code>call</code>, <code>apply</code>, <code>bind</code> 메서드를 이용하면 더 깔끔하게 처리할 수 있습니다.</p><figure class="highlight js"><figcaption><span>내부함수에 this 전달 - call</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  outer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//&#123;outer : f&#125;</span></span><br><span class="line">    <span class="keyword">var</span> innerFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//&#123;outer : f&#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    innerFunc.call(<span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.outer();</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>내부함수에 this 전달 -bind</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  outer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//&#123;outer : f&#125;</span></span><br><span class="line">    <span class="keyword">var</span> innerFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//&#123;outer : f&#125;</span></span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>); <span class="comment">// 호출x, 새로운 함수 바인드</span></span><br><span class="line">    innerFunc(); <span class="comment">// 호출</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.outer();</span><br></pre></td></tr></table></figure><ul><li>또한 콜백 함수를 인자로 받는 함수(메서드) 중에서 기본적으로 콜백 함수 내에서의 <code>this</code>에 관여하는 함수(메서드)에 대해서도 <code>bind</code> 메서드를 사용하면 <code>this</code>값을 지정하여 바꿀 수 있습니다.</li></ul><figure class="highlight js"><figcaption><span>bind 메서드 - 내부 함수에 this 전달</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  logThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  logThisLater1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="keyword">this</span>.logThis, <span class="number">500</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  logThisLater2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="keyword">this</span>.logThis.bind(<span class="keyword">this</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.logThisLater1(); <span class="comment">// Window &#123; ... &#125;</span></span><br><span class="line">obj.logThisLater2(); <span class="comment">// obj &#123; logThis: f, ... &#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="화살표-함수의-예외사항"><a href="#화살표-함수의-예외사항" class="headerlink" title="화살표 함수의 예외사항"></a>화살표 함수의 예외사항</h3><p>ES6에 새롭게 도입된 화살표 함수 <code>=&gt;</code>는 실행 컨텍스트 생성 시 this를 바인딩 하지 않습니다.<br>즉 화살표 함수 <code>=&gt;</code> 내부에는 <code>this</code>가 아예 없으며, <code>this</code>에 접근하고자 하면 스코프체인상 가장 가까운 <code>this</code>에 접근하게 됩니다.</p><figure class="highlight js"><figcaption><span>화삺표 함수 내부에서의 this</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  outer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">var</span> innerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    innerFunc();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.outer();</span><br></pre></td></tr></table></figure><ul><li><code>call</code>, <code>apply</code>, <code>bind</code>를 사용했던 예제의 내부함수를 <code>=&gt;</code>함수로 바꾼 것입니다.<br>더욱 간결해졌습니다.</li></ul><hr><h3 id="별도의-인자로-this를-받는-경우-콜백-함수-내에서의-this"><a href="#별도의-인자로-this를-받는-경우-콜백-함수-내에서의-this" class="headerlink" title="별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)"></a>별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)</h3><p>콜백 함수를 인자로 받는 메서드에는 <code>this</code>로 지정할 객체(<code>thisArg</code>)를 인자로 지정할 수 있는 것들이 있습니다. 이러한 메서드를 이용하여 <code>this</code>값을 원하는대로 변경할 수 있습니다.</p><p>이러한 메서드는 내부 요소에 대해 같은 동작을 반복 수행해야하는 배열 메서드에 많이 존재하고, 같은 이유로 ES6에 추가된 <code>Set</code>, <code>Map</code>등의 메서드에도 일부 존재합니다.</p><ul><li>콜백 함수와 함께 thisArg를 인자로 받는 메서드<table><thead><tr><th>Array.prototype</th><th>Set.prototype</th><th>Map.prototype</th></tr></thead><tbody><tr><td><code>forEach</code>(callback[, thisArg])</td><td><code>forEach</code>(callback[, thisArg])</td><td><code>forEach</code>(callback[, thisArg])</td></tr><tr><td><code>map</code>(callback[, thisArg])</td><td></td><td></td></tr><tr><td><code>filter</code>(callback[, thisArg])</td><td></td><td></td></tr><tr><td><code>some</code>(callback[, thisArg])</td><td></td><td></td></tr><tr><td><code>every</code>(callback[, thisArg])</td><td></td><td></td></tr><tr><td><code>find</code>(callback[, thisArg])</td><td></td><td></td></tr><tr><td><code>findIndex</code>(callback[, thisArg])</td><td></td><td></td></tr><tr><td><code>flatMap</code>(callback[, thisArg])</td><td></td><td></td></tr><tr><td><code>from</code>(arrayLike[, callback[, thisArg]])</td><td></td><td></td></tr></tbody></table></li></ul><hr><h4 id="대표적인-배열-메서드인-forEach-예시"><a href="#대표적인-배열-메서드인-forEach-예시" class="headerlink" title="대표적인 배열 메서드인 forEach 예시"></a>대표적인 배열 메서드인 forEach 예시</h4><figure class="highlight js"><figcaption><span>forEach</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> report = &#123;</span><br><span class="line">  sum: <span class="number">0</span>,</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    args.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sum += entry;</span><br><span class="line">      ++<span class="keyword">this</span>.count;</span><br><span class="line">    &#125;, <span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  average: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sum / <span class="keyword">this</span>.count;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">report.add(<span class="number">60</span>, <span class="number">85</span>, <span class="number">95</span>);</span><br><span class="line"><span class="built_in">console</span>.log(report.sum, report.count, report.average()); <span class="comment">// 240 3 80</span></span><br></pre></td></tr></table></figure><ul><li><code>60, 85, 95</code>를 인자로 삼아 <code>add</code> 메서드를 호출하면 <code>slice.call</code>메서드가 인자를 받아 새로운 배열로 반환합니다. 이후 <code>forEach</code> 메서드가 실행됩니다.</li></ul><ul><li>콜백 함수 내부의 <code>this</code>는 <code>forEach</code> 함수의 두 번째 인자로 전달해준 <code>this</code>(add 메서드의 this)가 전달된 상태이므로 <code>add</code> 메서드의 <code>this(report)</code>를 가리킵니다.</li></ul><ul><li>따라서 배열의 요소들을 순회 반복하며 <code>report.sum</code> , <code>report.count</code>값이 차례로 바뀌게 됩니다.<br>출력 결과로 <code>report.sum</code>에 240, <code>report.count</code>에 3이 반환되어 출력됩니다.</li></ul><hr><h2 id="this_point">this 정리</h2><p>명시적 <code>this</code> 바인딩이 없는 한 항상 성립하는 규칙</p><ul><li><p>전역공간에서의 <code>this</code>는 전역객체를 참조 (브라우저에서는 <code>window</code>, Node.js에서는 <code>global</code>)</p></li><li><p>함수를 메서드로 호출한 경우 <code>this</code>는 메서드 호출 주체를 참조 (메서드명 앞의 객체)</p></li><li><p>함수를 함수로 호출한 경우 <code>this</code>는 전역객체를 참조 (메서드의 내부함수에서도 동일)</p></li><li><p>콜백 함수 내부에서의 <code>this</code>는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바를 참조<br><code>this</code>가 정의되어 있지않다면 전역객체를 참조</p></li><li><p><code>class</code> 함수에서 <code>this</code>는 생성될 <code>instance</code>를 참조</p></li></ul><p>위 규칙에 부합하지 않는 경우 명시적 <code>this</code> 바인딩 규칙으로 예측할 수 있습니다.</p><ul><li><p><code>call</code>, <code>apply</code> 메서드는 <code>this</code>를 명시적으로 지정하면서 함수 또는 메서드를 호출</p></li><li><p><code>bind</code> 메서드는 <code>this</code> 및 함수에 넘길 파라미터를 일부 지정해 새로운 함수를 만듭니다.</p></li><li><p>콜백 함수를 반복 순회,호출 하는 일부 메서드는 별도의 인자로 <code>this</code>를 받기도 합니다.</p></li></ul>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/04/27/this-Core-JavaScript/#disqus_thread</comments>
    </item>
    
    <item>
      <title>실행 컨텍스트 -Core JavaScript</title>
      <link>https://hdw0903.github.io/2020/04/26/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-Core-JavaScript/</link>
      <guid>https://hdw0903.github.io/2020/04/26/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-Core-JavaScript/</guid>
      <pubDate>Sun, 26 Apr 2020 08:50:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;실행 컨텍스트(&lt;code&gt;execution context&lt;/code&gt;)는 실행할 코드에 제공할 환경 정보를 모아놓은 객체로,&lt;br&gt;자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념입니다.&lt;br&gt;자바스크립트는 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(&lt;code&gt;호이스팅&lt;/code&gt;), 외부 환경 정보를 구성하고, &lt;code&gt;this&lt;/code&gt; 값을 설정하는 등의 동작을 수행하는데, 이로 인해 다른 언어에서는 발견할 수 없는 특이한 현상들이 발생합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실행 컨텍스트&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/26/실행-컨텍스트-Core-JavaScript/#execution_context&quot;&gt;실행 컨텍스트란?&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;스택과 큐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/26/실행-컨텍스트-Core-JavaScript/#VariableEnvironment&quot;&gt;VariableEnvironment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/26/실행-컨텍스트-Core-JavaScript/#LexicalEnvironment&quot;&gt;LexicalEnvironment&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;environmentRecord와 호이스팅&lt;ul&gt;
&lt;li&gt;호이스팅 규칙&lt;/li&gt;
&lt;li&gt;함수 선언문과 함수 표현식&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스코프, 스코프 체인, outerEnvironmentReference&lt;ul&gt;
&lt;li&gt;스코프 체인&lt;/li&gt;
&lt;li&gt;전역변수 와 지역변수&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/26/실행-컨텍스트-Core-JavaScript/#thisBinding&quot;&gt;this&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>실행 컨텍스트(<code>execution context</code>)는 실행할 코드에 제공할 환경 정보를 모아놓은 객체로,<br>자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념입니다.<br>자바스크립트는 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(<code>호이스팅</code>), 외부 환경 정보를 구성하고, <code>this</code> 값을 설정하는 등의 동작을 수행하는데, 이로 인해 다른 언어에서는 발견할 수 없는 특이한 현상들이 발생합니다.</p><ul><li>실행 컨텍스트<ul><li><a href="/2020/04/26/실행-컨텍스트-Core-JavaScript/#execution_context">실행 컨텍스트란?</a><ul><li>스택과 큐</li></ul></li><li><a href="/2020/04/26/실행-컨텍스트-Core-JavaScript/#VariableEnvironment">VariableEnvironment</a></li><li><a href="/2020/04/26/실행-컨텍스트-Core-JavaScript/#LexicalEnvironment">LexicalEnvironment</a><ul><li>environmentRecord와 호이스팅<ul><li>호이스팅 규칙</li><li>함수 선언문과 함수 표현식</li></ul></li><li>스코프, 스코프 체인, outerEnvironmentReference<ul><li>스코프 체인</li><li>전역변수 와 지역변수</li></ul></li></ul></li><li><a href="/2020/04/26/실행-컨텍스트-Core-JavaScript/#thisBinding">this</a></li></ul></li></ul><a id="more"></a><hr><h2 id="execution_context">실행 컨텍스트란?</h2><hr><h3 id="스택-stack-과-큐-queue"><a href="#스택-stack-과-큐-queue" class="headerlink" title="스택(stack)과 큐(queue)"></a>스택(stack)과 큐(queue)</h3><ul><li>스택 : 출입구가 하나뿐인 데이터 구조<br>비어있는 스택에 순서대로 데이터 a,b,c,d를 저정했다면 꺼낼 때는 반대로 d,c,b,a의 순서대로 꺼낸다.<br>저장할 수 있는 데이터 스택이 넘치면 엔진에서 <code>RangeError: Maximum call stack size exceeded</code> 에러를 던집니다.</li></ul><ul><li>큐 : 한쪽은 입구, 한쪽은 출구를 담당하는 양쪽 데이터 구조<br>비어있는 큐에 순서대로 데이터 a,b,c,d를 저정했다면 꺼낼 때도 a,b,c,d의 순서대로 꺼낸다.</li></ul><hr><h4 id="엔진이-동일한-환경에-있는-코드들을-실행할-때"><a href="#엔진이-동일한-환경에-있는-코드들을-실행할-때" class="headerlink" title="엔진이 동일한 환경에 있는 코드들을 실행할 때"></a>엔진이 동일한 환경에 있는 코드들을 실행할 때</h4><p>필요한 환경정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련된 코드들을 실행하므로 코드의 환경과 순서를 보장받을 수 있습니다.</p><p>흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것입니다.</p><figure class="highlight js"><figcaption><span>실행 컨텍스트와 콜 스택</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">3.</span> inner(); </span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span> outer(); </span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ol><li><p>처음 자바스크립트 코드를 실행하는 순간 전역 컨텍스트가 콜 스택에 담깁니다.<br>(<del>코드 내부에서 별도의 실행 명령 없이 브라우저에서 자동으로 실행하므로 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화 된다고 이해</del>)</p></li><li><p>전역 컨텍스트와 관련된 코드들을 순차적으로 진행하다가 <code>outer()</code>를 호출하면 엔진은 <code>outer</code>에 대한 환경 정보를 수집해 <code>outer</code> 실행 컨텍스트를 생성한 후 콜 스택에 담습니다.<br>이때, 콜 스택 내부에서 전역 컨텍스트 위에 <code>outer</code> 실행 컨텍스트가 놓인 상태가 되어 <code>outer</code> 실행 컨텍스트 즉, <code>outer</code> 함수 내부 코드들을 순차적으로 실행합니다. (전역 컨텍스트 일시정지)</p></li><li><p>마찬가지로 <code>outer</code> 실행 컨텍스트를 진행하다 <code>inner()</code>함수의 실행 컨텍스트가 콜 스택의 가장 위에 담기면 <code>outer</code> 컨텍스트는 일시정지되고 <code>inner</code> 함수 내부 코드를 실행합니다.</p></li></ol><ul><li>실행 컨텍스트와 콜 스택<br><img src="/images/context_callStack.png" alt="실행 컨텍스트와 콜 스택"></li></ul><p><u>실행 컨텍스트가 콜 스택의 맨위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하는 시점.<br>기존의 컨텍스트는 새로 쌓인 컨텍스트보다 아래에 위치할 수 밖에 없음</u></p><p><mark>이렇게 어떤 컨텍스트가 활성화될 때 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는데 필요한 환경 정보들을 수집하여 실행 컨텍스트 객체에 저장함.</mark></p><p>이 객체는 엔진이 활용 목적으로 생성할 뿐 개발자 코드로 확인할 수는 없음<br>이에 담기는 정보들은 다음과 같습니다.</p><ul><li><p><code>VariableEnvironment</code> : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보.<br>선언 시점의 <code>LexicalEnvironment</code>의 스냅샷(<code>snapshot</code>)으로, 변경 사항은 반영되지 않음.</p></li><li><p><code>LexicalEnvironment</code> : 처음에는 <code>VariableEnvironment</code>와 같지만 변경 사항이 실시간으로 반영되는 점이 다름.</p></li><li><p><code>ThisBinding</code> : <code>this</code> 식별자가 바라봐야 할 대상 객체</p></li></ul><hr><h2 id="VariableEnvironment">VariableEnvironment</h2><p><code>VariableEnvironment</code>에 담기는 내용은 <code>LexicalEnvironment</code>와 같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다릅니다.</p><p>실행 컨텍스트를 생성할 때 <code>VariableEnvironment</code>에 정보를 먼저 담은 후<br>이를 그대로 복사하여 <code>LexicalEnvironment</code>를 만들고, 생성된 <code>LexicalEnvironment</code>를 활용합니다.</p><p><code>VariableEnvironment</code>와 <code>LexicalEnvironment</code> 는 초기화 과정 중에는 사실상 완전히 동일하고 둘 다 내부에 <code>environmentRecord</code>와 <code>outer-EnvironmentReference</code>로 구성되어 있습니다. </p><p>다음의 <code>LexicalEnvironment</code>를 살펴보며 자세한 내용과 둘의 코드 진행과정 차이를 알아봅시다.</p><hr><h2 id="LexicalEnvironment">LexicalEnvironment</h2><p><code>LexicalEnvironment</code>은 개발자 용어로 <code>정적 환경</code>으로 통하나 <u>실제 의미가 동일 하지는 않습니다.</u><br>커뮤니케이션을 위해 정적 환경으로 불리지만 <code>LexicalEnvironment</code>를 현재 컨텍스트의 내부에는 식별자들이 있고 그 외부 정보를 다른 객체가 참조하도록 구성되어 있다는 식의 <u>컨텍스트 구성 환경 정보들을 모아놓은</u> 느낌으로 이해합시다.</p><hr><h3 id="environmentRecord와-호이스팅"><a href="#environmentRecord와-호이스팅" class="headerlink" title="environmentRecord와 호이스팅"></a>environmentRecord와 호이스팅</h3><p><code>environmentRecord</code>에는 현재 컨텍스트와 관련된 코드의 <mark>식별자 정보</mark>들이 저장됩니다.</p><ul><li><p>컨텍스트를 구성하는 함수에 지정된 <mark>매개변수 식별자</mark></p></li><li><p>선언한 함수가 있을 경우 <mark>그 함수 자체</mark></p></li><li><p>var등으로 선언된 <mark>변수의 식별자 등</mark></p></li></ul><p><strong>컨텍스트 내부 전체를 처음부터 끝까지 순서대로 수집합니다.</strong></p><ul><li>참고 :<br><mark>전역 실행 컨텍스트는 변수 객체를 생성하지 않습니다.</mark><br>자바스크립트 구동 환경이 별도로 제공하는 객체 즉, <mark>전역 객체를 활용합니다</mark>. (브라우저의 window, Node.js의 global 객체 등)<br>이들은 자바스크립트 내장 객체가 아닌 호스트 객체로 분류됩니다.</li></ul><hr><h4 id="호이스팅-규칙"><a href="#호이스팅-규칙" class="headerlink" title="호이스팅 규칙"></a>호이스팅 규칙</h4><p><code>environmentRecord</code>가 현재 컨텍스트와 관련된 변수 정보를 수집한 상태는<br>컨텍스트의 코드가 실행되기 전의 상태입니다. 코드가 실행되기 전에 엔진이 이미 해당 환경에 속한 코드의 변수명을 모두 알고 있는 상태가 되는 것 입니다.</p><p>이 상태를 엔진이 식별자 정보들을 최상단으로 끌어올려놓고 순차적으로 코드를 실행하는 것처럼 보여<br><mark>변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념으로 등장한 개념이 호이스팅<mark> 입니다.</p><p>엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주하는 개념입니다.</p><figure class="highlight js"><figcaption><span>함수 선언의 호이스팅</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="number">1.</span> <span class="built_in">console</span>.log(b); <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">'bbb'</span>; <span class="comment">// 수집 대상 1(변수 선언)</span></span><br><span class="line">  <span class="number">2.</span> <span class="built_in">console</span>.log(b); <span class="comment">// (2)</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 수집 대상 2(함수 선언)</span></span><br><span class="line">  <span class="number">3.</span> <span class="built_in">console</span>.log(b); <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="comment">// function b()&#123;&#125;</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// bbb</span></span><br></pre></td></tr></table></figure><ul><li><code>environmentRecord</code>에는 매개변수의 이름, 함수 선언, 변수명 들이 담깁니다.<br>엔진은 이러한 호이스팅으로 인해 코드 실행전 부터 컨텍스트 구성 정보를 가지고 있습니다.</li></ul><ol><li><code>environmentRecord</code>에 의해 <code>var b;</code> 와 <code>var b = function b (){}</code>가 최상단에 위치한다고 볼 수 있습니다.<br><code>function b(){}</code> 를 참조하여 출력됩니다.</li></ol><ol start="2"><li><ol start="3"><li><code>var b = &#39;bbb&#39;</code> 으로 할당된 후 이므로 <code>bbb</code>가 출력됩니다.</li></ol></li></ol><hr><h4 id="함수-선언문과-함수-표현식"><a href="#함수-선언문과-함수-표현식" class="headerlink" title="함수 선언문과 함수 표현식"></a>함수 선언문과 함수 표현식</h4><ul><li><p>함수 선언문 : <code>function</code> 정의부만 존재하고 별도의 할당 명령이 없는 것<br><mark>반드시 함수명이 정의되어 있어야 함.</mark></p></li><li><p>함수 표현식 : 정의한 <code>function</code>을 별도의 변수에 할당하는 것<br><mark>함수명이 없어도 됨.</mark></p></li></ul><figure class="highlight js"><figcaption><span>함수를 정의하는 세 가지 방식</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125; <span class="comment">// 함수 선언문. 함수명 a가 곧 변수명.</span></span><br><span class="line">a(); <span class="comment">// 실행 OK.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;; <span class="comment">// (익명) 함수 표현식. 변수명 b가 곧 함수명.</span></span><br><span class="line">b(); <span class="comment">// 실행 OK.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;; <span class="comment">// 기명 함수 표현식. 변수명은 c, 함수명은 d.</span></span><br><span class="line">c(); <span class="comment">// 실행 OK.</span></span><br><span class="line">d(); <span class="comment">// 에러!</span></span><br></pre></td></tr></table></figure><ul><li>함수 선언문과 함수 표현식 호이스팅 시 차이.</li></ul><figure class="highlight js"><figcaption><span>호이스팅 전 원본 코드</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(multiply(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 함수 선언문 sum</span></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multiply = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 함수 표현식 multiply</span></span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>호이스팅 후 함수 표현식과 선언문의 차이</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 함수 선언문은 전체를 호이스팅합니다.</span></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> multiply; <span class="comment">// 변수는 선언부만 끌어올립니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(multiply(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">multiply = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 변수의 할당부는 원래 자리에 남겨둡니다.</span></span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>위에서 볼 수 있듯 함수 선언문은 함수 전체를 호이스팅</p></li><li><p>함수 표현식은 변수 부분만 호이스팅, 할당하는 부분은 호이스팅 하지 않음.</p></li><li><p><code>console.log(multiply(3,4))</code> 시점의 <code>multiply</code>에는 값이 할당돼 있지 않습니다.<br>따라서 <code>multiply is not a function</code> 에러 메시지가 출력되고 , 에러로 인해 아래 할당부 코드는 실행되지 않고 종료됩니다.</p></li></ul><hr><h3 id="스코프-스코프-체인-outerEnvironmentReference"><a href="#스코프-스코프-체인-outerEnvironmentReference" class="headerlink" title="스코프, 스코프 체인, outerEnvironmentReference"></a>스코프, 스코프 체인, outerEnvironmentReference</h3><ul><li><p>스코프(scope) : 식별자에 대한 유효범위</p></li><li><p>스코프 체인 : 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것</p></li><li><p>outerEnvironmentReference : 스코프 체인을 가능하게 하는 <code>LexicalEnvironment</code>의 두 번째 수집자료 <code>outerEnvironmentReference</code></p></li></ul><hr><h4 id="스코프-체인"><a href="#스코프-체인" class="headerlink" title="스코프 체인"></a>스코프 체인</h4><p><code>outerEnvironmentReference</code>는 현재 호출된 함수가 <mark>선언될 당시의 LexicalEnvironment</mark>를 참조합니다. (== 콜 스택 상에서 실행 컨텍스트가 활성화된 상태)</p><figure class="highlight js"><figcaption><span>outerEnvironmentReference 동작 예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//(...) </span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//(...)</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//(...)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a 함수 내부에 b 함수를 선언하고 다시 b 함수 내부에 c 함수를 선언했습니다.</p><ul><li><p>이 경우 <code>함수 c</code>의 <code>outerEnvironmentReference</code>는 <code>함수 b</code>의 <code>LexicalEnvironment</code>를 참조합니다.<br><code>함수 b</code>의 <code>LexicalEnvironment</code>에 있는 <code>outerEnvironmentReference</code>는 다시 <code>함수 a</code>의 <code>LexicalEnvironment</code>를 참조합니다.</p></li><li><p>이처럼 <code>outerEnvironmentReference</code>는 연결리스트 형태를 가지고 있고 선언 시점의 <code>LexicalEnvironment</code>를 계속 찾아 올라가면 마지막에는 전역 컨텍스트의 <code>LexicalEnvironment</code>가 있을 것입니다.</p></li><li><p><code>outerEnvironmentReference</code>는 <mark>자신이 선언된 시점의 LexicalEnvironment만 참조</mark>하고 있으므로 가장 가까운 요소부터 차례로 접근할 수 밖에 없습니다.</p></li></ul><p>이런 구조적 특성 덕분에 여러 스코프에서 동일한 스코프를 선언한 경우에는 <mark>무조건 스코프 체인 상에서 가장 먼저 발견된 식별자만 접근 가능</mark> 하게 됩니다.</p><figure class="highlight js"><figcaption><span>개발자 도구로 스코프 체인 확인법 -크롬</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(inner);</span><br><span class="line">  &#125;;</span><br><span class="line">  inner();</span><br><span class="line">&#125;;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><ul><li>함수 내부에 함수를 출력하는 방법으로 현재 실행 컨텍스트를 제외한 상위 스코프 정보들을 개발자 도구에서 확인할 수 있습니다. (<code>debugger</code> 사용시 더욱 자세한 정보 확인 가능)</li></ul><hr><h4 id="전역변수와-지역변수"><a href="#전역변수와-지역변수" class="headerlink" title="전역변수와 지역변수"></a>전역변수와 지역변수</h4><ul><li><p>전역변수 : 전역 스코프에서 선언한 변수</p></li><li><p>지역변수 : 전역 스코프가 아닌 함수 스코프 또는 블록 스코프 내부에서 선언한 변수<br>지역 변수는 선언된 스코프 외부에서 접근할 수 없음.</p></li></ul><hr><h2 id="thisBinding">this</h2><p>실행 컨텍스트의 <code>thisBinding</code>에는 <code>this</code>로 지정된 객체가 저장됩니다.<br>실행 컨텍스트 활성화 당시에 <code>this</code>가 지정되지 않으면 <code>this</code>는 전역 객체를 참조하게 됩니다.</p><p>함수를 호출하는 방식 등 사용되는 방법에 따라 <code>this</code>가 참조하는 대상이 변하게 되므로<br><code>this</code>에 자세한 내용은 따로 다루도록 하겠습니다.</p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/04/26/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-Core-JavaScript/#disqus_thread</comments>
    </item>
    
    <item>
      <title>데이터 타입 -Core JavaScript</title>
      <link>https://hdw0903.github.io/2020/04/16/%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%83%80%EC%9E%85%20-Core%20JavaScript/</link>
      <guid>https://hdw0903.github.io/2020/04/16/%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%83%80%EC%9E%85%20-Core%20JavaScript/</guid>
      <pubDate>Thu, 16 Apr 2020 00:00:39 GMT</pubDate>
      <description>
      
        &lt;p&gt;자바스크립트가 데이터를 처리하는 과정을 살펴봄으로써&lt;br&gt;기본형 타입과 참조형 타입이 서로 다르게 동작하는 이유를 이해하고&lt;br&gt;이를 적절히 활용할 수 있게 되는 것을 목표로 합니다.&lt;br&gt;나아가 데이터 타입과 관련된 중요한 개념 몇 가지를 추가로 살펴봅니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_1&quot;&gt;데이터 타입의 종류&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_2&quot;&gt;데이터 타입에 관한 배경 지식&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;메모리와 데이터&lt;/li&gt;
&lt;li&gt;식별자와 변수&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_3&quot;&gt;변수 선언과 데이터 할당&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;변수 선언&lt;/li&gt;
&lt;li&gt;데이터 할당&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_4&quot;&gt;기본형 데이터와 참조형 데이터&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;불변값&lt;/li&gt;
&lt;li&gt;가변값&lt;/li&gt;
&lt;li&gt;변수 복사 비교&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_5&quot;&gt;불변 객체&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;불변 객체를 만드는 간단한 방법&lt;/li&gt;
&lt;li&gt;얕은 복사와 깊은 복사&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_6&quot;&gt;undefined 와 null&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>자바스크립트가 데이터를 처리하는 과정을 살펴봄으로써<br>기본형 타입과 참조형 타입이 서로 다르게 동작하는 이유를 이해하고<br>이를 적절히 활용할 수 있게 되는 것을 목표로 합니다.<br>나아가 데이터 타입과 관련된 중요한 개념 몇 가지를 추가로 살펴봅니다.</p><ul><li><a href="/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_1">데이터 타입의 종류</a></li><li><a href="/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_2">데이터 타입에 관한 배경 지식</a><ul><li>메모리와 데이터</li><li>식별자와 변수</li></ul></li><li><a href="/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_3">변수 선언과 데이터 할당</a><ul><li>변수 선언</li><li>데이터 할당</li></ul></li><li><a href="/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_4">기본형 데이터와 참조형 데이터</a><ul><li>불변값</li><li>가변값</li><li>변수 복사 비교</li></ul></li><li><a href="/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_5">불변 객체</a><ul><li>불변 객체를 만드는 간단한 방법</li><li>얕은 복사와 깊은 복사</li></ul></li><li><a href="/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_6">undefined 와 null</a></li></ul><a id="more"></a><hr><h2 id="1_1">데이터 타입의 종류</h2><p>자바스크립트의 데이터 타입에는 크게 두 가지가 있습니다. 바로 기본형과 참조형 입니다.</p><ul><li><p><strong>기본형</strong>(원시형, <code>primitive type</code>)<br>number, string, boolean, null, undefined, Symbol</p></li><li><p><strong>참조형</strong>(<code>reference type</code>)<br>object, Array, Function, Date, RegExp, Map, WeakMap, Set, WeakSet 등이 객체의 하위 분류에 속합니다.</p></li></ul><img src="/images/JavaScript-Data-Types.PNG"><p><a href="https://tutorial.eyehunts.com/js/javascript-data-types-and-examples">https://tutorial.eyehunts.com/js/javascript-data-types-and-examples</a></p><p>일반적으로 기본형은 할당이나 연산시 복제되고 참조형은 참조된다고 알려져 있습니다.<br>엄밀히 말하면 둘 모두 복제를 하긴 합니다.<br>다만 <u>기본형은 값이 담긴 주소값을 바로 복제하는 반면 참조형은 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제한다는 점이 다릅니다.</u></p><ul><li><p>기본형은 <code>불변성(immutability)</code>을 뜁니다.<br><del>언뜻 생각해 보면 혼란스러울 수 있습니다.</del>  </p><p>불변성을 잘 이해하려면 메모리와 데이터에 대한 지식이 필요하고, 식별자와 변수의 개념을 구분할 수 있어야합니다.<br>메모리 영역에서 자바스크립트의 데이터가 처리되는 과정을 알아봅시다.</p></li></ul><hr><h2 id="1_2">데이터 타입에 관한 배경 지식</h2><hr><h3 id="메모리와-데이터"><a href="#메모리와-데이터" class="headerlink" title="메모리와 데이터"></a>메모리와 데이터</h3><p>컴퓨터는 모든 데이터를 <code>0 또는 1</code>로 기억합니다.<br><code>0 또는 1</code>만 표현할 수 있는 하나의 메모리 조각을 <code>비트(bit)</code>라고 합니다. 각 비트는 고유한 식별자(<code>unique identifier</code>)를 통해 위치를 확인할 수 있습니다.</p><p>1byte = 8 bit 입니다.</p><p>메모리 용량이 과거보다 월등히 커진 영향으로 자바스크립트에서는 숫자의 경우 정수형인지 부동소수형인지 구분하지 않고 64비트 (8바이트)를 확보합니다.</p><p><mark>모든 데이터는 바이트 단위의 식별자, 즉 메모리 주소값(memory address)을 통해 서로 구분하고 연결할 수 있습니다.</mark></p><hr><h3 id="식별자와-변수"><a href="#식별자와-변수" class="headerlink" title="식별자와 변수"></a>식별자와 변수</h3><ul><li><p><strong>변수</strong>는 “변할 수 있는 데이터” 입니다. (숫자,문자열,객체,배열 모두가 데이터 입니다.)</p></li><li><p><strong>식별자</strong>는 어떤 데이터를 식별하는데 사용하는 이름. 즉 <code>변수명</code> 입니다.</p></li></ul><hr><h2 id="1_3">변수 선언과 데이터 할당</h2><hr><h3 id="변수-선언"><a href="#변수-선언" class="headerlink" title="변수 선언"></a>변수 선언</h3><p>변수 선언의 동작 원리를 알아봅니다.</p><blockquote><p>var a;</p></blockquote><p>위 코드를 말로 해석하자면 <strong>변할 수 있는 데이터를 만들고</strong>, <code>식별자 이름을 a</code>로 설정합니다.</p><p>즉, 엔진에서는 <strong>메모리에서 비어있는 공간을 확보</strong>하고 이 <u>메모리 영역의 이름(식별자)을 a</u>로 설정합니다.</p><p>여기까지가 변수 선언 과정입니다.<br>이후에 a에 접근하고자 하면 엔진은 메모리 영역에서 a라는 이름을 가진 주소를 검색해 해당 영역에 담긴 데이터를 반환합니다.</p><hr><h3 id="데이터-할당"><a href="#데이터-할당" class="headerlink" title="데이터 할당"></a>데이터 할당</h3><blockquote><p>var a = ‘abc’;</p></blockquote><p>a라는 이름의 주소를 검색해서 그곳에 문자열 ‘abc’를 할당할 것 같지만,<br>실제로 <u>해당 위치에 문자열을 직접 저장하지는 않습니다.</u></p><p>엔진에서는 데이터를 저장하기 위한 <strong>별도의 메모리 공간을 확보하여 문자열 ‘abc’를 저장</strong>하고,<br><mark>그 주소를 변수 영역에 저장하는 식으로 이뤄집니다.</mark><br><strong>메모리 공간</strong>은 <strong>변수영역</strong> 과 <strong>데이터 영역</strong>을 <u>구분지어 값을 저장</u>한다고 생각하면 됩니다.</p><ul><li>데이터 할당과 변수 선언 흐름</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'abc'</span>;  </span><br><span class="line"><span class="comment">// 위 코드는 아래 코드와 동일 합니다.  </span></span><br><span class="line"><span class="keyword">var</span> a;  </span><br><span class="line">a = <span class="string">'abc'</span>;  </span><br><span class="line"><span class="comment">// 즉 엔진의 흐름은  </span></span><br><span class="line"><span class="number">1.</span> 변수 영역에서 빈 공간을 확보하고  </span><br><span class="line"><span class="number">2.</span> 확보한 공간의 식별자를 a로 지정합니다.  </span><br><span class="line"><span class="number">3.</span> 변수 영역이 아닌 데이터 영역의 빈 공간에 문자열 <span class="string">'abc'</span>를 저장합니다.  </span><br><span class="line"><span class="number">4.</span> 변수 영역에서 a 식별자를 검색합니다.  </span><br><span class="line"><span class="number">5.</span> 데이터 영역에서 생성한 문자열의 주소를   </span><br><span class="line"> a 식별자로 검색한 변수 영역에 대입합니다.</span><br></pre></td></tr></table></figure><p>이러한 방식은 데이터를 변경(or 삭제/추가)등의 작업을 할때<br>변경된 데이터의 주소들을 다시 식별자에 연결하여 저장하지 않아도 됩니다.<br>(엔진이 처리할 연산을 최소한으로 해줍니다.)</p><p>효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적입니다.</p><p>예를 들어 다수의 변수를 생성하여 모든 변수에 숫자 5를 할당한다면,<br>변수의 개수만큼 변수의 메모리 공간마다 5를 할당해야 합니다.<br>하지만 5를 별도의 공간(메모리 공간 중 변수 영역이 아닌 데이터 영역)에 한 번만 저장하고 그 주소를 연결한다면? 엔진의 중복 연산 처리 효율이 높아집니다.</p><hr><h2 id="1_4">기본형 데이터와 참조형 데이터</h2><hr><h3 id="불변값"><a href="#불변값" class="headerlink" title="불변값"></a>불변값</h3><p>변수 와 상수의 차이는 <code>“변경 가능성”</code>입니다.<br><strong>변수</strong>는 변할 수 있는 데이터,<br><strong>상수</strong>는 바뀌지 않습니다.  </p><p>이 <code>“변경 가능성”</code>의 기준은 변수 영역의 메모리 입니다.<br><mark>한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건입니다.</mark></p><p>반면 상수 와 불변값을 구분짓는 <code>“변경 가능성”</code>의 기준은 <strong>데이터 영역 메모리</strong> 입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">var</span> a = <span class="string">'abc'</span>;  </span><br><span class="line">a = a + <span class="string">'def'</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span> <span class="keyword">var</span> b = <span class="number">5</span>;  </span><br><span class="line"><span class="keyword">var</span> c = <span class="number">5</span>;  </span><br><span class="line"><span class="number">3.</span> b = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><ol><li><code>변수 a</code> 에 문자열 <code>‘abc’</code>를 할당했다가 아래 코드로 <code>‘def’</code>를 추가하면<br>기존의 <code>‘abc’</code>가 <code>‘abcdef’</code>로 바뀌는 것이 아니라 <strong>새로운 문자열</strong> <code>‘abcdef’</code>를 만들어<br><strong>그 주소를 변수 a에 저장</strong>합니다. <code>‘abc’</code>와 <code>‘abcdef’</code>는 <strong>완전히 별개의 데이터</strong> 입니다.</li></ol><ol start="2"><li><code>변수 b</code> 에 데이터 영역을 만들어 <strong>5를 설정하고 그 주소를 b에 저장</strong>합니다.<br>다음 코드에서 <code>c</code>에 5를 할당하려고 하면 <strong>엔진은 데이터 영역에서 5를 찾습니다.</strong><br>이미 만들어진 주소가 있으므로 그 주소를 <strong>재활용하여 c에 저장</strong>합니다.</li></ol><ol start="3"><li><code>변수 b</code> 의 값을 7로 바꾸려고 합니다. <strong>기존에 저장된 5를 7로 바꾸는 것이 아니라</strong><br> <strong>데이터 영역에서 7을 찾아 있으면 그 주소를 재활용하고 없다면 새로 만들어 b에 저장합니다.</strong><br> <code>결국 5 와 7 모두 다른 값으로 변경할 수 없습니다.</code></li></ol><p>이처럼 문자열 값 과 숫자 값 모두 한 번 만든 값을 바꿀 수 없고, 다른 값으로 변경할 수 없습니다. 변경은 새로 만드는 동작을 통해서만 이뤄집니다. 한 번 만들어진 값은 <code>GC(Garbage Collection)</code> 당하지 않는 한 영원히 변하지 않습니다. 이것이 바로 <strong>불변값의 특징</strong>입니다.</p><p><strong>기본형(원시값, <code>primitive</code>)데이터</strong>인 number, string, boolean, null, undefined, Symbol은 모두 불변값입니다.</p><hr><h3 id="가변값"><a href="#가변값" class="headerlink" title="가변값"></a>가변값</h3><p><strong>참조형(<code>reference</code>) 데이터</strong>의 기본적인 성질은 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용하는 방법도 있습니다.</p><p>참조형 데이터를 변수에 할당하는 과정부터 확인해 봅니다.</p><figure class="highlight js"><figcaption><span>참조형 데이터의 할당</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 =&#123;  </span><br><span class="line"> a: <span class="number">1</span>,  </span><br><span class="line"> b: <span class="string">'bbb'</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p>엔진은 우선 변수 영역의 빈공간을 확보하고, 그 주소의 이름을 obj로 지정합니다.</p></li><li><p>{} 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 주소 이름으로 각각 a 와 b라는 프로퍼티 이름을 지정합니다.</p></li><li><p>데이터 영역에서 숫자 1을 검색합니다. 검색 결과가 없으므로 데이터 영역에 저장하고 이 주소를 a 주소에 저장합니다. 문자열 ‘bbb’역시 데이터 영역에 저장하고 이 주소를 b 주소에 저장합니다.</p></li></ol><p><mark>기본형 데이터와의 차이는 “객체의 변수(프로퍼티) 영역”이 별도로 존재한다는 점입니다.</mark><br>객체가 별도로 할애한 영역은 변수 영역일 뿐 “데이터 영역”은 기존의 메모리 공간을 그대로 활용하고 있습니다.<br>데이터 영역에 저장된 값은 모두 불변값입니다. 그러나 변수에는 얼마든지 다른 값을 대입할 수 있습니다.<br>바로 <strong>이 부분 때문에 흔히 참조형(reference)데이터는 가변값이라고 하는 것</strong>입니다.</p><figure class="highlight js"><figcaption><span>참조형 데이터의 프로퍼티 재할당</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 =&#123;  </span><br><span class="line"> a: <span class="number">1</span>,  </span><br><span class="line"> b: <span class="string">'bbb'</span>  </span><br><span class="line">&#125;;  </span><br><span class="line">obj.a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li><code>obj1</code>의 <code>a</code> 프로퍼티에 숫자 <code>2</code>를 할당하려고 합니다. 데이터 영역에서 숫자 <code>2</code>를 검색합니다.<br>존재하지 않으므로 데이터 영역을 새로만들어 <code>2</code>를 저장합니다. 이 주소를 프로퍼티 영역의 <code>a</code> 주소에 저장합니다.<br>변수 <code>obj1</code>이 <strong>바라보고 있는 주소는 데이터 영역으로 변하지 않았습니다. 즉 새로운 Object가 만들어진 것이 아니라</strong> <code>Object</code> 내부의 프로퍼티 영역 <code>a</code>의 값만 바뀐 것 입니다.</li></ul><p>다음은 <strong>참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우</strong> 입니다.<br>이러한 경우를 <code>중첩객체(nested object)</code>라고 합니다.</p><figure class="highlight js"><figcaption><span>중첩된 참조형 데이터(객체)의 프로퍼티 할당</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;  </span><br><span class="line"> x : <span class="number">3</span>,  </span><br><span class="line"> arr : [ <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>엔진은 우선 <strong>변수 영역의 빈공간을 확보</strong>하고, 그 주소의 이름을 <code>obj</code>로 지정합니다.</li></ol><ol start="2"><li>데이터 저장 공간에 데이터를 저장하려는데( {} ), 이 데이터는 여러개의 프로퍼티와 값들을 모아놓은 그룹(객체)입니다. <strong>각 프로퍼티들을 저장하기 위해 별도의 프로퍼티 영역을 마련하고 그 주소를 {}의 주소에 저장합니다.</strong></li></ol><ol start="3"><li>각 프로퍼티 영역에 <code>x</code> 와 <code>arr</code> 를 주소 이름으로 지정합니다.</li></ol><ol start="4"><li>데이터 영역에서 숫자 <code>3</code>을 검색합니다. 없으므로 새로 만들고 이 주소를 프로퍼티 영역 x의 주소에 저장합니다.</li></ol><ol start="5"><li>데이터 영역에 <code>arr</code> 로 저장할 값은 <code>Array</code>로써 별도의 <code>Array</code> 영역을 만들어 저장하고 프로퍼티 영역 <code>arr</code>의 주소에 저장합니다.</li></ol><ol start="6"><li>배열의 요소가 총 <code>3</code>개 이므로 <code>Array</code> 영역에 공간을 확보하고 각각 <strong>인덱스를 부여하고 주소이름으로 사용</strong>합니다.</li></ol><ol start="7"><li>데이터 영역에서 숫자 <code>3</code>을 검색하여 그 주소를 <code>인덱스 0</code>의 주소에 저장합니다.</li></ol><ol start="8"><li>데이터 영역에 숫자 <code>4</code>가 없으므로 <strong>새로운 데이터 영역을 만들고 그 주소를</strong> <code>인덱스 1</code>의 주소에 저장합니다.</li></ol><ol start="9"><li>데이터 영역에 숫자 <code>5</code>도 없으므로 생성한 주소를 <code>인덱스 2</code>의 주소에 저장합니다.</li></ol><p><mark>이제 obj.arr[1]을 검색하고자 하면 엔진의 메모리에서는 다음과 같은 과정을 거칩니다.</mark></p><pre><code>1. obj라는 식별자를 가진 주소를 찾습니다.2. obj 주소에 연결된 데이터 영역의 주소로 이동합니다.3. 데이터 영역에 연결된 프로퍼티 영역의 주소로 이동합니다.4. 프로퍼티 영역에서 arr이라는 식별자를 가진 주소를 찾습니다.5. arr 주소에 연결된 Array 영역의 주소로 이동합니다.6. Array 영역에서 인덱스 1(==식별자 이름)을 검색하여 해당하는 주소로 이동합니다.7. 해당하는 주소의 값 숫자형 데이터 4를 반환합니다.</code></pre><p><mark>만약 이 상태에서 다음과 같이 재할당을 하면 다음과 같은 과정을 거칩니다.</mark></p><blockquote><p>obj.arr = “str”;</p></blockquote><p>데이터 영역에 문자열 <code>“str”</code>을 저장하고, 그 주소를 프로퍼티 영역에 저장합니다.(재할당)  </p><p>그러면 기존에 있던 <code>Array</code> 영역의 인덱스 주소를 저장하던 데이터 영역(공간)은 자신의 주소를 참조하는 변수가 하나도 없게 됩니다. (프로퍼티 영역인 arr 주소의 값이 재할당 되므로 데이터 영역의 str을 주소로 갖음)  </p><p><code>참조 카운트</code>(자신을 참조하는 변수의 개수)가 <code>0</code>인 메모리는 <code>garbage collector</code>의 수거 대상이 됩니다.  </p><p>즉, <strong>Array 영역의 주소를 저장하던 데이터 영역은</strong> <code>GC</code>의 수거 대상이며,  </p><p><code>GC</code>가 처리되는 과정에서 연쇄적으로 <code>Array</code> 영역의 <code>참조 카운트</code>도 <code>0</code>이 되고 <code>GC</code>의 대상이되어 제거됩니다.</p><p>제거된 메모리 영역은 다시 새로운 값을 할당할 수 있는 빈 공간이 됩니다.</p><hr><h3 id="변수-복사-비교"><a href="#변수-복사-비교" class="headerlink" title="변수 복사 비교"></a>변수 복사 비교</h3><p>변수를 복사할 때<br><code>기본형</code>(원시값, primitive) 데이터 와 <code>참조형</code>(reference) 데이터의 차이</p><figure class="highlight js"><figcaption><span>변수 복사</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primitive  </span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;  </span><br><span class="line"><span class="keyword">var</span> b = a;   </span><br><span class="line">  </span><br><span class="line"><span class="comment">// reference  </span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">c</span>: <span class="number">10</span>, <span class="attr">d</span>: <span class="string">'ddd'</span> &#125;;  </span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br></pre></td></tr></table></figure><ol><li><p>변수 영역의 빈 공간을 확보하고 <code>식별자를 a</code>로 지정합니다.<br><code>숫자 10</code>을 데이터 영역에서 검색하여, 없으면 데이터 영역에 새로 만들어 저장하고 주소를 <code>a</code>의 주소에 저장합니다.</p></li><li><p>변수 영역의 빈 공간을 확보하고 <code>식별자를 b</code>로 지정합니다. 그 후에 변수 영역에서 <code>a</code>식별자를 검색해 <code>a</code>에 저장된 데이터 주소(10)를 <code>b 변수 영역</code>에 저장합니다.</p></li><li><p>변수 영역의 빈 공간을 확보하고 식별자를 <code>obj1</code>로 지정합니다. 데이터 영역을 새로 만들고 데이터 그룹을 담을 프로퍼티 영역을 만들어 이 주소를 데이터 영역에 저장합니다.<br>각각의 프로퍼티 영역에 식별자 이름으로 <code>c</code> , <code>d</code>으로 사용하고 각각의 값 <code>(10, ‘ddd’)</code>을 데이터 영역에서 검색합니다. <code>10</code>은 이미 있으므로 기존의 주소를 프로퍼티 영역에 연결하고, <code>‘ddd’</code>는 새로 만들어 프로퍼티 영역에 연결합니다.</p></li><li><p>변수 영역의 빈 공간을 확보하고 식별자를 <code>obj2</code>로 지정합니다. 그 후에 변수 영역에서 식별자 <code>obj1</code>을 검색해 <code>obj1</code>에 저장된 데이터 주소를 <code>obj2</code> 변수 영역에 저장합니다.</p></li></ol><p><mark>변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일합니다. 복사 과정은 동일하지만 데이터 할당 과정에서 이미 차이가 있기 때문에 변수 복사 이후의 동작에서 큰 차이가 발생합니다.</mark></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수 복사이후 값 변경 결과 비교(1)  </span></span><br><span class="line"><span class="comment">// object 프로퍼티 변경 시  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// primitive  </span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;  </span><br><span class="line"><span class="keyword">var</span> b = a;   </span><br><span class="line">  </span><br><span class="line"><span class="comment">// reference  </span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">c</span>: <span class="number">10</span>, <span class="attr">d</span>: <span class="string">'ddd'</span> &#125;;  </span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 프로퍼티 값 변경  </span></span><br><span class="line">b = <span class="number">15</span>;  </span><br><span class="line">obj2.c = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>b = 15</code> 코드는 데이터 영역에 <code>15</code>가 없으므로 새로운 데이터 영역에 저장하고 그 주소를 변수 영역 식별자 <code>b</code>인 주소에 저장합니다.</p></li><li><p><code>obj.c = 20</code> 코드는 데이터 영역에 <code>20</code>이 없으므르 새로운 데이터 영역에 저장하고 그 주소를 변수 영역 식별자 <code>obj2</code>의 주소를 찾고 이어서 <code>obj2</code>에 저장되있는 프로퍼티 영역의 <code>c</code>주소를 찾아 그 곳에 주소를 저장합니다.</p></li></ul><p><strong>기본형(원시값, primitive) 데이터를 복사한</strong> <code>변수b</code>의 값을 바꾸면 <code>데이터영역 b 주소</code>의 값이 달라집니다.  </p><p><strong>참조형(reference) 데이터를 복사한</strong> <code>변수 obj2</code>의 프로퍼티 값을 바꾸면 바라보는 <code>obj2의 프로퍼티 주소</code>는 달라지지 않습니다. 값만 변합니다.</p><p>즉, 변수 a와 b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1 과 obj2는 여전히 같은 객체를 바라보고 있는 상태입니다. (a !== b), (obj1 === obj2)</p><p><mark>이 결과가 바로 기본형과 참조형 데이터의 가장 큰 차이점 입니다.</mark> <del>대부분의 자바스크립트 책에서 ‘기본형은 값을 복사하고 참조형은 주솟값을 복사한다’고 설명하고 있지만, 사실은 어떤 데이터 타입이든 변수에 할당하기 위해서는 주솟값을 복사해야 하기 때문에</del> <mark>엄밀히 따지면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수 밖에 없습니다. 다만 기본형은 주솟값 복사 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이가 있는 것입니다.</mark></p><figure class="highlight js"><figcaption><span>Object 자체를 변경 시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수 복사이후 값 변경 결과 비교(2)  </span></span><br><span class="line"><span class="comment">// object 변경 시  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// primitive  </span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;  </span><br><span class="line"><span class="keyword">var</span> b = a;   </span><br><span class="line">  </span><br><span class="line"><span class="comment">// reference  </span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">c</span>: <span class="number">10</span>, <span class="attr">d</span>: <span class="string">'ddd'</span> &#125;;  </span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;  </span><br><span class="line">  </span><br><span class="line">b = <span class="number">15</span>;  </span><br><span class="line">obj2 = &#123; <span class="attr">c</span>: <span class="number">20</span>, <span class="attr">d</span>: <span class="string">'ddd'</span> &#125;; <span class="comment">//object 자체를 변경</span></span><br></pre></td></tr></table></figure><ul><li>obj2에도 새로운 객체를 할당함으로써 값을 직접 변경했습니다.<br>데이터 영역에 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 주소에 저장하게 됩니다.<br>즉, 기본형 데이터의 값 변경처럼 참조형 데이터가 바라보는 주소가 달라지게 되는 것입니다.<br><mark>따라서 참조형 데이터가 “가변값”이라고 설명할 때의 “가변”은 참조형 데이터 내부의 프로퍼티 값을 변경할 때의 성질입니다. 참조형 데이터 자체를 변경하는 경우는 성립되지 않습니다.</mark></li></ul><hr><h2 id="1_5">불변 객체</h2><hr><h3 id="불변-객체를-만드는-간단한-방법"><a href="#불변-객체를-만드는-간단한-방법" class="headerlink" title="불변 객체를 만드는 간단한 방법"></a>불변 객체를 만드는 간단한 방법</h3><p>참조형 데이터의 “가변”은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때 성립되므로<br>내부 프로퍼티를 변경할 필요가 있을 때 마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하거나<br>자동으로 새로운 객체를 만드는 도구<em>를 활용하면 객체 역시 불변성을 확보할 수 있습니다.<br><sub></em>대표적으로 immutable.js, immer.js, immutability-helper 등의 라이브러리가 있고,<br>ES6의 spread operator, Object.assign 메서드 등도 새로운 객체를 만드는 도구 목적으로 활용할 수 있습니다.</sub></p><p>ex)값으로 전달받은 객체를 변경하더라도 원본 객체는 변하지 않게 하고 싶을 경우 불변 객체가 필요합니다.</p><figure class="highlight js"><figcaption><span>가변성의 문제점</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;  </span><br><span class="line"> name: <span class="string">'Jaenam'</span>,  </span><br><span class="line"> gender: <span class="string">'male'</span>,  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> changeName = <span class="function"><span class="keyword">function</span>(<span class="params">user, newName</span>) </span>&#123;  </span><br><span class="line"> <span class="keyword">var</span> newUser = user;  </span><br><span class="line"> newUser.name = newName;  </span><br><span class="line"> <span class="keyword">return</span> newUser;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> user2 = changeName(user, <span class="string">'Jung'</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (user !== user2) &#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'유저 정보가 변경되었습니다.'</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">console</span>.log(user.name, user2.name); <span class="comment">// Jung Jung  </span></span><br><span class="line"><span class="built_in">console</span>.log(user === user2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><code>user</code> 객체의 <code>name</code> 프로퍼티를 <code>‘Jung’</code>으로 바꾸는 함수를 호출해 반환 값을 <code>user2</code> 변수에 담습니다.<br>그 결과 <code>user</code> 와 <code>user2</code>의 <code>name</code> 프로퍼티가 모두 <code>‘Jung’</code>으로 출력되고 (user === user2)가 true로 같다는 것을 알 수 있습니다.</li></ul><p>원본 데이터를 변경하고 싶지 않은 경우 각 변수마다 다른 객체를 바라보게 만들어야겠습니다.</p><figure class="highlight js"><figcaption><span>서로 다른 객체를 바라보게</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;  </span><br><span class="line"> name: <span class="string">'Jaenam'</span>,  </span><br><span class="line"> gender: <span class="string">'male'</span>,  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> changeName = <span class="function"><span class="keyword">function</span>(<span class="params">user, newName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;  </span><br><span class="line">        name: newName,  </span><br><span class="line">        gender: user.gender,  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> user2 = changeName(user, <span class="string">'Jung'</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (user !== user2) &#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'유저 정보가 변경되었습니다.'</span>); <span class="comment">// 유저 정보가 변경되었습니다.  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">console</span>.log(user.name, user2.name); <span class="comment">// Jaenam Jung  </span></span><br><span class="line"><span class="built_in">console</span>.log(user === user2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>changeName() 함수가 새로운 Object를 반환하도록 한 간단한 예시 입니다.<br>user 와 user2는 서로 다른 Object가 됩니다.</li></ul><hr><h3 id="얕은-복사와-깊은-복사"><a href="#얕은-복사와-깊은-복사" class="headerlink" title="얕은 복사와 깊은 복사"></a>얕은 복사와 깊은 복사</h3><p>얕은 복사(<code>shallow copy</code>)는 바로 아래 단계의 값만 복사하는 방법이고,<br>깊은 복사(<code>deep copy</code>)는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법입니다.</p><p>얕은 복사는 중접된 <code>object</code>에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사합니다.<br>그러므로 해당 <u>프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터 주소</u>를 가리키게 됩니다.<br>즉, <mark>얕은 복사는 사본을 바꾸면 원본도 바뀌고, 원본을 바꾸면 사본도 바뀝니다.</mark></p><figure class="highlight js"><figcaption><span>중첩된 객체에 대한 얕은 복사</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//복사해서 새로운 object를 반환하는 함수</span></span><br><span class="line"><span class="keyword">var</span> copyObject = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">    result[prop] = target[prop];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Jaenam'</span>,</span><br><span class="line">  urls: &#123;</span><br><span class="line">    portfolio: <span class="string">'http://github.com/abc'</span>,</span><br><span class="line">    blog: <span class="string">'http://blog.com'</span>,</span><br><span class="line">    facebook: <span class="string">'http://facebook.com/abc'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> user2 = copyObject(user);</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> user2.name = <span class="string">'Jung'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user.name === user2.name); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> user.urls.portfolio = <span class="string">'http://portfolio.com'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user.urls.portfolio === user2.urls.portfolio); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> user2.urls.blog = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user.urls.blog === user2.urls.blog); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol><li><p>사본인 <code>user2</code>의 <code>name</code> 프로퍼티 값을 바꿔도 원본 <code>user</code>의 <code>name</code> 프로퍼티 값은 바뀌지 않습니다.</p></li><li><p>2번 과 3번 코드는 원본과 사본 어느 쪽을 바꾸더라도 다른 한쪽의 값 역시 바뀐 것을 확인할 수 있습니다.</p></li></ol><p>즉, <code>user</code> 객체에 직접 속한 프로퍼티에 대해서는 복사하여 새로운 데이터가 만들어진 반면,<br>한 단계 더 들어간 <code>urls object</code>의 내부 프로퍼티들은 기존 데이터를 참조합니다.</p><p>이런 현상을 막기 위해서는 한 단계 더 들어가는 프로퍼티들도 불변 객체로 만들 필요가 있습니다.</p><figure class="highlight js"><figcaption><span>중첩된 객체에 대한 깊은 복사</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//복사해서 새로운 object를 반환하는 함수</span></span><br><span class="line"><span class="keyword">var</span> copyObject = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">    result[prop] = target[prop];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Jaenam'</span>,</span><br><span class="line">  urls: &#123;</span><br><span class="line">    portfolio: <span class="string">'http://github.com/abc'</span>,</span><br><span class="line">    blog: <span class="string">'http://blog.com'</span>,</span><br><span class="line">    facebook: <span class="string">'http://facebook.com/abc'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user2 = copyObject(user);</span><br><span class="line"><span class="number">1.</span> user2.urls = copyObject(user.urls);</span><br><span class="line"></span><br><span class="line">user.urls.portfolio = <span class="string">'http://portfolio.com'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user.urls.portfolio === user2.urls.portfolio); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">user2.urls.blog = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user.urls.blog === user2.urls.blog); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ol><li>사본 <code>user2</code>의 <code>urls</code>프로퍼티에 <code>copyObject()</code> 함수를 실행하여 원본 <code>user</code>의 <code>urls</code>프로퍼티의 내부까지 복사하여 새로운 <code>object</code>를 만들어 할당했습니다. 그 결과 원본과 사본의 참조형 데이터 프로퍼티 값이 서로 다른 결과를 얻어냈습니다.</li></ol><hr><h4 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h4><p>정리하자면 <u>객체를 복사할 때 객체 내부의 모든 값을 복사하여 새로운 객체를 만들고자 할때</u>.<br>객체의 프로퍼티가 <mark>기본형 데이터인 경우 그대로 복사하면 되지만,<br>참조형 데이터는 내부의 프로퍼티들을 다시 복사하는 과정을 거쳐야 깊은 복사가 되는 것입니다.</mark></p><p>아래는 이 개념을 바탕으로 원본데이터를 깊은 복사 방식으로 새로운 객체를 반환하는 코드입니다.</p><hr><h4 id="깊은-복사로-복사하는-방법"><a href="#깊은-복사로-복사하는-방법" class="headerlink" title="깊은 복사로 복사하는 방법"></a>깊은 복사로 복사하는 방법</h4><figure class="highlight js"><figcaption><span>객체의 깊은 복사를 도와주는 범용 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> copyObjectDeep = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">  <span class="comment">/* target이 object인 경우 내부 프로퍼티들을 순회하여</span></span><br><span class="line"><span class="comment">    copyObjectDeep 함수를 재귀적으로 호출합니다.*/</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      result[prop] = copyObjectDeep(target[prop]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//object가 아닌 경우 target을 그대로 지정합니다. </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>target === object</code> 뒤에 <code>target !== null</code> 조건이 붙은 이유는<br>typeof 메서드가 null 값에 대해 ‘object’를 반환하는 일종의 버그성? 때문입니다.</p></li><li><p>이 함수를 사용해 객체를 복사하면 원본과 사본이 서로 다른 주소를 참조하게 되어 한 쪽의 프로퍼티를 변경하더라도 다른 한 쪽에 영향을 주지 않습니다.</p></li></ul><hr><p>객체를 JSON 문법으로 표현된 문자열로 변환했다가 다시 JSON객체로 바꾸는 방법도 있습니다.</p><figure class="highlight js"><figcaption><span>JSON을 이용한 간단한 깊은 복사</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> copyObjectViaJSON = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(target));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="literal">null</span>,</span><br><span class="line">    d: [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  func2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = copyObjectViaJSON(obj);</span><br><span class="line"></span><br><span class="line">obj2.a = <span class="number">3</span>;</span><br><span class="line">obj2.b.c = <span class="number">4</span>;</span><br><span class="line">obj.b.d[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; a: 1. b: &#123; c: null, d: [1, 3], func1: f() &#125;, func2: f() &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123; a: 3. b: &#123; c: 4,    d: [1, 2] &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>이 방법은 단순하고 잘 동작합니다. 하지만 <mark>메서드(함수)나 숨겨진 프로퍼티인 &#95;&#95;proto&#95;&#95;나 getter/setter 등과 같이 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시됩니다.</mark><br><u>httpReaquest로 받은 데이터를 저장한 object를 복사할 경우 등 순수한 정보만을 다루는 object 복사에 좋은 방법입니다.</u></p><hr><h2 id="1_6">undefined 와 null</h2><p>자바스크립트에 “없음”을 나타내는 두 값 <code>&quot;undefined&quot;</code> 와 <code>&quot;null&quot;</code><br>미세하게 다른 둘의 의미와 사용하는 목적을 살펴봅시다.</p><hr><h5 id="자바스크립트는-다음과-같은-경우-엔진에서-undefined-값을-자동으로-부여합니다"><a href="#자바스크립트는-다음과-같은-경우-엔진에서-undefined-값을-자동으로-부여합니다" class="headerlink" title="자바스크립트는 다음과 같은 경우 엔진에서 undefined 값을 자동으로 부여합니다."></a>자바스크립트는 다음과 같은 경우 엔진에서 undefined 값을 자동으로 부여합니다.</h5><ol><li><p>값을 대입하지 않은 변수,즉 데이터 영역에 메모리 주소를 지정하지 않은 식별자에 접근할 때</p></li><li><p>존재하지 않는 프로퍼티에 접근할 때</p></li><li><p>return 문이 없거나 호출되지 않는 함수의 실행 결과</p></li></ol><figure class="highlight js"><figcaption><span>엔진에서 undefined를 부여하는 경우 예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// (1) undefined. 값을 대입하지 않은 변수에 접근</span></span><br><span class="line">                <span class="comment">// a 는 데이터 영역의 메모리 주소가 지정되지 않은 식별자</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">// (2) 존재하지 않는 프로퍼티에 접근</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// c.f) ReferenceError: b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> c = func(); <span class="comment">// (3) 반환(return)값이 없으면 undefined를 반환한 것으로 간주.</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><hr><h5 id="값을-대입하지-않은-변수가-빈-배열일-경우"><a href="#값을-대입하지-않은-변수가-빈-배열일-경우" class="headerlink" title="값을 대입하지 않은 변수가 빈 배열일 경우"></a>값을 대입하지 않은 변수가 빈 배열일 경우</h5><p>값을 대입하지 않은 변수가 빈 배열일 경우 특이한 결과를 확인할 수 있습니다.</p><figure class="highlight js"><figcaption><span>undefined 와 빈 배열</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">var</span> arr1 = [];</span><br><span class="line">arr1.length = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [empty x 3]</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [empty x 3]</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="keyword">var</span> arr3 = [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// [undefined, undefined, undefined]</span></span><br></pre></td></tr></table></figure><ol><li>빈 배열을 만들고 배열의 length 값을 3으로 지정하고 console에 찍으니 <code>[empty x 3]</code>이 출력됩니다.<br>이는 배열에 3개의 빈 배열 요소를 확보했지만 확보된 요소에 어떤 값도 할당되어 있지 않음을 의미합니다.<br>(undefined 조차 할당되어 있지 않습니다.)</li></ol><ol start="2"><li>new 연산자를 사용해 Array 생성자 함수를 호출하고 length 값을 3으로 지정했습니다. 위에 1번과 같은 결과를 갖습니다.</li></ol><ol start="3"><li><p>배열을 만들고 각 요소에 undefined 값을 지정했습니다. 출력시 <code>[undefined, undefined, undefined]</code>가 출력됩니다.</p><p> <img src="/images/Array_empty.JPG" alt="undefined 와 null"></p></li></ol><p>이처럼 “비어있는 요소”(<code>empty</code>)와 “<code>undefined</code>를 할당한 요소는” 출력 결과부터 다릅니다.</p><blockquote><p>empty !=== undefined</p></blockquote><p><code>&quot;비어있는 요소&quot;</code>는 이터러블과 관련된 많은 배열 메서드들의 대상에서 제외됩니다.</p><p>사실은 <code>Array</code>도 <code>object</code>임을 생각해보면 자연스러운 현상입니다.</p><p>존재하지 않는 프로퍼티를 이터러블 메서드로 순회할 수 없는 것이 당연합니다.</p><p><del>배열은 length 프로퍼티의 개수만큼 빈 공간을 확보하고 각각의 인덱스를 이름으로 지정할 것이라고 생각할 수 있지만,</del></p><p><mark>실제로는 object와 마찬가지로 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 동작을 합니다.</mark></p><p>즉, 값이 지정되지 않은 인덱스는 프로퍼티값이 지정되지 않은 빈 공간입니다.</p><p>위 처럼 <code>undefined</code>는 엔진이 부여하는 경우와 사용자가 값으로 할당한 실존하는 데이터인 경우로 나뉠수 있습니다.<br>이러한 방식은 혼란을 가져올 수 있습니다.<br>사용자가 “비어 있음”을 나타내고 싶어 할당한 값과, 엔진이 부여하는 “해당 값이 없음”<br>이 두가지를 확실히 구분하기 위해 사용하는 것이 바로 <code>null</code> 입니다.</p><hr><h5 id="null-사용-뜻"><a href="#null-사용-뜻" class="headerlink" title="null 사용 뜻"></a>null 사용 뜻</h5><p>사용자가 <code>&quot;비어있음&quot;</code>을 뜻하는 용도로 사용하고 싶을 때는 <code>null</code>을 사용하도록 합니다.<br><code>null</code>을 이런 용도에 사용하는 규칙을 지킨다면, <code>undefined</code>가 <strong>“값을 대입하지 않은 변수에 접근할 때” 엔진이 반환해 주는 값으로만 존재할 수 있습니다.</strong></p><p><del>애초에 null이 이런 용도로 만들어진 데이터 타입입니다.</del></p>]]></content:encoded>
      
      <comments>https://hdw0903.github.io/2020/04/16/%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%83%80%EC%9E%85%20-Core%20JavaScript/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
