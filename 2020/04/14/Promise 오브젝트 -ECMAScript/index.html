<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="웹 개발 공부 블로그"><title>Promise 오브젝트 -ECMAScript - 한참치의 Study Blog</title><meta description="Promise 오브젝트는 비동기(Asynchronous)처리를 위한 메커니즘을 제공합니다.ES5까지 없었던 개념으로 ES6에 추가되었습니다.  Promise 오브젝트 개요 Promise 처리 순서   Promise 상태 settled 상태 fulfill (성공) reject (실패)   new Promise(): Promise 인스턴스 생성 then():"><meta property="og:type" content="blog"><meta property="og:title" content="Promise 오브젝트 -ECMAScript"><meta property="og:url" content="https://hdw0903.github.io/2020/04/14/Promise%20%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%20-ECMAScript/"><meta property="og:site_name" content="한참치의 Study Blog"><meta property="og:description" content="Promise 오브젝트는 비동기(Asynchronous)처리를 위한 메커니즘을 제공합니다.ES5까지 없었던 개념으로 ES6에 추가되었습니다.  Promise 오브젝트 개요 Promise 처리 순서   Promise 상태 settled 상태 fulfill (성공) reject (실패)   new Promise(): Promise 인스턴스 생성 then():"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://hdw0903.github.io/2020/04/14/Promise%20%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%20-ECMAScript/images/blog_logo.png"><meta property="article:published_time" content="2020-04-14T00:44:27.000Z"><meta property="article:modified_time" content="2020-06-07T09:13:19.858Z"><meta property="article:author" content="Han Dongwon"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="ECMAScript6"><meta property="article:tag" content="Promise"><meta property="article:tag" content="settled"><meta property="article:tag" content="fulfill"><meta property="article:tag" content="reject"><meta property="article:tag" content="new Promise()"><meta property="article:tag" content="then()"><meta property="article:tag" content="catch()"><meta property="article:tag" content="resolve()"><meta property="article:tag" content="thenable"><meta property="article:tag" content="reject()"><meta property="article:tag" content="all()"><meta property="article:tag" content="race()"><meta property="article:tag" content="Synchronous"><meta property="article:tag" content="Asynchronous"><meta property="article:tag" content="PromiseState"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="images/blog_logo.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hdw0903.github.io/2020/04/14/Promise%20%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%20-ECMAScript/"},"headline":"한참치의 Study Blog","image":[],"datePublished":"2020-04-14T00:44:27.000Z","dateModified":"2020-06-07T09:13:19.858Z","author":{"@type":"Person","name":"Han Dongwon"},"description":"Promise 오브젝트는 비동기(Asynchronous)처리를 위한 메커니즘을 제공합니다.ES5까지 없었던 개념으로 ES6에 추가되었습니다.  Promise 오브젝트 개요 Promise 처리 순서   Promise 상태 settled 상태 fulfill (성공) reject (실패)   new Promise(): Promise 인스턴스 생성 then():"}</script><link rel="canonical" href="https://hdw0903.github.io/2020/04/14/Promise%20%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%20-ECMAScript/"><link rel="icon" href="/images/coffee-favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/tomorrow-night-bright.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link href="https://fonts.googleapis.com/earlyaccess/jejugothic.css" rel="stylesheet"><meta name="naver-site-verification" content="3b4f64ce6899317f220936e0013e08a5320d0b65"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-164181722-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-164181722-1');</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script data-ad-client="ca-pub-7899198893911275" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><link rel="alternate" href="/rss2.xml" title="한참치의 Study Blog" type="application/rss+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/template.png" alt="한참치의 Study Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub Home" href="https://github.com/hdw0903"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="카탈로그" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-10-desktop is-11-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">2020년 4월 14일 화요일 오전 9:44</span><span class="level-item"><a class="link-muted" href="/categories/ECMAScript6/">ECMAScript6</a></span><span class="level-item">한 시간 읽기 (대략 8319 단어)</span></div></div><h1 class="title is-3 is-size-3-mobile">Promise 오브젝트 -ECMAScript</h1><div class="content"><p><code>Promise</code> 오브젝트는 비동기(<code>Asynchronous</code>)처리를 위한 메커니즘을 제공합니다.<br><code>ES5</code>까지 없었던 개념으로 <code>ES6</code>에 추가되었습니다.</p>
<ul>
<li>Promise 오브젝트<ul>
<li><a href="/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise">개요</a><ul>
<li>Promise 처리 순서</li>
</ul>
</li>
<li><a href="/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_상태">Promise 상태</a><ul>
<li>settled 상태</li>
<li>fulfill (성공)</li>
<li>reject (실패)</li>
</ul>
</li>
<li><a href="/2020/04/14/Promise%20오브젝트%20-ECMAScript/#newPromise">new Promise(): Promise 인스턴스 생성</a></li>
<li><a href="/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_then">then(): 성공, 실패 핸들러</a></li>
<li><a href="/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_catch">catch(): 실패 핸들러</a></li>
<li><a href="/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_resolve">resolve(): 성공 상태의 인스턴스 반환</a><ul>
<li>thenable</li>
</ul>
</li>
<li><a href="/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_reject">reject(): 실패 상태의 인스턴스 반환</a></li>
<li><a href="/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_all">all(): 모두 성공이면 핸들러 실행</a></li>
<li><a href="/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_race">race(): 처음 한 번만 핸들러 호출</a></li>
</ul>
</li>
</ul>
<a id="more"></a>

<hr>
<h2 id="Promise">개요</h2>

<p>자바스크립트는 기본적으로 동기(<code>Synchronous</code>)로 실행합니다. 동기 실행이란 현재 코드가 실행을 완료해야 다음 코드가 실행되는 것을 의미합니다. 여러 줄의 코드가 있다고 했을 때, 첫째 줄의 코드가 실행을 완료해야 둘째 줄이 실행되며, 둘째 줄이 실행을 완료해야 셋째 줄이 실행되는 형태입니다.</p>
<p>반면, <code>Promise</code>는 비동기(<code>Asynchronous</code>)로 실행합니다. <code>XMLHttp Request</code>의 비동기 통신과 비슷합니다.<br>클라이언트에서 서버로 보낸 요청(<code>Request</code>)에 서버가 응답(<code>Response</code>)할 때까지 통신이 연결된 상태에서 기다리지 않습니다. 따라서 서버가 처리하는 동안 다른 처리를 할 수 있습니다. 클라이언트에서 서버가 응답했을 때의 처리를 사전에 정의해 두면, 서버가 응답했을 때 정의한 코드가 자동으로 실행됩니다.  </p>
<p><code>Promise</code>도 이와 개념이 비슷합니다.</p>
<p>코드 구현 관점에서 보면 <code>Promise</code>는 하나의 오브젝트입니다.<br><code>Promise</code> 오브젝트에서 비동기 처리 방법을 제공하므로 이에 맞추어 코드를 작성하면 됩니다.</p>
<p><code>Promise</code> 오브젝트는 <code>DOM</code>(Document Object Model)에서 처음 제시되었으나 현재는 <code>JavaScript</code> 스펙에 포함되었습니다. <strong>따라서 <code>DOM</code>에서도 사용이 가능하며 이는 <code>DOM</code>을 사용하는 다른 언어에서도 <code>Promise</code>를 사용할 수 있다는 것이 됩니다.</strong></p>
<h3 id="Promise-처리-순서"><a href="#Promise-처리-순서" class="headerlink" title="Promise 처리 순서"></a>Promise 처리 순서</h3><p><code>Promise</code> 개념을 이해하기 위해 <code>Promise</code>의 비동기 처리 흐름을 간단하게 살펴봅니다.</p>
<figure class="highlight js"><figcaption><span>Promise 처리 흐름</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"> <span class="number">3.</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;  </span><br><span class="line"> resolve();  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"1: resolve"</span>);  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span> <span class="number">4.</span> <span class="number">6.</span> create().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"3: 성공"</span>);  </span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"3: 실패"</span>);  </span><br><span class="line">&#125;);  </span><br><span class="line"><span class="number">5.</span> <span class="built_in">console</span>.log(<span class="string">"2: 끝"</span>);  </span><br><span class="line"><span class="comment">// 1: resolve  </span></span><br><span class="line"><span class="comment">// 2: 끝  </span></span><br><span class="line"><span class="comment">// 3: 성공</span></span><br></pre></td></tr></table></figure>

<ol>
<li>엔진이 <code>function</code> 키워드를 만나면 <code>create()</code>를 호출할 수 있도록 <code>Function</code> 오브젝트로 생성합니다.<br>함수 안에 코드는 실행하지 않고 다음 줄로 이동합니다.</li>
</ol>
<ol start="2">
<li><code>create()</code> 함수를 호출합니다. 함수 안에 코드가 실행됩니다.</li>
</ol>
<ol start="3">
<li><ol>
<li><p><code>return</code> 문의 표현식을 평가하므로 <code>new Promise()</code>로 인스턴스를 생성합니다.</p>
</li>
<li><p>이때, <code>Promise()</code> 파라미터에 작성한 <code>function(){}</code>을 실행합니다. (function을 executer(실행자)라고 합니다.)</p>
</li>
<li><p><code>function</code>(executer) 블록의 첫째 줄에 <code>resolve()</code>가 작성되어 있습니다. 그런데 호출을 받아서 처리할 같은 이름의 함수가 소스 코드에 없습니다. 단지 파라미터에 <code>resolve</code>가 작성되어 있을 뿐입니다.</p>
</li>
<li><p><code>resolve()</code> 형태가 함수를 호출하는 형태이지만 호출하지 않습니다. 이에 대해서는 사전 설명이 필요하므로 뒤에서 다룹니다.</p>
</li>
<li><p>다음 줄에 console.log()를 실행하여 “1: resolve”를 출력합니다.</p>
</li>
<li><p>생성한 인스턴스를 반환합니다.<br><strong>여기서 중요한 점이 <code>executer</code>가 실행된다는 것과 <code>resolve</code>()가 호출되지 않는다는 점입니다. resolve()를 바로 호출하지 않고 호출할 수 있는 환경이 되었을 때 호출합니다.</strong></p>
</li>
</ol>
</li>
</ol>
<ol start="4">
<li><code>create()</code> 실행이 끝나면 생성한 <code>Promise</code> 인스턴스를 반환합니다. <code>Promise</code> 인스턴스에 <code>then()</code>이 있으므로 이어서 <code>then()</code>을 호출할 수 있습니다. 하지만 <code>then()</code>을 호출하지 않고, 아래 코드로 이동합니다.<br><strong>앞에서 <code>resolve()</code>를 호출할 수 있는 환경이 되었을 때 호출하는 것과 <code>then()</code>을 실행하지 않고 아래 코드로 이동하는 것이 <code>Promise</code> 비동기 처리의 핵심 매커니즘 입니다.</strong></li>
</ol>
<ol start="5">
<li><code>create()</code> 실행 이후에 <code>then()</code>을 호출하지 않고 다음 줄로 이동했을 때 만나는 코드입니다.<br>“2: 끝”이 출력됩니다. 이제 더 이상 남아있는 코드가 없습니다.</li>
</ol>
<ol start="6">
<li>이제 남은 것은 <code>then()</code>에 작성한 <code>function()</code>의 실행입니다.<br><code>then()</code>은 두 개의 파라미터를 갖고 있습니다.<br>위 코드에서는 첫 번째 파라미터의 <code>function</code>이 실행되어 <code>“3: 성공”</code>이 출력됩니다.<br>두 번째 파라미터의 <code>function</code>은 실행되지 않습니다. 첫 번째 파라미터 <code>function</code>이 실행된 이유는 뒤에서 다룹니다.</li>
</ol>
<ul>
<li><p>console.log 출력 순서를 보면</p>
<ol>
<li><p>“1: resolve”는 new Promise()로 인스턴스를 생성할 때 executer에서 출력합니다.<br>Promise 인스턴스를 생성해야 메서드를 사용할 수 있으므로 먼저 인스턴스를 생성합니다.</p>
</li>
<li><p>“2: 끝”은 create()에 연결된 then()을 실행하지 않으므로 두 번째로 실행됩니다.</p>
</li>
<li><p>“3: 성공”은 소스 코드 전체를 끝까지 처리한 후 실행되어 세 번째로 출력됩니다.</p>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="Promise_상태">Promise 상태</h2>

<p><strong><code>Promise</code>는 코드를 실행할 때마다 진행 상태를<code>[[PromiseState]]</code>에 저장합니다.</strong> </p>
<p>상태를 저장하는 이유는 연속해서 코드를 실행하지 않고, 소스 코드 끝까지 내려갔다 다시 올라와서 실행하므로 진행 상태가 필요하기 때문입니다. 상태에 따라 다음 단계를 처리하기 위해서 입니다.</p>
<img src="/images/promise.SVG">

<p><code>Promise</code> 진행 상태는 크게 두 가지로 나눌 수 있습니다.<br><code>pending</code> 과 <code>settled</code>로 나뉩니다.<br><code>settled</code> 상태는 다시 <code>fulfill</code>(성공) 과 <code>reject</code>(실패)로 나눌 수 있습니다.<br><code>pending</code> 과 <code>settled</code>는 상태이면서 발생 단계입니다. 먼저 <code>pending</code> 상태가 되었다가 <code>settled</code> 상태로 넘어갑니다.  </p>
<p>단계로 보면 두 단계 (<code>pending</code>, <code>settled</code>)이지만 상태 측면에서 보면 세 개이므로 세 개의 상태로 분류하기도 합니다.</p>
<h3 id="pending-상태"><a href="#pending-상태" class="headerlink" title="pending 상태"></a>pending 상태</h3><figure class="highlight js"><figcaption><span>pending</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;  </span><br><span class="line"> resolve();  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"1: resolve"</span>);  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>pending</code> 상태(단계)에서는 위 코드와 같이 우선 <code>new Promise()</code>로 인스턴스를 생성합니다. <strong>그리고 <code>executer</code>를 실행하여 성공과 실패에 따라 호출할 핸들러 함수를 바인딩 합니다.</strong><br>바인딩이란 <code>resolve()</code>와 같이 바로 함수를 호출하지 않고 나중에 호출하므로, 그때를 위한 호출 환경을 설정하는 것을 의미합니다.</p>
<p><code>executer</code> 블록의 코드를 실행하지 않고 소스 코드 끝까지 처리한 후 실행하므로 이 시점에서 <code>Promise</code> 처리의 성공과 실패를 알 수 없습니다. 따라서 성공 또는 실패가 발생했을 때, 이에 따라 함수가 호출될 수 있도록 환경 설정이 필요합니다.</p>
<h3 id="settled-상태"><a href="#settled-상태" class="headerlink" title="settled 상태"></a>settled 상태</h3><figure class="highlight js"><figcaption><span>settled</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"3: 성공"</span>);  </span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"4: 실패"</span>);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>pending</code> 상태가 종료되면 <code>settled</code> 상태로 변환됩니다. 이때 처리의 성공과 실패를 알 수 있습니다.<br><code>settled</code> 상태는 다시 <code>fulfill</code>(성공) 상태와 <code>reject</code>(실패) 상태로 구분됩니다. 상태에 따라 <code>pending</code> 단계에서 바인딩한 핸들러 함수가 호출됩니다.</p>
<h4 id="fulfill-성공"><a href="#fulfill-성공" class="headerlink" title="fulfill (성공)"></a>fulfill (성공)</h4><p><code>executer</code> 불록의 코드가 성공적으로 실핸된 상태를 나타냅니다.<br><code>then()</code>의 첫 번째 파라미터의 핸들러(<code>function</code>)가 실행됩니다. - 핸들러 안에 성공에 따른 코드를 작성합니다.</p>
<h4 id="reject-실패"><a href="#reject-실패" class="headerlink" title="reject (실패)"></a>reject (실패)</h4><p><code>executer</code> 블록의 코드 실행이 실패한 상태를 나타냅니다.<br><code>then()</code>의 두 번째 파라미터의 핸들러가 실행됩니다. - 핸들러 안에 실패에 따른 코드를 작성합니다.</p>
<hr>
<h2 id="newPromise">new Promise(): Promise 인스턴스 생성</h2>

<p><strong><code>Promise</code> 인스턴스를 생성하여 반환합니다.</strong></p>
<blockquote>
<p>new Promise()</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;  </span><br><span class="line"> resolve( );  </span><br><span class="line"> reject( );  </span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>executer</code>에 두 개의 파라미터를 작성할 수 있습니다. 첫 번째 파라미터에 <code>executer</code> 블록에서 처리를 성공했을 때 호출할 핸들러 이름(resolve)를 작성합니다. 두 번째 파라미터에 실패했을 때 호출할 핸들러 이름(<code>reject</code>)를 작성합니다. <code>resolve</code> 와 <code>reject</code>는 가독성을 위한 것으로 다른 이름을 사용해도 됩니다.</li>
</ul>
<ul>
<li><code>executer</code> 블록에 핸들러 함수를 작성하지 않으면, then()의 파라미터에 작성한 함수가 실행되지 않습니다.<br>핸들러 함수 이름과 <code>executer</code>의 파라미터에 작성한 이름과 같아야 하며, 같지 않으면 에러가 발생합니다.<br>예를 들어, <code>resolve()</code> 와 <code>function(resolve)</code>와 같이 <code>resolve</code> 이름이 같아야 합니다.</li>
</ul>
<hr>
<h3 id="성공-기준"><a href="#성공-기준" class="headerlink" title="성공 기준"></a>성공 기준</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">param</span>)</span>&#123;  </span><br><span class="line"> <span class="number">2.</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;  </span><br><span class="line"> <span class="number">3.</span> <span class="keyword">if</span> (param === <span class="string">"ok"</span>)&#123;  </span><br><span class="line"> resolve(param);  </span><br><span class="line"> <span class="number">4.</span> <span class="built_in">console</span>.log(<span class="string">"1: resolve"</span>);  </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line"> reject(param);  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="number">1.</span> <span class="number">5.</span> create(<span class="string">"ok"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">param</span>)</span>&#123;  </span><br><span class="line"> <span class="number">7.</span> <span class="built_in">console</span>.log(<span class="string">"3: 성공,"</span>, param);  </span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">param</span>)</span>&#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"3: 실패,"</span>, param);  </span><br><span class="line">&#125;);  </span><br><span class="line"><span class="number">6.</span> <span class="built_in">console</span>.log(<span class="string">"2: 끝"</span>);  </span><br><span class="line"><span class="comment">// 1: resolve  </span></span><br><span class="line"><span class="comment">// 2: 끝  </span></span><br><span class="line"><span class="comment">// 3: 성공, ok</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>create()</code>를 호출하면서 “ok”를 파라미터 값으로 넘겨 줍니다. 호출받은 <code>create()</code> 함수의 파라마터 <code>param</code>에 설정됩니다.</li>
</ol>
<ol start="2">
<li><p><code>executer</code>의 파라미터에 <code>resolve</code> 와 <code>reject</code>를 작성했습니다. <code>Function</code> 오브젝트를 생성하여 <code>resolve</code> 와 <code>reject</code>에 할당합니다. <code>Promise</code> 인스턴스를 생성하여 <code>return</code> 한 후, <code>create()</code>에 연결된 <code>then()</code>의 파라미터에 작성한 함수와 연결합니다.</p>
<p>이렇게 설정함으로써 <code>executer</code> 블록에서 <code>resolve()</code>를 호출하면 <code>then()</code>의 첫 번째 파라미터의 함수가 호출되고, <code>reject()</code>를 호출하면 <code>then()</code>의 두 번째 파라미터의 함수가 호출됩니다.<br><code>executer</code> 파라미터의 <code>resolve</code>와 <code>executer</code> 블록의 <code>resolve()</code>와 <code>then()</code>의 첫 번째 파라미터 함수가 연결되고,<br><code>executer</code> 파라미터의 <code>reject</code>와 <code>executer</code> 블록의 <code>reject()</code>와 <code>then()</code>의 두 번째 파라미터 함수가 연결되는 것입니다.</p>
</li>
</ol>
<ol start="3">
<li><p><code>param</code> 값으로 받은 파라미터가 “ok”이므로 true가 되어 if 문 블록을 수행합니다.<br><code>resolve(param)</code>가 함수를 호출하는 형태이지만, 지금 호출하지 않고 소스 코드를 끝까지 실행한 후 되돌아와서 호출합니다. 되돌아와서 <code>resolve()</code>를 호출하면 이를 받아 실행할 같은 이름의 함수가 없습니다.  </p>
<p><mark>이때 executer 파라미터의 resolve에 설정된 함수를 호출합니다. 그러면 resolve 와 then()의 첫 번째 파라미터의 함수와 연결되어 있으므로 then()의 첫 번째 함수가 연결되어 있으므로 then()의 첫 번째 함수가 실행됩니다. 이것이 Promise의 비동기 처리 메커니즘입니다.</mark></p>
</li>
</ol>
<ol start="4">
<li><code>resolve(param)</code> 다음 줄에 console.log을 실행하며 “1: resolve”를 출력합니다.<br>이제 남은 것은 생성한 인스턴스를 반환하는 것입니다.</li>
</ol>
<ol start="5">
<li><p><code>create(“ok”)</code>의 호출이 완료되면 <code>Promise</code> 인스턴스를 반환하므로 <code>“인스턴스.then()”</code> 형태가 되어 <code>then()</code>을 실행할 수 있지만 바로 실행하지 않습니다. 우선 <code>then()</code>의 첫 번째 파라미터를 <code>executer</code>의 <code>resolve</code>에 바인딩하고, <code>then()</code>의 두 번째 파라미터를 <code>executer</code>의 <code>reject</code>에 바인딩 합니다.  </p>
<p>이렇게 바인딩을 함으로써 <code>executer</code> 블록에서 <code>resolve()</code>를 호출했을 때 <code>then()</code>의 첫 번째 파라미터에 작성한 함수가 실행됩니다.</p>
</li>
</ol>
<ol start="6">
<li>소스 코드의 마지막 코드로 console에 “2: 끝”을 출력합니다. 모든 코드를 읽었으므로 이제 남은 것은 <code>resolve()</code>를 실행하는 것입니다.</li>
</ol>
<ol start="7">
<li><code>executer</code> 블록에서 <code>resolve(param)</code>을 호출하면, <code>then()</code>의 첫 번째 파라미터 함수가 호출됩니다.<br>이때, <code>resolve(param)</code>에서 <code>param</code> 값인 “ok”가 핸들러 함수인 <code>function(param)</code>의 <code>param</code>에 설정됩니다.<br>따라서 console에 “3: 성공, ok”가 출력됩니다.</li>
</ol>
<hr>
<h3 id="실패-기준"><a href="#실패-기준" class="headerlink" title="실패 기준"></a>실패 기준</h3><figure class="highlight js"><figcaption><span>fail</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">param</span>)</span>&#123;  </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;  </span><br><span class="line"> <span class="keyword">if</span> (param === <span class="string">"ok"</span>)&#123;  </span><br><span class="line"> resolve(param);  </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line"> reject(param);  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"1: reject"</span>);  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="number">1.</span> create(<span class="string">"fail"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">param</span>)</span>&#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"3: 성공,"</span>, param);  </span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">param</span>)</span>&#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"3: 실패,"</span>, param);  </span><br><span class="line">&#125;);  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"2: 끝"</span>);  </span><br><span class="line"><span class="comment">// 1: reject  </span></span><br><span class="line"><span class="comment">// 2: 끝  </span></span><br><span class="line"><span class="comment">// 3: 실패, fail</span></span><br></pre></td></tr></table></figure>

<ul>
<li>바로 앞에서 다룬 코드는 성공 기준이며 위 코드는 실패 기준입니다.<br><code>Promise</code> 처리 흐름은 같습니다. <code>then()</code>의 두 번째 파라미터에 작성한 함수가 실행된다는 점이 다릅니다.</li>
</ul>
<ol>
<li><p><code>create()</code>를 호출하면서 <code>“fail”</code>을 파라미터 값으로 넘겨 줍니다.<br>호출된 <code>create()</code> 함수에서 <code>if</code> 문의 <code>else</code> 블록 <code>reject(param)</code>과 <code>console.log(“1: reject”)</code>를 실행하게 됩니다.</p>
<p>물론 <code>reject(param)</code>은 이때 호출되지 않고 소스 코드를 끝까지 실행한 후 되돌아와서 호출 환경이 설정되있을 때 호출됩니다.  </p>
<p><code>executer</code> 블록에서 <code>reject()</code>가 호출되면 <code>then()</code>의 두 번째 파라미터에 작성한 함수가 실행됩니다.<br>따라서 콘솔에 “3: 실패, fail”이 출력됩니다.</p>
</li>
</ol>
<hr>
<h2 id="Promise_then">then(): 성공, 실패 핸들러</h2>

<p><strong>성공과 실패 핸들러를 정의합니다.</strong></p>
<blockquote>
<p>Promise.prototype.then(onFulfilled, onRejected)</p>
</blockquote>
<p>첫 번째 파라미터에 <code>Promise</code>가 성공 상태가 되었을 때 실행될 핸들러 함수를 작성합니다.<br>두 번째 파라미터에 <code>Promise</code>가 실패 상태가 되었을 때 실행될 핸들러 함수를 작성합니다.</p>
<ul>
<li><code>executer</code> 블록의 <code>resolve()</code> 와 <code>reject()</code>에서 다수의 파라미터 값을 넘겨주더라도 핸들러 함수에서 첫 번째 파라미터 하나만 받습니다. 따라서 여러 개의 파라미터 값을 넘겨 주려면 <code>resolve()</code>와 <code>reject()</code>의 파라미터에 배열과 같은 형태로 작성해야 합니다.</li>
</ul>
<ul>
<li><code>resolve</code>(성공) 와 <code>reject</code>(실패) 핸들러 함수에서 <code>return</code> 문의 작성 여부와 관계없이 현재 실행 중인 <code>Promise</code> 인스턴스를 반환합니다. <code>return</code> 문을 작성하면 <code>return</code> 문의 표현식을 평가하고 그 결과를 <code>[[PromiseValue]]</code>에 <code>undefined</code>를 설정합니다.</li>
</ul>
<ul>
<li><code>then()</code> 에서 <code>Promise</code> 인스턴스를 반환하므로 <code>then(one).then(two)</code>와 같이 <code>then()</code>을 연속해서 작성할 수 있습니다. 이때, 첫 번째 <code>then()</code>에서 <code>[[PromiseValue]]</code>에 설정한 값이 두 번째 <code>then(two)</code>의 파라미터인 <code>two</code>에 설정됩니다. 핸들러 함수에서 <code>Promise</code> 인스턴스를 반환하여 연속해서 메서드를 호출할 수 있도록 하고, <code>return</code> 문의 반환 값을 <code>[[PromiseValue]]</code>에 설정하여 다음 <code>then()</code>의 핸들러 함수의 파라미터에 설정합니다.</li>
</ul>
<figure class="highlight js"><figcaption><span>then()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(<span class="number">100</span>));  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="number">2.</span> create().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"1:then"</span>));  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span> create().then(<span class="function">(<span class="params">param</span>) =&gt;</span> &#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"2:then,"</span>, param);  </span><br><span class="line"> <span class="keyword">return</span> param + <span class="number">50</span>;  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="number">4.</span> create().then(<span class="function">(<span class="params">param</span>) =&gt;</span> &#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"3:then,"</span>, param);  </span><br><span class="line"> <span class="keyword">return</span> param + <span class="number">70</span>;  </span><br><span class="line">&#125;).then(<span class="function">(<span class="params">param</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"4:then,"</span>, param));  </span><br><span class="line"><span class="comment">// 1:then  </span></span><br><span class="line"><span class="comment">// 2:then, 100  </span></span><br><span class="line"><span class="comment">// 3:then, 100  </span></span><br><span class="line"><span class="comment">// 4:then, 170</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>create()</code>가 호출되면 <code>executer</code> 블록의 <code>resolve()</code>를 수행하게 됩니다.<br>하지만 호출받을 <code>resolve</code> 함수가 없으므로 호출 환경이 되었을 때 호출합니다.<br>즉, 소스 코드 끝까지 처리하고 되돌아와 호출합니다.<br><strong>실패가 발생하지 않으면 <code>executer</code>의 파라미터와 블록에 <code>reject</code>를 작성하지 않아도 됩니다.</strong></li>
</ol>
<ol start="2">
<li><code>then()</code>의 첫 번째 파라미터에 핸들러 함수를 작성하여 연결합니다. <code>executer</code> 블록에서 <code>resolve</code> 파라미터 값으로 100을 넘겨 주지만 이 코드에서는 사용되지 않습니다. “1:then”을 출력합니다.</li>
</ol>
<ol start="3">
<li>두 번째로 <code>create()</code>를 호출하여 <code>Promise</code> 인스턴스를 생성합니다. <code>executer</code> 블록에서 <code>resolve(100)</code>으로 호출하면, <code>then()</code>의 첫 번째 파라미터의 핸들러 함수가 실행되며 100이 param에 설정됩니다.<br><code>return</code>문의 표현식을 평가한 150을 <code>[[PromiseValue]]</code>에 설정만하고 반환하지 않으며, 실행 중인 <code>Promise</code> 인스턴스를 반환합니다.</li>
</ol>
<ol start="4">
<li><p>세 번째로 <code>create()</code>를 호출하여 <code>Promise</code> 인스턴스를 생성합니다. <code>then()</code>의 첫 번째 파라미터의 핸들러 함수가 호출되면 <code>param</code> 파라미터에 100이 설정됩니다. <code>return</code> 문의 표현식을 평가한 170을 <code>[[PromiseValue]]</code>에 설정하고 실행중인 <code>Promise</code> 인스턴스를 반환합니다.</p>
<p><code>then()</code>에서 <code>Promise</code> 인스턴스를 반환하므로 두 번째 <code>.then()</code> 으로 호출할 수 있습니다.<br><code>[[PromiseValue]]</code>에 설정된 170이 <code>param</code> 파라미터에 설정되며 “4: then, 170”이 출력됩니다.</p>
</li>
</ol>
<h3 id="코드-실행-순서-정리"><a href="#코드-실행-순서-정리" class="headerlink" title="코드 실행 순서 정리"></a>코드 실행 순서 정리</h3><ol>
<li>첫 번째 <code>create()</code> 함수를 호출합니다. <code>Promise</code> 인스턴스를 반환합니다.<br>연결된 <code>then()</code>의 핸들러 함수를 실행하지 않고 아래로 이동합니다.</li>
</ol>
<ol start="2">
<li>두 번째 <code>create()</code> 함수를 호출합니다. <code>Promise</code> 인스턴스를 반환합니다.<br>연결된 <code>then()</code>의 핸들러 함수를 실행하지 않고 아래로 이동합니다.</li>
</ol>
<ol start="3">
<li>세 번째 <code>create()</code> 함수를 호출합니다. <code>Promise</code> 인스턴스를 반환합니다.<br>연결된 <code>then()</code>의 핸들러 함수를 실행하지 않고 아래로 이동합니다.</li>
</ol>
<ol start="4">
<li>더 이상 처리할 코드가 없습니다.</li>
</ol>
<ol start="5">
<li>첫 번째의 <code>executer</code> 블록의 <code>resolve()</code>가 호출되며 <code>then()</code>의 핸들러 함수가 실행됩니다.<br>콘솔에 “1:then”이 출력됩니다.</li>
</ol>
<ol start="6">
<li>두 번째의 <code>executer</code> 블록의 <code>resolve()</code>가 호출되며 <code>then()</code>의 핸들러 함수가 실행됩니다.<br>콘솔에 “2:then, 100”이 출력됩니다.</li>
</ol>
<ol start="7">
<li>세 번째의 <code>executer</code> 블록의 <code>resolve()</code>가 호출되며 <code>then()</code>의 핸들러 함수가 실행됩니다.<br>콘솔에 “3:then, 100”이 출력됩니다.</li>
</ol>
<ol start="8">
<li>세 번째의 <code>then()</code>에 연결된 <code>then()</code>의 핸들러 함수가 실행됩니다.<br>콘솔에 “4:then, 170”이 출력됩니다.</li>
</ol>
<p><strong>then().then()과 같이 then()이 연결되어 있으면, 처음 then()의 핸들러 함수를 실행한 후, 두 번째 then()의 함수 코드를 실행합니다.</strong> <mark>이때 처음 then()의 return 값이 두 번째 then()함수의 파라미터 값으로 설정됩니다.</mark></p>
<hr>
<h2 id="Promise_catch">catch(): 실패 핸들러</h2>

<p><strong>실패(<code>reject</code>) 핸들러를 정의합니다.</strong></p>
<blockquote>
<p>Promise.prototype.catch(onRejected)</p>
</blockquote>
<ul>
<li>파라미터에 <code>Promise</code>가 <code>reject</code> 상태가 되었을 때 실행될 핸들러 함수를 작성합니다.<br><code>then()</code>의 첫 번째 파라미터에 함수를 작성하고, 두 번째 파라미터는 작성하지 않습니다.<br>대신 <code>then().catch()</code> 형태로 작성하여 <code>then()</code>의 두 번째 파라미터에 작성할 함수를 catch()의 파라미터에 작성합니다. <code>then()</code>은 성공했을 때 실행되며 <code>catch()</code>는 실패했을 때 실행됩니다.</li>
</ul>
<ul>
<li><code>catch()</code> 의 핸들러 함수에 파라미터를 하나만 작성할 수 있습니다.<br><code>executer</code> 블록의 <code>reject()</code> 에서 다수의 파라미터를 넘겨주려면 배열과 같은 형태로 작성해야 합니다.</li>
</ul>
<ul>
<li><strong><code>catch()</code>의 핸들러 함수에서 <code>return</code> 문의 작성 여부와 관계없이 현재 실행 중인 <code>Promise</code> 인스턴스를 반환합니다.</strong></li>
</ul>
<ul>
<li><code>catch().then()</code>과 같이 <code>catch()</code> 다음에 <code>then()</code>을 연결할 수 있으며, <code>catch()</code>에서 설정한 <code>[[PromiseValue]]</code> 값을 <code>then()</code>의 파라미터 값으로 넘겨줍니다.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">param</span>)</span>&#123;  </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;  </span><br><span class="line"> <span class="number">1.</span> param === <span class="string">"ok"</span> ? resolve(param) : reject(param);  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span> create(<span class="string">"fail"</span>).then(<span class="function">(<span class="params">param</span>) =&gt;</span> &#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"성공:"</span>, param);  </span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">param</span>) =&gt;</span> &#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"실패:"</span>, param);  </span><br><span class="line">&#125;);  </span><br><span class="line"><span class="comment">// 실패 : fail</span></span><br></pre></td></tr></table></figure>

<ol>
<li>파라미터로 받은 <code>param</code> 값이 <code>“ok”</code>이면 <code>resolve(param)</code>을 호출하고, 아니면 <code>reject(param)</code>을 호출합니다.<br><code>“fail”</code>값으로 <code>create()</code>를 호출합니다. 따라서 <code>reject()</code>를 호출하게 되며, <code>catch()</code>의 핸들러 함수가 실행됩니다.</li>
</ol>
<ol start="2">
<li><code>create(“fail”)</code>로 호출하여 <code>Promise</code> 인스턴스를 생성합니다.<br><code>executer</code> 블록에서 <code>reject()</code>가 호출되므로 <code>catch()</code>의 핸들러 함수가 실행됩니다.<br><code>reject(param)</code>에서 <code>param</code> 값이 핸들러 함수의 파라미터인 <code>param</code>에 설정됩니다.<br>실패만 발생하므로 <code>then()</code>의 핸들러 함수는 실행되지 않고, <code>catch()</code> 핸들러 함수만 실행됩니다.</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">param</span>)</span>&#123;  </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;  </span><br><span class="line"> resolve(<span class="string">"resolve"</span>);  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="number">1.</span>   </span><br><span class="line">create().then(<span class="function">(<span class="params">param</span>) =&gt;</span> &#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"1:then,"</span>, param);  </span><br><span class="line"> <span class="keyword">throw</span> <span class="string">"에러 발생 시킴"</span>;  </span><br><span class="line"><span class="number">2.</span>  </span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">param</span>) =&gt;</span> &#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"2:catch,"</span>, param);  </span><br><span class="line"><span class="number">3.</span>  </span><br><span class="line">&#125;).then(<span class="function">(<span class="params">param</span>) =&gt;</span> &#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"3:then,"</span>, param);  </span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">param</span>) =&gt;</span> &#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"4:catch,"</span>, param);  </span><br><span class="line">&#125;);  </span><br><span class="line"><span class="comment">// 1: then, resolve  </span></span><br><span class="line"><span class="comment">// 2: catch, 에러 발생 시킴  </span></span><br><span class="line"><span class="comment">// 3: then, undefined</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>then()</code>의 핸들러 함수가 실행되면 콘솔에 <code>“1:then, resolve”</code>가 출력됩니다.<br>이어서 <code>throw</code> 문으로 에러를 발생시킵니다. 그러면 <code>then()</code>에 이어서 작성한 <code>catch()</code>핸들러 함수가 실행됩니다.</li>
</ol>
<ol start="2">
<li><p><code>executer</code> 블록에서 <code>reject()</code>를 호출해도 <code>catch()</code>의 핸들러 함수가 실행되지만,<br><code>then()</code>에서 에러가 발생해도 <code>catch()</code>의 핸들러 함수가 실행됩니다.<br>이때, 앞 <code>then()</code>의 <code>throw</code>문에 작성한 <code>“에러 발생 시킴”</code>이 <code>catch()</code> 핸들러 함수의 <code>param</code> 파라미터에 설정됩니다. 콘솔에 “2:catch, 에러 발생 시킴”이 출력됩니다.</p>
<p>핸들러 함수에 <code>return</code> 문을 작성하지 않았으므로 <code>[[PromiseValue]]</code>에 <code>undefined</code>가 설정되며 실행 중인 <code>Promise</code> 인스턴스가 반환됩니다. </p>
<p><code>catch()</code>에서 에러가 발생하지 않으면 <code>then().catch().then().catch()</code> 형태에서 <code>catch()</code>에 연결된 두 번째 <code>then()</code>이 실행됩니다. 만약 에러가 발생하여 두 번째 <code>catch()</code>를 실행하더라도 소스 코드 전체가 종료되지 않습니다.</p>
</li>
</ol>
<ol start="3">
<li><p><code>then()</code>이 실행되면 <code>catch()</code>에서 <code>[[PromiseValue]]</code>에 설정한 <code>undefined</code>가 <code>param</code> 파라미터에 설정됩니다.  </p>
<p>콘솔에 “3:then, undefined”가 출력됩니다. <code>then()</code>에 이어서 <code>catch()</code>가 있지만, <code>then()</code>에서 에러가 발생하지 않았으므로 <code>catch()</code>가 실행되지 않습니다. <code>then()</code>의 핸들러 함수를 실행한 후, 소스 코드 전체가 종료됩니다.</p>
</li>
</ol>
<hr>
<h2 id="Promise_resolve">resolve(): 성공 상태의 인스턴스 반환</h2>

<p><strong><code>fulfill</code>(성공) 상태의 <code>Promise</code> 인스턴스를 반환합니다.</strong></p>
<blockquote>
<p>Promise.resolve()</p>
</blockquote>
<ul>
<li><p>파라미터<br>value, promise, thenable</p>
</li>
<li><p>반환 값<br>파라미터 값에 따라 반환 형태가 다릅니다.</p>
</li>
</ul>
<p>파라미터에 값을 작성하면 성공 상태의 <code>Promise</code> 인스턴스를 생성하여 반환합니다.<br>이어서 <code>then()</code>을 작성하면 <code>then()</code>의 첫 번째 파라미터에 작성한 함수가 호출됩니다.<br>파라미터에 <code>Promise</code> 인스턴스를 지정하면 인스턴스를 성공 상태로 변환하여 반환합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">let</span> promiseObj = <span class="built_in">Promise</span>.resolve(  </span><br><span class="line"> &#123;<span class="attr">sports</span>: <span class="string">"스포츠"</span>, <span class="attr">music</span>: <span class="string">"음악"</span>&#125;  </span><br><span class="line">);  </span><br><span class="line"><span class="number">2.</span> promiseObj.then(<span class="function">(<span class="params">param</span>) =&gt;</span>&#123;  </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> param)&#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(name, param[name]);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span> <span class="built_in">Promise</span>.resolve(  </span><br><span class="line"> [<span class="string">"sports"</span>, <span class="string">"music"</span>]  </span><br><span class="line">).then(<span class="function">(<span class="params">param</span>) =&gt;</span> <span class="built_in">console</span>.log(param));  </span><br><span class="line"><span class="comment">// sports 스포츠  </span></span><br><span class="line"><span class="comment">// music 음악  </span></span><br><span class="line"><span class="comment">// ["sports", "music"]</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>Promise.resolve()</code>를 호출하면 <code>Promise</code> 인스턴스를 생성하고 <code>Promise</code>를 성공 상태로 설정하여 반환합니다.<br><code>then()</code>의 핸들러 함수에 파라미터 하나만 작성할 수 있으므로 다 수의 파라미터 값을 넘겨주기 위해 <code>Object</code> 오브젝트로 작성했습니다.</p>
<ul>
<li>다음은 promiseObj 인스턴스 구조입니다.<img src="/images/resolvePromiseObj.JPG"></li>
</ul>
<ol>
<li><p><code>__proto__</code>에 첨부된 프로퍼티가 <code>Promise.prototype</code>에 연결된 프로퍼티와 같습니다.<br><strong>이는 <code>new</code> 연산자를 사용하지 않고 <code>Promise.resolve()</code>를 실행해도 <code>Promise</code> 인스턴스를 생성한다는 의미입니다.</strong></p>
</li>
<li><p><code>[[PromiseState]]</code> 값이 <code>“resolve”</code>로 설정되어 있습니다. 따라서 <code>then()</code>의 첫 번째 파라미터의 핸들러 함수가 실행됩니다.</p>
</li>
<li><p><code>Promise.resolve()</code>의 파라미터 값이 <code>[[PromiseValue]]</code>에 설정되었으며 <code>then()</code>의 핸들러 함수의 파라미터에 설정됩니다.</p>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p><code>PromiseObj</code>의 <code>Promise</code> 인스턴스가 성공 상태이므로 <code>then()</code>의 첫 번째 파라미터 함수가 실행됩니다.  </p>
<p>이 시점에서 실행되지 않고 소스 코드에 작성된 코드를 끝까지 처리한 후 실행됩니다.<br>핸들러 함수의 <code>param</code> 파라미터에 <code>{sports: “스포츠”, music: “음악”}</code>이 설정됩니다.</p>
</li>
<li><p><code>Promise.resolve()</code> 가 <code>Promise</code> 인스턴스를 생성하여 반환하므로 <code>then()</code>을 연결하여 작성할 수 있습니다.<br>지금 <code>then()</code>의 핸들러 함수를 실행하지 않고, 위에 작성한 <code>then()</code>의 핸들러 함수를 먼저 실행한 후 실행합니다.<br><code>resolve()</code>파라미터 값인 <code>[“sports”, “music”]</code>이 <code>then()</code>의 핸들러 함수의 <code>param</code> 파라미터에 설정됩니다.</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">let</span> oneObj = <span class="built_in">Promise</span>.resolve(  </span><br><span class="line"> &#123;<span class="attr">sports</span>: <span class="string">"스포츠"</span>&#125;  </span><br><span class="line">);  </span><br><span class="line"><span class="number">2.</span> <span class="built_in">Promise</span>.resolve(oneObj).then(<span class="function">(<span class="params">param</span>) =&gt;</span>&#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(param);  </span><br><span class="line">&#125;);  </span><br><span class="line"><span class="comment">// Object &#123;sports: "스포츠"&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>promise.resolve()</code> 파라미터에 <code>promise.resolve()</code>로 생성한 인스턴스를 지정한 형태입니다.</li>
</ul>
<ol>
<li><code>Promise</code> 인스턴스를 생성하여 반환합니다. 이때 <code>resolve( )</code>의 파라미터 값이 <code>[[PromiseValue]]</code>에 설정됩니다.</li>
</ol>
<ol start="2">
<li><code>Promise.resolve()</code> 파라미터에 앞에서 생성한 <code>Promise</code> 인스턴스를 지정했습니다.<br><code>then()</code>의 핸들러 함수가 실행되면 <code>oneObj</code> 인스턴스 <code>[[PromiseValue]]</code>에 설정된 값이 핸들러 함수의 <code>param</code> 파라미터에 설정됩니다. 즉, {sports: “스포츠”}가 설정됩니다.</li>
</ol>
<hr>
<h3 id="thenable"><a href="#thenable" class="headerlink" title="thenable"></a>thenable</h3><blockquote>
<p>let obj = {then(resolve,reject) {…} }</p>
</blockquote>
<p><strong>와 같이 오브젝트 안에 then()을 작성한 형태를 thenable이라고 합니다.</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">let</span> oneObj = <span class="built_in">Promise</span>.resolve(&#123;  </span><br><span class="line"> then(resolve)&#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"1: then"</span>);  </span><br><span class="line"> resolve(<span class="string">"thenable"</span>);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line"><span class="number">2.</span> oneObj.then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"2:"</span>,value));  </span><br><span class="line"><span class="comment">// 1: then  </span></span><br><span class="line"><span class="comment">// 2: thenable</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>Promise.resolve()</code>의 파라미터에 <code>Object</code> 오브젝트를 작성하고, 그 안에 <code>then()</code>을 작성했습니다.<br>이를 <code>thenable</code>이라고 합니다.이 시점에서는 <code>Promise</code> 인스턴스만 생성하고 <code>then()</code>을 실행하지 않습니다.  </p>
<p>소스 코드의 마지막 코드까지 실행한 후 <code>then()</code>을 실행합니다.<br><code>oneObj</code>에 생성한 인스턴스를 할당한 시점의 <code>[[PromiseState]]</code>값은 <code>“pending”</code>입니다.</p>
<p><code>then()</code>의 <code>resolve(“thenable”)</code>을 호출하기 전까지 <code>“pending”</code>상태 이며 호출하면 <code>“resolved”</code>로 바뀝니다.</p>
</li>
</ol>
<ol start="2">
<li><p><code>oneObj</code> 인스턴스에 <code>then()</code>이 포함되어 있으므로 위 코드를 연결하면 <code>oneObj.then().then()</code> 형태가 됩니다. </p>
<p>이 형태는 다음과 같은 순서와 방법으로 실행됩니다.</p>
<ol>
<li><code>oneObj</code> 인스턴스의 <code>then(resolve)</code>가 실행됩니다.</li>
<li>콘솔에 <code>“1:then”</code>을 출력합니다.</li>
<li><code>resolve(“thenable”)</code>을 호출합니다. 이때<code>[[PromiseValue]]</code>에 <code>“thenable”</code>을 설정합니다.</li>
<li><code>oneObj.then().then()</code> 형태에서 두 번째 <code>then()</code>이 호출됩니다.</li>
<li>두 번째 <code>then()</code>의 <code>value</code> 파라미터에 <code>[[PromiseValue]]</code> 값인 <code>“thenable”</code>이 설정됩니다.</li>
<li>콘솔에 <code>“2:thenable”</code>을 출력합니다.</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;  </span><br><span class="line"> then(resolve, reject)&#123;  </span><br><span class="line"> resolve(<span class="string">"resolve"</span>);  </span><br><span class="line"> reject(<span class="string">"에러"</span>);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="number">1.</span> <span class="keyword">let</span> oneObj = <span class="built_in">Promise</span>.resolve(thenable);  </span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span> oneObj.then(  </span><br><span class="line"> (value) =&gt; <span class="built_in">console</span>.log(value),  </span><br><span class="line"> (value) =&gt; <span class="built_in">console</span>.log(<span class="string">"실행되지 않음"</span>)  </span><br><span class="line">);  </span><br><span class="line"><span class="comment">// resolve</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Object 오브젝트에 then(resolve,reject)를 작성하였으며, resolve() 다음 줄에 reject()를 작성하였습니다. 작성 형태만 보면 resolve()를 호출하고 reject()를 호출할 것으로 보이지만,<br><mark>성공 또는 실패 하나만 발생하므로 먼저 작성한 resolve()만 호출됩니다.<br>반대로 reject(), resolve() 순서로 작성하면 reject()만 호출되고 resolve()는 호출되지 않습니다.</mark></li>
</ul>
<ol>
<li><code>Promise.resolve()</code> 파라미터에 <code>thenable</code> 오브젝트를 지정하여 <code>Promise</code> 인스턴스를 생성합니다. 이때 <code>then()</code>은 실행되지 않습니다.</li>
</ol>
<ol start="2">
<li><p><code>oneObj.then()</code>에 두 개의 파라미터를 작성했습니다.<br>첫 번째 파라미터는 <code>resolve()</code>로 호출했을 때 실행되는 함수이고<br>두 번째 파라미터는 <code>reject()</code>로 호출했을 때 실행되는 함수입니다.  </p>
<p><code>oneObj</code> 인스턴스에 <code>then()</code>이 있으므로 <code>oneObj.then()</code>은 <code>then().then()</code> 형태가 됩니다.</p>
<p>첫 번째 <code>then()</code>에서 <code>resolve(“resolve”)</code>를 호출하면 <code>[[PromiseValue]]</code>에 <code>“resolve”</code>가 설정됩니다.<br>두 번째 <code>then()</code>의 첫 번째 파라미터 함수가 실행되며, <code>value</code> 파라미터에 <code>“resolve”</code>가 설정됩니다.<br><strong>두 번째 파라미터 함수는 <code>reject()</code>를 호출하였을 때 실행되므로 위 코드에서는 실행되지 않습니다.</strong></p>
</li>
</ol>
<hr>
<h2 id="Promise_reject">reject(): 실패 상태의 인스턴스 반환</h2>

<p><strong><code>reject</code>(실패) 상태의 <code>Promise</code> 인스턴스를 반환합니다.</strong></p>
<blockquote>
<p>Promise.reject()</p>
</blockquote>
<ul>
<li>파라미터에 실패 사유를 작성합니다.</li>
</ul>
<ul>
<li>reject 상태로 변환된 Promise 인스턴스를 반환합니다.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">let</span> promiseObj = <span class="built_in">Promise</span>.reject(<span class="string">"reject 처리"</span>);  </span><br><span class="line"><span class="number">2.</span> promiseObj.then(  </span><br><span class="line"> (param) =&gt; <span class="built_in">console</span>.log(param),  </span><br><span class="line"> (param) =&gt; <span class="built_in">console</span>.log(<span class="string">"에러:"</span>, param));  </span><br><span class="line"><span class="comment">// 에러: reject 처리</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>Promise.reject()</code>를 실행하면 <code>reject</code> 상태의 <code>Promise</code> 인스턴스를 생성하여 반환합니다.<br>파라미터 값이 <code>[[PromiseValue]]</code>에 설정되며, <code>then()</code>의 두 번째 파라미터 함수의 파라미터 값으로 설정됩니다.  </p>
<p>다음은 promiseObj 인스턴스 구조입니다.</p>
<img src="/images/rejectPromiseObj.JPG">

<ol>
<li><code>Promise</code> 인스턴스의 상태는 <code>“reject”</code>입니다. 따라서 <code>then()</code>의 두 번째 파라미터 함수가 호출됩니다.</li>
<li><code>Promise.reject()</code> 파라미터에 작성한 <code>“reject 처리”</code>가 <code>[[PromiseValue]]</code>에 설정됩니다.</li>
</ol>
</li>
</ol>
<ol start="2">
<li><code>promiseObj.then()</code>에 두 개의 파라미터를 작성했습니다. 첫 번째 파라미터 함수는 <code>resolve()</code>로 호출했을 때 실행되고, 두 번째 파라미터 함수는 <code>reject()</code>로 호출했을 때 실행됩니다.<br>현재 <code>reject</code> 상태이므로 두 번째 파라미터 함수가 실행됩니다.</li>
</ol>
<hr>
<h2 id="Promise_all">all(): 모두 성공이면 핸들러 실행</h2>

<p><strong>파라미터의 모든 <code>Promise</code> 인스턴스가 성공 상태이면 <code>then()</code>의 핸들러 함수를 실행합니다.</strong></p>
<blockquote>
<p>Promise.all()</p>
</blockquote>
<ul>
<li>파라미터에 이터러블 오브젝트를 작성합니다.<br>이터러블 오브젝트에 작성한 순서로 Promise 인스턴스를 생성합니다.</li>
</ul>
<p><mark>생성한 모든 Promise 인스턴스가 성공 상태이면, then()의 첫 번째 파라미터 함수를 실행합니다.<br>Promise 인스턴스가 하나라도 실패한다면, then()의 핸들러 함수를 실행하지 않습니다.</mark></p>
<p><code>executer</code> 블록에서 <code>resolve()</code>를 호출한 순서가 아닌 <code>Promise</code> 인스턴스를 생성한 순서로 파라미터 값을 배열에 첨부하여 <code>[[PromiseValue]]</code>에 설정합니다. <code>then()</code>의 첫 번째 파라미터 함수에서 파라미터 값으로 사용합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">function</span> <span class="title">order</span>(<span class="params">mili</span>) </span>&#123;  </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;  </span><br><span class="line"> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"실행"</span>, mili);  </span><br><span class="line"> resolve(mili);  </span><br><span class="line"> &#125;, mili);  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span> <span class="built_in">Promise</span>.all([order(<span class="number">300</span>), order(<span class="number">200</span>), order(<span class="number">100</span>)])  </span><br><span class="line"> .then(<span class="function">(<span class="params">milis</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"호출"</span>, milis));  </span><br><span class="line"><span class="comment">// 실행 100  </span></span><br><span class="line"><span class="comment">// 실행 200  </span></span><br><span class="line"><span class="comment">// 실행 300  </span></span><br><span class="line"><span class="comment">// 호출 [300, 200, 100]</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>order(mili)</code>가 호출되면 <code>Promise</code> 인스턴스를 생성하면서 <code>setTimeout()</code>을 실행합니다.<br>파라미터로 받은 <code>mili</code> 값을 지연 시간으로 사용합니다. 지연 시간이 경과한 후에 <code>setTimeout</code>의 콜백 함수가 실행됩니다.<br><strong><code>order()</code>를 여러 번 호출했을 때, 호출한 순서가 아닌 <code>mili</code> 값에 따라 콜백 함수가 실행되므로 실행 순서가 달라질 수 있습니다.</strong><br>즉, 콜백 함수에서 <code>resolve()</code> 호출 순서가 바뀔 수 있습니다.</li>
</ol>
<ol start="2">
<li><code>Promise.all()</code>의 파라미터에 <code>order()</code> 호출을 배열로 작성했습니다.<br>따라서 첫 번째 엘리먼트부터 차례로 <code>order()</code> 함수를 호출하게 됩니다. 호출된 <code>order()</code> 함수에서 <code>setTimeout()</code>을 실행하며, 파라미터로 넘겨준 값을 지연 시간으로 사용합니다.<br>함수 호출에는 시간이 걸리지 않아 (0.1초 안에) 세 개의 <code>order() 300,200,100</code> 순서로 호출됩니다.<br>하지만 <code>setTimeout()</code>의 콜백 함수는 지연 시간으로 인해 100, 200, 300 순서로 실행되게 됩니다.</li>
</ol>
<p><code>setTimeout()</code>에서 지연 시간이 경과하면 콜백 함수에서 <code>resolve(mili)</code>를 호출하게 되며<br><code>then()</code>의 핸들러 함수가 실행됩니다.<br>이때, <code>Promise.all()</code>은 <code>resolve(mili)</code>를 호출할 때 마다 <code>then()</code>의 핸들러 함수가 실행되지 않습니다. </p>
<p><code>Promise.all()</code>의 파라미터에서 <code>order()</code> 호출로 생성한 <code>Promise</code> 인스턴스가 모두 성공적으로 처리되었을 때 한 번만 호출합니다.  </p>
<p><code>Promise.all()</code>에서 <code>order()</code>함수를 총 세 번 호출하지만, 생성된 인스턴스가 모두 성공적으로 처리돼야 <code>then()</code>의 핸들러 함수를 실행하는 것입니다.</p>
<p>실행 결과 “실행 100”, “실행 200”, “실행 300”은 <code>setTimeout</code>의 콜백 함수가 실행한 출력 값이고,<br>호출 [300, 200, 100]은 <code>then()</code>의 핸들러 함수에서 출력한 값입니다.</p>
<hr>
<h2 id="Promise_race">race(): 처음 한 번만 핸들러 호출</h2>

<p><strong>처음 한 번만 <code>then()</code>의 핸들러 함수를 실행합니다.</strong></p>
<blockquote>
<p>Promise.race()</p>
</blockquote>
<ul>
<li>파라미터에 이터러블 오브젝트를 작성합니다. 이터러블 오브젝트에 작성한 순서로 <code>Promise</code> 인스턴스를 생성합니다. 처음 한 번만 <code>Promise</code> 인스턴스 성공과 실패에 따라 <code>then()</code>의 핸들러 함수를 호출하고, 그 다음 부터는 호출하지 않습니다.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">order</span>(<span class="params">mili</span>) </span>&#123;  </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  </span><br><span class="line"> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(mili);  </span><br><span class="line"> resolve(mili);  </span><br><span class="line"> &#125;, mili);  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="number">1.</span> <span class="built_in">Promise</span>.race([order(<span class="number">300</span>), order(<span class="number">200</span>), order(<span class="number">100</span>)])  </span><br><span class="line"> .then(<span class="function">(<span class="params">milis</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"then:"</span>, milis),  </span><br><span class="line"> (error) =&gt; <span class="built_in">console</span>.log(error));  </span><br><span class="line"><span class="comment">// 100  </span></span><br><span class="line"><span class="comment">// then: 100  </span></span><br><span class="line"><span class="comment">// 200  </span></span><br><span class="line"><span class="comment">// 300</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>Promise.race()</code>에서 order(300), order(200), order(100) 순서로 order() 함수를 호출합니다.<br>하지만 <code>Promise.race()</code>는 <strong>처음 한 번만 <code>then()</code>의 핸들러 함수가 실행되므로 order(200), order(100)의 핸들러 함수는 실행되지 않습니다.</strong></li>
</ol>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JavaScript/">JavaScript</a><a class="link-muted mr-2" rel="tag" href="/tags/ECMAScript6/">ECMAScript6</a><a class="link-muted mr-2" rel="tag" href="/tags/Promise/">Promise</a><a class="link-muted mr-2" rel="tag" href="/tags/settled/">settled</a><a class="link-muted mr-2" rel="tag" href="/tags/fulfill/">fulfill</a><a class="link-muted mr-2" rel="tag" href="/tags/reject/">reject</a><a class="link-muted mr-2" rel="tag" href="/tags/new-Promise/">new Promise()</a><a class="link-muted mr-2" rel="tag" href="/tags/then/">then()</a><a class="link-muted mr-2" rel="tag" href="/tags/catch/">catch()</a><a class="link-muted mr-2" rel="tag" href="/tags/resolve/">resolve()</a><a class="link-muted mr-2" rel="tag" href="/tags/thenable/">thenable</a><a class="link-muted mr-2" rel="tag" href="/tags/reject/">reject()</a><a class="link-muted mr-2" rel="tag" href="/tags/all/">all()</a><a class="link-muted mr-2" rel="tag" href="/tags/race/">race()</a><a class="link-muted mr-2" rel="tag" href="/tags/Synchronous/">Synchronous</a><a class="link-muted mr-2" rel="tag" href="/tags/Asynchronous/">Asynchronous</a><a class="link-muted mr-2" rel="tag" href="/tags/PromiseState/">PromiseState</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/04/16/%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%83%80%EC%9E%85%20-Core%20JavaScript/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">데이터 타입 -Core JavaScript</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/04/14/WeakSet%20%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%20-ECMAScript/"><span class="level-item">WeakSet 오브젝트 -ECMAScript</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">카탈로그</h3><ul class="menu-list"><li><a class="is-flex" href="#Promise"><span class="mr-2">1</span><span>개요</span></a><ul class="menu-list"><li><a class="is-flex" href="#Promise-처리-순서"><span class="mr-2">1.1</span><span>Promise 처리 순서</span></a></li></ul></li><li><a class="is-flex" href="#Promise_상태"><span class="mr-2">2</span><span>Promise 상태</span></a><ul class="menu-list"><li><a class="is-flex" href="#pending-상태"><span class="mr-2">2.1</span><span>pending 상태</span></a></li><li><a class="is-flex" href="#settled-상태"><span class="mr-2">2.2</span><span>settled 상태</span></a><ul class="menu-list"><li><a class="is-flex" href="#fulfill-성공"><span class="mr-2">2.2.1</span><span>fulfill (성공)</span></a></li><li><a class="is-flex" href="#reject-실패"><span class="mr-2">2.2.2</span><span>reject (실패)</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#newPromise"><span class="mr-2">3</span><span>new Promise(): Promise 인스턴스 생성</span></a><ul class="menu-list"><li><a class="is-flex" href="#성공-기준"><span class="mr-2">3.1</span><span>성공 기준</span></a></li><li><a class="is-flex" href="#실패-기준"><span class="mr-2">3.2</span><span>실패 기준</span></a></li></ul></li><li><a class="is-flex" href="#Promise_then"><span class="mr-2">4</span><span>then(): 성공, 실패 핸들러</span></a><ul class="menu-list"><li><a class="is-flex" href="#코드-실행-순서-정리"><span class="mr-2">4.1</span><span>코드 실행 순서 정리</span></a></li></ul></li><li><a class="is-flex" href="#Promise_catch"><span class="mr-2">5</span><span>catch(): 실패 핸들러</span></a></li><li><a class="is-flex" href="#Promise_resolve"><span class="mr-2">6</span><span>resolve(): 성공 상태의 인스턴스 반환</span></a><ul class="menu-list"><li><a class="is-flex" href="#thenable"><span class="mr-2">6.1</span><span>thenable</span></a></li></ul></li><li><a class="is-flex" href="#Promise_reject"><span class="mr-2">7</span><span>reject(): 실패 상태의 인스턴스 반환</span></a></li><li><a class="is-flex" href="#Promise_all"><span class="mr-2">8</span><span>all(): 모두 성공이면 핸들러 실행</span></a></li><li><a class="is-flex" href="#Promise_race"><span class="mr-2">9</span><span>race(): 처음 한 번만 핸들러 호출</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Core-JavaScript/"><span class="level-start"><span class="level-item">Core JavaScript</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/ECMAScript6/"><span class="level-start"><span class="level-item">ECMAScript6</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/React/"><span class="level-start"><span class="level-item">React</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/VS-Code/"><span class="level-start"><span class="level-item">VS Code</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/jQuery/"><span class="level-start"><span class="level-item">jQuery</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/template.png" alt="한참치의 Study Blog" height="28"></a><p class="size-small"><span>&copy; 2020 Han Dongwon</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://hdw0903.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script async="async" src="https://sda.dveamer.com/js/csda.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(Untitled)","posts":"포스트","pages":"Pages","categories":"카테고리","tags":"태그"});
        });</script></body></html>