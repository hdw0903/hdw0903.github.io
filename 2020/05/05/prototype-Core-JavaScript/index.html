<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="웹 개발 공부 블로그"><title>prototype -Core JavaScript - 한참치의 Study Blog</title><meta description="프로토타입 (prototype) 프로토타입의 개념 이해 constructor, prototype, instance constructor 프로퍼티   프로토타입 체인 메서드 오버라이드 프로토타입 체인 객체 전용 메서드의 예외사항 다중 프로토타입 체인   정리"><meta property="og:type" content="blog"><meta property="og:title" content="prototype -Core JavaScript"><meta property="og:url" content="https://hdw0903.github.io/2020/05/05/prototype-Core-JavaScript/"><meta property="og:site_name" content="한참치의 Study Blog"><meta property="og:description" content="프로토타입 (prototype) 프로토타입의 개념 이해 constructor, prototype, instance constructor 프로퍼티   프로토타입 체인 메서드 오버라이드 프로토타입 체인 객체 전용 메서드의 예외사항 다중 프로토타입 체인   정리"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://hdw0903.github.io/2020/05/05/prototype-Core-JavaScript/images/blog_logo.png"><meta property="article:published_time" content="2020-05-05T08:57:53.000Z"><meta property="article:modified_time" content="2020-07-06T11:54:28.781Z"><meta property="article:author" content="Han Dongwon"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="prototype"><meta property="article:tag" content="constructor"><meta property="article:tag" content="static"><meta property="article:tag" content="__proto__"><meta property="article:tag" content="Core JavaScript"><meta property="article:tag" content="instance"><meta property="article:tag" content="prototype chain"><meta property="article:tag" content="method override"><meta property="article:tag" content="Object.prototype"><meta property="article:tag" content="prototype 도식"><meta property="article:tag" content="Object static method"><meta property="article:tag" content="multiple prototype chain"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="images/blog_logo.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hdw0903.github.io/2020/05/05/prototype-Core-JavaScript/"},"headline":"한참치의 Study Blog","image":["https://hdw0903.github.io/images/prototype_schematic.png","https://hdw0903.github.io/images/prototype_schematic2.png","https://hdw0903.github.io/images/prototype_Constructor.png","https://hdw0903.github.io/images/prototype_Instance.png","https://hdw0903.github.io/images/prototype_arr_Array.png","https://hdw0903.github.io/images/prototype_Array_schematic.png","https://hdw0903.github.io/images/%EA%B0%9D%EC%B2%B4%EC%9D%98_%EC%B5%9C%EC%83%81%EC%9C%84_%EA%B0%9D%EC%B2%B4_Object.png","https://hdw0903.github.io/images/Object_prototype.png"],"datePublished":"2020-05-05T08:57:53.000Z","dateModified":"2020-07-06T11:54:28.781Z","author":{"@type":"Person","name":"Han Dongwon"},"description":"프로토타입 (prototype) 프로토타입의 개념 이해 constructor, prototype, instance constructor 프로퍼티   프로토타입 체인 메서드 오버라이드 프로토타입 체인 객체 전용 메서드의 예외사항 다중 프로토타입 체인   정리"}</script><link rel="canonical" href="https://hdw0903.github.io/2020/05/05/prototype-Core-JavaScript/"><link rel="icon" href="/images/coffee-favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/tomorrow-night-bright.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link href="https://fonts.googleapis.com/earlyaccess/jejugothic.css" rel="stylesheet"><meta name="naver-site-verification" content="3b4f64ce6899317f220936e0013e08a5320d0b65"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-164181722-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-164181722-1');</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script data-ad-client="ca-pub-7899198893911275" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><link rel="alternate" href="/rss2.xml" title="한참치의 Study Blog" type="application/rss+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/template.png" alt="한참치의 Study Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub Home" href="https://github.com/hdw0903"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="카탈로그" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-10-desktop is-11-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">2020년 5월 5일 화요일 오후 5:57</span><span class="level-item"><a class="link-muted" href="/categories/Core-JavaScript/">Core JavaScript</a></span><span class="level-item">25분 읽기 (대략 3678 단어)</span></div></div><h1 class="title is-3 is-size-3-mobile">prototype -Core JavaScript</h1><div class="content"><ul>
<li>프로토타입 (prototype)<ul>
<li><a href="/2020/05/05/prototype-Core-JavaScript/#프로토타입의-개념-이해">프로토타입의 개념 이해</a><ul>
<li>constructor, prototype, instance</li>
<li>constructor 프로퍼티</li>
</ul>
</li>
<li><a href="/2020/05/05/prototype-Core-JavaScript/#prototype_chain">프로토타입 체인</a><ul>
<li>메서드 오버라이드</li>
<li>프로토타입 체인</li>
<li>객체 전용 메서드의 예외사항</li>
<li>다중 프로토타입 체인</li>
</ul>
</li>
<li><a href="/2020/05/05/prototype-Core-JavaScript/#point">정리</a></li>
</ul>
</li>
</ul>
<a id="more"></a>

<hr>
<h2 id="프로포타입의-개념-이해">프로토타입의 개념 이해</h2>

<h3 id="constructor-prototype-instance"><a href="#constructor-prototype-instance" class="headerlink" title="constructor, prototype, instance"></a>constructor, prototype, instance</h3><blockquote>
<p>var instance = new Constructor();</p>
</blockquote>
<p>위 코드를 추상화 하여 나타내면 다음과 같습니다.</p>
<p><img src="/images/prototype_schematic.png" alt="prototype schematic"></p>
<p>윗변(실선)의 왼쪽 꼭지점에는 <code>Constructor</code>(생성자 함수)를, 오른쪽 꼭짓점에는 <code>Constructor.prototype</code>이라는 프로퍼티를 위치시켰습니다.<br>왼쪽 꼭짓점부터 아래를 향한 화살표 중간에 <code>new</code>가 있고, 화살표의 종점에는 <code>instance</code>가 있습니다.<br>오른쪽 꼭짓점으로부터 대각선 아래로 향하는 화살표의 종점에는 <code>instance.__proto__</code>이라는 프로퍼티를 위치시켰습니다. </p>
<hr>
<ul>
<li><p>어떤 생성자 함수(<code>Constructor</code>)를 <code>new</code> 연산자와 함께 호출하면</p>
</li>
<li><p><code>Constructor</code>에서 정의된 내용을 바탕으로 새로운 인스턴스(<code>instance</code>)가 생성됩니다.</p>
</li>
<li><p>이떄 <code>instance</code>에는 <code>__proto__</code>라는 프로퍼티가 자동으로 부여되는데,</p>
</li>
<li><p>이 프로퍼티는 <code>Constructor</code>의 <code>prototype</code>이라는 프로퍼티를 참조합니다.</p>
</li>
</ul>
<p><code>prototype</code>이라는 프로퍼티와 <code>__proto__</code> <mark>이 둘의 관계가 프로토타입 개념의 핵심입니다.</mark></p>
<p><code>prototype</code>은 객체입니다. 이를 참조하는 <code>__proto__</code> 역시 객체입니다.</p>
<p><code>prototype</code> 객체 내부에는 <code>instance</code>가 사용할 메서드를 저장합니다. 그러면 <code>instance</code>에서도 숨겨진 프로퍼티인 <code>__proto__</code>를 통해 이 메서드들에 접근할 수 있게 됩니다.</p>
<hr>
<figure class="highlight js"><figcaption><span>Person이라는 생성자 함수의 prototype에 getName이라는 메서드를 지정한 예제</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>이제 <code>Person</code>의 <code>instance</code>는 <code>__proto__</code>프로퍼티를 통해 <code>getName</code>을 호출할 수 있습니다.<br><code>instance</code>의 <code>__proto__</code>가 <code>Constructor</code>의 <code>prototype</code>프로퍼티를 참조하므로 결국 둘은 같은 객체를 바라보기 때문입니다.</p>
<figure class="highlight js"><figcaption><span>this 바인딩 값</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suzi = <span class="keyword">new</span> Person(<span class="string">'Suzi'</span>);</span><br><span class="line">suzi.__proto__.getName(); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">Person.prototype === suzi.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>suzi.__proto__.getName();</code>를 실행해 <code>undefined</code>가 나왔다는 것은 이 변수가 “호출할 수 있는 함수”에 해당한다는 것을 의미합니다. </li>
</ul>
<ul>
<li>만약 함수가 아닌 다른 데이터 값이었다면 <code>TypeError</code>가 발생했을 것입니다. 에러가 아닌 <code>undefined</code>를 반환했으므로 <code>getName</code>이 실제로 실행됐고 <code>getName</code>이 함수라는 것이 입증됐습니다.</li>
</ul>
<ul>
<li><code>undefined</code>를 반환한 이유는 <code>this</code>의 바인딩 값이 잘못됐음을 의미합니다.</li>
</ul>
<ul>
<li><code>suzi.__proto__.getName();</code>에서 <code>getName</code> 함수 내부에서의 <code>this</code>는 <code>suzi</code>가 아니라 메서드명 바로앞의 객체 즉, <code>suzi.__proto__</code>를 참조하게 되는 것입니다. </li>
</ul>
<ul>
<li><code>suzi.__proto__</code> 내부에 <code>name</code>프로퍼티가 없으므로 엔진이 “데이터 영역에 지정되지 않은 식별자에 접근할 때”를 뜻하는 <code>undefined</code>를 반환하게 됩니다. </li>
</ul>
<hr>
<p><code>__proto__</code> 객체에 <code>name</code> 프로퍼티가 있다면 <code>undefined</code>가 아니라 프로퍼티 값이 출력 되겠죠?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suzi = <span class="keyword">new</span> Person(<span class="string">'Suzi'</span>);</span><br><span class="line">suzi.__proto__._name = <span class="string">'SUZI__proto__'</span>;</span><br><span class="line">suzi.__proto__.getName(); <span class="comment">// SUZI__proto__</span></span><br></pre></td></tr></table></figure>

<p>위 예제 코드들의 관건은 <code>this</code>가 어떤 값을 참조하게 되는가 였습니다.<br><code>this</code>가 <code>instance</code>를 참조하게 하는 방법은 간단합니다.<br><code>__proto__</code>를 생략하고 <code>instance</code>뒤에 바로 메서드를 작성하면 됩니다.</p>
<figure class="highlight js"><figcaption><span>__proto__ 생략</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suzi = <span class="keyword">new</span> Person(<span class="string">'Suzi'</span>, <span class="number">28</span>);</span><br><span class="line">suzi.getName(); <span class="comment">// Suzi</span></span><br></pre></td></tr></table></figure>

<p>이런 코드가 실행되는 이유는 <code>__proto__</code>가 생략 가능한 프로퍼티이기 때문입니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suzi.__proto__.getName</span><br><span class="line">&gt; suzi(.__proto__).getName</span><br><span class="line">== suzi.getName</span><br></pre></td></tr></table></figure>

<ul>
<li><p>정리하면 </p>
<ul>
<li><code>__proto__</code>를 생략하지 않으면 <code>this</code>는 <code>suzi.__proto__</code>를 참조 (내부에 name프로퍼티 존재하지 않음)</li>
<li>생략하면 <code>suzi</code>를 참조 가능해짐. (suzi.getName 형태, name 프로퍼티 존재)</li>
</ul>
<p><img src="/images/prototype_schematic2.png" alt="prototype schematic2"></p>
<ul>
<li>new 연산자로 <code>Constructor</code> 호출시 <code>instance</code> 생성되고<br><code>instance</code>의 생략가능한 프로퍼티인 <code>__proto__</code>는<br><code>Constructor</code>의 <code>prototype</code>을 참조</li>
</ul>
</li>
</ul>
<figure class="highlight js"><figcaption><span>prototype과 __proto__</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Constructor = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Constructor.prototype.method1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Constructor.prototype.property1 = <span class="string">'Constructor Prototype Property'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Constructor(<span class="string">'Instance'</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(Constructor); <span class="comment">//Constructor의 디렉터리 구조 출력</span></span><br><span class="line"><span class="built_in">console</span>.dir(instance); <span class="comment">//instance의 디렉터리 구조 출력</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위 예제를 크롬 개발자도구에서 실행한 결과</li>
</ul>
<p><img src="/images/prototype_Constructor.png" alt="prototype Constructor"></p>
<ul>
<li><code>Constructor</code>의 디렉터리 구조를 출력한<ul>
<li>첫 번째 줄에 함수라는 의미의 <code>f</code> 와 함수이름 <code>Constructor</code>, 인자 <code>name</code>이 출력되었습니다.</li>
<li>그 내부에는 <mark>옅은 색</mark>의 argument, caller, length, name, <code>prototype</code>, &#95;&#95;proto&#95;&#95;등의 프로퍼티들이 나타납니다.</li>
<li>내부 프로퍼티중 <code>prototype</code>을 열면 개발자가 직접 추가한 <code>metod1</code>, <code>property1</code>등의 값은 <mark>짙은 색</mark>으로 보이고, constructor, &#95;&#95;proto&#95;&#95; 등은 <mark>옅은 색</mark>으로 보입니다.<pre><code>이런 색상의 차이는 { enumerable: false } 속성이 부여된 프로퍼티인지 여부에 따릅니다.
짙은 색은 enumerable, 즉 열거 가능한 프로퍼티임을 의미하고, 
옅은 색은 innumerable, 즉 열거할 수 없는 프로퍼티입니다.
for in 문 등으로 객체의 프로퍼티 전체에 접근할 때 접근 가능 여부를 
색상으로 구분지어 표기하는 것입니다.</code></pre></li>
</ul>
</li>
</ul>
<div align="center">

<p><img src="/images/prototype_Instance.png" alt="prototype Instance"></p>
</div>

<ul>
<li><code>instance</code>의 디렉터리 구조를 출력한<ul>
<li>첫 번째 줄에 <code>Constructor</code>가 출력됩니다.<br>생성자 함수의 <code>instance</code>는 해당 생성자 함수의 이름을 표기함으로<br>해당 함수의 <code>instance</code>임을 나타냅니다.</li>
<li><code>Constructor</code>를 열어보면 <code>name</code>프로퍼티가 짙은 색으로 표기되고, <code>__proto__</code>프로퍼티가 옅은 색으로 표기됩니다.</li>
<li><code>__proto__</code>를 열어보면 <code>method1</code>, <code>property1</code>, <code>constructor</code>, <code>__proto__</code> 등이 있으므로,<br><code>Constructor</code>의 <code>prototype</code>과 동일한 내용으로 구성돼 있음을 확인할 수 있습니다.</li>
</ul>
</li>
</ul>
<hr>
<h4 id="내장-built-in-생성자-함수-Array-구조"><a href="#내장-built-in-생성자-함수-Array-구조" class="headerlink" title="내장(built-in) 생성자 함수 Array 구조"></a>내장(built-in) 생성자 함수 Array 구조</h4><figure class="highlight js"><figcaption><span>Array</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.dir(arr);</span><br><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">Array</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/prototype_arr_Array.png" alt="prototype arr and Array"></p>
<ul>
<li><p>arr</p>
<ul>
<li>첫 줄에 <code>Array(2)</code>가 표기됩니다.</li>
<li><code>Array</code> 생성자 함수를 원본으로 생성됐고, <code>length</code> 값 2를 알 수 있습니다.</li>
<li><code>index 0, 1</code>은 짙은 색으로 length와 &#95;&#95;proto&#95;&#95;는 옅은 색으로 표기됩니다.</li>
<li>&#95;&#95;proto&#95;&#95; 에는 Array 메서드 들이 포함되어 있습니다.</li>
</ul>
</li>
<li><p>Array</p>
<ul>
<li>첫 줄에 함수를 뜻하는 <code>f</code>가 표시됩니다.</li>
<li>함수의 프로퍼티인 <code>argument</code>, <code>caller</code>, <code>length</code>, <code>name</code>등이 표기됩니다.</li>
<li>또한 <code>Array</code> 함수의 정적 메서드 <code>from</code>, <code>isArray</code> <code>of</code> 등도 있습니다.</li>
<li><code>prototype</code>을 열어보면 왼쪽(arr)의 &#95;&#95;proto&#95;&#95;와 동일한 구성임을 확인할 수 있습니다.</li>
</ul>
</li>
</ul>
<ul>
<li><p>위 결과를 도식으로 나타면 다음과 같습니다.<br><img src="/images/prototype_Array_schematic.png" alt="prototype Array schematic"></p>
</li>
<li><p>Array를 new 연산자와 함께 호출하든, 배열 리터럴을 생성하든 <code>instance</code>인 [1, 2]가 만들어집니다.</p>
</li>
</ul>
<ul>
<li><code>instance</code>의 <code>__proto__</code>은 Array.prototype을 참조함으로 <code>instance</code>가 push, pop, forEach 등 Array 메서드를 자신의 것처럼 호출할 수 있습니다.(<code>__proto__</code>가 생략 가능하도록 설계돼 있기 때문에)</li>
</ul>
<ul>
<li><strong>한편 <code>Array의 prototype 프로퍼티 내부</code>에 있지 않은 <code>from, isArray</code> 등의 메서드들은 <code>instance</code>가 직접 호출할 수 없습니다. 이들은 <code>Array 생성자 함수</code>에서 직접 접근해야 실행 가능합니다.</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array 생성자 함수를 원본으로하는 instance인 arr</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// __proto__ 생략 가능으로 인한 Array 메서드 직접 호출 </span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;); <span class="comment">// (o)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array의 prototype 프로퍼티 내부에 없는 메서드는</span></span><br><span class="line"><span class="comment">// instance가 직접 호출 불가능</span></span><br><span class="line">arr.isArray(); <span class="comment">// (x) TypeError: arr.isArray is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array 생성자 함수에서 직접 접근하여 실행해야 됨</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr); <span class="comment">// (o) true</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="constructor-프로퍼티"><a href="#constructor-프로퍼티" class="headerlink" title="constructor 프로퍼티"></a>constructor 프로퍼티</h3><p><code>생성자 함수</code>의 프로퍼티인 <code>prototype</code> 객체 내부에는 <code>constructor</code> 프로퍼티가 있습니다.<br><code>instance</code>의 <code>__proto__</code> 객체 내부에도 마찬가지로 존재합니다.<br><code>constructor</code> 프로퍼티는 원래의 생성자 함수(자기 자신)를 참조하고,<br><code>instance</code>로부터 그 원형을 알 수 있는 수단으로 <code>instance</code>와의 관계에 있어 필요한 정보입니다.</p>
<figure class="highlight js"><figcaption><span>constructor 프로퍼티 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">arr.__proto__.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">arr.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> arr.constructor(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [3, 4]</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="다양한-constructor-접근-방법"><a href="#다양한-constructor-접근-방법" class="headerlink" title="다양한 constructor 접근 방법"></a>다양한 constructor 접근 방법</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'사람1'</span>); <span class="comment">// Person &#123; name: "사람1" &#125; true</span></span><br><span class="line"><span class="keyword">var</span> p1Proto = <span class="built_in">Object</span>.getPrototypeOf(p1);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person.prototype.constructor(<span class="string">'사람2'</span>); <span class="comment">// Person &#123; name: "사람2" &#125; true</span></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> p1Proto.constructor(<span class="string">'사람3'</span>); <span class="comment">// Person &#123; name: "사람3" &#125; true</span></span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> p1.__proto__.constructor(<span class="string">'사람4'</span>); <span class="comment">// Person &#123; name: "사람4" &#125; true</span></span><br><span class="line"><span class="keyword">var</span> p5 = <span class="keyword">new</span> p1.constructor(<span class="string">'사람5'</span>); <span class="comment">// Person &#123; name: "사람5" &#125; true</span></span><br><span class="line"></span><br><span class="line">[p1, p2, p3, p4, p5].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p, p <span class="keyword">instanceof</span> Person);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>다음은 모두 동일한 대상을 가리키게 됩니다.</strong></li>
</ul>
<pre><code>1. [Constructor]

2. [instance].__proto__.constructor

3. [instance].constructor

4. Object.getPrototypeOf([instance]).constructor

5. [Constructor].prototype.constructor</code></pre><ul>
<li><strong>다음은 모두 동일한 객체에 접근할 수 있습니다.</strong></li>
</ul>
<pre><code>1. [Constructor].prototype

2. [instance].__proto__

3. [instance]

4. Object.getPrototypeOf([instance])</code></pre><ul>
<li>따라서 p1 부터 p5까지 모두 Person의 instance입니다.</li>
</ul>
<hr>
<h2 id="prototype_chain">프로토타입 체인</h2>

<hr>
<h3 id="메서드-오버라이드"><a href="#메서드-오버라이드" class="headerlink" title="메서드 오버라이드"></a>메서드 오버라이드</h3><p><code>instance</code>가 동일한 이름의 프로퍼티 또는 메서드를 가지고 있는 상황이라면</p>
<p><code>instance.method()</code> 형태로 호출했을 때<br><code>instance.__proto__.method</code>가 아닌 <code>instance</code>객체에 있는 해당 <code>method</code>가 호출됩니다.<br>여기서 일어난 현상을 메서드 위에 메서드를 덮어씌웠다고 하여 <mark>메서드 오버라이드</mark>라고합니다.</p>
<ul>
<li>자바스크립트 엔진은 프로퍼티(혹은 메서드)를 찾을 때 가장 가까운 대상인 자신의 프로퍼티를 먼저 검색하고, 없으면 그다음으로 가까운 대상인 &#95;&#95;proto&#95;&#95;를 검색합니다.<br>그러므로 메서드 오버라이드 됐을 때 &#95;&#95;proto&#95;&#95;에 있는 메서드는 우선 순위에서 밀려 호출되지 않는 것입니다.</li>
</ul>
<hr>
<h4 id="메서드-오버라이드된-상태에서-prototype에-있는-메서드에-접근법"><a href="#메서드-오버라이드된-상태에서-prototype에-있는-메서드에-접근법" class="headerlink" title="메서드 오버라이드된 상태에서 prototype에 있는 메서드에 접근법"></a>메서드 오버라이드된 상태에서 prototype에 있는 메서드에 접근법</h4><blockquote>
<p>instance.&#95;&#95;proto&#95;&#95;.method()</p>
</blockquote>
<p>형태로 호출하면 정상적으로 <code>prototype</code>에 있는 <code>method</code>에 접근할 수 있습니다.<br>하지만 <code>this</code>가 <code>instance</code>를 바라보지 않고 있습니다.</p>
<p><code>call</code>이나 <code>apply</code>를 사용하면</p>
<blockquote>
<p>instance.&#95;&#95;proto&#95;&#95;.method.call(thisArg) 형태로 작성하여 <code>this</code> 대상을 지정합니다.</p>
</blockquote>
<hr>
<h3 id="프로토타입-체인"><a href="#프로토타입-체인" class="headerlink" title="프로토타입 체인"></a>프로토타입 체인</h3><p><mark>자바스크립트의 모든 객체의 최상위 객체에는 Object 객체가 존재합니다.</mark></p>
<p>따라서 모든 객체의 <code>__proto__</code>에는 <code>Object.prototype</code>이 연결됩니다.</p>
<p><strong>Array 객체를 예시로 든 최상위 객체 Object와의 구조 도식(<del>prototype 역시 객체입니다.</del>)</strong></p>
<p><img src="/images/%EA%B0%9D%EC%B2%B4%EC%9D%98_%EC%B5%9C%EC%83%81%EC%9C%84_%EA%B0%9D%EC%B2%B4_Object.png" alt="객체의 최상위 객체 Object"></p>
<ul>
<li><p>앞에서 <code>__proto__</code>는 생략가능한 프로퍼티이므로 <code>배열[]</code>에서 <code>Array.prototype</code> 내부의 메서드를 직접 호출할 수 있었습니다. </p>
</li>
<li><p>마찬가지로 <code>배열[]</code>의 <code>__proto__</code>를 계속 따라가다 보면 <code>Object.prototype</code>이 있으므로 <code>Object.prototype</code>의 내부 메서드도 직접 호출할 수 있습니다.</p>
</li>
</ul>
<hr>
<p>이러한 <code>__proto__</code> 프로퍼티 내부에 다시 <code>__proto__</code>프로퍼티가 연쇄적으로 이어진 것을<br><strong>프로토타입 체인</strong>(<code>prototype chain</code>)이라 하고, </p>
<p>이 체인을 따라 검색하는 것을 <strong>프로토타입 체이닝</strong>(<code>prototype chaining</code>)이라고 합니다.</p>
<hr>
<h3 id="객체-전용-메서드의-예외사항"><a href="#객체-전용-메서드의-예외사항" class="headerlink" title="객체 전용 메서드의 예외사항"></a>객체 전용 메서드의 예외사항</h3><p>어떤 생성자 함수이든 <code>prototype</code>은 객체이기 때문에 <code>Object.prototype</code>이 언제나 프로토타입 체인의 최상단에 존재하게 됩니다.</p>
<p>따라서 <strong>객체에서만 사용할 메서드는 다른 데이터 타입처럼 프로토타입 객체 안에 정의할 수 없습니다.</strong></p>
<p><strong>객체에서만 사용할 메서드를 <code>Object.prototype</code>내부에 정의한다면 다른 데이터 타입도 해당 메서드를 사용할 수 있게 되기 때문입니다.</strong>(참조형 데이터뿐 아니라 기본형 데이터도 &#95;&#95;proto&#95;&#95;에 반복적으로 접근하여 도달하는 최상위 객체가 Object.prototype이 됨)</p>
<ul>
<li>이 같은 이유로 객체만을 대상으로 동작하는 <strong>Object 전용 메서드</strong>들은 부득이 <code>Object.prototype</code>이 아닌 <code>Object</code>에 정적(<code>static</code>)메서드로 구현돼 있습니다.</li>
</ul>
<p><img src="/images/Object_prototype.png" alt="Object-prototype"></p>
<ul>
<li>한편 <code>Object.prototype</code>에는 어떤 데이터에서도 활용할 수 있는 범용적인 메서드들만 있습니다.<br>toString, hasOwnProperty, valueOf, isPrototypeOf 등은 모든 <code>instance</code>가 직접 호출할 수 있습니다.</li>
</ul>
<hr>
<h3 id="다중-프로토타입-체인"><a href="#다중-프로토타입-체인" class="headerlink" title="다중 프로토타입 체인"></a>다중 프로토타입 체인</h3><p>자바스크립트의 기본 내장 데이터 타입들은 모두 프로토타입 체인 1단계(객체), 2단계(나머지)로 끝나는 경우가 있지만 <strong>사용자가 새롭게 만드는 경우 계속해서 단계를 추가할 수 있습니다.</strong></p>
<p><code>__proto__</code>를 연결하는 방법은 <code>__proto__</code>가 가리키는 대상을<br>생성자 함수의 <code>prototype</code>이 연결하고자 하는 상위 생성자 함수의 <code>instance</code>를 지정해 주면됩니다.</p>
<figure class="highlight js"><figcaption><span>다중 프로토타입 체인</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Grade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>[i] = args[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.length = args.length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Grade(<span class="number">100</span>, <span class="number">80</span>);</span><br><span class="line">Grade.prototype = [];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Grade</code>의 <code>instance</code>는 여러개의 인자를 받아 각 순서대로 인덱싱해서 저장합니다. (<code>유사배열객체</code>)</li>
</ul>
<ul>
<li><code>변수 g</code> 가 <code>Grade</code>의 <code>instance</code>를 바라봅니다.</li>
</ul>
<ul>
<li><code>유사배열객체</code>지만 <strong>배열 메서드를 직접 호출할 수 있게</strong> 만들고자 합니다.</li>
</ul>
<ul>
<li><code>g.__proto__</code> 즉, <code>Grade.prototype</code>이 배열의 <code>instance</code>를 바라보게 해주면 됩니다.<br><code>Grade.prototype = [];</code></li>
</ul>
<ul>
<li><code>Grade</code>의 <code>instance</code>인 <code>g</code>에서 직접 배열 메서드를 사용할수 있게됩니다.</li>
</ul>
<p><code>g</code>의 <code>instance</code>는 프로토타입 체인을 따라 <code>Grade.prototype</code>, <code>Array.prototype</code>, <code>Object.prototype</code>에 접근할 수 있는 <strong>3단계 다중프로토타입 체인 형식</strong>입니다.</p>
<hr>
<h2 id="point">정리</h2>

<ul>
<li><code>__proto__</code>는 생략 가능한 속성이므로 <code>instance</code>에서 상위 객체의 <code>prototype</code>에 있는 메서드를 직접호출할 수 있습니다.</li>
</ul>
<ul>
<li><code>Constructor</code> <strong>프로퍼티는 생성자 함수 자기 자신을 가리킵니다.</strong><br><code>instance</code>에서 <strong>자신의 생성자 함수가 무엇인지 알고자할 때 필요한 수단입니다.</strong></li>
</ul>
<ul>
<li><strong>참조형 데이터뿐 아니라 기본형 데이터도 &#95;&#95;proto&#95;&#95;에 반복적으로 접근하면 최상위 객체 <code>Object.prototype</code>에 도달하게 됩니다.</strong></li>
</ul>
<ul>
<li><code>Object.prototype</code>에는 <strong>모든 데이터 타입에서 사용할 수 있는 범용적인 메서드만 존재합니다.</strong><br><code>Object</code> 전용 메서드는 <code>Object</code> 생성자 함수에 정적(<code>static</code>)하게 담겨있습니다.</li>
</ul>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JavaScript/">JavaScript</a><a class="link-muted mr-2" rel="tag" href="/tags/prototype/">prototype</a><a class="link-muted mr-2" rel="tag" href="/tags/constructor/">constructor</a><a class="link-muted mr-2" rel="tag" href="/tags/static/">static</a><a class="link-muted mr-2" rel="tag" href="/tags/proto/">__proto__</a><a class="link-muted mr-2" rel="tag" href="/tags/Core-JavaScript/">Core JavaScript</a><a class="link-muted mr-2" rel="tag" href="/tags/instance/">instance</a><a class="link-muted mr-2" rel="tag" href="/tags/prototype-chain/">prototype chain</a><a class="link-muted mr-2" rel="tag" href="/tags/method-override/">method override</a><a class="link-muted mr-2" rel="tag" href="/tags/Object-prototype/">Object.prototype</a><a class="link-muted mr-2" rel="tag" href="/tags/prototype-%EB%8F%84%EC%8B%9D/">prototype 도식</a><a class="link-muted mr-2" rel="tag" href="/tags/Object-static-method/">Object static method</a><a class="link-muted mr-2" rel="tag" href="/tags/multiple-prototype-chain/">multiple prototype chain</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/05/11/%ED%81%B4%EB%9E%98%EC%8A%A4-Class-Core-JavaScript/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">클래스(Class) -Core JavaScript</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/05/03/%ED%81%B4%EB%A1%9C%EC%A0%80-Core-JavaScript/"><span class="level-item">클로저 -Core JavaScript</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">카탈로그</h3><ul class="menu-list"><li><a class="is-flex" href="#프로포타입의-개념-이해"><span class="mr-2">1</span><span>프로토타입의 개념 이해</span></a><ul class="menu-list"><li><a class="is-flex" href="#constructor-prototype-instance"><span class="mr-2">1.1</span><span>constructor, prototype, instance</span></a><ul class="menu-list"><li><a class="is-flex" href="#내장-built-in-생성자-함수-Array-구조"><span class="mr-2">1.1.1</span><span>내장(built-in) 생성자 함수 Array 구조</span></a></li></ul></li><li><a class="is-flex" href="#constructor-프로퍼티"><span class="mr-2">1.2</span><span>constructor 프로퍼티</span></a><ul class="menu-list"><li><a class="is-flex" href="#다양한-constructor-접근-방법"><span class="mr-2">1.2.1</span><span>다양한 constructor 접근 방법</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#prototype_chain"><span class="mr-2">2</span><span>프로토타입 체인</span></a><ul class="menu-list"><li><a class="is-flex" href="#메서드-오버라이드"><span class="mr-2">2.1</span><span>메서드 오버라이드</span></a><ul class="menu-list"><li><a class="is-flex" href="#메서드-오버라이드된-상태에서-prototype에-있는-메서드에-접근법"><span class="mr-2">2.1.1</span><span>메서드 오버라이드된 상태에서 prototype에 있는 메서드에 접근법</span></a></li></ul></li><li><a class="is-flex" href="#프로토타입-체인"><span class="mr-2">2.2</span><span>프로토타입 체인</span></a></li><li><a class="is-flex" href="#객체-전용-메서드의-예외사항"><span class="mr-2">2.3</span><span>객체 전용 메서드의 예외사항</span></a></li><li><a class="is-flex" href="#다중-프로토타입-체인"><span class="mr-2">2.4</span><span>다중 프로토타입 체인</span></a></li></ul></li><li><a class="is-flex" href="#point"><span class="mr-2">3</span><span>정리</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Core-JavaScript/"><span class="level-start"><span class="level-item">Core JavaScript</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/ECMAScript6/"><span class="level-start"><span class="level-item">ECMAScript6</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/ES11/"><span class="level-start"><span class="level-item">ES11</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/React/"><span class="level-start"><span class="level-item">React</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/VS-Code/"><span class="level-start"><span class="level-item">VS Code</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/jQuery/"><span class="level-start"><span class="level-item">jQuery</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/template.png" alt="한참치의 Study Blog" height="28"></a><p class="size-small"><span>&copy; 2020 Han Dongwon</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://hdw0903.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script async="async" src="https://sda.dveamer.com/js/csda.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(Untitled)","posts":"포스트","pages":"Pages","categories":"카테고리","tags":"태그"});
        });</script></body></html>