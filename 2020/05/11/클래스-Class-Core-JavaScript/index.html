<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="웹 개발 공부 블로그"><title>클래스(Class) -Core JavaScript - 한참치의 Study Blog</title><meta description="다른 언어의 상속 개념을 흉내 내기위해 자바스크립트 ES6에서 추가된 Class 문법(내부적으로는 프로토타입을 따름)  클래스와 인스턴스의 개념 이해 자바스크립트의 클래스 클래스 상속 기본 구현 클래스가 구체적인 데이터를 지니지 않게 하는법 constructor 복구하기 상위 클래스에 접근 수단   ES6의 클래스 및 클래스 상속 정리"><meta property="og:type" content="blog"><meta property="og:title" content="클래스(Class) -Core JavaScript"><meta property="og:url" content="https://hdw0903.github.io/2020/05/11/%ED%81%B4%EB%9E%98%EC%8A%A4-Class-Core-JavaScript/"><meta property="og:site_name" content="한참치의 Study Blog"><meta property="og:description" content="다른 언어의 상속 개념을 흉내 내기위해 자바스크립트 ES6에서 추가된 Class 문법(내부적으로는 프로토타입을 따름)  클래스와 인스턴스의 개념 이해 자바스크립트의 클래스 클래스 상속 기본 구현 클래스가 구체적인 데이터를 지니지 않게 하는법 constructor 복구하기 상위 클래스에 접근 수단   ES6의 클래스 및 클래스 상속 정리"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://hdw0903.github.io/2020/05/11/%ED%81%B4%EB%9E%98%EC%8A%A4-Class-Core-JavaScript/images/blog_logo.png"><meta property="article:published_time" content="2020-05-11T10:13:14.000Z"><meta property="article:modified_time" content="2020-06-07T09:11:49.548Z"><meta property="article:author" content="Han Dongwon"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="Class"><meta property="article:tag" content="Core JavaScript"><meta property="article:tag" content="prototype chain"><meta property="article:tag" content="코어 자바스크립트"><meta property="article:tag" content="JavaScript 상속"><meta property="article:tag" content="Class 상속"><meta property="article:tag" content="Class 와 instance"><meta property="article:tag" content="super class"><meta property="article:tag" content="sup class"><meta property="article:tag" content="빈 함수"><meta property="article:tag" content="Object.create"><meta property="article:tag" content="Object.freeze"><meta property="article:tag" content="ES5 ES6 클래스 문법 비교"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="images/blog_logo.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hdw0903.github.io/2020/05/11/%ED%81%B4%EB%9E%98%EC%8A%A4-Class-Core-JavaScript/"},"headline":"한참치의 Study Blog","image":["https://hdw0903.github.io/images/Class.png","https://hdw0903.github.io/images/superClass_subClass.jpg","https://hdw0903.github.io/images/static_member.png","https://hdw0903.github.io/images/dir_sq.png","https://hdw0903.github.io/images/Class2.png"],"datePublished":"2020-05-11T10:13:14.000Z","dateModified":"2020-06-07T09:11:49.548Z","author":{"@type":"Person","name":"Han Dongwon"},"description":"다른 언어의 상속 개념을 흉내 내기위해 자바스크립트 ES6에서 추가된 Class 문법(내부적으로는 프로토타입을 따름)  클래스와 인스턴스의 개념 이해 자바스크립트의 클래스 클래스 상속 기본 구현 클래스가 구체적인 데이터를 지니지 않게 하는법 constructor 복구하기 상위 클래스에 접근 수단   ES6의 클래스 및 클래스 상속 정리"}</script><link rel="canonical" href="https://hdw0903.github.io/2020/05/11/%ED%81%B4%EB%9E%98%EC%8A%A4-Class-Core-JavaScript/"><link rel="icon" href="/images/coffee-favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/tomorrow-night-bright.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link href="https://fonts.googleapis.com/earlyaccess/jejugothic.css" rel="stylesheet"><meta name="naver-site-verification" content="3b4f64ce6899317f220936e0013e08a5320d0b65"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-164181722-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-164181722-1');</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="alternate" href="/rss2.xml" title="한참치의 Study Blog" type="application/rss+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/template.png" alt="한참치의 Study Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub Home" href="https://github.com/hdw0903"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="카탈로그" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-10-desktop is-11-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">2020년 5월 11일 월요일 오후 7:13</span><span class="level-item"><a class="link-muted" href="/categories/Core-JavaScript/">Core JavaScript</a></span><span class="level-item">34분 읽기 (대략 5121 단어)</span></div></div><h1 class="title is-3 is-size-3-mobile">클래스(Class) -Core JavaScript</h1><div class="content"><p>다른 언어의 상속 개념을 흉내 내기위해 자바스크립트 ES6에서 추가된 <code>Class</code> 문법<br>(<strong>내부적으로는 프로토타입을 따름</strong>)</p>
<ul>
<li><a href="/2020/05/11/클래스-Class-Core-JavaScript/#Class">클래스와 인스턴스의 개념 이해</a></li>
<li><a href="/2020/05/11/클래스-Class-Core-JavaScript/#JavaScript_Class">자바스크립트의 클래스</a></li>
<li><a href="/2020/05/11/클래스-Class-Core-JavaScript/#Class_상속">클래스 상속</a><ul>
<li>기본 구현</li>
<li>클래스가 구체적인 데이터를 지니지 않게 하는법</li>
<li>constructor 복구하기</li>
<li>상위 클래스에 접근 수단</li>
</ul>
</li>
<li><a href="/2020/05/11/클래스-Class-Core-JavaScript/#ES6_Class">ES6의 클래스 및 클래스 상속</a></li>
<li><a href="/2020/05/11/클래스-Class-Core-JavaScript/#point">정리</a></li>
</ul>
<a id="more"></a>

<hr>
<h2 id="Class">클래스와 인스턴스의 개념 이해</h2>

<p>상위(<code>superior</code>), 하위(<code>subordinate</code>) 개념의 앞글자를 따서<br>상위 클래스(<code>superclass</code>), 하위 클래스(<code>subclass</code>)로 표현합니다.</p>
<p>자바스크립트를 기준으로 하위 클래스(<code>subclass</code>)를 <code>Array</code>로 생각해 본다면 상위 클래스(<code>superclass</code>)는 <code>__proto__</code>와 <code>Array.prototype</code>에 따라 <code>Object</code>가 되겠습니다.</p>
<p><img src="/images/Class.png" alt="superClass 와 subClass"></p>
<p>클래스의 속성을 지니는 실존하는 개체를 <code>instance</code>라고 합니다.<br><code>instance</code>는 <strong>“해당 클래스의 조건을 만족하는 구체적인 예시”</strong>라고 해석 할 수도 있습니다.</p>
<ul>
<li><p><code>Class</code>를 바탕으로 <code>instance</code>를 만들 때 생성된 개체가 <code>Class</code>의 속성을 지니게 됩니다.</p>
</li>
<li><p>또한 한 <code>instance</code>는 <strong>하나의 클래스만을 바탕으로 만들어 집니다.</strong><br>인스턴스가 다양한 클래스에 속할 수는 있지만 인스턴스 입장에서는 모두 ‘직계존속’클래스들 입니다.<br>결국 인스턴스를 생성할 때 호출할 수 있는 클래스는 오직 하나뿐 이기 떄문입니다.<br><img src="/images/superClass_subClass.jpg" alt="superClass subClass"><br><a href="https://coding-restaurant.tistory.com/239">도식 그림 출처: 코딩맛집</a></p>
</li>
</ul>
<hr>
<h2 id="JavaScript_Class">자바스크립트의 클래스</h2>

<p>생성자 함수 <code>Array</code>를 <code>new</code> 연산자와 함께 호출하면 <code>instance</code>가 생성됩니다. 이 때 <code>Array</code>를 일종의 <code>클래스</code>라고 하면 <code>Array</code>의 <code>prototype</code> 객체 내부 요소들이 <code>instance</code>에 <strong>‘상속’</strong>된다고 볼수 있습니다. (내부적으로는 상속이 아닌 프로토 타입 체이닝에 의한 참조 입니다.)</p>
<ul>
<li><p>한편 <code>Array</code> 내부 프로퍼티들 중 <code>prototype</code> 프로퍼티를 제외한 나머지는 <code>instance</code>에 상속되지 않습니다.</p>
</li>
<li><p><code>instance</code>가 참조하는지 여부에 따라 </p>
<ul>
<li>스태틱 맴버(<code>static member</code>) 와</li>
<li>인스턴스 맴버(<code>instance member</code>)로 나뉩니다.<br><img src="/images/static_member.png" alt="static member, instance member"></li>
</ul>
</li>
<li><p><code>prototype</code>에 있는 내부 메서드는 <code>instance</code>가 직접 호출할 수 있습니다.</p>
</li>
<li><p>반대로 <code>prototype</code>에 없는 메서드는 <code>instance</code>가 참조하지 않으므로 호출할 수 없습니다.</p>
</li>
<li><p>이렇게 <code>instance</code><strong>에서 직접 접근할 수 없는 메서드를 스태틱 메서드라고 합니다.</strong></p>
</li>
</ul>
<hr>
<h2 id="Class_상속">클래스 상속</h2>

<hr>
<h3 id="기본-구현"><a href="#기본-구현" class="headerlink" title="기본 구현"></a>기본 구현</h3><p>클래스 상속은 객체지향에서 가장 중요한 요소 중 하나입니다, 하지만 자바스크립트는 ES5까지 클래스가 없었기 때문에 프로토 타입 체인을 활용해 클래스 상속을 흉내내었었습니다.</p>
<p>이에 대해 가볍게 알아보겠습니다.</p>
<hr>
<h4 id="length-프로퍼티-삭제-가능"><a href="#length-프로퍼티-삭제-가능" class="headerlink" title="length 프로퍼티 삭제 가능"></a>length 프로퍼티 삭제 가능</h4><figure class="highlight js"><figcaption><span>length 삭제</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Grade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>[i] = args[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.length = args.length;</span><br><span class="line">&#125;;</span><br><span class="line">Grade.prototype = [];</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Grade(<span class="number">100</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">g.push(<span class="number">90</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// Grade &#123; 0: 100, 1: 80, 2: 90, length: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> g.length;</span><br><span class="line">g.push(<span class="number">70</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// Grade &#123; 0: 70, 1: 80, 2: 90, length: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>length</code>프로퍼티를 삭제하고 다시 <code>push</code> 했더니, <code>push</code>한 값이 0번째 <code>index</code>에 들어가고, <code>length</code>가 1이 됐습니다.</li>
</ul>
<ul>
<li>내장객체인 <code>배열 instance</code>의 <code>length</code> 프로퍼티는 <code>{ configurable : false }</code>라서 삭제가 불가능하지만,<br><code>Grade</code> 클래스의 <code>instance</code>는 <strong>배열 메서드를 상속(참조)하지만 기본적으로는 일반 객체의 성질을 그대로 지니므로 삭제가 가능</strong>해서 문제가 됩니다.</li>
</ul>
<hr>
<h4 id="빈-배열"><a href="#빈-배열" class="headerlink" title="빈 배열"></a>빈 배열</h4><ul>
<li><code>push</code>했을 때 0번째 <code>index</code>에 70이 들어가고 <code>length</code>가 1이 된 이유:<br><code>g.__proto__</code>, 즉 <code>Grade.prototype</code>이 <strong>빈 배열을 가리키고 있기 때문</strong></li>
</ul>
<ul>
<li><code>push</code> 명령에 의해 엔진이 <code>g.length</code>를 읽으려 하는데 <code>g.length</code>가 <strong>존재하지 않으므로 프로토 타입 체이닝을 타고</strong> <code>g.__proto__.length</code>을 읽어옴.</li>
</ul>
<ul>
<li>빈 배열의 <code>length</code>는 0 이므로 여기에 값을 할당하고 <code>length</code>는 1 만큼 증가합니다.</li>
</ul>
<hr>
<h4 id="요소가-있는-배열을-prototype에-매칭한-경우"><a href="#요소가-있는-배열을-prototype에-매칭한-경우" class="headerlink" title="요소가 있는 배열을 prototype에 매칭한 경우"></a>요소가 있는 배열을 prototype에 매칭한 경우</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Grade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>[i] = args[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.length = args.length;</span><br><span class="line">&#125;;</span><br><span class="line">Grade.prototype = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]; <span class="comment">// 빈 배열 아님</span></span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Grade(<span class="number">100</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">g.push(<span class="number">90</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// Grade &#123; 0: 100, 1: 80, 2: 90, length: 3 &#125;</span></span><br><span class="line"><span class="comment">// length 삭제 후</span></span><br><span class="line"><span class="keyword">delete</span> g.length;</span><br><span class="line">g.push(<span class="number">70</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// Grade &#123; 0: 100, 1: 80, 2: 90, ___ 4: 70, length: 5 &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Grade.prototype</code>에 빈 배열이 아닌 <code>length</code>가 4인 배열을 할당했습니다.</li>
</ul>
<ul>
<li><code>length</code>를 삭제 후 <code>push</code>한 값이 <code>Grade.prototype</code>에 빈 배열을 할당했을 때와는 다르게 동작합니다.</li>
</ul>
<ul>
<li><code>push</code>명령에 의해 엔진이 <code>g.length</code>를 읽으려 하는데 존재하지 않으므로 <code>g.__proto__.length</code>를 읽어오는데 <code>length</code>값이 4인 배열입니다.</li>
</ul>
<ul>
<li>그러므로 여기에 (<code>index : 4</code>) 70값을 할당하고 <code>length</code> 값을 1증가시켜 5가 되는것 입니다.</li>
</ul>
<p><strong>이처럼 <code>class</code>에 있는 값이 <code>instance</code>의 동작에 영향을 줘서는 안됩니다.</strong>(이런 영향을 줄 수 있다는 것 자체가 이미 클래스의 추상성을 해치는 것입니다.)</p>
<p><code>class</code>는 <code>instance</code>와의 관계에서는 <strong>구체적인 데이터를 지니지 않고</strong> 오직 <code>instance</code>가 <strong>사용할 메서드만을 지니는 추상적인 틀</strong>로만 작용해야 합니다.</p>
<hr>
<h4 id="사용자가-정의한-두-클래스-사이에서의-상속관계-구현"><a href="#사용자가-정의한-두-클래스-사이에서의-상속관계-구현" class="headerlink" title="사용자가 정의한 두 클래스 사이에서의 상속관계 구현"></a>사용자가 정의한 두 클래스 사이에서의 상속관계 구현</h4><p>직사각형 클래스와 정사각형 클래스를 만듭니다.</p>
<ul>
<li><p>직사각형: 두 쌍의 마주 보는 변이 평행이고 그 길이가 같습니다.</p>
</li>
<li><p>정사각형: 직사각형이며(직사각형의 조건을 충족) 네 변의 길이가 모두 같습니다.</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rect.getArea()); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Square = <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">&#125;;</span><br><span class="line">Square.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.width;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> sq = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sq.getArea()); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Rectangle</code>과 <code>Square</code>클래스에 공통 요소가 보입니다. <code>width</code> 프로퍼티가 공통이고, <code>getArea</code>메서드는 다른 부분이 있으나 비슷합니다.</li>
</ul>
<ul>
<li><code>Square</code>에서 <code>width</code>프로퍼티만 쓰지 않고 <code>height</code>프로퍼티에 <code>width</code>값을 부여하는 형태로 변경한다면 <code>getArea</code>도 동일하게 쓸 수 있겠습니다.</li>
</ul>
<figure class="highlight js"><figcaption><span>Square 수정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Square = <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = width;</span><br><span class="line">&#125;;</span><br><span class="line">Square.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Square</code>를 위와같이 수정해 주면 <code>Square</code>를 <code>Rectangle</code>의 하위 클래스로 삼을 수 있습니다.</li>
</ul>
<ul>
<li><code>getArea</code> 메서드는 동일한 동작을 하므로 <strong>상위 클래스에서만 정의하고, 하위 클래스에서는 해당 메서드를 상속</strong>하면서 <code>height</code> 대신 <code>width</code>를 넣어주면 되겠습니다.</li>
</ul>
<figure class="highlight js"><figcaption><span>Rectangle을 상속하는 Square 클래스</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Square = <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  Rectangle.call(<span class="keyword">this</span>, width, width);</span><br><span class="line">&#125;;</span><br><span class="line">Square.prototype = <span class="keyword">new</span> Rectangle();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Square</code> 생성자 함수 내부에서 <code>Rectangle</code> 생성자 함수를 함수로 호출하고 <strong>인자 height 자리에 width를 전달합니다.</strong></li>
</ul>
<ul>
<li><code>Square.prototype = new Rectangle();</code>  : 메서드를 상속하기 위해 프로토타입 객체에 <code>Rectangle</code>의 <code>instance</code>를 부여했습니다.</li>
</ul>
<p>하지만 위 코드만으로 <strong>완벽한 클래스 체계가 구축됐다고 볼 수는 없습니다.</strong></p>
<p><strong>아직 클래스에 있는 값이 인스턴스에 영향을 줄 수 있는 구조이기 때문입니다.</strong></p>
<ul>
<li><code>console.dir(sq);</code>로 sq <code>instance</code>에 대하여 콘솔로 출력해보면<br><img src="/images/dir_sq.png" alt="console.dir(sq);"><br>첫 줄에서 <code>Square</code>의 <code>instance</code>을 표시하고 있고 <code>width</code>와 <code>height</code>에 5가 잘 들어있습니다. <code>__proto__</code>는 <code>Rectangle</code>의 <code>instance</code>임을 표시하고 이어서 <code>width</code>, <code>height</code>에 모두 <code>undefined</code>가 할당되어 있습니다. <code>Square.prototype</code>에 값이 존재하여 이후에 임의로 <code>Square.prototype.width (또는 height)</code>에 값을 부여하고 <code>sq.width(또는 height)</code>의 값을 지워버린다면 프로토타입 체이닝에 의해 엉뚱한 결과가 나오는 문제가 생길 수 있습니다.</li>
</ul>
<p><img src="/images/Square%EB%8F%84%EC%8B%9D.jfif" alt="Rectangle -&gt; Square 상속 관계 구현 도식"><br><a href="https://coding-restaurant.tistory.com/239">도식 그림 출처: 코딩맛집</a></p>
<p>나아가 <code>constructor</code>가 여전히 <code>Rectangle</code>을 바라보고 있는 문제도 있습니다. <code>sq.constructor</code>로 접근하면 프로토타입 체이닝을 따라 <code>sq.__proto__.__proto__,</code> 즉 <code>Rectangle.prototype</code>에서 찾게 되며 이는 <code>Rectangle</code>을 가리키고 있기 때문입니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect2 = <span class="keyword">new</span> sq.constructor(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rect2); <span class="comment">// Rectangle &#123;width: 2, height: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>이처럼 하위 클래스로 삼을 생성자 함수의 <code>prototype</code> 에 상위 클래스의 <code>instance</code>를 부여하는 것만으로도 기본적 메서드 상속은 가능하지만 다양한 문제가 발생할 여지가 있어 구조적 안정성이 떨어집니다.</p>
<hr>
<h3 id="클래스가-구체적인-데이터를-지니지-않게-하는법"><a href="#클래스가-구체적인-데이터를-지니지-않게-하는법" class="headerlink" title="클래스가 구체적인 데이터를 지니지 않게 하는법"></a>클래스가 구체적인 데이터를 지니지 않게 하는법</h3><p>클래스 (prototype)가 구체적인 데이터를 지니지 않게 하는 방법 중<br>가장 쉬운 방법은 일단 만들고 나서 프로퍼티들을 일일히 지우고 더는 <strong>새로운 프로퍼티를 추가할 수 없게 하는 것</strong>입니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> Square.prototype.width; </span><br><span class="line"><span class="keyword">delete</span> Square.prototype.height; </span><br><span class="line"><span class="built_in">Object</span>.freeze(Square.prototype);</span><br></pre></td></tr></table></figure>

<p>프로퍼티가 많다면 반복 작업이 될테니 반복을 없애고 좀 더 범용적으로 이런 동작을 하는 함수를 만들면 좋겠습니다.</p>
<figure class="highlight js"><figcaption><span>인스턴스 생성 후 프로퍼티 제거</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass1 = <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">  SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> SubClass.prototype) &#123;</span><br><span class="line">    <span class="keyword">if</span> (SubClass.prototype.hasOwnProperty(prop)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> SubClass.prototype[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">      SubClass.prototype[method] = subMethods[method];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">  <span class="keyword">return</span> SubClass;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Square = extendClass1(Rectangle, <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  Rectangle.call(<span class="keyword">this</span>, width, width);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> sq = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sq.getArea()); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>extendClass1</code> 함수는 <code>SuperClass</code>와 <code>SubClass</code>, <code>SubClass</code>에 추가할 메서드들이 정의된 객체를 받아 <code>SubClass</code>의 <code>prototype</code> 내용을 정리하고 <code>freeze</code>하는 내용으로 구성돼있습니다.</li>
</ul>
<hr>
<h4 id="두-번째-방법-빈-함수"><a href="#두-번째-방법-빈-함수" class="headerlink" title="두 번째 방법(빈 함수)"></a>두 번째 방법(빈 함수)</h4><p>더글라스 크락포드가 제시하여 대중적으로 알려진 방법입니다.<br><code>SubClass</code>의 <code>prototype</code>에 직접 <code>SubClass</code>의 <code>instance</code>를 할당하는 대신</p>
<p><strong>아무런 프로퍼티를 생성하지 않는 빈 생성자 함수(<code>Bridge</code>)를 하나 더 만들어서</strong> 그 <code>prototype</code>이 <code>SubClass</code>의 <code>prototype</code>을 바라보게 한 다음,<code>SubClass</code>의 <code>prototype</code>에는 <code>Bridge</code>의 <code>instance</code>를 할당하게 하는 것입니다.<br>(<strong>빈 함수에 다리 역활을 부여</strong>)</p>
<p><img src="/images/Class2.png" alt="클래스 상속 및 추상화 방법(2)- 빈 함수 활용"></p>
<ul>
<li><code>Bridge</code>라는 빈 함수를 만들고, <code>Bridge.prototype</code>이 <code>Rectangle.prototype</code>을 참조하게 한 다음, <code>Square.prototype</code>에 <code>new Bridge()</code>로 할당하면, 우측 그림처럼 <code>Rectangle</code> 자리에 <code>Bridge</code>가 대체됩니다.</li>
</ul>
<ul>
<li>이로써 <code>instance</code>를 제외한 <strong>프로토타입 체인 경로상에는 더는 구체적인 데이터가 남아있지 않게 됩니다</strong>.</li>
</ul>
<p>마찬가지로 반복작업을 없애기 위해 범용적으로 이런 동작을 하는 함수를 만들어 보겠습니다.</p>
<figure class="highlight js"><figcaption><span>빈 함수를 활용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass2 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Bridge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">    Bridge.prototype = SuperClass.prototype;</span><br><span class="line">    SubClass.prototype = <span class="keyword">new</span> Bridge();</span><br><span class="line">    <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">        SubClass.prototype[method] = subMethods[method];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">    <span class="keyword">return</span> SubClass;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Square = extendClass2(Rectangle, <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  Rectangle.call(<span class="keyword">this</span>, width, width);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> sq = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sq.getArea()); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>즉시실행함수 내부에서 <code>Bridge</code>를 선언하여 이를 클로저로 활용함으로써 메모리에 불필요한 함수 선언을 줄였습니다.</p>
</li>
<li><p><code>subMethods</code>에는 <code>SubClass</code>의 <code>prototype</code>이 담길 메서드들을 객체로 전달하게 했습니다.</p>
</li>
</ul>
<hr>
<h4 id="세-번째-방법-Object-create"><a href="#세-번째-방법-Object-create" class="headerlink" title="세 번째 방법(Object.create)"></a>세 번째 방법(Object.create)</h4><p>세 번째 방법은 ES5에서 도입된 <code>Object.create</code>를 이용한 방법으로 이 방법은</p>
<p><code>SubClass</code>의 <code>prototype</code>의 <code>__proto__</code>가 <code>SuperClass</code>의 <code>prototype</code>을 바라보되, <code>SuperClass</code>의 <code>instance</code>가 되지는 않으므로 앞서 소개한 두 방법보다 간편하면서 안전합니다.</p>
<figure class="highlight js"><figcaption><span>Object.create 활용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Square = <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">  Rectangle.call(<span class="keyword">this</span>, width, width);</span><br><span class="line">&#125;;</span><br><span class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype);</span><br><span class="line"><span class="built_in">Object</span>.freeze(Square.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sq = <span class="keyword">new</span> Square(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sq.getArea()); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<p><del>클래스 상속 및 추상화를 흉내 내기 위한 라이브러리가 많이 있지만 기본적인 접근 방법은 위 세가지 아이디어를 크게 벗어나지 않습니다.</del></p>
<p>결론적으로 <code>SubClass.prototype</code>의 <code>__proto__</code>가 <code>SuperClass.prototype</code>을 참조하고, <code>SubClass.prototype</code>에는 불필요한 <code>instance 프로퍼티</code>가 남아있으면 안되기 때문입니다.</p>
<hr>
<h3 id="constructor-복구하기"><a href="#constructor-복구하기" class="headerlink" title="constructor 복구하기"></a>constructor 복구하기</h3><p>위 세 가지 방법 모두 기본적인 상속에는 성공했지만, <code>SubClass</code> <code>instance</code>의 <code>constructor</code>는 여전히 <code>Superclass</code>를 가리키는 상태입니다.</p>
<ul>
<li>엄밀히는 <code>SubClass</code>의 <code>instance</code>에는 <code>constructor</code>가 없고, <code>SubClass.prototype</code>에도 없는 상태입니다.</li>
</ul>
<ul>
<li>프로토타입 체인상에 가장 먼저 등장하는 <code>SuperClass.prototype</code>의 <code>constructor</code>가 가리키는 대상인 <code>SuperClass</code>가 출력되는 것입니다.</li>
</ul>
<p>따라서 <code>SubClass.prototype.constructor</code>가 원래의 <code>SubClass</code>를 바라보도록 해주겠습니다.</p>
<figure class="highlight js"><figcaption><span>인스턴스 생성 후 프로퍼티 제거 + constructor 복구</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass1 = <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">  SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> SubClass.prototype) &#123;</span><br><span class="line">    <span class="keyword">if</span> (SubClass.prototype.hasOwnProperty(prop)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> SubClass.prototype[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//SubClass.prototype.constructor가 원래의 SubClass를 바라보도록 함</span></span><br><span class="line">  SubClass.prototype.consturctor = SubClass;</span><br><span class="line">  <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">      SubClass.prototype[method] = subMethods[method];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">  <span class="keyword">return</span> SubClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><figcaption><span>빈 함수 활용 + constructor 복구</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass2 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Bridge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">    Bridge.prototype = SuperClass.prototype;</span><br><span class="line">    SubClass.prototype = <span class="keyword">new</span> Bridge();</span><br><span class="line">    SubClass.prototype.consturctor = SubClass;</span><br><span class="line">    <span class="comment">//SuperClass와의 관계를 복구하기 위해</span></span><br><span class="line">    <span class="comment">//Bridge.prototype.constructor가 SuperClass를 바라보게 하는 작업 추가</span></span><br><span class="line">    Bridge.prototype.constructor = SuperClass;</span><br><span class="line">    <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">        SubClass.prototype[method] = subMethods[method];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">    <span class="keyword">return</span> SubClass;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>빈 함수(<code>Bridge</code>)를 이용한 두 번째 방법의 경우 <code>SubClass.prototype</code>이 <code>SuperClass</code> 대신 <code>Bridge</code>의 <code>instance</code>를 바라보는 상태이므로 <code>SuperClass</code>와의 관계를 복구하기 위해 <code>Bridge.prototype.constructor</code>가 <code>SuperClass</code>를 바라보게 하는 작업이 추가돼야 합니다. </p>
<figure class="highlight js"><figcaption><span>Object.create 활용 + constructor 복구</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass3 = <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">  SubClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line">  <span class="comment">//SubClass.prototype.constructor가 원래의 SubClass를 바라보도록 함</span></span><br><span class="line">  SubClass.prototype.constructor = SubClass;</span><br><span class="line">  <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">      SubClass.prototype[method] = subMethods[method];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">  <span class="keyword">return</span> SubClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="상위-클래스에-접근-수단"><a href="#상위-클래스에-접근-수단" class="headerlink" title="상위 클래스에 접근 수단"></a>상위 클래스에 접근 수단</h3><p>하위 클래스의 메서드에서 <strong>상위 클래스의 메서드 실행 결과를 바탕으로 추가적인 작업을 수행하고 싶을 때</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass.prototype.method.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure>
<p>매번 이런식으로 코드를 추가해서 해결하는 것은 상당히 번거롭고 가독성이 떨어지는 방식입니다.</p>
<p>하위 클래스에서 <strong>상위 클래스의 프로토타입 메서드에 접근하기 위한 별도의 수단</strong>이 있다면 편리할 것 같습니다.</p>
<p>이런 <strong>별도의 수단</strong>인 다른 객체지향 언어들의 클래스 문법 중 하나인 <code>super</code>를 흉내 내보겠습니다.</p>
<figure class="highlight js"><figcaption><span>상위 클래스 접근 수단 super 메서드 추가</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendClass = <span class="function"><span class="keyword">function</span>(<span class="params">SuperClass, SubClass, subMethods</span>) </span>&#123;</span><br><span class="line">  SubClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line">  SubClass.prototype.constructor = SubClass;</span><br><span class="line">  SubClass.prototype.super = <span class="function"><span class="keyword">function</span>(<span class="params">propName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 추가된 부분 시작</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!propName) <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//인자가 비어있을 경우 </span></span><br><span class="line">        SuperClass.apply(self, <span class="built_in">arguments</span>);<span class="comment">// SuperClass 생성자 함수에 접근하는 것으로 간주</span></span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">var</span> prop = SuperClass.prototype[propName]; <span class="comment">//SuperClass.prototype 내부의 propName에 해당하는 값이     </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> prop !== <span class="string">'function'</span>) <span class="keyword">return</span> prop;<span class="comment">//함수가 아닌 경우 해당값을 그대로 반환합니다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//함수인 경우</span></span><br><span class="line">      <span class="keyword">return</span> prop.apply(self, <span class="built_in">arguments</span>); <span class="comment">//메서드에 접근하는 것으로 여김</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;; <span class="comment">// 추가된 부분 끝</span></span><br><span class="line">  <span class="keyword">if</span> (subMethods) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> subMethods) &#123;</span><br><span class="line">      SubClass.prototype[method] = subMethods[method];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(SubClass.prototype);</span><br><span class="line">  <span class="keyword">return</span> SubClass;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Square = extendClass(Rectangle, <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.super()(width, width); <span class="comment">// super 사용 (1)</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    getArea: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'size is :'</span>, <span class="keyword">this</span>.super(<span class="string">'getArea'</span>)()); <span class="comment">// super 사용 (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> sq = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line">sq.getArea(); <span class="comment">// size is : 100</span></span><br><span class="line"><span class="built_in">console</span>.log(sq.super(<span class="string">'getArea'</span>)()); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<ul>
<li>추가된 부분에서 <code>super</code> 메서드의 동작을 정의하고 있습니다.</li>
</ul>
<ul>
<li>7번째 줄에서 인자가 비어있을 경우 <code>SuperClass</code> 생성자 함수에 접근하는 것으로 간주했습니다.</li>
</ul>
<ul>
<li><code>this</code>가 달라지는 것을 막기 위해 클로저를 활용했습니다.</li>
</ul>
<ul>
<li>11번째 줄은 <code>SuperClass</code>의 <code>prototype</code> 내부의 <code>propName</code>에 해당하는 값이 함수가 아닌 경우 해당값을 그대로 반환합니다.</li>
</ul>
<ul>
<li>12번째 줄은 함수인 경우이므로 마찬가지로 클로저를 활용해 메서드에 접근하는 것으로 여기도록 했습니다.</li>
</ul>
<p>이제 <code>SuperClass</code>의 <strong>생성자 함수에 접근하고자 할 때는</strong> <code>this.super()</code>, <code>SuperClass</code>의 <strong>프로토타입 메서드에 접근하고자 할 때는</strong> <code>this.super(propName)</code>과 같이 사용할 수 있습니다.</p>
<hr>
<h2 id="ES6_Class">ES6의 클래스 및 클래스 상속</h2>

<ul>
<li><p><code>ES6</code>에서는 본격적으로 클래스 문법이 도입됐습니다.</p>
</li>
<li><p><code>ES5</code>에서의 생성자 함수 및 프로토타입 과 <code>ES6</code>의 클래스 문법을 비교해봅니다.</p>
</li>
</ul>
<hr>
<h4 id="ES5-ES6-클래스-문법-비교"><a href="#ES5-ES6-클래스-문법-비교" class="headerlink" title="ES5 / ES6 클래스 문법 비교"></a>ES5 / ES6 클래스 문법 비교</h4><figure class="highlight js"><figcaption><span>ES5와 ES6 클래스 문법 비교</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ES5 = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">ES5.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' staticMethod'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">ES5.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' method'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> es5Instance = <span class="keyword">new</span> ES5(<span class="string">'es5'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ES5.staticMethod()); <span class="comment">// es5 staticMethod</span></span><br><span class="line"><span class="built_in">console</span>.log(es5Instance.method()); <span class="comment">// es5 method</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ES6 = <span class="class"><span class="keyword">class</span> </span>&#123; <span class="comment">//중괄호 &#123;&#125;내부가 클래스 본문 영역입니다.</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123; <span class="comment">//클래스 본문에서는 'function'키워드를 생략하더라도</span></span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">//모두 메서드로 인식합니다.</span></span><br><span class="line">  &#125; <span class="comment">//메서드와 다음 메서드 사이에는 콤마(,)로 구분하지 않습니다.</span></span><br><span class="line">  <span class="keyword">static</span> staticMethod() &#123; <span class="comment">//static 키워드는 해당 메서드가 static 메서드라는 뜻입니다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' staticMethod'</span>; <span class="comment">//ES5의 생성자 함수에 바로 할당하는 메서드와 동일하게</span></span><br><span class="line">  &#125;                                     <span class="comment">//생성자 함수(클래스) 자신만이 호출할 수 있습니다.</span></span><br><span class="line">  method() &#123; <span class="comment">//method는 자동으로 prototype 객체 내부에 할당되는 메서드입니다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' method'</span>;<span class="comment">//ES5.prototype.method와 동일하게, </span></span><br><span class="line">  &#125; <span class="comment">//instance가 프로토타입 체이닝을 통해 자신의 것처럼 직접 호출가능합니다.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> es6Instance = <span class="keyword">new</span> ES6(<span class="string">'es6'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ES6.staticMethod()); <span class="comment">// es6 staticMethod</span></span><br><span class="line"><span class="built_in">console</span>.log(es6Instance.method()); <span class="comment">// es6 method</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="ES6의-클래스-상속"><a href="#ES6의-클래스-상속" class="headerlink" title="ES6의 클래스 상속"></a>ES6의 클래스 상속</h4><figure class="highlight js"><figcaption><span>ES6의 클래스 상속</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Rectangle = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(width, height) &#123;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Square = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(width) &#123;</span><br><span class="line">    <span class="keyword">super</span>(width, width);</span><br><span class="line">  &#125;</span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'size is :'</span>, <span class="keyword">super</span>.getArea());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Square</code>를 <code>Rectangle</code> 클래스를 상속받게 하기위해 <code>class</code>명렁어 뒤에 <code>extends Rectangle</code>을 추가합니다.<br>이것으로 상속 관계 설정이 완료됩니다.</li>
</ul>
<ul>
<li><code>constructor</code> 내부에서는 <code>super</code>라는 키워드를 함수처럼 사용할 수 있습니다. 이 함수는 <code>SuperClass</code>의 <code>constructor</code>를 실행합니다.</li>
</ul>
<ul>
<li><code>constructor</code> 메서드를 제외한 다른 메서드에서는 <code>super</code>키워드를 마치 객체처럼 사용할 수 있고, 이때 객체는 <code>SuperClass.prototype</code>을 바라보는데, <strong>호출한 메서드의 <code>this</code>는 <code>super</code>가 아닌 원래의 <code>this</code>를 그대로 따릅니다.</strong></li>
</ul>
<p><a href="https://hdw0903.github.io/2020/04/01/Class%20%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%20-ECMAScript/">ES6의 Class 오브젝트 더 자세히 알아보기</a></p>
<hr>
<h2 id="point">정리</h2>

<ul>
<li>클래스는 어떤 사물의 공통 속성을 모아 정의한 추상적인 개념, <code>instance</code>는 클래스의 속성을 갖는 구체적인 사례<br>상위 클래스(<code>SuperClass</code>)의 조건을 충족하면서 더욱 구체적인 조건이 추가된 것을 하위 클래스(<code>SubClass</code>)라고 함.</li>
</ul>
<ul>
<li>클래스의 <code>prototype</code> 내부에 정의된 메서드를 <code>프로토타입 메서드</code>라고 하며, 이들은 <code>instance</code>가 마치 자신의 것처럼 호출할 수 있습니다.</li>
</ul>
<ul>
<li>클래스(생성자 함수)에 직접 정의한 메서드를 <code>스태틱 메서드</code>라고 하며, 이들은 <code>instance</code>가 직접 호출할 수 없고 클래스(생성자 함수)에 의해서만 호출할 수 있음.</li>
</ul>
<ul>
<li><p>클래스 상속을 흉내 내기 위한 세 가지 방법</p>
<ul>
<li><p><code>SubClass.prototype</code>에 <code>Superclass</code>의 <code>instance</code>를 할당하고 프로퍼티를 모두 삭제하는 방법.</p>
</li>
<li><p>빈 함수(<code>Bridge</code>)를 할용하는 방법</p>
</li>
<li><p>Object.create를 이용하는 방법</p>
</li>
</ul>
<p><strong>세 방법 모두 <code>constructor</code> 프로퍼티가 원래의 생성자 함수를 바라보도록 조정해 줘야함</strong> </p>
</li>
</ul>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JavaScript/">JavaScript</a><a class="link-muted mr-2" rel="tag" href="/tags/Class/">Class</a><a class="link-muted mr-2" rel="tag" href="/tags/Core-JavaScript/">Core JavaScript</a><a class="link-muted mr-2" rel="tag" href="/tags/prototype-chain/">prototype chain</a><a class="link-muted mr-2" rel="tag" href="/tags/%EC%BD%94%EC%96%B4-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">코어 자바스크립트</a><a class="link-muted mr-2" rel="tag" href="/tags/JavaScript-%EC%83%81%EC%86%8D/">JavaScript 상속</a><a class="link-muted mr-2" rel="tag" href="/tags/Class-%EC%83%81%EC%86%8D/">Class 상속</a><a class="link-muted mr-2" rel="tag" href="/tags/Class-%EC%99%80-instance/">Class 와 instance</a><a class="link-muted mr-2" rel="tag" href="/tags/super-class/">super class</a><a class="link-muted mr-2" rel="tag" href="/tags/sup-class/">sup class</a><a class="link-muted mr-2" rel="tag" href="/tags/%EB%B9%88-%ED%95%A8%EC%88%98/">빈 함수</a><a class="link-muted mr-2" rel="tag" href="/tags/Object-create/">Object.create</a><a class="link-muted mr-2" rel="tag" href="/tags/Object-freeze/">Object.freeze</a><a class="link-muted mr-2" rel="tag" href="/tags/ES5-ES6-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%AC%B8%EB%B2%95-%EB%B9%84%EA%B5%90/">ES5 ES6 클래스 문법 비교</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/05/19/Array-prototype-map-filter-reduce-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Array.prototype. map, filter, reduce 구현하기</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/05/05/prototype-Core-JavaScript/"><span class="level-item">prototype -Core JavaScript</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">카탈로그</h3><ul class="menu-list"><li><a class="is-flex" href="#Class"><span class="mr-2">1</span><span>클래스와 인스턴스의 개념 이해</span></a></li><li><a class="is-flex" href="#JavaScript_Class"><span class="mr-2">2</span><span>자바스크립트의 클래스</span></a></li><li><a class="is-flex" href="#Class_상속"><span class="mr-2">3</span><span>클래스 상속</span></a><ul class="menu-list"><li><a class="is-flex" href="#기본-구현"><span class="mr-2">3.1</span><span>기본 구현</span></a><ul class="menu-list"><li><a class="is-flex" href="#length-프로퍼티-삭제-가능"><span class="mr-2">3.1.1</span><span>length 프로퍼티 삭제 가능</span></a></li><li><a class="is-flex" href="#빈-배열"><span class="mr-2">3.1.2</span><span>빈 배열</span></a></li><li><a class="is-flex" href="#요소가-있는-배열을-prototype에-매칭한-경우"><span class="mr-2">3.1.3</span><span>요소가 있는 배열을 prototype에 매칭한 경우</span></a></li><li><a class="is-flex" href="#사용자가-정의한-두-클래스-사이에서의-상속관계-구현"><span class="mr-2">3.1.4</span><span>사용자가 정의한 두 클래스 사이에서의 상속관계 구현</span></a></li></ul></li><li><a class="is-flex" href="#클래스가-구체적인-데이터를-지니지-않게-하는법"><span class="mr-2">3.2</span><span>클래스가 구체적인 데이터를 지니지 않게 하는법</span></a><ul class="menu-list"><li><a class="is-flex" href="#두-번째-방법-빈-함수"><span class="mr-2">3.2.1</span><span>두 번째 방법(빈 함수)</span></a></li><li><a class="is-flex" href="#세-번째-방법-Object-create"><span class="mr-2">3.2.2</span><span>세 번째 방법(Object.create)</span></a></li></ul></li><li><a class="is-flex" href="#constructor-복구하기"><span class="mr-2">3.3</span><span>constructor 복구하기</span></a></li><li><a class="is-flex" href="#상위-클래스에-접근-수단"><span class="mr-2">3.4</span><span>상위 클래스에 접근 수단</span></a></li></ul></li><li><a class="is-flex" href="#ES6_Class"><span class="mr-2">4</span><span>ES6의 클래스 및 클래스 상속</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex" href="#ES5-ES6-클래스-문법-비교"><span class="mr-2">4.1.1</span><span>ES5 / ES6 클래스 문법 비교</span></a></li><li><a class="is-flex" href="#ES6의-클래스-상속"><span class="mr-2">4.1.2</span><span>ES6의 클래스 상속</span></a></li></ul></ul></li><li><a class="is-flex" href="#point"><span class="mr-2">5</span><span>정리</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Core-JavaScript/"><span class="level-start"><span class="level-item">Core JavaScript</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/ECMAScript6/"><span class="level-start"><span class="level-item">ECMAScript6</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/React/"><span class="level-start"><span class="level-item">React</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/VS-Code/"><span class="level-start"><span class="level-item">VS Code</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/jQuery/"><span class="level-start"><span class="level-item">jQuery</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="coupangadsbydveamer" style="display:block;" data-csda-ltag="AF3437698" data-csda-categories="178255" data-csda-size="auto"></div><div class="coupangadsbydveamer" style="display:block;" data-csda-ltag="AF3437698" data-csda-categories="194276" data-csda-size="auto"></div><div class="coupangadsbydveamer" style="display:block;" data-csda-ltag="AF3437698" data-csda-categories="000000" data-csda-size="auto"></div></div></div></div></section><footer class="footer"><div class="container"><div class="coupangadsbydveamer" style="display:block;" data-csda-ltag="AF3437698" data-csda-categories="178255,194276,000000" data-csda-size="auto"></div><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/template.png" alt="한참치의 Study Blog" height="28"></a><p class="size-small"><span>&copy; 2020 Han Dongwon</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://hdw0903.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script async="async" src="https://sda.dveamer.com/js/csda.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(Untitled)","posts":"포스트","pages":"Pages","categories":"카테고리","tags":"태그"});
        });</script></body></html>