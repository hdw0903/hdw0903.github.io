<div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-03-16T04:13:42.000Z" title="2020-03-16T04:13:42.000Z">2020-03-16</time><span class="level-item"><a class="link-muted" href="/categories/ECMAScript6/">ECMAScript6</a></span><span class="level-item">15분 읽기 (대략 2200 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile">키워드, 블록 스코프 -ECMAScript</h1><div class="content"><h2 id="글로벌-변수-오해"><a href="#글로벌-변수-오해" class="headerlink" title="글로벌 변수 오해"></a>글로벌 변수 오해</h2><hr>
<p>글로벌 오브젝트에 작성한 변수는 <strong>글로벌 오브젝트가 스코프</strong>입니다.<br>글로벌 오브젝트에 작성하여 글로벌 변수라고 부르는 것이지,<br><strong>글로벌 오브젝트에서 보면 로컬 변수입니다.</strong></p>
<p>var 키워드를 작성하지 않으면 글로벌 변수로 간주한다는 점으로 인해<br>var키워드를 작성하지 않을 뿐이지 글로벌 변수는 var 키워드를 사용하지 않는다는것이 아닙니다.</p>
<p>글로벌 변수도 var 키워드를 사용하여</p>
<blockquote>
<p>var global = “”;</p>
</blockquote>
<p>형식으로 작성하는 것이 정확한 작성법입니다.</p>
<p>글로벌 변수는 객체지향 관점에서 보면 단점이라고 할 수 있습니다.<br>function 안에서 글로벌 오브젝트에 작성된 글로벌 변수를 사용할 수는 있지만,<br>다른 프로그램에서 글로벌 변수 값을 변경 하거나 재사용 할 수도 있는<br>위험이 있습니다.<br>이러한 경우는 자칫 오류를 만들게 되어 객체 지향 기본에서 어긋나는 행동입니다.</p>
<a id="more"></a>

<hr>
<h2 id="let-키워드"><a href="#let-키워드" class="headerlink" title="let 키워드"></a>let 키워드</h2><hr>
<p>let 키워드 변수 선언 형태</p>
<blockquote>
<p>let sports = “축구”;</p>
</blockquote>
<p>let 키워드는 var 키워드의 문제점을 해결하기 위한 것으로<br>다음과 같은 특징이 있습니다.</p>
<ol>
<li>함수 안에 작성한 let 변수는 함수가 스코프 입니다.</li>
<li>함수 안에 if(a=b) {let sports = “축구”} 형태의 코드를 작성했을 때,<br>sports 변수는 함수가 스코프가 아니라 if문의 블록{}이 스코프입니다.</li>
<li>블록{} 밖에 같은 이름의 변수가 있어도 스코프가 다르므로 변수 각각에 값을 설정할 수 있고 그 변수 값이 유지됩니다.</li>
<li>블록{} 안에 블록{}을 계층적으로 작성하면 각각의 블록이 스코프입니다.</li>
<li>같은 스코프 안에서 같은 이름의 let 변수는 허용되지 않습니다.</li>
</ol>
<hr>
<h2 id="블록-스코프"><a href="#블록-스코프" class="headerlink" title="블록 스코프"></a>블록 스코프</h2><hr>
<p>let 변수를 선언하는 가장 큰 목적은 스코프이며 그중에서도 블록 스코프가 돋보입니다.<br>블록{} 안과 밖에 변수 이름이 같더라도 스코프가 다르므로<br>변수가 선언되고 각 변수에 할당된 값이 대체되지 않고 유지됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sports = <span class="string">"축구"</span>;  </span><br><span class="line"><span class="keyword">if</span> (sports)&#123;  </span><br><span class="line"> <span class="keyword">let</span> sports = <span class="string">"농구"</span>;  </span><br><span class="line"> <span class="number">1.</span> <span class="built_in">console</span>.log(<span class="string">"블록: "</span>, sports); <span class="comment">// 농구  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="number">2.</span> <span class="built_in">console</span>.log(<span class="string">"글로벌: "</span>, sports); <span class="comment">// 축구</span></span><br></pre></td></tr></table></figure>

<ul>
<li>if문 앞에 같은 이름의 sports 변수가 있지만 블록{}을 기준으로<br>스코프가 다르므로 각 sports 변수에 값이 할당되어<br>“축구”가 “농구”로 대체되지 않고 각 값이 유지됩니다.</li>
</ul>
<hr>
<h2 id="let과-this-키워드"><a href="#let과-this-키워드" class="headerlink" title="let과 this 키워드"></a>let과 this 키워드</h2><hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">var</span> music = <span class="string">"음악"</span>; <span class="comment">//var (this)  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.music);  </span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span> <span class="keyword">let</span> sports = <span class="string">"축구"</span>; <span class="comment">//let (this)  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.sports);</span><br></pre></td></tr></table></figure>

<ol>
<li>var 키워드는 현재 글로벌 오브젝트의 상태이고<br>this는 글로벌 오브젝트를 참조하게 되어<br>music 변수 값인 “음악”이 출력됩니다.</li>
</ol>
<ol start="2">
<li>let 키워드로 선언,할당한 후<br>this로 sports값을 출력하면 undefined가 출력됩니다.<br>this가 글로벌 오브젝트를 의미하여 window 오브젝트를 참조하는데<br>window 오브젝트에 let 변수가 없다는 것은<br>window 오브젝트에 let 변수가 설정되지 않는다는 의미 입니다.<br>이점이 var변수와 let변수의 차이입니다.</li>
</ol>
<hr>
<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><hr>
<p>function도 스코프를 가지므로 하나의 블록 스코프입니다.<br>function 안에 선언된 모든 변수가 function내의 스코프에 속하고<br>function안에 if 블록{}은 스코프 안에 스코프를 가지는 계층 구조의 형성입니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sports = <span class="string">"축구"</span>, music = <span class="string">"재즈"</span>;  </span><br><span class="line"><span class="comment">// get 함수 밖에 sports 와 music을 선언하고 값을 설정했습니다.  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"> <span class="keyword">let</span> music = <span class="string">"클래식"</span>; <span class="comment">//get 함수안에 music을 선언,할당했습니다.  </span></span><br><span class="line"> <span class="number">1.</span> <span class="built_in">console</span>.log(music);  </span><br><span class="line"> <span class="number">2.</span> <span class="built_in">console</span>.log(sports);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">get</span>();</span><br></pre></td></tr></table></figure>

<ol>
<li>var 변수와 마찬가지로 함수안에서 music 변수를 검색하고,없으면<br>함수 밖으로 나가 검색합니다. 함수안에 music변수가 있으므로<br>“클래식”이 출력됩니다.</li>
</ol>
<ol start="2">
<li>함수안에 sports변수가 없으므로 함수 밖의 sports값인 “축구”를 출력합니다.</li>
</ol>
<p><mark>이와 같이 let 변수도 가장 가까운 스코프에 있는 변수를 먼저 사용합니다.</mark></p>
<figure class="highlight js"><figcaption><span>예시2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sports = <span class="string">"축구"</span>; <span class="comment">// var sports  </span></span><br><span class="line"><span class="keyword">let</span> music = <span class="string">"재즈"</span>; <span class="comment">// let music  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"> <span class="keyword">var</span> sports = <span class="string">"농구"</span>;  </span><br><span class="line"> <span class="keyword">let</span> music = <span class="string">"클래식"</span>;  </span><br><span class="line">  </span><br><span class="line"> <span class="number">1.</span> <span class="built_in">console</span>.log(<span class="string">"1:"</span>, sports);  </span><br><span class="line"> <span class="number">2.</span> <span class="built_in">console</span>.log(<span class="string">"2:"</span>, <span class="keyword">this</span>.sports);  </span><br><span class="line"> <span class="number">3</span> .console.log(<span class="string">"3:"</span>, <span class="keyword">this</span>.music);  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// 1번째 호출   </span></span><br><span class="line"><span class="built_in">window</span>.get();  </span><br><span class="line"><span class="comment">// 2번째 호출  </span></span><br><span class="line"><span class="keyword">get</span>();</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>strict 모드에서 window.get과 같이 get() 앞의 오브젝트 위치에</strong><br><strong>window를 작성하면 function get() 내의 this가 window 오브젝트를 참조합니다.</strong></p>
<ol>
<li><p>함수 안에 sport 변수가 있으므로 그 값인 “농구”를 출력합니다.</p>
</li>
<li><p>window.get()형태로 호출했으므로 this가 window 오브젝트를 참조하여<br>get()함수 밖의 var 변수 sports의 값 “축구”를 출력합니다.</p>
</li>
<li><p>undefined<br>this가 window 오브젝트를 참조하여 get()함수 밖의 music 변수를 찾지만<br>music 변수가 let으로 선언되어 있어 this(window 오브젝트)로 참조할 수 없어 undefined가 출력됩니다.</p>
</li>
</ol>
</li>
<li><p><strong>get()과 같이 오브젝트를 지정하지 않고 호출하면 this가 window 오브젝트를 참조하지 않습니다.</strong></p>
<ol>
<li><p>sports는 var 변수입니다.<br>var변수는 window 오브젝트 지정과 관계없이 함수 안의 변수를 참조하여<br>“농구”가 출력됩니다.</p>
</li>
<li><p>,3. 에러<br>window 오브젝트를 작성하지 않고 호출하여 this가 window 오브젝트를 참조 &gt;하지못하고 엔진은 참조할 오브젝트 위치에 undefined를 설정합니다.<br>this는 참조할 오브젝트 위치에 있는 undefined를 참조하게 되고<br>TypeError가 발생합니다.</p>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><hr>
<p><strong>try-catch문에서 try 블록{}기준으로 블록 스코프를 갖습니다.</strong><br><strong>catch 블록은 스코프를 가지지 않으며 try 블록 스코프에 속합니다.</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sports = <span class="string">"축구"</span>; <span class="comment">//try문 밖의 let sports   </span></span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line"> <span class="keyword">let</span> sports = <span class="string">"농구"</span>; <span class="comment">//try문 안에 let sports  </span></span><br><span class="line"> <span class="number">1.</span> <span class="built_in">console</span>.log(sports);  </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span> <span class="built_in">console</span>.log(sports);  </span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  <span class="keyword">try</span>문 블록&#123;&#125; 스코프의 sports 값 출력 “농구”</span><br><span class="line"><span class="number">2.</span>  <span class="keyword">try</span>문 밖의 sports 값 출력 “축구”</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h2><hr>
<p><strong>switch-case 문에서 switch 블록이 블록 스코프입니다.</strong><br><strong>switch 안에 case는 별도의 스코프를 갖지 않으며 switch 스코프에 속합니다.</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>; <span class="comment">// switch문의 case1:을 실행하기 위해 count에 1할당  </span></span><br><span class="line"><span class="keyword">let</span> sports = <span class="string">"축구"</span>; <span class="comment">//switch문 밖의 let sports  </span></span><br><span class="line"><span class="keyword">switch</span> (count) &#123;  </span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line"> <span class="keyword">let</span> sports = <span class="string">"농구"</span>; <span class="comment">//switch문 내의 let sports  </span></span><br><span class="line"> <span class="built_in">console</span>.log(sports); <span class="comment">// "농구"가 출력됩니다.  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="built_in">console</span>.log(sports); <span class="comment">//"축구"가 출력됩니다.</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="for"><a href="#for" class="headerlink" title="for()"></a>for()</h2><hr>
<p>for()문에서 var변수로 작성하는 것과 let변수로 작성하는 것에는<br>큰 차이가 있습니다.<br><mark>let 변수는 반복할 때 마다 스코프를 갖는 반면,<br>var 변수는 스코프를 갖지 않습니다.</mark></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>1~10<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>11~20<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>21~30<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>var</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodes = <span class="built_in">document</span>.querySelector(<span class="string">"ul"</span>);  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; nodes.children.length; k++)&#123;  </span><br><span class="line"> <span class="keyword">var</span> el = nodes.children[k];  </span><br><span class="line"> el.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;  </span><br><span class="line"> event.target.style.backgroundColor = <span class="string">"yellow"</span>;  </span><br><span class="line"> <span class="built_in">console</span>.log(k);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>querySelector(“ul”)으로 html에 작성된 li 요소 3개를 nodes 변수에 할당합니다.<br>nodes.childern.length는 NodeList의 요소 수로 3입니다.<br>for문을 반복하면서 각 li 요소마다 onclick 이벤트를 설정합니다.<br>클릭시 배경색을 변경하고 for문의 K 변수 값을 출력합니다.<br>어떤 li요소를 클릭하더라도 콘솔에 K값 3이 출력되며 3이 K의 최종값 입니다.</p>
<p>클릭한 li 요소에 해당하는 K변수 값을 출력하고 싶다면<br>let변수를 사용하면 됩니다.</p>
<figure class="highlight js"><figcaption><span>let</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodes = <span class="built_in">document</span>.querySelector(<span class="string">"ul"</span>);  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; nodes.children.length; k++)&#123;  </span><br><span class="line"> <span class="keyword">var</span> el = nodes.children[k];  </span><br><span class="line"> el.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;  </span><br><span class="line"> event.target.style.backgroundColor = <span class="string">"yellow"</span>;  </span><br><span class="line"> <span class="built_in">console</span>.log(k);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>li요소를 클릭하면 onclick이벤트를 설정했을 때<br>사용한 K변수 값을 출력합니다. 0,1,2<br>이는 let변수가 스코프를 갖기 때문입니다.</p>
<hr>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><hr>
<p>const 변수에 할당된 값은 상수가 됩니다.<br>상수는 재할당 할 수 없으며 재선언 할 수도 없습니다.</p>
<p>const 변수는 선언-초기화-할당을 한번에 합니다.<br>즉, const a; 처럼 선언만 해놓을 수 없습니다.<br>반드시 const a = 0; 처럼 초기값을 할당해 줘야 합니다.</p>
<p>상수 선언에는 대소문자 모두 사용할 수 있지만,<br>일반적인 관습은 모두 대문자를 사용하는 것입니다.</p>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JavaScript/">JavaScript</a><a class="link-muted mr-2" rel="tag" href="/tags/ECMAScript6/">ECMAScript6</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/03/17/Arrow%20-ECMAScript/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Arrow -ECMAScript</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/03/16/Strict%20mode%20-ECMAScript/"><span class="level-item">Strict mode -ECMAScript</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">댓글</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div>