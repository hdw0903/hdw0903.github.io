<div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-03-16T01:04:46.000Z" title="2020-03-16T01:04:46.000Z">2020-03-16</time><span class="level-item"><a class="link-muted" href="/categories/ECMAScript6/">ECMAScript6</a></span><span class="level-item">14분 읽기 (대략 2102 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile">Strict mode -ECMAScript</h1><div class="content"><hr>
<h3 id="Strict-mode"><a href="#Strict-mode" class="headerlink" title="Strict mode"></a>Strict mode</h3><hr>
<p>strict mode는<br>JavaScript 코드가 “엄격 모드”에서 실행되도록 정의합니다.</p>
<p>“strict mode”지시문은 ECMAScript 버전 5에서 새로 추가되었습니다.</p>
<p>IE9 이하를 제외한 모든 최신 브라우저는 strict mode를 지원합니다.</p>
<p>가끔 엄격하지 않은 기본값을<br>“느슨한 모드(sloppy mode)”라고 부르기도 합니다.<br>공식적인 용어는 아니지만 혹시 모르니 알아두세요.</p>
<p><code>&quot;strict mode&quot;지시문은 script 나 function의 시작 부분에서만 인식됩니다.</code></p>
<a id="more"></a>

<ul>
<li>전체 스크립트 적용 구문</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//스크립트 파일 첫번째 줄  </span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>function에 적용하는 구문<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strict</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line"> <span class="comment">// 함수-레벨 strict mode 문법  </span></span><br><span class="line"><span class="meta"> "use strict"</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="1-strict-mode를-사용하면-선언되지-않은-변수를-사용할-수-없습니다"><a href="#1-strict-mode를-사용하면-선언되지-않은-변수를-사용할-수-없습니다" class="headerlink" title="1.  strict mode를 사용하면 선언되지 않은 변수를 사용할 수 없습니다."></a>1.  strict mode를 사용하면 선언되지 않은 변수를 사용할 수 없습니다.</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;  </span><br><span class="line">myFunction();  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line"> x = <span class="number">3.14</span>; <span class="comment">// x를 선언해 주지 않았기 때문에 오류가 발생합니다.  </span></span><br><span class="line">&#125;  </span><br><span class="line">y= <span class="number">3</span>; <span class="comment">// y역시 선언되지 않았기에 오류가 발생합니다.</span></span><br></pre></td></tr></table></figure>

<p>strict mode는 이전에 허용 된 “잘못된 구문”을 실제 오류로 변경합니다.</p>
<p>또한 선언되지 않은 변수를 사용하지 못하게하는 것과 같이<br>더 깨끗한 코드를 작성하는 데 도움이됩니다.<br>“strict mode”는 문자열이므로 IE 9는 이해하지 않아도 오류를 발생시키지 않습니다.</p>
<p>예를 들어,<br>일반적인 JavaScript에서 변수 이름을 잘못 입력하면 새로운 전역 변수가 만들어집니다.<br><code>strict mode에서는 실수로 전역 변수를 만들 수 없습니다.</code></p>
<hr>
<h4 id="2-NaN-은-쓸-수-없는-전역-변수입니다"><a href="#2-NaN-은-쓸-수-없는-전역-변수입니다" class="headerlink" title="2.  NaN 은 쓸 수 없는 전역 변수입니다."></a>2.  NaN 은 쓸 수 없는 전역 변수입니다.</h4><p>NaN 에 할당하는 일반적인 코드는 아무 것도 하지 않습니다.<br>개발자도 아무런 실패 피드백을 받지 않습니다.</p>
<p>엄격 모드에서 NaN 에 할당하는 것은 예외를 발생시킵니다.<br>일반 코드에서 조용히 넘어가는 모든 실패에 대해 (쓸 수 없는 전역 또는 프로퍼티에 할당, getter-only 프로퍼티에 할당, 확장 불가 객체에 새 프로퍼티 할당) 엄격 모드에서는 예외를 발생시킵니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 쓸 수 없는 프로퍼티에 할당  </span></span><br><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">5</span>; <span class="comment">// TypeError 발생  </span></span><br><span class="line"><span class="keyword">var</span> <span class="literal">Infinity</span> = <span class="number">5</span>; <span class="comment">// TypeError 발생  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 쓸 수 없는 프로퍼티에 할당  </span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;  </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">"x"</span>, &#123; <span class="attr">value</span>: <span class="number">42</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;);  </span><br><span class="line">obj1.x = <span class="number">9</span>; <span class="comment">// TypeError 발생  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// getter-only 프로퍼티에 할당  </span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="keyword">get</span> x() &#123; <span class="keyword">return</span> <span class="number">17</span>; &#125; &#125;;  </span><br><span class="line">obj2.x = <span class="number">5</span>; <span class="comment">// TypeError 발생  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 확장 불가 객체에 새 프로퍼티 할당  </span></span><br><span class="line"><span class="keyword">var</span> fixed = &#123;&#125;;  </span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(fixed);  </span><br><span class="line">fixed.newProp = <span class="string">"ohai"</span>; <span class="comment">// TypeError 발생</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-엄격-모드는-삭제할-수-없는-프로퍼티를-삭제하려할-때-예외를-발생시킵니다-시도가-어떤-효과도-없을-때"><a href="#3-엄격-모드는-삭제할-수-없는-프로퍼티를-삭제하려할-때-예외를-발생시킵니다-시도가-어떤-효과도-없을-때" class="headerlink" title="3. 엄격 모드는 삭제할 수 없는 프로퍼티를 삭제하려할 때 예외를 발생시킵니다.  (시도가 어떤 효과도 없을 때)."></a>3. 엄격 모드는 삭제할 수 없는 프로퍼티를 삭제하려할 때 예외를 발생시킵니다.  (시도가 어떤 효과도 없을 때).</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;  </span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype; <span class="comment">// TypeError 발생</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-또한-function-삭제도-허용하지-않습니다"><a href="#4-또한-function-삭제도-허용하지-않습니다" class="headerlink" title="4. 또한 function 삭제도 허용하지 않습니다."></a>4. 또한 function 삭제도 허용하지 않습니다.</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">p1, p2</span>) </span>&#123;&#125;;  </span><br><span class="line"><span class="keyword">delete</span> x;        <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-엄격모드는-유니크한-함수-파라미터-이름을-요구합니다-일반-코드에서는-마지막으로-중복된-인수가-이전에-지정된-인수를-숨깁니다-이러한-이전의-인수들은-arguments-i-를-통해-여전히-남아-있을-수-있으므로-완전히-접근-불가한-것이-아닙니다-여전히-이런-숨김-처리는-이치에-맞지-않으며-원했던-것이-아닐-수-있습니다-예를-들면-오타를-숨길-수도-있습니다-따라서-엄격-모드에서는-종복-인수명은-구문-에러입니다"><a href="#5-엄격모드는-유니크한-함수-파라미터-이름을-요구합니다-일반-코드에서는-마지막으로-중복된-인수가-이전에-지정된-인수를-숨깁니다-이러한-이전의-인수들은-arguments-i-를-통해-여전히-남아-있을-수-있으므로-완전히-접근-불가한-것이-아닙니다-여전히-이런-숨김-처리는-이치에-맞지-않으며-원했던-것이-아닐-수-있습니다-예를-들면-오타를-숨길-수도-있습니다-따라서-엄격-모드에서는-종복-인수명은-구문-에러입니다" class="headerlink" title="5.  엄격모드는 유니크한 함수 파라미터 이름을 요구합니다. 일반 코드에서는 마지막으로 중복된 인수가 이전에 지정된 인수를 숨깁니다. 이러한 이전의 인수들은 arguments[i] 를 통해 여전히 남아 있을 수 있으므로, 완전히 접근 불가한 것이 아닙니다. 여전히, 이런 숨김 처리는 이치에 맞지 않으며 원했던 것이 아닐 수 있습니다(예를 들면 오타를 숨길 수도 있습니다). 따라서 엄격 모드에서는 종복 인수명은 구문 에러입니다."></a>5.  엄격모드는 유니크한 함수 파라미터 이름을 요구합니다. 일반 코드에서는 마지막으로 중복된 인수가 이전에 지정된 인수를 숨깁니다. 이러한 이전의 인수들은 arguments[i] 를 통해 여전히 남아 있을 수 있으므로, 완전히 접근 불가한 것이 아닙니다. 여전히, 이런 숨김 처리는 이치에 맞지 않으며 원했던 것이 아닐 수 있습니다(예를 들면 오타를 숨길 수도 있습니다). 따라서 엄격 모드에서는 종복 인수명은 구문 에러입니다.</h4><figure class="highlight js"><figcaption><span>예시1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">p1, p1</span>) </span>&#123;&#125;;   <span class="comment">// !!! 구문 에러</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><figcaption><span>예시2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, a, c</span>)</span>&#123; <span class="comment">// !!! 구문 에러  </span></span><br><span class="line"><span class="meta"> "use strict"</span>;  </span><br><span class="line"> <span class="keyword">return</span> a + b + c; <span class="comment">// 코드가 실행되면 잘못된 것임  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-ECMAScript-5-에서의-엄격-모드는-8진수-구문을-금지합니다"><a href="#6-ECMAScript-5-에서의-엄격-모드는-8진수-구문을-금지합니다" class="headerlink" title="6.  ECMAScript 5 에서의 엄격 모드는 8진수 구문을 금지합니다."></a>6.  ECMAScript 5 에서의 엄격 모드는 8진수 구문을 금지합니다.</h4><p>8진수 구문은 ES5의 문법이 아니지만,<br>모든 브라우저에서 앞에 0을 붙여 지원됩니다(0644 === 420 와 “045” === “%”).</p>
<p><code>ECMAScript 2015 에서는 접두사 &quot;0o&quot;를 붙여 8진수를 지원합니다.</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0o10</span>; <span class="comment">// ES6: 8진수</span></span><br></pre></td></tr></table></figure>

<p>초보 개발자들은 가끔 앞에 붙은 0 이 무의미하다고 생각하여, 이를 정렬용으로 사용합니다 — 하지만 이는 숫자의 의미를 바꿔버립니다.<br>이 8진수 문법은 거의 무용하며 잘못 사용될 수 있으므로 엄격모드에서 이 구문은 에러입니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;  </span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">015</span> + <span class="comment">// !!! 구문 에러  </span></span><br><span class="line"> <span class="number">197</span> +  </span><br><span class="line"> <span class="number">142</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-ECMAScript-6-의-엄격모드는-primitive-값에-프로퍼티를-설정하는-것을-금지합니다-엄격모드가-아닐-때에는-프로퍼티-설정이-간단하게-무시되지만-no-op-엄격모드에서는-TypeError-를-발생시킵니다"><a href="#7-ECMAScript-6-의-엄격모드는-primitive-값에-프로퍼티를-설정하는-것을-금지합니다-엄격모드가-아닐-때에는-프로퍼티-설정이-간단하게-무시되지만-no-op-엄격모드에서는-TypeError-를-발생시킵니다" class="headerlink" title="7. ECMAScript 6 의 엄격모드는 primitive 값에 프로퍼티를 설정하는 것을 금지합니다. 엄격모드가 아닐 때에는 프로퍼티 설정이 간단하게 무시되지만(no-op), 엄격모드에서는 TypeError 를 발생시킵니다."></a>7. ECMAScript 6 의 엄격모드는 primitive 값에 프로퍼티를 설정하는 것을 금지합니다. 엄격모드가 아닐 때에는 프로퍼티 설정이 간단하게 무시되지만(no-op), 엄격모드에서는 TypeError 를 발생시킵니다.</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line"><span class="meta">"use strict"</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="literal">false</span>.true = <span class="string">""</span>;         <span class="comment">// TypeError  </span></span><br><span class="line">(<span class="number">14</span>).sailing = <span class="string">"home"</span>;   <span class="comment">// TypeError  </span></span><br><span class="line"><span class="string">"with"</span>.you = <span class="string">"far away"</span>; <span class="comment">// TypeError  </span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><code>primitive</code>: 원시값 또는 원시 자료형<br>객체도 아니고 메서드도 아닌 데이터입니다.<br>string, number, bigint, boolean, null, undefined, symbol<br>7가지 원시 자료형이 존재 합니다.</p>
<p><mark>모든 원시 값은 불변합니다. 즉, 변형할 수 없습니다. 원시값 자체와, 원시값을 할당한 변수를 혼동하지 않는 것이 중요합니다. 변수는 새로운 값을 다시 할당할 수 있지만, 이미 생성한 원시값은 객체, 배열, 함수와는 달리 변형할 수 없습니다.</mark></p>
<figure class="highlight js"><figcaption><span>원시값 예시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열 메서드는 문자열을 변형하지 않음  </span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="string">"baz"</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(bar);        <span class="comment">// baz  </span></span><br><span class="line">bar.toUpperCase();  </span><br><span class="line"><span class="built_in">console</span>.log(bar);        <span class="comment">// baz  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 배열 메소드는 배열을 변형함  </span></span><br><span class="line"><span class="keyword">var</span> foo = [];  </span><br><span class="line"><span class="built_in">console</span>.log(foo);        <span class="comment">// []  </span></span><br><span class="line">foo.push(<span class="string">"plugh"</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(foo);        <span class="comment">// ["plugh"]  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 할당은 원시 값에 새로운 값을 부여 (변형이 아님)  </span></span><br><span class="line">bar = bar.toUpperCase(); <span class="comment">// BAZ</span></span><br></pre></td></tr></table></figure>

<p><code>원시 값을 교체할 수는 있지만, 직접 변형할 수는 없습니다.</code></p>
<figure class="highlight js"><figcaption><span>원시형 코드 실행 과정</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 원시값  </span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="number">5</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 원시값을 변경해야 하는 함수 정의  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">num</span>) </span>&#123;  </span><br><span class="line"> num += <span class="number">2</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 같은 작업을 시도하는 다른 함수  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo_v2</span>(<span class="params">foo</span>) </span>&#123;  </span><br><span class="line"> foo += <span class="number">2</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 원시값을 인수로 전달해 첫 번째 함수를 호출  </span></span><br><span class="line">addTwo(foo);  </span><br><span class="line"><span class="comment">// 현재 원시값 반환  </span></span><br><span class="line"><span class="built_in">console</span>.log(foo);   <span class="comment">// 5  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 두 번째 함수로 다시 시도  </span></span><br><span class="line">addTwo_v2(foo);  </span><br><span class="line"><span class="built_in">console</span>.log(foo);   <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>5 대신 7 일 것이라고 예상하였나요?<br>그렇다면, 이 코드의 실행 과정을 살펴보세요.</p>
<ol>
<li><p>addTwo 와 addTwo_v2 함수 호출을 위해, JavaScript는 식별자 foo 의 값을 찾습니다. 이는 인스턴스화된 첫 번째 구문의 변수를 올바르게 찾습니다.</p>
</li>
<li><p>찾은 다음, JavaScript는 인수를 함수의 매개변수로서 전달합니다.</p>
</li>
<li><p>함수의 본문 내 구문들을 실행하기 전에, JavaScript는 원래 전달된 인수(원시 값)를 복사해 로컬 복사본을 생성합니다. 이러한 복사본은 함수의 스코프 내에서만 존재하며, 함수 정의 내에 지정한 식별자를 통해 접근가능합니다(addTwo 의 num, addTwo_v2 의 foo).</p>
</li>
<li><p>그 후, 함수의 구문들이 실행됩니다.<br>4-1. 첫 번째 함수내에서, 로컬 num 인수가 생성되었습니다. 이 값을 2 증가시키는 것이며, 원래 foo 의 값이 아닙니다!</p>
<p>4-2. 두 번째 함수내에서, 로컬 foo 인수가 생성되었습니다. 이 값을 2 증가시키는 것이며, 원래(외부) foo 의 값이 아닙니다! 또한, 이 경우에서, 외부 foo 변수에는 어떤 방법으로든 접근할 수 없습니다. 이는 자바스크립트의 어휘적 유효 범위(lexical scoping)와 결과 변수 섀도잉 때문입니다. 로컬 foo 는 외부 foo 를 숨깁니다.</p>
</li>
</ol>
<p><mark>결과적으로, 우리 함수들 내부의 모든 변경은 그 복사본으로 작업하였기 때문에, 원본 foo 에 전혀 영향을 주지 않았습니다.</mark></p>
<p>이것이 원시값이 변하지 않는 이유입니다. 원시값에 직접 작업하지 않으므로, 원본을 건드리지 않고 복사본 가져와 계속 작업을 합니다.</p>
<hr>
<h4 id="8-function의-this키워드는-엄격모드에서-다르게-작동합니다"><a href="#8-function의-this키워드는-엄격모드에서-다르게-작동합니다" class="headerlink" title="8. function의 this키워드는 엄격모드에서 다르게 작동합니다."></a>8. function의 this키워드는 엄격모드에서 다르게 작동합니다.</h4><p>this 키워드는 함수를 호출 한 객체를 나타냅니다.<br>객체를 지정하지 않으면 엄격 모드의 function은 undefined로 반환됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line"> alert(<span class="keyword">this</span>); <span class="comment">// will alert "undefined"  </span></span><br><span class="line">&#125;  </span><br><span class="line">myFunction();</span><br></pre></td></tr></table></figure></div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JavaScript/">JavaScript</a><a class="link-muted mr-2" rel="tag" href="/tags/ECMAScript6/">ECMAScript6</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/03/16/%ED%82%A4%EC%9B%8C%EB%93%9C,%20%EB%B8%94%EB%A1%9D%20%EC%8A%A4%EC%BD%94%ED%94%84%20-ECMAScript/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">키워드, 블록 스코프 -ECMAScript</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/03/12/%ED%9A%A8%EA%B3%BC%20%EB%B0%8F%20%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20-jQuery/"><span class="level-item">효과 및 애니메이션 -jQuery</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">댓글</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div>