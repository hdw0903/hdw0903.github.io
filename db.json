{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/Array_empty.JPG","path":"images/Array_empty.JPG","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/ClassThisInstance.JPG","path":"images/ClassThisInstance.JPG","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/JavaScript-Data-Types.PNG","path":"images/JavaScript-Data-Types.PNG","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/SymbolObj.JPG","path":"images/SymbolObj.JPG","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/coffee-favicon.png","path":"images/coffee-favicon.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/constructorInstance.JPG","path":"images/constructorInstance.JPG","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/context_callStack.png","path":"images/context_callStack.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/extendsObj.JPG","path":"images/extendsObj.JPG","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/extendsSoccer.JPG","path":"images/extendsSoccer.JPG","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/favicon.svg","path":"images/favicon.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/maengo.jpg","path":"images/maengo.jpg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/newMapInstance.JPG","path":"images/newMapInstance.JPG","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/promise.SVG","path":"images/promise.SVG","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/razor-bottom-black.svg","path":"images/razor-bottom-black.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/razor-top-black.svg","path":"images/razor-top-black.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/rejectPromiseObj.JPG","path":"images/rejectPromiseObj.JPG","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/resolvePromiseObj.JPG","path":"images/resolvePromiseObj.JPG","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/speciesArrayObj.JPG","path":"images/speciesArrayObj.JPG","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/sportsConsole.JPG","path":"images/sportsConsole.JPG","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/template.png","path":"images/template.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/thumbnail.svg","path":"images/thumbnail.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/tuna_blog.jpg","path":"images/tuna_blog.jpg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/tuna_blog.png","path":"images/tuna_blog.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/default.styl","path":"css/default.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/og_image.png","path":"images/og_image.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/blog_logo.png","path":"images/blog_logo.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/prototype_schematic.png","path":"images/prototype_schematic.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/prototype_schematic2.png","path":"images/prototype_schematic2.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/prototype_Constructor.png","path":"images/prototype_Constructor.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/prototype_Instance.png","path":"images/prototype_Instance.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/prototype_arr_Array.png","path":"images/prototype_arr_Array.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/prototype_Array_schematic.png","path":"images/prototype_Array_schematic.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/객체의_최상위_객체_Object.png","path":"images/객체의_최상위_객체_Object.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/icarus/.eslintignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1587406360630},{"_id":"themes/icarus/.eslintrc.json","hash":"b6de6612836a7814bae9a51a5089609853cc44a2","modified":1587406360630},{"_id":"themes/icarus/.gitignore","hash":"8ecd21ae1f2cdc3cf59b71a526564252c93b84df","modified":1587406360645},{"_id":"themes/icarus/.travis.yml","hash":"d7c64bd876f0af1288d855a6d61d691d27770560","modified":1587406360645},{"_id":"themes/icarus/CONTRIBUTING.md","hash":"6498cecab7b128e8f61061ec1ab1c6f3cb635507","modified":1587406360645},{"_id":"themes/icarus/LICENSE","hash":"62e3701684087bc9a66f0b20386036ede9b430b7","modified":1587406360645},{"_id":"themes/icarus/README.md","hash":"1eafb0e93832f63e9d2baeaf2bb7f8de40e04843","modified":1587406360645},{"_id":"themes/icarus/_config.yml","hash":"db120ae8e81956c82075263df5103dfbec468132","modified":1588941351955},{"_id":"themes/icarus/css백업.txt","hash":"f42161ae874b6afa12d186768c1e26e5755783e1","modified":1587411049304},{"_id":"themes/icarus/package-lock.json","hash":"98c48f6ba27ccd4c371fca90fba59e8055d0e2cd","modified":1587409332528},{"_id":"themes/icarus/package.json","hash":"2c1d29d904512c00b1445f82f0c1eeab9a83fce8","modified":1587409332492},{"_id":"source/_posts/Array 배열 객체 -JavaScript.md","hash":"9f4ca218dabfcddf1a8f237d301fb27b4cd356d8","modified":1587808628465},{"_id":"source/_posts/Array 오브젝트 -ECMAScript.md","hash":"5b3a01013a7074ed0bd5e630233c23bfcf6660c9","modified":1587808628465},{"_id":"source/_posts/Arrow -ECMAScript.md","hash":"924ee2e9503327a7dbce742c23a3728cf726c6f8","modified":1587808628465},{"_id":"source/_posts/BOM 브라우저 객체 모델.md","hash":"b7e5c0b21df8b2bc467733aa88bff487af8dfee8","modified":1587808628465},{"_id":"source/_posts/Class 오브젝트 -ECMAScript.md","hash":"5c83d1961a1801c46961cb3a72534f4a62b0eac2","modified":1587808628465},{"_id":"source/_posts/DOM 문서 객체 모델.md","hash":"d0cef312d2307284b7aa6cac133b58dcfdd69c14","modified":1587808628465},{"_id":"source/_posts/Destructuring -ECMAScript.md","hash":"835c7e4fb74b1b293dd23d151a81c0436792f6cf","modified":1587808628465},{"_id":"source/_posts/ES6에 추가된 Operation -ECMAScript.md","hash":"dbd3b4db952fdd6ebf0bf5b47ef1c0579d8298c4","modified":1587808628465},{"_id":"source/_posts/Generator 오브젝트 -ECMAScript.md","hash":"9ef72c3aea3182f634764e1048103daf2cbccb70","modified":1587808628465},{"_id":"source/_posts/Global Variable 전역변수 와 Local Variable 지역변수.md","hash":"b864b729f4c814df6aadadf6c87c8d7e4ca3e48a","modified":1587808628465},{"_id":"source/_posts/Iteration -ECMAScript.md","hash":"94152f32e0389f687cb5f2325ac8606ca9d0fea7","modified":1587808628465},{"_id":"source/_posts/Map 오브젝트 -ECMAScriprt.md","hash":"b4f4fc7fa645b6867e67d616475c06edea529ca5","modified":1587808628465},{"_id":"source/_posts/Math 오브젝트 -ECMAScript.md","hash":"c1bb9e42127e140b0f0c1073cc4e6c3a8d6bb5cf","modified":1587808628465},{"_id":"source/_posts/Number 오브젝트 -ECMAScript.md","hash":"c4e5e669b16ecad855257413b7261cf426e6467d","modified":1587808628465},{"_id":"source/_posts/Promise 오브젝트 -ECMAScript.md","hash":"341d38a3dbb971c2443563d12eea85dbe7aad027","modified":1587808628465},{"_id":"source/_posts/Object 오브젝트 -ECMAScript.md","hash":"0b72e811540c25955e8812ea6ce52ab343bfe9d1","modified":1587808628465},{"_id":"source/_posts/RegExp 정규표현 객체 -JavaScript.md","hash":"ee499a3d475e30858f78b7344f0b9a63d692d431","modified":1587808628469},{"_id":"source/_posts/Spread 연산자 -ECMAScript.md","hash":"d1a66e188b5a264acdd98dcc607bf8121f46c657","modified":1587808628469},{"_id":"source/_posts/Strict mode -ECMAScript.md","hash":"3776b2ec9bdbfcd19b3caa837cbcec5a1a8e19ba","modified":1588770717133},{"_id":"source/_posts/String 문자 객체 -JavaScript.md","hash":"38c49a3fcd3a190c9a2bd482acc156bcd903b8a6","modified":1587808628469},{"_id":"source/_posts/Set 오브젝트 -ECMAScript.md","hash":"da368af12bfe2dea3440452e5d5cf4a47e68cfd4","modified":1587808628469},{"_id":"source/_posts/String 오브젝트 -ECMAScript.md","hash":"24e48abb750e9cd126d7b663e16b6d1783172637","modified":1587808628469},{"_id":"source/_posts/Symbol 메서드 -ECMAScript.md","hash":"b1984c3fb580cdd171d879eb1f1b87f2fe65a569","modified":1587808628469},{"_id":"source/_posts/Symbol 오브젝트 -ECMAScript.md","hash":"def33415493392545f499bba46fec8892cdf9b0a","modified":1587808628469},{"_id":"source/_posts/Template 리터널 -ECMAScript.md","hash":"5cca76b60053edb4b1fb9c92f639d9a939f40776","modified":1587808628469},{"_id":"source/_posts/WeakMap 오브젝트 -ECMAScript.md","hash":"bb5aa255bc22fed12a645f9a24002c9d10977bc2","modified":1588771855904},{"_id":"source/_posts/WeakSet 오브젝트 -ECMAScript.md","hash":"76156156122fb27a4822e3b20af5f027349bc2e2","modified":1587808628469},{"_id":"source/_posts/function 함수 -JavaScript.md","hash":"202ba5a0ccb9fc67660a27259ed67012277c8663","modified":1588936426119},{"_id":"source/_posts/jQuery 이벤트 핸들러.md","hash":"c12465a9deb322d8543053b050388eac0596325e","modified":1587808628465},{"_id":"source/_posts/return 문, 재귀함수 호출 -JavaScript.md","hash":"8b3d95c0444f2479e08bca0a349cedba34ea3460","modified":1587808628465},{"_id":"source/_posts/this Keyword -JavaScript.md","hash":"9a2879cc59a15a3b9c7cba0589a4dbbd70c6f674","modified":1587808628469},{"_id":"source/_posts/this-Core-JavaScript.md","hash":"f2cf248db29905dc53be89a6a1e28f7991b0dc86","modified":1588596846982},{"_id":"source/_posts/객체 조작 메서드 -jQuery.md","hash":"373422e45d9a3ca0048117516929dd2092f5635a","modified":1587808628469},{"_id":"source/_posts/날짜 객체 메서드.md","hash":"8873948660197affd1b2b22ce2cf8aa8e82ab52a","modified":1587888321358},{"_id":"source/_posts/데이터 타입 -Core JavaScript.md","hash":"b7d99a58224096f3ac9164ec6fce445226afe413","modified":1588939367825},{"_id":"source/_posts/선택자 -jQuery.md","hash":"9f51078de85ecda828bc7f4d8e662e2c930969fc","modified":1587808628469},{"_id":"source/_posts/수학 객체 -JavaScript.md","hash":"66b85c24b9d86b51654c0bc853656598c80e6a17","modified":1587808628469},{"_id":"source/_posts/Symbol 프로퍼티 -ECMAScript.md","hash":"8152eaf2f5a2c59055715eac81529eea4ee48330","modified":1587808628469},{"_id":"source/_posts/숫자 객체 -JavaScript.md","hash":"819fbead88f198b1d05046c3ed4e428ef8879484","modified":1587808628469},{"_id":"source/_posts/실행-컨텍스트-Core-JavaScript.md","hash":"1dd5e714c7822e743bea1dc899372dfd52469114","modified":1588937542204},{"_id":"source/_posts/이벤트 -JavaScript.md","hash":"2fea0a40cf88c59d46493f01fed1b4cb8c025f8a","modified":1587808628469},{"_id":"source/_posts/자바스크립트 기초 문법.md","hash":"5d05041b91f3bdd3407e12ed84e601dd1218928e","modified":1587808628469},{"_id":"source/_posts/자바스크립트 선택문.md","hash":"8174de6384a29588dfa934a4c3e709b907b70cdd","modified":1587808628465},{"_id":"source/_posts/자바스크립트 연산자.md","hash":"faf2f9bf51db839f54e775fba53c7810b65e1961","modified":1587808628469},{"_id":"source/_posts/자바스크립트 조건문.md","hash":"7ebabdf5dd2d490fcd3a6d72ad34f19c03eb2ab4","modified":1587808628469},{"_id":"source/_posts/키워드, 블록 스코프 -ECMAScript.md","hash":"8bbb4a09f474d7e4b09911202f0a15c586695f24","modified":1587808628469},{"_id":"source/_posts/효과 및 애니메이션 -jQuery.md","hash":"6d9c97f8c8d22b440e4fbf1f25b458877a202b35","modified":1587808628469},{"_id":"themes/icarus/.github/stale.yml","hash":"bbf3abd0d342022c1d62a66cb5f4211b43eab47a","modified":1587406360630},{"_id":"themes/icarus/include/config.js","hash":"bd4b10b7ad360ac09912646c04efc021ff3d45ad","modified":1587406360645},{"_id":"themes/icarus/include/dependency.js","hash":"239871703ff1d23cd59aa9213c5fa0a0ed2706c0","modified":1587406360645},{"_id":"themes/icarus/include/register.js","hash":"dc4dca98a5b84f40679e7af1a8f1d55f8d634b40","modified":1587406360673},{"_id":"themes/icarus/languages/de.yml","hash":"ef43979c403b3a221585d5dd0b7205627437818e","modified":1587406360737},{"_id":"themes/icarus/languages/en.yml","hash":"9d14e90a3f3dde00b982fa56becd8e63925ff6cd","modified":1587406360737},{"_id":"themes/icarus/languages/es.yml","hash":"f0ea2c482a8bc5ed43452ecc7ebe601504e0cc54","modified":1587406360737},{"_id":"themes/icarus/languages/fr.yml","hash":"b85a2d4fcc790a8b84326235850eb54532f6b75e","modified":1587406360752},{"_id":"themes/icarus/languages/id.yml","hash":"ee655e6a045eb28ea480a348bbefd10ef115494b","modified":1587406360752},{"_id":"themes/icarus/languages/ja.yml","hash":"3c921f24b19a797b2ae23cf621a35bb9b043ddf9","modified":1587406360752},{"_id":"themes/icarus/languages/ko.yml","hash":"a92c949f8bfcdeaa9e0bcc5b775f50034216e22e","modified":1588248546086},{"_id":"themes/icarus/languages/pl.yml","hash":"a6dbd568cb18104685b20ab7b5767f455628f61c","modified":1587406360752},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"28ae713d8d26ab875104684e604592f4c495b638","modified":1587406360752},{"_id":"themes/icarus/languages/tr.yml","hash":"2e334f0f98756256754f48d8dff3baa045700283","modified":1587406360752},{"_id":"themes/icarus/languages/ru.yml","hash":"62451109780acfe2db8630248005697c10a68a61","modified":1587406360752},{"_id":"themes/icarus/languages/vn.yml","hash":"cd2d57a3fe6389bdd76f193c6c662d242960ed02","modified":1587406360752},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"915b3868a8fa5af2d4a81bebaec1fce9c160c530","modified":1587406360752},{"_id":"themes/icarus/layout/archive.jsx","hash":"eef212d92edd1f10d3f0756cd153771ea925dbbc","modified":1587406360752},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"eaede43f04878974f43eff4d41cb28bf4c2908fe","modified":1587406360752},{"_id":"themes/icarus/layout/categories.jsx","hash":"50d81072a5b5508a906b2c96289982d081a59edd","modified":1587406360752},{"_id":"themes/icarus/layout/category.jsx","hash":"16c8cf03fd976d839242dcf9240ccaf59b843daa","modified":1587406360752},{"_id":"themes/icarus/layout/index.jsx","hash":"c2e7008020c4358f491c8e2ad871aa2274a427d0","modified":1587406360768},{"_id":"themes/icarus/layout/layout.jsx","hash":"7d33707bce4be18353551729cf916a3cb64bdeda","modified":1588943313006},{"_id":"themes/icarus/layout/page.jsx","hash":"8a3cce132f7a4d52450cdcada54afeb5465fdc8d","modified":1587406360768},{"_id":"themes/icarus/layout/post.jsx","hash":"8a3cce132f7a4d52450cdcada54afeb5465fdc8d","modified":1587406360768},{"_id":"themes/icarus/layout/tag.jsx","hash":"49c04b040ba0ff138ad36d6478bd76e18edc8085","modified":1587406360768},{"_id":"themes/icarus/layout/tags.jsx","hash":"5bd27a87fc6e456beb3e56e1dcdbd1f7ac010ce1","modified":1587406360768},{"_id":"themes/icarus/scripts/index.js","hash":"6156ee1e29064e851aeef66305302103a379cae3","modified":1587406360784},{"_id":"themes/icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1587406360752},{"_id":"themes/icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1587406360768},{"_id":"themes/icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1587406360768},{"_id":"themes/icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1587406360768},{"_id":"themes/icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1587406360768},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/bug_report.md","hash":"f132b847b60e4a0b0831b142bf5c6611e0dc7108","modified":1587406360630},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/feature_request.md","hash":"d802c5ab45baeaebd4d1157d4c4019464dcafbf2","modified":1587406360630},{"_id":"themes/icarus/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md","hash":"5da42c65d575a85dbae576e5dd918efc9bb470b3","modified":1587406360630},{"_id":"themes/icarus/include/migration/head.js","hash":"c32df32ae70cd5e522de5481cde4e7c416b4dbec","modified":1587406360669},{"_id":"themes/icarus/include/migration/v2_v3.js","hash":"5a93bf29353c63afe96626a46202aa98e945e64c","modified":1587550312685},{"_id":"themes/icarus/include/schema/config.json","hash":"0b4810adae5ad713c535a5abe126bfb044c861e7","modified":1587406360706},{"_id":"themes/icarus/include/style/article.styl","hash":"72cea905dd2ad60a093696e16389fd82115e12c1","modified":1588945444568},{"_id":"themes/icarus/include/style/base.styl","hash":"689d69549ae3875c9e8de65aa7fd6487be2168c8","modified":1587486033277},{"_id":"themes/icarus/include/style/button.styl","hash":"425796eba494ee6f4d7c0cc1eeb29d03c95fd131","modified":1587476796897},{"_id":"themes/icarus/include/style/card.styl","hash":"9d7a48ebc4308914e480cd23444c88aae511ddf3","modified":1588943673029},{"_id":"themes/icarus/include/style/codeblock.styl","hash":"345c921afba5d01df30c78ae626a317eb64ba987","modified":1587496167447},{"_id":"themes/icarus/include/style/donate.styl","hash":"41495808091511b475d35e3b3491e2d345584601","modified":1587406360721},{"_id":"themes/icarus/include/style/footer.styl","hash":"54e8b9c772ca6acaaed153bbd6b32ea0fabdc19f","modified":1587474669468},{"_id":"themes/icarus/include/style/helper.styl","hash":"3debb5fccf79729fc917e4908c29aab716e52b7b","modified":1587491091565},{"_id":"themes/icarus/include/style/navbar.styl","hash":"27cb86d807ff31e4081aef187fa7fdee4ecdf88b","modified":1587474679574},{"_id":"themes/icarus/include/style/pagination.styl","hash":"7e1aba7d4442b5ba39b82569341c4e939a8005cc","modified":1587406360737},{"_id":"themes/icarus/include/style/plugin.styl","hash":"f23c80665bcef81640eeb635f265418fa0f66ace","modified":1588008973757},{"_id":"themes/icarus/include/style/responsive.styl","hash":"2959b0845c3153e369a1beb1ae41e9b186a249ab","modified":1588944930013},{"_id":"themes/icarus/include/style/search.styl","hash":"3e4505ee53ebddaacbcec84ba8e1f13ed0c50e5b","modified":1587499800513},{"_id":"themes/icarus/include/style/timeline.styl","hash":"0f15f648821abe412e2105e157c9810bb4834aa4","modified":1587406360737},{"_id":"themes/icarus/include/util/console.js","hash":"9bd6d4691b56012ea17146db577e27ae20e0c335","modified":1587406360737},{"_id":"themes/icarus/layout/common/article.jsx","hash":"c876d839409dc2a387ad391e1a4ca2c24557cf12","modified":1588170680653},{"_id":"themes/icarus/layout/common/comment.jsx","hash":"0ab94bbc55bda6f3f284cbd208efa4ed8205481c","modified":1587406360752},{"_id":"themes/icarus/layout/common/donates.jsx","hash":"c026449e4bc757fbd9edb5b870d56f7b7a349497","modified":1587406360752},{"_id":"themes/icarus/layout/common/footer.jsx","hash":"583a29899f56f278caf3afbe019a17e1ec7fc027","modified":1587406360768},{"_id":"themes/icarus/layout/common/head.jsx","hash":"98b0d280d28e0f9e9ac6fab0bb0b6c79e9900863","modified":1588011544672},{"_id":"themes/icarus/layout/common/navbar.jsx","hash":"59786a8510709ff43f2af0e01ff9715cdebc26fd","modified":1587406360768},{"_id":"themes/icarus/layout/common/plugins.jsx","hash":"fedab3e147ae1ed2d730a559c29e72b2315db5c1","modified":1587406360768},{"_id":"themes/icarus/layout/common/scripts.jsx","hash":"28418838ec8162e567572962f1df4f7bd9cb82df","modified":1587810986902},{"_id":"themes/icarus/layout/common/search.jsx","hash":"82a0cf309dbe5257f30c95621dd4e6521b912cbc","modified":1587406360768},{"_id":"themes/icarus/layout/common/share.jsx","hash":"ed9aba6def6515df79b77e231f8620b0e209e30c","modified":1587406360768},{"_id":"themes/icarus/layout/common/widgets.jsx","hash":"a91e3e772635cade1b05c289f5c6ba8400054708","modified":1588945758154},{"_id":"themes/icarus/layout/plugin/animejs.jsx","hash":"bd2b9209051a03e5cb3bdf2c97e6c16d0d75cb8a","modified":1587406360768},{"_id":"themes/icarus/layout/plugin/back_to_top.jsx","hash":"efff826b01ac0f8fc2619b6c43660ef8d6de6c3f","modified":1587406360768},{"_id":"themes/icarus/layout/widget/profile.jsx","hash":"7a739aa78b637512f6e08bc9c4f0cc347af4a6f4","modified":1587406360768},{"_id":"themes/icarus/source/js/.eslintrc.json","hash":"45c9014e02fbc516e257484487b4e29ddb5743e1","modified":1587406360784},{"_id":"themes/icarus/source/js/animation.js","hash":"5bb98c8b7e6fdde902f61e40ddfb2a3fbdeb13bf","modified":1587406360784},{"_id":"themes/icarus/source/js/back_to_top.js","hash":"6be1b206481d231ca93ff9b1ccb08c548618cfdf","modified":1587406360784},{"_id":"themes/icarus/source/js/main.js","hash":"34acf13d49dcca1d5e2393c4bfa459bcde40892a","modified":1587406360784},{"_id":"themes/icarus/source/images/Array_empty.JPG","hash":"21711b4e59eeac55e4d69eabfb26f180b2ad4495","modified":1587644602186},{"_id":"themes/icarus/source/images/ClassThisInstance.JPG","hash":"1262809219296d9d969b1ee406a5a615d24e4060","modified":1587282470025},{"_id":"themes/icarus/source/images/JavaScript-Data-Types.PNG","hash":"a47cf5aef481ec19dcc8c9269009c18a77ae5ee7","modified":1587282470025},{"_id":"themes/icarus/source/images/SymbolObj.JPG","hash":"04a6d93b1b9ec0f225c87528d5fb95d701e54e05","modified":1587282470025},{"_id":"themes/icarus/source/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1587406360784},{"_id":"themes/icarus/source/images/coffee-favicon.png","hash":"2561c83c17f98ff7b5f055946b281ceb0269b234","modified":1587282470025},{"_id":"themes/icarus/source/images/constructorInstance.JPG","hash":"af002b27e280fd984a1def5532fa4b58dfb4523c","modified":1587282470025},{"_id":"themes/icarus/source/images/context_callStack.png","hash":"771adc5943d257609b15b3a98905aa9dbe22303c","modified":1587979128415},{"_id":"themes/icarus/source/images/extendsObj.JPG","hash":"63b269b70ca63bfaf99eb3a331752aa695868b78","modified":1587282470025},{"_id":"themes/icarus/source/images/extendsSoccer.JPG","hash":"245dbae4b9e543050417034f68a5dd38ef188c1c","modified":1587282470025},{"_id":"themes/icarus/source/images/favicon.svg","hash":"50322629b1947588ff7a6e59fb07cb1b5bfb9f8c","modified":1587406360784},{"_id":"themes/icarus/source/images/logo.png","hash":"243ce59d8575e86703ec8e5c7e00d6a2f66a4b66","modified":1587282470041},{"_id":"themes/icarus/source/images/logo.svg","hash":"f4a9aa50f9a732981ae79e3711a997fc7325a7db","modified":1587406360784},{"_id":"themes/icarus/source/images/maengo.jpg","hash":"cb645ebd800efbfde73959b2a0d21e9c65f0cf95","modified":1587282470041},{"_id":"themes/icarus/source/images/newMapInstance.JPG","hash":"ef25bb55a6d10ac41b9014035d53bd67d3f757ed","modified":1587282470041},{"_id":"themes/icarus/source/images/promise.SVG","hash":"abbede10bf83d8996ecba4a8951a639e30e4aae3","modified":1587282470041},{"_id":"themes/icarus/source/images/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1587406360784},{"_id":"themes/icarus/source/images/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1587406360784},{"_id":"themes/icarus/source/images/rejectPromiseObj.JPG","hash":"5459c6f2e36fad0122034fa0ca40c4bd1309e739","modified":1587282470041},{"_id":"themes/icarus/source/images/resolvePromiseObj.JPG","hash":"729d8018400822ba7af155e61879d3d1530ce726","modified":1587282470041},{"_id":"themes/icarus/source/images/speciesArrayObj.JPG","hash":"77fdc7c7ed7a2be2390e863e31ed434731e5296c","modified":1587282470041},{"_id":"themes/icarus/source/images/sportsConsole.JPG","hash":"3a81cd01c63db62b6089a36865181fe391dd8324","modified":1587282470041},{"_id":"themes/icarus/source/images/template.png","hash":"7dcdd2d92748110bc6ead645732490aac7f258b3","modified":1587282470041},{"_id":"themes/icarus/source/images/thumbnail.svg","hash":"38801ce6b2f60c660e1b8868da902c9ab553c82f","modified":1587406360784},{"_id":"themes/icarus/source/images/tuna_blog.jpg","hash":"0daed9894c0d39d97f040bca5f875f16518215f0","modified":1587282470041},{"_id":"themes/icarus/source/images/tuna_blog.png","hash":"498c98efa32afb84861ec2dbb94a15f02f70dfdf","modified":1587282470041},{"_id":"themes/icarus/source/css/cyberpunk.styl","hash":"13b12c6024a67561a3678d1480113dfdf48f0269","modified":1587406360784},{"_id":"themes/icarus/source/css/default.styl","hash":"b2d886eacd43ab395ae3221e92bc0a9d23eff3a0","modified":1587406360784},{"_id":"themes/icarus/source/css/style.styl","hash":"4c1e1734d85fa68b3ebcb5347c32f79e443ddcba","modified":1587406360784},{"_id":"themes/icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1587406360681},{"_id":"themes/icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1587406360706},{"_id":"themes/icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1587406360706},{"_id":"themes/icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1587406360706},{"_id":"themes/icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1587406360706},{"_id":"themes/icarus/source/images/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1587406360784},{"_id":"themes/icarus/include/hexo/generator/category.js","hash":"ab6bd15ded796ea978166da480de56600af14787","modified":1587406360665},{"_id":"themes/icarus/include/hexo/generator/insight.js","hash":"58251b0393541836ae40da3ba32a3d6821b74163","modified":1587406360665},{"_id":"themes/icarus/include/schema/common/article.json","hash":"3e75eee5f3ae18661e9a0d75baf7b6021ed857a0","modified":1587464724792},{"_id":"themes/icarus/include/schema/common/comment.json","hash":"394665355c58e711ff9a739d1de047bb44588e72","modified":1587406360685},{"_id":"themes/icarus/include/schema/common/donates.json","hash":"4ea76783b0b039f05742287c101e0d11b113328c","modified":1587406360685},{"_id":"themes/icarus/include/schema/common/footer.json","hash":"b6036e21a11a5ed0455010ee668e43f165e55254","modified":1587406360689},{"_id":"themes/icarus/include/schema/common/head.json","hash":"cf95b825bfca5f1c03d066a4067bd42a7467a423","modified":1587406360689},{"_id":"themes/icarus/include/schema/common/navbar.json","hash":"52a7ae23ebcfb06e8c219be4da1506b824e17715","modified":1587406360693},{"_id":"themes/icarus/include/schema/common/plugins.json","hash":"1b4de5817363ad969b444477cda28eb677a2c0f7","modified":1587406360693},{"_id":"themes/icarus/include/schema/common/providers.json","hash":"5453827e1c267c67102bc983c8d2313865aa64fd","modified":1587406360693},{"_id":"themes/icarus/include/schema/common/search.json","hash":"dd34241b3776bc9aed8ef815c67f2fa622d0984b","modified":1587406360697},{"_id":"themes/icarus/include/schema/common/share.json","hash":"da98300e9197fbc717082419652d54636fd118b9","modified":1587406360697},{"_id":"themes/icarus/include/schema/common/sidebar.json","hash":"5687b24e32bcff12ff7660ff5dc26d74f466a994","modified":1587406360701},{"_id":"themes/icarus/include/schema/common/widgets.json","hash":"43a9c4fccaf75418038537e2e49f2457727a21e7","modified":1587406360701},{"_id":"themes/icarus/include/schema/plugin/animejs.json","hash":"0b5c4a315c0d25f2b296eb44ed14a1d59ccb8613","modified":1587406360706},{"_id":"themes/icarus/include/schema/plugin/back_to_top.json","hash":"c8e0e97a61c3a02c9736f303c206dd406de95d9a","modified":1587406360706},{"_id":"themes/icarus/include/schema/widget/profile.json","hash":"994aff115d59827ad6f98d03adf55b1cf1245378","modified":1587406360721},{"_id":"themes/icarus/source/images/blog_logo.png","hash":"da427880b8629201ed787810b5be6a269af6273e","modified":1587282470025},{"_id":"public/rss2.xml","hash":"71ead4eb4fc1aa28c7bf2d16e544404bd3528a97","modified":1588006978320},{"_id":"public/content.json","hash":"2f0f9da303828b3b84cea42dcc9d455ead53c734","modified":1588006978320},{"_id":"public/post-sitemap.xml","hash":"f5ad5a867b1e75e9fe05252d3f3daea792079bc5","modified":1588006978320},{"_id":"public/js/algolia.js","hash":"cbfc4355b23d84d2f0dc622e069b3f06c0d10f70","modified":1588006978320},{"_id":"public/js/google_cse.js","hash":"55e7250f4a12bf15220ba5d1d49c91fda5fbd3b4","modified":1588006978320},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1588006978320},{"_id":"public/sitemap.xml","hash":"fb8c2da7040a504883e0a676f8e31bae200260d0","modified":1588006978320},{"_id":"public/js/insight.js","hash":"78b74ae77f1e854089ccabd871d581dc391fcc29","modified":1588006978320},{"_id":"public/robots.txt","hash":"75dd0b423ccf4931a9e7dd971e2241338f2783eb","modified":1588006978320},{"_id":"public/archives/2020/02/index.html","hash":"4164d3e55f03d01bdfe8f3449b6f84cb6b2fe1f3","modified":1588006978320},{"_id":"public/archives/2020/03/page/4/index.html","hash":"a5ac3bebf39dfc12044d016520bb2edbe0dddf32","modified":1588006978320},{"_id":"public/archives/2020/04/page/2/index.html","hash":"64e0992a67466a03ff7c15571931f279c887d614","modified":1588006978320},{"_id":"public/categories/index.html","hash":"19a7de23092a5c28cdffe271b6a592481917682b","modified":1588006978320},{"_id":"public/2020/04/27/this-Core-JavaScript/index.html","hash":"5a5714b28ad0e2b02951ef01fcbebff018aa70b3","modified":1588006978320},{"_id":"public/2020/04/26/실행-컨텍스트-Core-JavaScript/index.html","hash":"ac609016fe60cd1ee0df88fbde48950376d65b6d","modified":1588006978320},{"_id":"public/2020/04/16/데이터 타입 -Core JavaScript/index.html","hash":"9a8946c77ac32d12e5febca2be3f8bad1c6ebaf3","modified":1588006978320},{"_id":"public/2020/04/14/WeakSet 오브젝트 -ECMAScript/index.html","hash":"78b7b514dfbcc2b1c9e7995b1f5f841c2554348d","modified":1588006978320},{"_id":"public/2020/04/14/Promise 오브젝트 -ECMAScript/index.html","hash":"d2029c59ff0060179ab072251f9f99dbcbae8a56","modified":1588006978320},{"_id":"public/2020/04/13/Set 오브젝트 -ECMAScript/index.html","hash":"21041ae530652b40eb1b9a371c0320caf482ca08","modified":1588006978320},{"_id":"public/2020/04/13/WeakMap 오브젝트 -ECMAScript/index.html","hash":"cbd64205c20ec76e60a2cb97e7e748a13c9c9ad1","modified":1588006978320},{"_id":"public/2020/04/10/Map 오브젝트 -ECMAScriprt/index.html","hash":"cfd73187a2369c36588163050328aa1f34f8d532","modified":1588006978320},{"_id":"public/2020/04/09/Symbol 메서드 -ECMAScript/index.html","hash":"52d66f47f9fcaf03ac7eb8d5c771bb1d20efadfa","modified":1588006978320},{"_id":"public/2020/04/06/Symbol 프로퍼티 -ECMAScript/index.html","hash":"520af15d3cbc8a664608202ef61623b2d3d768e2","modified":1588006978320},{"_id":"public/2020/04/01/Class 오브젝트 -ECMAScript/index.html","hash":"d8810c20081bab231e5dface8f34ecbf64edd836","modified":1588006978320},{"_id":"public/2020/04/06/Symbol 오브젝트 -ECMAScript/index.html","hash":"80afa9d4808b0b0be0cb391fdfe9b60918d69f1e","modified":1588006978320},{"_id":"public/2020/03/31/Generator 오브젝트 -ECMAScript/index.html","hash":"96dd13640b21a3cde89bfe7e662210c12084788e","modified":1588006978320},{"_id":"public/2020/03/30/Array 오브젝트 -ECMAScript/index.html","hash":"bcb99424d114ab0fec5c6a5c49b1beceb5c61767","modified":1588006978320},{"_id":"public/2020/03/29/Template 리터널 -ECMAScript/index.html","hash":"31c51417b166b1aaab1b7d434d0394f9abbb4db6","modified":1588006978320},{"_id":"public/2020/03/29/String 오브젝트 -ECMAScript/index.html","hash":"2928d57386ce8c25a3c4e7e7180d2651861e257d","modified":1588006978320},{"_id":"public/2020/03/29/Math 오브젝트 -ECMAScript/index.html","hash":"019d37011edc77926470146bc2efeaa05674812d","modified":1588006978320},{"_id":"public/2020/03/26/Number 오브젝트 -ECMAScript/index.html","hash":"ed7b28510381d5bdbe0216d5c883f87cba10cc62","modified":1588006978320},{"_id":"public/2020/03/22/ES6에 추가된 Operation -ECMAScript/index.html","hash":"a8f81907ed1a2879f2756479f0107965e0d4d944","modified":1588006978320},{"_id":"public/2020/03/23/Object 오브젝트 -ECMAScript/index.html","hash":"db7b597ca5d84dead213e4ecfd0c5db2067a6b8b","modified":1588006978320},{"_id":"public/2020/03/20/Destructuring -ECMAScript/index.html","hash":"96353f31cbc7eb42c359bd71eda52a32d36168a1","modified":1588006978320},{"_id":"public/2020/03/20/Spread 연산자 -ECMAScript/index.html","hash":"6bb950d499a3eaecebdb03fcb2b49224ca2b6f8e","modified":1588006978320},{"_id":"public/2020/03/18/Iteration -ECMAScript/index.html","hash":"8017744ce875f968fd08ffc00b9d895509bb2206","modified":1588006978320},{"_id":"public/2020/03/17/Arrow -ECMAScript/index.html","hash":"62cdbdf7b946dd8121b31ea2e94cedad946e4d7f","modified":1588006978320},{"_id":"public/2020/03/16/키워드, 블록 스코프 -ECMAScript/index.html","hash":"12581ee265aaf6fb3bedafa44b880b65c1915f9e","modified":1588006978320},{"_id":"public/2020/03/16/Strict mode -ECMAScript/index.html","hash":"19a7234a83f5a503e88d89d7fb5475454971caab","modified":1588006978320},{"_id":"public/2020/03/12/효과 및 애니메이션 -jQuery/index.html","hash":"7a2c6813e93c16f63f3de3dd82e9f4620e79b005","modified":1588006978320},{"_id":"public/2020/03/12/jQuery 이벤트 핸들러/index.html","hash":"99cb53712e4eafb66a6cf4eca8e916b392b72bf5","modified":1588006978320},{"_id":"public/2020/03/10/객체 조작 메서드 -jQuery/index.html","hash":"8b6bba508b7af74039e9bf275594afdb07287955","modified":1588006978320},{"_id":"public/2020/03/10/선택자 -jQuery/index.html","hash":"c1a6b4bdd8b9bfa3e153dae49bc0bb72c3520c94","modified":1588006978320},{"_id":"public/2020/03/10/this Keyword -JavaScript/index.html","hash":"e5d287f365015ee4aa4bd028edbced366358b213","modified":1588006978320},{"_id":"public/2020/03/09/이벤트 -JavaScript/index.html","hash":"4a021f8ee3b37cb7e1ed131a1df77b7d05e62376","modified":1588006978320},{"_id":"public/2020/03/09/Global Variable 전역변수 와 Local Variable 지역변수/index.html","hash":"4cf3d051935f497f57ab7f30bed20af5b3bde2fb","modified":1588006978320},{"_id":"public/2020/03/09/return 문, 재귀함수 호출 -JavaScript/index.html","hash":"7a2d5cabc263494f5926fd0558d4079c7c8fd8d5","modified":1588006978320},{"_id":"public/2020/03/09/function 함수 -JavaScript/index.html","hash":"0375a6e24d0ef852243e83418302c599006ed632","modified":1588006978320},{"_id":"public/2020/03/08/DOM 문서 객체 모델/index.html","hash":"1260843cf9537ac0ef877116796bdd7bf32e94e3","modified":1588006978320},{"_id":"public/2020/03/04/BOM 브라우저 객체 모델/index.html","hash":"a97575a90ca0129c0e83c6c3ab0ca2d79a74f781","modified":1588006978320},{"_id":"public/2020/03/03/RegExp 정규표현 객체 -JavaScript/index.html","hash":"a83cdbf2a41e0a249ca6fb968420a235374cd6fe","modified":1588006978320},{"_id":"public/2020/03/02/String 문자 객체 -JavaScript/index.html","hash":"c675a066f4ec4b80d6c9fc41fcf1118969ec009d","modified":1588006978320},{"_id":"public/2020/03/02/Array 배열 객체 -JavaScript/index.html","hash":"9fac1d4019911e37bf07da1ea887e18523fe6eb7","modified":1588006978320},{"_id":"public/2020/03/02/수학 객체 -JavaScript/index.html","hash":"dfccdd7bb1200d89136d2dcfe7db39bf109b5e2e","modified":1588006978320},{"_id":"public/2020/03/02/숫자 객체 -JavaScript/index.html","hash":"af2e5a33ef3437ad820dcb12317b5993106af964","modified":1588006978320},{"_id":"public/2020/03/02/날짜 객체 메서드/index.html","hash":"a6d669aefdf2f0f3bcdc34e8f968f028f204fe93","modified":1588006978320},{"_id":"public/2020/02/25/자바스크립트 선택문/index.html","hash":"e13d2534c3ef88fca076a3bb574cac14f5bd2aa9","modified":1588006978320},{"_id":"public/2020/02/24/자바스크립트 조건문/index.html","hash":"8ef051b8dcf80b1e15e808ff3da7393b1b7d6a7b","modified":1588006978320},{"_id":"public/2020/02/24/자바스크립트 연산자/index.html","hash":"4f44b5e388717c0e7fd959b51e5cf7734d1dcd22","modified":1588006978320},{"_id":"public/2020/02/23/자바스크립트 기초 문법/index.html","hash":"a7b98c79a96b39f901a1cd645cdfdfaff4b59cbf","modified":1588006978320},{"_id":"public/archives/index.html","hash":"10db1c358889f68122015e21e3ed344fc552efb7","modified":1588006978320},{"_id":"public/archives/page/2/index.html","hash":"3984897387a214548c24b71fc89e95fefd3b4c5c","modified":1588006978320},{"_id":"public/archives/page/3/index.html","hash":"08ef16254f131a12f0a12953f116b2a70d3afbaf","modified":1588006978320},{"_id":"public/archives/page/4/index.html","hash":"ba2665511d10bdc364fbdf3570e8e51d1eef8965","modified":1588006978320},{"_id":"public/archives/page/5/index.html","hash":"5a19732defdd790dbdd25be02cb463bbbb84e037","modified":1588006978320},{"_id":"public/archives/2020/index.html","hash":"5c6f68fd5af0ee20284c7222fd02f9ade0792243","modified":1588006978320},{"_id":"public/archives/2020/page/2/index.html","hash":"49e22201436c60739ec75d8bd48dcade5434fa93","modified":1588006978320},{"_id":"public/archives/2020/page/3/index.html","hash":"71c1be1504f38ea46d8785e5802f11e9922fc4cc","modified":1588006978320},{"_id":"public/archives/2020/page/4/index.html","hash":"3cb075465b6213e1cc9615682c5f1f84075d51c0","modified":1588006978320},{"_id":"public/archives/2020/page/5/index.html","hash":"de1cbadafe983573160453521e148671f2c2c41f","modified":1588006978320},{"_id":"public/archives/2020/03/index.html","hash":"4b274409f0f1ce1ee13cada40da1c7d6860494a3","modified":1588006978320},{"_id":"public/archives/2020/03/page/2/index.html","hash":"77e175a9c51d0e2d6e75c15c174b506c1281f72a","modified":1588006978320},{"_id":"public/archives/2020/03/page/3/index.html","hash":"6691d67e17c6e74ee1c72bf60c88ecdb08892114","modified":1588006978320},{"_id":"public/archives/2020/04/index.html","hash":"3757225fc4ff1f39a94c0ee89e9d823f8d4f8194","modified":1588006978320},{"_id":"public/categories/ECMAScript6/index.html","hash":"f4cacece7f21f8711b416c810a5045ebecd3e8ef","modified":1588006978320},{"_id":"public/categories/ECMAScript6/page/2/index.html","hash":"25bfc12cc568e57e2965524dda989509b6c3bdeb","modified":1588006978320},{"_id":"public/categories/ECMAScript6/page/3/index.html","hash":"91d76d48f527bd1a050306c9a09e0bc054938ddf","modified":1588006978320},{"_id":"public/categories/JavaScript/index.html","hash":"02bb5ea7ad703dcf8607ab5e2b459e0fd236692f","modified":1588006978320},{"_id":"public/categories/JavaScript/page/2/index.html","hash":"9610fc66ec6808be96865334af20005fb7828cb9","modified":1588006978320},{"_id":"public/categories/jQuery/index.html","hash":"5b787a718467360f0a41f954d145cb7cba789637","modified":1588006978320},{"_id":"public/categories/Core-JavaScript/index.html","hash":"86ae0c55f14b19188966e7b8e14038b43e07c361","modified":1588006978320},{"_id":"public/page/2/index.html","hash":"2cff4b0ea39aebcad89421cf69598c81930a3cb8","modified":1588006978320},{"_id":"public/index.html","hash":"b12492aaadb7d0d6c55d9a692e1f8d6f88d805f5","modified":1588006978320},{"_id":"public/page/3/index.html","hash":"971370b28eb2e87c28212574da1aa39126359557","modified":1588006978320},{"_id":"public/page/4/index.html","hash":"92b0ee7ecb172e2d9d2d6f48889369b36e8d4b69","modified":1588006978320},{"_id":"public/page/5/index.html","hash":"c0f5da0c0e411f0ad97d71ab1fc148d96a71c424","modified":1588006978320},{"_id":"public/tags/ECMAScript6/index.html","hash":"f967694343b4396dce8c2b2ba58ac027023b82ea","modified":1588006978320},{"_id":"public/tags/ECMAScript6/page/2/index.html","hash":"2ab5f79df2880f9def50e1784d0c8582637859dc","modified":1588006978320},{"_id":"public/tags/ECMAScript6/page/3/index.html","hash":"5f77178ffd4683e10be2f2201ffc78a8127cacba","modified":1588006978320},{"_id":"public/tags/JavaScript/index.html","hash":"1e7445075d639c855b26d9d983d63c9f8e30e8a0","modified":1588006978320},{"_id":"public/tags/JavaScript/page/2/index.html","hash":"6ba39f77d20350bb5410b7816c11bda66b0bf155","modified":1588006978320},{"_id":"public/tags/JavaScript/page/3/index.html","hash":"b763bf4ae9d6c51efcbecdd1dd7315cd65d0fce1","modified":1588006978320},{"_id":"public/tags/JavaScript/page/4/index.html","hash":"f7fa333dcc515a9f3e6646fed1bc8e86cba77356","modified":1588006978320},{"_id":"public/tags/JavaScript/page/5/index.html","hash":"8f3ed196c3a56d5962364facb8d46932330efe78","modified":1588006978320},{"_id":"public/tags/jQuery/index.html","hash":"ea3b085ad22a8f340d08bfdcb92982afee8faeee","modified":1588006978320},{"_id":"public/tags/Core-JavaScript/index.html","hash":"6e356fa5eaef9d29d40125c7f46fc40bb17ef6b6","modified":1588006978320},{"_id":"public/tags/index.html","hash":"79ecfcc26f6eb4354f5cbb58239d4c9ed35ffa1a","modified":1588006978320},{"_id":"public/images/Array_empty.JPG","hash":"21711b4e59eeac55e4d69eabfb26f180b2ad4495","modified":1588006978320},{"_id":"public/images/ClassThisInstance.JPG","hash":"1262809219296d9d969b1ee406a5a615d24e4060","modified":1588006978320},{"_id":"public/images/JavaScript-Data-Types.PNG","hash":"a47cf5aef481ec19dcc8c9269009c18a77ae5ee7","modified":1588006978320},{"_id":"public/images/SymbolObj.JPG","hash":"04a6d93b1b9ec0f225c87528d5fb95d701e54e05","modified":1588006978320},{"_id":"public/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1588006978320},{"_id":"public/images/coffee-favicon.png","hash":"2561c83c17f98ff7b5f055946b281ceb0269b234","modified":1588006978320},{"_id":"public/images/constructorInstance.JPG","hash":"af002b27e280fd984a1def5532fa4b58dfb4523c","modified":1588006978320},{"_id":"public/images/context_callStack.png","hash":"771adc5943d257609b15b3a98905aa9dbe22303c","modified":1588006978320},{"_id":"public/images/extendsObj.JPG","hash":"63b269b70ca63bfaf99eb3a331752aa695868b78","modified":1588006978320},{"_id":"public/images/extendsSoccer.JPG","hash":"245dbae4b9e543050417034f68a5dd38ef188c1c","modified":1588006978320},{"_id":"public/images/favicon.svg","hash":"50322629b1947588ff7a6e59fb07cb1b5bfb9f8c","modified":1588006978320},{"_id":"public/images/logo.svg","hash":"f4a9aa50f9a732981ae79e3711a997fc7325a7db","modified":1588006978320},{"_id":"public/images/logo.png","hash":"243ce59d8575e86703ec8e5c7e00d6a2f66a4b66","modified":1588006978320},{"_id":"public/images/maengo.jpg","hash":"cb645ebd800efbfde73959b2a0d21e9c65f0cf95","modified":1588006978320},{"_id":"public/images/newMapInstance.JPG","hash":"ef25bb55a6d10ac41b9014035d53bd67d3f757ed","modified":1588006978320},{"_id":"public/images/promise.SVG","hash":"abbede10bf83d8996ecba4a8951a639e30e4aae3","modified":1588006978320},{"_id":"public/images/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1588006978320},{"_id":"public/images/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1588006978320},{"_id":"public/images/rejectPromiseObj.JPG","hash":"5459c6f2e36fad0122034fa0ca40c4bd1309e739","modified":1588006978320},{"_id":"public/images/speciesArrayObj.JPG","hash":"77fdc7c7ed7a2be2390e863e31ed434731e5296c","modified":1588006978320},{"_id":"public/images/resolvePromiseObj.JPG","hash":"729d8018400822ba7af155e61879d3d1530ce726","modified":1588006978320},{"_id":"public/images/sportsConsole.JPG","hash":"3a81cd01c63db62b6089a36865181fe391dd8324","modified":1588006978320},{"_id":"public/images/template.png","hash":"7dcdd2d92748110bc6ead645732490aac7f258b3","modified":1588006978320},{"_id":"public/images/tuna_blog.jpg","hash":"0daed9894c0d39d97f040bca5f875f16518215f0","modified":1588006978320},{"_id":"public/images/thumbnail.svg","hash":"38801ce6b2f60c660e1b8868da902c9ab553c82f","modified":1588006978320},{"_id":"public/images/tuna_blog.png","hash":"498c98efa32afb84861ec2dbb94a15f02f70dfdf","modified":1588006978320},{"_id":"public/images/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1588006978320},{"_id":"public/js/back_to_top.js","hash":"0f071e2331e39043529041322c4812bb13a3990d","modified":1588006978320},{"_id":"public/js/main.js","hash":"3fb6be34945798cd400825e021c4267856fff2df","modified":1588006978320},{"_id":"public/js/animation.js","hash":"59a05568fd5718513792b0d48bcb4bcf7eaa20e8","modified":1588006978320},{"_id":"public/css/cyberpunk.css","hash":"13c1d805ca20b63a5837df489329a2f51dbc30db","modified":1588006978320},{"_id":"public/css/default.css","hash":"2e0657de821c33fbeaf88258d4fc2b13308e2cbc","modified":1588006978320},{"_id":"public/css/style.css","hash":"2e0657de821c33fbeaf88258d4fc2b13308e2cbc","modified":1588006978320},{"_id":"public/images/blog_logo.png","hash":"da427880b8629201ed787810b5be6a269af6273e","modified":1588006978320},{"_id":"source/_posts/콜백-함수-Core-JavaScript.md","hash":"85592194f7d2a363edb3b1c62090c36f9b233550","modified":1588337434807},{"_id":"source/_posts/클로저-Core-JavaScript.md","hash":"553012856d7922fec8e4725e59cd26c38a5b8fda","modified":1588599642819},{"_id":"source/_posts/prototype-Core-JavaScript.md","hash":"90fa6a0117b4395d7c14dd784080f9aefcd24dca","modified":1588940912794},{"_id":"themes/icarus/source/images/prototype_Array_schematic.png","hash":"3c34c541e3855685fbad287e82e340d54602474a","modified":1588669015448},{"_id":"themes/icarus/source/images/prototype_Instance.png","hash":"217b220f787c4ccca0a4c5b5c585c9fa68e3cd8f","modified":1588757098196},{"_id":"themes/icarus/source/images/prototype_schematic.png","hash":"bf702b3cd5b3af02d14da0d80c08af33279e0081","modified":1588668988817},{"_id":"themes/icarus/source/images/prototype_schematic2.png","hash":"ccb3cd3328b84f713281cbb7871a8a7e9ad48204","modified":1588669003452},{"_id":"themes/icarus/source/images/prototype_Constructor.png","hash":"23b89aa12a307add2926cdbde2b8b31940f56979","modified":1588757143441},{"_id":"themes/icarus/source/images/prototype_arr_Array.png","hash":"4fd810843315200662aae88040aec02223a38666","modified":1588760564092},{"_id":"themes/icarus/source/images/객체의_최상위_객체_Object.png","hash":"9d4db4e3f58ab2ef69002d0a4de3f8086c6d1877","modified":1588935099690}],"Category":[{"name":"ECMAScript6","_id":"ck9iqcrrp0002qgvqc9ydcz9y"},{"name":"JavaScript","_id":"ck9iqcrrt0007qgvqbbuy2wju"},{"name":"jQuery","_id":"ck9iqcrt8002jqgvq5o088r4q"},{"name":"Core JavaScript","_id":"ck9iqcrtb002tqgvqd1rx4bt1"}],"Data":[],"Page":[],"Post":[{"title":"Array 오브젝트 -ECMAScript","date":"2020-03-29T22:55:37.000Z","disqusId":"tunas-blog-1","_content":"\nES6에서 Array오브젝트에 9개의 메서드가 추가되었습니다.  \n추가된 메서드를 살펴봅니다.\n\n*   Array 오브젝트\n    *   [from(): Array 오브젝트 생성](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_from)\n    *   [of(): 배열 엘리먼트 설정](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_of)\n    *   [copyWithin(): 범위 값 복사, 설정](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_copyWithin)\n    *   [fill(): 범위 값 변경](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_fill)\n    *   [entries(): 이터레이터 오브젝트 생성](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_enteries)\n    *   [keys(): key 이터레이터 오브젝트 생성](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_keys)\n    *   [values(): value 이터레이터 오브젝트 생성](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_values)\n    *   [find(): 엘리먼트 값 비교, 반환](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_find)\n    *   [findIndex(): 배열 인덱스 반환](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_findeIndex)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Array_from\">from(): Array 오브젝트 생성</h2>\n\n새로운 Array 오브젝트를 생성하고 콜백 함수에서 반환된 값을 엘리먼트 값으로 설정하여 새로운 Array 객체를 반환합니다.\n\n> Array.from(arrayLike[, mapFn[, thisArg]])\n\n*   arrayLike  \n    배열로 변환하고자 하는 유사 배열 객체(Array-like)나 반복 가능한 객체(이터러블 오브젝트).\n    \n*   mapFn (선택적 파라미터)  \n    배열의 모든 엘리먼트 마다 호출할 함수.\n    \n*   thisArg (선택적 파라미터)  \n    두 번째 파라미터 함수 실행 시에 this로 참조할 값.\n    \n*   반환 값  \n    새로운 Array 인스턴스.\n    \n\n### 중요 포인트\n\n다음과 같은 경우에 Array.from()으로새Array를 만들 수 있습니다.\n\n*   유사 배열 객체 (length 속성과 인덱싱된 요소를 가진 객체)\n*   순회 가능한 객체 (Map, Set 등객체의 요소를 얻을 수 있는 객체)\n\nArray.from()은 선택 매개변수인 mapFn를 가지는데,배열(혹은 배열 서브클래스)의 각 요소를 맵핑할 때 사용할 수 있습니다. 즉,Array.from(obj, mapFn, thisArg)는 중간에 다른 배열을 생성하지 않는다는 점을 제외하면Array.from(obj).map(mapFn, thisArg)와 같습니다. 이 특징은 typed arrays와 같은 특정 배열 서브클래스에서 중간 배열 값이 적절한 유형에 맞게 생략되기 때문에 특히 중요합니다.\n\nfrom() 메서드의 length 속성은 1입니다.\n\nES2015 이후, 클래스 구문은 내장 및 새 클래스의 상속을 가능케 했습니다. 그 결과로 Array.from과 같은 정적 메서드는 Array의 서브클래스에 의해 상속되며, Array 대신 자신의 인스턴스를 만듭니다.\n\n```js 예제1\n1. let arrayObj = Array.from({0: \"zero\", 1: \"one\", length: 2});  \nconsole.log(Array.isArray(arrayObj));  \nconsole.log(arrayObj);  \n  \n2. let stringObj = Array.from(\"ABC\");  \nconsole.log(stringObj);  \n  \n// true  \n// [\"zero\",\"one\"]  \n// [\"A\", \"B\", \"C\"]  \n```\n\n1.  Array.from() 첫 번째 파라미터에 Array-like 오브젝트를 작성했습니다.  \n    새로운 Array 오브젝트를 생성하고 Array-like 오브젝트의 프로퍼티 값을 배열에 추가하여 반환합니다. {0:”zero”, 1:”one”, length: 2}에서 프로퍼티 키와 length 프로퍼티를 제외한 “zero” 와 “one”이 생성된 Array 오브젝트에 추가됩니다.\n\n2.  Array.from() 파라미터 “ABC” 를 생성한 Array 오브젝트 배열의 엘리먼트에 하나씩 설정하여 반환합니다. 즉[“A”, “B”, “C”] 형태로 반환합니다.\n\n```js 예제2\nlet arrayLike = {0: 10, 1: 30, length: 2};  \nlet values = Array.from(arrayLike, function(value) {  \n return value + this.bonus;  \n}, {bonus: 100});  \nconsole.log(values);  \n// [110, 130]  \n```\n\nArray-like 오브젝트의 프로퍼티를 하나씩 읽어 갑니다.  \n프로퍼티를 읽을 때 마다 콜백 함수를 호출 합니다.  \n읽은 프로퍼티 값이 콜백 함수의 value 파라미터에 설정됩니다.  \n콜백 함수에서 this로 from()의 세 번째 파라미터에 지정한 오브젝트를 참조할 수 있습니다. Array-like 오브젝트의 length 프로퍼티는 참조되지 않습니다.\n\n1.  첫 번째 파라미터의 첫 번째 프로퍼티 값은 10 이며  \n    두 번째 파라미터 콜백 함수의 value 파라미터에 설정됩니다.  \n    this.bonus는 bonus 값을 참조합니다.\n\n2.  value + this.bonus는 110이 반환되고 생성된 Array 배열에 추가됩니다.\n\n3.  두 번째 프로퍼티 값인 30도 같은 방법으로 처리되고 최종적으로 생성된 배열을 반환합니다.\n\n### 그외 예제\n\n*   Set에서 배열 만들기\n```js    \nconst s = new Set([‘foo’, window]);  \nArray.from(s);  \n// [“foo”, window]\n```\n\n*   Map에서 배열 만들기\n```js    \nconst m = new Map([[1, 2], [2, 4], [4, 8]]);  \nArray.from(m);  \n// [[1, 2], [2, 4], [4, 8]]\n\nconst mapper = new Map([[‘1’, ‘a’], [‘2’, ‘b’]]);  \nArray.from(mapper.values());  \n// [‘a’, ‘b’];\n\nArray.from(mapper.keys());  \n// [‘1’, ‘2’];\n```\n    \n*   배열 형태를 가진 객체(arguments)에서 배열 만들기\n```js    \nfunction f() {  \nreturn Array.from(arguments);  \n}  \nf(1, 2, 3);  \n// [1, 2, 3]\n```\n\n*   Array.from과 화살표 함수 사용하기\n```js    \nArray.from([1, 2, 3], x => x + x);  \n// [2, 4, 6]\n\n// 숫자생성  \n// Array는 초기화 될때 각 위치마다 ‘undefined’값으로 초기화 됩니다.  \n// 아래의 v 의 value 값은 undefined 가 될 것입니다.  \nArray.from({length: 5}, (v, i) => i);  \n// [0, 1, 2, 3, 4]\n```    \n\n* * *\n\n<h2 id=\"Array_of\">of(): 배열 엘리먼트 설정</h2>\n\n파라미터 값을 새로운 배열의 엘리먼트로 설정하여 반환합니다.\n\n> Array.of(element0[, element1[, …[, elementN]]])\n\n*   매개변수  \n    elementN  \n    배열을 생성할 때 사용할 엘리먼트.\n    \n*   반환 값  \n    새로운 Array 객체.\n    \n```js\nlet arrayObj = Array.of(1, 2, 3);  \nconsole.log(arrayObj);  \n/// [1, 2, 3]  \n```\n\nArray.of() 파라미터에 새로운 배열의 엘리먼트에 설정할 값을 작성합니다.  \n콤마로 구분하여 다수를 작성할 수 있습니다.  \nArray.of()가 호출되면 우선 Array 오브젝트를 생성합니다. 이어서 파라미터에 작성한 순서대로 Array 오브젝트에 추가한 후, 반환합니다.\n\n*   Array.from()은 파라미터에 Array-like 또는 이터러블 오브젝트를 지정하지만,  \n    Array.of()는 파라미터에 값을 지정합니다.\n\n*   Array.of()와 Array 생성자의 차이는 정수형 인자의 처리 방법에 있습니다.  \n    Array.of(7)은 하나의 요소 7을 가진 배열을 생성하지만  \n    Array(7)은 length 속성이 7인 빈 배열을 생성합니다.\n\n```js Array.of\nArray.of(7);       // [7]   \nArray.of(1, 2, 3); // [1, 2, 3]  \n  \nArray(7);          // [ , , , , , , ]  \nArray(1, 2, 3);    // [1, 2, 3]  \n```\n\n* * *\n\n<h2 id=\"copyWithin\">copyWithin(): 범위 값 복사, 설정</h2>\n\ncopyWithin() 메서드는 배열의 일부를 인덱스 범위의 값을 복사하여, 동일한 배열의 지정한 위치에 덮어쓰고 그 배열을 반환합니다. 이 때, 배열의 길이를 수정하지 않고 반환합니다.\n\n> Array.copyWithin(target[, start[, end]])\n\n*   target  \n    복사한 값을 설정할 시작 인덱스. 음수를 지정하면 인덱스를 배열의 끝에서부터 계산합니다.  \n    target이 arr.length보다 크거나 같으면 아무것도 복사하지 않습니다.  \n    target이 start 이후라면 복사한 시퀀스를 arr.length에 맞춰 자릅니다.\n\n*   start (선택적 파라미터)  \n    복사를 시작할 위치를 가리키는 0 기반 인덱스.  \n    음수를 지정하면 인덱스를 배열의 끝에서부터 계산합니다.  \n    기본값은 0으로, start를 지정하지 않으면 배열의 처음부터 복사합니다.\n\n*   end (선택적 파라미터)  \n    복사를 끝낼 위치를 가리키는 0 기반 인덱스.  \n    copyWithin은 end 인덱스 이전까지 복사하므로  \n    end 인덱스가 가리키는 요소는 제외합니다. 음수를 지정하면 인덱스를 배열의 끝에서부터 계산합니다.  \n    기본값은 arr.length로, end를 지정하지 않으면 배열의 끝까지 복사합니다.\n\n*   반환 값  \n    수정한 배열.\n\n### 중요 포인트\n\ncopyWithin은 C와 C++의 memmove처럼 작동하고, 복사와 대입이 하나의 연산에서 이루어지므로 Array의 데이터를 이동할 때 사용할 수 있는 고성능 메서드입니다. TypedArray의 동명 메서드에서 이 특징이 두드러집니다. 붙여넣은 시퀀스의 위치가 복사한 범위와 겹치더라도 최종 결과는 원본 배열에서 복사한 것과 같습니다.\n\ncopyWithin 함수는 [제네릭 함수](https://heecheolman.tistory.com/67)로, this 값이 Array 객체일 필요는 없습니다.\n\ncopyWithin 메서드는 변경자 메서드로, this의 길이는 바꾸지 않지만 내용을 바꾸며 필요하다면 새로운 속성을 생성합니다.\n\n```js\n1. let one = [1, 2, 3, 4, 5];  \nconsole.log(one.copyWithin(0, 3));  \n  \n2. let two = [1, 2, 3, 4, 5];  \nconsole.log(two.copyWithin(0, 2, 4));  \n  \n3. let three = [1, 2, 3, 4, 5];  \nconsole.log(three.copyWithin(3));  \n// [4, 5, 3, 4, 5]  \n// [3, 4, 3, 4, 5]  \n// [1, 2, 3, 1, 2]  \n```\n\n1.  copyWithin() 두 번째 파라미터에 지정한 인덱스 3부터 배열의 끝까지 엘리먼트 값을 복사하여 첫 번째 파라미터 값인 인덱스 0부터 차례대로 설정합니다. 4와 5를 인덱스 0 부터 설정하므로 [1, 2]가 [4, 5]로 대체되어 [4, 5, 3, 4, 5]가 됩니다.\n\n2.  두 번째 파라미터 값인 인덱스 2부터 세 번째 파라미터 값인 인덱스 4 직전까지 엘리먼트 값을 복사항 첫 번째 파라미터 값인 인덱스 0부터 차례대로 설정합니다.  \n    3과 4를 인덱스 0부터 설정하므로 [1, 2]가 [3, 4]로 대체되어 [3, 4, 3, 4, 5]가 됩니다.\n\n3.  두 번째와 세 번째 파라미터를 작성하지 않았으므로 배열 전체를 복사하여  \n    인덱스 3부터 설정합니다. 복사할 엘리먼트 수는 5이지만, 설정 할수 있는 엘리먼트의 수는 두 개 입니다. [4, 5]에 [1, 2]가 설정되고 나머지 [3, 4, 5]는 설정되지 않습니다. 즉 [1, 2, 3, 1, 2]가 출력됩니다.\n\n```js Array-like\nlet arrayLike = {0: \"ABC\", 1: \"DEF\", 2: \"가나다\", length: 3};  \n1. let one = Array.prototype.copyWithin.call(arrayLike, 0, 1);  \nconsole.log(one);  \n  \n2. function two() {  \n return Array.prototype.copyWithin.call(arguments, 3, 0, 2);  \n};  \nconsole.log(two(1, 2, 3, 4, 5));  \n/*  \nObject  \n0: \"DEF\"  \n1: \"가나다\"  \n2: \"가나다\"  \nlength: 3  \n  \nArguments(5)  \ncallee: (...)  \n0: 1  \n1: 2  \n2: 3  \n3: 1  \n4: 2  \nlength: 5  \n*/  \n```\n\nArray-like 는 배열이 아닌 오브젝트이므로 Array.copyWithin()형태로 호출할 수 없습니다. 하지만 위와 같이 call()을 호출하면서 첫 번째 파라미터에 Array-like를 지정하면 copyWithin()이 호출됩니다.\n\n1.  arrayLike 오브젝트의 프로퍼티 키인 0,1,2를 배열의 인덱스로 사용합니다.  \n    세 번째 파라미터인 인덱스 1 부터 끝까지 복사하여 [“DEF”,”가나다”] 가  \n    인덱스 0,1 값과 대체됩니다. {0: “DEF”, 1: “가나다”, 2: “가나다”, length: 3}\n\n2.  호출한 함수에서 넘겨준 파라미터 값이 arguments에 설정됩니다. arguments가 Array-ike 오브젝트 이므로 call()의 첫 번째 파라미터에 지정하면 copyWithin()을 호출할 수 있습니다. 인덱스 0 부터 인덱스 2 이전까지 복사합니다 [1, 2]  \n    이를 인덱스 3부터 설정하여 인덱스 3,4의 값이 대체됩니다. [1, 2, 3, 1, 2]\n\n* * *\n\n<h2 id=\"Array_fill\">fill(): 범위 값 변경</h2>\n\n같은 배열에서 인덱스 범위의 값을 하나의 지정한 값으로 바꾸어 반환합니다.\n\n> array.fill(value[, start[, end]])\n\n*   value  \n    배열을 채울 값.\n    \n*   start (선택적 파라미터)  \n    시작 인덱스, 기본 값은 0.\n    \n*   end (선택적 파라미터)  \n    범위 끝 인덱스, 기본 값은 this.length.\n    \n*   반환 값  \n    변형한 배열.\n    \n\n### 중요 포인트\n\n*   start가 음수이면 시작 인덱스는 [length + start]입니다. end가 음수이면 끝 인덱스는 [length + end]입니다.\n\n*   fill은 일반 함수이며, this 값이 배열 객체일 필요는 없습니다.\n\n*   fill 메서드는 변경자 메서드로, 복사본이 아니라 this 객체를 변형해 반환합니다.  \n    value에 객체를 받을 경우 그 참조만 복사해서 배열을 채웁니다.\n\n```js\nlet one = [1, 2, 3];  \n1. console.log(one.fill(7));  \n  \nlet two = [1, 2, 3, 4, 5];  \n2. console.log(two.fill(7, 1));  \n  \nlet three = [1, 2, 3, 4, 5];  \n3. console.log(three.fill(7, 1, 3));  \n// [7, 7, 7]  \n// [1, 7, 7, 7, 7]  \n// [1, 7, 7, 4, 5]  \n```\n\n1.  범위를 지정해 주지 않았으므로 배열 전체가 변경 대상이 됩니다.  \n    첫 번째 파라미터 7이 변경할 값이 되어 [7, 7, 7]로 변경됩니다.\n\n2.  두 번째 파라미터 인덱스 값1 부터 배열 끝까지가 변경 대상이 됩니다.  \n    [1, 7, 7, 7, 7]로 변경됩니다.\n\n3.  두 번째 파라미터 인덱스 값1 부터 세 번째 파라미터 인덱스 3이전 까지가 변경 대상입니다. [2, 3]이 7로 변경되어 [1, 7, 7, 4, 5]이 됩니다.\n\n* * *\n\n<h2 id=\"Array_enteries\">entries(): 이터레이터 오브젝트 생성</h2>\n\nArray오브젝트를 이터레이터 오브젝트로 생성하여 반환합니다.\n\n> Array.entries()\n\n*   반환값 iterator\n\n```js entries\nlet values = [10, 20, 30];  \n// Array 오브젝트로 이터레이터 오브젝트를 생성해 반환합니다.  \n1. let iterator = values.entries();  \nconsole.log(iterator.next());  \n  \n2. for (var [key, value] of iterator){  \n console.log(key, \":\", value);  \n};  \n/* Object   \n{value: Array(2)  \n [ {0: 0},  \n {1: 10} ],  \n done: false}  \n1: 20  \n2: 30  \n*/  \n```\n\n1.  iterator 오브젝트의 next()를 호출 하면 {value: (2),done: false} 형태를 반환합니다. 배열의 인덱스와 엘리먼트가 프로퍼티 형태로 되기 때문입니다.  \n    [{0: 0}, {1: 10}]\n\n2.  이터레이터 오브젝트는 for-of문에 [key: value]형태로 키와 값을 동시에 작성할 수 있습니다. 실행 결과에 “0: 10”이 출력되지 않는 것은 바로 앞의 next()에서 이터레이션 처리를 하였기 때문입니다. 따라서 for-of문은 두 번째 인덱스부터 처리되었습니다.\n\n* * *\n\n<h2 id=\"Array_keys\">keys(): key 이터레이터 오브젝트 생성</h2>\n\nkey만 갖는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n배열의 인덱스를 key 값으로 사용하여 이터레이터 오브젝트를 생성합니다.  \n배열의 엘리먼트 값은 이터레이터 오브젝트에 포함되지 않습니다.\n\n```js\nlet iterator = [10, 20, 30].keys();  \nfor (var key of iterator){  \n console.log(key, \":\", iterator[key]);  \n};  \n/*  \n0 \":\" undefined  \n1 \":\" undefined  \n2 \":\" undefined  \n*/  \n```\n\n[10, 20, 30].keys()로 이터레이터 오브젝트를 생성하면  \n**인덱스 0, 1, 2만 설정되고 엘리먼트 값 [10, 20, 30]은 설정되지 않습니다.**  \nvalue 값에 undefined가 출력됩니다.\n\n`for(var[key, value] of iterator){}와 같이 [key, value]를 작성하면 TypeError가 발생하므로 key만 작성해야 합니다.`\n\n* * *\n\n<h2 id=\"Array_values\">values(): value 이터레이터 오브젝트 생성</h2>\n\nvalue만 갖는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n배열 엘리먼트 값으로 이터레이터 오브젝트를 생성합니다.  \n배열 인덱스는 이터레이터 오브젝트에 포함되지 않습니다.  \nSymbol.iterator()와 같습니다.\n\n```js\n// 크롬 52~54, 파이어폭스 47~49 지원하지 않음  \nlet iterator = [10, 20, 30].values();  \n1. console.log(iterator.next());  \n2. console.log(iterator.next());  \n3. console.log(iterator.next());  \n4. console.log(iterator.next());  \n/*  \n1.Object  \nvalue: 10  \ndone: false  \n  \n2.Object  \nvalue: 20  \ndone: false  \n  \n3.Object  \nvalue: 30  \ndone: false  \n  \n4.Object  \nvalue: undefined  \ndone: true  \n*/  \n```\n\nfor-of 루프 반복을 사용 하려면.  \n브라우저가 for-of 루프와 for 루프안에 let 스코프 변수를 지원해야 합니다.\n\n* * *\n\n<h2 id=\"Array_find\">find(): 엘리먼트 값 비교, 반환</h2>\n\nfind() 메서드는 주어진 콜백 함수를 만족하는(true 값) 첫 번째 엘리먼트의 값을 반환합니다. 그런 요소가 없다면 undefined를 반환합니다.\n\n> Array.find(callback[, thisArg])\n\n*   callback  \n    배열의 각 값에 대해 실행할 함수. 아래의 세 인자를 받습니다.\n    \n    *   element  \n        콜백함수에서 처리할 현재 엘리먼트.\n        \n    *   index  \n        콜백함수에서 처리할 현재 엘리먼트의 인덱스.\n        \n    *   array  \n        find 함수를 호출한 배열.\n        \n\n*   thisArg (선택적 파라미터)  \n    콜백이 호출될 때 this로 사용할 객체.\n\n*   반환 값  \n    주어진 판별 함수를 만족하는 첫 번째 요소의 값. 그 외에는 undefined.\n\n### 중요 포인트\n\n*   find 메서드는 callback 함수가 참을 반환 할 때까지 해당 배열의 각 요소에 대해서 callback 함수를 실행합니다. 만약 어느 요소를 찾았다면 find 메서드는 해당 요소의 값을 즉시 반환하고, 그렇지 않았다면 undefined를 반환합니다.\n\n*   callback은 0 부터 length - 1 까지 배열의 모든 인덱스에 대해 호출되며, **값이 지정되지 않은 요소도 포함하여 모든 인덱스에 대해 호출됩니다. 따라서, 희소 배열 (sparse arrays)의 경우에는 값이 지정된 요소만 탐색하는 다른 메소드에 비해 더 비효율적입니다.**\n\n*   thisArg 파라미터가 주어진 경우에는 제공되었다면 thisArg가 callback안에서 this로 사용되고, 그렇지 않은 경우 undefined 가 this로 사용됩니다.\n\n*   find는 호출의 대상이 된 배열을 변경(mutate)하지 않습니다.\n\n*   find가 처리할 배열 요소의 범위는 첫 callback이 호출되기 전에 먼저 결정됩니다. find메서드가 실행 된 이후에 배열에 추가된 요소들에 대해서는 callback이 호출되지 않습니다. 아직 callback이 호출되지 않았던 배열 요소가 callback에 의해서 변경된 경우, find가 해당 요소의 인덱스를 방문할 때의 값으로 callback함수에 전달될 것입니다. 즉, 삭제된 요소에도 callback이 호출됩니다.\n\n```js\n1. let result = [1, 2, 3].find((value, index, allData) => value === 2);  \nconsole.log(result);  \n  \n2. result = [1, 2, 1].find(function(value, index, allData){  \n return value === 1 && value === this.key;  \n}, {key: 1});  \nconsole.log(result);  \n//2  \n//1  \n```\n\n1.  [1, 2, 3]에서 1을 읽으면 콜백 함수가 호출됩니다. 콜백 함수의 value 파라미터에 1이 설정되고 index에 0이 설정되며, allData에 배열 전체가 설정됩니다.  \n    value === 2에서 false를 반환하므로 배열의 다음 엘리먼트로 넘어가 콜백 함수를 호출합니다. 엘리먼트 값이 2이므로 true가 반환됩니다.  \n    `이때 find()를 종료하면서 처리 중인 엘리먼트 값 2가 반환됩니다.`\n\n2.  find()의 두 번째 파라미터에 {key: 1}을 작성했으며 콜백 함수에서 this로 참조할 수 있습니다. 배열의 첫 번째 엘리먼트 값이 1이므로 콜백 함수가 true를 반환하고 find()가 종료됩니다. 엘리먼트 값 1을 반환합니다.  \n    남은 엘리먼트 값 [2, 1]은 처리되지 않습니다.\n\n* * *\n\n<h2 id=\"Array_findeIndex\">findIndex(): 배열 인덱스 반환</h2>\n\n콜백 함수에서 true를 반환하는 첫 번째 엘리먼트의 배열 인덱스를 반환합니다.  \n만족하는 요소가 없으면 -1을 반환합니다.\n\n> Array.findIndex(callback(element[, index[, array]])[, thisArg])\n\n*   callback  \n    3개의 인수를 취하여 배열의 각 값에 대해 실행할 함수입니다.\n    \n    *   element  \n        배열에서 처리중인 현재 요소입니다.\n        \n    *   index  \n        배열에서 처리중인 현재 요소의 인덱스입니다.\n        \n    *   array  \n        findIndex 함수가 호출된 배열입니다.\n        \n    *   thisArg (선택적 파라미터)  \n        콜백을 실행할 때 this로 사용할 객체입니다.\n        \n\n*   반환 값  \n    엘리먼트가 함수에 true값을 반환하면 그 배열의 인덱스 반환.  \n    그렇지 않으면 -1을 반환합니다.\n\n```js\n1. let result = [10, 20, 30].findIndex(  \n (value, index, allData) => value === 20);  \nconsole.log(result);  \n  \n2. result = [10, 20, 30].findIndex((value, index, allData) => value === 77);  \nconsole.log(result);  \n  \n3. result = [10, 20, 30].findIndex(function(value, index, allData){  \n return value === 30 && value === this.check;  \n}, {check: 30});  \nconsole.log(result);  \n// 1  \n// -1  \n// 2  \n```\n\n1.  [10, 20, 30]에서 처음의 10을 읽으면 콜백 함수가 호출됩니다.  \n    콜백 함수의 value 파라미터에 10이 설정되고 index에 0이 설정되며,  \n    allData에 배열 전체가 설정됩니다. value === 20 에서 false를 반환하므로  \n    배열의 다음 엘리먼트로 넘어가 콜백 함수를 호출 합니다.  \n    엘리먼트 값이 20이므로 true를 반환하며 findIndex()를 종료하며 처리 중인 인덱스 1을 반환합니다.\n\n2.  배열에 true값 77이 없으므로 배열의 엘리먼트 마지막까지 콜백 함수에서 false를 반환하게 되면 findIndex()를 종료하면서 -1을 반환합니다.\n\n3.  findIndex()의 두 번째 파라미터에 {check: 30}을 작성했으며  \n    콜백 함수에서 this로 참조할 수 있습니다.  \n    배열 엘리먼트 값이 30일 때 콜백 함수에서 true를 반환하며 인덱스 값이 2이므로  \n    최종적으로 2를 반환합니다.\n","source":"_posts/Array 오브젝트 -ECMAScript.md","raw":"---\ntitle: Array 오브젝트 -ECMAScript\ndate: 2020-03-30 07:55:37\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\nES6에서 Array오브젝트에 9개의 메서드가 추가되었습니다.  \n추가된 메서드를 살펴봅니다.\n\n*   Array 오브젝트\n    *   [from(): Array 오브젝트 생성](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_from)\n    *   [of(): 배열 엘리먼트 설정](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_of)\n    *   [copyWithin(): 범위 값 복사, 설정](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_copyWithin)\n    *   [fill(): 범위 값 변경](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_fill)\n    *   [entries(): 이터레이터 오브젝트 생성](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_enteries)\n    *   [keys(): key 이터레이터 오브젝트 생성](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_keys)\n    *   [values(): value 이터레이터 오브젝트 생성](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_values)\n    *   [find(): 엘리먼트 값 비교, 반환](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_find)\n    *   [findIndex(): 배열 인덱스 반환](/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_findeIndex)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Array_from\">from(): Array 오브젝트 생성</h2>\n\n새로운 Array 오브젝트를 생성하고 콜백 함수에서 반환된 값을 엘리먼트 값으로 설정하여 새로운 Array 객체를 반환합니다.\n\n> Array.from(arrayLike[, mapFn[, thisArg]])\n\n*   arrayLike  \n    배열로 변환하고자 하는 유사 배열 객체(Array-like)나 반복 가능한 객체(이터러블 오브젝트).\n    \n*   mapFn (선택적 파라미터)  \n    배열의 모든 엘리먼트 마다 호출할 함수.\n    \n*   thisArg (선택적 파라미터)  \n    두 번째 파라미터 함수 실행 시에 this로 참조할 값.\n    \n*   반환 값  \n    새로운 Array 인스턴스.\n    \n\n### 중요 포인트\n\n다음과 같은 경우에 Array.from()으로새Array를 만들 수 있습니다.\n\n*   유사 배열 객체 (length 속성과 인덱싱된 요소를 가진 객체)\n*   순회 가능한 객체 (Map, Set 등객체의 요소를 얻을 수 있는 객체)\n\nArray.from()은 선택 매개변수인 mapFn를 가지는데,배열(혹은 배열 서브클래스)의 각 요소를 맵핑할 때 사용할 수 있습니다. 즉,Array.from(obj, mapFn, thisArg)는 중간에 다른 배열을 생성하지 않는다는 점을 제외하면Array.from(obj).map(mapFn, thisArg)와 같습니다. 이 특징은 typed arrays와 같은 특정 배열 서브클래스에서 중간 배열 값이 적절한 유형에 맞게 생략되기 때문에 특히 중요합니다.\n\nfrom() 메서드의 length 속성은 1입니다.\n\nES2015 이후, 클래스 구문은 내장 및 새 클래스의 상속을 가능케 했습니다. 그 결과로 Array.from과 같은 정적 메서드는 Array의 서브클래스에 의해 상속되며, Array 대신 자신의 인스턴스를 만듭니다.\n\n```js 예제1\n1. let arrayObj = Array.from({0: \"zero\", 1: \"one\", length: 2});  \nconsole.log(Array.isArray(arrayObj));  \nconsole.log(arrayObj);  \n  \n2. let stringObj = Array.from(\"ABC\");  \nconsole.log(stringObj);  \n  \n// true  \n// [\"zero\",\"one\"]  \n// [\"A\", \"B\", \"C\"]  \n```\n\n1.  Array.from() 첫 번째 파라미터에 Array-like 오브젝트를 작성했습니다.  \n    새로운 Array 오브젝트를 생성하고 Array-like 오브젝트의 프로퍼티 값을 배열에 추가하여 반환합니다. {0:”zero”, 1:”one”, length: 2}에서 프로퍼티 키와 length 프로퍼티를 제외한 “zero” 와 “one”이 생성된 Array 오브젝트에 추가됩니다.\n\n2.  Array.from() 파라미터 “ABC” 를 생성한 Array 오브젝트 배열의 엘리먼트에 하나씩 설정하여 반환합니다. 즉[“A”, “B”, “C”] 형태로 반환합니다.\n\n```js 예제2\nlet arrayLike = {0: 10, 1: 30, length: 2};  \nlet values = Array.from(arrayLike, function(value) {  \n return value + this.bonus;  \n}, {bonus: 100});  \nconsole.log(values);  \n// [110, 130]  \n```\n\nArray-like 오브젝트의 프로퍼티를 하나씩 읽어 갑니다.  \n프로퍼티를 읽을 때 마다 콜백 함수를 호출 합니다.  \n읽은 프로퍼티 값이 콜백 함수의 value 파라미터에 설정됩니다.  \n콜백 함수에서 this로 from()의 세 번째 파라미터에 지정한 오브젝트를 참조할 수 있습니다. Array-like 오브젝트의 length 프로퍼티는 참조되지 않습니다.\n\n1.  첫 번째 파라미터의 첫 번째 프로퍼티 값은 10 이며  \n    두 번째 파라미터 콜백 함수의 value 파라미터에 설정됩니다.  \n    this.bonus는 bonus 값을 참조합니다.\n\n2.  value + this.bonus는 110이 반환되고 생성된 Array 배열에 추가됩니다.\n\n3.  두 번째 프로퍼티 값인 30도 같은 방법으로 처리되고 최종적으로 생성된 배열을 반환합니다.\n\n### 그외 예제\n\n*   Set에서 배열 만들기\n```js    \nconst s = new Set([‘foo’, window]);  \nArray.from(s);  \n// [“foo”, window]\n```\n\n*   Map에서 배열 만들기\n```js    \nconst m = new Map([[1, 2], [2, 4], [4, 8]]);  \nArray.from(m);  \n// [[1, 2], [2, 4], [4, 8]]\n\nconst mapper = new Map([[‘1’, ‘a’], [‘2’, ‘b’]]);  \nArray.from(mapper.values());  \n// [‘a’, ‘b’];\n\nArray.from(mapper.keys());  \n// [‘1’, ‘2’];\n```\n    \n*   배열 형태를 가진 객체(arguments)에서 배열 만들기\n```js    \nfunction f() {  \nreturn Array.from(arguments);  \n}  \nf(1, 2, 3);  \n// [1, 2, 3]\n```\n\n*   Array.from과 화살표 함수 사용하기\n```js    \nArray.from([1, 2, 3], x => x + x);  \n// [2, 4, 6]\n\n// 숫자생성  \n// Array는 초기화 될때 각 위치마다 ‘undefined’값으로 초기화 됩니다.  \n// 아래의 v 의 value 값은 undefined 가 될 것입니다.  \nArray.from({length: 5}, (v, i) => i);  \n// [0, 1, 2, 3, 4]\n```    \n\n* * *\n\n<h2 id=\"Array_of\">of(): 배열 엘리먼트 설정</h2>\n\n파라미터 값을 새로운 배열의 엘리먼트로 설정하여 반환합니다.\n\n> Array.of(element0[, element1[, …[, elementN]]])\n\n*   매개변수  \n    elementN  \n    배열을 생성할 때 사용할 엘리먼트.\n    \n*   반환 값  \n    새로운 Array 객체.\n    \n```js\nlet arrayObj = Array.of(1, 2, 3);  \nconsole.log(arrayObj);  \n/// [1, 2, 3]  \n```\n\nArray.of() 파라미터에 새로운 배열의 엘리먼트에 설정할 값을 작성합니다.  \n콤마로 구분하여 다수를 작성할 수 있습니다.  \nArray.of()가 호출되면 우선 Array 오브젝트를 생성합니다. 이어서 파라미터에 작성한 순서대로 Array 오브젝트에 추가한 후, 반환합니다.\n\n*   Array.from()은 파라미터에 Array-like 또는 이터러블 오브젝트를 지정하지만,  \n    Array.of()는 파라미터에 값을 지정합니다.\n\n*   Array.of()와 Array 생성자의 차이는 정수형 인자의 처리 방법에 있습니다.  \n    Array.of(7)은 하나의 요소 7을 가진 배열을 생성하지만  \n    Array(7)은 length 속성이 7인 빈 배열을 생성합니다.\n\n```js Array.of\nArray.of(7);       // [7]   \nArray.of(1, 2, 3); // [1, 2, 3]  \n  \nArray(7);          // [ , , , , , , ]  \nArray(1, 2, 3);    // [1, 2, 3]  \n```\n\n* * *\n\n<h2 id=\"copyWithin\">copyWithin(): 범위 값 복사, 설정</h2>\n\ncopyWithin() 메서드는 배열의 일부를 인덱스 범위의 값을 복사하여, 동일한 배열의 지정한 위치에 덮어쓰고 그 배열을 반환합니다. 이 때, 배열의 길이를 수정하지 않고 반환합니다.\n\n> Array.copyWithin(target[, start[, end]])\n\n*   target  \n    복사한 값을 설정할 시작 인덱스. 음수를 지정하면 인덱스를 배열의 끝에서부터 계산합니다.  \n    target이 arr.length보다 크거나 같으면 아무것도 복사하지 않습니다.  \n    target이 start 이후라면 복사한 시퀀스를 arr.length에 맞춰 자릅니다.\n\n*   start (선택적 파라미터)  \n    복사를 시작할 위치를 가리키는 0 기반 인덱스.  \n    음수를 지정하면 인덱스를 배열의 끝에서부터 계산합니다.  \n    기본값은 0으로, start를 지정하지 않으면 배열의 처음부터 복사합니다.\n\n*   end (선택적 파라미터)  \n    복사를 끝낼 위치를 가리키는 0 기반 인덱스.  \n    copyWithin은 end 인덱스 이전까지 복사하므로  \n    end 인덱스가 가리키는 요소는 제외합니다. 음수를 지정하면 인덱스를 배열의 끝에서부터 계산합니다.  \n    기본값은 arr.length로, end를 지정하지 않으면 배열의 끝까지 복사합니다.\n\n*   반환 값  \n    수정한 배열.\n\n### 중요 포인트\n\ncopyWithin은 C와 C++의 memmove처럼 작동하고, 복사와 대입이 하나의 연산에서 이루어지므로 Array의 데이터를 이동할 때 사용할 수 있는 고성능 메서드입니다. TypedArray의 동명 메서드에서 이 특징이 두드러집니다. 붙여넣은 시퀀스의 위치가 복사한 범위와 겹치더라도 최종 결과는 원본 배열에서 복사한 것과 같습니다.\n\ncopyWithin 함수는 [제네릭 함수](https://heecheolman.tistory.com/67)로, this 값이 Array 객체일 필요는 없습니다.\n\ncopyWithin 메서드는 변경자 메서드로, this의 길이는 바꾸지 않지만 내용을 바꾸며 필요하다면 새로운 속성을 생성합니다.\n\n```js\n1. let one = [1, 2, 3, 4, 5];  \nconsole.log(one.copyWithin(0, 3));  \n  \n2. let two = [1, 2, 3, 4, 5];  \nconsole.log(two.copyWithin(0, 2, 4));  \n  \n3. let three = [1, 2, 3, 4, 5];  \nconsole.log(three.copyWithin(3));  \n// [4, 5, 3, 4, 5]  \n// [3, 4, 3, 4, 5]  \n// [1, 2, 3, 1, 2]  \n```\n\n1.  copyWithin() 두 번째 파라미터에 지정한 인덱스 3부터 배열의 끝까지 엘리먼트 값을 복사하여 첫 번째 파라미터 값인 인덱스 0부터 차례대로 설정합니다. 4와 5를 인덱스 0 부터 설정하므로 [1, 2]가 [4, 5]로 대체되어 [4, 5, 3, 4, 5]가 됩니다.\n\n2.  두 번째 파라미터 값인 인덱스 2부터 세 번째 파라미터 값인 인덱스 4 직전까지 엘리먼트 값을 복사항 첫 번째 파라미터 값인 인덱스 0부터 차례대로 설정합니다.  \n    3과 4를 인덱스 0부터 설정하므로 [1, 2]가 [3, 4]로 대체되어 [3, 4, 3, 4, 5]가 됩니다.\n\n3.  두 번째와 세 번째 파라미터를 작성하지 않았으므로 배열 전체를 복사하여  \n    인덱스 3부터 설정합니다. 복사할 엘리먼트 수는 5이지만, 설정 할수 있는 엘리먼트의 수는 두 개 입니다. [4, 5]에 [1, 2]가 설정되고 나머지 [3, 4, 5]는 설정되지 않습니다. 즉 [1, 2, 3, 1, 2]가 출력됩니다.\n\n```js Array-like\nlet arrayLike = {0: \"ABC\", 1: \"DEF\", 2: \"가나다\", length: 3};  \n1. let one = Array.prototype.copyWithin.call(arrayLike, 0, 1);  \nconsole.log(one);  \n  \n2. function two() {  \n return Array.prototype.copyWithin.call(arguments, 3, 0, 2);  \n};  \nconsole.log(two(1, 2, 3, 4, 5));  \n/*  \nObject  \n0: \"DEF\"  \n1: \"가나다\"  \n2: \"가나다\"  \nlength: 3  \n  \nArguments(5)  \ncallee: (...)  \n0: 1  \n1: 2  \n2: 3  \n3: 1  \n4: 2  \nlength: 5  \n*/  \n```\n\nArray-like 는 배열이 아닌 오브젝트이므로 Array.copyWithin()형태로 호출할 수 없습니다. 하지만 위와 같이 call()을 호출하면서 첫 번째 파라미터에 Array-like를 지정하면 copyWithin()이 호출됩니다.\n\n1.  arrayLike 오브젝트의 프로퍼티 키인 0,1,2를 배열의 인덱스로 사용합니다.  \n    세 번째 파라미터인 인덱스 1 부터 끝까지 복사하여 [“DEF”,”가나다”] 가  \n    인덱스 0,1 값과 대체됩니다. {0: “DEF”, 1: “가나다”, 2: “가나다”, length: 3}\n\n2.  호출한 함수에서 넘겨준 파라미터 값이 arguments에 설정됩니다. arguments가 Array-ike 오브젝트 이므로 call()의 첫 번째 파라미터에 지정하면 copyWithin()을 호출할 수 있습니다. 인덱스 0 부터 인덱스 2 이전까지 복사합니다 [1, 2]  \n    이를 인덱스 3부터 설정하여 인덱스 3,4의 값이 대체됩니다. [1, 2, 3, 1, 2]\n\n* * *\n\n<h2 id=\"Array_fill\">fill(): 범위 값 변경</h2>\n\n같은 배열에서 인덱스 범위의 값을 하나의 지정한 값으로 바꾸어 반환합니다.\n\n> array.fill(value[, start[, end]])\n\n*   value  \n    배열을 채울 값.\n    \n*   start (선택적 파라미터)  \n    시작 인덱스, 기본 값은 0.\n    \n*   end (선택적 파라미터)  \n    범위 끝 인덱스, 기본 값은 this.length.\n    \n*   반환 값  \n    변형한 배열.\n    \n\n### 중요 포인트\n\n*   start가 음수이면 시작 인덱스는 [length + start]입니다. end가 음수이면 끝 인덱스는 [length + end]입니다.\n\n*   fill은 일반 함수이며, this 값이 배열 객체일 필요는 없습니다.\n\n*   fill 메서드는 변경자 메서드로, 복사본이 아니라 this 객체를 변형해 반환합니다.  \n    value에 객체를 받을 경우 그 참조만 복사해서 배열을 채웁니다.\n\n```js\nlet one = [1, 2, 3];  \n1. console.log(one.fill(7));  \n  \nlet two = [1, 2, 3, 4, 5];  \n2. console.log(two.fill(7, 1));  \n  \nlet three = [1, 2, 3, 4, 5];  \n3. console.log(three.fill(7, 1, 3));  \n// [7, 7, 7]  \n// [1, 7, 7, 7, 7]  \n// [1, 7, 7, 4, 5]  \n```\n\n1.  범위를 지정해 주지 않았으므로 배열 전체가 변경 대상이 됩니다.  \n    첫 번째 파라미터 7이 변경할 값이 되어 [7, 7, 7]로 변경됩니다.\n\n2.  두 번째 파라미터 인덱스 값1 부터 배열 끝까지가 변경 대상이 됩니다.  \n    [1, 7, 7, 7, 7]로 변경됩니다.\n\n3.  두 번째 파라미터 인덱스 값1 부터 세 번째 파라미터 인덱스 3이전 까지가 변경 대상입니다. [2, 3]이 7로 변경되어 [1, 7, 7, 4, 5]이 됩니다.\n\n* * *\n\n<h2 id=\"Array_enteries\">entries(): 이터레이터 오브젝트 생성</h2>\n\nArray오브젝트를 이터레이터 오브젝트로 생성하여 반환합니다.\n\n> Array.entries()\n\n*   반환값 iterator\n\n```js entries\nlet values = [10, 20, 30];  \n// Array 오브젝트로 이터레이터 오브젝트를 생성해 반환합니다.  \n1. let iterator = values.entries();  \nconsole.log(iterator.next());  \n  \n2. for (var [key, value] of iterator){  \n console.log(key, \":\", value);  \n};  \n/* Object   \n{value: Array(2)  \n [ {0: 0},  \n {1: 10} ],  \n done: false}  \n1: 20  \n2: 30  \n*/  \n```\n\n1.  iterator 오브젝트의 next()를 호출 하면 {value: (2),done: false} 형태를 반환합니다. 배열의 인덱스와 엘리먼트가 프로퍼티 형태로 되기 때문입니다.  \n    [{0: 0}, {1: 10}]\n\n2.  이터레이터 오브젝트는 for-of문에 [key: value]형태로 키와 값을 동시에 작성할 수 있습니다. 실행 결과에 “0: 10”이 출력되지 않는 것은 바로 앞의 next()에서 이터레이션 처리를 하였기 때문입니다. 따라서 for-of문은 두 번째 인덱스부터 처리되었습니다.\n\n* * *\n\n<h2 id=\"Array_keys\">keys(): key 이터레이터 오브젝트 생성</h2>\n\nkey만 갖는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n배열의 인덱스를 key 값으로 사용하여 이터레이터 오브젝트를 생성합니다.  \n배열의 엘리먼트 값은 이터레이터 오브젝트에 포함되지 않습니다.\n\n```js\nlet iterator = [10, 20, 30].keys();  \nfor (var key of iterator){  \n console.log(key, \":\", iterator[key]);  \n};  \n/*  \n0 \":\" undefined  \n1 \":\" undefined  \n2 \":\" undefined  \n*/  \n```\n\n[10, 20, 30].keys()로 이터레이터 오브젝트를 생성하면  \n**인덱스 0, 1, 2만 설정되고 엘리먼트 값 [10, 20, 30]은 설정되지 않습니다.**  \nvalue 값에 undefined가 출력됩니다.\n\n`for(var[key, value] of iterator){}와 같이 [key, value]를 작성하면 TypeError가 발생하므로 key만 작성해야 합니다.`\n\n* * *\n\n<h2 id=\"Array_values\">values(): value 이터레이터 오브젝트 생성</h2>\n\nvalue만 갖는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n배열 엘리먼트 값으로 이터레이터 오브젝트를 생성합니다.  \n배열 인덱스는 이터레이터 오브젝트에 포함되지 않습니다.  \nSymbol.iterator()와 같습니다.\n\n```js\n// 크롬 52~54, 파이어폭스 47~49 지원하지 않음  \nlet iterator = [10, 20, 30].values();  \n1. console.log(iterator.next());  \n2. console.log(iterator.next());  \n3. console.log(iterator.next());  \n4. console.log(iterator.next());  \n/*  \n1.Object  \nvalue: 10  \ndone: false  \n  \n2.Object  \nvalue: 20  \ndone: false  \n  \n3.Object  \nvalue: 30  \ndone: false  \n  \n4.Object  \nvalue: undefined  \ndone: true  \n*/  \n```\n\nfor-of 루프 반복을 사용 하려면.  \n브라우저가 for-of 루프와 for 루프안에 let 스코프 변수를 지원해야 합니다.\n\n* * *\n\n<h2 id=\"Array_find\">find(): 엘리먼트 값 비교, 반환</h2>\n\nfind() 메서드는 주어진 콜백 함수를 만족하는(true 값) 첫 번째 엘리먼트의 값을 반환합니다. 그런 요소가 없다면 undefined를 반환합니다.\n\n> Array.find(callback[, thisArg])\n\n*   callback  \n    배열의 각 값에 대해 실행할 함수. 아래의 세 인자를 받습니다.\n    \n    *   element  \n        콜백함수에서 처리할 현재 엘리먼트.\n        \n    *   index  \n        콜백함수에서 처리할 현재 엘리먼트의 인덱스.\n        \n    *   array  \n        find 함수를 호출한 배열.\n        \n\n*   thisArg (선택적 파라미터)  \n    콜백이 호출될 때 this로 사용할 객체.\n\n*   반환 값  \n    주어진 판별 함수를 만족하는 첫 번째 요소의 값. 그 외에는 undefined.\n\n### 중요 포인트\n\n*   find 메서드는 callback 함수가 참을 반환 할 때까지 해당 배열의 각 요소에 대해서 callback 함수를 실행합니다. 만약 어느 요소를 찾았다면 find 메서드는 해당 요소의 값을 즉시 반환하고, 그렇지 않았다면 undefined를 반환합니다.\n\n*   callback은 0 부터 length - 1 까지 배열의 모든 인덱스에 대해 호출되며, **값이 지정되지 않은 요소도 포함하여 모든 인덱스에 대해 호출됩니다. 따라서, 희소 배열 (sparse arrays)의 경우에는 값이 지정된 요소만 탐색하는 다른 메소드에 비해 더 비효율적입니다.**\n\n*   thisArg 파라미터가 주어진 경우에는 제공되었다면 thisArg가 callback안에서 this로 사용되고, 그렇지 않은 경우 undefined 가 this로 사용됩니다.\n\n*   find는 호출의 대상이 된 배열을 변경(mutate)하지 않습니다.\n\n*   find가 처리할 배열 요소의 범위는 첫 callback이 호출되기 전에 먼저 결정됩니다. find메서드가 실행 된 이후에 배열에 추가된 요소들에 대해서는 callback이 호출되지 않습니다. 아직 callback이 호출되지 않았던 배열 요소가 callback에 의해서 변경된 경우, find가 해당 요소의 인덱스를 방문할 때의 값으로 callback함수에 전달될 것입니다. 즉, 삭제된 요소에도 callback이 호출됩니다.\n\n```js\n1. let result = [1, 2, 3].find((value, index, allData) => value === 2);  \nconsole.log(result);  \n  \n2. result = [1, 2, 1].find(function(value, index, allData){  \n return value === 1 && value === this.key;  \n}, {key: 1});  \nconsole.log(result);  \n//2  \n//1  \n```\n\n1.  [1, 2, 3]에서 1을 읽으면 콜백 함수가 호출됩니다. 콜백 함수의 value 파라미터에 1이 설정되고 index에 0이 설정되며, allData에 배열 전체가 설정됩니다.  \n    value === 2에서 false를 반환하므로 배열의 다음 엘리먼트로 넘어가 콜백 함수를 호출합니다. 엘리먼트 값이 2이므로 true가 반환됩니다.  \n    `이때 find()를 종료하면서 처리 중인 엘리먼트 값 2가 반환됩니다.`\n\n2.  find()의 두 번째 파라미터에 {key: 1}을 작성했으며 콜백 함수에서 this로 참조할 수 있습니다. 배열의 첫 번째 엘리먼트 값이 1이므로 콜백 함수가 true를 반환하고 find()가 종료됩니다. 엘리먼트 값 1을 반환합니다.  \n    남은 엘리먼트 값 [2, 1]은 처리되지 않습니다.\n\n* * *\n\n<h2 id=\"Array_findeIndex\">findIndex(): 배열 인덱스 반환</h2>\n\n콜백 함수에서 true를 반환하는 첫 번째 엘리먼트의 배열 인덱스를 반환합니다.  \n만족하는 요소가 없으면 -1을 반환합니다.\n\n> Array.findIndex(callback(element[, index[, array]])[, thisArg])\n\n*   callback  \n    3개의 인수를 취하여 배열의 각 값에 대해 실행할 함수입니다.\n    \n    *   element  \n        배열에서 처리중인 현재 요소입니다.\n        \n    *   index  \n        배열에서 처리중인 현재 요소의 인덱스입니다.\n        \n    *   array  \n        findIndex 함수가 호출된 배열입니다.\n        \n    *   thisArg (선택적 파라미터)  \n        콜백을 실행할 때 this로 사용할 객체입니다.\n        \n\n*   반환 값  \n    엘리먼트가 함수에 true값을 반환하면 그 배열의 인덱스 반환.  \n    그렇지 않으면 -1을 반환합니다.\n\n```js\n1. let result = [10, 20, 30].findIndex(  \n (value, index, allData) => value === 20);  \nconsole.log(result);  \n  \n2. result = [10, 20, 30].findIndex((value, index, allData) => value === 77);  \nconsole.log(result);  \n  \n3. result = [10, 20, 30].findIndex(function(value, index, allData){  \n return value === 30 && value === this.check;  \n}, {check: 30});  \nconsole.log(result);  \n// 1  \n// -1  \n// 2  \n```\n\n1.  [10, 20, 30]에서 처음의 10을 읽으면 콜백 함수가 호출됩니다.  \n    콜백 함수의 value 파라미터에 10이 설정되고 index에 0이 설정되며,  \n    allData에 배열 전체가 설정됩니다. value === 20 에서 false를 반환하므로  \n    배열의 다음 엘리먼트로 넘어가 콜백 함수를 호출 합니다.  \n    엘리먼트 값이 20이므로 true를 반환하며 findIndex()를 종료하며 처리 중인 인덱스 1을 반환합니다.\n\n2.  배열에 true값 77이 없으므로 배열의 엘리먼트 마지막까지 콜백 함수에서 false를 반환하게 되면 findIndex()를 종료하면서 -1을 반환합니다.\n\n3.  findIndex()의 두 번째 파라미터에 {check: 30}을 작성했으며  \n    콜백 함수에서 this로 참조할 수 있습니다.  \n    배열 엘리먼트 값이 30일 때 콜백 함수에서 true를 반환하며 인덱스 값이 2이므로  \n    최종적으로 2를 반환합니다.\n","slug":"Array 오브젝트 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrri0000qgvqgkkn31ch","content":"<p>ES6에서 Array오브젝트에 9개의 메서드가 추가되었습니다.<br>추가된 메서드를 살펴봅니다.</p>\n<ul>\n<li>Array 오브젝트<ul>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_from\">from(): Array 오브젝트 생성</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_of\">of(): 배열 엘리먼트 설정</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_copyWithin\">copyWithin(): 범위 값 복사, 설정</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_fill\">fill(): 범위 값 변경</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_enteries\">entries(): 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_keys\">keys(): key 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_values\">values(): value 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_find\">find(): 엘리먼트 값 비교, 반환</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_findeIndex\">findIndex(): 배열 인덱스 반환</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"Array_from\">from(): Array 오브젝트 생성</h2>\n\n<p>새로운 Array 오브젝트를 생성하고 콜백 함수에서 반환된 값을 엘리먼트 값으로 설정하여 새로운 Array 객체를 반환합니다.</p>\n<blockquote>\n<p>Array.from(arrayLike[, mapFn[, thisArg]])</p>\n</blockquote>\n<ul>\n<li><p>arrayLike<br>배열로 변환하고자 하는 유사 배열 객체(Array-like)나 반복 가능한 객체(이터러블 오브젝트).</p>\n</li>\n<li><p>mapFn (선택적 파라미터)<br>배열의 모든 엘리먼트 마다 호출할 함수.</p>\n</li>\n<li><p>thisArg (선택적 파라미터)<br>두 번째 파라미터 함수 실행 시에 this로 참조할 값.</p>\n</li>\n<li><p>반환 값<br>새로운 Array 인스턴스.</p>\n</li>\n</ul>\n<h3 id=\"중요-포인트\"><a href=\"#중요-포인트\" class=\"headerlink\" title=\"중요 포인트\"></a>중요 포인트</h3><p>다음과 같은 경우에 Array.from()으로새Array를 만들 수 있습니다.</p>\n<ul>\n<li>유사 배열 객체 (length 속성과 인덱싱된 요소를 가진 객체)</li>\n<li>순회 가능한 객체 (Map, Set 등객체의 요소를 얻을 수 있는 객체)</li>\n</ul>\n<p>Array.from()은 선택 매개변수인 mapFn를 가지는데,배열(혹은 배열 서브클래스)의 각 요소를 맵핑할 때 사용할 수 있습니다. 즉,Array.from(obj, mapFn, thisArg)는 중간에 다른 배열을 생성하지 않는다는 점을 제외하면Array.from(obj).map(mapFn, thisArg)와 같습니다. 이 특징은 typed arrays와 같은 특정 배열 서브클래스에서 중간 배열 값이 적절한 유형에 맞게 생략되기 때문에 특히 중요합니다.</p>\n<p>from() 메서드의 length 속성은 1입니다.</p>\n<p>ES2015 이후, 클래스 구문은 내장 및 새 클래스의 상속을 가능케 했습니다. 그 결과로 Array.from과 같은 정적 메서드는 Array의 서브클래스에 의해 상속되며, Array 대신 자신의 인스턴스를 만듭니다.</p>\n<figure class=\"highlight js\"><figcaption><span>예제1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> arrayObj = <span class=\"built_in\">Array</span>.from(&#123;<span class=\"number\">0</span>: <span class=\"string\">\"zero\"</span>, <span class=\"number\">1</span>: <span class=\"string\">\"one\"</span>, <span class=\"attr\">length</span>: <span class=\"number\">2</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.isArray(arrayObj));  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrayObj);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> stringObj = <span class=\"built_in\">Array</span>.from(<span class=\"string\">\"ABC\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringObj);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// true  </span></span><br><span class=\"line\"><span class=\"comment\">// [\"zero\",\"one\"]  </span></span><br><span class=\"line\"><span class=\"comment\">// [\"A\", \"B\", \"C\"]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Array.from() 첫 번째 파라미터에 Array-like 오브젝트를 작성했습니다.<br>새로운 Array 오브젝트를 생성하고 Array-like 오브젝트의 프로퍼티 값을 배열에 추가하여 반환합니다. {0:”zero”, 1:”one”, length: 2}에서 프로퍼티 키와 length 프로퍼티를 제외한 “zero” 와 “one”이 생성된 Array 오브젝트에 추가됩니다.</p>\n</li>\n<li><p>Array.from() 파라미터 “ABC” 를 생성한 Array 오브젝트 배열의 엘리먼트에 하나씩 설정하여 반환합니다. 즉[“A”, “B”, “C”] 형태로 반환합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>예제2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;<span class=\"number\">0</span>: <span class=\"number\">10</span>, <span class=\"number\">1</span>: <span class=\"number\">30</span>, <span class=\"attr\">length</span>: <span class=\"number\">2</span>&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> values = <span class=\"built_in\">Array</span>.from(arrayLike, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> value + <span class=\"keyword\">this</span>.bonus;  </span><br><span class=\"line\">&#125;, &#123;<span class=\"attr\">bonus</span>: <span class=\"number\">100</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(values);  </span><br><span class=\"line\"><span class=\"comment\">// [110, 130]</span></span><br></pre></td></tr></table></figure>\n\n<p>Array-like 오브젝트의 프로퍼티를 하나씩 읽어 갑니다.<br>프로퍼티를 읽을 때 마다 콜백 함수를 호출 합니다.<br>읽은 프로퍼티 값이 콜백 함수의 value 파라미터에 설정됩니다.<br>콜백 함수에서 this로 from()의 세 번째 파라미터에 지정한 오브젝트를 참조할 수 있습니다. Array-like 오브젝트의 length 프로퍼티는 참조되지 않습니다.</p>\n<ol>\n<li><p>첫 번째 파라미터의 첫 번째 프로퍼티 값은 10 이며<br>두 번째 파라미터 콜백 함수의 value 파라미터에 설정됩니다.<br>this.bonus는 bonus 값을 참조합니다.</p>\n</li>\n<li><p>value + this.bonus는 110이 반환되고 생성된 Array 배열에 추가됩니다.</p>\n</li>\n<li><p>두 번째 프로퍼티 값인 30도 같은 방법으로 처리되고 최종적으로 생성된 배열을 반환합니다.</p>\n</li>\n</ol>\n<h3 id=\"그외-예제\"><a href=\"#그외-예제\" class=\"headerlink\" title=\"그외 예제\"></a>그외 예제</h3><ul>\n<li><p>Set에서 배열 만들기</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([‘foo’, <span class=\"built_in\">window</span>]);  </span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(s);  </span><br><span class=\"line\"><span class=\"comment\">// [“foo”, window]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Map에서 배열 만들기</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">2</span>, <span class=\"number\">4</span>], [<span class=\"number\">4</span>, <span class=\"number\">8</span>]]);  </span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(m);  </span><br><span class=\"line\"><span class=\"comment\">// [[1, 2], [2, 4], [4, 8]]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapper = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[‘<span class=\"number\">1</span>’, ‘a’], [‘<span class=\"number\">2</span>’, ‘b’]]);  </span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(mapper.values());  </span><br><span class=\"line\"><span class=\"comment\">// [‘a’, ‘b’];</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(mapper.keys());  </span><br><span class=\"line\"><span class=\"comment\">// [‘1’, ‘2’];</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>배열 형태를 가진 객체(arguments)에서 배열 만들기</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Array.from과 화살표 함수 사용하기</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], x =&gt; x + x);  </span><br><span class=\"line\"><span class=\"comment\">// [2, 4, 6]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 숫자생성  </span></span><br><span class=\"line\"><span class=\"comment\">// Array는 초기화 될때 각 위치마다 ‘undefined’값으로 초기화 됩니다.  </span></span><br><span class=\"line\"><span class=\"comment\">// 아래의 v 의 value 값은 undefined 가 될 것입니다.  </span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(&#123;<span class=\"attr\">length</span>: <span class=\"number\">5</span>&#125;, (v, i) =&gt; i);  </span><br><span class=\"line\"><span class=\"comment\">// [0, 1, 2, 3, 4]</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`    </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* * *</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&lt;h2 id=\"Array_of\"&gt;of(): 배열 엘리먼트 설정&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">파라미터 값을 새로운 배열의 엘리먼트로 설정하여 반환합니다.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&gt; Array.of(element0[, element1[, …[, elementN]]])</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">*   매개변수  </span></span><br><span class=\"line\"><span class=\"string\">    elementN  </span></span><br><span class=\"line\"><span class=\"string\">    배열을 생성할 때 사용할 엘리먼트.</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">*   반환 값  </span></span><br><span class=\"line\"><span class=\"string\">    새로운 Array 객체.</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">let</span> arrayObj = <span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrayObj);  </span><br><span class=\"line\"><span class=\"comment\">/// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>Array.of() 파라미터에 새로운 배열의 엘리먼트에 설정할 값을 작성합니다.<br>콤마로 구분하여 다수를 작성할 수 있습니다.<br>Array.of()가 호출되면 우선 Array 오브젝트를 생성합니다. 이어서 파라미터에 작성한 순서대로 Array 오브젝트에 추가한 후, 반환합니다.</p>\n<ul>\n<li><p>Array.from()은 파라미터에 Array-like 또는 이터러블 오브젝트를 지정하지만,<br>Array.of()는 파라미터에 값을 지정합니다.</p>\n</li>\n<li><p>Array.of()와 Array 생성자의 차이는 정수형 인자의 처리 방법에 있습니다.<br>Array.of(7)은 하나의 요소 7을 가진 배열을 생성하지만<br>Array(7)은 length 속성이 7인 빈 배열을 생성합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>Array.of</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">7</span>);       <span class=\"comment\">// [7]   </span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// [1, 2, 3]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">7</span>);          <span class=\"comment\">// [ , , , , , , ]  </span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);    <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"copyWithin\">copyWithin(): 범위 값 복사, 설정</h2>\n\n<p>copyWithin() 메서드는 배열의 일부를 인덱스 범위의 값을 복사하여, 동일한 배열의 지정한 위치에 덮어쓰고 그 배열을 반환합니다. 이 때, 배열의 길이를 수정하지 않고 반환합니다.</p>\n<blockquote>\n<p>Array.copyWithin(target[, start[, end]])</p>\n</blockquote>\n<ul>\n<li><p>target<br>복사한 값을 설정할 시작 인덱스. 음수를 지정하면 인덱스를 배열의 끝에서부터 계산합니다.<br>target이 arr.length보다 크거나 같으면 아무것도 복사하지 않습니다.<br>target이 start 이후라면 복사한 시퀀스를 arr.length에 맞춰 자릅니다.</p>\n</li>\n<li><p>start (선택적 파라미터)<br>복사를 시작할 위치를 가리키는 0 기반 인덱스.<br>음수를 지정하면 인덱스를 배열의 끝에서부터 계산합니다.<br>기본값은 0으로, start를 지정하지 않으면 배열의 처음부터 복사합니다.</p>\n</li>\n<li><p>end (선택적 파라미터)<br>복사를 끝낼 위치를 가리키는 0 기반 인덱스.<br>copyWithin은 end 인덱스 이전까지 복사하므로<br>end 인덱스가 가리키는 요소는 제외합니다. 음수를 지정하면 인덱스를 배열의 끝에서부터 계산합니다.<br>기본값은 arr.length로, end를 지정하지 않으면 배열의 끝까지 복사합니다.</p>\n</li>\n<li><p>반환 값<br>수정한 배열.</p>\n</li>\n</ul>\n<h3 id=\"중요-포인트-1\"><a href=\"#중요-포인트-1\" class=\"headerlink\" title=\"중요 포인트\"></a>중요 포인트</h3><p>copyWithin은 C와 C++의 memmove처럼 작동하고, 복사와 대입이 하나의 연산에서 이루어지므로 Array의 데이터를 이동할 때 사용할 수 있는 고성능 메서드입니다. TypedArray의 동명 메서드에서 이 특징이 두드러집니다. 붙여넣은 시퀀스의 위치가 복사한 범위와 겹치더라도 최종 결과는 원본 배열에서 복사한 것과 같습니다.</p>\n<p>copyWithin 함수는 <a href=\"https://heecheolman.tistory.com/67\">제네릭 함수</a>로, this 값이 Array 객체일 필요는 없습니다.</p>\n<p>copyWithin 메서드는 변경자 메서드로, this의 길이는 바꾸지 않지만 내용을 바꾸며 필요하다면 새로운 속성을 생성합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> one = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(one.copyWithin(<span class=\"number\">0</span>, <span class=\"number\">3</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> two = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(two.copyWithin(<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> three = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(three.copyWithin(<span class=\"number\">3</span>));  </span><br><span class=\"line\"><span class=\"comment\">// [4, 5, 3, 4, 5]  </span></span><br><span class=\"line\"><span class=\"comment\">// [3, 4, 3, 4, 5]  </span></span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 1, 2]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>copyWithin() 두 번째 파라미터에 지정한 인덱스 3부터 배열의 끝까지 엘리먼트 값을 복사하여 첫 번째 파라미터 값인 인덱스 0부터 차례대로 설정합니다. 4와 5를 인덱스 0 부터 설정하므로 [1, 2]가 [4, 5]로 대체되어 [4, 5, 3, 4, 5]가 됩니다.</p>\n</li>\n<li><p>두 번째 파라미터 값인 인덱스 2부터 세 번째 파라미터 값인 인덱스 4 직전까지 엘리먼트 값을 복사항 첫 번째 파라미터 값인 인덱스 0부터 차례대로 설정합니다.<br>3과 4를 인덱스 0부터 설정하므로 [1, 2]가 [3, 4]로 대체되어 [3, 4, 3, 4, 5]가 됩니다.</p>\n</li>\n<li><p>두 번째와 세 번째 파라미터를 작성하지 않았으므로 배열 전체를 복사하여<br>인덱스 3부터 설정합니다. 복사할 엘리먼트 수는 5이지만, 설정 할수 있는 엘리먼트의 수는 두 개 입니다. [4, 5]에 [1, 2]가 설정되고 나머지 [3, 4, 5]는 설정되지 않습니다. 즉 [1, 2, 3, 1, 2]가 출력됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>Array-like</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;<span class=\"number\">0</span>: <span class=\"string\">\"ABC\"</span>, <span class=\"number\">1</span>: <span class=\"string\">\"DEF\"</span>, <span class=\"number\">2</span>: <span class=\"string\">\"가나다\"</span>, <span class=\"attr\">length</span>: <span class=\"number\">3</span>&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> one = <span class=\"built_in\">Array</span>.prototype.copyWithin.call(arrayLike, <span class=\"number\">0</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(one);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">two</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.copyWithin.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(two(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>));  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Object  </span></span><br><span class=\"line\"><span class=\"comment\">0: \"DEF\"  </span></span><br><span class=\"line\"><span class=\"comment\">1: \"가나다\"  </span></span><br><span class=\"line\"><span class=\"comment\">2: \"가나다\"  </span></span><br><span class=\"line\"><span class=\"comment\">length: 3  </span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">Arguments(5)  </span></span><br><span class=\"line\"><span class=\"comment\">callee: (...)  </span></span><br><span class=\"line\"><span class=\"comment\">0: 1  </span></span><br><span class=\"line\"><span class=\"comment\">1: 2  </span></span><br><span class=\"line\"><span class=\"comment\">2: 3  </span></span><br><span class=\"line\"><span class=\"comment\">3: 1  </span></span><br><span class=\"line\"><span class=\"comment\">4: 2  </span></span><br><span class=\"line\"><span class=\"comment\">length: 5  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>Array-like 는 배열이 아닌 오브젝트이므로 Array.copyWithin()형태로 호출할 수 없습니다. 하지만 위와 같이 call()을 호출하면서 첫 번째 파라미터에 Array-like를 지정하면 copyWithin()이 호출됩니다.</p>\n<ol>\n<li><p>arrayLike 오브젝트의 프로퍼티 키인 0,1,2를 배열의 인덱스로 사용합니다.<br>세 번째 파라미터인 인덱스 1 부터 끝까지 복사하여 [“DEF”,”가나다”] 가<br>인덱스 0,1 값과 대체됩니다. {0: “DEF”, 1: “가나다”, 2: “가나다”, length: 3}</p>\n</li>\n<li><p>호출한 함수에서 넘겨준 파라미터 값이 arguments에 설정됩니다. arguments가 Array-ike 오브젝트 이므로 call()의 첫 번째 파라미터에 지정하면 copyWithin()을 호출할 수 있습니다. 인덱스 0 부터 인덱스 2 이전까지 복사합니다 [1, 2]<br>이를 인덱스 3부터 설정하여 인덱스 3,4의 값이 대체됩니다. [1, 2, 3, 1, 2]</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Array_fill\">fill(): 범위 값 변경</h2>\n\n<p>같은 배열에서 인덱스 범위의 값을 하나의 지정한 값으로 바꾸어 반환합니다.</p>\n<blockquote>\n<p>array.fill(value[, start[, end]])</p>\n</blockquote>\n<ul>\n<li><p>value<br>배열을 채울 값.</p>\n</li>\n<li><p>start (선택적 파라미터)<br>시작 인덱스, 기본 값은 0.</p>\n</li>\n<li><p>end (선택적 파라미터)<br>범위 끝 인덱스, 기본 값은 this.length.</p>\n</li>\n<li><p>반환 값<br>변형한 배열.</p>\n</li>\n</ul>\n<h3 id=\"중요-포인트-2\"><a href=\"#중요-포인트-2\" class=\"headerlink\" title=\"중요 포인트\"></a>중요 포인트</h3><ul>\n<li><p>start가 음수이면 시작 인덱스는 [length + start]입니다. end가 음수이면 끝 인덱스는 [length + end]입니다.</p>\n</li>\n<li><p>fill은 일반 함수이며, this 값이 배열 객체일 필요는 없습니다.</p>\n</li>\n<li><p>fill 메서드는 변경자 메서드로, 복사본이 아니라 this 객체를 변형해 반환합니다.<br>value에 객체를 받을 경우 그 참조만 복사해서 배열을 채웁니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(one.fill(<span class=\"number\">7</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> two = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(two.fill(<span class=\"number\">7</span>, <span class=\"number\">1</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> three = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(three.fill(<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>));  </span><br><span class=\"line\"><span class=\"comment\">// [7, 7, 7]  </span></span><br><span class=\"line\"><span class=\"comment\">// [1, 7, 7, 7, 7]  </span></span><br><span class=\"line\"><span class=\"comment\">// [1, 7, 7, 4, 5]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>범위를 지정해 주지 않았으므로 배열 전체가 변경 대상이 됩니다.<br>첫 번째 파라미터 7이 변경할 값이 되어 [7, 7, 7]로 변경됩니다.</p>\n</li>\n<li><p>두 번째 파라미터 인덱스 값1 부터 배열 끝까지가 변경 대상이 됩니다.<br>[1, 7, 7, 7, 7]로 변경됩니다.</p>\n</li>\n<li><p>두 번째 파라미터 인덱스 값1 부터 세 번째 파라미터 인덱스 3이전 까지가 변경 대상입니다. [2, 3]이 7로 변경되어 [1, 7, 7, 4, 5]이 됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Array_enteries\">entries(): 이터레이터 오브젝트 생성</h2>\n\n<p>Array오브젝트를 이터레이터 오브젝트로 생성하여 반환합니다.</p>\n<blockquote>\n<p>Array.entries()</p>\n</blockquote>\n<ul>\n<li>반환값 iterator</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>entries</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> values = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>];  </span><br><span class=\"line\"><span class=\"comment\">// Array 오브젝트로 이터레이터 오브젝트를 생성해 반환합니다.  </span></span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> iterator = values.entries();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> [key, value] <span class=\"keyword\">of</span> iterator)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, <span class=\"string\">\":\"</span>, value);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">/* Object   </span></span><br><span class=\"line\"><span class=\"comment\">&#123;value: Array(2)  </span></span><br><span class=\"line\"><span class=\"comment\"> [ &#123;0: 0&#125;,  </span></span><br><span class=\"line\"><span class=\"comment\"> &#123;1: 10&#125; ],  </span></span><br><span class=\"line\"><span class=\"comment\"> done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">1: 20  </span></span><br><span class=\"line\"><span class=\"comment\">2: 30  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>iterator 오브젝트의 next()를 호출 하면 {value: (2),done: false} 형태를 반환합니다. 배열의 인덱스와 엘리먼트가 프로퍼티 형태로 되기 때문입니다.<br>[{0: 0}, {1: 10}]</p>\n</li>\n<li><p>이터레이터 오브젝트는 for-of문에 [key: value]형태로 키와 값을 동시에 작성할 수 있습니다. 실행 결과에 “0: 10”이 출력되지 않는 것은 바로 앞의 next()에서 이터레이션 처리를 하였기 때문입니다. 따라서 for-of문은 두 번째 인덱스부터 처리되었습니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Array_keys\">keys(): key 이터레이터 오브젝트 생성</h2>\n\n<p>key만 갖는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<p>배열의 인덱스를 key 값으로 사용하여 이터레이터 오브젝트를 생성합니다.<br>배열의 엘리먼트 값은 이터레이터 오브젝트에 포함되지 않습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterator = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>].keys();  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">of</span> iterator)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, <span class=\"string\">\":\"</span>, iterator[key]);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">0 \":\" undefined  </span></span><br><span class=\"line\"><span class=\"comment\">1 \":\" undefined  </span></span><br><span class=\"line\"><span class=\"comment\">2 \":\" undefined  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>[10, 20, 30].keys()로 이터레이터 오브젝트를 생성하면<br><strong>인덱스 0, 1, 2만 설정되고 엘리먼트 값 [10, 20, 30]은 설정되지 않습니다.</strong><br>value 값에 undefined가 출력됩니다.</p>\n<p><code>for(var[key, value] of iterator){}와 같이 [key, value]를 작성하면 TypeError가 발생하므로 key만 작성해야 합니다.</code></p>\n<hr>\n<h2 id=\"Array_values\">values(): value 이터레이터 오브젝트 생성</h2>\n\n<p>value만 갖는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<p>배열 엘리먼트 값으로 이터레이터 오브젝트를 생성합니다.<br>배열 인덱스는 이터레이터 오브젝트에 포함되지 않습니다.<br>Symbol.iterator()와 같습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 크롬 52~54, 파이어폭스 47~49 지원하지 않음  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> iterator = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>].values();  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(iterator.next());  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(iterator.next());  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(iterator.next());  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(iterator.next());  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">1.Object  </span></span><br><span class=\"line\"><span class=\"comment\">value: 10  </span></span><br><span class=\"line\"><span class=\"comment\">done: false  </span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">2.Object  </span></span><br><span class=\"line\"><span class=\"comment\">value: 20  </span></span><br><span class=\"line\"><span class=\"comment\">done: false  </span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">3.Object  </span></span><br><span class=\"line\"><span class=\"comment\">value: 30  </span></span><br><span class=\"line\"><span class=\"comment\">done: false  </span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">4.Object  </span></span><br><span class=\"line\"><span class=\"comment\">value: undefined  </span></span><br><span class=\"line\"><span class=\"comment\">done: true  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>for-of 루프 반복을 사용 하려면.<br>브라우저가 for-of 루프와 for 루프안에 let 스코프 변수를 지원해야 합니다.</p>\n<hr>\n<h2 id=\"Array_find\">find(): 엘리먼트 값 비교, 반환</h2>\n\n<p>find() 메서드는 주어진 콜백 함수를 만족하는(true 값) 첫 번째 엘리먼트의 값을 반환합니다. 그런 요소가 없다면 undefined를 반환합니다.</p>\n<blockquote>\n<p>Array.find(callback[, thisArg])</p>\n</blockquote>\n<ul>\n<li><p>callback<br>배열의 각 값에 대해 실행할 함수. 아래의 세 인자를 받습니다.</p>\n<ul>\n<li><p>element<br>콜백함수에서 처리할 현재 엘리먼트.</p>\n</li>\n<li><p>index<br>콜백함수에서 처리할 현재 엘리먼트의 인덱스.</p>\n</li>\n<li><p>array<br>find 함수를 호출한 배열.</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>thisArg (선택적 파라미터)<br>콜백이 호출될 때 this로 사용할 객체.</p>\n</li>\n<li><p>반환 값<br>주어진 판별 함수를 만족하는 첫 번째 요소의 값. 그 외에는 undefined.</p>\n</li>\n</ul>\n<h3 id=\"중요-포인트-3\"><a href=\"#중요-포인트-3\" class=\"headerlink\" title=\"중요 포인트\"></a>중요 포인트</h3><ul>\n<li><p>find 메서드는 callback 함수가 참을 반환 할 때까지 해당 배열의 각 요소에 대해서 callback 함수를 실행합니다. 만약 어느 요소를 찾았다면 find 메서드는 해당 요소의 값을 즉시 반환하고, 그렇지 않았다면 undefined를 반환합니다.</p>\n</li>\n<li><p>callback은 0 부터 length - 1 까지 배열의 모든 인덱스에 대해 호출되며, <strong>값이 지정되지 않은 요소도 포함하여 모든 인덱스에 대해 호출됩니다. 따라서, 희소 배열 (sparse arrays)의 경우에는 값이 지정된 요소만 탐색하는 다른 메소드에 비해 더 비효율적입니다.</strong></p>\n</li>\n<li><p>thisArg 파라미터가 주어진 경우에는 제공되었다면 thisArg가 callback안에서 this로 사용되고, 그렇지 않은 경우 undefined 가 this로 사용됩니다.</p>\n</li>\n<li><p>find는 호출의 대상이 된 배열을 변경(mutate)하지 않습니다.</p>\n</li>\n<li><p>find가 처리할 배열 요소의 범위는 첫 callback이 호출되기 전에 먼저 결정됩니다. find메서드가 실행 된 이후에 배열에 추가된 요소들에 대해서는 callback이 호출되지 않습니다. 아직 callback이 호출되지 않았던 배열 요소가 callback에 의해서 변경된 경우, find가 해당 요소의 인덱스를 방문할 때의 값으로 callback함수에 전달될 것입니다. 즉, 삭제된 요소에도 callback이 호출됩니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> result = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].find(<span class=\"function\">(<span class=\"params\">value, index, allData</span>) =&gt;</span> value === <span class=\"number\">2</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> result = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>].find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, allData</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> value === <span class=\"number\">1</span> &amp;&amp; value === <span class=\"keyword\">this</span>.key;  </span><br><span class=\"line\">&#125;, &#123;<span class=\"attr\">key</span>: <span class=\"number\">1</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\"><span class=\"comment\">//2  </span></span><br><span class=\"line\"><span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>[1, 2, 3]에서 1을 읽으면 콜백 함수가 호출됩니다. 콜백 함수의 value 파라미터에 1이 설정되고 index에 0이 설정되며, allData에 배열 전체가 설정됩니다.<br>value === 2에서 false를 반환하므로 배열의 다음 엘리먼트로 넘어가 콜백 함수를 호출합니다. 엘리먼트 값이 2이므로 true가 반환됩니다.<br><code>이때 find()를 종료하면서 처리 중인 엘리먼트 값 2가 반환됩니다.</code></p>\n</li>\n<li><p>find()의 두 번째 파라미터에 {key: 1}을 작성했으며 콜백 함수에서 this로 참조할 수 있습니다. 배열의 첫 번째 엘리먼트 값이 1이므로 콜백 함수가 true를 반환하고 find()가 종료됩니다. 엘리먼트 값 1을 반환합니다.<br>남은 엘리먼트 값 [2, 1]은 처리되지 않습니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Array_findeIndex\">findIndex(): 배열 인덱스 반환</h2>\n\n<p>콜백 함수에서 true를 반환하는 첫 번째 엘리먼트의 배열 인덱스를 반환합니다.<br>만족하는 요소가 없으면 -1을 반환합니다.</p>\n<blockquote>\n<p>Array.findIndex(callback(element[, index[, array]])[, thisArg])</p>\n</blockquote>\n<ul>\n<li><p>callback<br>3개의 인수를 취하여 배열의 각 값에 대해 실행할 함수입니다.</p>\n<ul>\n<li><p>element<br>배열에서 처리중인 현재 요소입니다.</p>\n</li>\n<li><p>index<br>배열에서 처리중인 현재 요소의 인덱스입니다.</p>\n</li>\n<li><p>array<br>findIndex 함수가 호출된 배열입니다.</p>\n</li>\n<li><p>thisArg (선택적 파라미터)<br>콜백을 실행할 때 this로 사용할 객체입니다.</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>반환 값<br>엘리먼트가 함수에 true값을 반환하면 그 배열의 인덱스 반환.<br>그렇지 않으면 -1을 반환합니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> result = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>].findIndex(  </span><br><span class=\"line\"> (value, index, allData) =&gt; value === <span class=\"number\">20</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> result = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>].findIndex(<span class=\"function\">(<span class=\"params\">value, index, allData</span>) =&gt;</span> value === <span class=\"number\">77</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> result = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>].findIndex(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, allData</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> value === <span class=\"number\">30</span> &amp;&amp; value === <span class=\"keyword\">this</span>.check;  </span><br><span class=\"line\">&#125;, &#123;<span class=\"attr\">check</span>: <span class=\"number\">30</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\"><span class=\"comment\">// 1  </span></span><br><span class=\"line\"><span class=\"comment\">// -1  </span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>[10, 20, 30]에서 처음의 10을 읽으면 콜백 함수가 호출됩니다.<br>콜백 함수의 value 파라미터에 10이 설정되고 index에 0이 설정되며,<br>allData에 배열 전체가 설정됩니다. value === 20 에서 false를 반환하므로<br>배열의 다음 엘리먼트로 넘어가 콜백 함수를 호출 합니다.<br>엘리먼트 값이 20이므로 true를 반환하며 findIndex()를 종료하며 처리 중인 인덱스 1을 반환합니다.</p>\n</li>\n<li><p>배열에 true값 77이 없으므로 배열의 엘리먼트 마지막까지 콜백 함수에서 false를 반환하게 되면 findIndex()를 종료하면서 -1을 반환합니다.</p>\n</li>\n<li><p>findIndex()의 두 번째 파라미터에 {check: 30}을 작성했으며<br>콜백 함수에서 this로 참조할 수 있습니다.<br>배열 엘리먼트 값이 30일 때 콜백 함수에서 true를 반환하며 인덱스 값이 2이므로<br>최종적으로 2를 반환합니다.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>ES6에서 Array오브젝트에 9개의 메서드가 추가되었습니다.<br>추가된 메서드를 살펴봅니다.</p>\n<ul>\n<li>Array 오브젝트<ul>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_from\">from(): Array 오브젝트 생성</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_of\">of(): 배열 엘리먼트 설정</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_copyWithin\">copyWithin(): 범위 값 복사, 설정</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_fill\">fill(): 범위 값 변경</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_enteries\">entries(): 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_keys\">keys(): key 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_values\">values(): value 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_find\">find(): 엘리먼트 값 비교, 반환</a></li>\n<li><a href=\"/2020/03/30/Array%20오브젝트%20-ECMAScript/#Array_findeIndex\">findIndex(): 배열 인덱스 반환</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"Array_from\">from(): Array 오브젝트 생성</h2>\n\n<p>새로운 Array 오브젝트를 생성하고 콜백 함수에서 반환된 값을 엘리먼트 값으로 설정하여 새로운 Array 객체를 반환합니다.</p>\n<blockquote>\n<p>Array.from(arrayLike[, mapFn[, thisArg]])</p>\n</blockquote>\n<ul>\n<li><p>arrayLike<br>배열로 변환하고자 하는 유사 배열 객체(Array-like)나 반복 가능한 객체(이터러블 오브젝트).</p>\n</li>\n<li><p>mapFn (선택적 파라미터)<br>배열의 모든 엘리먼트 마다 호출할 함수.</p>\n</li>\n<li><p>thisArg (선택적 파라미터)<br>두 번째 파라미터 함수 실행 시에 this로 참조할 값.</p>\n</li>\n<li><p>반환 값<br>새로운 Array 인스턴스.</p>\n</li>\n</ul>\n<h3 id=\"중요-포인트\"><a href=\"#중요-포인트\" class=\"headerlink\" title=\"중요 포인트\"></a>중요 포인트</h3><p>다음과 같은 경우에 Array.from()으로새Array를 만들 수 있습니다.</p>\n<ul>\n<li>유사 배열 객체 (length 속성과 인덱싱된 요소를 가진 객체)</li>\n<li>순회 가능한 객체 (Map, Set 등객체의 요소를 얻을 수 있는 객체)</li>\n</ul>\n<p>Array.from()은 선택 매개변수인 mapFn를 가지는데,배열(혹은 배열 서브클래스)의 각 요소를 맵핑할 때 사용할 수 있습니다. 즉,Array.from(obj, mapFn, thisArg)는 중간에 다른 배열을 생성하지 않는다는 점을 제외하면Array.from(obj).map(mapFn, thisArg)와 같습니다. 이 특징은 typed arrays와 같은 특정 배열 서브클래스에서 중간 배열 값이 적절한 유형에 맞게 생략되기 때문에 특히 중요합니다.</p>\n<p>from() 메서드의 length 속성은 1입니다.</p>\n<p>ES2015 이후, 클래스 구문은 내장 및 새 클래스의 상속을 가능케 했습니다. 그 결과로 Array.from과 같은 정적 메서드는 Array의 서브클래스에 의해 상속되며, Array 대신 자신의 인스턴스를 만듭니다.</p>\n<figure class=\"highlight js\"><figcaption><span>예제1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> arrayObj = <span class=\"built_in\">Array</span>.from(&#123;<span class=\"number\">0</span>: <span class=\"string\">\"zero\"</span>, <span class=\"number\">1</span>: <span class=\"string\">\"one\"</span>, <span class=\"attr\">length</span>: <span class=\"number\">2</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.isArray(arrayObj));  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrayObj);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> stringObj = <span class=\"built_in\">Array</span>.from(<span class=\"string\">\"ABC\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringObj);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// true  </span></span><br><span class=\"line\"><span class=\"comment\">// [\"zero\",\"one\"]  </span></span><br><span class=\"line\"><span class=\"comment\">// [\"A\", \"B\", \"C\"]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Array.from() 첫 번째 파라미터에 Array-like 오브젝트를 작성했습니다.<br>새로운 Array 오브젝트를 생성하고 Array-like 오브젝트의 프로퍼티 값을 배열에 추가하여 반환합니다. {0:”zero”, 1:”one”, length: 2}에서 프로퍼티 키와 length 프로퍼티를 제외한 “zero” 와 “one”이 생성된 Array 오브젝트에 추가됩니다.</p>\n</li>\n<li><p>Array.from() 파라미터 “ABC” 를 생성한 Array 오브젝트 배열의 엘리먼트에 하나씩 설정하여 반환합니다. 즉[“A”, “B”, “C”] 형태로 반환합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>예제2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;<span class=\"number\">0</span>: <span class=\"number\">10</span>, <span class=\"number\">1</span>: <span class=\"number\">30</span>, <span class=\"attr\">length</span>: <span class=\"number\">2</span>&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> values = <span class=\"built_in\">Array</span>.from(arrayLike, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> value + <span class=\"keyword\">this</span>.bonus;  </span><br><span class=\"line\">&#125;, &#123;<span class=\"attr\">bonus</span>: <span class=\"number\">100</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(values);  </span><br><span class=\"line\"><span class=\"comment\">// [110, 130]</span></span><br></pre></td></tr></table></figure>\n\n<p>Array-like 오브젝트의 프로퍼티를 하나씩 읽어 갑니다.<br>프로퍼티를 읽을 때 마다 콜백 함수를 호출 합니다.<br>읽은 프로퍼티 값이 콜백 함수의 value 파라미터에 설정됩니다.<br>콜백 함수에서 this로 from()의 세 번째 파라미터에 지정한 오브젝트를 참조할 수 있습니다. Array-like 오브젝트의 length 프로퍼티는 참조되지 않습니다.</p>\n<ol>\n<li><p>첫 번째 파라미터의 첫 번째 프로퍼티 값은 10 이며<br>두 번째 파라미터 콜백 함수의 value 파라미터에 설정됩니다.<br>this.bonus는 bonus 값을 참조합니다.</p>\n</li>\n<li><p>value + this.bonus는 110이 반환되고 생성된 Array 배열에 추가됩니다.</p>\n</li>\n<li><p>두 번째 프로퍼티 값인 30도 같은 방법으로 처리되고 최종적으로 생성된 배열을 반환합니다.</p>\n</li>\n</ol>\n<h3 id=\"그외-예제\"><a href=\"#그외-예제\" class=\"headerlink\" title=\"그외 예제\"></a>그외 예제</h3><ul>\n<li><p>Set에서 배열 만들기</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([‘foo’, <span class=\"built_in\">window</span>]);  </span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(s);  </span><br><span class=\"line\"><span class=\"comment\">// [“foo”, window]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Map에서 배열 만들기</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">2</span>, <span class=\"number\">4</span>], [<span class=\"number\">4</span>, <span class=\"number\">8</span>]]);  </span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(m);  </span><br><span class=\"line\"><span class=\"comment\">// [[1, 2], [2, 4], [4, 8]]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapper = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[‘<span class=\"number\">1</span>’, ‘a’], [‘<span class=\"number\">2</span>’, ‘b’]]);  </span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(mapper.values());  </span><br><span class=\"line\"><span class=\"comment\">// [‘a’, ‘b’];</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(mapper.keys());  </span><br><span class=\"line\"><span class=\"comment\">// [‘1’, ‘2’];</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>배열 형태를 가진 객체(arguments)에서 배열 만들기</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Array.from과 화살표 함수 사용하기</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], x =&gt; x + x);  </span><br><span class=\"line\"><span class=\"comment\">// [2, 4, 6]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 숫자생성  </span></span><br><span class=\"line\"><span class=\"comment\">// Array는 초기화 될때 각 위치마다 ‘undefined’값으로 초기화 됩니다.  </span></span><br><span class=\"line\"><span class=\"comment\">// 아래의 v 의 value 값은 undefined 가 될 것입니다.  </span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(&#123;<span class=\"attr\">length</span>: <span class=\"number\">5</span>&#125;, (v, i) =&gt; i);  </span><br><span class=\"line\"><span class=\"comment\">// [0, 1, 2, 3, 4]</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`    </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* * *</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&lt;h2 id=\"Array_of\"&gt;of(): 배열 엘리먼트 설정&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">파라미터 값을 새로운 배열의 엘리먼트로 설정하여 반환합니다.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&gt; Array.of(element0[, element1[, …[, elementN]]])</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">*   매개변수  </span></span><br><span class=\"line\"><span class=\"string\">    elementN  </span></span><br><span class=\"line\"><span class=\"string\">    배열을 생성할 때 사용할 엘리먼트.</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">*   반환 값  </span></span><br><span class=\"line\"><span class=\"string\">    새로운 Array 객체.</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">let</span> arrayObj = <span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrayObj);  </span><br><span class=\"line\"><span class=\"comment\">/// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>Array.of() 파라미터에 새로운 배열의 엘리먼트에 설정할 값을 작성합니다.<br>콤마로 구분하여 다수를 작성할 수 있습니다.<br>Array.of()가 호출되면 우선 Array 오브젝트를 생성합니다. 이어서 파라미터에 작성한 순서대로 Array 오브젝트에 추가한 후, 반환합니다.</p>\n<ul>\n<li><p>Array.from()은 파라미터에 Array-like 또는 이터러블 오브젝트를 지정하지만,<br>Array.of()는 파라미터에 값을 지정합니다.</p>\n</li>\n<li><p>Array.of()와 Array 생성자의 차이는 정수형 인자의 처리 방법에 있습니다.<br>Array.of(7)은 하나의 요소 7을 가진 배열을 생성하지만<br>Array(7)은 length 속성이 7인 빈 배열을 생성합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>Array.of</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">7</span>);       <span class=\"comment\">// [7]   </span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// [1, 2, 3]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">7</span>);          <span class=\"comment\">// [ , , , , , , ]  </span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);    <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"copyWithin\">copyWithin(): 범위 값 복사, 설정</h2>\n\n<p>copyWithin() 메서드는 배열의 일부를 인덱스 범위의 값을 복사하여, 동일한 배열의 지정한 위치에 덮어쓰고 그 배열을 반환합니다. 이 때, 배열의 길이를 수정하지 않고 반환합니다.</p>\n<blockquote>\n<p>Array.copyWithin(target[, start[, end]])</p>\n</blockquote>\n<ul>\n<li><p>target<br>복사한 값을 설정할 시작 인덱스. 음수를 지정하면 인덱스를 배열의 끝에서부터 계산합니다.<br>target이 arr.length보다 크거나 같으면 아무것도 복사하지 않습니다.<br>target이 start 이후라면 복사한 시퀀스를 arr.length에 맞춰 자릅니다.</p>\n</li>\n<li><p>start (선택적 파라미터)<br>복사를 시작할 위치를 가리키는 0 기반 인덱스.<br>음수를 지정하면 인덱스를 배열의 끝에서부터 계산합니다.<br>기본값은 0으로, start를 지정하지 않으면 배열의 처음부터 복사합니다.</p>\n</li>\n<li><p>end (선택적 파라미터)<br>복사를 끝낼 위치를 가리키는 0 기반 인덱스.<br>copyWithin은 end 인덱스 이전까지 복사하므로<br>end 인덱스가 가리키는 요소는 제외합니다. 음수를 지정하면 인덱스를 배열의 끝에서부터 계산합니다.<br>기본값은 arr.length로, end를 지정하지 않으면 배열의 끝까지 복사합니다.</p>\n</li>\n<li><p>반환 값<br>수정한 배열.</p>\n</li>\n</ul>\n<h3 id=\"중요-포인트-1\"><a href=\"#중요-포인트-1\" class=\"headerlink\" title=\"중요 포인트\"></a>중요 포인트</h3><p>copyWithin은 C와 C++의 memmove처럼 작동하고, 복사와 대입이 하나의 연산에서 이루어지므로 Array의 데이터를 이동할 때 사용할 수 있는 고성능 메서드입니다. TypedArray의 동명 메서드에서 이 특징이 두드러집니다. 붙여넣은 시퀀스의 위치가 복사한 범위와 겹치더라도 최종 결과는 원본 배열에서 복사한 것과 같습니다.</p>\n<p>copyWithin 함수는 <a href=\"https://heecheolman.tistory.com/67\">제네릭 함수</a>로, this 값이 Array 객체일 필요는 없습니다.</p>\n<p>copyWithin 메서드는 변경자 메서드로, this의 길이는 바꾸지 않지만 내용을 바꾸며 필요하다면 새로운 속성을 생성합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> one = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(one.copyWithin(<span class=\"number\">0</span>, <span class=\"number\">3</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> two = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(two.copyWithin(<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> three = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(three.copyWithin(<span class=\"number\">3</span>));  </span><br><span class=\"line\"><span class=\"comment\">// [4, 5, 3, 4, 5]  </span></span><br><span class=\"line\"><span class=\"comment\">// [3, 4, 3, 4, 5]  </span></span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 1, 2]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>copyWithin() 두 번째 파라미터에 지정한 인덱스 3부터 배열의 끝까지 엘리먼트 값을 복사하여 첫 번째 파라미터 값인 인덱스 0부터 차례대로 설정합니다. 4와 5를 인덱스 0 부터 설정하므로 [1, 2]가 [4, 5]로 대체되어 [4, 5, 3, 4, 5]가 됩니다.</p>\n</li>\n<li><p>두 번째 파라미터 값인 인덱스 2부터 세 번째 파라미터 값인 인덱스 4 직전까지 엘리먼트 값을 복사항 첫 번째 파라미터 값인 인덱스 0부터 차례대로 설정합니다.<br>3과 4를 인덱스 0부터 설정하므로 [1, 2]가 [3, 4]로 대체되어 [3, 4, 3, 4, 5]가 됩니다.</p>\n</li>\n<li><p>두 번째와 세 번째 파라미터를 작성하지 않았으므로 배열 전체를 복사하여<br>인덱스 3부터 설정합니다. 복사할 엘리먼트 수는 5이지만, 설정 할수 있는 엘리먼트의 수는 두 개 입니다. [4, 5]에 [1, 2]가 설정되고 나머지 [3, 4, 5]는 설정되지 않습니다. 즉 [1, 2, 3, 1, 2]가 출력됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>Array-like</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;<span class=\"number\">0</span>: <span class=\"string\">\"ABC\"</span>, <span class=\"number\">1</span>: <span class=\"string\">\"DEF\"</span>, <span class=\"number\">2</span>: <span class=\"string\">\"가나다\"</span>, <span class=\"attr\">length</span>: <span class=\"number\">3</span>&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> one = <span class=\"built_in\">Array</span>.prototype.copyWithin.call(arrayLike, <span class=\"number\">0</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(one);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">two</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.copyWithin.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(two(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>));  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Object  </span></span><br><span class=\"line\"><span class=\"comment\">0: \"DEF\"  </span></span><br><span class=\"line\"><span class=\"comment\">1: \"가나다\"  </span></span><br><span class=\"line\"><span class=\"comment\">2: \"가나다\"  </span></span><br><span class=\"line\"><span class=\"comment\">length: 3  </span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">Arguments(5)  </span></span><br><span class=\"line\"><span class=\"comment\">callee: (...)  </span></span><br><span class=\"line\"><span class=\"comment\">0: 1  </span></span><br><span class=\"line\"><span class=\"comment\">1: 2  </span></span><br><span class=\"line\"><span class=\"comment\">2: 3  </span></span><br><span class=\"line\"><span class=\"comment\">3: 1  </span></span><br><span class=\"line\"><span class=\"comment\">4: 2  </span></span><br><span class=\"line\"><span class=\"comment\">length: 5  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>Array-like 는 배열이 아닌 오브젝트이므로 Array.copyWithin()형태로 호출할 수 없습니다. 하지만 위와 같이 call()을 호출하면서 첫 번째 파라미터에 Array-like를 지정하면 copyWithin()이 호출됩니다.</p>\n<ol>\n<li><p>arrayLike 오브젝트의 프로퍼티 키인 0,1,2를 배열의 인덱스로 사용합니다.<br>세 번째 파라미터인 인덱스 1 부터 끝까지 복사하여 [“DEF”,”가나다”] 가<br>인덱스 0,1 값과 대체됩니다. {0: “DEF”, 1: “가나다”, 2: “가나다”, length: 3}</p>\n</li>\n<li><p>호출한 함수에서 넘겨준 파라미터 값이 arguments에 설정됩니다. arguments가 Array-ike 오브젝트 이므로 call()의 첫 번째 파라미터에 지정하면 copyWithin()을 호출할 수 있습니다. 인덱스 0 부터 인덱스 2 이전까지 복사합니다 [1, 2]<br>이를 인덱스 3부터 설정하여 인덱스 3,4의 값이 대체됩니다. [1, 2, 3, 1, 2]</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Array_fill\">fill(): 범위 값 변경</h2>\n\n<p>같은 배열에서 인덱스 범위의 값을 하나의 지정한 값으로 바꾸어 반환합니다.</p>\n<blockquote>\n<p>array.fill(value[, start[, end]])</p>\n</blockquote>\n<ul>\n<li><p>value<br>배열을 채울 값.</p>\n</li>\n<li><p>start (선택적 파라미터)<br>시작 인덱스, 기본 값은 0.</p>\n</li>\n<li><p>end (선택적 파라미터)<br>범위 끝 인덱스, 기본 값은 this.length.</p>\n</li>\n<li><p>반환 값<br>변형한 배열.</p>\n</li>\n</ul>\n<h3 id=\"중요-포인트-2\"><a href=\"#중요-포인트-2\" class=\"headerlink\" title=\"중요 포인트\"></a>중요 포인트</h3><ul>\n<li><p>start가 음수이면 시작 인덱스는 [length + start]입니다. end가 음수이면 끝 인덱스는 [length + end]입니다.</p>\n</li>\n<li><p>fill은 일반 함수이며, this 값이 배열 객체일 필요는 없습니다.</p>\n</li>\n<li><p>fill 메서드는 변경자 메서드로, 복사본이 아니라 this 객체를 변형해 반환합니다.<br>value에 객체를 받을 경우 그 참조만 복사해서 배열을 채웁니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(one.fill(<span class=\"number\">7</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> two = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(two.fill(<span class=\"number\">7</span>, <span class=\"number\">1</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> three = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(three.fill(<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>));  </span><br><span class=\"line\"><span class=\"comment\">// [7, 7, 7]  </span></span><br><span class=\"line\"><span class=\"comment\">// [1, 7, 7, 7, 7]  </span></span><br><span class=\"line\"><span class=\"comment\">// [1, 7, 7, 4, 5]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>범위를 지정해 주지 않았으므로 배열 전체가 변경 대상이 됩니다.<br>첫 번째 파라미터 7이 변경할 값이 되어 [7, 7, 7]로 변경됩니다.</p>\n</li>\n<li><p>두 번째 파라미터 인덱스 값1 부터 배열 끝까지가 변경 대상이 됩니다.<br>[1, 7, 7, 7, 7]로 변경됩니다.</p>\n</li>\n<li><p>두 번째 파라미터 인덱스 값1 부터 세 번째 파라미터 인덱스 3이전 까지가 변경 대상입니다. [2, 3]이 7로 변경되어 [1, 7, 7, 4, 5]이 됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Array_enteries\">entries(): 이터레이터 오브젝트 생성</h2>\n\n<p>Array오브젝트를 이터레이터 오브젝트로 생성하여 반환합니다.</p>\n<blockquote>\n<p>Array.entries()</p>\n</blockquote>\n<ul>\n<li>반환값 iterator</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>entries</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> values = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>];  </span><br><span class=\"line\"><span class=\"comment\">// Array 오브젝트로 이터레이터 오브젝트를 생성해 반환합니다.  </span></span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> iterator = values.entries();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> [key, value] <span class=\"keyword\">of</span> iterator)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, <span class=\"string\">\":\"</span>, value);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">/* Object   </span></span><br><span class=\"line\"><span class=\"comment\">&#123;value: Array(2)  </span></span><br><span class=\"line\"><span class=\"comment\"> [ &#123;0: 0&#125;,  </span></span><br><span class=\"line\"><span class=\"comment\"> &#123;1: 10&#125; ],  </span></span><br><span class=\"line\"><span class=\"comment\"> done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">1: 20  </span></span><br><span class=\"line\"><span class=\"comment\">2: 30  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>iterator 오브젝트의 next()를 호출 하면 {value: (2),done: false} 형태를 반환합니다. 배열의 인덱스와 엘리먼트가 프로퍼티 형태로 되기 때문입니다.<br>[{0: 0}, {1: 10}]</p>\n</li>\n<li><p>이터레이터 오브젝트는 for-of문에 [key: value]형태로 키와 값을 동시에 작성할 수 있습니다. 실행 결과에 “0: 10”이 출력되지 않는 것은 바로 앞의 next()에서 이터레이션 처리를 하였기 때문입니다. 따라서 for-of문은 두 번째 인덱스부터 처리되었습니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Array_keys\">keys(): key 이터레이터 오브젝트 생성</h2>\n\n<p>key만 갖는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<p>배열의 인덱스를 key 값으로 사용하여 이터레이터 오브젝트를 생성합니다.<br>배열의 엘리먼트 값은 이터레이터 오브젝트에 포함되지 않습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterator = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>].keys();  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">of</span> iterator)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, <span class=\"string\">\":\"</span>, iterator[key]);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">0 \":\" undefined  </span></span><br><span class=\"line\"><span class=\"comment\">1 \":\" undefined  </span></span><br><span class=\"line\"><span class=\"comment\">2 \":\" undefined  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>[10, 20, 30].keys()로 이터레이터 오브젝트를 생성하면<br><strong>인덱스 0, 1, 2만 설정되고 엘리먼트 값 [10, 20, 30]은 설정되지 않습니다.</strong><br>value 값에 undefined가 출력됩니다.</p>\n<p><code>for(var[key, value] of iterator){}와 같이 [key, value]를 작성하면 TypeError가 발생하므로 key만 작성해야 합니다.</code></p>\n<hr>\n<h2 id=\"Array_values\">values(): value 이터레이터 오브젝트 생성</h2>\n\n<p>value만 갖는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<p>배열 엘리먼트 값으로 이터레이터 오브젝트를 생성합니다.<br>배열 인덱스는 이터레이터 오브젝트에 포함되지 않습니다.<br>Symbol.iterator()와 같습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 크롬 52~54, 파이어폭스 47~49 지원하지 않음  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> iterator = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>].values();  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(iterator.next());  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(iterator.next());  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(iterator.next());  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(iterator.next());  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">1.Object  </span></span><br><span class=\"line\"><span class=\"comment\">value: 10  </span></span><br><span class=\"line\"><span class=\"comment\">done: false  </span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">2.Object  </span></span><br><span class=\"line\"><span class=\"comment\">value: 20  </span></span><br><span class=\"line\"><span class=\"comment\">done: false  </span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">3.Object  </span></span><br><span class=\"line\"><span class=\"comment\">value: 30  </span></span><br><span class=\"line\"><span class=\"comment\">done: false  </span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">4.Object  </span></span><br><span class=\"line\"><span class=\"comment\">value: undefined  </span></span><br><span class=\"line\"><span class=\"comment\">done: true  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>for-of 루프 반복을 사용 하려면.<br>브라우저가 for-of 루프와 for 루프안에 let 스코프 변수를 지원해야 합니다.</p>\n<hr>\n<h2 id=\"Array_find\">find(): 엘리먼트 값 비교, 반환</h2>\n\n<p>find() 메서드는 주어진 콜백 함수를 만족하는(true 값) 첫 번째 엘리먼트의 값을 반환합니다. 그런 요소가 없다면 undefined를 반환합니다.</p>\n<blockquote>\n<p>Array.find(callback[, thisArg])</p>\n</blockquote>\n<ul>\n<li><p>callback<br>배열의 각 값에 대해 실행할 함수. 아래의 세 인자를 받습니다.</p>\n<ul>\n<li><p>element<br>콜백함수에서 처리할 현재 엘리먼트.</p>\n</li>\n<li><p>index<br>콜백함수에서 처리할 현재 엘리먼트의 인덱스.</p>\n</li>\n<li><p>array<br>find 함수를 호출한 배열.</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>thisArg (선택적 파라미터)<br>콜백이 호출될 때 this로 사용할 객체.</p>\n</li>\n<li><p>반환 값<br>주어진 판별 함수를 만족하는 첫 번째 요소의 값. 그 외에는 undefined.</p>\n</li>\n</ul>\n<h3 id=\"중요-포인트-3\"><a href=\"#중요-포인트-3\" class=\"headerlink\" title=\"중요 포인트\"></a>중요 포인트</h3><ul>\n<li><p>find 메서드는 callback 함수가 참을 반환 할 때까지 해당 배열의 각 요소에 대해서 callback 함수를 실행합니다. 만약 어느 요소를 찾았다면 find 메서드는 해당 요소의 값을 즉시 반환하고, 그렇지 않았다면 undefined를 반환합니다.</p>\n</li>\n<li><p>callback은 0 부터 length - 1 까지 배열의 모든 인덱스에 대해 호출되며, <strong>값이 지정되지 않은 요소도 포함하여 모든 인덱스에 대해 호출됩니다. 따라서, 희소 배열 (sparse arrays)의 경우에는 값이 지정된 요소만 탐색하는 다른 메소드에 비해 더 비효율적입니다.</strong></p>\n</li>\n<li><p>thisArg 파라미터가 주어진 경우에는 제공되었다면 thisArg가 callback안에서 this로 사용되고, 그렇지 않은 경우 undefined 가 this로 사용됩니다.</p>\n</li>\n<li><p>find는 호출의 대상이 된 배열을 변경(mutate)하지 않습니다.</p>\n</li>\n<li><p>find가 처리할 배열 요소의 범위는 첫 callback이 호출되기 전에 먼저 결정됩니다. find메서드가 실행 된 이후에 배열에 추가된 요소들에 대해서는 callback이 호출되지 않습니다. 아직 callback이 호출되지 않았던 배열 요소가 callback에 의해서 변경된 경우, find가 해당 요소의 인덱스를 방문할 때의 값으로 callback함수에 전달될 것입니다. 즉, 삭제된 요소에도 callback이 호출됩니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> result = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].find(<span class=\"function\">(<span class=\"params\">value, index, allData</span>) =&gt;</span> value === <span class=\"number\">2</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> result = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>].find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, allData</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> value === <span class=\"number\">1</span> &amp;&amp; value === <span class=\"keyword\">this</span>.key;  </span><br><span class=\"line\">&#125;, &#123;<span class=\"attr\">key</span>: <span class=\"number\">1</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\"><span class=\"comment\">//2  </span></span><br><span class=\"line\"><span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>[1, 2, 3]에서 1을 읽으면 콜백 함수가 호출됩니다. 콜백 함수의 value 파라미터에 1이 설정되고 index에 0이 설정되며, allData에 배열 전체가 설정됩니다.<br>value === 2에서 false를 반환하므로 배열의 다음 엘리먼트로 넘어가 콜백 함수를 호출합니다. 엘리먼트 값이 2이므로 true가 반환됩니다.<br><code>이때 find()를 종료하면서 처리 중인 엘리먼트 값 2가 반환됩니다.</code></p>\n</li>\n<li><p>find()의 두 번째 파라미터에 {key: 1}을 작성했으며 콜백 함수에서 this로 참조할 수 있습니다. 배열의 첫 번째 엘리먼트 값이 1이므로 콜백 함수가 true를 반환하고 find()가 종료됩니다. 엘리먼트 값 1을 반환합니다.<br>남은 엘리먼트 값 [2, 1]은 처리되지 않습니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Array_findeIndex\">findIndex(): 배열 인덱스 반환</h2>\n\n<p>콜백 함수에서 true를 반환하는 첫 번째 엘리먼트의 배열 인덱스를 반환합니다.<br>만족하는 요소가 없으면 -1을 반환합니다.</p>\n<blockquote>\n<p>Array.findIndex(callback(element[, index[, array]])[, thisArg])</p>\n</blockquote>\n<ul>\n<li><p>callback<br>3개의 인수를 취하여 배열의 각 값에 대해 실행할 함수입니다.</p>\n<ul>\n<li><p>element<br>배열에서 처리중인 현재 요소입니다.</p>\n</li>\n<li><p>index<br>배열에서 처리중인 현재 요소의 인덱스입니다.</p>\n</li>\n<li><p>array<br>findIndex 함수가 호출된 배열입니다.</p>\n</li>\n<li><p>thisArg (선택적 파라미터)<br>콜백을 실행할 때 this로 사용할 객체입니다.</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>반환 값<br>엘리먼트가 함수에 true값을 반환하면 그 배열의 인덱스 반환.<br>그렇지 않으면 -1을 반환합니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> result = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>].findIndex(  </span><br><span class=\"line\"> (value, index, allData) =&gt; value === <span class=\"number\">20</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> result = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>].findIndex(<span class=\"function\">(<span class=\"params\">value, index, allData</span>) =&gt;</span> value === <span class=\"number\">77</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> result = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>].findIndex(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, allData</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> value === <span class=\"number\">30</span> &amp;&amp; value === <span class=\"keyword\">this</span>.check;  </span><br><span class=\"line\">&#125;, &#123;<span class=\"attr\">check</span>: <span class=\"number\">30</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\"><span class=\"comment\">// 1  </span></span><br><span class=\"line\"><span class=\"comment\">// -1  </span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>[10, 20, 30]에서 처음의 10을 읽으면 콜백 함수가 호출됩니다.<br>콜백 함수의 value 파라미터에 10이 설정되고 index에 0이 설정되며,<br>allData에 배열 전체가 설정됩니다. value === 20 에서 false를 반환하므로<br>배열의 다음 엘리먼트로 넘어가 콜백 함수를 호출 합니다.<br>엘리먼트 값이 20이므로 true를 반환하며 findIndex()를 종료하며 처리 중인 인덱스 1을 반환합니다.</p>\n</li>\n<li><p>배열에 true값 77이 없으므로 배열의 엘리먼트 마지막까지 콜백 함수에서 false를 반환하게 되면 findIndex()를 종료하면서 -1을 반환합니다.</p>\n</li>\n<li><p>findIndex()의 두 번째 파라미터에 {check: 30}을 작성했으며<br>콜백 함수에서 this로 참조할 수 있습니다.<br>배열 엘리먼트 값이 30일 때 콜백 함수에서 true를 반환하며 인덱스 값이 2이므로<br>최종적으로 2를 반환합니다.</p>\n</li>\n</ol>"},{"title":"Array(배열) 객체 -JavaScript","date":"2020-03-02T02:23:53.000Z","disqusId":"tunas-blog-1","_content":"\n여러 개의 데이터를 하나의 저장소에 저장하는 Array(배열) 객체\n\n사용법 3가지\n\n    1. var a =new Array();\n        a[0]=30;\n        a[1]=\"홍길동\";\n        a[2]=true;\n    \n    2. var b =new Array(30, \"홍길동\", true);\n    \n    3. var c =[30, \"홍길동\", true];\n\n<!-- more -->\n\n* * *\n\n#### 배열 객체의 메서드 및 속성\n\n| 종류                  | 설명                                                                   |\n|-----------------------|------------------------------------------------------------------------|\n| join(연결문자)        | 배열 객체에 데이터를 연결 문자 기준으로 1개의 문자형 데이터로 반환     |\n| reverse()             | 배열 객체에 데이터의 순서를 거꾸로 바꾼 후 반환                        |\n| sort()                | 배열 객체에 데이터를 오름차순으로 정렬                                 |\n| slice(index1, index2) | 배열 객체에 데이터 중 원하는 인덱스 구간만큼 잘라서 배열 객체로 가져옴 |\n| splice()              | 배열 객체에 지정 데이터를 삭제하고 그 구간에 새 데이터를 삽입          |\n| concat()              | 2개의 배열 객체를 하나로 결합                                          |\n| pop()                 | 배열에 저장된 데이터 중 마지막 인덱스에 저장된 데이터를 삭제           |\n| push(new data)        | 배열 객체 마지막 인덱스에 새 데이터 삽입                               |\n| shift()               | 배열 객체에 저장된 데이터 중 첫 번째 인덱스에 저장된 데이터를 삭제     |\n| unshift(new date)     | 배열 객체의 가장 앞의 인덱스에 새 데이터를 삽입                        |\n| length                | 배열에 저장된 총 데이터의 개수를 반환                                  |\n\n* * *\n\n#### join() 과 reverse() 사용 예제\n\n```js\nvar num=[\"사당\",\"교대\",\"방배\",\"강남\"];  \n  // 배열 객체를 출력합니다.  \n document.write(num,\"<br />\"); //사당,교대,방배,강남  \n  \n // 배열 객체의 형(type) 출력합니다.  \n document.write(typeof num,\"<br/>\"); //object  \n    \n // \"-\" 문자를 기준으로 하나의 문자형 데이터로 결합합니다.  \n document.write(num.join(\"-\"),\"<br/>\"); // 사당-교대-방배-강남  \n  \n // join으로 결합된 데이터의 형이 문자형 데이터인걸 확인할 수 있습니다.  \n document.write(typeof num.join(\"-\"),\"<br/>\"); //string  \n  \n // 배열 객체 값 순서가 역으로 출력됩니다.  \n document.write(num.reverse(),\"<br/>\"); // 강남,방배,교대,사당  \n  \n // 배열 객체 값들을 오름차순으로 정렬 후 출력합니다.  \n document.write(num.sort(),\"<br/>\"); // 강남,교대,방배,사당  \n```\n\n* * *\n\n#### splice() 와 slice() 사용 예제\n\n```js\nvar greenLine=[\"사당\",\"교대\",\"방배\",\"강남\"];  \n  \n/* greenline 배열 객체 인덱스 2에 저장된 데이터 1개를 삭제하고   \n \"서초\",\"역삼\" 데이터 삽입 */  \n greenLine.splice(2,1,\"서초\",\"역삼\"); //사당,교대,서초,역삼,강남  \n document.write(greenLine,\"<br/>\");  \n    \n // greenline 객체의 인덱스1 부터 3이전 까지 일부 데이터만 반환합니다.  \n document.write(greenLine.slice(1,3),\"<br/>\"); //교대,서초  \n```\n\n* * *\n\n#### concat(), pop(), push(), shift(), unshift() 사용 예제\n\n```js\nvar greenLine=[\"사당\",\"교대\",\"방배\",\"강남\"];  \nvar yellowLine=[\"미금\",\"정자\",\"모란\",\"수서\"];  \n  \n var twoLine=greenLine.concat(yellowLine);  \n document.write(twoLine,\"<br/>\"); // 2개의 배열 객체가 하나가 되어 twoLine에 저장됩니다.  \n  \n greenLine.pop();  \n document.write(greenLine,\"<br/>\"); // 마지막 인덱스 값인 \"강남\" 삭제됩니다.  \n  \n greenLine.push(\"삼성\");  \n document.write(greenLine,\"<br/>\"); // 마지막 인덱스에 \"삼성\" 값을 삽입합니다.  \n  \n greenLine.shift();  \n document.write(greenLine,\"<br/>\"); // 첫 번째 인덱스 값인 \"사당\" 삭제됩니다.  \n  \n greenLine.unshift(\"신도림\");  \n document.write(greenLine,\"<br/>\"); // 인덱스 가장 앞에 \"신도림\" 값을 삽입합니다.  \n```\n","source":"_posts/Array 배열 객체 -JavaScript.md","raw":"---\ntitle: Array(배열) 객체 -JavaScript\ndate: 2020-03-02 11:23:53\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\n여러 개의 데이터를 하나의 저장소에 저장하는 Array(배열) 객체\n\n사용법 3가지\n\n    1. var a =new Array();\n        a[0]=30;\n        a[1]=\"홍길동\";\n        a[2]=true;\n    \n    2. var b =new Array(30, \"홍길동\", true);\n    \n    3. var c =[30, \"홍길동\", true];\n\n<!-- more -->\n\n* * *\n\n#### 배열 객체의 메서드 및 속성\n\n| 종류                  | 설명                                                                   |\n|-----------------------|------------------------------------------------------------------------|\n| join(연결문자)        | 배열 객체에 데이터를 연결 문자 기준으로 1개의 문자형 데이터로 반환     |\n| reverse()             | 배열 객체에 데이터의 순서를 거꾸로 바꾼 후 반환                        |\n| sort()                | 배열 객체에 데이터를 오름차순으로 정렬                                 |\n| slice(index1, index2) | 배열 객체에 데이터 중 원하는 인덱스 구간만큼 잘라서 배열 객체로 가져옴 |\n| splice()              | 배열 객체에 지정 데이터를 삭제하고 그 구간에 새 데이터를 삽입          |\n| concat()              | 2개의 배열 객체를 하나로 결합                                          |\n| pop()                 | 배열에 저장된 데이터 중 마지막 인덱스에 저장된 데이터를 삭제           |\n| push(new data)        | 배열 객체 마지막 인덱스에 새 데이터 삽입                               |\n| shift()               | 배열 객체에 저장된 데이터 중 첫 번째 인덱스에 저장된 데이터를 삭제     |\n| unshift(new date)     | 배열 객체의 가장 앞의 인덱스에 새 데이터를 삽입                        |\n| length                | 배열에 저장된 총 데이터의 개수를 반환                                  |\n\n* * *\n\n#### join() 과 reverse() 사용 예제\n\n```js\nvar num=[\"사당\",\"교대\",\"방배\",\"강남\"];  \n  // 배열 객체를 출력합니다.  \n document.write(num,\"<br />\"); //사당,교대,방배,강남  \n  \n // 배열 객체의 형(type) 출력합니다.  \n document.write(typeof num,\"<br/>\"); //object  \n    \n // \"-\" 문자를 기준으로 하나의 문자형 데이터로 결합합니다.  \n document.write(num.join(\"-\"),\"<br/>\"); // 사당-교대-방배-강남  \n  \n // join으로 결합된 데이터의 형이 문자형 데이터인걸 확인할 수 있습니다.  \n document.write(typeof num.join(\"-\"),\"<br/>\"); //string  \n  \n // 배열 객체 값 순서가 역으로 출력됩니다.  \n document.write(num.reverse(),\"<br/>\"); // 강남,방배,교대,사당  \n  \n // 배열 객체 값들을 오름차순으로 정렬 후 출력합니다.  \n document.write(num.sort(),\"<br/>\"); // 강남,교대,방배,사당  \n```\n\n* * *\n\n#### splice() 와 slice() 사용 예제\n\n```js\nvar greenLine=[\"사당\",\"교대\",\"방배\",\"강남\"];  \n  \n/* greenline 배열 객체 인덱스 2에 저장된 데이터 1개를 삭제하고   \n \"서초\",\"역삼\" 데이터 삽입 */  \n greenLine.splice(2,1,\"서초\",\"역삼\"); //사당,교대,서초,역삼,강남  \n document.write(greenLine,\"<br/>\");  \n    \n // greenline 객체의 인덱스1 부터 3이전 까지 일부 데이터만 반환합니다.  \n document.write(greenLine.slice(1,3),\"<br/>\"); //교대,서초  \n```\n\n* * *\n\n#### concat(), pop(), push(), shift(), unshift() 사용 예제\n\n```js\nvar greenLine=[\"사당\",\"교대\",\"방배\",\"강남\"];  \nvar yellowLine=[\"미금\",\"정자\",\"모란\",\"수서\"];  \n  \n var twoLine=greenLine.concat(yellowLine);  \n document.write(twoLine,\"<br/>\"); // 2개의 배열 객체가 하나가 되어 twoLine에 저장됩니다.  \n  \n greenLine.pop();  \n document.write(greenLine,\"<br/>\"); // 마지막 인덱스 값인 \"강남\" 삭제됩니다.  \n  \n greenLine.push(\"삼성\");  \n document.write(greenLine,\"<br/>\"); // 마지막 인덱스에 \"삼성\" 값을 삽입합니다.  \n  \n greenLine.shift();  \n document.write(greenLine,\"<br/>\"); // 첫 번째 인덱스 값인 \"사당\" 삭제됩니다.  \n  \n greenLine.unshift(\"신도림\");  \n document.write(greenLine,\"<br/>\"); // 인덱스 가장 앞에 \"신도림\" 값을 삽입합니다.  \n```\n","slug":"Array 배열 객체 -JavaScript","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrro0001qgvqa80b64ht","content":"<p>여러 개의 데이터를 하나의 저장소에 저장하는 Array(배열) 객체</p>\n<p>사용법 3가지</p>\n<pre><code>1. var a =new Array();\n    a[0]=30;\n    a[1]=&quot;홍길동&quot;;\n    a[2]=true;\n\n2. var b =new Array(30, &quot;홍길동&quot;, true);\n\n3. var c =[30, &quot;홍길동&quot;, true];</code></pre><a id=\"more\"></a>\n\n<hr>\n<h4 id=\"배열-객체의-메서드-및-속성\"><a href=\"#배열-객체의-메서드-및-속성\" class=\"headerlink\" title=\"배열 객체의 메서드 및 속성\"></a>배열 객체의 메서드 및 속성</h4><table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>join(연결문자)</td>\n<td>배열 객체에 데이터를 연결 문자 기준으로 1개의 문자형 데이터로 반환</td>\n</tr>\n<tr>\n<td>reverse()</td>\n<td>배열 객체에 데이터의 순서를 거꾸로 바꾼 후 반환</td>\n</tr>\n<tr>\n<td>sort()</td>\n<td>배열 객체에 데이터를 오름차순으로 정렬</td>\n</tr>\n<tr>\n<td>slice(index1, index2)</td>\n<td>배열 객체에 데이터 중 원하는 인덱스 구간만큼 잘라서 배열 객체로 가져옴</td>\n</tr>\n<tr>\n<td>splice()</td>\n<td>배열 객체에 지정 데이터를 삭제하고 그 구간에 새 데이터를 삽입</td>\n</tr>\n<tr>\n<td>concat()</td>\n<td>2개의 배열 객체를 하나로 결합</td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>배열에 저장된 데이터 중 마지막 인덱스에 저장된 데이터를 삭제</td>\n</tr>\n<tr>\n<td>push(new data)</td>\n<td>배열 객체 마지막 인덱스에 새 데이터 삽입</td>\n</tr>\n<tr>\n<td>shift()</td>\n<td>배열 객체에 저장된 데이터 중 첫 번째 인덱스에 저장된 데이터를 삭제</td>\n</tr>\n<tr>\n<td>unshift(new date)</td>\n<td>배열 객체의 가장 앞의 인덱스에 새 데이터를 삽입</td>\n</tr>\n<tr>\n<td>length</td>\n<td>배열에 저장된 총 데이터의 개수를 반환</td>\n</tr>\n</tbody></table>\n<hr>\n<h4 id=\"join-과-reverse-사용-예제\"><a href=\"#join-과-reverse-사용-예제\" class=\"headerlink\" title=\"join() 과 reverse() 사용 예제\"></a>join() 과 reverse() 사용 예제</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num=[<span class=\"string\">\"사당\"</span>,<span class=\"string\">\"교대\"</span>,<span class=\"string\">\"방배\"</span>,<span class=\"string\">\"강남\"</span>];  </span><br><span class=\"line\">  <span class=\"comment\">// 배열 객체를 출력합니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(num,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">//사당,교대,방배,강남  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"comment\">// 배열 객체의 형(type) 출력합니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"keyword\">typeof</span> num,<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">//object  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">// \"-\" 문자를 기준으로 하나의 문자형 데이터로 결합합니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(num.join(<span class=\"string\">\"-\"</span>),<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 사당-교대-방배-강남  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"comment\">// join으로 결합된 데이터의 형이 문자형 데이터인걸 확인할 수 있습니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"keyword\">typeof</span> num.join(<span class=\"string\">\"-\"</span>),<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">//string  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"comment\">// 배열 객체 값 순서가 역으로 출력됩니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(num.reverse(),<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 강남,방배,교대,사당  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"comment\">// 배열 객체 값들을 오름차순으로 정렬 후 출력합니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(num.sort(),<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 강남,교대,방배,사당</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"splice-와-slice-사용-예제\"><a href=\"#splice-와-slice-사용-예제\" class=\"headerlink\" title=\"splice() 와 slice() 사용 예제\"></a>splice() 와 slice() 사용 예제</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greenLine=[<span class=\"string\">\"사당\"</span>,<span class=\"string\">\"교대\"</span>,<span class=\"string\">\"방배\"</span>,<span class=\"string\">\"강남\"</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/* greenline 배열 객체 인덱스 2에 저장된 데이터 1개를 삭제하고   </span></span><br><span class=\"line\"><span class=\"comment\"> \"서초\",\"역삼\" 데이터 삽입 */</span>  </span><br><span class=\"line\"> greenLine.splice(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"string\">\"서초\"</span>,<span class=\"string\">\"역삼\"</span>); <span class=\"comment\">//사당,교대,서초,역삼,강남  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(greenLine,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">// greenline 객체의 인덱스1 부터 3이전 까지 일부 데이터만 반환합니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(greenLine.slice(<span class=\"number\">1</span>,<span class=\"number\">3</span>),<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">//교대,서초</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"concat-pop-push-shift-unshift-사용-예제\"><a href=\"#concat-pop-push-shift-unshift-사용-예제\" class=\"headerlink\" title=\"concat(), pop(), push(), shift(), unshift() 사용 예제\"></a>concat(), pop(), push(), shift(), unshift() 사용 예제</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greenLine=[<span class=\"string\">\"사당\"</span>,<span class=\"string\">\"교대\"</span>,<span class=\"string\">\"방배\"</span>,<span class=\"string\">\"강남\"</span>];  </span><br><span class=\"line\"><span class=\"keyword\">var</span> yellowLine=[<span class=\"string\">\"미금\"</span>,<span class=\"string\">\"정자\"</span>,<span class=\"string\">\"모란\"</span>,<span class=\"string\">\"수서\"</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> twoLine=greenLine.concat(yellowLine);  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(twoLine,<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 2개의 배열 객체가 하나가 되어 twoLine에 저장됩니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> greenLine.pop();  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(greenLine,<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 마지막 인덱스 값인 \"강남\" 삭제됩니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> greenLine.push(<span class=\"string\">\"삼성\"</span>);  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(greenLine,<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 마지막 인덱스에 \"삼성\" 값을 삽입합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> greenLine.shift();  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(greenLine,<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 첫 번째 인덱스 값인 \"사당\" 삭제됩니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> greenLine.unshift(<span class=\"string\">\"신도림\"</span>);  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(greenLine,<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 인덱스 가장 앞에 \"신도림\" 값을 삽입합니다.</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>여러 개의 데이터를 하나의 저장소에 저장하는 Array(배열) 객체</p>\n<p>사용법 3가지</p>\n<pre><code>1. var a =new Array();\n    a[0]=30;\n    a[1]=&quot;홍길동&quot;;\n    a[2]=true;\n\n2. var b =new Array(30, &quot;홍길동&quot;, true);\n\n3. var c =[30, &quot;홍길동&quot;, true];</code></pre>","more":"<hr>\n<h4 id=\"배열-객체의-메서드-및-속성\"><a href=\"#배열-객체의-메서드-및-속성\" class=\"headerlink\" title=\"배열 객체의 메서드 및 속성\"></a>배열 객체의 메서드 및 속성</h4><table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>join(연결문자)</td>\n<td>배열 객체에 데이터를 연결 문자 기준으로 1개의 문자형 데이터로 반환</td>\n</tr>\n<tr>\n<td>reverse()</td>\n<td>배열 객체에 데이터의 순서를 거꾸로 바꾼 후 반환</td>\n</tr>\n<tr>\n<td>sort()</td>\n<td>배열 객체에 데이터를 오름차순으로 정렬</td>\n</tr>\n<tr>\n<td>slice(index1, index2)</td>\n<td>배열 객체에 데이터 중 원하는 인덱스 구간만큼 잘라서 배열 객체로 가져옴</td>\n</tr>\n<tr>\n<td>splice()</td>\n<td>배열 객체에 지정 데이터를 삭제하고 그 구간에 새 데이터를 삽입</td>\n</tr>\n<tr>\n<td>concat()</td>\n<td>2개의 배열 객체를 하나로 결합</td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>배열에 저장된 데이터 중 마지막 인덱스에 저장된 데이터를 삭제</td>\n</tr>\n<tr>\n<td>push(new data)</td>\n<td>배열 객체 마지막 인덱스에 새 데이터 삽입</td>\n</tr>\n<tr>\n<td>shift()</td>\n<td>배열 객체에 저장된 데이터 중 첫 번째 인덱스에 저장된 데이터를 삭제</td>\n</tr>\n<tr>\n<td>unshift(new date)</td>\n<td>배열 객체의 가장 앞의 인덱스에 새 데이터를 삽입</td>\n</tr>\n<tr>\n<td>length</td>\n<td>배열에 저장된 총 데이터의 개수를 반환</td>\n</tr>\n</tbody></table>\n<hr>\n<h4 id=\"join-과-reverse-사용-예제\"><a href=\"#join-과-reverse-사용-예제\" class=\"headerlink\" title=\"join() 과 reverse() 사용 예제\"></a>join() 과 reverse() 사용 예제</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num=[<span class=\"string\">\"사당\"</span>,<span class=\"string\">\"교대\"</span>,<span class=\"string\">\"방배\"</span>,<span class=\"string\">\"강남\"</span>];  </span><br><span class=\"line\">  <span class=\"comment\">// 배열 객체를 출력합니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(num,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">//사당,교대,방배,강남  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"comment\">// 배열 객체의 형(type) 출력합니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"keyword\">typeof</span> num,<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">//object  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">// \"-\" 문자를 기준으로 하나의 문자형 데이터로 결합합니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(num.join(<span class=\"string\">\"-\"</span>),<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 사당-교대-방배-강남  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"comment\">// join으로 결합된 데이터의 형이 문자형 데이터인걸 확인할 수 있습니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"keyword\">typeof</span> num.join(<span class=\"string\">\"-\"</span>),<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">//string  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"comment\">// 배열 객체 값 순서가 역으로 출력됩니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(num.reverse(),<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 강남,방배,교대,사당  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"comment\">// 배열 객체 값들을 오름차순으로 정렬 후 출력합니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(num.sort(),<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 강남,교대,방배,사당</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"splice-와-slice-사용-예제\"><a href=\"#splice-와-slice-사용-예제\" class=\"headerlink\" title=\"splice() 와 slice() 사용 예제\"></a>splice() 와 slice() 사용 예제</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greenLine=[<span class=\"string\">\"사당\"</span>,<span class=\"string\">\"교대\"</span>,<span class=\"string\">\"방배\"</span>,<span class=\"string\">\"강남\"</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/* greenline 배열 객체 인덱스 2에 저장된 데이터 1개를 삭제하고   </span></span><br><span class=\"line\"><span class=\"comment\"> \"서초\",\"역삼\" 데이터 삽입 */</span>  </span><br><span class=\"line\"> greenLine.splice(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"string\">\"서초\"</span>,<span class=\"string\">\"역삼\"</span>); <span class=\"comment\">//사당,교대,서초,역삼,강남  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(greenLine,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">// greenline 객체의 인덱스1 부터 3이전 까지 일부 데이터만 반환합니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(greenLine.slice(<span class=\"number\">1</span>,<span class=\"number\">3</span>),<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">//교대,서초</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"concat-pop-push-shift-unshift-사용-예제\"><a href=\"#concat-pop-push-shift-unshift-사용-예제\" class=\"headerlink\" title=\"concat(), pop(), push(), shift(), unshift() 사용 예제\"></a>concat(), pop(), push(), shift(), unshift() 사용 예제</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greenLine=[<span class=\"string\">\"사당\"</span>,<span class=\"string\">\"교대\"</span>,<span class=\"string\">\"방배\"</span>,<span class=\"string\">\"강남\"</span>];  </span><br><span class=\"line\"><span class=\"keyword\">var</span> yellowLine=[<span class=\"string\">\"미금\"</span>,<span class=\"string\">\"정자\"</span>,<span class=\"string\">\"모란\"</span>,<span class=\"string\">\"수서\"</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> twoLine=greenLine.concat(yellowLine);  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(twoLine,<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 2개의 배열 객체가 하나가 되어 twoLine에 저장됩니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> greenLine.pop();  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(greenLine,<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 마지막 인덱스 값인 \"강남\" 삭제됩니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> greenLine.push(<span class=\"string\">\"삼성\"</span>);  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(greenLine,<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 마지막 인덱스에 \"삼성\" 값을 삽입합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> greenLine.shift();  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(greenLine,<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 첫 번째 인덱스 값인 \"사당\" 삭제됩니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> greenLine.unshift(<span class=\"string\">\"신도림\"</span>);  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(greenLine,<span class=\"string\">\"&lt;br/&gt;\"</span>); <span class=\"comment\">// 인덱스 가장 앞에 \"신도림\" 값을 삽입합니다.</span></span><br></pre></td></tr></table></figure>"},{"title":"Arrow -ECMAScript","date":"2020-03-17T02:51:03.000Z","disqusId":"tunas-blog-1","_content":"\narrow(화살표) 함수는  \nfunction(param) {코드} 형태를 축약한 것으로\n\n> (param) => {코드}\n\n형태로 작성합니다.\n\n화살표 함수 표현(arrow function expression)은 function 표현에 비해 구문이 짧고 자신의 this, arguments, super 또는 new.target을 바인딩 하지 않습니다.  \n화살표 함수는 항상 익명입니다. 이 함수 표현은 메소드 함수가 아닌 곳에 가장 적합합니다. 그래서 생성자로서 사용할 수 없습니다.\n\n<!-- more -->\n\n* * *\n\n*   기본 구문\n\n> (param1, param2, …, paramN) => { statements }  \n> (param1, param2, …, paramN) => expression  \n> // 다음과 동일함: => { return expression; }\n\n> // 매개변수가 하나뿐인 경우 괄호는 선택사항:  \n> (singleParam) => { statements }  \n> singleParam => { statements }\n\n> // 매개변수가 없는 함수는 괄호가 필요:  \n> () => { statements }\n\n* * *\n\n*   고급 구문\n\n```js\n// 객체 리터럴 표현을 반환하기 위해서는 함수 본문(body)을 괄호 속에 넣음:  \nparams => ({foo: bar})\n```\n\n```js\n// 나머지 매개변수 및 기본 매개변수를 지원함  \n(param1, param2, …rest) => { statements }  \n(param1 = defaultValue1, param2, …, paramN = defaultValueN) => { statements }\n```\n```js\n// 매개변수 목록 내 비구조화도 지원됨  \nvar f = ([a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;  \nf(); // 6\n```\n\n```js 예시\nvar materials = [  \n 'Hydrogen',  \n 'Helium',  \n 'Lithium',  \n 'Beryllium'  \n];  \n  \nmaterials.map(function(material) {   \n return material.length;   \n}); // [8, 6, 7, 9]  \n  \n// 위에 있는 함수를 arrow 함수를 이용해 아래와 같이 표현할 수 있다  \nmaterials.map((material) => {  \n return material.length;  \n}); // [8, 6, 7, 9]  \n  \nmaterials.map(({length}) => length); // [8, 6, 7, 9]  \n```\n\n* * *\n\n*   줄바꿈  \n    화살표 함수는 파라미터와 화살표 사이에 개행 문자를 포함 할 수 없습니다.\n\n> var func = (a, b, c)  \n> => 1;  \n> // SyntaxError: expected expression, got ‘=>’\n\n하지만, 보기 좋은 코드를 유지하고 싶다면, 아래에 보는 것처럼 괄호나 개행을 둠으로써 이를 수정할 수 있습니다.\n\n```js\nvar func = (  \na,  \nb,  \nc  \n) => (  \n1  \n);  \n// SyntaxError가 발생하지 않습니다.\n```\n\n* * *\n\n* new 연산자 사용  \n화살표 함수는 생성자로서 사용될 수 없으며 new와 함께 사용하면 오류가 발생합니다.\n\n> var Foo = () => {};  \n> var foo = new Foo(); // TypeError: Foo is not a constructor\n\n* * *\n\n* prototype 속성 사용  \n화살표 함수는 prototype 속성이 없습니다.\n\n> var Foo = () => {};  \n> console.log(Foo.prototype); // undefined\n\n* * *\n\n* 함수 호출  \narrow 함수는 함수 이름이 없는 무명(혹은 익명) 함수 입니다.  \n따라서 함수를 호출 하려면 함수 표현식과 같이 변수에 할당해야 합니다.\n\n> let fn = (param) => {코드}\n\n위 처럼 arrow 함수로 생성한 function 오브젝트를 할당할 변수를 작성해야합니다.\n\n```js\n\"use strict\";  \ndebugger;  \n  \n//arrow 함수로 생성된 function 오브젝트를 할당할 변수 es6 작성  \nlet es6 = (one, two) => { //파라미터 (one,two) 작성  \n return one + two;  \n};  \nlet result = es6(1, 2);  \nconsole.log(result); // 3  \n```\n\n* * *\n\n## 블록,파라미터\n\narrow 함수에서 함수 블록{}을 사용하지 않고 한 줄에 작성할 수 있습니다.\n\n```js {}없이 한줄 작성\n\"use strict\";  \ndebugger;  \n  \nlet total = (one, two) => one + two;  \nlet result = total(1, 2);   \nconsole.log(result); // 3  \n```\n\n블록{}을 사용하지 않은 형태입니다.  \n()안의 one,two가 total 함수의 파라미터가 됩니다.  \none + two; 는 return을 생략한 것입니다.  \nreturn one + two; 와 동일합니다.\n\n* 호출 받는 파라미터가 하나인경우 소괄호()을 제외하고 작성할 수도 있습니다.\n\n```js ()제외\nlet get = value => value + 10; // = (value) + 10;  \nlet result = get(20);  \nconsole.log(result); // 30  \n```\n\n*   파라미터 없이 함수 호출만 이루어 진다면 ()만 작성합니다.\n\n```js\nlet noParam = () => 3 + 4;  \nlet result = noParam();  \nconsole.log(result); // 7  \n```\n\n* * *\n\n## {key: value} 형태의 Objedt 오브젝트 반환\n\n{key: value} 형태의 Objedt 오브젝트 반환하려면 ()안에 {key: value}를 작성합니다.\n\n```js (o)\nlet get = param => ({sports: \"축구\"});  \nlet result = get();  \nconsole.log(result); // Object {sports: \"축구\"}  \n```\n\nJavaScript는 소괄호() 안의 코드를 표현식으로 인식합니다.  \n그래서 소괄호()안에 작성된 {sports: “축구”}를 반환할 수 있습니다.\n\n\n```js (x)\nlet sports = () => {};  \nlet result = sports();  \nconsole.log(result); // undefined  \n```\n\n위 코드는 sports() 함수를 호출하면 {key: value} 형태의  \n빈 Object 오브젝트를 반환하는 것이 목적입니다.\n\n하지만, arrow (=>) 다음의 블록{}을 함수 블록으로 인식하고  \n함수 블록{}안에 return문을 작성하지 않은 것으로 인식되어  \n함수 안에 return문을 작성하지 않았을 때의 디폴트 값 undefined가 반환됩니다.\n\n<mark>arrow 함수이기 때문에 undefined값이 반환 되는것이 아니라\nES5 기준으로 함수블록으로 인식되었기 때문입니다.</mark>\n\n* * *\n\n## arguments\n\n자바스크립트에서는 함수를 호출할 때 인수들과 함께 암묵적으로 arguments 객체가 함수 내부로 전달된다.\n\narguments 객체는 함수를 호출할 때 넘긴 인자들이 배열 형태로 저장된 객체를 의미한다.\n\n특이한 점은 실재 배열이 아닌 마치 배열 형태처럼 숫자로 인덱싱된 프로퍼티가 있는 객체다.\n\n이러한 객체를 <mark>배열과 유사하다 하여 유사 배열 객체</mark>라고 부른다.\n\n*   arguments 객체는 세 부분으로 구성되어 있다.\n\n1.  함수를 호출할 때 넘겨진 인자(배열 형태): 첫 번째 인자는 0, … n-1번 인덱스\n    \n2.  length 프로퍼티: 호출할 때 넘겨진 인자의 개수\n    \n3.  callee 프로퍼티: 현재 실행 중인 함수의 참조값\n    \n\n`arguments은 유사 배열 객체로써 배열과 유사하게 동작하지만, 배열은 아니므로 배열 메서드를 사용하면 에러가 발생한다.`\n\n**바인딩 되지 않은 arguments**\n\n화살표 함수는 arguments 객체를 바인드 하지 않습니다.  \n때문에 arguments 프로퍼티를 사용할 수 없습니다.\n\n```js\nlet sports = () => {  \n try {  \n let args = arguments; //ReferenceError  \n } catch (error) {  \n console.log(\"사용 불가\");  \n }  \n}  \nsports(1, 2);  \n```\n\n`ES6에서는 arguments 대신에 rest 파라미터를 사용합니다.`\n\n> let sports = (…rest) => {코드}\n\n()안에 …을 작성하고 이어서 파라미터를 작성합니다.\n\n```js\nfunction foo(n) {  \n var f = (...args) => args[0] + n;  \n return f(2);  \n}  \n  \nfoo(1); // 3  \n```\n\n* * *\n\n## this와 setTimeout()\n\narrow함수가 간단한 코드작성을 할 수 있어 편리하지만  \nthis의 참조 경우를 고려해야 합니다.\n\n```js 예시\nlet Sports = function(){  \n this.count = 20;  \n};  \nSports.prototype = {  \n plus: function(){  \n this.count += 1;  \n },  \n get: function(){  \n setTimeout(function(){  \n console.log(this === window);  \n console.log(this.plus);  \n }, 1000);  \n }  \n};  \n// newSports 변수에 new 연산자로 생성된 Sports 인스턴스를 생성하여 할당합니다.  \nlet newSports = new Sports();  \n//get() 함수에 작성된 setTimeout() 함수가 실행되어  \n//1초 후에 콜백 함수가 실행됩니다.  \nnewSports.get();  \n// true  \n// undefined  \n```\n\n*   setTimeout()이 window 오브젝트 함수 이므로  \n    this가 window 오브젝트를 참조하게 되어 true가 출력됩니다.\n\n*   중요한 점은 newSports.get()형태로 호출 하였기 때문에  \n    this가 newSports 인스턴스를 참조 하지 않고  \n    window 오브젝트를 참조 한다는 것 입니다.\n\n*   this가 newSports 인스턴스를 참조하지 못하므로  \n    setTimeout()을 실행하기 전에 newSports 인스턴스를 변수에 할당하고,  \n    setTimeout() 콜백 함수에서 변수의 인스턴스를 사용하는 형태를 취했습니다.\n\n*   console.log(this.plus)코드의 목적은  \n    this로 newSports 인스턴스를 참조하여 plus 메서드를 반환받는 것입니다.  \n    그런데 this가 window 오브젝트를 참조하므로 undefined값이 출력됩니다.\n\n```js 해결방법\nlet Sports = function(){  \n this.count = 20;  \n};  \nSports.prototype = {  \n plus: function(){  \n this.count += 1;  \n },  \n get: function() {  \n setTimeout(() => { // 콜백 함수를 arrow함수로 작성합니다.  \n this.plus();  \n console.log(this.count);  \n }, 1000);  \n }  \n};  \nlet newSports = new Sports();  \nnewSports.get(); // 21  \n```\n\n*   setTimeout() 함수의 콜백 함수를 arrow함수로 작성하면  \n    this가 newSports.get()형태에서 newSports 인스턴스를 참조 할수 있게 됩니다.\n","source":"_posts/Arrow -ECMAScript.md","raw":"---\ntitle: Arrow -ECMAScript\ndate: 2020-03-17 11:51:03\ncategories: ECMAScript6\ndisqusId: tunas-blog-1\ntag: \n- ECMAScript6\n- JavaScript\n---\n\narrow(화살표) 함수는  \nfunction(param) {코드} 형태를 축약한 것으로\n\n> (param) => {코드}\n\n형태로 작성합니다.\n\n화살표 함수 표현(arrow function expression)은 function 표현에 비해 구문이 짧고 자신의 this, arguments, super 또는 new.target을 바인딩 하지 않습니다.  \n화살표 함수는 항상 익명입니다. 이 함수 표현은 메소드 함수가 아닌 곳에 가장 적합합니다. 그래서 생성자로서 사용할 수 없습니다.\n\n<!-- more -->\n\n* * *\n\n*   기본 구문\n\n> (param1, param2, …, paramN) => { statements }  \n> (param1, param2, …, paramN) => expression  \n> // 다음과 동일함: => { return expression; }\n\n> // 매개변수가 하나뿐인 경우 괄호는 선택사항:  \n> (singleParam) => { statements }  \n> singleParam => { statements }\n\n> // 매개변수가 없는 함수는 괄호가 필요:  \n> () => { statements }\n\n* * *\n\n*   고급 구문\n\n```js\n// 객체 리터럴 표현을 반환하기 위해서는 함수 본문(body)을 괄호 속에 넣음:  \nparams => ({foo: bar})\n```\n\n```js\n// 나머지 매개변수 및 기본 매개변수를 지원함  \n(param1, param2, …rest) => { statements }  \n(param1 = defaultValue1, param2, …, paramN = defaultValueN) => { statements }\n```\n```js\n// 매개변수 목록 내 비구조화도 지원됨  \nvar f = ([a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;  \nf(); // 6\n```\n\n```js 예시\nvar materials = [  \n 'Hydrogen',  \n 'Helium',  \n 'Lithium',  \n 'Beryllium'  \n];  \n  \nmaterials.map(function(material) {   \n return material.length;   \n}); // [8, 6, 7, 9]  \n  \n// 위에 있는 함수를 arrow 함수를 이용해 아래와 같이 표현할 수 있다  \nmaterials.map((material) => {  \n return material.length;  \n}); // [8, 6, 7, 9]  \n  \nmaterials.map(({length}) => length); // [8, 6, 7, 9]  \n```\n\n* * *\n\n*   줄바꿈  \n    화살표 함수는 파라미터와 화살표 사이에 개행 문자를 포함 할 수 없습니다.\n\n> var func = (a, b, c)  \n> => 1;  \n> // SyntaxError: expected expression, got ‘=>’\n\n하지만, 보기 좋은 코드를 유지하고 싶다면, 아래에 보는 것처럼 괄호나 개행을 둠으로써 이를 수정할 수 있습니다.\n\n```js\nvar func = (  \na,  \nb,  \nc  \n) => (  \n1  \n);  \n// SyntaxError가 발생하지 않습니다.\n```\n\n* * *\n\n* new 연산자 사용  \n화살표 함수는 생성자로서 사용될 수 없으며 new와 함께 사용하면 오류가 발생합니다.\n\n> var Foo = () => {};  \n> var foo = new Foo(); // TypeError: Foo is not a constructor\n\n* * *\n\n* prototype 속성 사용  \n화살표 함수는 prototype 속성이 없습니다.\n\n> var Foo = () => {};  \n> console.log(Foo.prototype); // undefined\n\n* * *\n\n* 함수 호출  \narrow 함수는 함수 이름이 없는 무명(혹은 익명) 함수 입니다.  \n따라서 함수를 호출 하려면 함수 표현식과 같이 변수에 할당해야 합니다.\n\n> let fn = (param) => {코드}\n\n위 처럼 arrow 함수로 생성한 function 오브젝트를 할당할 변수를 작성해야합니다.\n\n```js\n\"use strict\";  \ndebugger;  \n  \n//arrow 함수로 생성된 function 오브젝트를 할당할 변수 es6 작성  \nlet es6 = (one, two) => { //파라미터 (one,two) 작성  \n return one + two;  \n};  \nlet result = es6(1, 2);  \nconsole.log(result); // 3  \n```\n\n* * *\n\n## 블록,파라미터\n\narrow 함수에서 함수 블록{}을 사용하지 않고 한 줄에 작성할 수 있습니다.\n\n```js {}없이 한줄 작성\n\"use strict\";  \ndebugger;  \n  \nlet total = (one, two) => one + two;  \nlet result = total(1, 2);   \nconsole.log(result); // 3  \n```\n\n블록{}을 사용하지 않은 형태입니다.  \n()안의 one,two가 total 함수의 파라미터가 됩니다.  \none + two; 는 return을 생략한 것입니다.  \nreturn one + two; 와 동일합니다.\n\n* 호출 받는 파라미터가 하나인경우 소괄호()을 제외하고 작성할 수도 있습니다.\n\n```js ()제외\nlet get = value => value + 10; // = (value) + 10;  \nlet result = get(20);  \nconsole.log(result); // 30  \n```\n\n*   파라미터 없이 함수 호출만 이루어 진다면 ()만 작성합니다.\n\n```js\nlet noParam = () => 3 + 4;  \nlet result = noParam();  \nconsole.log(result); // 7  \n```\n\n* * *\n\n## {key: value} 형태의 Objedt 오브젝트 반환\n\n{key: value} 형태의 Objedt 오브젝트 반환하려면 ()안에 {key: value}를 작성합니다.\n\n```js (o)\nlet get = param => ({sports: \"축구\"});  \nlet result = get();  \nconsole.log(result); // Object {sports: \"축구\"}  \n```\n\nJavaScript는 소괄호() 안의 코드를 표현식으로 인식합니다.  \n그래서 소괄호()안에 작성된 {sports: “축구”}를 반환할 수 있습니다.\n\n\n```js (x)\nlet sports = () => {};  \nlet result = sports();  \nconsole.log(result); // undefined  \n```\n\n위 코드는 sports() 함수를 호출하면 {key: value} 형태의  \n빈 Object 오브젝트를 반환하는 것이 목적입니다.\n\n하지만, arrow (=>) 다음의 블록{}을 함수 블록으로 인식하고  \n함수 블록{}안에 return문을 작성하지 않은 것으로 인식되어  \n함수 안에 return문을 작성하지 않았을 때의 디폴트 값 undefined가 반환됩니다.\n\n<mark>arrow 함수이기 때문에 undefined값이 반환 되는것이 아니라\nES5 기준으로 함수블록으로 인식되었기 때문입니다.</mark>\n\n* * *\n\n## arguments\n\n자바스크립트에서는 함수를 호출할 때 인수들과 함께 암묵적으로 arguments 객체가 함수 내부로 전달된다.\n\narguments 객체는 함수를 호출할 때 넘긴 인자들이 배열 형태로 저장된 객체를 의미한다.\n\n특이한 점은 실재 배열이 아닌 마치 배열 형태처럼 숫자로 인덱싱된 프로퍼티가 있는 객체다.\n\n이러한 객체를 <mark>배열과 유사하다 하여 유사 배열 객체</mark>라고 부른다.\n\n*   arguments 객체는 세 부분으로 구성되어 있다.\n\n1.  함수를 호출할 때 넘겨진 인자(배열 형태): 첫 번째 인자는 0, … n-1번 인덱스\n    \n2.  length 프로퍼티: 호출할 때 넘겨진 인자의 개수\n    \n3.  callee 프로퍼티: 현재 실행 중인 함수의 참조값\n    \n\n`arguments은 유사 배열 객체로써 배열과 유사하게 동작하지만, 배열은 아니므로 배열 메서드를 사용하면 에러가 발생한다.`\n\n**바인딩 되지 않은 arguments**\n\n화살표 함수는 arguments 객체를 바인드 하지 않습니다.  \n때문에 arguments 프로퍼티를 사용할 수 없습니다.\n\n```js\nlet sports = () => {  \n try {  \n let args = arguments; //ReferenceError  \n } catch (error) {  \n console.log(\"사용 불가\");  \n }  \n}  \nsports(1, 2);  \n```\n\n`ES6에서는 arguments 대신에 rest 파라미터를 사용합니다.`\n\n> let sports = (…rest) => {코드}\n\n()안에 …을 작성하고 이어서 파라미터를 작성합니다.\n\n```js\nfunction foo(n) {  \n var f = (...args) => args[0] + n;  \n return f(2);  \n}  \n  \nfoo(1); // 3  \n```\n\n* * *\n\n## this와 setTimeout()\n\narrow함수가 간단한 코드작성을 할 수 있어 편리하지만  \nthis의 참조 경우를 고려해야 합니다.\n\n```js 예시\nlet Sports = function(){  \n this.count = 20;  \n};  \nSports.prototype = {  \n plus: function(){  \n this.count += 1;  \n },  \n get: function(){  \n setTimeout(function(){  \n console.log(this === window);  \n console.log(this.plus);  \n }, 1000);  \n }  \n};  \n// newSports 변수에 new 연산자로 생성된 Sports 인스턴스를 생성하여 할당합니다.  \nlet newSports = new Sports();  \n//get() 함수에 작성된 setTimeout() 함수가 실행되어  \n//1초 후에 콜백 함수가 실행됩니다.  \nnewSports.get();  \n// true  \n// undefined  \n```\n\n*   setTimeout()이 window 오브젝트 함수 이므로  \n    this가 window 오브젝트를 참조하게 되어 true가 출력됩니다.\n\n*   중요한 점은 newSports.get()형태로 호출 하였기 때문에  \n    this가 newSports 인스턴스를 참조 하지 않고  \n    window 오브젝트를 참조 한다는 것 입니다.\n\n*   this가 newSports 인스턴스를 참조하지 못하므로  \n    setTimeout()을 실행하기 전에 newSports 인스턴스를 변수에 할당하고,  \n    setTimeout() 콜백 함수에서 변수의 인스턴스를 사용하는 형태를 취했습니다.\n\n*   console.log(this.plus)코드의 목적은  \n    this로 newSports 인스턴스를 참조하여 plus 메서드를 반환받는 것입니다.  \n    그런데 this가 window 오브젝트를 참조하므로 undefined값이 출력됩니다.\n\n```js 해결방법\nlet Sports = function(){  \n this.count = 20;  \n};  \nSports.prototype = {  \n plus: function(){  \n this.count += 1;  \n },  \n get: function() {  \n setTimeout(() => { // 콜백 함수를 arrow함수로 작성합니다.  \n this.plus();  \n console.log(this.count);  \n }, 1000);  \n }  \n};  \nlet newSports = new Sports();  \nnewSports.get(); // 21  \n```\n\n*   setTimeout() 함수의 콜백 함수를 arrow함수로 작성하면  \n    this가 newSports.get()형태에서 newSports 인스턴스를 참조 할수 있게 됩니다.\n","slug":"Arrow -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrrr0004qgvq45qpc1qx","content":"<p>arrow(화살표) 함수는<br>function(param) {코드} 형태를 축약한 것으로</p>\n<blockquote>\n<p>(param) =&gt; {코드}</p>\n</blockquote>\n<p>형태로 작성합니다.</p>\n<p>화살표 함수 표현(arrow function expression)은 function 표현에 비해 구문이 짧고 자신의 this, arguments, super 또는 new.target을 바인딩 하지 않습니다.<br>화살표 함수는 항상 익명입니다. 이 함수 표현은 메소드 함수가 아닌 곳에 가장 적합합니다. 그래서 생성자로서 사용할 수 없습니다.</p>\n<a id=\"more\"></a>\n\n<hr>\n<ul>\n<li>기본 구문</li>\n</ul>\n<blockquote>\n<p>(param1, param2, …, paramN) =&gt; { statements }<br>(param1, param2, …, paramN) =&gt; expression<br>// 다음과 동일함: =&gt; { return expression; }</p>\n</blockquote>\n<blockquote>\n<p>// 매개변수가 하나뿐인 경우 괄호는 선택사항:<br>(singleParam) =&gt; { statements }<br>singleParam =&gt; { statements }</p>\n</blockquote>\n<blockquote>\n<p>// 매개변수가 없는 함수는 괄호가 필요:<br>() =&gt; { statements }</p>\n</blockquote>\n<hr>\n<ul>\n<li>고급 구문</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 객체 리터럴 표현을 반환하기 위해서는 함수 본문(body)을 괄호 속에 넣음:  </span></span><br><span class=\"line\">params =&gt; (&#123;<span class=\"attr\">foo</span>: bar&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 나머지 매개변수 및 기본 매개변수를 지원함  </span></span><br><span class=\"line\">(param1, param2, …rest) =&gt; &#123; statements &#125;  </span><br><span class=\"line\">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 매개변수 목록 내 비구조화도 지원됨  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\">(<span class=\"params\">[a, b] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>], &#123;x: c&#125; = &#123;x: a + b&#125;</span>) =&gt;</span> a + b + c;  </span><br><span class=\"line\">f(); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> materials = [  </span><br><span class=\"line\"> <span class=\"string\">'Hydrogen'</span>,  </span><br><span class=\"line\"> <span class=\"string\">'Helium'</span>,  </span><br><span class=\"line\"> <span class=\"string\">'Lithium'</span>,  </span><br><span class=\"line\"> <span class=\"string\">'Beryllium'</span>  </span><br><span class=\"line\">];  </span><br><span class=\"line\">  </span><br><span class=\"line\">materials.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">material</span>) </span>&#123;   </span><br><span class=\"line\"> <span class=\"keyword\">return</span> material.length;   </span><br><span class=\"line\">&#125;); <span class=\"comment\">// [8, 6, 7, 9]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 위에 있는 함수를 arrow 함수를 이용해 아래와 같이 표현할 수 있다  </span></span><br><span class=\"line\">materials.map(<span class=\"function\">(<span class=\"params\">material</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> material.length;  </span><br><span class=\"line\">&#125;); <span class=\"comment\">// [8, 6, 7, 9]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">materials.map(<span class=\"function\">(<span class=\"params\">&#123;length&#125;</span>) =&gt;</span> length); <span class=\"comment\">// [8, 6, 7, 9]</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<ul>\n<li>줄바꿈<br>화살표 함수는 파라미터와 화살표 사이에 개행 문자를 포함 할 수 없습니다.</li>\n</ul>\n<blockquote>\n<p>var func = (a, b, c)<br>=&gt; 1;<br>// SyntaxError: expected expression, got ‘=&gt;’</p>\n</blockquote>\n<p>하지만, 보기 좋은 코드를 유지하고 싶다면, 아래에 보는 것처럼 괄호나 개행을 둠으로써 이를 수정할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = (  </span><br><span class=\"line\">a,  </span><br><span class=\"line\">b,  </span><br><span class=\"line\">c  </span><br><span class=\"line\">) =&gt; (  </span><br><span class=\"line\"><span class=\"number\">1</span>  </span><br><span class=\"line\">);  </span><br><span class=\"line\"><span class=\"comment\">// SyntaxError가 발생하지 않습니다.</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<ul>\n<li>new 연산자 사용<br>화살표 함수는 생성자로서 사용될 수 없으며 new와 함께 사용하면 오류가 발생합니다.</li>\n</ul>\n<blockquote>\n<p>var Foo = () =&gt; {};<br>var foo = new Foo(); // TypeError: Foo is not a constructor</p>\n</blockquote>\n<hr>\n<ul>\n<li>prototype 속성 사용<br>화살표 함수는 prototype 속성이 없습니다.</li>\n</ul>\n<blockquote>\n<p>var Foo = () =&gt; {};<br>console.log(Foo.prototype); // undefined</p>\n</blockquote>\n<hr>\n<ul>\n<li>함수 호출<br>arrow 함수는 함수 이름이 없는 무명(혹은 익명) 함수 입니다.<br>따라서 함수를 호출 하려면 함수 표현식과 같이 변수에 할당해야 합니다.</li>\n</ul>\n<blockquote>\n<p>let fn = (param) =&gt; {코드}</p>\n</blockquote>\n<p>위 처럼 arrow 함수로 생성한 function 오브젝트를 할당할 변수를 작성해야합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">debugger</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//arrow 함수로 생성된 function 오브젝트를 할당할 변수 es6 작성  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> es6 = <span class=\"function\">(<span class=\"params\">one, two</span>) =&gt;</span> &#123; <span class=\"comment\">//파라미터 (one,two) 작성  </span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> one + two;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = es6(<span class=\"number\">1</span>, <span class=\"number\">2</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"블록-파라미터\"><a href=\"#블록-파라미터\" class=\"headerlink\" title=\"블록,파라미터\"></a>블록,파라미터</h2><p>arrow 함수에서 함수 블록{}을 사용하지 않고 한 줄에 작성할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>&#123;&#125;없이 한줄 작성</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">debugger</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> total = <span class=\"function\">(<span class=\"params\">one, two</span>) =&gt;</span> one + two;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = total(<span class=\"number\">1</span>, <span class=\"number\">2</span>);   </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>블록{}을 사용하지 않은 형태입니다.<br>()안의 one,two가 total 함수의 파라미터가 됩니다.<br>one + two; 는 return을 생략한 것입니다.<br>return one + two; 와 동일합니다.</p>\n<ul>\n<li>호출 받는 파라미터가 하나인경우 소괄호()을 제외하고 작성할 수도 있습니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>()제외</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">get</span> = value =&gt; value + 10; // = (value) + 10;  </span><br><span class=\"line\">let result = <span class=\"keyword\">get</span>(20);  </span><br><span class=\"line\">console.log(result); // 30</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>파라미터 없이 함수 호출만 이루어 진다면 ()만 작성합니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> noParam = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">3</span> + <span class=\"number\">4</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = noParam();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// 7</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"key-value-형태의-Objedt-오브젝트-반환\"><a href=\"#key-value-형태의-Objedt-오브젝트-반환\" class=\"headerlink\" title=\"{key: value} 형태의 Objedt 오브젝트 반환\"></a>{key: value} 형태의 Objedt 오브젝트 반환</h2><p>{key: value} 형태의 Objedt 오브젝트 반환하려면 ()안에 {key: value}를 작성합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>(o)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">get</span> = param =&gt; (&#123;sports: <span class=\"string\">\"축구\"</span>&#125;);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"keyword\">get</span>();  </span><br><span class=\"line\">console.log(result); // Object &#123;sports: <span class=\"string\">\"축구\"</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JavaScript는 소괄호() 안의 코드를 표현식으로 인식합니다.<br>그래서 소괄호()안에 작성된 {sports: “축구”}를 반환할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>(x)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = sports();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>위 코드는 sports() 함수를 호출하면 {key: value} 형태의<br>빈 Object 오브젝트를 반환하는 것이 목적입니다.</p>\n<p>하지만, arrow (=&gt;) 다음의 블록{}을 함수 블록으로 인식하고<br>함수 블록{}안에 return문을 작성하지 않은 것으로 인식되어<br>함수 안에 return문을 작성하지 않았을 때의 디폴트 값 undefined가 반환됩니다.</p>\n<p><mark>arrow 함수이기 때문에 undefined값이 반환 되는것이 아니라<br>ES5 기준으로 함수블록으로 인식되었기 때문입니다.</mark></p>\n<hr>\n<h2 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h2><p>자바스크립트에서는 함수를 호출할 때 인수들과 함께 암묵적으로 arguments 객체가 함수 내부로 전달된다.</p>\n<p>arguments 객체는 함수를 호출할 때 넘긴 인자들이 배열 형태로 저장된 객체를 의미한다.</p>\n<p>특이한 점은 실재 배열이 아닌 마치 배열 형태처럼 숫자로 인덱싱된 프로퍼티가 있는 객체다.</p>\n<p>이러한 객체를 <mark>배열과 유사하다 하여 유사 배열 객체</mark>라고 부른다.</p>\n<ul>\n<li>arguments 객체는 세 부분으로 구성되어 있다.</li>\n</ul>\n<ol>\n<li><p>함수를 호출할 때 넘겨진 인자(배열 형태): 첫 번째 인자는 0, … n-1번 인덱스</p>\n</li>\n<li><p>length 프로퍼티: 호출할 때 넘겨진 인자의 개수</p>\n</li>\n<li><p>callee 프로퍼티: 현재 실행 중인 함수의 참조값</p>\n</li>\n</ol>\n<p><code>arguments은 유사 배열 객체로써 배열과 유사하게 동작하지만, 배열은 아니므로 배열 메서드를 사용하면 에러가 발생한다.</code></p>\n<p><strong>바인딩 되지 않은 arguments</strong></p>\n<p>화살표 함수는 arguments 객체를 바인드 하지 않습니다.<br>때문에 arguments 프로퍼티를 사용할 수 없습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> args = <span class=\"built_in\">arguments</span>; <span class=\"comment\">//ReferenceError  </span></span><br><span class=\"line\"> &#125; <span class=\"keyword\">catch</span> (error) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"사용 불가\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">sports(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>ES6에서는 arguments 대신에 rest 파라미터를 사용합니다.</code></p>\n<blockquote>\n<p>let sports = (…rest) =&gt; {코드}</p>\n</blockquote>\n<p>()안에 …을 작성하고 이어서 파라미터를 작성합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">n</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> f = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> args[<span class=\"number\">0</span>] + n;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> f(<span class=\"number\">2</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">foo(<span class=\"number\">1</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"this와-setTimeout\"><a href=\"#this와-setTimeout\" class=\"headerlink\" title=\"this와 setTimeout()\"></a>this와 setTimeout()</h2><p>arrow함수가 간단한 코드작성을 할 수 있어 편리하지만<br>this의 참조 경우를 고려해야 합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.count = <span class=\"number\">20</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">Sports.prototype = &#123;  </span><br><span class=\"line\"> plus: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.count += <span class=\"number\">1</span>;  </span><br><span class=\"line\"> &#125;,  </span><br><span class=\"line\"> <span class=\"keyword\">get</span>: function()&#123;  </span><br><span class=\"line\"> setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>);  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.plus);  </span><br><span class=\"line\"> &#125;, <span class=\"number\">1000</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// newSports 변수에 new 연산자로 생성된 Sports 인스턴스를 생성하여 할당합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newSports = <span class=\"keyword\">new</span> Sports();  </span><br><span class=\"line\"><span class=\"comment\">//get() 함수에 작성된 setTimeout() 함수가 실행되어  </span></span><br><span class=\"line\"><span class=\"comment\">//1초 후에 콜백 함수가 실행됩니다.  </span></span><br><span class=\"line\">newSports.get();  </span><br><span class=\"line\"><span class=\"comment\">// true  </span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>setTimeout()이 window 오브젝트 함수 이므로<br>this가 window 오브젝트를 참조하게 되어 true가 출력됩니다.</p>\n</li>\n<li><p>중요한 점은 newSports.get()형태로 호출 하였기 때문에<br>this가 newSports 인스턴스를 참조 하지 않고<br>window 오브젝트를 참조 한다는 것 입니다.</p>\n</li>\n<li><p>this가 newSports 인스턴스를 참조하지 못하므로<br>setTimeout()을 실행하기 전에 newSports 인스턴스를 변수에 할당하고,<br>setTimeout() 콜백 함수에서 변수의 인스턴스를 사용하는 형태를 취했습니다.</p>\n</li>\n<li><p>console.log(this.plus)코드의 목적은<br>this로 newSports 인스턴스를 참조하여 plus 메서드를 반환받는 것입니다.<br>그런데 this가 window 오브젝트를 참조하므로 undefined값이 출력됩니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>해결방법</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.count = <span class=\"number\">20</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">Sports.prototype = &#123;  </span><br><span class=\"line\"> plus: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.count += <span class=\"number\">1</span>;  </span><br><span class=\"line\"> &#125;,  </span><br><span class=\"line\"> <span class=\"keyword\">get</span>: function() &#123;  </span><br><span class=\"line\"> setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 콜백 함수를 arrow함수로 작성합니다.  </span></span><br><span class=\"line\"> <span class=\"keyword\">this</span>.plus();  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.count);  </span><br><span class=\"line\"> &#125;, <span class=\"number\">1000</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> newSports = <span class=\"keyword\">new</span> Sports();  </span><br><span class=\"line\">newSports.get(); <span class=\"comment\">// 21</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>setTimeout() 함수의 콜백 함수를 arrow함수로 작성하면<br>this가 newSports.get()형태에서 newSports 인스턴스를 참조 할수 있게 됩니다.</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>arrow(화살표) 함수는<br>function(param) {코드} 형태를 축약한 것으로</p>\n<blockquote>\n<p>(param) =&gt; {코드}</p>\n</blockquote>\n<p>형태로 작성합니다.</p>\n<p>화살표 함수 표현(arrow function expression)은 function 표현에 비해 구문이 짧고 자신의 this, arguments, super 또는 new.target을 바인딩 하지 않습니다.<br>화살표 함수는 항상 익명입니다. 이 함수 표현은 메소드 함수가 아닌 곳에 가장 적합합니다. 그래서 생성자로서 사용할 수 없습니다.</p>","more":"<hr>\n<ul>\n<li>기본 구문</li>\n</ul>\n<blockquote>\n<p>(param1, param2, …, paramN) =&gt; { statements }<br>(param1, param2, …, paramN) =&gt; expression<br>// 다음과 동일함: =&gt; { return expression; }</p>\n</blockquote>\n<blockquote>\n<p>// 매개변수가 하나뿐인 경우 괄호는 선택사항:<br>(singleParam) =&gt; { statements }<br>singleParam =&gt; { statements }</p>\n</blockquote>\n<blockquote>\n<p>// 매개변수가 없는 함수는 괄호가 필요:<br>() =&gt; { statements }</p>\n</blockquote>\n<hr>\n<ul>\n<li>고급 구문</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 객체 리터럴 표현을 반환하기 위해서는 함수 본문(body)을 괄호 속에 넣음:  </span></span><br><span class=\"line\">params =&gt; (&#123;<span class=\"attr\">foo</span>: bar&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 나머지 매개변수 및 기본 매개변수를 지원함  </span></span><br><span class=\"line\">(param1, param2, …rest) =&gt; &#123; statements &#125;  </span><br><span class=\"line\">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 매개변수 목록 내 비구조화도 지원됨  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\">(<span class=\"params\">[a, b] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>], &#123;x: c&#125; = &#123;x: a + b&#125;</span>) =&gt;</span> a + b + c;  </span><br><span class=\"line\">f(); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> materials = [  </span><br><span class=\"line\"> <span class=\"string\">'Hydrogen'</span>,  </span><br><span class=\"line\"> <span class=\"string\">'Helium'</span>,  </span><br><span class=\"line\"> <span class=\"string\">'Lithium'</span>,  </span><br><span class=\"line\"> <span class=\"string\">'Beryllium'</span>  </span><br><span class=\"line\">];  </span><br><span class=\"line\">  </span><br><span class=\"line\">materials.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">material</span>) </span>&#123;   </span><br><span class=\"line\"> <span class=\"keyword\">return</span> material.length;   </span><br><span class=\"line\">&#125;); <span class=\"comment\">// [8, 6, 7, 9]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 위에 있는 함수를 arrow 함수를 이용해 아래와 같이 표현할 수 있다  </span></span><br><span class=\"line\">materials.map(<span class=\"function\">(<span class=\"params\">material</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> material.length;  </span><br><span class=\"line\">&#125;); <span class=\"comment\">// [8, 6, 7, 9]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">materials.map(<span class=\"function\">(<span class=\"params\">&#123;length&#125;</span>) =&gt;</span> length); <span class=\"comment\">// [8, 6, 7, 9]</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<ul>\n<li>줄바꿈<br>화살표 함수는 파라미터와 화살표 사이에 개행 문자를 포함 할 수 없습니다.</li>\n</ul>\n<blockquote>\n<p>var func = (a, b, c)<br>=&gt; 1;<br>// SyntaxError: expected expression, got ‘=&gt;’</p>\n</blockquote>\n<p>하지만, 보기 좋은 코드를 유지하고 싶다면, 아래에 보는 것처럼 괄호나 개행을 둠으로써 이를 수정할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = (  </span><br><span class=\"line\">a,  </span><br><span class=\"line\">b,  </span><br><span class=\"line\">c  </span><br><span class=\"line\">) =&gt; (  </span><br><span class=\"line\"><span class=\"number\">1</span>  </span><br><span class=\"line\">);  </span><br><span class=\"line\"><span class=\"comment\">// SyntaxError가 발생하지 않습니다.</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<ul>\n<li>new 연산자 사용<br>화살표 함수는 생성자로서 사용될 수 없으며 new와 함께 사용하면 오류가 발생합니다.</li>\n</ul>\n<blockquote>\n<p>var Foo = () =&gt; {};<br>var foo = new Foo(); // TypeError: Foo is not a constructor</p>\n</blockquote>\n<hr>\n<ul>\n<li>prototype 속성 사용<br>화살표 함수는 prototype 속성이 없습니다.</li>\n</ul>\n<blockquote>\n<p>var Foo = () =&gt; {};<br>console.log(Foo.prototype); // undefined</p>\n</blockquote>\n<hr>\n<ul>\n<li>함수 호출<br>arrow 함수는 함수 이름이 없는 무명(혹은 익명) 함수 입니다.<br>따라서 함수를 호출 하려면 함수 표현식과 같이 변수에 할당해야 합니다.</li>\n</ul>\n<blockquote>\n<p>let fn = (param) =&gt; {코드}</p>\n</blockquote>\n<p>위 처럼 arrow 함수로 생성한 function 오브젝트를 할당할 변수를 작성해야합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">debugger</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//arrow 함수로 생성된 function 오브젝트를 할당할 변수 es6 작성  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> es6 = <span class=\"function\">(<span class=\"params\">one, two</span>) =&gt;</span> &#123; <span class=\"comment\">//파라미터 (one,two) 작성  </span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> one + two;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = es6(<span class=\"number\">1</span>, <span class=\"number\">2</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"블록-파라미터\"><a href=\"#블록-파라미터\" class=\"headerlink\" title=\"블록,파라미터\"></a>블록,파라미터</h2><p>arrow 함수에서 함수 블록{}을 사용하지 않고 한 줄에 작성할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>&#123;&#125;없이 한줄 작성</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">debugger</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> total = <span class=\"function\">(<span class=\"params\">one, two</span>) =&gt;</span> one + two;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = total(<span class=\"number\">1</span>, <span class=\"number\">2</span>);   </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>블록{}을 사용하지 않은 형태입니다.<br>()안의 one,two가 total 함수의 파라미터가 됩니다.<br>one + two; 는 return을 생략한 것입니다.<br>return one + two; 와 동일합니다.</p>\n<ul>\n<li>호출 받는 파라미터가 하나인경우 소괄호()을 제외하고 작성할 수도 있습니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>()제외</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">get</span> = value =&gt; value + 10; // = (value) + 10;  </span><br><span class=\"line\">let result = <span class=\"keyword\">get</span>(20);  </span><br><span class=\"line\">console.log(result); // 30</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>파라미터 없이 함수 호출만 이루어 진다면 ()만 작성합니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> noParam = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">3</span> + <span class=\"number\">4</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = noParam();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// 7</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"key-value-형태의-Objedt-오브젝트-반환\"><a href=\"#key-value-형태의-Objedt-오브젝트-반환\" class=\"headerlink\" title=\"{key: value} 형태의 Objedt 오브젝트 반환\"></a>{key: value} 형태의 Objedt 오브젝트 반환</h2><p>{key: value} 형태의 Objedt 오브젝트 반환하려면 ()안에 {key: value}를 작성합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>(o)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">get</span> = param =&gt; (&#123;sports: <span class=\"string\">\"축구\"</span>&#125;);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"keyword\">get</span>();  </span><br><span class=\"line\">console.log(result); // Object &#123;sports: <span class=\"string\">\"축구\"</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JavaScript는 소괄호() 안의 코드를 표현식으로 인식합니다.<br>그래서 소괄호()안에 작성된 {sports: “축구”}를 반환할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>(x)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = sports();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>위 코드는 sports() 함수를 호출하면 {key: value} 형태의<br>빈 Object 오브젝트를 반환하는 것이 목적입니다.</p>\n<p>하지만, arrow (=&gt;) 다음의 블록{}을 함수 블록으로 인식하고<br>함수 블록{}안에 return문을 작성하지 않은 것으로 인식되어<br>함수 안에 return문을 작성하지 않았을 때의 디폴트 값 undefined가 반환됩니다.</p>\n<p><mark>arrow 함수이기 때문에 undefined값이 반환 되는것이 아니라<br>ES5 기준으로 함수블록으로 인식되었기 때문입니다.</mark></p>\n<hr>\n<h2 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h2><p>자바스크립트에서는 함수를 호출할 때 인수들과 함께 암묵적으로 arguments 객체가 함수 내부로 전달된다.</p>\n<p>arguments 객체는 함수를 호출할 때 넘긴 인자들이 배열 형태로 저장된 객체를 의미한다.</p>\n<p>특이한 점은 실재 배열이 아닌 마치 배열 형태처럼 숫자로 인덱싱된 프로퍼티가 있는 객체다.</p>\n<p>이러한 객체를 <mark>배열과 유사하다 하여 유사 배열 객체</mark>라고 부른다.</p>\n<ul>\n<li>arguments 객체는 세 부분으로 구성되어 있다.</li>\n</ul>\n<ol>\n<li><p>함수를 호출할 때 넘겨진 인자(배열 형태): 첫 번째 인자는 0, … n-1번 인덱스</p>\n</li>\n<li><p>length 프로퍼티: 호출할 때 넘겨진 인자의 개수</p>\n</li>\n<li><p>callee 프로퍼티: 현재 실행 중인 함수의 참조값</p>\n</li>\n</ol>\n<p><code>arguments은 유사 배열 객체로써 배열과 유사하게 동작하지만, 배열은 아니므로 배열 메서드를 사용하면 에러가 발생한다.</code></p>\n<p><strong>바인딩 되지 않은 arguments</strong></p>\n<p>화살표 함수는 arguments 객체를 바인드 하지 않습니다.<br>때문에 arguments 프로퍼티를 사용할 수 없습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> args = <span class=\"built_in\">arguments</span>; <span class=\"comment\">//ReferenceError  </span></span><br><span class=\"line\"> &#125; <span class=\"keyword\">catch</span> (error) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"사용 불가\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">sports(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>ES6에서는 arguments 대신에 rest 파라미터를 사용합니다.</code></p>\n<blockquote>\n<p>let sports = (…rest) =&gt; {코드}</p>\n</blockquote>\n<p>()안에 …을 작성하고 이어서 파라미터를 작성합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">n</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> f = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> args[<span class=\"number\">0</span>] + n;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> f(<span class=\"number\">2</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">foo(<span class=\"number\">1</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"this와-setTimeout\"><a href=\"#this와-setTimeout\" class=\"headerlink\" title=\"this와 setTimeout()\"></a>this와 setTimeout()</h2><p>arrow함수가 간단한 코드작성을 할 수 있어 편리하지만<br>this의 참조 경우를 고려해야 합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.count = <span class=\"number\">20</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">Sports.prototype = &#123;  </span><br><span class=\"line\"> plus: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.count += <span class=\"number\">1</span>;  </span><br><span class=\"line\"> &#125;,  </span><br><span class=\"line\"> <span class=\"keyword\">get</span>: function()&#123;  </span><br><span class=\"line\"> setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>);  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.plus);  </span><br><span class=\"line\"> &#125;, <span class=\"number\">1000</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// newSports 변수에 new 연산자로 생성된 Sports 인스턴스를 생성하여 할당합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newSports = <span class=\"keyword\">new</span> Sports();  </span><br><span class=\"line\"><span class=\"comment\">//get() 함수에 작성된 setTimeout() 함수가 실행되어  </span></span><br><span class=\"line\"><span class=\"comment\">//1초 후에 콜백 함수가 실행됩니다.  </span></span><br><span class=\"line\">newSports.get();  </span><br><span class=\"line\"><span class=\"comment\">// true  </span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>setTimeout()이 window 오브젝트 함수 이므로<br>this가 window 오브젝트를 참조하게 되어 true가 출력됩니다.</p>\n</li>\n<li><p>중요한 점은 newSports.get()형태로 호출 하였기 때문에<br>this가 newSports 인스턴스를 참조 하지 않고<br>window 오브젝트를 참조 한다는 것 입니다.</p>\n</li>\n<li><p>this가 newSports 인스턴스를 참조하지 못하므로<br>setTimeout()을 실행하기 전에 newSports 인스턴스를 변수에 할당하고,<br>setTimeout() 콜백 함수에서 변수의 인스턴스를 사용하는 형태를 취했습니다.</p>\n</li>\n<li><p>console.log(this.plus)코드의 목적은<br>this로 newSports 인스턴스를 참조하여 plus 메서드를 반환받는 것입니다.<br>그런데 this가 window 오브젝트를 참조하므로 undefined값이 출력됩니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>해결방법</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.count = <span class=\"number\">20</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">Sports.prototype = &#123;  </span><br><span class=\"line\"> plus: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.count += <span class=\"number\">1</span>;  </span><br><span class=\"line\"> &#125;,  </span><br><span class=\"line\"> <span class=\"keyword\">get</span>: function() &#123;  </span><br><span class=\"line\"> setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 콜백 함수를 arrow함수로 작성합니다.  </span></span><br><span class=\"line\"> <span class=\"keyword\">this</span>.plus();  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.count);  </span><br><span class=\"line\"> &#125;, <span class=\"number\">1000</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> newSports = <span class=\"keyword\">new</span> Sports();  </span><br><span class=\"line\">newSports.get(); <span class=\"comment\">// 21</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>setTimeout() 함수의 콜백 함수를 arrow함수로 작성하면<br>this가 newSports.get()형태에서 newSports 인스턴스를 참조 할수 있게 됩니다.</li>\n</ul>"},{"title":"Class 오브젝트 -ECMAScript","date":"2020-04-01T00:45:41.000Z","disqusId":"tunas-blog-1","_content":"\nClass(클래스)를 완전하게 이해하려면 객체지항 프로그래밍(OOP:Object Oriented Programming)에 대한 이해가 필요합니다.\n\nOOP만 다루는 책이 있을 정도로 범위가 넓고 깊으므로  \nOOP는 나중에 자세히 다루고 ES6기준으로 살펴봅니다.\n\n*   Class 오브젝트\n    *   [Class 선언문](/2020/04/01/Class%20오브젝트%20-ECMAScript/#Class_선언문)\n    *   [Class 표현식](/2020/04/01/Class%20오브젝트%20-ECMAScript/#Class_표현식)\n    *   [Class 특징](/2020/04/01/Class%20오브젝트%20-ECMAScript/#클래스_특징)\n        *   strict 모드에서 실행\n        *   클래스에 메서드 작성 방법\n        *   prototype에 프로퍼티 연결\n        *   prototype에 프로퍼티 추가\n    *   [constructor](/2020/04/01/Class%20오브젝트%20-ECMAScript/#constructor)\n    *   [constructor 반환 값 변경](/2020/04/01/Class%20오브젝트%20-ECMAScript/#constructor_return)\n    *   [getter, setter](/2020/04/01/Class%20오브젝트%20-ECMAScript/#getter_and_setter)\n    *   [상속](/2020/04/01/Class%20오브젝트%20-ECMAScript/#상속)\n    *   [extends 키워드](/2020/04/01/Class%20오브젝트%20-ECMAScript/#extends)\n    *   [super 키워드](/2020/04/01/Class%20오브젝트%20-ECMAScript/#super)\n        *   메서드 오버라이딩\n    *   [빌트인 오브젝트 상속](/2020/04/01/Class%20오브젝트%20-ECMAScript/#builtin)\n    *   [Object에서 super 사용](/2020/04/01/Class%20오브젝트%20-ECMAScript/#Object_super)\n    *   [static 키워드](/2020/04/01/Class%20오브젝트%20-ECMAScript/#static)\n    *   [Class 호이스팅](/2020/04/01/Class%20오브젝트%20-ECMAScript/#Class_Hoisting)\n    *   [computed name](/2020/04/01/Class%20오브젝트%20-ECMAScript/#computed_name)\n    *   [this](/2020/04/01/Class%20오브젝트%20-ECMAScript/#this)\n    *   [제너레이터](/2020/04/01/Class%20오브젝트%20-ECMAScript/#generator)\n    *   [new.target](/2020/04/01/Class%20오브젝트%20-ECMAScript/#new_target)\n        *   name 프로퍼티\n    *   [오브젝트 상속](/2020/04/01/Class%20오브젝트%20-ECMAScript/#Image_Object)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Class_선언문\">Class 선언문</h2>\n\n> Class name {}  \n> Class name extends super_name {}\n\n엔진이 function 키워드를 만나면 Function 오브젝트를 생성하듯이  \nclass 키워드를 만나면 Class 오브젝트를 생성합니다.  \nClass 오브젝트는 Function 오브젝트, String 오브젝트와 같이 하나의 오트젝트 타입입니다.\n\n*   name에 클래스 이름을 작성합니다.  \n    name 다음의 extends는 키워드로 super_name(슈퍼 클래스)를 상속받을 때 사용합니다. 이 형태를 클래스 선언문 이라고 합니다.\n\nclass는 클래스를 선언하는 키워드이고  \n엔진이 class 키워드로 생성한 오브젝트는 Class 오브젝트 입니다.  \n문맥에 따라 Class 오브젝트를 class라고 말하기도 합니다.\n\n```js\nclass Member {  \n getName() {  \n return \"이름\";  \n }  \n};  \n1. let obj = new Member();  \n  \n2. console.log(obj.getName());  \n// 이름  \n```\n\n*   class 키워드를 작성하고 이어서 클래스 이름을 작성합니다. 그리고 블록{}을 작성하고 블록에 클래스 코드를 작성합니다.  \n    엔진이 class 키워드를 만나면 클래스(Class) 오브젝트를 생성합니다.\n\n1.  new 연산자로 Member()를 호출하면 인스턴스를 생성하여 반환합니다.\n    \n    <mark>function name(){}는 new 연산자로 인스턴스를 생성하지 않고  \n    name()형태로 호출할 수 있지만,  \n    클래스는 new 연산자로 인스턴스 생성없이 name()형태로 호출할 수 없으며  \n    TypeError가 발생합니다.</mark>\n2.  obj는 인스턴스이고 getName()은 class Member{}안에 작성한 메서드 입니다.  \n    이와 같이 new 연산자로 생성한 인스턴스를 사용하여 클래스에 작성한 메서드를 호출할 수 있습니다. 실행 결과 “이름”이 출력됩니다.\n    \n\n*   참고\n    \n    > new 연산자로 인스턴스를 생성하는 함수는 함수 이름의 첫 문자를 대문자로 작성합니다. 클래스 또한 new 연산자로 인스턴스를 생성하므로 클래스 이름의 첫 문자를 대문자로 사용합니다. 이는 스펙에 정의된 것은 아니며 자바스크립트 개발자들 사이의 관례입니다. 개발자가 코드의 대문자를 보고 인스턴스를 생성한다는 것을 알 수 있으므로 지키는 것이 좋습니다. 빌트인 Number 오브젝트, String 오브젝트도 이와 같은 맥락입니다.\n    \n\n*   같은 클래스를 두 번 선언하려고 시도할 때  \n    클래스 선언문으로 같은 클래스를 두 번 선언하면 오류가 발생합니다.\n    \n    > class Foo {};  \n    > class Foo {}; // Uncaught SyntaxError: Identifier ‘Foo’ has already been declared\n    \n\n*   이전에 표현식으로 정의한 경우에도 오류가 발생합니다.\n    \n    > var Foo = class {};  \n    > class Foo {}; // Uncaught TypeError: Identifier ‘Foo’ has already been declared\n    \n\n* * *\n\n<h2 id=\"Class_표현식\">Class 표현식</h2>\n\n클래스 표현식으로 클래스를 선언합니다.\n\n> let name = class {}  \n> let name = class inner_name {}  \n> let name = class extends super_name {}  \n> let name = class inner_name extends super_name {}\n\n할당 연산자 (=) 왼쪽에 클래스 이름을 작성하고 오른쪽에 class 키워드를 작성하고 블록{}안에 클래스 코드를 작성합니다. 이를 클래스 표현식이라고 합니다.\n\nClass 표현식은 이름을 가질 수도 있고, 갖지 않을 수도 있습니다. 이름을 가진 class 표현식의 이름은 클래스의 body에 대해 local scope에 한해 유효합니다.\n\n4번째 구문 class 와 extends 키워드 사이의 inner_name은 클래스 안에서 자신을 호출할 때 사용합니다. ~~function 키워드 함수에서도 inner_name을 작성할 수 있지만 사용하지 않듯 클래스도 사용하지 않습니다.~~\n\n```js\nlet Member = class {  \n getName() {  \n return \"이름\";  \n }  \n};  \nlet obj = new Member();  \nconsole.log(obj.getName());  \n```\n\n엔진이 클래스 키워드를 만나면 클래스 오브젝트를 생성하여 Member 변수에 할당합니다.\n\n* * *\n\n<h2 id=\"클래스_특징\">클래스 특징</h2>\n\nClass는 사실 함수입니다. 함수를 함수 표현식과 함수 선언으로 정의할 수 있듯이 class 문법도 class 표현식과 class 선언 두 가지 방법을 제공합니다.\n\n1.  strict 모드에서 실행\n    \n    **“use static”을 선언하지 않아도 클래스의 코드는 static 모드에서 실행됩니다.**\n    \n\n2.  클래스에 메서드 작성 방법\n    ```js\n    class Member{  \n     1. setName(name) {  \n     this.name = name;  \n     }  \n     2. getName() {  \n     return this.name;  \n     }  \n    };  \n    4. Member.prototype.getTitle = function(){};  \n    3. console.log(typeof Member);  \n    // function  \n    ```\n\n    *   setName(){ } 과 같이 function 키워드와 콜론(:)을 작성하지 않고 메서드 이름만 작성합니다.\n        \n    *   setName()과 getName() 메서드 사이에 콤마를 작성하지 않습니다.\n        \n    *   클래스의 typeof는 function 입니다. 이는 class가 function 구조라는 것을 의미합니다.\n        \n    *   function name(){ }은 글로벌 오브젝트(window Object)에 설정되지만  \n        class name(){ }은 글로벌 오브젝트에 설정되지 않습니다.  \n        따라서 window.Member로 클래스에 접근하면 undefined가 반환됩니다.  \n        `Class 오브젝트의 프로퍼티는 for()문 등으로 열거할 수 없습니다.`\n        \n\n3.  prototype에 프로퍼티 연결\n\n```js\nclass Member{  \n setName(name) {  \n this.name = name;  \n }  \n};  \n```\n\n~~prototype에 메서드를 연결하여 prototype.setName과 같이 작성하지 않고~~  \nsetName을 작성합니다. 자바스크립트는 기본적으로 prototype에 메서드를 연결하는 구조이므로 **클래스 안에 작성된 메서드를 엔진이 자동으로 prototype에 연결합니다.**  \n즉. 엔진이 Member.prototype.setName 형태로 연결해줍니다.\n\n이는 중요한 의미를 갖습니다. 자바스크립트의 기본 아키텍처(구성 방식 혹은 컴퓨터 소프트웨어의 호환성)를 유지하면서 객체지향 언어의 특징을 반영하려는 접근입니다.\n\n4.  prototype에 프로퍼티 추가\n\n\n> Member.prototype.getTitle = function(  ){ };  \n\n**클래스 밖에서 Member 클래스에 메서드를 추가하려면** 위와 같이  \nMember.prototype에 메서드를 연결하여 작성합니다.  \nMember 클래스를 선언할 때는 클래스 블록{}안에 작성하겠지만,  \n인스턴스를 생성한 후 상황에 따라 추가할 때 이 형태로 작성합니다.\n\n*   참고  \n    이렇게 메서드를 추가하면 이미 생성된 인스턴스에서 추가한 메서드를 공유할 수 있도록 엔진이 처리하게 되므로 부하 혹은 자원낭비가 됩니다.  \n    좋은 사용 예시로는 사용자의 행동이나 서버 데이터에 따라 메서드를 따로 추가할 수 있는 점이 있습니다.(역동성이 높다.)\n\n* * *\n\n<h2 id=\"constructor\">constructor</h2>\n\n*   constructor 메소드는 class 인스턴스를 생성하고 생성된 인스턴스를 초기화하는 역활을 합니다.\n\n*   “constructor” 라는 이름을 가진 메소드는 클래스 안에 한 개만 존재할 수 있습니다. 만약 클래스에 여러 개의 constructor 메소드가 존재하면 SyntaxError 가 발생할 것입니다.\n\n*   constructor는 부모 클래스의 constructor 를 호출하기 위해 super 키워드를 사용할 수 있습니다.\n\n*   참고  \n    클래스에 constructor를 작성하지 않으면 prototype의 constructor가 호출됩니다.  \n    이를 디폴트 constructor라고 하고 constructor가 없으면 인스턴스를 생성할 수 없습니다.  \n    ES5 에서 클래스 오브젝트를 실행하면 엔진이 디폴트 constructor를 호출해서 이를 활용할 수 없었습니다.  \n    ES6 에서는 개발자가 constructor를 정의할 수 있어서 Class 오브젝트 뿐 아니라  \n    Proxy 오브젝트, Reflect 오브젝트에서 활용할 수 있습니다.\n\n```js\n1. class Member {  \n constructor(name){  \n this.name = name;  \n }  \n getName() {  \n return this.name;  \n }  \n}  \n2. let memberObj = new Member(\"스포츠\");  \n3. console.log(memberObj.getName());  \n// 스포츠  \n```\n\n1.  클래스 안에 constructor를 작성했으며 constructor 안에 생성한 인스턴스에 초기값을 설정하는 코드를 작성했습니다.  \n    constructor 안의 this는 생성하는 인스턴스를 참조합니다.\n\n2.  new Member(“스포츠”)를 실행하면 Member 클래스에 작성한 constructor가 자동으로 호출되며 파라미터 값으로 “스포츠”를 넘겨 줍니다.\n    \n    *   new 연산자는 constructor를 호출하면서 파라미터를 넘겨주는 역활\n    *   호출된 constructor가 인스턴스를 생성하여 반환하면 new 연산자가 받아 new를 실행한 곳으로 반환합니다.\n\n## <mark>클래스 와 인스턴스 생성 과정 이해를 위한 개념적인 순서</mark>\n\n    1. new Member(\"스포츠\")를 실행합니다.\n\n    2. new 연산자가 constructor를 호출하면서 파라미터 값을 넘겨줍니다.\n\n    3. constructor의 블록 코드를 실행하기 전에 빈 Object 오브젝트를생성합니다.\n\n    4. 이 것이 인스턴스입니다. 인스턴스가 생성되면 빈 오브젝트를 채웁니다.\n\n    5. 인스턴스 구성에 필요한 프로퍼티를 Object 오브젝트에 설정합니다.\n\n    6. constructor 블록에 있는 코드를 실행합니다.\n\n    7. 인스턴스를 먼저 생성하므로 constructor에서 this로 인스턴스를 참조할수    있습니다.\n\n    8. 생성된 인스턴스를 반환합니다.\n\n3.  console.log(memberObj.getName());를 호출하면 다음 코드가 실행됩니다.\n\n>getName() {\n return this.name;\n}\n\nconstructor에서 this에 “스포츠”를 설정했으므로 “스포츠”가 반환됩니다.\n\n아래는 생성된 memberObj 인스턴스 구조입니다.\n\n<img src=\"/images/constructorInstance.JPG\">\n\nconstructor에서 파라미터로 받은 “스포츠”를 this.name에 할당했으며,  \n이때 this가 생성하는 인스턴스를 참조하므로 인스턴스 프로퍼티로 설정됩니다.\n\n*   &#95;&#95;proto&#95;&#95;는 인스턴스를 생성하면 엔진이 자동으로 첨부합니다.\n\n*   &#95;&#95;proto&#95;&#95;에 Member.prototype에 연결된 프로퍼티를 첨부하므로 getName도 첨부됩니다.\n\n*   &#95;&#95;proto&#95;&#95;에 Object 오브젝트의 prototype에 연결된 프로퍼티가 첨부됩니다.\n\n* * *\n\n<h2 id=\"constructor\">constructor</h2>\n\nconstructor는 일반적으로 return 문을 작성하지 않으며, 생성한 인스턴스를 반환합니다.  \nreturn을 사용하면 인스턴스 이외의 값을 반환할 수 있습니다.\n\n```js\nclass Member {  \n constructor(){  \n return 1;  \n }  \n getName(){  \n return \"이름\";  \n }  \n};  \nlet memberObj = new Member();  \nconsole.log(memberObj.getName());  \n```\n\nconstructor(){ }안에 return 1;을 작성하였습니다.  \n~~일반적으로 숫자 값을 반환하지 않습니다, 엔진 처리 방법 예시를 위해 작성되었습니다.~~  \n<mark>constructor에서 Number 또는 String 값을 반환하면 이를 무시하고 생성한 인스턴스를 반환합니다.</mark>\n\nconsole.log(memberObj.getName();)을 호출하면 constructor에서 1을 반환하여  \nmemberObj에 1이 설정됩니다. 이후에 getName()을 호출하면 인스턴스 1에 getName()이 존재하지 않으므로 에러가 발생합니다. 하지만 Member 인스턴스를 반환하므로 getName()이 호출됩니다.\n\n```js\nclass Member {  \n constructor(){  \n return {name: \"홍길동\"};  \n }  \n getName(){  \n return \"이름\";  \n }  \n}  \nlet memberObj = new Member();  \n  \n1. console.log(memberObj.name);  \n2. console.log(memberObj.getName);  \n// 홍길동  \n// undefined  \n```\n\nconstructor에서 Object오브젝트를 return하면 이를 반환합니다.  \n즉, {name: “홍길동”}이 반환됩니다.\n\n1.  memberObj에 반환된 {name: “홍길동”}이 설정되어 있으므로 memberObj.name 값이 홍길동 으로 출력됩니다.\n\n2.  클래스에 getName 메서드를 작성했지만, 인스턴스를 반환하지 않고 {name: “홍길동”}을 반환하므로  \n    MemberObj에 getName이 존재하지 않습니다. undefined가 출력됩니다.\n\n* * *\n\n<h2 id=\"getter_and_setter\">getter, setter</h2>\n\n클래스에도 getter와 setter를 선언할 수 있습니다.  \n메서드 이름 앞에 “get”을 작성하면 getter, “set”을 작성하면 setter가 됩니다.\n\n```js getter\nclass Member {  \n get getName() {  \n return \"이름\";  \n }  \n};  \nlet memberObj = new Member();  \nconsole.log(memberObj.getName);  \n// 이름  \n```\n\nget getName()과 같이 메서드 이름 앞에 get을 작성하여 getter로 선언합니다.\n\ngetName이 getter이므로 메서드로 호출됩니다.\n\n```js setter\nclass Member {  \n set setName(name) {  \n this.name = name;  \n }  \n get getName() {  \n return this.name;  \n }  \n};  \nlet memberObj = new Member();  \nmemberObj.setName = \"이름\";  \n  \nconsole.log(memberObj.getName);  \n// 이름  \n```\n\nmemberObj.setName = “이름”과 같이 setter로 선언된 메서드 이름에 값을 할당하면  \nsetName이 메서드로 호출됩니다. 이때 할당하는 값인 “이름”을 파라미터 값으로 넘겨줍니다.\n\n* * *\n\n<h2 id=\"상속\">상속</h2>\n\n객체지향 프로그래밍에서 상속은 주요한 기능 중 하나입니다.  \n클래스를 상속받으면 상속받은 클래스의 메서드와 프로퍼티를 사용할 수 있습니다.\n\n*   참고  \n    상속해 주는 클래스를 일반적으로 부모 클래스라고 부릅니다만  \n    앞으로는 “슈퍼 클래스”라고 표기해줍시다.  \n    슈퍼 클래스라고 표기하는 이유는 ES6에서 super키워드가 있으며  \n    슈퍼 클래스를 지칭하므로 직관적이기 때문입니다.  \n    상속받는 클래스도 일반적으로 자식 클래스라고 부릅니다만,  \n    슈퍼 클래스와 운을 맞추기 위해 “서브 클레스”로 표기해줍시다.\n\n\n<mark>자바스크립트 (객채지향 프로그래밍)의 상속 형태는 상속이 아니다?</mark>\n\n일반적으로 상속이라고 하면 부모의 재산을 자식에게 물려주면  \n자식이 부모의 능력을 고스란히 물려받습니다.  \n자바스크립트에서는 객체도 생성자도 모두 프로토타입에 접근할 수 있고  \n심지어 변경까지할 수 있습니다.  \n이는 상속받을 것들을 자기 마음대로 선택,변경할 수 있게 되고  \n다른 언어의 상속과는 다른 형태를 갖습니다.  \n상속이라고 부르지만, 프로토타입의 (자원)공유로 이해하는 것이 적절해 보입니다.\n\n**ES5에서의 상속 구현 형태**\n\n```js ES5 상속 형태\n1. function Sports(member){  \n 2. this.member = member;  \n};  \n3. Sports.prototype.setItem = function(item){  \n this.item = item;  \n};  \n  \n4. function Soccer(member){  \n Sports.call(this, member);  \n};  \n5. Soccer.prototype = Object.create(Sports.prototype, {  \n setGround: {  \n value: function(ground){  \n this.ground = ground;  \n }  \n }  \n});  \n6. Soccer.prototype.constructor = Soccer;  \n  \n7. var obj = new Soccer(11);  \n8. obj.setItem(\"축구\");  \nobj.setGround(\"상암\");  \n  \n9. console.log(obj.member); // 11  \nconsole.log(obj.item); // 축구  \nconsole.log(obj.ground); // 상암  \n```\n\n1.  Sports 첫 문자를 대문자로 작성한 것은 new 연산자로 인스턴스를 생성하려는 의도입니다. new Sports()를 실행하면 Sports()가 호출되고, 다시 디폴트 constructor를 호출합니다. 그래서 Sports()를 생성자(constructor)함수라고 부릅니다.\n\n2.  this.member에서 this가 생성하는 인스턴스를 참조하므로 member는 인스턴스 프로퍼티가 됩니다. Sports(생성자 함수)함수에서 this.member = member 형태가 인스턴스에 초기값으로 설정됩니다. ~~이렇게 설정된 값은 생성된 모든 인스턴스에서 공유하지 않고 인스턴스마다 값을 각각 유지합니다. 이것이 인스턴스를 만드는 목적 중의 하나입니다.~~\n\n3.  생성자 함수가 있으면 Sports.prototype.setItem과 같이 prototype에 메서드를 연결한 코드가 작성되어 있습니다. 이를 작성하지 않으면 생성자 함수가 아닌 일반 함수 입니다. **이 형태가 ES5에서 인스턴스를 구현하는 기본 형태입니다.**\n\n4.  Soccer()가 호출되면 Sports()를 호출합니다. Soccer의 첫 문자가 대문자이므로 인스턴스를 사용한다는 것을 알 수 있습니다. 그런데 new Sports()가 아닌 Sports.call()형태로 함수를 호출한 것은, 바로 다음 코드에서 Sports.prototype을 사용하여 인스턴스를 생성하므로 인스턴스에 초기값만 성정하면 되기 때문입니다.\n\n5.  Object.create()의 두 번째 파라미터 setGround를 첫 번째 파라미터인 Soccer.prototype에 첨부합니다. 그리고 Sports.prototype에 연결된 메서드를 Soccer.prototype.&#95;&#95;proto&#95;&#95;에 첨부합니다.  \n    이렇게 연결된 후에 new Soccer()로 인스턴스를 생성하면 Soccer.prototype과 Sports.prototype에 연결된 메서드를 인스턴스 메서드로 호출할 수 있습니다.**ES5에서는 이와 같은 방법으로 상속을 구현합니다.**\n\n6.  Soccer.prototype에 constructor가 연결되어 있는데, 앞 코드에서  \n    Soccer.prototype에 프로퍼티를 연결하므로 constructor가 지워집니다.  \n    Soccer를 설정하지 않아도 인스턴스가 생성되지만, constructor에서 Soccer전체를 참조하는 것이 정상입니다.\n\n7.  new 연산자로 Soccer() 생성자 함수를 호출하여 인스턴스를 생성합니다.  \n    Sports.prototype에 연결된 메서드는 인스턴스에 포함되지만, Sports() 생성자 함수는 포함되지 않으므로 Sports.call(this.member); 코드를 수행하여 인스턴스에 초기값을 설정합니다. this는 생성한 인스턴스를 참조하게 됩니다.\n\n8.  setItem()은 상속받은 Sports.prototype에 연결된 메서드 입니다.  \n    상속을 받으면 인스턴스에서 직접 상속받은 메서드를 호출할 수 있습니다.\n\n9.  생성자 함수를 모두 호출하여 인스턴스에 초기값을 설정했으므로 인스턴스 프로퍼티로 프로퍼티 값을 구할 수 있습니다.  \n    ES5에서는 이와 같이 prototype에 연결해야 하며 직관적이지 않은 점도 있습니다.\n\n* * *\n\n<h2 id=\"extends\">extends 키워드</h2>\n\nES6에서는 extends 키워드로 상속을 구현합니다.\n\n> class subClass extends superClass { }\n\n*   subClass  \n    상속 받는 자식 클래스(서브 클래스).\n    \n*   superClass  \n    상속 해주는 부모 클래스(슈퍼 클래스).\n    \n*   new subClass()로 인스턴스를 생성하면 인스턴스에서 subClass 클래스와 super 클래스의 메서드를 호출할 수 있습니다.\n    \n\n```js extends ES6\n1. class Sports {  \n constructor(member){  \n this.member = member;  \n }  \n getMember(){  \n return this.member;  \n }  \n};  \n2. class Soccer extends Sports {  \n setGround(ground){  \n this.ground = ground;  \n }  \n};  \n3. let obj = new Soccer(11);  \n  \n4. console.log(obj.getMember()); // 11  \n```\n\n1.  Sports 클래스를 상속받으므로 Sports 클래스는 슈퍼 클래스입니다.  \n    new Soccer()로 인스턴스를 생성하면 constructor가 호출되며,this가 생성하는 인스턴스를 참조하므로 파라미터로 받은 값을 인스턴스의 member 프로퍼티에 설정할 수 있습니다.\n\n2.  extends 키워드 기준으로 왼쪽의 Soccer 클래스가 서브클래스  \n    오른쪽 Sports 클래스가 슈퍼클래스입니다. 즉, Soccer 클래스에서 Sports 클래스를 상속받습니다. this.ground에서 this는 생성한 인스턴스를 참조합니다.\n    \n    *   이 시점의 Soccer 클래스 구조입니다.    \n    <img scr=\"/images/extendsSoccer.JPG\">\n    \n    1.  Soccer.prototype에 setGround가 연결되어 있으며\n    2.  Soccer.prototype.&#95;&#95;proto&#95;&#95;에 Sports.prototype에 연결되어 있는 getMember가 첨부되어 있습니다.\n    3.  Soccer.&#95;&#95;proto&#95;&#95;에 Sports.prototype에 연결된 프로퍼티도 첨부되어 있습니다.\n    \n    *   이와 같이 extends 키워드는 서브클래스의 prototype에 &#95;&#95;proto&#95;&#95;를 만들고 여기에 슈퍼클래스의 prototype에 연결된 프로퍼티를 연결합니다.  \n        ~~슈퍼클래스의 prototype에 연결된 메서드를 복사하는 것이 아니라 공유합니다.~~  \n        new Soccer()로 인스턴스를 생성할 때 Soccer.prototype에 연결된 프로퍼티를 사용하므로 서브클래스와 슈퍼클래스의 메서드가 인스턴스에 포함됩니다.\n\n3.  new Soccer(11)을 실행하면 다음의 순서와 방법으로 실행합니다.\n    \n    1.  Soccer 클래스의 constructor가 호출됩니다.\n    2.  Soccer 클래스에는 constructor를 작성하지 않았습니다.\n    3.  슈퍼 클래스의 constructor가 호출되면서 11을 파라미터 값으로 넘겨줍니다.\n    4.  슈퍼 클래스의 constructor에서 this는 현재의 인스턴스를 참조하므로 인스턴스의 member 프로퍼티에 파라미터로 받은 11을 설정한 후 돌아오게 되며,\n    5.  생성한 인스턴스를 obj에 할당합니다.\n    \n    *   다음은 obj의 인스턴스 구조입니다.\n        <img src=\"/images/extendsObj.JPG\">\n        \n    *   인스턴스를 생성하는 주체는 서브 클래스입니다. new Sports()가 아닌 new Soccer()로 인스턴스를 생성합니다.\n        \n    *   슈퍼 클래스의 constructor에서 this.member에 설정한 값이 인스턴스 프로퍼티로 설정됩니다.\n        \n    *   &#95;&#95;proto&#95;&#95;에 서브 클래스의 prototype에 연결된 메서드가 첨부되었으며\n        \n    *   &#95;&#95;proto&#95;&#95;에 슈퍼 클래스의 prototype에 연결된 메서드가 첨부됩니다.\n        \n    *   메서드를 호출할 때 &#95;&#95;proto&#95;&#95;를 작성하지 않아도 되므로  \n        setGround()와 getMember()를 인스턴스에서 직접 호출할 수 있습니다.\n        \n\n4.  obj.getMember()를 호출하면 우선 obj.&#95;&#95;proto&#95;&#95;에서 메서드를 찾습니다. 존재하지 않으면 obj.&#95;&#95;proto&#95;&#95;.&#95;&#95;proto&#95;&#95;에서 찾습니다. 메서드가 존재하면 호출됩니다.  \n    이것이 자바스크립트의 상속 메커니즘 입니다.\n\n* * *\n\n<h2 id=\"super\">super 키워드</h2>\n\n서브 클래스와 슈퍼 클래스에 같은 이름의 메서드가 존재하면 슈퍼 클래스의 메서드는 호출되지 않습니다.  \n이때 super 키워드를 사용하여 슈퍼 클래스의 메서드(혹은 함수)를 호출할 수 있습니다.\n\n서브 클래스 constructor에 super()를 작성하면 슈퍼 클래스의 constructor가 호출됩니다.  \nsuper.name()과 같이 super 키워드에 이어서 호출하려는 메서드 이름을 작성합니다.\n\n### 메서드 오버라이딩\n\n서브 클래스와 슈퍼 클래스에 같은 이름의 메서드가 있을 때 서브 클래스의 메서드가 호출 되는 것을  \n메서드 오버라이딩(Overriding)이라고 합니다. 메서드 오버라이딩은 의도적인 접근 방식입니다.\n\n서브 클래스와 슈퍼 클래스의 같은 이름의 메서드가 같은 목적을 가진 것을 나타내면서  \n서브 클래스의 목적에 맞도록 보완할 때 사용합니다.(슈퍼 클래스의 메서드 기능을 사용하면서 서브 클래스에서 기능을 추가,변경할 때 사용합니다.)\n\n슈퍼 클래스와 서브 클래스의 메서드 기능/목적이 다른 경우에는 같은 이름을 사용하지 않습니다.\n\n```js super-1\nclass Sports {  \n setGround(ground){  \n this.ground = ground;  \n }  \n};  \n1. class Soccer extends Sports {  \n setGround(ground){  \n 2. super.setGround();  \n this.ground = ground;  \n }  \n};  \n3. let obj = new Soccer();  \nobj.setGround(\"상암구장\");  \nconsole.log(obj.ground);  \n// 상암구장  \n```\n\n~~Sports 클래스는 슈퍼 클래스 입니다. 상속을 해주지만 단독으로 인스턴스를 생성할 수도 있습니다.~~\n\n*   Class Sports{}에는 그라운드(setground)가 필요합니다.  \n    Sports의 종목이 여러개라면 종목마다 그라운드(setGround)형태도 달라져야 할 수 있습니다.  \n    그런 의미에서 setGround()메서드는 의미 없어 보일 수 있습니다.\n\n*   하지만 Sports 클래스를 상속받는 서브 클래스에서 setGround를 오버라이딩 하면 일관성 있게  \n    그라운드를 정의할 수 있습니다. 메서드 이름을 유지하면서 서브클래스 마다  \n    적합한 그라운드(setGround)를 설정해 주는 것입니다.  \n    이를 객체 지향에서 추상화(Abstraction)라고 합니다.\n\n1.  Soccer 클래스에서 Sports 클래스를 상속받습니다. Sports 클래스에 setGround()가 있으며  \n    Soccer 클래스에도 있으므로 메서드가 오버라이딩 됩니다.  \n    new Soccer()로 인스턴스를 생성한 후 setGround()를 호출하게 되면 서브클래스(Soccer)의  \n    메서드가 호출됩니다. 이때 super.setGround()는 슈퍼클래스(Sports)의 setGround()를 호출합니다.\n\n2.  super.setGround()를 호출하면서 파라미터 값은 정해주지 않았습니다.  \n    슈퍼클래스(Soccer)의 setGround()에서 this.ground에 undefined가 설정됩니다.  \n    super.setGround()를 실행한 후 돌아오면 바로 다음 줄의 this.ground에서 파라미터로 받은 값을 설정합니다.\n\n3.  new Soccer()로 인스턴스를 생성하고 setGround()를 호출하면 인스턴스의 ground 프로퍼티에 파라미터 값이 설정됩니다. ground가 인스턴스 프로퍼티이므로 obj.ground로 값을 출력할 수 있습니다.\n\n```js super-2\nclass Sports {  \n    constructor(member){  \n        this.member = member;  \n        console.log(this.member);  \n    }  \n};  \n2. class Soccer extends Sports {  \n 3. constructor(member){  \n        super(member);  \n        this.member = 456;  \n        console.log(this.member);  \n    }  \n};  \n1. let obj = new Soccer(123);  \n// 123  \n// 456  \n```\n\n1.  new Soccer(123)을 실행하면 Soccer 클래스의 constructor가 호출됩니다.\n\n2.  constructor 첫째 줄의 super(member)를 실행하면 슈퍼 클래스의 constructor를  \n    호출 하면서 파라미터로 받은 값을 넘겨줍니다. 슈퍼 클래스의 constructor를  \n    호출하려면 서브클래스 constructor의 첫째 줄에 super()를 작성해야 합니다.\n\n**super() 앞에 변수를 선언하거나 변수에 값을 할당하는 코드는 작성해도 되지만,**  \n**this 키워드는 super() 앞에 사용할 수 없습니다.**\n\n3.  super()로 인해 constructor가 호출되면 this로 인스턴스를 참조할 수 있습니다.  \n    따라서 파라미터로 받은 member 값을 인스턴스의 member 프로퍼티에 할당할 수 있습니다.\n\n* * *\n\n<h2 id=\"builtin\">빌트인 오브젝트 상속</h2>\n\nextends 키워드로 Array 오브젝트 등의 빌트인 오브젝트를 상속받을 수 있습니다.  \n상속을 받지 않고 서브 클래스에서 빌트인 오브젝트의 메서드를 호출해도 되지만  \n상속 받는 것과 차이가 있습니다. 서브 클래스에서 빌트인 오브젝트를 상속받으면  \n빌트인 오브젝트의 메서드를 마치 서브 클래스에서 선언한 것처럼 사용할 수 있게 됩니다.\n\n```js builtin\n2. class ExtendArray extends Array {  \n constructor(){  \n super();  \n }  \n getTotal(){  \n let total = 0;  \n for (var value of this){  \n total += value;  \n };  \n return total;  \n }  \n};  \n  \n1. let obj = new ExtendArray();  \n3. obj.push(10, 20);  \n  \n4. console.log(obj.getTotal());  \n// 30  \n```\n\n1.  클래스 ExtendArray 에 빌트인 오브젝트인 Array 오브젝트를 상속받았습니다.  \n    new 연산자로 인스턴스를 생성하면 인스턴스는 Array 오브젝트의 특징을 갖게됩니다.  \n    따라서 인스턴스에서 push()와 같은 Array 메서드를 직접 호출할 수 있습니다.  \n    “[].push()”형태가 아닌 “인스턴스.push()”형태로 호출할 수 있습니다.  \n    이 형태의 차이에 상속 받는 목적이 담겨있다고 할 수 있습니다.\n\n2.  new ExtendArray()를 실행하면 아래에 작성한 constructor가 호출됩니다.\n    \n    > constructor(){  \n    > super();  \n    > }\n    \n    super()가 슈퍼 클래스의 constructor를 호출하므로 Array 오브젝트 constructor가  \n    호출됩니다.\n    \n\n3.  obj 인스턴스에 push()메서드가 상속되어 있으므로 obj.push(10,20)형태로 호출할 수 있습니다.  \n    obj.push(10, 20) 과 [].push(10, 20)에서 obj 인스턴스가 Array 리터럴[]에 해당됩니다.  \n    따라서 obj 인스턴스에 10 과 20를 설정하는 것은 Array 인스턴스에 설정하는 것과 같습니다.  \n    이것이 빌트인 오브젝트를 상속받는 목적 중의 하나입니다.\n\n4.  obj.getTotal()을 호출하면 for-of 문으로 [10, 20]을 합산하여 반환합니다.  \n    ~~값을 합산해주는 빌트인 함수도 있지만 for(var value of this)문에서  \n    this를 다루기 위해 의도적으로 for-of 문을 사용했습니다.~~  \n    this가 obj 인스턴스를 참조합니다. obj 인스턴스는 [10, 20]값이 설정되어 있으며  \n    Array 오브젝트를 상속받은 상태 이므로 length 프로퍼티를 갖고있습니다.  \n    즉, 이터레이션을 수행할 수 있는 조건을 충족합니다.\n    \n    > for(var value of [10, 20]){  \n    > total += value;  \n    > } return total\n    \n\n위 헝태가 되어 엘리먼트(10, 20)를 하나씩 읽어가면서 for-of 문을 반복합니다.\n\n* * *\n\n<h2 id=\"Object_super\">Object에서 super 사용</h2>\n\n두 개의 Object 오브젝트가 연결된 구조에서 super.name() 형태로 슈퍼 오브젝트의  \n메서드를 호출할 수 있습니다.\n\n```js\nlet Sports = {  \n getTitle(){  \n console.log(\"Sports\");  \n }  \n};  \nlet Soccer = {  \n getTitle(){  \n super.getTitle();  \n console.log(\"Soccer\");  \n }  \n};  \n1. Object.setPrototypeOf(Soccer, Sports);  \n2. Soccer.getTitle();  \n//Sports  \n//Soccer  \n```\n\n1.  Object.setPrototypeOf()을 실행하면 Soccer.&#95;&#95;proto&#95;&#95;에  \n    Sports 오브젝트의 프로퍼티가 첨부됩니다.  \n    Object 오브젝트가 대상이므로 생성자 함수가 없지만,&#95;&#95;proto&#95;&#95;에 프로퍼티가 첨부되는 것이 상속 구조(형태)입니다.\n    \n2.  Soccer.getTitle();이 호출되면, 첫째 줄에서 super.getTitle()을 호출합니다.  \n    상속을 하면 &#95;&#95;proto&#95;&#95;로 계층을 만들고,&#95;&#95;proto&#95;&#95;에 상속받을 오브젝트의 프로퍼티를 첨부하므로, super는 한 단계 아래의 &#95;&#95;proto&#95;&#95;를 참조하는 것과 같습니다.\n    \n\n현재 Soccer.&#95;&#95;proto&#95;&#95;에 Sports 오브젝트의 getTitle()이 첨부되어 있습니다.  \n따라서 super.getTitle()을 호출하면, super가 Soccer.&#95;&#95;proto&#95;&#95;를 참조하므로  \nSports 오브젝트의 getTitle()이 호출됩니다.  \n\n**이와 같이 Object.setPrototypeOf()으로 &#95;&#95;proto&#95;&#95;구조를 만들고 상속받을 오브젝트의 프로퍼티를 첨부하면, super키워드로 상속 계층 구조에 있는 메서드를 호출할 수 있습니다.**\n\n* * *\n\n<h2 id=\"static\">static 키워드</h2>\n\n클래스에 static(정적) 메서드를 정의합니다.\n\n> static methodName() { … }\n\nprototype에 연결된 메서드는 인스턴스를 생성하여 호출 하지만,  \nstatic 메서드는 인스턴스를 생성하지않고 클래스에 직접 연결하여 호출합니다.\n\nstatic 메서드는 prototype에 연결되지 않으므로 인스턴스에서 호출할 수 없습니다.  \n클래스 이름을 지정하여 static 메서드를 호출해야 합니다.\n\n*   중요 포인트  \n    엔진이 class 키워드를 만나면 클래스 안에 static 메서드 작성 여부를 체크합니다.  \n    static 메서드가 존재한다면 이를 Function 오브젝트로 생성합니다.  \n    (메서드를 호출하기 위해서는 메서드가 Function 오브젝트여야 하고,  \n    이렇게 생성함으로써 클래스 아래의 static메서드를 호출할 수 있게 합니다.)\n\n```js 자바스크립트 Function 오브젝트 생성 형태\nfunction(){ // Function 오브젝트입니다.  \n function(){ // Function 오브젝트가 아닙니다.  \n }  \n}  \n```\n\nfunction 안에 function은 Function 오브젝트로 생성하지 않고,  \nfunction이 호출되어 안에 있는 function으로 들어갔을 때  \nFunction 오브젝트를 생성합니다.  \n따라서 function을 호출하지 않으면 안에 있는 function은  \n아무것도 아닙니다. 그저 작성돼있는 함수 입니다.  \n이 점이 static 키워드를 사용한 메서드와 차이점 입니다.\n\n```js\nclass Sports {  \n static getGround() {  \n return \"상암구장\";  \n }  \n};  \n1. console.log(Sports.getGround());  \n```\n\ngetGround(){} 앞에 static을 작성하여 static메서드로 선언했습니다.\n\n1.  Sports는 클래스 이름이고 getGround()는 static메서드 입니다.  \n    이와 같이 앞에 클래스 이름을 작성하고 이어서 static메서드를 작성하여 호출합니다.\n\n* * *\n\n<h2 id=\"Class_Hoisting\">Class 호이스팅</h2>\n\n클래스는 호이스팅(Hoisting)이 되지 않습니다.\n\n```js\n// Class  \nlet result = Member;  \nclass Member {  \n static getMember(){  \n return \"member\";  \n }  \n};  \nconsole.log(Member.getMember()); // member  \nconsole.log(result.getMember()); // TypeError  \n  \n// function과 비교  \nlet result2 = Member2;  \nfunction Member2() {  \n return \"member2\";  \n};  \nconsole.log(Member2());// member2  \nconsole.log(result2());// member2  \n```\n\n호이스팅 된다면 Member 클래스가 result 변수에 할당됩니다.  \n호이스팅 되지않으면 Member를 인식하지 못합니다. Error\n\n*   클래스는 호이스팅 되지않아 result에 할당할 Member를 인식하지 못합니다.  \n    result에 Member 값을 넣으려면 클래스 문이 완전히 끝난 뒤에 작성해야합니다.\n    \n*   function은 호이스팅 되므로 result2에 Member2를 인식하여 할당할 수 있습니다.\n    \n\n* * *\n\n<h2 id=\"computed_name\">computed name</h2>\n\n클래스의 메서드 이름을 조합(computed name)하여 작성할 수 있습니다.\n\n```js computed name\nlet type = \"Type\";  \nclass Sports {  \n static [\"get\" + type](kind){  \n return kind ? \"스포츠\" : \"음악\";  \n }  \n}  \n1. console.log(Sports[\"get\" + type](1)); // 스포츠  \nconsole.log(Sports.getType(1)); // 스포츠  \n```\n\n변수 type 에 문자열 값 “Type”을 할당해 줬습니다.  \nstatic 메서드 []안에 문자열 “get” 과 클래스 밖에 작성된 type 변수 값을  \n작성해줬습니다. static메서드의 이름이 getType이 됩니다.  \n이와 같이 static 메서드 []안에 조합할 이름을 작성합니다.\n\n1.  문자열 “get”과 변수인 type을 조합하여 호출합니다.  \n    파라미터 값이 1 (true)이므로 호출된 getType()에서 “스포츠”를 반환합니다.  \n    물론 console.log(Sports.getType(1)); 형태로 호출할 수 도 있습니다.\n\n* * *\n\n<h2 id=\"this\">this</h2>\n\nstatic 메서드에서 this는 클래스 오브젝트를 참조합니다.  \nconstructor 안에서 this.constructor.name()형태로 static 메서드를 호출할 수 있습니다.\n\n```js this 예제\nclass Sports {  \n static setGround(ground){  \n this.ground = ground;  \n }  \n static getGround(){  \n return this.ground;  \n }  \n};  \nSports.setGround(\"상암구장\");  \nconsole.log(Sports.getGround());  \n// 상암구장  \n```\n\nSports.setGround(“상암구장”)를 실행하면 static메서드인 setGround()가 호출됩니다.  \nthis.ground에서 this가 Sports 클래스를 참조하므로 Sports 클래스에  \n{ground: “상암구장”} 형태로 설정됩니다.\n\nSports.getGround()를 실행하면 getGround() 정적 메서드가 호출됩니다.  \nthis.Ground에서 this가 Sports 클래스를 참조하므로 setGround()에서  \nSports 클래스에 설정한 ground 프로퍼티 값을 구할 수 있습니다. //상암구장\n\n```js this 호출 예제\nclass Sports{  \n constructor(){  \n 1. console.log(Sports.getGround());  \n 2. console.log(this.constructor.getGround());  \n }  \n static getGround(){  \n return \"상암구장\";  \n }  \n};  \nlet obj = new Sports();  \n```\n\nnew Sports()를 실행하면 constructor가 호출됩니다.  \nconstructor 블록{}안에서 static메서드인 getGround를 호출하며,  \nthis.constructor 형태도 사용하고 있습니다.\n\n1.  Sports 클래스에 static 메서드로 getGround()를 작성했으므로  \n    Sports.getGround() 형태로 호출할 수 있습니다.  \n    constructor 블록{} 아래에 getGround()가 작성되어 있습니다만  \n    이미 Function 오브젝트로 생성된 상태이므로 호출이 됩니다.\n\n2.  constructor가 Sports 클래스를 참조하며 인스턴스의 &#95;&#95;proto&#95;&#95;에  \n    constructor가 첨부되어 있으므로 this.constructor.getGround() 형태로  \n    static메서드를 호출할 수 있습니다. 구조는 다음 사진과 같습니다.\n    <img src=\"/images/ClassThisInstance.JPG\">\n\n*   this.getGround()형태로는 호출할 수 없습니다. (//undefined)  \n    this가 new Sport()로 생성한 인스턴스를 참조하고,  \n    getGround는 static메서드 이므로 인스턴스에 존재하지 않기 때문입니다.\n\n* * *\n\n<h2 id=\"generator\">제너레이터</h2>\n\n클래스 안에 제너레이터 함수를 작성할 수 있습니다.  \n클래스 안에 작성한 제너레이터 함수는 prototype에 연결됩니다.  \n따라서 static 메서드로 호출할 수 없고 인스턴스를 생성하여 호출해야 합니다.\n\n```js\nclass Member{  \n *gen() {  \n yield 10;  \n yield 20;  \n }  \n};  \nlet obj = new Member();  \nlet genObj = obj.gen();  \n  \nconsole.log(genObj.next());  \nconsole.log(genObj.next());  \n// Object {value: 10, done: false}  \n// Object {value: 20, done: false}\n```  \n\nnew Member()로 클래스 인스턴스를 생성 합니다. 변수 obj에 할당됩니다.  \ngenObj 변수에 obj.gen 메서드를 할당합니다.  \ngenObj.next()로 호출할 수 있게됩니다.\n\n* * *\n\n<h2 id=\"new_target\">new.target</h2>\n\nnew.target은 메타(meta) 프로퍼티로 생성자 함수와 클래스에서  \nconstructor를 참조합니다. new 연산자로 인스턴스를 생성하지 않으면  \nnew.target 값은 undefined 입니다.\n\n```js\nlet sports = function(){  \n console.log(new.target);  \n}  \nsports();  \nnew sports();  \n// undefined  \n/* function() {  \n console.log(new.target);  \n}  \n*/  \n```\n\nsports(); 와 같이 new 연산자를 사용하지 않고 호출하면 new.target값은 undefined 입니다.\n\nnew sports();로 호출하면 new.target은 constructor를 참조합니다.  \nsports 함수에 constructor를 작성하지 않았으므로 디폴트 constructor가 호출됩니다.  \n디폴트 constructor = (function: Object() {native code})  \nconstructor가 sports 전체를 참조하므로 sports 함수의 코드가 출력됩니다.\n\n### name 프로퍼티\n\nES6는 클래스, 함수 오브젝트에 name 프로퍼티가 존재하며 이름이 설정됩니다.\n\n```js\nclass Sports {  \n constructor(){  \n console.log(\"Sports:\", new.target.name);  \n }  \n};  \nclass Soccer extends Sports {  \n constructor(){  \n super();  \n console.log(\"Soccer:\", new.target.name);  \n }  \n};  \nlet sportsObj = new Sports();  \nlet soccerObj = new Soccer();  \n// Sports: Sports  \n// Sports: Soccer  \n// Soccer: Soccer  \n```\n\n*   new Sports()를 호출하면 Sports 클래스이므로 클래스 name 프로퍼티에 “Sports”가  \n    설정되어 있습니다. constructor에서 new.target은 constructor를 참조하므로  \n    Sports 클래스의 name 프로퍼티 값 “Sports”가 출력됩니다.\n    \n*   new Soccer()를 호출하면 super()로 인해 Sports의 constructor가 호출됩니다.  \n    Sports의 constructor에서 new.target은 super()로 호출한 Soccer의  \n    constructor를 참조합니다. 따라서 new.target.name 값으로 Sports가 아닌 Soccer가 출력됩니다.\n    \n\n* * *\n\n<h2 id=\"Image_Object\">Image 오브젝트 상속</h2>\n\n*   DOM(Document Object Model)에서 제공하는 Image 인터페이스, Audio 인터페이스 등을 상속받을 수 있습니다.  \n    빌트인 Array 오브젝트를 상속받으면 Array 오브젝트 특징을 갖듯이  \n    상속받은 인터페이스 특징을 갖습니다.\n    \n*   DOM의 Image 인터페이스는 웹 페이지에 png 파일과 같은 이미지 파일을 표현하기 위한 속성을 제공합니다.  \n    인터페이스는 객체지향 용어로 이 자체를 그대로 사용할 수 없고 오브젝트로 변환하여 사용해야 합니다.  \n    DOM은 오브젝트를 제공하지 않고 인터페이스를 제공하는데,이는 자바스크립트뿐만 아니라 Java등의 다른 언어에서도 사용하기 때문입니다. 각 언어에서 DOM인터페이스를 언어에 맞게 변환하여 사용합니다.\n    \n\n인터페이스를 오브젝트로 변환하려면 extends 키워드를 사용합니다.\n\n```js extends-image\n1. class ExtendsImage extends Image{  \n constructor() {  \n super();  \n }  \n 2. setProperty(image){  \n this.src = image.src;  \n this.alt = image.alt;  \n this.title = image.title;  \n }  \n};  \nlet imageObj = new ExtendsImage();  \n  \nlet properties = {  \n src: \"file/rainbow.png\",  \n alt: \"나무와 집이 있고 그 위에 무지개가 있는 모습\",  \n title: \"무지개\"  \n};  \n  \nimageObj.setProperty(properties);  \n3. document.querySelector(\"body\").appendChild(imageObj);  \n```\n\n1.  Image 오브젝트를 extends 키워드로 상속받습니다.  \n    ExtendsImage 클래스는 Image 특성을 갖게됩니다.  \n    즉, < img > 엘리먼트의 속성을 직접 사용할 수 있습니다.  \n    또한 this로 엘리먼트 속성에 접근할 수 있습니다.\n    \n2.  파라미터로 받은 < img > 속성 값을 this가 참조하는 imageObj 인스턴스에 설정합니다.\n    \n3.  < body> 엘리먼트에 자식 요소로 imageObj를 첨부합니다.  \n    body 엘리먼트에 imageObj 안에 있는 img 엘리먼트 속성도 첨부 횝니다.\n    \n\n웹페이지에 이미지가 표시되고 그 속성은 다음과 같습니다.\n\n> < img src = “file/rainbow.png”  \n> alt= “나무와 집이 있고 그 위에 무지개가 있는 모습”  \n> title= “무지개” >\n","source":"_posts/Class 오브젝트 -ECMAScript.md","raw":"---\ntitle: Class 오브젝트 -ECMAScript\ndate: 2020-04-01 09:45:41\ncategories: ECMAScript6\ndisqusId: tunas-blog-1\ntag: \n- ECMAScript6\n- JavaScript\n---\n\nClass(클래스)를 완전하게 이해하려면 객체지항 프로그래밍(OOP:Object Oriented Programming)에 대한 이해가 필요합니다.\n\nOOP만 다루는 책이 있을 정도로 범위가 넓고 깊으므로  \nOOP는 나중에 자세히 다루고 ES6기준으로 살펴봅니다.\n\n*   Class 오브젝트\n    *   [Class 선언문](/2020/04/01/Class%20오브젝트%20-ECMAScript/#Class_선언문)\n    *   [Class 표현식](/2020/04/01/Class%20오브젝트%20-ECMAScript/#Class_표현식)\n    *   [Class 특징](/2020/04/01/Class%20오브젝트%20-ECMAScript/#클래스_특징)\n        *   strict 모드에서 실행\n        *   클래스에 메서드 작성 방법\n        *   prototype에 프로퍼티 연결\n        *   prototype에 프로퍼티 추가\n    *   [constructor](/2020/04/01/Class%20오브젝트%20-ECMAScript/#constructor)\n    *   [constructor 반환 값 변경](/2020/04/01/Class%20오브젝트%20-ECMAScript/#constructor_return)\n    *   [getter, setter](/2020/04/01/Class%20오브젝트%20-ECMAScript/#getter_and_setter)\n    *   [상속](/2020/04/01/Class%20오브젝트%20-ECMAScript/#상속)\n    *   [extends 키워드](/2020/04/01/Class%20오브젝트%20-ECMAScript/#extends)\n    *   [super 키워드](/2020/04/01/Class%20오브젝트%20-ECMAScript/#super)\n        *   메서드 오버라이딩\n    *   [빌트인 오브젝트 상속](/2020/04/01/Class%20오브젝트%20-ECMAScript/#builtin)\n    *   [Object에서 super 사용](/2020/04/01/Class%20오브젝트%20-ECMAScript/#Object_super)\n    *   [static 키워드](/2020/04/01/Class%20오브젝트%20-ECMAScript/#static)\n    *   [Class 호이스팅](/2020/04/01/Class%20오브젝트%20-ECMAScript/#Class_Hoisting)\n    *   [computed name](/2020/04/01/Class%20오브젝트%20-ECMAScript/#computed_name)\n    *   [this](/2020/04/01/Class%20오브젝트%20-ECMAScript/#this)\n    *   [제너레이터](/2020/04/01/Class%20오브젝트%20-ECMAScript/#generator)\n    *   [new.target](/2020/04/01/Class%20오브젝트%20-ECMAScript/#new_target)\n        *   name 프로퍼티\n    *   [오브젝트 상속](/2020/04/01/Class%20오브젝트%20-ECMAScript/#Image_Object)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Class_선언문\">Class 선언문</h2>\n\n> Class name {}  \n> Class name extends super_name {}\n\n엔진이 function 키워드를 만나면 Function 오브젝트를 생성하듯이  \nclass 키워드를 만나면 Class 오브젝트를 생성합니다.  \nClass 오브젝트는 Function 오브젝트, String 오브젝트와 같이 하나의 오트젝트 타입입니다.\n\n*   name에 클래스 이름을 작성합니다.  \n    name 다음의 extends는 키워드로 super_name(슈퍼 클래스)를 상속받을 때 사용합니다. 이 형태를 클래스 선언문 이라고 합니다.\n\nclass는 클래스를 선언하는 키워드이고  \n엔진이 class 키워드로 생성한 오브젝트는 Class 오브젝트 입니다.  \n문맥에 따라 Class 오브젝트를 class라고 말하기도 합니다.\n\n```js\nclass Member {  \n getName() {  \n return \"이름\";  \n }  \n};  \n1. let obj = new Member();  \n  \n2. console.log(obj.getName());  \n// 이름  \n```\n\n*   class 키워드를 작성하고 이어서 클래스 이름을 작성합니다. 그리고 블록{}을 작성하고 블록에 클래스 코드를 작성합니다.  \n    엔진이 class 키워드를 만나면 클래스(Class) 오브젝트를 생성합니다.\n\n1.  new 연산자로 Member()를 호출하면 인스턴스를 생성하여 반환합니다.\n    \n    <mark>function name(){}는 new 연산자로 인스턴스를 생성하지 않고  \n    name()형태로 호출할 수 있지만,  \n    클래스는 new 연산자로 인스턴스 생성없이 name()형태로 호출할 수 없으며  \n    TypeError가 발생합니다.</mark>\n2.  obj는 인스턴스이고 getName()은 class Member{}안에 작성한 메서드 입니다.  \n    이와 같이 new 연산자로 생성한 인스턴스를 사용하여 클래스에 작성한 메서드를 호출할 수 있습니다. 실행 결과 “이름”이 출력됩니다.\n    \n\n*   참고\n    \n    > new 연산자로 인스턴스를 생성하는 함수는 함수 이름의 첫 문자를 대문자로 작성합니다. 클래스 또한 new 연산자로 인스턴스를 생성하므로 클래스 이름의 첫 문자를 대문자로 사용합니다. 이는 스펙에 정의된 것은 아니며 자바스크립트 개발자들 사이의 관례입니다. 개발자가 코드의 대문자를 보고 인스턴스를 생성한다는 것을 알 수 있으므로 지키는 것이 좋습니다. 빌트인 Number 오브젝트, String 오브젝트도 이와 같은 맥락입니다.\n    \n\n*   같은 클래스를 두 번 선언하려고 시도할 때  \n    클래스 선언문으로 같은 클래스를 두 번 선언하면 오류가 발생합니다.\n    \n    > class Foo {};  \n    > class Foo {}; // Uncaught SyntaxError: Identifier ‘Foo’ has already been declared\n    \n\n*   이전에 표현식으로 정의한 경우에도 오류가 발생합니다.\n    \n    > var Foo = class {};  \n    > class Foo {}; // Uncaught TypeError: Identifier ‘Foo’ has already been declared\n    \n\n* * *\n\n<h2 id=\"Class_표현식\">Class 표현식</h2>\n\n클래스 표현식으로 클래스를 선언합니다.\n\n> let name = class {}  \n> let name = class inner_name {}  \n> let name = class extends super_name {}  \n> let name = class inner_name extends super_name {}\n\n할당 연산자 (=) 왼쪽에 클래스 이름을 작성하고 오른쪽에 class 키워드를 작성하고 블록{}안에 클래스 코드를 작성합니다. 이를 클래스 표현식이라고 합니다.\n\nClass 표현식은 이름을 가질 수도 있고, 갖지 않을 수도 있습니다. 이름을 가진 class 표현식의 이름은 클래스의 body에 대해 local scope에 한해 유효합니다.\n\n4번째 구문 class 와 extends 키워드 사이의 inner_name은 클래스 안에서 자신을 호출할 때 사용합니다. ~~function 키워드 함수에서도 inner_name을 작성할 수 있지만 사용하지 않듯 클래스도 사용하지 않습니다.~~\n\n```js\nlet Member = class {  \n getName() {  \n return \"이름\";  \n }  \n};  \nlet obj = new Member();  \nconsole.log(obj.getName());  \n```\n\n엔진이 클래스 키워드를 만나면 클래스 오브젝트를 생성하여 Member 변수에 할당합니다.\n\n* * *\n\n<h2 id=\"클래스_특징\">클래스 특징</h2>\n\nClass는 사실 함수입니다. 함수를 함수 표현식과 함수 선언으로 정의할 수 있듯이 class 문법도 class 표현식과 class 선언 두 가지 방법을 제공합니다.\n\n1.  strict 모드에서 실행\n    \n    **“use static”을 선언하지 않아도 클래스의 코드는 static 모드에서 실행됩니다.**\n    \n\n2.  클래스에 메서드 작성 방법\n    ```js\n    class Member{  \n     1. setName(name) {  \n     this.name = name;  \n     }  \n     2. getName() {  \n     return this.name;  \n     }  \n    };  \n    4. Member.prototype.getTitle = function(){};  \n    3. console.log(typeof Member);  \n    // function  \n    ```\n\n    *   setName(){ } 과 같이 function 키워드와 콜론(:)을 작성하지 않고 메서드 이름만 작성합니다.\n        \n    *   setName()과 getName() 메서드 사이에 콤마를 작성하지 않습니다.\n        \n    *   클래스의 typeof는 function 입니다. 이는 class가 function 구조라는 것을 의미합니다.\n        \n    *   function name(){ }은 글로벌 오브젝트(window Object)에 설정되지만  \n        class name(){ }은 글로벌 오브젝트에 설정되지 않습니다.  \n        따라서 window.Member로 클래스에 접근하면 undefined가 반환됩니다.  \n        `Class 오브젝트의 프로퍼티는 for()문 등으로 열거할 수 없습니다.`\n        \n\n3.  prototype에 프로퍼티 연결\n\n```js\nclass Member{  \n setName(name) {  \n this.name = name;  \n }  \n};  \n```\n\n~~prototype에 메서드를 연결하여 prototype.setName과 같이 작성하지 않고~~  \nsetName을 작성합니다. 자바스크립트는 기본적으로 prototype에 메서드를 연결하는 구조이므로 **클래스 안에 작성된 메서드를 엔진이 자동으로 prototype에 연결합니다.**  \n즉. 엔진이 Member.prototype.setName 형태로 연결해줍니다.\n\n이는 중요한 의미를 갖습니다. 자바스크립트의 기본 아키텍처(구성 방식 혹은 컴퓨터 소프트웨어의 호환성)를 유지하면서 객체지향 언어의 특징을 반영하려는 접근입니다.\n\n4.  prototype에 프로퍼티 추가\n\n\n> Member.prototype.getTitle = function(  ){ };  \n\n**클래스 밖에서 Member 클래스에 메서드를 추가하려면** 위와 같이  \nMember.prototype에 메서드를 연결하여 작성합니다.  \nMember 클래스를 선언할 때는 클래스 블록{}안에 작성하겠지만,  \n인스턴스를 생성한 후 상황에 따라 추가할 때 이 형태로 작성합니다.\n\n*   참고  \n    이렇게 메서드를 추가하면 이미 생성된 인스턴스에서 추가한 메서드를 공유할 수 있도록 엔진이 처리하게 되므로 부하 혹은 자원낭비가 됩니다.  \n    좋은 사용 예시로는 사용자의 행동이나 서버 데이터에 따라 메서드를 따로 추가할 수 있는 점이 있습니다.(역동성이 높다.)\n\n* * *\n\n<h2 id=\"constructor\">constructor</h2>\n\n*   constructor 메소드는 class 인스턴스를 생성하고 생성된 인스턴스를 초기화하는 역활을 합니다.\n\n*   “constructor” 라는 이름을 가진 메소드는 클래스 안에 한 개만 존재할 수 있습니다. 만약 클래스에 여러 개의 constructor 메소드가 존재하면 SyntaxError 가 발생할 것입니다.\n\n*   constructor는 부모 클래스의 constructor 를 호출하기 위해 super 키워드를 사용할 수 있습니다.\n\n*   참고  \n    클래스에 constructor를 작성하지 않으면 prototype의 constructor가 호출됩니다.  \n    이를 디폴트 constructor라고 하고 constructor가 없으면 인스턴스를 생성할 수 없습니다.  \n    ES5 에서 클래스 오브젝트를 실행하면 엔진이 디폴트 constructor를 호출해서 이를 활용할 수 없었습니다.  \n    ES6 에서는 개발자가 constructor를 정의할 수 있어서 Class 오브젝트 뿐 아니라  \n    Proxy 오브젝트, Reflect 오브젝트에서 활용할 수 있습니다.\n\n```js\n1. class Member {  \n constructor(name){  \n this.name = name;  \n }  \n getName() {  \n return this.name;  \n }  \n}  \n2. let memberObj = new Member(\"스포츠\");  \n3. console.log(memberObj.getName());  \n// 스포츠  \n```\n\n1.  클래스 안에 constructor를 작성했으며 constructor 안에 생성한 인스턴스에 초기값을 설정하는 코드를 작성했습니다.  \n    constructor 안의 this는 생성하는 인스턴스를 참조합니다.\n\n2.  new Member(“스포츠”)를 실행하면 Member 클래스에 작성한 constructor가 자동으로 호출되며 파라미터 값으로 “스포츠”를 넘겨 줍니다.\n    \n    *   new 연산자는 constructor를 호출하면서 파라미터를 넘겨주는 역활\n    *   호출된 constructor가 인스턴스를 생성하여 반환하면 new 연산자가 받아 new를 실행한 곳으로 반환합니다.\n\n## <mark>클래스 와 인스턴스 생성 과정 이해를 위한 개념적인 순서</mark>\n\n    1. new Member(\"스포츠\")를 실행합니다.\n\n    2. new 연산자가 constructor를 호출하면서 파라미터 값을 넘겨줍니다.\n\n    3. constructor의 블록 코드를 실행하기 전에 빈 Object 오브젝트를생성합니다.\n\n    4. 이 것이 인스턴스입니다. 인스턴스가 생성되면 빈 오브젝트를 채웁니다.\n\n    5. 인스턴스 구성에 필요한 프로퍼티를 Object 오브젝트에 설정합니다.\n\n    6. constructor 블록에 있는 코드를 실행합니다.\n\n    7. 인스턴스를 먼저 생성하므로 constructor에서 this로 인스턴스를 참조할수    있습니다.\n\n    8. 생성된 인스턴스를 반환합니다.\n\n3.  console.log(memberObj.getName());를 호출하면 다음 코드가 실행됩니다.\n\n>getName() {\n return this.name;\n}\n\nconstructor에서 this에 “스포츠”를 설정했으므로 “스포츠”가 반환됩니다.\n\n아래는 생성된 memberObj 인스턴스 구조입니다.\n\n<img src=\"/images/constructorInstance.JPG\">\n\nconstructor에서 파라미터로 받은 “스포츠”를 this.name에 할당했으며,  \n이때 this가 생성하는 인스턴스를 참조하므로 인스턴스 프로퍼티로 설정됩니다.\n\n*   &#95;&#95;proto&#95;&#95;는 인스턴스를 생성하면 엔진이 자동으로 첨부합니다.\n\n*   &#95;&#95;proto&#95;&#95;에 Member.prototype에 연결된 프로퍼티를 첨부하므로 getName도 첨부됩니다.\n\n*   &#95;&#95;proto&#95;&#95;에 Object 오브젝트의 prototype에 연결된 프로퍼티가 첨부됩니다.\n\n* * *\n\n<h2 id=\"constructor\">constructor</h2>\n\nconstructor는 일반적으로 return 문을 작성하지 않으며, 생성한 인스턴스를 반환합니다.  \nreturn을 사용하면 인스턴스 이외의 값을 반환할 수 있습니다.\n\n```js\nclass Member {  \n constructor(){  \n return 1;  \n }  \n getName(){  \n return \"이름\";  \n }  \n};  \nlet memberObj = new Member();  \nconsole.log(memberObj.getName());  \n```\n\nconstructor(){ }안에 return 1;을 작성하였습니다.  \n~~일반적으로 숫자 값을 반환하지 않습니다, 엔진 처리 방법 예시를 위해 작성되었습니다.~~  \n<mark>constructor에서 Number 또는 String 값을 반환하면 이를 무시하고 생성한 인스턴스를 반환합니다.</mark>\n\nconsole.log(memberObj.getName();)을 호출하면 constructor에서 1을 반환하여  \nmemberObj에 1이 설정됩니다. 이후에 getName()을 호출하면 인스턴스 1에 getName()이 존재하지 않으므로 에러가 발생합니다. 하지만 Member 인스턴스를 반환하므로 getName()이 호출됩니다.\n\n```js\nclass Member {  \n constructor(){  \n return {name: \"홍길동\"};  \n }  \n getName(){  \n return \"이름\";  \n }  \n}  \nlet memberObj = new Member();  \n  \n1. console.log(memberObj.name);  \n2. console.log(memberObj.getName);  \n// 홍길동  \n// undefined  \n```\n\nconstructor에서 Object오브젝트를 return하면 이를 반환합니다.  \n즉, {name: “홍길동”}이 반환됩니다.\n\n1.  memberObj에 반환된 {name: “홍길동”}이 설정되어 있으므로 memberObj.name 값이 홍길동 으로 출력됩니다.\n\n2.  클래스에 getName 메서드를 작성했지만, 인스턴스를 반환하지 않고 {name: “홍길동”}을 반환하므로  \n    MemberObj에 getName이 존재하지 않습니다. undefined가 출력됩니다.\n\n* * *\n\n<h2 id=\"getter_and_setter\">getter, setter</h2>\n\n클래스에도 getter와 setter를 선언할 수 있습니다.  \n메서드 이름 앞에 “get”을 작성하면 getter, “set”을 작성하면 setter가 됩니다.\n\n```js getter\nclass Member {  \n get getName() {  \n return \"이름\";  \n }  \n};  \nlet memberObj = new Member();  \nconsole.log(memberObj.getName);  \n// 이름  \n```\n\nget getName()과 같이 메서드 이름 앞에 get을 작성하여 getter로 선언합니다.\n\ngetName이 getter이므로 메서드로 호출됩니다.\n\n```js setter\nclass Member {  \n set setName(name) {  \n this.name = name;  \n }  \n get getName() {  \n return this.name;  \n }  \n};  \nlet memberObj = new Member();  \nmemberObj.setName = \"이름\";  \n  \nconsole.log(memberObj.getName);  \n// 이름  \n```\n\nmemberObj.setName = “이름”과 같이 setter로 선언된 메서드 이름에 값을 할당하면  \nsetName이 메서드로 호출됩니다. 이때 할당하는 값인 “이름”을 파라미터 값으로 넘겨줍니다.\n\n* * *\n\n<h2 id=\"상속\">상속</h2>\n\n객체지향 프로그래밍에서 상속은 주요한 기능 중 하나입니다.  \n클래스를 상속받으면 상속받은 클래스의 메서드와 프로퍼티를 사용할 수 있습니다.\n\n*   참고  \n    상속해 주는 클래스를 일반적으로 부모 클래스라고 부릅니다만  \n    앞으로는 “슈퍼 클래스”라고 표기해줍시다.  \n    슈퍼 클래스라고 표기하는 이유는 ES6에서 super키워드가 있으며  \n    슈퍼 클래스를 지칭하므로 직관적이기 때문입니다.  \n    상속받는 클래스도 일반적으로 자식 클래스라고 부릅니다만,  \n    슈퍼 클래스와 운을 맞추기 위해 “서브 클레스”로 표기해줍시다.\n\n\n<mark>자바스크립트 (객채지향 프로그래밍)의 상속 형태는 상속이 아니다?</mark>\n\n일반적으로 상속이라고 하면 부모의 재산을 자식에게 물려주면  \n자식이 부모의 능력을 고스란히 물려받습니다.  \n자바스크립트에서는 객체도 생성자도 모두 프로토타입에 접근할 수 있고  \n심지어 변경까지할 수 있습니다.  \n이는 상속받을 것들을 자기 마음대로 선택,변경할 수 있게 되고  \n다른 언어의 상속과는 다른 형태를 갖습니다.  \n상속이라고 부르지만, 프로토타입의 (자원)공유로 이해하는 것이 적절해 보입니다.\n\n**ES5에서의 상속 구현 형태**\n\n```js ES5 상속 형태\n1. function Sports(member){  \n 2. this.member = member;  \n};  \n3. Sports.prototype.setItem = function(item){  \n this.item = item;  \n};  \n  \n4. function Soccer(member){  \n Sports.call(this, member);  \n};  \n5. Soccer.prototype = Object.create(Sports.prototype, {  \n setGround: {  \n value: function(ground){  \n this.ground = ground;  \n }  \n }  \n});  \n6. Soccer.prototype.constructor = Soccer;  \n  \n7. var obj = new Soccer(11);  \n8. obj.setItem(\"축구\");  \nobj.setGround(\"상암\");  \n  \n9. console.log(obj.member); // 11  \nconsole.log(obj.item); // 축구  \nconsole.log(obj.ground); // 상암  \n```\n\n1.  Sports 첫 문자를 대문자로 작성한 것은 new 연산자로 인스턴스를 생성하려는 의도입니다. new Sports()를 실행하면 Sports()가 호출되고, 다시 디폴트 constructor를 호출합니다. 그래서 Sports()를 생성자(constructor)함수라고 부릅니다.\n\n2.  this.member에서 this가 생성하는 인스턴스를 참조하므로 member는 인스턴스 프로퍼티가 됩니다. Sports(생성자 함수)함수에서 this.member = member 형태가 인스턴스에 초기값으로 설정됩니다. ~~이렇게 설정된 값은 생성된 모든 인스턴스에서 공유하지 않고 인스턴스마다 값을 각각 유지합니다. 이것이 인스턴스를 만드는 목적 중의 하나입니다.~~\n\n3.  생성자 함수가 있으면 Sports.prototype.setItem과 같이 prototype에 메서드를 연결한 코드가 작성되어 있습니다. 이를 작성하지 않으면 생성자 함수가 아닌 일반 함수 입니다. **이 형태가 ES5에서 인스턴스를 구현하는 기본 형태입니다.**\n\n4.  Soccer()가 호출되면 Sports()를 호출합니다. Soccer의 첫 문자가 대문자이므로 인스턴스를 사용한다는 것을 알 수 있습니다. 그런데 new Sports()가 아닌 Sports.call()형태로 함수를 호출한 것은, 바로 다음 코드에서 Sports.prototype을 사용하여 인스턴스를 생성하므로 인스턴스에 초기값만 성정하면 되기 때문입니다.\n\n5.  Object.create()의 두 번째 파라미터 setGround를 첫 번째 파라미터인 Soccer.prototype에 첨부합니다. 그리고 Sports.prototype에 연결된 메서드를 Soccer.prototype.&#95;&#95;proto&#95;&#95;에 첨부합니다.  \n    이렇게 연결된 후에 new Soccer()로 인스턴스를 생성하면 Soccer.prototype과 Sports.prototype에 연결된 메서드를 인스턴스 메서드로 호출할 수 있습니다.**ES5에서는 이와 같은 방법으로 상속을 구현합니다.**\n\n6.  Soccer.prototype에 constructor가 연결되어 있는데, 앞 코드에서  \n    Soccer.prototype에 프로퍼티를 연결하므로 constructor가 지워집니다.  \n    Soccer를 설정하지 않아도 인스턴스가 생성되지만, constructor에서 Soccer전체를 참조하는 것이 정상입니다.\n\n7.  new 연산자로 Soccer() 생성자 함수를 호출하여 인스턴스를 생성합니다.  \n    Sports.prototype에 연결된 메서드는 인스턴스에 포함되지만, Sports() 생성자 함수는 포함되지 않으므로 Sports.call(this.member); 코드를 수행하여 인스턴스에 초기값을 설정합니다. this는 생성한 인스턴스를 참조하게 됩니다.\n\n8.  setItem()은 상속받은 Sports.prototype에 연결된 메서드 입니다.  \n    상속을 받으면 인스턴스에서 직접 상속받은 메서드를 호출할 수 있습니다.\n\n9.  생성자 함수를 모두 호출하여 인스턴스에 초기값을 설정했으므로 인스턴스 프로퍼티로 프로퍼티 값을 구할 수 있습니다.  \n    ES5에서는 이와 같이 prototype에 연결해야 하며 직관적이지 않은 점도 있습니다.\n\n* * *\n\n<h2 id=\"extends\">extends 키워드</h2>\n\nES6에서는 extends 키워드로 상속을 구현합니다.\n\n> class subClass extends superClass { }\n\n*   subClass  \n    상속 받는 자식 클래스(서브 클래스).\n    \n*   superClass  \n    상속 해주는 부모 클래스(슈퍼 클래스).\n    \n*   new subClass()로 인스턴스를 생성하면 인스턴스에서 subClass 클래스와 super 클래스의 메서드를 호출할 수 있습니다.\n    \n\n```js extends ES6\n1. class Sports {  \n constructor(member){  \n this.member = member;  \n }  \n getMember(){  \n return this.member;  \n }  \n};  \n2. class Soccer extends Sports {  \n setGround(ground){  \n this.ground = ground;  \n }  \n};  \n3. let obj = new Soccer(11);  \n  \n4. console.log(obj.getMember()); // 11  \n```\n\n1.  Sports 클래스를 상속받으므로 Sports 클래스는 슈퍼 클래스입니다.  \n    new Soccer()로 인스턴스를 생성하면 constructor가 호출되며,this가 생성하는 인스턴스를 참조하므로 파라미터로 받은 값을 인스턴스의 member 프로퍼티에 설정할 수 있습니다.\n\n2.  extends 키워드 기준으로 왼쪽의 Soccer 클래스가 서브클래스  \n    오른쪽 Sports 클래스가 슈퍼클래스입니다. 즉, Soccer 클래스에서 Sports 클래스를 상속받습니다. this.ground에서 this는 생성한 인스턴스를 참조합니다.\n    \n    *   이 시점의 Soccer 클래스 구조입니다.    \n    <img scr=\"/images/extendsSoccer.JPG\">\n    \n    1.  Soccer.prototype에 setGround가 연결되어 있으며\n    2.  Soccer.prototype.&#95;&#95;proto&#95;&#95;에 Sports.prototype에 연결되어 있는 getMember가 첨부되어 있습니다.\n    3.  Soccer.&#95;&#95;proto&#95;&#95;에 Sports.prototype에 연결된 프로퍼티도 첨부되어 있습니다.\n    \n    *   이와 같이 extends 키워드는 서브클래스의 prototype에 &#95;&#95;proto&#95;&#95;를 만들고 여기에 슈퍼클래스의 prototype에 연결된 프로퍼티를 연결합니다.  \n        ~~슈퍼클래스의 prototype에 연결된 메서드를 복사하는 것이 아니라 공유합니다.~~  \n        new Soccer()로 인스턴스를 생성할 때 Soccer.prototype에 연결된 프로퍼티를 사용하므로 서브클래스와 슈퍼클래스의 메서드가 인스턴스에 포함됩니다.\n\n3.  new Soccer(11)을 실행하면 다음의 순서와 방법으로 실행합니다.\n    \n    1.  Soccer 클래스의 constructor가 호출됩니다.\n    2.  Soccer 클래스에는 constructor를 작성하지 않았습니다.\n    3.  슈퍼 클래스의 constructor가 호출되면서 11을 파라미터 값으로 넘겨줍니다.\n    4.  슈퍼 클래스의 constructor에서 this는 현재의 인스턴스를 참조하므로 인스턴스의 member 프로퍼티에 파라미터로 받은 11을 설정한 후 돌아오게 되며,\n    5.  생성한 인스턴스를 obj에 할당합니다.\n    \n    *   다음은 obj의 인스턴스 구조입니다.\n        <img src=\"/images/extendsObj.JPG\">\n        \n    *   인스턴스를 생성하는 주체는 서브 클래스입니다. new Sports()가 아닌 new Soccer()로 인스턴스를 생성합니다.\n        \n    *   슈퍼 클래스의 constructor에서 this.member에 설정한 값이 인스턴스 프로퍼티로 설정됩니다.\n        \n    *   &#95;&#95;proto&#95;&#95;에 서브 클래스의 prototype에 연결된 메서드가 첨부되었으며\n        \n    *   &#95;&#95;proto&#95;&#95;에 슈퍼 클래스의 prototype에 연결된 메서드가 첨부됩니다.\n        \n    *   메서드를 호출할 때 &#95;&#95;proto&#95;&#95;를 작성하지 않아도 되므로  \n        setGround()와 getMember()를 인스턴스에서 직접 호출할 수 있습니다.\n        \n\n4.  obj.getMember()를 호출하면 우선 obj.&#95;&#95;proto&#95;&#95;에서 메서드를 찾습니다. 존재하지 않으면 obj.&#95;&#95;proto&#95;&#95;.&#95;&#95;proto&#95;&#95;에서 찾습니다. 메서드가 존재하면 호출됩니다.  \n    이것이 자바스크립트의 상속 메커니즘 입니다.\n\n* * *\n\n<h2 id=\"super\">super 키워드</h2>\n\n서브 클래스와 슈퍼 클래스에 같은 이름의 메서드가 존재하면 슈퍼 클래스의 메서드는 호출되지 않습니다.  \n이때 super 키워드를 사용하여 슈퍼 클래스의 메서드(혹은 함수)를 호출할 수 있습니다.\n\n서브 클래스 constructor에 super()를 작성하면 슈퍼 클래스의 constructor가 호출됩니다.  \nsuper.name()과 같이 super 키워드에 이어서 호출하려는 메서드 이름을 작성합니다.\n\n### 메서드 오버라이딩\n\n서브 클래스와 슈퍼 클래스에 같은 이름의 메서드가 있을 때 서브 클래스의 메서드가 호출 되는 것을  \n메서드 오버라이딩(Overriding)이라고 합니다. 메서드 오버라이딩은 의도적인 접근 방식입니다.\n\n서브 클래스와 슈퍼 클래스의 같은 이름의 메서드가 같은 목적을 가진 것을 나타내면서  \n서브 클래스의 목적에 맞도록 보완할 때 사용합니다.(슈퍼 클래스의 메서드 기능을 사용하면서 서브 클래스에서 기능을 추가,변경할 때 사용합니다.)\n\n슈퍼 클래스와 서브 클래스의 메서드 기능/목적이 다른 경우에는 같은 이름을 사용하지 않습니다.\n\n```js super-1\nclass Sports {  \n setGround(ground){  \n this.ground = ground;  \n }  \n};  \n1. class Soccer extends Sports {  \n setGround(ground){  \n 2. super.setGround();  \n this.ground = ground;  \n }  \n};  \n3. let obj = new Soccer();  \nobj.setGround(\"상암구장\");  \nconsole.log(obj.ground);  \n// 상암구장  \n```\n\n~~Sports 클래스는 슈퍼 클래스 입니다. 상속을 해주지만 단독으로 인스턴스를 생성할 수도 있습니다.~~\n\n*   Class Sports{}에는 그라운드(setground)가 필요합니다.  \n    Sports의 종목이 여러개라면 종목마다 그라운드(setGround)형태도 달라져야 할 수 있습니다.  \n    그런 의미에서 setGround()메서드는 의미 없어 보일 수 있습니다.\n\n*   하지만 Sports 클래스를 상속받는 서브 클래스에서 setGround를 오버라이딩 하면 일관성 있게  \n    그라운드를 정의할 수 있습니다. 메서드 이름을 유지하면서 서브클래스 마다  \n    적합한 그라운드(setGround)를 설정해 주는 것입니다.  \n    이를 객체 지향에서 추상화(Abstraction)라고 합니다.\n\n1.  Soccer 클래스에서 Sports 클래스를 상속받습니다. Sports 클래스에 setGround()가 있으며  \n    Soccer 클래스에도 있으므로 메서드가 오버라이딩 됩니다.  \n    new Soccer()로 인스턴스를 생성한 후 setGround()를 호출하게 되면 서브클래스(Soccer)의  \n    메서드가 호출됩니다. 이때 super.setGround()는 슈퍼클래스(Sports)의 setGround()를 호출합니다.\n\n2.  super.setGround()를 호출하면서 파라미터 값은 정해주지 않았습니다.  \n    슈퍼클래스(Soccer)의 setGround()에서 this.ground에 undefined가 설정됩니다.  \n    super.setGround()를 실행한 후 돌아오면 바로 다음 줄의 this.ground에서 파라미터로 받은 값을 설정합니다.\n\n3.  new Soccer()로 인스턴스를 생성하고 setGround()를 호출하면 인스턴스의 ground 프로퍼티에 파라미터 값이 설정됩니다. ground가 인스턴스 프로퍼티이므로 obj.ground로 값을 출력할 수 있습니다.\n\n```js super-2\nclass Sports {  \n    constructor(member){  \n        this.member = member;  \n        console.log(this.member);  \n    }  \n};  \n2. class Soccer extends Sports {  \n 3. constructor(member){  \n        super(member);  \n        this.member = 456;  \n        console.log(this.member);  \n    }  \n};  \n1. let obj = new Soccer(123);  \n// 123  \n// 456  \n```\n\n1.  new Soccer(123)을 실행하면 Soccer 클래스의 constructor가 호출됩니다.\n\n2.  constructor 첫째 줄의 super(member)를 실행하면 슈퍼 클래스의 constructor를  \n    호출 하면서 파라미터로 받은 값을 넘겨줍니다. 슈퍼 클래스의 constructor를  \n    호출하려면 서브클래스 constructor의 첫째 줄에 super()를 작성해야 합니다.\n\n**super() 앞에 변수를 선언하거나 변수에 값을 할당하는 코드는 작성해도 되지만,**  \n**this 키워드는 super() 앞에 사용할 수 없습니다.**\n\n3.  super()로 인해 constructor가 호출되면 this로 인스턴스를 참조할 수 있습니다.  \n    따라서 파라미터로 받은 member 값을 인스턴스의 member 프로퍼티에 할당할 수 있습니다.\n\n* * *\n\n<h2 id=\"builtin\">빌트인 오브젝트 상속</h2>\n\nextends 키워드로 Array 오브젝트 등의 빌트인 오브젝트를 상속받을 수 있습니다.  \n상속을 받지 않고 서브 클래스에서 빌트인 오브젝트의 메서드를 호출해도 되지만  \n상속 받는 것과 차이가 있습니다. 서브 클래스에서 빌트인 오브젝트를 상속받으면  \n빌트인 오브젝트의 메서드를 마치 서브 클래스에서 선언한 것처럼 사용할 수 있게 됩니다.\n\n```js builtin\n2. class ExtendArray extends Array {  \n constructor(){  \n super();  \n }  \n getTotal(){  \n let total = 0;  \n for (var value of this){  \n total += value;  \n };  \n return total;  \n }  \n};  \n  \n1. let obj = new ExtendArray();  \n3. obj.push(10, 20);  \n  \n4. console.log(obj.getTotal());  \n// 30  \n```\n\n1.  클래스 ExtendArray 에 빌트인 오브젝트인 Array 오브젝트를 상속받았습니다.  \n    new 연산자로 인스턴스를 생성하면 인스턴스는 Array 오브젝트의 특징을 갖게됩니다.  \n    따라서 인스턴스에서 push()와 같은 Array 메서드를 직접 호출할 수 있습니다.  \n    “[].push()”형태가 아닌 “인스턴스.push()”형태로 호출할 수 있습니다.  \n    이 형태의 차이에 상속 받는 목적이 담겨있다고 할 수 있습니다.\n\n2.  new ExtendArray()를 실행하면 아래에 작성한 constructor가 호출됩니다.\n    \n    > constructor(){  \n    > super();  \n    > }\n    \n    super()가 슈퍼 클래스의 constructor를 호출하므로 Array 오브젝트 constructor가  \n    호출됩니다.\n    \n\n3.  obj 인스턴스에 push()메서드가 상속되어 있으므로 obj.push(10,20)형태로 호출할 수 있습니다.  \n    obj.push(10, 20) 과 [].push(10, 20)에서 obj 인스턴스가 Array 리터럴[]에 해당됩니다.  \n    따라서 obj 인스턴스에 10 과 20를 설정하는 것은 Array 인스턴스에 설정하는 것과 같습니다.  \n    이것이 빌트인 오브젝트를 상속받는 목적 중의 하나입니다.\n\n4.  obj.getTotal()을 호출하면 for-of 문으로 [10, 20]을 합산하여 반환합니다.  \n    ~~값을 합산해주는 빌트인 함수도 있지만 for(var value of this)문에서  \n    this를 다루기 위해 의도적으로 for-of 문을 사용했습니다.~~  \n    this가 obj 인스턴스를 참조합니다. obj 인스턴스는 [10, 20]값이 설정되어 있으며  \n    Array 오브젝트를 상속받은 상태 이므로 length 프로퍼티를 갖고있습니다.  \n    즉, 이터레이션을 수행할 수 있는 조건을 충족합니다.\n    \n    > for(var value of [10, 20]){  \n    > total += value;  \n    > } return total\n    \n\n위 헝태가 되어 엘리먼트(10, 20)를 하나씩 읽어가면서 for-of 문을 반복합니다.\n\n* * *\n\n<h2 id=\"Object_super\">Object에서 super 사용</h2>\n\n두 개의 Object 오브젝트가 연결된 구조에서 super.name() 형태로 슈퍼 오브젝트의  \n메서드를 호출할 수 있습니다.\n\n```js\nlet Sports = {  \n getTitle(){  \n console.log(\"Sports\");  \n }  \n};  \nlet Soccer = {  \n getTitle(){  \n super.getTitle();  \n console.log(\"Soccer\");  \n }  \n};  \n1. Object.setPrototypeOf(Soccer, Sports);  \n2. Soccer.getTitle();  \n//Sports  \n//Soccer  \n```\n\n1.  Object.setPrototypeOf()을 실행하면 Soccer.&#95;&#95;proto&#95;&#95;에  \n    Sports 오브젝트의 프로퍼티가 첨부됩니다.  \n    Object 오브젝트가 대상이므로 생성자 함수가 없지만,&#95;&#95;proto&#95;&#95;에 프로퍼티가 첨부되는 것이 상속 구조(형태)입니다.\n    \n2.  Soccer.getTitle();이 호출되면, 첫째 줄에서 super.getTitle()을 호출합니다.  \n    상속을 하면 &#95;&#95;proto&#95;&#95;로 계층을 만들고,&#95;&#95;proto&#95;&#95;에 상속받을 오브젝트의 프로퍼티를 첨부하므로, super는 한 단계 아래의 &#95;&#95;proto&#95;&#95;를 참조하는 것과 같습니다.\n    \n\n현재 Soccer.&#95;&#95;proto&#95;&#95;에 Sports 오브젝트의 getTitle()이 첨부되어 있습니다.  \n따라서 super.getTitle()을 호출하면, super가 Soccer.&#95;&#95;proto&#95;&#95;를 참조하므로  \nSports 오브젝트의 getTitle()이 호출됩니다.  \n\n**이와 같이 Object.setPrototypeOf()으로 &#95;&#95;proto&#95;&#95;구조를 만들고 상속받을 오브젝트의 프로퍼티를 첨부하면, super키워드로 상속 계층 구조에 있는 메서드를 호출할 수 있습니다.**\n\n* * *\n\n<h2 id=\"static\">static 키워드</h2>\n\n클래스에 static(정적) 메서드를 정의합니다.\n\n> static methodName() { … }\n\nprototype에 연결된 메서드는 인스턴스를 생성하여 호출 하지만,  \nstatic 메서드는 인스턴스를 생성하지않고 클래스에 직접 연결하여 호출합니다.\n\nstatic 메서드는 prototype에 연결되지 않으므로 인스턴스에서 호출할 수 없습니다.  \n클래스 이름을 지정하여 static 메서드를 호출해야 합니다.\n\n*   중요 포인트  \n    엔진이 class 키워드를 만나면 클래스 안에 static 메서드 작성 여부를 체크합니다.  \n    static 메서드가 존재한다면 이를 Function 오브젝트로 생성합니다.  \n    (메서드를 호출하기 위해서는 메서드가 Function 오브젝트여야 하고,  \n    이렇게 생성함으로써 클래스 아래의 static메서드를 호출할 수 있게 합니다.)\n\n```js 자바스크립트 Function 오브젝트 생성 형태\nfunction(){ // Function 오브젝트입니다.  \n function(){ // Function 오브젝트가 아닙니다.  \n }  \n}  \n```\n\nfunction 안에 function은 Function 오브젝트로 생성하지 않고,  \nfunction이 호출되어 안에 있는 function으로 들어갔을 때  \nFunction 오브젝트를 생성합니다.  \n따라서 function을 호출하지 않으면 안에 있는 function은  \n아무것도 아닙니다. 그저 작성돼있는 함수 입니다.  \n이 점이 static 키워드를 사용한 메서드와 차이점 입니다.\n\n```js\nclass Sports {  \n static getGround() {  \n return \"상암구장\";  \n }  \n};  \n1. console.log(Sports.getGround());  \n```\n\ngetGround(){} 앞에 static을 작성하여 static메서드로 선언했습니다.\n\n1.  Sports는 클래스 이름이고 getGround()는 static메서드 입니다.  \n    이와 같이 앞에 클래스 이름을 작성하고 이어서 static메서드를 작성하여 호출합니다.\n\n* * *\n\n<h2 id=\"Class_Hoisting\">Class 호이스팅</h2>\n\n클래스는 호이스팅(Hoisting)이 되지 않습니다.\n\n```js\n// Class  \nlet result = Member;  \nclass Member {  \n static getMember(){  \n return \"member\";  \n }  \n};  \nconsole.log(Member.getMember()); // member  \nconsole.log(result.getMember()); // TypeError  \n  \n// function과 비교  \nlet result2 = Member2;  \nfunction Member2() {  \n return \"member2\";  \n};  \nconsole.log(Member2());// member2  \nconsole.log(result2());// member2  \n```\n\n호이스팅 된다면 Member 클래스가 result 변수에 할당됩니다.  \n호이스팅 되지않으면 Member를 인식하지 못합니다. Error\n\n*   클래스는 호이스팅 되지않아 result에 할당할 Member를 인식하지 못합니다.  \n    result에 Member 값을 넣으려면 클래스 문이 완전히 끝난 뒤에 작성해야합니다.\n    \n*   function은 호이스팅 되므로 result2에 Member2를 인식하여 할당할 수 있습니다.\n    \n\n* * *\n\n<h2 id=\"computed_name\">computed name</h2>\n\n클래스의 메서드 이름을 조합(computed name)하여 작성할 수 있습니다.\n\n```js computed name\nlet type = \"Type\";  \nclass Sports {  \n static [\"get\" + type](kind){  \n return kind ? \"스포츠\" : \"음악\";  \n }  \n}  \n1. console.log(Sports[\"get\" + type](1)); // 스포츠  \nconsole.log(Sports.getType(1)); // 스포츠  \n```\n\n변수 type 에 문자열 값 “Type”을 할당해 줬습니다.  \nstatic 메서드 []안에 문자열 “get” 과 클래스 밖에 작성된 type 변수 값을  \n작성해줬습니다. static메서드의 이름이 getType이 됩니다.  \n이와 같이 static 메서드 []안에 조합할 이름을 작성합니다.\n\n1.  문자열 “get”과 변수인 type을 조합하여 호출합니다.  \n    파라미터 값이 1 (true)이므로 호출된 getType()에서 “스포츠”를 반환합니다.  \n    물론 console.log(Sports.getType(1)); 형태로 호출할 수 도 있습니다.\n\n* * *\n\n<h2 id=\"this\">this</h2>\n\nstatic 메서드에서 this는 클래스 오브젝트를 참조합니다.  \nconstructor 안에서 this.constructor.name()형태로 static 메서드를 호출할 수 있습니다.\n\n```js this 예제\nclass Sports {  \n static setGround(ground){  \n this.ground = ground;  \n }  \n static getGround(){  \n return this.ground;  \n }  \n};  \nSports.setGround(\"상암구장\");  \nconsole.log(Sports.getGround());  \n// 상암구장  \n```\n\nSports.setGround(“상암구장”)를 실행하면 static메서드인 setGround()가 호출됩니다.  \nthis.ground에서 this가 Sports 클래스를 참조하므로 Sports 클래스에  \n{ground: “상암구장”} 형태로 설정됩니다.\n\nSports.getGround()를 실행하면 getGround() 정적 메서드가 호출됩니다.  \nthis.Ground에서 this가 Sports 클래스를 참조하므로 setGround()에서  \nSports 클래스에 설정한 ground 프로퍼티 값을 구할 수 있습니다. //상암구장\n\n```js this 호출 예제\nclass Sports{  \n constructor(){  \n 1. console.log(Sports.getGround());  \n 2. console.log(this.constructor.getGround());  \n }  \n static getGround(){  \n return \"상암구장\";  \n }  \n};  \nlet obj = new Sports();  \n```\n\nnew Sports()를 실행하면 constructor가 호출됩니다.  \nconstructor 블록{}안에서 static메서드인 getGround를 호출하며,  \nthis.constructor 형태도 사용하고 있습니다.\n\n1.  Sports 클래스에 static 메서드로 getGround()를 작성했으므로  \n    Sports.getGround() 형태로 호출할 수 있습니다.  \n    constructor 블록{} 아래에 getGround()가 작성되어 있습니다만  \n    이미 Function 오브젝트로 생성된 상태이므로 호출이 됩니다.\n\n2.  constructor가 Sports 클래스를 참조하며 인스턴스의 &#95;&#95;proto&#95;&#95;에  \n    constructor가 첨부되어 있으므로 this.constructor.getGround() 형태로  \n    static메서드를 호출할 수 있습니다. 구조는 다음 사진과 같습니다.\n    <img src=\"/images/ClassThisInstance.JPG\">\n\n*   this.getGround()형태로는 호출할 수 없습니다. (//undefined)  \n    this가 new Sport()로 생성한 인스턴스를 참조하고,  \n    getGround는 static메서드 이므로 인스턴스에 존재하지 않기 때문입니다.\n\n* * *\n\n<h2 id=\"generator\">제너레이터</h2>\n\n클래스 안에 제너레이터 함수를 작성할 수 있습니다.  \n클래스 안에 작성한 제너레이터 함수는 prototype에 연결됩니다.  \n따라서 static 메서드로 호출할 수 없고 인스턴스를 생성하여 호출해야 합니다.\n\n```js\nclass Member{  \n *gen() {  \n yield 10;  \n yield 20;  \n }  \n};  \nlet obj = new Member();  \nlet genObj = obj.gen();  \n  \nconsole.log(genObj.next());  \nconsole.log(genObj.next());  \n// Object {value: 10, done: false}  \n// Object {value: 20, done: false}\n```  \n\nnew Member()로 클래스 인스턴스를 생성 합니다. 변수 obj에 할당됩니다.  \ngenObj 변수에 obj.gen 메서드를 할당합니다.  \ngenObj.next()로 호출할 수 있게됩니다.\n\n* * *\n\n<h2 id=\"new_target\">new.target</h2>\n\nnew.target은 메타(meta) 프로퍼티로 생성자 함수와 클래스에서  \nconstructor를 참조합니다. new 연산자로 인스턴스를 생성하지 않으면  \nnew.target 값은 undefined 입니다.\n\n```js\nlet sports = function(){  \n console.log(new.target);  \n}  \nsports();  \nnew sports();  \n// undefined  \n/* function() {  \n console.log(new.target);  \n}  \n*/  \n```\n\nsports(); 와 같이 new 연산자를 사용하지 않고 호출하면 new.target값은 undefined 입니다.\n\nnew sports();로 호출하면 new.target은 constructor를 참조합니다.  \nsports 함수에 constructor를 작성하지 않았으므로 디폴트 constructor가 호출됩니다.  \n디폴트 constructor = (function: Object() {native code})  \nconstructor가 sports 전체를 참조하므로 sports 함수의 코드가 출력됩니다.\n\n### name 프로퍼티\n\nES6는 클래스, 함수 오브젝트에 name 프로퍼티가 존재하며 이름이 설정됩니다.\n\n```js\nclass Sports {  \n constructor(){  \n console.log(\"Sports:\", new.target.name);  \n }  \n};  \nclass Soccer extends Sports {  \n constructor(){  \n super();  \n console.log(\"Soccer:\", new.target.name);  \n }  \n};  \nlet sportsObj = new Sports();  \nlet soccerObj = new Soccer();  \n// Sports: Sports  \n// Sports: Soccer  \n// Soccer: Soccer  \n```\n\n*   new Sports()를 호출하면 Sports 클래스이므로 클래스 name 프로퍼티에 “Sports”가  \n    설정되어 있습니다. constructor에서 new.target은 constructor를 참조하므로  \n    Sports 클래스의 name 프로퍼티 값 “Sports”가 출력됩니다.\n    \n*   new Soccer()를 호출하면 super()로 인해 Sports의 constructor가 호출됩니다.  \n    Sports의 constructor에서 new.target은 super()로 호출한 Soccer의  \n    constructor를 참조합니다. 따라서 new.target.name 값으로 Sports가 아닌 Soccer가 출력됩니다.\n    \n\n* * *\n\n<h2 id=\"Image_Object\">Image 오브젝트 상속</h2>\n\n*   DOM(Document Object Model)에서 제공하는 Image 인터페이스, Audio 인터페이스 등을 상속받을 수 있습니다.  \n    빌트인 Array 오브젝트를 상속받으면 Array 오브젝트 특징을 갖듯이  \n    상속받은 인터페이스 특징을 갖습니다.\n    \n*   DOM의 Image 인터페이스는 웹 페이지에 png 파일과 같은 이미지 파일을 표현하기 위한 속성을 제공합니다.  \n    인터페이스는 객체지향 용어로 이 자체를 그대로 사용할 수 없고 오브젝트로 변환하여 사용해야 합니다.  \n    DOM은 오브젝트를 제공하지 않고 인터페이스를 제공하는데,이는 자바스크립트뿐만 아니라 Java등의 다른 언어에서도 사용하기 때문입니다. 각 언어에서 DOM인터페이스를 언어에 맞게 변환하여 사용합니다.\n    \n\n인터페이스를 오브젝트로 변환하려면 extends 키워드를 사용합니다.\n\n```js extends-image\n1. class ExtendsImage extends Image{  \n constructor() {  \n super();  \n }  \n 2. setProperty(image){  \n this.src = image.src;  \n this.alt = image.alt;  \n this.title = image.title;  \n }  \n};  \nlet imageObj = new ExtendsImage();  \n  \nlet properties = {  \n src: \"file/rainbow.png\",  \n alt: \"나무와 집이 있고 그 위에 무지개가 있는 모습\",  \n title: \"무지개\"  \n};  \n  \nimageObj.setProperty(properties);  \n3. document.querySelector(\"body\").appendChild(imageObj);  \n```\n\n1.  Image 오브젝트를 extends 키워드로 상속받습니다.  \n    ExtendsImage 클래스는 Image 특성을 갖게됩니다.  \n    즉, < img > 엘리먼트의 속성을 직접 사용할 수 있습니다.  \n    또한 this로 엘리먼트 속성에 접근할 수 있습니다.\n    \n2.  파라미터로 받은 < img > 속성 값을 this가 참조하는 imageObj 인스턴스에 설정합니다.\n    \n3.  < body> 엘리먼트에 자식 요소로 imageObj를 첨부합니다.  \n    body 엘리먼트에 imageObj 안에 있는 img 엘리먼트 속성도 첨부 횝니다.\n    \n\n웹페이지에 이미지가 표시되고 그 속성은 다음과 같습니다.\n\n> < img src = “file/rainbow.png”  \n> alt= “나무와 집이 있고 그 위에 무지개가 있는 모습”  \n> title= “무지개” >\n","slug":"Class 오브젝트 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrrr0005qgvqgkt43war","content":"<p>Class(클래스)를 완전하게 이해하려면 객체지항 프로그래밍(OOP:Object Oriented Programming)에 대한 이해가 필요합니다.</p>\n<p>OOP만 다루는 책이 있을 정도로 범위가 넓고 깊으므로<br>OOP는 나중에 자세히 다루고 ES6기준으로 살펴봅니다.</p>\n<ul>\n<li>Class 오브젝트<ul>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#Class_선언문\">Class 선언문</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#Class_표현식\">Class 표현식</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#클래스_특징\">Class 특징</a><ul>\n<li>strict 모드에서 실행</li>\n<li>클래스에 메서드 작성 방법</li>\n<li>prototype에 프로퍼티 연결</li>\n<li>prototype에 프로퍼티 추가</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#constructor\">constructor</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#constructor_return\">constructor 반환 값 변경</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#getter_and_setter\">getter, setter</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#상속\">상속</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#extends\">extends 키워드</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#super\">super 키워드</a><ul>\n<li>메서드 오버라이딩</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#builtin\">빌트인 오브젝트 상속</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#Object_super\">Object에서 super 사용</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#static\">static 키워드</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#Class_Hoisting\">Class 호이스팅</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#computed_name\">computed name</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#this\">this</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#generator\">제너레이터</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#new_target\">new.target</a><ul>\n<li>name 프로퍼티</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#Image_Object\">오브젝트 상속</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"Class_선언문\">Class 선언문</h2>\n\n<blockquote>\n<p>Class name {}<br>Class name extends super_name {}</p>\n</blockquote>\n<p>엔진이 function 키워드를 만나면 Function 오브젝트를 생성하듯이<br>class 키워드를 만나면 Class 오브젝트를 생성합니다.<br>Class 오브젝트는 Function 오브젝트, String 오브젝트와 같이 하나의 오트젝트 타입입니다.</p>\n<ul>\n<li>name에 클래스 이름을 작성합니다.<br>name 다음의 extends는 키워드로 super_name(슈퍼 클래스)를 상속받을 때 사용합니다. 이 형태를 클래스 선언문 이라고 합니다.</li>\n</ul>\n<p>class는 클래스를 선언하는 키워드이고<br>엔진이 class 키워드로 생성한 오브젝트는 Class 오브젝트 입니다.<br>문맥에 따라 Class 오브젝트를 class라고 말하기도 합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;  </span><br><span class=\"line\"> getName() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"이름\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Member();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(obj.getName());  </span><br><span class=\"line\"><span class=\"comment\">// 이름</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>class 키워드를 작성하고 이어서 클래스 이름을 작성합니다. 그리고 블록{}을 작성하고 블록에 클래스 코드를 작성합니다.<br>엔진이 class 키워드를 만나면 클래스(Class) 오브젝트를 생성합니다.</li>\n</ul>\n<ol>\n<li><p>new 연산자로 Member()를 호출하면 인스턴스를 생성하여 반환합니다.</p>\n<p><mark>function name(){}는 new 연산자로 인스턴스를 생성하지 않고<br>name()형태로 호출할 수 있지만,<br>클래스는 new 연산자로 인스턴스 생성없이 name()형태로 호출할 수 없으며<br>TypeError가 발생합니다.</mark></p>\n</li>\n<li><p>obj는 인스턴스이고 getName()은 class Member{}안에 작성한 메서드 입니다.<br>이와 같이 new 연산자로 생성한 인스턴스를 사용하여 클래스에 작성한 메서드를 호출할 수 있습니다. 실행 결과 “이름”이 출력됩니다.</p>\n</li>\n</ol>\n<ul>\n<li><p>참고</p>\n<blockquote>\n<p>new 연산자로 인스턴스를 생성하는 함수는 함수 이름의 첫 문자를 대문자로 작성합니다. 클래스 또한 new 연산자로 인스턴스를 생성하므로 클래스 이름의 첫 문자를 대문자로 사용합니다. 이는 스펙에 정의된 것은 아니며 자바스크립트 개발자들 사이의 관례입니다. 개발자가 코드의 대문자를 보고 인스턴스를 생성한다는 것을 알 수 있으므로 지키는 것이 좋습니다. 빌트인 Number 오브젝트, String 오브젝트도 이와 같은 맥락입니다.</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>같은 클래스를 두 번 선언하려고 시도할 때<br>클래스 선언문으로 같은 클래스를 두 번 선언하면 오류가 발생합니다.</p>\n<blockquote>\n<p>class Foo {};<br>class Foo {}; // Uncaught SyntaxError: Identifier ‘Foo’ has already been declared</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>이전에 표현식으로 정의한 경우에도 오류가 발생합니다.</p>\n<blockquote>\n<p>var Foo = class {};<br>class Foo {}; // Uncaught TypeError: Identifier ‘Foo’ has already been declared</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h2 id=\"Class_표현식\">Class 표현식</h2>\n\n<p>클래스 표현식으로 클래스를 선언합니다.</p>\n<blockquote>\n<p>let name = class {}<br>let name = class inner_name {}<br>let name = class extends super_name {}<br>let name = class inner_name extends super_name {}</p>\n</blockquote>\n<p>할당 연산자 (=) 왼쪽에 클래스 이름을 작성하고 오른쪽에 class 키워드를 작성하고 블록{}안에 클래스 코드를 작성합니다. 이를 클래스 표현식이라고 합니다.</p>\n<p>Class 표현식은 이름을 가질 수도 있고, 갖지 않을 수도 있습니다. 이름을 가진 class 표현식의 이름은 클래스의 body에 대해 local scope에 한해 유효합니다.</p>\n<p>4번째 구문 class 와 extends 키워드 사이의 inner_name은 클래스 안에서 자신을 호출할 때 사용합니다. <del>function 키워드 함수에서도 inner_name을 작성할 수 있지만 사용하지 않듯 클래스도 사용하지 않습니다.</del></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Member = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;  </span><br><span class=\"line\"> getName() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"이름\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Member();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getName());</span><br></pre></td></tr></table></figure>\n\n<p>엔진이 클래스 키워드를 만나면 클래스 오브젝트를 생성하여 Member 변수에 할당합니다.</p>\n<hr>\n<h2 id=\"클래스_특징\">클래스 특징</h2>\n\n<p>Class는 사실 함수입니다. 함수를 함수 표현식과 함수 선언으로 정의할 수 있듯이 class 문법도 class 표현식과 class 선언 두 가지 방법을 제공합니다.</p>\n<ol>\n<li><p>strict 모드에서 실행</p>\n<p><strong>“use static”을 선언하지 않아도 클래스의 코드는 static 모드에서 실행됩니다.</strong></p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>클래스에 메서드 작성 방법</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> setName(name) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"number\">2.</span> getName() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">4.</span> Member.prototype.getTitle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> Member);  </span><br><span class=\"line\"><span class=\"comment\">// function</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>setName(){ } 과 같이 function 키워드와 콜론(:)을 작성하지 않고 메서드 이름만 작성합니다.</p>\n</li>\n<li><p>setName()과 getName() 메서드 사이에 콤마를 작성하지 않습니다.</p>\n</li>\n<li><p>클래스의 typeof는 function 입니다. 이는 class가 function 구조라는 것을 의미합니다.</p>\n</li>\n<li><p>function name(){ }은 글로벌 오브젝트(window Object)에 설정되지만<br>class name(){ }은 글로벌 오브젝트에 설정되지 않습니다.<br>따라서 window.Member로 클래스에 접근하면 undefined가 반환됩니다.<br><code>Class 오브젝트의 프로퍼티는 for()문 등으로 열거할 수 없습니다.</code></p>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li>prototype에 프로퍼티 연결</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span>&#123;  </span><br><span class=\"line\"> setName(name) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><del>prototype에 메서드를 연결하여 prototype.setName과 같이 작성하지 않고</del><br>setName을 작성합니다. 자바스크립트는 기본적으로 prototype에 메서드를 연결하는 구조이므로 <strong>클래스 안에 작성된 메서드를 엔진이 자동으로 prototype에 연결합니다.</strong><br>즉. 엔진이 Member.prototype.setName 형태로 연결해줍니다.</p>\n<p>이는 중요한 의미를 갖습니다. 자바스크립트의 기본 아키텍처(구성 방식 혹은 컴퓨터 소프트웨어의 호환성)를 유지하면서 객체지향 언어의 특징을 반영하려는 접근입니다.</p>\n<ol start=\"4\">\n<li>prototype에 프로퍼티 추가</li>\n</ol>\n<blockquote>\n<p>Member.prototype.getTitle = function(  ){ };  </p>\n</blockquote>\n<p><strong>클래스 밖에서 Member 클래스에 메서드를 추가하려면</strong> 위와 같이<br>Member.prototype에 메서드를 연결하여 작성합니다.<br>Member 클래스를 선언할 때는 클래스 블록{}안에 작성하겠지만,<br>인스턴스를 생성한 후 상황에 따라 추가할 때 이 형태로 작성합니다.</p>\n<ul>\n<li>참고<br>이렇게 메서드를 추가하면 이미 생성된 인스턴스에서 추가한 메서드를 공유할 수 있도록 엔진이 처리하게 되므로 부하 혹은 자원낭비가 됩니다.<br>좋은 사용 예시로는 사용자의 행동이나 서버 데이터에 따라 메서드를 따로 추가할 수 있는 점이 있습니다.(역동성이 높다.)</li>\n</ul>\n<hr>\n<h2 id=\"constructor\">constructor</h2>\n\n<ul>\n<li><p>constructor 메소드는 class 인스턴스를 생성하고 생성된 인스턴스를 초기화하는 역활을 합니다.</p>\n</li>\n<li><p>“constructor” 라는 이름을 가진 메소드는 클래스 안에 한 개만 존재할 수 있습니다. 만약 클래스에 여러 개의 constructor 메소드가 존재하면 SyntaxError 가 발생할 것입니다.</p>\n</li>\n<li><p>constructor는 부모 클래스의 constructor 를 호출하기 위해 super 키워드를 사용할 수 있습니다.</p>\n</li>\n<li><p>참고<br>클래스에 constructor를 작성하지 않으면 prototype의 constructor가 호출됩니다.<br>이를 디폴트 constructor라고 하고 constructor가 없으면 인스턴스를 생성할 수 없습니다.<br>ES5 에서 클래스 오브젝트를 실행하면 엔진이 디폴트 constructor를 호출해서 이를 활용할 수 없었습니다.<br>ES6 에서는 개발자가 constructor를 정의할 수 있어서 Class 오브젝트 뿐 아니라<br>Proxy 오브젝트, Reflect 오브젝트에서 활용할 수 있습니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>(name)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> getName() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> memberObj = <span class=\"keyword\">new</span> Member(<span class=\"string\">\"스포츠\"</span>);  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(memberObj.getName());  </span><br><span class=\"line\"><span class=\"comment\">// 스포츠</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>클래스 안에 constructor를 작성했으며 constructor 안에 생성한 인스턴스에 초기값을 설정하는 코드를 작성했습니다.<br>constructor 안의 this는 생성하는 인스턴스를 참조합니다.</p>\n</li>\n<li><p>new Member(“스포츠”)를 실행하면 Member 클래스에 작성한 constructor가 자동으로 호출되며 파라미터 값으로 “스포츠”를 넘겨 줍니다.</p>\n<ul>\n<li>new 연산자는 constructor를 호출하면서 파라미터를 넘겨주는 역활</li>\n<li>호출된 constructor가 인스턴스를 생성하여 반환하면 new 연산자가 받아 new를 실행한 곳으로 반환합니다.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"클래스-와-인스턴스-생성-과정-이해를-위한-개념적인-순서\"><a href=\"#클래스-와-인스턴스-생성-과정-이해를-위한-개념적인-순서\" class=\"headerlink\" title=\"클래스 와 인스턴스 생성 과정 이해를 위한 개념적인 순서\"></a><mark>클래스 와 인스턴스 생성 과정 이해를 위한 개념적인 순서</mark></h2><pre><code>1. new Member(&quot;스포츠&quot;)를 실행합니다.\n\n2. new 연산자가 constructor를 호출하면서 파라미터 값을 넘겨줍니다.\n\n3. constructor의 블록 코드를 실행하기 전에 빈 Object 오브젝트를생성합니다.\n\n4. 이 것이 인스턴스입니다. 인스턴스가 생성되면 빈 오브젝트를 채웁니다.\n\n5. 인스턴스 구성에 필요한 프로퍼티를 Object 오브젝트에 설정합니다.\n\n6. constructor 블록에 있는 코드를 실행합니다.\n\n7. 인스턴스를 먼저 생성하므로 constructor에서 this로 인스턴스를 참조할수    있습니다.\n\n8. 생성된 인스턴스를 반환합니다.</code></pre><ol start=\"3\">\n<li>console.log(memberObj.getName());를 호출하면 다음 코드가 실행됩니다.</li>\n</ol>\n<blockquote>\n<p>getName() {<br> return this.name;<br>}</p>\n</blockquote>\n<p>constructor에서 this에 “스포츠”를 설정했으므로 “스포츠”가 반환됩니다.</p>\n<p>아래는 생성된 memberObj 인스턴스 구조입니다.</p>\n<img src=\"/images/constructorInstance.JPG\">\n\n<p>constructor에서 파라미터로 받은 “스포츠”를 this.name에 할당했으며,<br>이때 this가 생성하는 인스턴스를 참조하므로 인스턴스 프로퍼티로 설정됩니다.</p>\n<ul>\n<li><p>&#95;&#95;proto&#95;&#95;는 인스턴스를 생성하면 엔진이 자동으로 첨부합니다.</p>\n</li>\n<li><p>&#95;&#95;proto&#95;&#95;에 Member.prototype에 연결된 프로퍼티를 첨부하므로 getName도 첨부됩니다.</p>\n</li>\n<li><p>&#95;&#95;proto&#95;&#95;에 Object 오브젝트의 prototype에 연결된 프로퍼티가 첨부됩니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"constructor\">constructor</h2>\n\n<p>constructor는 일반적으로 return 문을 작성하지 않으며, 생성한 인스턴스를 반환합니다.<br>return을 사용하면 인스턴스 이외의 값을 반환할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"number\">1</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> getName()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"이름\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> memberObj = <span class=\"keyword\">new</span> Member();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(memberObj.getName());</span><br></pre></td></tr></table></figure>\n\n<p>constructor(){ }안에 return 1;을 작성하였습니다.<br><del>일반적으로 숫자 값을 반환하지 않습니다, 엔진 처리 방법 예시를 위해 작성되었습니다.</del><br><mark>constructor에서 Number 또는 String 값을 반환하면 이를 무시하고 생성한 인스턴스를 반환합니다.</mark></p>\n<p>console.log(memberObj.getName();)을 호출하면 constructor에서 1을 반환하여<br>memberObj에 1이 설정됩니다. 이후에 getName()을 호출하면 인스턴스 1에 getName()이 존재하지 않으므로 에러가 발생합니다. 하지만 Member 인스턴스를 반환하므로 getName()이 호출됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> &#123;<span class=\"attr\">name</span>: <span class=\"string\">\"홍길동\"</span>&#125;;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> getName()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"이름\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> memberObj = <span class=\"keyword\">new</span> Member();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(memberObj.name);  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(memberObj.getName);  </span><br><span class=\"line\"><span class=\"comment\">// 홍길동  </span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>constructor에서 Object오브젝트를 return하면 이를 반환합니다.<br>즉, {name: “홍길동”}이 반환됩니다.</p>\n<ol>\n<li><p>memberObj에 반환된 {name: “홍길동”}이 설정되어 있으므로 memberObj.name 값이 홍길동 으로 출력됩니다.</p>\n</li>\n<li><p>클래스에 getName 메서드를 작성했지만, 인스턴스를 반환하지 않고 {name: “홍길동”}을 반환하므로<br>MemberObj에 getName이 존재하지 않습니다. undefined가 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"getter_and_setter\">getter, setter</h2>\n\n<p>클래스에도 getter와 setter를 선언할 수 있습니다.<br>메서드 이름 앞에 “get”을 작성하면 getter, “set”을 작성하면 setter가 됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>getter</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">get</span> getName() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"이름\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> memberObj = <span class=\"keyword\">new</span> Member();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(memberObj.getName);  </span><br><span class=\"line\"><span class=\"comment\">// 이름</span></span><br></pre></td></tr></table></figure>\n\n<p>get getName()과 같이 메서드 이름 앞에 get을 작성하여 getter로 선언합니다.</p>\n<p>getName이 getter이므로 메서드로 호출됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>setter</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">set</span> setName(name) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">get</span> getName() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> memberObj = <span class=\"keyword\">new</span> Member();  </span><br><span class=\"line\">memberObj.setName = <span class=\"string\">\"이름\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(memberObj.getName);  </span><br><span class=\"line\"><span class=\"comment\">// 이름</span></span><br></pre></td></tr></table></figure>\n\n<p>memberObj.setName = “이름”과 같이 setter로 선언된 메서드 이름에 값을 할당하면<br>setName이 메서드로 호출됩니다. 이때 할당하는 값인 “이름”을 파라미터 값으로 넘겨줍니다.</p>\n<hr>\n<h2 id=\"상속\">상속</h2>\n\n<p>객체지향 프로그래밍에서 상속은 주요한 기능 중 하나입니다.<br>클래스를 상속받으면 상속받은 클래스의 메서드와 프로퍼티를 사용할 수 있습니다.</p>\n<ul>\n<li>참고<br>상속해 주는 클래스를 일반적으로 부모 클래스라고 부릅니다만<br>앞으로는 “슈퍼 클래스”라고 표기해줍시다.<br>슈퍼 클래스라고 표기하는 이유는 ES6에서 super키워드가 있으며<br>슈퍼 클래스를 지칭하므로 직관적이기 때문입니다.<br>상속받는 클래스도 일반적으로 자식 클래스라고 부릅니다만,<br>슈퍼 클래스와 운을 맞추기 위해 “서브 클레스”로 표기해줍시다.</li>\n</ul>\n<p><mark>자바스크립트 (객채지향 프로그래밍)의 상속 형태는 상속이 아니다?</mark></p>\n<p>일반적으로 상속이라고 하면 부모의 재산을 자식에게 물려주면<br>자식이 부모의 능력을 고스란히 물려받습니다.<br>자바스크립트에서는 객체도 생성자도 모두 프로토타입에 접근할 수 있고<br>심지어 변경까지할 수 있습니다.<br>이는 상속받을 것들을 자기 마음대로 선택,변경할 수 있게 되고<br>다른 언어의 상속과는 다른 형태를 갖습니다.<br>상속이라고 부르지만, 프로토타입의 (자원)공유로 이해하는 것이 적절해 보입니다.</p>\n<p><strong>ES5에서의 상속 구현 형태</strong></p>\n<figure class=\"highlight js\"><figcaption><span>ES5 상속 형태</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sports</span>(<span class=\"params\">member</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"keyword\">this</span>.member = member;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> Sports.prototype.setItem = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.item = item;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Soccer</span>(<span class=\"params\">member</span>)</span>&#123;  </span><br><span class=\"line\"> Sports.call(<span class=\"keyword\">this</span>, member);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">5.</span> Soccer.prototype = <span class=\"built_in\">Object</span>.create(Sports.prototype, &#123;  </span><br><span class=\"line\"> setGround: &#123;  </span><br><span class=\"line\"> value: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ground</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.ground = ground;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"number\">6.</span> Soccer.prototype.constructor = Soccer;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">7.</span> <span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> Soccer(<span class=\"number\">11</span>);  </span><br><span class=\"line\"><span class=\"number\">8.</span> obj.setItem(<span class=\"string\">\"축구\"</span>);  </span><br><span class=\"line\">obj.setGround(<span class=\"string\">\"상암\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">9.</span> <span class=\"built_in\">console</span>.log(obj.member); <span class=\"comment\">// 11  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.item); <span class=\"comment\">// 축구  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.ground); <span class=\"comment\">// 상암</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Sports 첫 문자를 대문자로 작성한 것은 new 연산자로 인스턴스를 생성하려는 의도입니다. new Sports()를 실행하면 Sports()가 호출되고, 다시 디폴트 constructor를 호출합니다. 그래서 Sports()를 생성자(constructor)함수라고 부릅니다.</p>\n</li>\n<li><p>this.member에서 this가 생성하는 인스턴스를 참조하므로 member는 인스턴스 프로퍼티가 됩니다. Sports(생성자 함수)함수에서 this.member = member 형태가 인스턴스에 초기값으로 설정됩니다. <del>이렇게 설정된 값은 생성된 모든 인스턴스에서 공유하지 않고 인스턴스마다 값을 각각 유지합니다. 이것이 인스턴스를 만드는 목적 중의 하나입니다.</del></p>\n</li>\n<li><p>생성자 함수가 있으면 Sports.prototype.setItem과 같이 prototype에 메서드를 연결한 코드가 작성되어 있습니다. 이를 작성하지 않으면 생성자 함수가 아닌 일반 함수 입니다. <strong>이 형태가 ES5에서 인스턴스를 구현하는 기본 형태입니다.</strong></p>\n</li>\n<li><p>Soccer()가 호출되면 Sports()를 호출합니다. Soccer의 첫 문자가 대문자이므로 인스턴스를 사용한다는 것을 알 수 있습니다. 그런데 new Sports()가 아닌 Sports.call()형태로 함수를 호출한 것은, 바로 다음 코드에서 Sports.prototype을 사용하여 인스턴스를 생성하므로 인스턴스에 초기값만 성정하면 되기 때문입니다.</p>\n</li>\n<li><p>Object.create()의 두 번째 파라미터 setGround를 첫 번째 파라미터인 Soccer.prototype에 첨부합니다. 그리고 Sports.prototype에 연결된 메서드를 Soccer.prototype.&#95;&#95;proto&#95;&#95;에 첨부합니다.<br>이렇게 연결된 후에 new Soccer()로 인스턴스를 생성하면 Soccer.prototype과 Sports.prototype에 연결된 메서드를 인스턴스 메서드로 호출할 수 있습니다.<strong>ES5에서는 이와 같은 방법으로 상속을 구현합니다.</strong></p>\n</li>\n<li><p>Soccer.prototype에 constructor가 연결되어 있는데, 앞 코드에서<br>Soccer.prototype에 프로퍼티를 연결하므로 constructor가 지워집니다.<br>Soccer를 설정하지 않아도 인스턴스가 생성되지만, constructor에서 Soccer전체를 참조하는 것이 정상입니다.</p>\n</li>\n<li><p>new 연산자로 Soccer() 생성자 함수를 호출하여 인스턴스를 생성합니다.<br>Sports.prototype에 연결된 메서드는 인스턴스에 포함되지만, Sports() 생성자 함수는 포함되지 않으므로 Sports.call(this.member); 코드를 수행하여 인스턴스에 초기값을 설정합니다. this는 생성한 인스턴스를 참조하게 됩니다.</p>\n</li>\n<li><p>setItem()은 상속받은 Sports.prototype에 연결된 메서드 입니다.<br>상속을 받으면 인스턴스에서 직접 상속받은 메서드를 호출할 수 있습니다.</p>\n</li>\n<li><p>생성자 함수를 모두 호출하여 인스턴스에 초기값을 설정했으므로 인스턴스 프로퍼티로 프로퍼티 값을 구할 수 있습니다.<br>ES5에서는 이와 같이 prototype에 연결해야 하며 직관적이지 않은 점도 있습니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"extends\">extends 키워드</h2>\n\n<p>ES6에서는 extends 키워드로 상속을 구현합니다.</p>\n<blockquote>\n<p>class subClass extends superClass { }</p>\n</blockquote>\n<ul>\n<li><p>subClass<br>상속 받는 자식 클래스(서브 클래스).</p>\n</li>\n<li><p>superClass<br>상속 해주는 부모 클래스(슈퍼 클래스).</p>\n</li>\n<li><p>new subClass()로 인스턴스를 생성하면 인스턴스에서 subClass 클래스와 super 클래스의 메서드를 호출할 수 있습니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>extends ES6</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>(member)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.member = member;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> getMember()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.member;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Soccer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> setGround(ground)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.ground = ground;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Soccer(<span class=\"number\">11</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(obj.getMember()); <span class=\"comment\">// 11</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Sports 클래스를 상속받으므로 Sports 클래스는 슈퍼 클래스입니다.<br>new Soccer()로 인스턴스를 생성하면 constructor가 호출되며,this가 생성하는 인스턴스를 참조하므로 파라미터로 받은 값을 인스턴스의 member 프로퍼티에 설정할 수 있습니다.</p>\n</li>\n<li><p>extends 키워드 기준으로 왼쪽의 Soccer 클래스가 서브클래스<br>오른쪽 Sports 클래스가 슈퍼클래스입니다. 즉, Soccer 클래스에서 Sports 클래스를 상속받습니다. this.ground에서 this는 생성한 인스턴스를 참조합니다.</p>\n<ul>\n<li>이 시점의 Soccer 클래스 구조입니다.    <img scr=\"/images/extendsSoccer.JPG\">\n</li>\n</ul>\n<ol>\n<li>Soccer.prototype에 setGround가 연결되어 있으며</li>\n<li>Soccer.prototype.&#95;&#95;proto&#95;&#95;에 Sports.prototype에 연결되어 있는 getMember가 첨부되어 있습니다.</li>\n<li>Soccer.&#95;&#95;proto&#95;&#95;에 Sports.prototype에 연결된 프로퍼티도 첨부되어 있습니다.</li>\n</ol>\n<ul>\n<li>이와 같이 extends 키워드는 서브클래스의 prototype에 &#95;&#95;proto&#95;&#95;를 만들고 여기에 슈퍼클래스의 prototype에 연결된 프로퍼티를 연결합니다.<br><del>슈퍼클래스의 prototype에 연결된 메서드를 복사하는 것이 아니라 공유합니다.</del><br>new Soccer()로 인스턴스를 생성할 때 Soccer.prototype에 연결된 프로퍼티를 사용하므로 서브클래스와 슈퍼클래스의 메서드가 인스턴스에 포함됩니다.</li>\n</ul>\n</li>\n<li><p>new Soccer(11)을 실행하면 다음의 순서와 방법으로 실행합니다.</p>\n<ol>\n<li>Soccer 클래스의 constructor가 호출됩니다.</li>\n<li>Soccer 클래스에는 constructor를 작성하지 않았습니다.</li>\n<li>슈퍼 클래스의 constructor가 호출되면서 11을 파라미터 값으로 넘겨줍니다.</li>\n<li>슈퍼 클래스의 constructor에서 this는 현재의 인스턴스를 참조하므로 인스턴스의 member 프로퍼티에 파라미터로 받은 11을 설정한 후 돌아오게 되며,</li>\n<li>생성한 인스턴스를 obj에 할당합니다.</li>\n</ol>\n<ul>\n<li><p>다음은 obj의 인스턴스 구조입니다.</p>\n<img src=\"/images/extendsObj.JPG\">\n</li>\n<li><p>인스턴스를 생성하는 주체는 서브 클래스입니다. new Sports()가 아닌 new Soccer()로 인스턴스를 생성합니다.</p>\n</li>\n<li><p>슈퍼 클래스의 constructor에서 this.member에 설정한 값이 인스턴스 프로퍼티로 설정됩니다.</p>\n</li>\n<li><p>&#95;&#95;proto&#95;&#95;에 서브 클래스의 prototype에 연결된 메서드가 첨부되었으며</p>\n</li>\n<li><p>&#95;&#95;proto&#95;&#95;에 슈퍼 클래스의 prototype에 연결된 메서드가 첨부됩니다.</p>\n</li>\n<li><p>메서드를 호출할 때 &#95;&#95;proto&#95;&#95;를 작성하지 않아도 되므로<br>setGround()와 getMember()를 인스턴스에서 직접 호출할 수 있습니다.</p>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li>obj.getMember()를 호출하면 우선 obj.&#95;&#95;proto&#95;&#95;에서 메서드를 찾습니다. 존재하지 않으면 obj.&#95;&#95;proto&#95;&#95;.&#95;&#95;proto&#95;&#95;에서 찾습니다. 메서드가 존재하면 호출됩니다.<br>이것이 자바스크립트의 상속 메커니즘 입니다.</li>\n</ol>\n<hr>\n<h2 id=\"super\">super 키워드</h2>\n\n<p>서브 클래스와 슈퍼 클래스에 같은 이름의 메서드가 존재하면 슈퍼 클래스의 메서드는 호출되지 않습니다.<br>이때 super 키워드를 사용하여 슈퍼 클래스의 메서드(혹은 함수)를 호출할 수 있습니다.</p>\n<p>서브 클래스 constructor에 super()를 작성하면 슈퍼 클래스의 constructor가 호출됩니다.<br>super.name()과 같이 super 키워드에 이어서 호출하려는 메서드 이름을 작성합니다.</p>\n<h3 id=\"메서드-오버라이딩\"><a href=\"#메서드-오버라이딩\" class=\"headerlink\" title=\"메서드 오버라이딩\"></a>메서드 오버라이딩</h3><p>서브 클래스와 슈퍼 클래스에 같은 이름의 메서드가 있을 때 서브 클래스의 메서드가 호출 되는 것을<br>메서드 오버라이딩(Overriding)이라고 합니다. 메서드 오버라이딩은 의도적인 접근 방식입니다.</p>\n<p>서브 클래스와 슈퍼 클래스의 같은 이름의 메서드가 같은 목적을 가진 것을 나타내면서<br>서브 클래스의 목적에 맞도록 보완할 때 사용합니다.(슈퍼 클래스의 메서드 기능을 사용하면서 서브 클래스에서 기능을 추가,변경할 때 사용합니다.)</p>\n<p>슈퍼 클래스와 서브 클래스의 메서드 기능/목적이 다른 경우에는 같은 이름을 사용하지 않습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>super-1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> setGround(ground)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.ground = ground;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Soccer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> setGround(ground)&#123;  </span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"keyword\">super</span>.setGround();  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.ground = ground;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Soccer();  </span><br><span class=\"line\">obj.setGround(<span class=\"string\">\"상암구장\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.ground);  </span><br><span class=\"line\"><span class=\"comment\">// 상암구장</span></span><br></pre></td></tr></table></figure>\n\n<p><del>Sports 클래스는 슈퍼 클래스 입니다. 상속을 해주지만 단독으로 인스턴스를 생성할 수도 있습니다.</del></p>\n<ul>\n<li><p>Class Sports{}에는 그라운드(setground)가 필요합니다.<br>Sports의 종목이 여러개라면 종목마다 그라운드(setGround)형태도 달라져야 할 수 있습니다.<br>그런 의미에서 setGround()메서드는 의미 없어 보일 수 있습니다.</p>\n</li>\n<li><p>하지만 Sports 클래스를 상속받는 서브 클래스에서 setGround를 오버라이딩 하면 일관성 있게<br>그라운드를 정의할 수 있습니다. 메서드 이름을 유지하면서 서브클래스 마다<br>적합한 그라운드(setGround)를 설정해 주는 것입니다.<br>이를 객체 지향에서 추상화(Abstraction)라고 합니다.</p>\n</li>\n</ul>\n<ol>\n<li><p>Soccer 클래스에서 Sports 클래스를 상속받습니다. Sports 클래스에 setGround()가 있으며<br>Soccer 클래스에도 있으므로 메서드가 오버라이딩 됩니다.<br>new Soccer()로 인스턴스를 생성한 후 setGround()를 호출하게 되면 서브클래스(Soccer)의<br>메서드가 호출됩니다. 이때 super.setGround()는 슈퍼클래스(Sports)의 setGround()를 호출합니다.</p>\n</li>\n<li><p>super.setGround()를 호출하면서 파라미터 값은 정해주지 않았습니다.<br>슈퍼클래스(Soccer)의 setGround()에서 this.ground에 undefined가 설정됩니다.<br>super.setGround()를 실행한 후 돌아오면 바로 다음 줄의 this.ground에서 파라미터로 받은 값을 설정합니다.</p>\n</li>\n<li><p>new Soccer()로 인스턴스를 생성하고 setGround()를 호출하면 인스턴스의 ground 프로퍼티에 파라미터 값이 설정됩니다. ground가 인스턴스 프로퍼티이므로 obj.ground로 값을 출력할 수 있습니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>super-2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(member)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.member = member;  </span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.member);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Soccer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"keyword\">constructor</span>(member)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">super</span>(member);  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.member = <span class=\"number\">456</span>;  </span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.member);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Soccer(<span class=\"number\">123</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 123  </span></span><br><span class=\"line\"><span class=\"comment\">// 456</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>new Soccer(123)을 실행하면 Soccer 클래스의 constructor가 호출됩니다.</p>\n</li>\n<li><p>constructor 첫째 줄의 super(member)를 실행하면 슈퍼 클래스의 constructor를<br>호출 하면서 파라미터로 받은 값을 넘겨줍니다. 슈퍼 클래스의 constructor를<br>호출하려면 서브클래스 constructor의 첫째 줄에 super()를 작성해야 합니다.</p>\n</li>\n</ol>\n<p><strong>super() 앞에 변수를 선언하거나 변수에 값을 할당하는 코드는 작성해도 되지만,</strong><br><strong>this 키워드는 super() 앞에 사용할 수 없습니다.</strong></p>\n<ol start=\"3\">\n<li>super()로 인해 constructor가 호출되면 this로 인스턴스를 참조할 수 있습니다.<br>따라서 파라미터로 받은 member 값을 인스턴스의 member 프로퍼티에 할당할 수 있습니다.</li>\n</ol>\n<hr>\n<h2 id=\"builtin\">빌트인 오브젝트 상속</h2>\n\n<p>extends 키워드로 Array 오브젝트 등의 빌트인 오브젝트를 상속받을 수 있습니다.<br>상속을 받지 않고 서브 클래스에서 빌트인 오브젝트의 메서드를 호출해도 되지만<br>상속 받는 것과 차이가 있습니다. 서브 클래스에서 빌트인 오브젝트를 상속받으면<br>빌트인 오브젝트의 메서드를 마치 서브 클래스에서 선언한 것처럼 사용할 수 있게 됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>builtin</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendArray</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">super</span>();  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> getTotal()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> total = <span class=\"number\">0</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> value <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>)&#123;  </span><br><span class=\"line\"> total += value;  </span><br><span class=\"line\"> &#125;;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> total;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> ExtendArray();  </span><br><span class=\"line\"><span class=\"number\">3.</span> obj.push(<span class=\"number\">10</span>, <span class=\"number\">20</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(obj.getTotal());  </span><br><span class=\"line\"><span class=\"comment\">// 30</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>클래스 ExtendArray 에 빌트인 오브젝트인 Array 오브젝트를 상속받았습니다.<br>new 연산자로 인스턴스를 생성하면 인스턴스는 Array 오브젝트의 특징을 갖게됩니다.<br>따라서 인스턴스에서 push()와 같은 Array 메서드를 직접 호출할 수 있습니다.<br>“[].push()”형태가 아닌 “인스턴스.push()”형태로 호출할 수 있습니다.<br>이 형태의 차이에 상속 받는 목적이 담겨있다고 할 수 있습니다.</p>\n</li>\n<li><p>new ExtendArray()를 실행하면 아래에 작성한 constructor가 호출됩니다.</p>\n<blockquote>\n<p>constructor(){<br>super();<br>}</p>\n</blockquote>\n<p>super()가 슈퍼 클래스의 constructor를 호출하므로 Array 오브젝트 constructor가<br>호출됩니다.</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>obj 인스턴스에 push()메서드가 상속되어 있으므로 obj.push(10,20)형태로 호출할 수 있습니다.<br>obj.push(10, 20) 과 [].push(10, 20)에서 obj 인스턴스가 Array 리터럴[]에 해당됩니다.<br>따라서 obj 인스턴스에 10 과 20를 설정하는 것은 Array 인스턴스에 설정하는 것과 같습니다.<br>이것이 빌트인 오브젝트를 상속받는 목적 중의 하나입니다.</p>\n</li>\n<li><p>obj.getTotal()을 호출하면 for-of 문으로 [10, 20]을 합산하여 반환합니다.<br><del>값을 합산해주는 빌트인 함수도 있지만 for(var value of this)문에서<br>this를 다루기 위해 의도적으로 for-of 문을 사용했습니다.</del><br>this가 obj 인스턴스를 참조합니다. obj 인스턴스는 [10, 20]값이 설정되어 있으며<br>Array 오브젝트를 상속받은 상태 이므로 length 프로퍼티를 갖고있습니다.<br>즉, 이터레이션을 수행할 수 있는 조건을 충족합니다.</p>\n<blockquote>\n<p>for(var value of [10, 20]){<br>total += value;<br>} return total</p>\n</blockquote>\n</li>\n</ol>\n<p>위 헝태가 되어 엘리먼트(10, 20)를 하나씩 읽어가면서 for-of 문을 반복합니다.</p>\n<hr>\n<h2 id=\"Object_super\">Object에서 super 사용</h2>\n\n<p>두 개의 Object 오브젝트가 연결된 구조에서 super.name() 형태로 슈퍼 오브젝트의<br>메서드를 호출할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Sports = &#123;  </span><br><span class=\"line\"> getTitle()&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Sports\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> Soccer = &#123;  </span><br><span class=\"line\"> getTitle()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">super</span>.getTitle();  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Soccer\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">Object</span>.setPrototypeOf(Soccer, Sports);  </span><br><span class=\"line\"><span class=\"number\">2.</span> Soccer.getTitle();  </span><br><span class=\"line\"><span class=\"comment\">//Sports  </span></span><br><span class=\"line\"><span class=\"comment\">//Soccer</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Object.setPrototypeOf()을 실행하면 Soccer.&#95;&#95;proto&#95;&#95;에<br>Sports 오브젝트의 프로퍼티가 첨부됩니다.<br>Object 오브젝트가 대상이므로 생성자 함수가 없지만,&#95;&#95;proto&#95;&#95;에 프로퍼티가 첨부되는 것이 상속 구조(형태)입니다.</p>\n</li>\n<li><p>Soccer.getTitle();이 호출되면, 첫째 줄에서 super.getTitle()을 호출합니다.<br>상속을 하면 &#95;&#95;proto&#95;&#95;로 계층을 만들고,&#95;&#95;proto&#95;&#95;에 상속받을 오브젝트의 프로퍼티를 첨부하므로, super는 한 단계 아래의 &#95;&#95;proto&#95;&#95;를 참조하는 것과 같습니다.</p>\n</li>\n</ol>\n<p>현재 Soccer.&#95;&#95;proto&#95;&#95;에 Sports 오브젝트의 getTitle()이 첨부되어 있습니다.<br>따라서 super.getTitle()을 호출하면, super가 Soccer.&#95;&#95;proto&#95;&#95;를 참조하므로<br>Sports 오브젝트의 getTitle()이 호출됩니다.  </p>\n<p><strong>이와 같이 Object.setPrototypeOf()으로 &#95;&#95;proto&#95;&#95;구조를 만들고 상속받을 오브젝트의 프로퍼티를 첨부하면, super키워드로 상속 계층 구조에 있는 메서드를 호출할 수 있습니다.</strong></p>\n<hr>\n<h2 id=\"static\">static 키워드</h2>\n\n<p>클래스에 static(정적) 메서드를 정의합니다.</p>\n<blockquote>\n<p>static methodName() { … }</p>\n</blockquote>\n<p>prototype에 연결된 메서드는 인스턴스를 생성하여 호출 하지만,<br>static 메서드는 인스턴스를 생성하지않고 클래스에 직접 연결하여 호출합니다.</p>\n<p>static 메서드는 prototype에 연결되지 않으므로 인스턴스에서 호출할 수 없습니다.<br>클래스 이름을 지정하여 static 메서드를 호출해야 합니다.</p>\n<ul>\n<li>중요 포인트<br>엔진이 class 키워드를 만나면 클래스 안에 static 메서드 작성 여부를 체크합니다.<br>static 메서드가 존재한다면 이를 Function 오브젝트로 생성합니다.<br>(메서드를 호출하기 위해서는 메서드가 Function 오브젝트여야 하고,<br>이렇게 생성함으로써 클래스 아래의 static메서드를 호출할 수 있게 합니다.)</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>자바스크립트 Function 오브젝트 생성 형태</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// Function 오브젝트입니다.  </span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// Function 오브젝트가 아닙니다.  </span></span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>function 안에 function은 Function 오브젝트로 생성하지 않고,<br>function이 호출되어 안에 있는 function으로 들어갔을 때<br>Function 오브젝트를 생성합니다.<br>따라서 function을 호출하지 않으면 안에 있는 function은<br>아무것도 아닙니다. 그저 작성돼있는 함수 입니다.<br>이 점이 static 키워드를 사용한 메서드와 차이점 입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> getGround() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"상암구장\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(Sports.getGround());</span><br></pre></td></tr></table></figure>\n\n<p>getGround(){} 앞에 static을 작성하여 static메서드로 선언했습니다.</p>\n<ol>\n<li>Sports는 클래스 이름이고 getGround()는 static메서드 입니다.<br>이와 같이 앞에 클래스 이름을 작성하고 이어서 static메서드를 작성하여 호출합니다.</li>\n</ol>\n<hr>\n<h2 id=\"Class_Hoisting\">Class 호이스팅</h2>\n\n<p>클래스는 호이스팅(Hoisting)이 되지 않습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Class  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = Member;  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> getMember()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"member\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Member.getMember()); <span class=\"comment\">// member  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.getMember()); <span class=\"comment\">// TypeError  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// function과 비교  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = Member2;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Member2</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"member2\"</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Member2());<span class=\"comment\">// member2  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result2());<span class=\"comment\">// member2</span></span><br></pre></td></tr></table></figure>\n\n<p>호이스팅 된다면 Member 클래스가 result 변수에 할당됩니다.<br>호이스팅 되지않으면 Member를 인식하지 못합니다. Error</p>\n<ul>\n<li><p>클래스는 호이스팅 되지않아 result에 할당할 Member를 인식하지 못합니다.<br>result에 Member 값을 넣으려면 클래스 문이 완전히 끝난 뒤에 작성해야합니다.</p>\n</li>\n<li><p>function은 호이스팅 되므로 result2에 Member2를 인식하여 할당할 수 있습니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"computed_name\">computed name</h2>\n\n<p>클래스의 메서드 이름을 조합(computed name)하여 작성할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>computed name</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> type = <span class=\"string\">\"Type\"</span>;  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> [<span class=\"string\">\"get\"</span> + type](kind)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> kind ? <span class=\"string\">\"스포츠\"</span> : <span class=\"string\">\"음악\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(Sports[<span class=\"string\">\"get\"</span> + type](<span class=\"number\">1</span>)); <span class=\"comment\">// 스포츠  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Sports.getType(<span class=\"number\">1</span>)); <span class=\"comment\">// 스포츠</span></span><br></pre></td></tr></table></figure>\n\n<p>변수 type 에 문자열 값 “Type”을 할당해 줬습니다.<br>static 메서드 []안에 문자열 “get” 과 클래스 밖에 작성된 type 변수 값을<br>작성해줬습니다. static메서드의 이름이 getType이 됩니다.<br>이와 같이 static 메서드 []안에 조합할 이름을 작성합니다.</p>\n<ol>\n<li>문자열 “get”과 변수인 type을 조합하여 호출합니다.<br>파라미터 값이 1 (true)이므로 호출된 getType()에서 “스포츠”를 반환합니다.<br>물론 console.log(Sports.getType(1)); 형태로 호출할 수 도 있습니다.</li>\n</ol>\n<hr>\n<h2 id=\"this\">this</h2>\n\n<p>static 메서드에서 this는 클래스 오브젝트를 참조합니다.<br>constructor 안에서 this.constructor.name()형태로 static 메서드를 호출할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>this 예제</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> setGround(ground)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.ground = ground;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> getGround()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.ground;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">Sports.setGround(<span class=\"string\">\"상암구장\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Sports.getGround());  </span><br><span class=\"line\"><span class=\"comment\">// 상암구장</span></span><br></pre></td></tr></table></figure>\n\n<p>Sports.setGround(“상암구장”)를 실행하면 static메서드인 setGround()가 호출됩니다.<br>this.ground에서 this가 Sports 클래스를 참조하므로 Sports 클래스에<br>{ground: “상암구장”} 형태로 설정됩니다.</p>\n<p>Sports.getGround()를 실행하면 getGround() 정적 메서드가 호출됩니다.<br>this.Ground에서 this가 Sports 클래스를 참조하므로 setGround()에서<br>Sports 클래스에 설정한 ground 프로퍼티 값을 구할 수 있습니다. //상암구장</p>\n<figure class=\"highlight js\"><figcaption><span>this 호출 예제</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span></span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(Sports.getGround());  </span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.constructor.getGround());  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> getGround()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"상암구장\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Sports();</span><br></pre></td></tr></table></figure>\n\n<p>new Sports()를 실행하면 constructor가 호출됩니다.<br>constructor 블록{}안에서 static메서드인 getGround를 호출하며,<br>this.constructor 형태도 사용하고 있습니다.</p>\n<ol>\n<li><p>Sports 클래스에 static 메서드로 getGround()를 작성했으므로<br>Sports.getGround() 형태로 호출할 수 있습니다.<br>constructor 블록{} 아래에 getGround()가 작성되어 있습니다만<br>이미 Function 오브젝트로 생성된 상태이므로 호출이 됩니다.</p>\n</li>\n<li><p>constructor가 Sports 클래스를 참조하며 인스턴스의 &#95;&#95;proto&#95;&#95;에<br>constructor가 첨부되어 있으므로 this.constructor.getGround() 형태로<br>static메서드를 호출할 수 있습니다. 구조는 다음 사진과 같습니다.</p>\n<img src=\"/images/ClassThisInstance.JPG\">\n</li>\n</ol>\n<ul>\n<li>this.getGround()형태로는 호출할 수 없습니다. (//undefined)<br>this가 new Sport()로 생성한 인스턴스를 참조하고,<br>getGround는 static메서드 이므로 인스턴스에 존재하지 않기 때문입니다.</li>\n</ul>\n<hr>\n<h2 id=\"generator\">제너레이터</h2>\n\n<p>클래스 안에 제너레이터 함수를 작성할 수 있습니다.<br>클래스 안에 작성한 제너레이터 함수는 prototype에 연결됩니다.<br>따라서 static 메서드로 호출할 수 없고 인스턴스를 생성하여 호출해야 합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span>&#123;  </span><br><span class=\"line\"> *gen() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">10</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">20</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Member();  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = obj.gen();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 10, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 20, done: false&#125;</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">new Member()로 클래스 인스턴스를 생성 합니다. 변수 obj에 할당됩니다.  </span></span><br><span class=\"line\"><span class=\"string\">genObj 변수에 obj.gen 메서드를 할당합니다.  </span></span><br><span class=\"line\"><span class=\"string\">genObj.next()로 호출할 수 있게됩니다.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* * *</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&lt;h2 id=\"new_target\"&gt;new.target&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">new.target은 메타(meta) 프로퍼티로 생성자 함수와 클래스에서  </span></span><br><span class=\"line\"><span class=\"string\">constructor를 참조합니다. new 연산자로 인스턴스를 생성하지 않으면  </span></span><br><span class=\"line\"><span class=\"string\">new.target 값은 undefined 입니다.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">let</span> sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span>.target);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">sports();  </span><br><span class=\"line\"><span class=\"keyword\">new</span> sports();  </span><br><span class=\"line\"><span class=\"comment\">// undefined  </span></span><br><span class=\"line\"><span class=\"comment\">/* function() &#123;  </span></span><br><span class=\"line\"><span class=\"comment\"> console.log(new.target);  </span></span><br><span class=\"line\"><span class=\"comment\">&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>sports(); 와 같이 new 연산자를 사용하지 않고 호출하면 new.target값은 undefined 입니다.</p>\n<p>new sports();로 호출하면 new.target은 constructor를 참조합니다.<br>sports 함수에 constructor를 작성하지 않았으므로 디폴트 constructor가 호출됩니다.<br>디폴트 constructor = (function: Object() {native code})<br>constructor가 sports 전체를 참조하므로 sports 함수의 코드가 출력됩니다.</p>\n<h3 id=\"name-프로퍼티\"><a href=\"#name-프로퍼티\" class=\"headerlink\" title=\"name 프로퍼티\"></a>name 프로퍼티</h3><p>ES6는 클래스, 함수 오브젝트에 name 프로퍼티가 존재하며 이름이 설정됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Sports:\"</span>, <span class=\"keyword\">new</span>.target.name);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Soccer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">super</span>();  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Soccer:\"</span>, <span class=\"keyword\">new</span>.target.name);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> sportsObj = <span class=\"keyword\">new</span> Sports();  </span><br><span class=\"line\"><span class=\"keyword\">let</span> soccerObj = <span class=\"keyword\">new</span> Soccer();  </span><br><span class=\"line\"><span class=\"comment\">// Sports: Sports  </span></span><br><span class=\"line\"><span class=\"comment\">// Sports: Soccer  </span></span><br><span class=\"line\"><span class=\"comment\">// Soccer: Soccer</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>new Sports()를 호출하면 Sports 클래스이므로 클래스 name 프로퍼티에 “Sports”가<br>설정되어 있습니다. constructor에서 new.target은 constructor를 참조하므로<br>Sports 클래스의 name 프로퍼티 값 “Sports”가 출력됩니다.</p>\n</li>\n<li><p>new Soccer()를 호출하면 super()로 인해 Sports의 constructor가 호출됩니다.<br>Sports의 constructor에서 new.target은 super()로 호출한 Soccer의<br>constructor를 참조합니다. 따라서 new.target.name 값으로 Sports가 아닌 Soccer가 출력됩니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"Image_Object\">Image 오브젝트 상속</h2>\n\n<ul>\n<li><p>DOM(Document Object Model)에서 제공하는 Image 인터페이스, Audio 인터페이스 등을 상속받을 수 있습니다.<br>빌트인 Array 오브젝트를 상속받으면 Array 오브젝트 특징을 갖듯이<br>상속받은 인터페이스 특징을 갖습니다.</p>\n</li>\n<li><p>DOM의 Image 인터페이스는 웹 페이지에 png 파일과 같은 이미지 파일을 표현하기 위한 속성을 제공합니다.<br>인터페이스는 객체지향 용어로 이 자체를 그대로 사용할 수 없고 오브젝트로 변환하여 사용해야 합니다.<br>DOM은 오브젝트를 제공하지 않고 인터페이스를 제공하는데,이는 자바스크립트뿐만 아니라 Java등의 다른 언어에서도 사용하기 때문입니다. 각 언어에서 DOM인터페이스를 언어에 맞게 변환하여 사용합니다.</p>\n</li>\n</ul>\n<p>인터페이스를 오브젝트로 변환하려면 extends 키워드를 사용합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>extends-image</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendsImage</span> <span class=\"keyword\">extends</span> <span class=\"title\">Image</span></span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">super</span>();  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"number\">2.</span> setProperty(image)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.src = image.src;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.alt = image.alt;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.title = image.title;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> imageObj = <span class=\"keyword\">new</span> ExtendsImage();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> properties = &#123;  </span><br><span class=\"line\"> src: <span class=\"string\">\"file/rainbow.png\"</span>,  </span><br><span class=\"line\"> alt: <span class=\"string\">\"나무와 집이 있고 그 위에 무지개가 있는 모습\"</span>,  </span><br><span class=\"line\"> title: <span class=\"string\">\"무지개\"</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">imageObj.setProperty(properties);  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"body\"</span>).appendChild(imageObj);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Image 오브젝트를 extends 키워드로 상속받습니다.<br>ExtendsImage 클래스는 Image 특성을 갖게됩니다.<br>즉, &lt; img &gt; 엘리먼트의 속성을 직접 사용할 수 있습니다.<br>또한 this로 엘리먼트 속성에 접근할 수 있습니다.</p>\n</li>\n<li><p>파라미터로 받은 &lt; img &gt; 속성 값을 this가 참조하는 imageObj 인스턴스에 설정합니다.</p>\n</li>\n<li><p>&lt; body&gt; 엘리먼트에 자식 요소로 imageObj를 첨부합니다.<br>body 엘리먼트에 imageObj 안에 있는 img 엘리먼트 속성도 첨부 횝니다.</p>\n</li>\n</ol>\n<p>웹페이지에 이미지가 표시되고 그 속성은 다음과 같습니다.</p>\n<blockquote>\n<p>&lt; img src = “file/rainbow.png”<br>alt= “나무와 집이 있고 그 위에 무지개가 있는 모습”<br>title= “무지개” &gt;</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Class(클래스)를 완전하게 이해하려면 객체지항 프로그래밍(OOP:Object Oriented Programming)에 대한 이해가 필요합니다.</p>\n<p>OOP만 다루는 책이 있을 정도로 범위가 넓고 깊으므로<br>OOP는 나중에 자세히 다루고 ES6기준으로 살펴봅니다.</p>\n<ul>\n<li>Class 오브젝트<ul>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#Class_선언문\">Class 선언문</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#Class_표현식\">Class 표현식</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#클래스_특징\">Class 특징</a><ul>\n<li>strict 모드에서 실행</li>\n<li>클래스에 메서드 작성 방법</li>\n<li>prototype에 프로퍼티 연결</li>\n<li>prototype에 프로퍼티 추가</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#constructor\">constructor</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#constructor_return\">constructor 반환 값 변경</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#getter_and_setter\">getter, setter</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#상속\">상속</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#extends\">extends 키워드</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#super\">super 키워드</a><ul>\n<li>메서드 오버라이딩</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#builtin\">빌트인 오브젝트 상속</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#Object_super\">Object에서 super 사용</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#static\">static 키워드</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#Class_Hoisting\">Class 호이스팅</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#computed_name\">computed name</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#this\">this</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#generator\">제너레이터</a></li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#new_target\">new.target</a><ul>\n<li>name 프로퍼티</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/01/Class%20오브젝트%20-ECMAScript/#Image_Object\">오브젝트 상속</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"Class_선언문\">Class 선언문</h2>\n\n<blockquote>\n<p>Class name {}<br>Class name extends super_name {}</p>\n</blockquote>\n<p>엔진이 function 키워드를 만나면 Function 오브젝트를 생성하듯이<br>class 키워드를 만나면 Class 오브젝트를 생성합니다.<br>Class 오브젝트는 Function 오브젝트, String 오브젝트와 같이 하나의 오트젝트 타입입니다.</p>\n<ul>\n<li>name에 클래스 이름을 작성합니다.<br>name 다음의 extends는 키워드로 super_name(슈퍼 클래스)를 상속받을 때 사용합니다. 이 형태를 클래스 선언문 이라고 합니다.</li>\n</ul>\n<p>class는 클래스를 선언하는 키워드이고<br>엔진이 class 키워드로 생성한 오브젝트는 Class 오브젝트 입니다.<br>문맥에 따라 Class 오브젝트를 class라고 말하기도 합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;  </span><br><span class=\"line\"> getName() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"이름\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Member();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(obj.getName());  </span><br><span class=\"line\"><span class=\"comment\">// 이름</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>class 키워드를 작성하고 이어서 클래스 이름을 작성합니다. 그리고 블록{}을 작성하고 블록에 클래스 코드를 작성합니다.<br>엔진이 class 키워드를 만나면 클래스(Class) 오브젝트를 생성합니다.</li>\n</ul>\n<ol>\n<li><p>new 연산자로 Member()를 호출하면 인스턴스를 생성하여 반환합니다.</p>\n<p><mark>function name(){}는 new 연산자로 인스턴스를 생성하지 않고<br>name()형태로 호출할 수 있지만,<br>클래스는 new 연산자로 인스턴스 생성없이 name()형태로 호출할 수 없으며<br>TypeError가 발생합니다.</mark></p>\n</li>\n<li><p>obj는 인스턴스이고 getName()은 class Member{}안에 작성한 메서드 입니다.<br>이와 같이 new 연산자로 생성한 인스턴스를 사용하여 클래스에 작성한 메서드를 호출할 수 있습니다. 실행 결과 “이름”이 출력됩니다.</p>\n</li>\n</ol>\n<ul>\n<li><p>참고</p>\n<blockquote>\n<p>new 연산자로 인스턴스를 생성하는 함수는 함수 이름의 첫 문자를 대문자로 작성합니다. 클래스 또한 new 연산자로 인스턴스를 생성하므로 클래스 이름의 첫 문자를 대문자로 사용합니다. 이는 스펙에 정의된 것은 아니며 자바스크립트 개발자들 사이의 관례입니다. 개발자가 코드의 대문자를 보고 인스턴스를 생성한다는 것을 알 수 있으므로 지키는 것이 좋습니다. 빌트인 Number 오브젝트, String 오브젝트도 이와 같은 맥락입니다.</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>같은 클래스를 두 번 선언하려고 시도할 때<br>클래스 선언문으로 같은 클래스를 두 번 선언하면 오류가 발생합니다.</p>\n<blockquote>\n<p>class Foo {};<br>class Foo {}; // Uncaught SyntaxError: Identifier ‘Foo’ has already been declared</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>이전에 표현식으로 정의한 경우에도 오류가 발생합니다.</p>\n<blockquote>\n<p>var Foo = class {};<br>class Foo {}; // Uncaught TypeError: Identifier ‘Foo’ has already been declared</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h2 id=\"Class_표현식\">Class 표현식</h2>\n\n<p>클래스 표현식으로 클래스를 선언합니다.</p>\n<blockquote>\n<p>let name = class {}<br>let name = class inner_name {}<br>let name = class extends super_name {}<br>let name = class inner_name extends super_name {}</p>\n</blockquote>\n<p>할당 연산자 (=) 왼쪽에 클래스 이름을 작성하고 오른쪽에 class 키워드를 작성하고 블록{}안에 클래스 코드를 작성합니다. 이를 클래스 표현식이라고 합니다.</p>\n<p>Class 표현식은 이름을 가질 수도 있고, 갖지 않을 수도 있습니다. 이름을 가진 class 표현식의 이름은 클래스의 body에 대해 local scope에 한해 유효합니다.</p>\n<p>4번째 구문 class 와 extends 키워드 사이의 inner_name은 클래스 안에서 자신을 호출할 때 사용합니다. <del>function 키워드 함수에서도 inner_name을 작성할 수 있지만 사용하지 않듯 클래스도 사용하지 않습니다.</del></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Member = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;  </span><br><span class=\"line\"> getName() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"이름\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Member();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getName());</span><br></pre></td></tr></table></figure>\n\n<p>엔진이 클래스 키워드를 만나면 클래스 오브젝트를 생성하여 Member 변수에 할당합니다.</p>\n<hr>\n<h2 id=\"클래스_특징\">클래스 특징</h2>\n\n<p>Class는 사실 함수입니다. 함수를 함수 표현식과 함수 선언으로 정의할 수 있듯이 class 문법도 class 표현식과 class 선언 두 가지 방법을 제공합니다.</p>\n<ol>\n<li><p>strict 모드에서 실행</p>\n<p><strong>“use static”을 선언하지 않아도 클래스의 코드는 static 모드에서 실행됩니다.</strong></p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>클래스에 메서드 작성 방법</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> setName(name) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"number\">2.</span> getName() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">4.</span> Member.prototype.getTitle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> Member);  </span><br><span class=\"line\"><span class=\"comment\">// function</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>setName(){ } 과 같이 function 키워드와 콜론(:)을 작성하지 않고 메서드 이름만 작성합니다.</p>\n</li>\n<li><p>setName()과 getName() 메서드 사이에 콤마를 작성하지 않습니다.</p>\n</li>\n<li><p>클래스의 typeof는 function 입니다. 이는 class가 function 구조라는 것을 의미합니다.</p>\n</li>\n<li><p>function name(){ }은 글로벌 오브젝트(window Object)에 설정되지만<br>class name(){ }은 글로벌 오브젝트에 설정되지 않습니다.<br>따라서 window.Member로 클래스에 접근하면 undefined가 반환됩니다.<br><code>Class 오브젝트의 프로퍼티는 for()문 등으로 열거할 수 없습니다.</code></p>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li>prototype에 프로퍼티 연결</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span>&#123;  </span><br><span class=\"line\"> setName(name) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><del>prototype에 메서드를 연결하여 prototype.setName과 같이 작성하지 않고</del><br>setName을 작성합니다. 자바스크립트는 기본적으로 prototype에 메서드를 연결하는 구조이므로 <strong>클래스 안에 작성된 메서드를 엔진이 자동으로 prototype에 연결합니다.</strong><br>즉. 엔진이 Member.prototype.setName 형태로 연결해줍니다.</p>\n<p>이는 중요한 의미를 갖습니다. 자바스크립트의 기본 아키텍처(구성 방식 혹은 컴퓨터 소프트웨어의 호환성)를 유지하면서 객체지향 언어의 특징을 반영하려는 접근입니다.</p>\n<ol start=\"4\">\n<li>prototype에 프로퍼티 추가</li>\n</ol>\n<blockquote>\n<p>Member.prototype.getTitle = function(  ){ };  </p>\n</blockquote>\n<p><strong>클래스 밖에서 Member 클래스에 메서드를 추가하려면</strong> 위와 같이<br>Member.prototype에 메서드를 연결하여 작성합니다.<br>Member 클래스를 선언할 때는 클래스 블록{}안에 작성하겠지만,<br>인스턴스를 생성한 후 상황에 따라 추가할 때 이 형태로 작성합니다.</p>\n<ul>\n<li>참고<br>이렇게 메서드를 추가하면 이미 생성된 인스턴스에서 추가한 메서드를 공유할 수 있도록 엔진이 처리하게 되므로 부하 혹은 자원낭비가 됩니다.<br>좋은 사용 예시로는 사용자의 행동이나 서버 데이터에 따라 메서드를 따로 추가할 수 있는 점이 있습니다.(역동성이 높다.)</li>\n</ul>\n<hr>\n<h2 id=\"constructor\">constructor</h2>\n\n<ul>\n<li><p>constructor 메소드는 class 인스턴스를 생성하고 생성된 인스턴스를 초기화하는 역활을 합니다.</p>\n</li>\n<li><p>“constructor” 라는 이름을 가진 메소드는 클래스 안에 한 개만 존재할 수 있습니다. 만약 클래스에 여러 개의 constructor 메소드가 존재하면 SyntaxError 가 발생할 것입니다.</p>\n</li>\n<li><p>constructor는 부모 클래스의 constructor 를 호출하기 위해 super 키워드를 사용할 수 있습니다.</p>\n</li>\n<li><p>참고<br>클래스에 constructor를 작성하지 않으면 prototype의 constructor가 호출됩니다.<br>이를 디폴트 constructor라고 하고 constructor가 없으면 인스턴스를 생성할 수 없습니다.<br>ES5 에서 클래스 오브젝트를 실행하면 엔진이 디폴트 constructor를 호출해서 이를 활용할 수 없었습니다.<br>ES6 에서는 개발자가 constructor를 정의할 수 있어서 Class 오브젝트 뿐 아니라<br>Proxy 오브젝트, Reflect 오브젝트에서 활용할 수 있습니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>(name)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> getName() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> memberObj = <span class=\"keyword\">new</span> Member(<span class=\"string\">\"스포츠\"</span>);  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(memberObj.getName());  </span><br><span class=\"line\"><span class=\"comment\">// 스포츠</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>클래스 안에 constructor를 작성했으며 constructor 안에 생성한 인스턴스에 초기값을 설정하는 코드를 작성했습니다.<br>constructor 안의 this는 생성하는 인스턴스를 참조합니다.</p>\n</li>\n<li><p>new Member(“스포츠”)를 실행하면 Member 클래스에 작성한 constructor가 자동으로 호출되며 파라미터 값으로 “스포츠”를 넘겨 줍니다.</p>\n<ul>\n<li>new 연산자는 constructor를 호출하면서 파라미터를 넘겨주는 역활</li>\n<li>호출된 constructor가 인스턴스를 생성하여 반환하면 new 연산자가 받아 new를 실행한 곳으로 반환합니다.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"클래스-와-인스턴스-생성-과정-이해를-위한-개념적인-순서\"><a href=\"#클래스-와-인스턴스-생성-과정-이해를-위한-개념적인-순서\" class=\"headerlink\" title=\"클래스 와 인스턴스 생성 과정 이해를 위한 개념적인 순서\"></a><mark>클래스 와 인스턴스 생성 과정 이해를 위한 개념적인 순서</mark></h2><pre><code>1. new Member(&quot;스포츠&quot;)를 실행합니다.\n\n2. new 연산자가 constructor를 호출하면서 파라미터 값을 넘겨줍니다.\n\n3. constructor의 블록 코드를 실행하기 전에 빈 Object 오브젝트를생성합니다.\n\n4. 이 것이 인스턴스입니다. 인스턴스가 생성되면 빈 오브젝트를 채웁니다.\n\n5. 인스턴스 구성에 필요한 프로퍼티를 Object 오브젝트에 설정합니다.\n\n6. constructor 블록에 있는 코드를 실행합니다.\n\n7. 인스턴스를 먼저 생성하므로 constructor에서 this로 인스턴스를 참조할수    있습니다.\n\n8. 생성된 인스턴스를 반환합니다.</code></pre><ol start=\"3\">\n<li>console.log(memberObj.getName());를 호출하면 다음 코드가 실행됩니다.</li>\n</ol>\n<blockquote>\n<p>getName() {<br> return this.name;<br>}</p>\n</blockquote>\n<p>constructor에서 this에 “스포츠”를 설정했으므로 “스포츠”가 반환됩니다.</p>\n<p>아래는 생성된 memberObj 인스턴스 구조입니다.</p>\n<img src=\"/images/constructorInstance.JPG\">\n\n<p>constructor에서 파라미터로 받은 “스포츠”를 this.name에 할당했으며,<br>이때 this가 생성하는 인스턴스를 참조하므로 인스턴스 프로퍼티로 설정됩니다.</p>\n<ul>\n<li><p>&#95;&#95;proto&#95;&#95;는 인스턴스를 생성하면 엔진이 자동으로 첨부합니다.</p>\n</li>\n<li><p>&#95;&#95;proto&#95;&#95;에 Member.prototype에 연결된 프로퍼티를 첨부하므로 getName도 첨부됩니다.</p>\n</li>\n<li><p>&#95;&#95;proto&#95;&#95;에 Object 오브젝트의 prototype에 연결된 프로퍼티가 첨부됩니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"constructor\">constructor</h2>\n\n<p>constructor는 일반적으로 return 문을 작성하지 않으며, 생성한 인스턴스를 반환합니다.<br>return을 사용하면 인스턴스 이외의 값을 반환할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"number\">1</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> getName()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"이름\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> memberObj = <span class=\"keyword\">new</span> Member();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(memberObj.getName());</span><br></pre></td></tr></table></figure>\n\n<p>constructor(){ }안에 return 1;을 작성하였습니다.<br><del>일반적으로 숫자 값을 반환하지 않습니다, 엔진 처리 방법 예시를 위해 작성되었습니다.</del><br><mark>constructor에서 Number 또는 String 값을 반환하면 이를 무시하고 생성한 인스턴스를 반환합니다.</mark></p>\n<p>console.log(memberObj.getName();)을 호출하면 constructor에서 1을 반환하여<br>memberObj에 1이 설정됩니다. 이후에 getName()을 호출하면 인스턴스 1에 getName()이 존재하지 않으므로 에러가 발생합니다. 하지만 Member 인스턴스를 반환하므로 getName()이 호출됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> &#123;<span class=\"attr\">name</span>: <span class=\"string\">\"홍길동\"</span>&#125;;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> getName()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"이름\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> memberObj = <span class=\"keyword\">new</span> Member();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(memberObj.name);  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(memberObj.getName);  </span><br><span class=\"line\"><span class=\"comment\">// 홍길동  </span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>constructor에서 Object오브젝트를 return하면 이를 반환합니다.<br>즉, {name: “홍길동”}이 반환됩니다.</p>\n<ol>\n<li><p>memberObj에 반환된 {name: “홍길동”}이 설정되어 있으므로 memberObj.name 값이 홍길동 으로 출력됩니다.</p>\n</li>\n<li><p>클래스에 getName 메서드를 작성했지만, 인스턴스를 반환하지 않고 {name: “홍길동”}을 반환하므로<br>MemberObj에 getName이 존재하지 않습니다. undefined가 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"getter_and_setter\">getter, setter</h2>\n\n<p>클래스에도 getter와 setter를 선언할 수 있습니다.<br>메서드 이름 앞에 “get”을 작성하면 getter, “set”을 작성하면 setter가 됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>getter</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">get</span> getName() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"이름\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> memberObj = <span class=\"keyword\">new</span> Member();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(memberObj.getName);  </span><br><span class=\"line\"><span class=\"comment\">// 이름</span></span><br></pre></td></tr></table></figure>\n\n<p>get getName()과 같이 메서드 이름 앞에 get을 작성하여 getter로 선언합니다.</p>\n<p>getName이 getter이므로 메서드로 호출됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>setter</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">set</span> setName(name) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">get</span> getName() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> memberObj = <span class=\"keyword\">new</span> Member();  </span><br><span class=\"line\">memberObj.setName = <span class=\"string\">\"이름\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(memberObj.getName);  </span><br><span class=\"line\"><span class=\"comment\">// 이름</span></span><br></pre></td></tr></table></figure>\n\n<p>memberObj.setName = “이름”과 같이 setter로 선언된 메서드 이름에 값을 할당하면<br>setName이 메서드로 호출됩니다. 이때 할당하는 값인 “이름”을 파라미터 값으로 넘겨줍니다.</p>\n<hr>\n<h2 id=\"상속\">상속</h2>\n\n<p>객체지향 프로그래밍에서 상속은 주요한 기능 중 하나입니다.<br>클래스를 상속받으면 상속받은 클래스의 메서드와 프로퍼티를 사용할 수 있습니다.</p>\n<ul>\n<li>참고<br>상속해 주는 클래스를 일반적으로 부모 클래스라고 부릅니다만<br>앞으로는 “슈퍼 클래스”라고 표기해줍시다.<br>슈퍼 클래스라고 표기하는 이유는 ES6에서 super키워드가 있으며<br>슈퍼 클래스를 지칭하므로 직관적이기 때문입니다.<br>상속받는 클래스도 일반적으로 자식 클래스라고 부릅니다만,<br>슈퍼 클래스와 운을 맞추기 위해 “서브 클레스”로 표기해줍시다.</li>\n</ul>\n<p><mark>자바스크립트 (객채지향 프로그래밍)의 상속 형태는 상속이 아니다?</mark></p>\n<p>일반적으로 상속이라고 하면 부모의 재산을 자식에게 물려주면<br>자식이 부모의 능력을 고스란히 물려받습니다.<br>자바스크립트에서는 객체도 생성자도 모두 프로토타입에 접근할 수 있고<br>심지어 변경까지할 수 있습니다.<br>이는 상속받을 것들을 자기 마음대로 선택,변경할 수 있게 되고<br>다른 언어의 상속과는 다른 형태를 갖습니다.<br>상속이라고 부르지만, 프로토타입의 (자원)공유로 이해하는 것이 적절해 보입니다.</p>\n<p><strong>ES5에서의 상속 구현 형태</strong></p>\n<figure class=\"highlight js\"><figcaption><span>ES5 상속 형태</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sports</span>(<span class=\"params\">member</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"keyword\">this</span>.member = member;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> Sports.prototype.setItem = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.item = item;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Soccer</span>(<span class=\"params\">member</span>)</span>&#123;  </span><br><span class=\"line\"> Sports.call(<span class=\"keyword\">this</span>, member);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">5.</span> Soccer.prototype = <span class=\"built_in\">Object</span>.create(Sports.prototype, &#123;  </span><br><span class=\"line\"> setGround: &#123;  </span><br><span class=\"line\"> value: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ground</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.ground = ground;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"number\">6.</span> Soccer.prototype.constructor = Soccer;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">7.</span> <span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> Soccer(<span class=\"number\">11</span>);  </span><br><span class=\"line\"><span class=\"number\">8.</span> obj.setItem(<span class=\"string\">\"축구\"</span>);  </span><br><span class=\"line\">obj.setGround(<span class=\"string\">\"상암\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">9.</span> <span class=\"built_in\">console</span>.log(obj.member); <span class=\"comment\">// 11  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.item); <span class=\"comment\">// 축구  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.ground); <span class=\"comment\">// 상암</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Sports 첫 문자를 대문자로 작성한 것은 new 연산자로 인스턴스를 생성하려는 의도입니다. new Sports()를 실행하면 Sports()가 호출되고, 다시 디폴트 constructor를 호출합니다. 그래서 Sports()를 생성자(constructor)함수라고 부릅니다.</p>\n</li>\n<li><p>this.member에서 this가 생성하는 인스턴스를 참조하므로 member는 인스턴스 프로퍼티가 됩니다. Sports(생성자 함수)함수에서 this.member = member 형태가 인스턴스에 초기값으로 설정됩니다. <del>이렇게 설정된 값은 생성된 모든 인스턴스에서 공유하지 않고 인스턴스마다 값을 각각 유지합니다. 이것이 인스턴스를 만드는 목적 중의 하나입니다.</del></p>\n</li>\n<li><p>생성자 함수가 있으면 Sports.prototype.setItem과 같이 prototype에 메서드를 연결한 코드가 작성되어 있습니다. 이를 작성하지 않으면 생성자 함수가 아닌 일반 함수 입니다. <strong>이 형태가 ES5에서 인스턴스를 구현하는 기본 형태입니다.</strong></p>\n</li>\n<li><p>Soccer()가 호출되면 Sports()를 호출합니다. Soccer의 첫 문자가 대문자이므로 인스턴스를 사용한다는 것을 알 수 있습니다. 그런데 new Sports()가 아닌 Sports.call()형태로 함수를 호출한 것은, 바로 다음 코드에서 Sports.prototype을 사용하여 인스턴스를 생성하므로 인스턴스에 초기값만 성정하면 되기 때문입니다.</p>\n</li>\n<li><p>Object.create()의 두 번째 파라미터 setGround를 첫 번째 파라미터인 Soccer.prototype에 첨부합니다. 그리고 Sports.prototype에 연결된 메서드를 Soccer.prototype.&#95;&#95;proto&#95;&#95;에 첨부합니다.<br>이렇게 연결된 후에 new Soccer()로 인스턴스를 생성하면 Soccer.prototype과 Sports.prototype에 연결된 메서드를 인스턴스 메서드로 호출할 수 있습니다.<strong>ES5에서는 이와 같은 방법으로 상속을 구현합니다.</strong></p>\n</li>\n<li><p>Soccer.prototype에 constructor가 연결되어 있는데, 앞 코드에서<br>Soccer.prototype에 프로퍼티를 연결하므로 constructor가 지워집니다.<br>Soccer를 설정하지 않아도 인스턴스가 생성되지만, constructor에서 Soccer전체를 참조하는 것이 정상입니다.</p>\n</li>\n<li><p>new 연산자로 Soccer() 생성자 함수를 호출하여 인스턴스를 생성합니다.<br>Sports.prototype에 연결된 메서드는 인스턴스에 포함되지만, Sports() 생성자 함수는 포함되지 않으므로 Sports.call(this.member); 코드를 수행하여 인스턴스에 초기값을 설정합니다. this는 생성한 인스턴스를 참조하게 됩니다.</p>\n</li>\n<li><p>setItem()은 상속받은 Sports.prototype에 연결된 메서드 입니다.<br>상속을 받으면 인스턴스에서 직접 상속받은 메서드를 호출할 수 있습니다.</p>\n</li>\n<li><p>생성자 함수를 모두 호출하여 인스턴스에 초기값을 설정했으므로 인스턴스 프로퍼티로 프로퍼티 값을 구할 수 있습니다.<br>ES5에서는 이와 같이 prototype에 연결해야 하며 직관적이지 않은 점도 있습니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"extends\">extends 키워드</h2>\n\n<p>ES6에서는 extends 키워드로 상속을 구현합니다.</p>\n<blockquote>\n<p>class subClass extends superClass { }</p>\n</blockquote>\n<ul>\n<li><p>subClass<br>상속 받는 자식 클래스(서브 클래스).</p>\n</li>\n<li><p>superClass<br>상속 해주는 부모 클래스(슈퍼 클래스).</p>\n</li>\n<li><p>new subClass()로 인스턴스를 생성하면 인스턴스에서 subClass 클래스와 super 클래스의 메서드를 호출할 수 있습니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>extends ES6</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>(member)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.member = member;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> getMember()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.member;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Soccer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> setGround(ground)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.ground = ground;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Soccer(<span class=\"number\">11</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(obj.getMember()); <span class=\"comment\">// 11</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Sports 클래스를 상속받으므로 Sports 클래스는 슈퍼 클래스입니다.<br>new Soccer()로 인스턴스를 생성하면 constructor가 호출되며,this가 생성하는 인스턴스를 참조하므로 파라미터로 받은 값을 인스턴스의 member 프로퍼티에 설정할 수 있습니다.</p>\n</li>\n<li><p>extends 키워드 기준으로 왼쪽의 Soccer 클래스가 서브클래스<br>오른쪽 Sports 클래스가 슈퍼클래스입니다. 즉, Soccer 클래스에서 Sports 클래스를 상속받습니다. this.ground에서 this는 생성한 인스턴스를 참조합니다.</p>\n<ul>\n<li>이 시점의 Soccer 클래스 구조입니다.    <img scr=\"/images/extendsSoccer.JPG\">\n</li>\n</ul>\n<ol>\n<li>Soccer.prototype에 setGround가 연결되어 있으며</li>\n<li>Soccer.prototype.&#95;&#95;proto&#95;&#95;에 Sports.prototype에 연결되어 있는 getMember가 첨부되어 있습니다.</li>\n<li>Soccer.&#95;&#95;proto&#95;&#95;에 Sports.prototype에 연결된 프로퍼티도 첨부되어 있습니다.</li>\n</ol>\n<ul>\n<li>이와 같이 extends 키워드는 서브클래스의 prototype에 &#95;&#95;proto&#95;&#95;를 만들고 여기에 슈퍼클래스의 prototype에 연결된 프로퍼티를 연결합니다.<br><del>슈퍼클래스의 prototype에 연결된 메서드를 복사하는 것이 아니라 공유합니다.</del><br>new Soccer()로 인스턴스를 생성할 때 Soccer.prototype에 연결된 프로퍼티를 사용하므로 서브클래스와 슈퍼클래스의 메서드가 인스턴스에 포함됩니다.</li>\n</ul>\n</li>\n<li><p>new Soccer(11)을 실행하면 다음의 순서와 방법으로 실행합니다.</p>\n<ol>\n<li>Soccer 클래스의 constructor가 호출됩니다.</li>\n<li>Soccer 클래스에는 constructor를 작성하지 않았습니다.</li>\n<li>슈퍼 클래스의 constructor가 호출되면서 11을 파라미터 값으로 넘겨줍니다.</li>\n<li>슈퍼 클래스의 constructor에서 this는 현재의 인스턴스를 참조하므로 인스턴스의 member 프로퍼티에 파라미터로 받은 11을 설정한 후 돌아오게 되며,</li>\n<li>생성한 인스턴스를 obj에 할당합니다.</li>\n</ol>\n<ul>\n<li><p>다음은 obj의 인스턴스 구조입니다.</p>\n<img src=\"/images/extendsObj.JPG\">\n</li>\n<li><p>인스턴스를 생성하는 주체는 서브 클래스입니다. new Sports()가 아닌 new Soccer()로 인스턴스를 생성합니다.</p>\n</li>\n<li><p>슈퍼 클래스의 constructor에서 this.member에 설정한 값이 인스턴스 프로퍼티로 설정됩니다.</p>\n</li>\n<li><p>&#95;&#95;proto&#95;&#95;에 서브 클래스의 prototype에 연결된 메서드가 첨부되었으며</p>\n</li>\n<li><p>&#95;&#95;proto&#95;&#95;에 슈퍼 클래스의 prototype에 연결된 메서드가 첨부됩니다.</p>\n</li>\n<li><p>메서드를 호출할 때 &#95;&#95;proto&#95;&#95;를 작성하지 않아도 되므로<br>setGround()와 getMember()를 인스턴스에서 직접 호출할 수 있습니다.</p>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li>obj.getMember()를 호출하면 우선 obj.&#95;&#95;proto&#95;&#95;에서 메서드를 찾습니다. 존재하지 않으면 obj.&#95;&#95;proto&#95;&#95;.&#95;&#95;proto&#95;&#95;에서 찾습니다. 메서드가 존재하면 호출됩니다.<br>이것이 자바스크립트의 상속 메커니즘 입니다.</li>\n</ol>\n<hr>\n<h2 id=\"super\">super 키워드</h2>\n\n<p>서브 클래스와 슈퍼 클래스에 같은 이름의 메서드가 존재하면 슈퍼 클래스의 메서드는 호출되지 않습니다.<br>이때 super 키워드를 사용하여 슈퍼 클래스의 메서드(혹은 함수)를 호출할 수 있습니다.</p>\n<p>서브 클래스 constructor에 super()를 작성하면 슈퍼 클래스의 constructor가 호출됩니다.<br>super.name()과 같이 super 키워드에 이어서 호출하려는 메서드 이름을 작성합니다.</p>\n<h3 id=\"메서드-오버라이딩\"><a href=\"#메서드-오버라이딩\" class=\"headerlink\" title=\"메서드 오버라이딩\"></a>메서드 오버라이딩</h3><p>서브 클래스와 슈퍼 클래스에 같은 이름의 메서드가 있을 때 서브 클래스의 메서드가 호출 되는 것을<br>메서드 오버라이딩(Overriding)이라고 합니다. 메서드 오버라이딩은 의도적인 접근 방식입니다.</p>\n<p>서브 클래스와 슈퍼 클래스의 같은 이름의 메서드가 같은 목적을 가진 것을 나타내면서<br>서브 클래스의 목적에 맞도록 보완할 때 사용합니다.(슈퍼 클래스의 메서드 기능을 사용하면서 서브 클래스에서 기능을 추가,변경할 때 사용합니다.)</p>\n<p>슈퍼 클래스와 서브 클래스의 메서드 기능/목적이 다른 경우에는 같은 이름을 사용하지 않습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>super-1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> setGround(ground)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.ground = ground;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Soccer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> setGround(ground)&#123;  </span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"keyword\">super</span>.setGround();  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.ground = ground;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Soccer();  </span><br><span class=\"line\">obj.setGround(<span class=\"string\">\"상암구장\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.ground);  </span><br><span class=\"line\"><span class=\"comment\">// 상암구장</span></span><br></pre></td></tr></table></figure>\n\n<p><del>Sports 클래스는 슈퍼 클래스 입니다. 상속을 해주지만 단독으로 인스턴스를 생성할 수도 있습니다.</del></p>\n<ul>\n<li><p>Class Sports{}에는 그라운드(setground)가 필요합니다.<br>Sports의 종목이 여러개라면 종목마다 그라운드(setGround)형태도 달라져야 할 수 있습니다.<br>그런 의미에서 setGround()메서드는 의미 없어 보일 수 있습니다.</p>\n</li>\n<li><p>하지만 Sports 클래스를 상속받는 서브 클래스에서 setGround를 오버라이딩 하면 일관성 있게<br>그라운드를 정의할 수 있습니다. 메서드 이름을 유지하면서 서브클래스 마다<br>적합한 그라운드(setGround)를 설정해 주는 것입니다.<br>이를 객체 지향에서 추상화(Abstraction)라고 합니다.</p>\n</li>\n</ul>\n<ol>\n<li><p>Soccer 클래스에서 Sports 클래스를 상속받습니다. Sports 클래스에 setGround()가 있으며<br>Soccer 클래스에도 있으므로 메서드가 오버라이딩 됩니다.<br>new Soccer()로 인스턴스를 생성한 후 setGround()를 호출하게 되면 서브클래스(Soccer)의<br>메서드가 호출됩니다. 이때 super.setGround()는 슈퍼클래스(Sports)의 setGround()를 호출합니다.</p>\n</li>\n<li><p>super.setGround()를 호출하면서 파라미터 값은 정해주지 않았습니다.<br>슈퍼클래스(Soccer)의 setGround()에서 this.ground에 undefined가 설정됩니다.<br>super.setGround()를 실행한 후 돌아오면 바로 다음 줄의 this.ground에서 파라미터로 받은 값을 설정합니다.</p>\n</li>\n<li><p>new Soccer()로 인스턴스를 생성하고 setGround()를 호출하면 인스턴스의 ground 프로퍼티에 파라미터 값이 설정됩니다. ground가 인스턴스 프로퍼티이므로 obj.ground로 값을 출력할 수 있습니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>super-2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(member)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.member = member;  </span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.member);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Soccer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"keyword\">constructor</span>(member)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">super</span>(member);  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.member = <span class=\"number\">456</span>;  </span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.member);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Soccer(<span class=\"number\">123</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 123  </span></span><br><span class=\"line\"><span class=\"comment\">// 456</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>new Soccer(123)을 실행하면 Soccer 클래스의 constructor가 호출됩니다.</p>\n</li>\n<li><p>constructor 첫째 줄의 super(member)를 실행하면 슈퍼 클래스의 constructor를<br>호출 하면서 파라미터로 받은 값을 넘겨줍니다. 슈퍼 클래스의 constructor를<br>호출하려면 서브클래스 constructor의 첫째 줄에 super()를 작성해야 합니다.</p>\n</li>\n</ol>\n<p><strong>super() 앞에 변수를 선언하거나 변수에 값을 할당하는 코드는 작성해도 되지만,</strong><br><strong>this 키워드는 super() 앞에 사용할 수 없습니다.</strong></p>\n<ol start=\"3\">\n<li>super()로 인해 constructor가 호출되면 this로 인스턴스를 참조할 수 있습니다.<br>따라서 파라미터로 받은 member 값을 인스턴스의 member 프로퍼티에 할당할 수 있습니다.</li>\n</ol>\n<hr>\n<h2 id=\"builtin\">빌트인 오브젝트 상속</h2>\n\n<p>extends 키워드로 Array 오브젝트 등의 빌트인 오브젝트를 상속받을 수 있습니다.<br>상속을 받지 않고 서브 클래스에서 빌트인 오브젝트의 메서드를 호출해도 되지만<br>상속 받는 것과 차이가 있습니다. 서브 클래스에서 빌트인 오브젝트를 상속받으면<br>빌트인 오브젝트의 메서드를 마치 서브 클래스에서 선언한 것처럼 사용할 수 있게 됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>builtin</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendArray</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">super</span>();  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> getTotal()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> total = <span class=\"number\">0</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> value <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>)&#123;  </span><br><span class=\"line\"> total += value;  </span><br><span class=\"line\"> &#125;;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> total;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> ExtendArray();  </span><br><span class=\"line\"><span class=\"number\">3.</span> obj.push(<span class=\"number\">10</span>, <span class=\"number\">20</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(obj.getTotal());  </span><br><span class=\"line\"><span class=\"comment\">// 30</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>클래스 ExtendArray 에 빌트인 오브젝트인 Array 오브젝트를 상속받았습니다.<br>new 연산자로 인스턴스를 생성하면 인스턴스는 Array 오브젝트의 특징을 갖게됩니다.<br>따라서 인스턴스에서 push()와 같은 Array 메서드를 직접 호출할 수 있습니다.<br>“[].push()”형태가 아닌 “인스턴스.push()”형태로 호출할 수 있습니다.<br>이 형태의 차이에 상속 받는 목적이 담겨있다고 할 수 있습니다.</p>\n</li>\n<li><p>new ExtendArray()를 실행하면 아래에 작성한 constructor가 호출됩니다.</p>\n<blockquote>\n<p>constructor(){<br>super();<br>}</p>\n</blockquote>\n<p>super()가 슈퍼 클래스의 constructor를 호출하므로 Array 오브젝트 constructor가<br>호출됩니다.</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>obj 인스턴스에 push()메서드가 상속되어 있으므로 obj.push(10,20)형태로 호출할 수 있습니다.<br>obj.push(10, 20) 과 [].push(10, 20)에서 obj 인스턴스가 Array 리터럴[]에 해당됩니다.<br>따라서 obj 인스턴스에 10 과 20를 설정하는 것은 Array 인스턴스에 설정하는 것과 같습니다.<br>이것이 빌트인 오브젝트를 상속받는 목적 중의 하나입니다.</p>\n</li>\n<li><p>obj.getTotal()을 호출하면 for-of 문으로 [10, 20]을 합산하여 반환합니다.<br><del>값을 합산해주는 빌트인 함수도 있지만 for(var value of this)문에서<br>this를 다루기 위해 의도적으로 for-of 문을 사용했습니다.</del><br>this가 obj 인스턴스를 참조합니다. obj 인스턴스는 [10, 20]값이 설정되어 있으며<br>Array 오브젝트를 상속받은 상태 이므로 length 프로퍼티를 갖고있습니다.<br>즉, 이터레이션을 수행할 수 있는 조건을 충족합니다.</p>\n<blockquote>\n<p>for(var value of [10, 20]){<br>total += value;<br>} return total</p>\n</blockquote>\n</li>\n</ol>\n<p>위 헝태가 되어 엘리먼트(10, 20)를 하나씩 읽어가면서 for-of 문을 반복합니다.</p>\n<hr>\n<h2 id=\"Object_super\">Object에서 super 사용</h2>\n\n<p>두 개의 Object 오브젝트가 연결된 구조에서 super.name() 형태로 슈퍼 오브젝트의<br>메서드를 호출할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Sports = &#123;  </span><br><span class=\"line\"> getTitle()&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Sports\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> Soccer = &#123;  </span><br><span class=\"line\"> getTitle()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">super</span>.getTitle();  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Soccer\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">Object</span>.setPrototypeOf(Soccer, Sports);  </span><br><span class=\"line\"><span class=\"number\">2.</span> Soccer.getTitle();  </span><br><span class=\"line\"><span class=\"comment\">//Sports  </span></span><br><span class=\"line\"><span class=\"comment\">//Soccer</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Object.setPrototypeOf()을 실행하면 Soccer.&#95;&#95;proto&#95;&#95;에<br>Sports 오브젝트의 프로퍼티가 첨부됩니다.<br>Object 오브젝트가 대상이므로 생성자 함수가 없지만,&#95;&#95;proto&#95;&#95;에 프로퍼티가 첨부되는 것이 상속 구조(형태)입니다.</p>\n</li>\n<li><p>Soccer.getTitle();이 호출되면, 첫째 줄에서 super.getTitle()을 호출합니다.<br>상속을 하면 &#95;&#95;proto&#95;&#95;로 계층을 만들고,&#95;&#95;proto&#95;&#95;에 상속받을 오브젝트의 프로퍼티를 첨부하므로, super는 한 단계 아래의 &#95;&#95;proto&#95;&#95;를 참조하는 것과 같습니다.</p>\n</li>\n</ol>\n<p>현재 Soccer.&#95;&#95;proto&#95;&#95;에 Sports 오브젝트의 getTitle()이 첨부되어 있습니다.<br>따라서 super.getTitle()을 호출하면, super가 Soccer.&#95;&#95;proto&#95;&#95;를 참조하므로<br>Sports 오브젝트의 getTitle()이 호출됩니다.  </p>\n<p><strong>이와 같이 Object.setPrototypeOf()으로 &#95;&#95;proto&#95;&#95;구조를 만들고 상속받을 오브젝트의 프로퍼티를 첨부하면, super키워드로 상속 계층 구조에 있는 메서드를 호출할 수 있습니다.</strong></p>\n<hr>\n<h2 id=\"static\">static 키워드</h2>\n\n<p>클래스에 static(정적) 메서드를 정의합니다.</p>\n<blockquote>\n<p>static methodName() { … }</p>\n</blockquote>\n<p>prototype에 연결된 메서드는 인스턴스를 생성하여 호출 하지만,<br>static 메서드는 인스턴스를 생성하지않고 클래스에 직접 연결하여 호출합니다.</p>\n<p>static 메서드는 prototype에 연결되지 않으므로 인스턴스에서 호출할 수 없습니다.<br>클래스 이름을 지정하여 static 메서드를 호출해야 합니다.</p>\n<ul>\n<li>중요 포인트<br>엔진이 class 키워드를 만나면 클래스 안에 static 메서드 작성 여부를 체크합니다.<br>static 메서드가 존재한다면 이를 Function 오브젝트로 생성합니다.<br>(메서드를 호출하기 위해서는 메서드가 Function 오브젝트여야 하고,<br>이렇게 생성함으로써 클래스 아래의 static메서드를 호출할 수 있게 합니다.)</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>자바스크립트 Function 오브젝트 생성 형태</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// Function 오브젝트입니다.  </span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// Function 오브젝트가 아닙니다.  </span></span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>function 안에 function은 Function 오브젝트로 생성하지 않고,<br>function이 호출되어 안에 있는 function으로 들어갔을 때<br>Function 오브젝트를 생성합니다.<br>따라서 function을 호출하지 않으면 안에 있는 function은<br>아무것도 아닙니다. 그저 작성돼있는 함수 입니다.<br>이 점이 static 키워드를 사용한 메서드와 차이점 입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> getGround() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"상암구장\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(Sports.getGround());</span><br></pre></td></tr></table></figure>\n\n<p>getGround(){} 앞에 static을 작성하여 static메서드로 선언했습니다.</p>\n<ol>\n<li>Sports는 클래스 이름이고 getGround()는 static메서드 입니다.<br>이와 같이 앞에 클래스 이름을 작성하고 이어서 static메서드를 작성하여 호출합니다.</li>\n</ol>\n<hr>\n<h2 id=\"Class_Hoisting\">Class 호이스팅</h2>\n\n<p>클래스는 호이스팅(Hoisting)이 되지 않습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Class  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = Member;  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> getMember()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"member\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Member.getMember()); <span class=\"comment\">// member  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.getMember()); <span class=\"comment\">// TypeError  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// function과 비교  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = Member2;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Member2</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"member2\"</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Member2());<span class=\"comment\">// member2  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result2());<span class=\"comment\">// member2</span></span><br></pre></td></tr></table></figure>\n\n<p>호이스팅 된다면 Member 클래스가 result 변수에 할당됩니다.<br>호이스팅 되지않으면 Member를 인식하지 못합니다. Error</p>\n<ul>\n<li><p>클래스는 호이스팅 되지않아 result에 할당할 Member를 인식하지 못합니다.<br>result에 Member 값을 넣으려면 클래스 문이 완전히 끝난 뒤에 작성해야합니다.</p>\n</li>\n<li><p>function은 호이스팅 되므로 result2에 Member2를 인식하여 할당할 수 있습니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"computed_name\">computed name</h2>\n\n<p>클래스의 메서드 이름을 조합(computed name)하여 작성할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>computed name</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> type = <span class=\"string\">\"Type\"</span>;  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> [<span class=\"string\">\"get\"</span> + type](kind)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> kind ? <span class=\"string\">\"스포츠\"</span> : <span class=\"string\">\"음악\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(Sports[<span class=\"string\">\"get\"</span> + type](<span class=\"number\">1</span>)); <span class=\"comment\">// 스포츠  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Sports.getType(<span class=\"number\">1</span>)); <span class=\"comment\">// 스포츠</span></span><br></pre></td></tr></table></figure>\n\n<p>변수 type 에 문자열 값 “Type”을 할당해 줬습니다.<br>static 메서드 []안에 문자열 “get” 과 클래스 밖에 작성된 type 변수 값을<br>작성해줬습니다. static메서드의 이름이 getType이 됩니다.<br>이와 같이 static 메서드 []안에 조합할 이름을 작성합니다.</p>\n<ol>\n<li>문자열 “get”과 변수인 type을 조합하여 호출합니다.<br>파라미터 값이 1 (true)이므로 호출된 getType()에서 “스포츠”를 반환합니다.<br>물론 console.log(Sports.getType(1)); 형태로 호출할 수 도 있습니다.</li>\n</ol>\n<hr>\n<h2 id=\"this\">this</h2>\n\n<p>static 메서드에서 this는 클래스 오브젝트를 참조합니다.<br>constructor 안에서 this.constructor.name()형태로 static 메서드를 호출할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>this 예제</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> setGround(ground)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.ground = ground;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> getGround()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.ground;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">Sports.setGround(<span class=\"string\">\"상암구장\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Sports.getGround());  </span><br><span class=\"line\"><span class=\"comment\">// 상암구장</span></span><br></pre></td></tr></table></figure>\n\n<p>Sports.setGround(“상암구장”)를 실행하면 static메서드인 setGround()가 호출됩니다.<br>this.ground에서 this가 Sports 클래스를 참조하므로 Sports 클래스에<br>{ground: “상암구장”} 형태로 설정됩니다.</p>\n<p>Sports.getGround()를 실행하면 getGround() 정적 메서드가 호출됩니다.<br>this.Ground에서 this가 Sports 클래스를 참조하므로 setGround()에서<br>Sports 클래스에 설정한 ground 프로퍼티 값을 구할 수 있습니다. //상암구장</p>\n<figure class=\"highlight js\"><figcaption><span>this 호출 예제</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span></span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(Sports.getGround());  </span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.constructor.getGround());  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> getGround()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"상암구장\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Sports();</span><br></pre></td></tr></table></figure>\n\n<p>new Sports()를 실행하면 constructor가 호출됩니다.<br>constructor 블록{}안에서 static메서드인 getGround를 호출하며,<br>this.constructor 형태도 사용하고 있습니다.</p>\n<ol>\n<li><p>Sports 클래스에 static 메서드로 getGround()를 작성했으므로<br>Sports.getGround() 형태로 호출할 수 있습니다.<br>constructor 블록{} 아래에 getGround()가 작성되어 있습니다만<br>이미 Function 오브젝트로 생성된 상태이므로 호출이 됩니다.</p>\n</li>\n<li><p>constructor가 Sports 클래스를 참조하며 인스턴스의 &#95;&#95;proto&#95;&#95;에<br>constructor가 첨부되어 있으므로 this.constructor.getGround() 형태로<br>static메서드를 호출할 수 있습니다. 구조는 다음 사진과 같습니다.</p>\n<img src=\"/images/ClassThisInstance.JPG\">\n</li>\n</ol>\n<ul>\n<li>this.getGround()형태로는 호출할 수 없습니다. (//undefined)<br>this가 new Sport()로 생성한 인스턴스를 참조하고,<br>getGround는 static메서드 이므로 인스턴스에 존재하지 않기 때문입니다.</li>\n</ul>\n<hr>\n<h2 id=\"generator\">제너레이터</h2>\n\n<p>클래스 안에 제너레이터 함수를 작성할 수 있습니다.<br>클래스 안에 작성한 제너레이터 함수는 prototype에 연결됩니다.<br>따라서 static 메서드로 호출할 수 없고 인스턴스를 생성하여 호출해야 합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span>&#123;  </span><br><span class=\"line\"> *gen() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">10</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">20</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Member();  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = obj.gen();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 10, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 20, done: false&#125;</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">new Member()로 클래스 인스턴스를 생성 합니다. 변수 obj에 할당됩니다.  </span></span><br><span class=\"line\"><span class=\"string\">genObj 변수에 obj.gen 메서드를 할당합니다.  </span></span><br><span class=\"line\"><span class=\"string\">genObj.next()로 호출할 수 있게됩니다.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* * *</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&lt;h2 id=\"new_target\"&gt;new.target&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">new.target은 메타(meta) 프로퍼티로 생성자 함수와 클래스에서  </span></span><br><span class=\"line\"><span class=\"string\">constructor를 참조합니다. new 연산자로 인스턴스를 생성하지 않으면  </span></span><br><span class=\"line\"><span class=\"string\">new.target 값은 undefined 입니다.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">let</span> sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span>.target);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">sports();  </span><br><span class=\"line\"><span class=\"keyword\">new</span> sports();  </span><br><span class=\"line\"><span class=\"comment\">// undefined  </span></span><br><span class=\"line\"><span class=\"comment\">/* function() &#123;  </span></span><br><span class=\"line\"><span class=\"comment\"> console.log(new.target);  </span></span><br><span class=\"line\"><span class=\"comment\">&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>sports(); 와 같이 new 연산자를 사용하지 않고 호출하면 new.target값은 undefined 입니다.</p>\n<p>new sports();로 호출하면 new.target은 constructor를 참조합니다.<br>sports 함수에 constructor를 작성하지 않았으므로 디폴트 constructor가 호출됩니다.<br>디폴트 constructor = (function: Object() {native code})<br>constructor가 sports 전체를 참조하므로 sports 함수의 코드가 출력됩니다.</p>\n<h3 id=\"name-프로퍼티\"><a href=\"#name-프로퍼티\" class=\"headerlink\" title=\"name 프로퍼티\"></a>name 프로퍼티</h3><p>ES6는 클래스, 함수 오브젝트에 name 프로퍼티가 존재하며 이름이 설정됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Sports:\"</span>, <span class=\"keyword\">new</span>.target.name);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Soccer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">super</span>();  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Soccer:\"</span>, <span class=\"keyword\">new</span>.target.name);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> sportsObj = <span class=\"keyword\">new</span> Sports();  </span><br><span class=\"line\"><span class=\"keyword\">let</span> soccerObj = <span class=\"keyword\">new</span> Soccer();  </span><br><span class=\"line\"><span class=\"comment\">// Sports: Sports  </span></span><br><span class=\"line\"><span class=\"comment\">// Sports: Soccer  </span></span><br><span class=\"line\"><span class=\"comment\">// Soccer: Soccer</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>new Sports()를 호출하면 Sports 클래스이므로 클래스 name 프로퍼티에 “Sports”가<br>설정되어 있습니다. constructor에서 new.target은 constructor를 참조하므로<br>Sports 클래스의 name 프로퍼티 값 “Sports”가 출력됩니다.</p>\n</li>\n<li><p>new Soccer()를 호출하면 super()로 인해 Sports의 constructor가 호출됩니다.<br>Sports의 constructor에서 new.target은 super()로 호출한 Soccer의<br>constructor를 참조합니다. 따라서 new.target.name 값으로 Sports가 아닌 Soccer가 출력됩니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"Image_Object\">Image 오브젝트 상속</h2>\n\n<ul>\n<li><p>DOM(Document Object Model)에서 제공하는 Image 인터페이스, Audio 인터페이스 등을 상속받을 수 있습니다.<br>빌트인 Array 오브젝트를 상속받으면 Array 오브젝트 특징을 갖듯이<br>상속받은 인터페이스 특징을 갖습니다.</p>\n</li>\n<li><p>DOM의 Image 인터페이스는 웹 페이지에 png 파일과 같은 이미지 파일을 표현하기 위한 속성을 제공합니다.<br>인터페이스는 객체지향 용어로 이 자체를 그대로 사용할 수 없고 오브젝트로 변환하여 사용해야 합니다.<br>DOM은 오브젝트를 제공하지 않고 인터페이스를 제공하는데,이는 자바스크립트뿐만 아니라 Java등의 다른 언어에서도 사용하기 때문입니다. 각 언어에서 DOM인터페이스를 언어에 맞게 변환하여 사용합니다.</p>\n</li>\n</ul>\n<p>인터페이스를 오브젝트로 변환하려면 extends 키워드를 사용합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>extends-image</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendsImage</span> <span class=\"keyword\">extends</span> <span class=\"title\">Image</span></span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">super</span>();  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"number\">2.</span> setProperty(image)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.src = image.src;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.alt = image.alt;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.title = image.title;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> imageObj = <span class=\"keyword\">new</span> ExtendsImage();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> properties = &#123;  </span><br><span class=\"line\"> src: <span class=\"string\">\"file/rainbow.png\"</span>,  </span><br><span class=\"line\"> alt: <span class=\"string\">\"나무와 집이 있고 그 위에 무지개가 있는 모습\"</span>,  </span><br><span class=\"line\"> title: <span class=\"string\">\"무지개\"</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">imageObj.setProperty(properties);  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"body\"</span>).appendChild(imageObj);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Image 오브젝트를 extends 키워드로 상속받습니다.<br>ExtendsImage 클래스는 Image 특성을 갖게됩니다.<br>즉, &lt; img &gt; 엘리먼트의 속성을 직접 사용할 수 있습니다.<br>또한 this로 엘리먼트 속성에 접근할 수 있습니다.</p>\n</li>\n<li><p>파라미터로 받은 &lt; img &gt; 속성 값을 this가 참조하는 imageObj 인스턴스에 설정합니다.</p>\n</li>\n<li><p>&lt; body&gt; 엘리먼트에 자식 요소로 imageObj를 첨부합니다.<br>body 엘리먼트에 imageObj 안에 있는 img 엘리먼트 속성도 첨부 횝니다.</p>\n</li>\n</ol>\n<p>웹페이지에 이미지가 표시되고 그 속성은 다음과 같습니다.</p>\n<blockquote>\n<p>&lt; img src = “file/rainbow.png”<br>alt= “나무와 집이 있고 그 위에 무지개가 있는 모습”<br>title= “무지개” &gt;</p>\n</blockquote>"},{"title":"BOM (브라우저 객체 모델)","date":"2020-03-04T01:18:19.000Z","disqusId":"tunas-blog-1","_content":"\n브라우저에 내장된 객체를\n\n**브라우저 객체(BOM: Browser Object Model)**라고 합니다.\n\nwindow는 브라우저 객체의 최상위 객체 입니다.\n\nwindow 객체는 여러가지 하위 객체를 포함하고 있습니다.\n\n<!-- more -->\n\n* * *\n\n## window 객체 메서드 종류\n--------------------------------------------------------\n\n| 종류           | 설명                                             |\n|----------------|--------------------------------------------------|\n| open()         | 새 창(popup)을 열 때 사용                        |\n| alert()        | 경고 창을 띄울때 사용 (window객체 없이 작성가능) |\n| prompt()       | 질의응답 창을 띄움 (window객체 없이 작성가능)    |\n| confirm()      | 확인/취소 창을 띄움 (window객체 없이 작성가능)   |\n| scrollBy(x, y) | 윈도우 스크롤의 위치를 상대적으로 이동           |\n| scrollTo(x, y) | 윈도우 스크롤의 위치를 절대적으로 이동           |\n| setInterval()  | 일정 간격으로 지속적으로 실행문을 실행시킴       |\n| setTimeout()   | 일정 간격으로 한번만 실행문을 실행시킴           |\n| focus()        | 윈도우에 초점 맞춤                               |\n| blur()         | 윈도우에 맞춘 초점 제거                          |\n| close()        | 윈도우 닫음                                      |\n| window.onload  | 윈도우 객체 로드 완료시 실행되는 객체            |\n| moveTo(x, y)   | 윈도우의 위치를 절대적으로 이동                  |\n| moveBy(x, y)   | 윈도우의 위치를 상대적으로 이동                  |\n| resizeTo(x, y) | 윈도우의 크기를 절대적으로 지정                  |\n| resizeBy(x, y) | 윈도우의 크기를 상대적으로 지정                  |\n\n\n* * *\n\n### open()\n\nopen()는 새 브라우저 창을 띄울 때 사용합니다.  \n사이트에서 팝업 창을 띄울 때 자주 사용되는 메서드 입니다.\n\n    기본형\n    window.open(\"url\",\"name\",\"specs,replace\");\n\n사용예시\n\n```js\nwindow.open(\"https://www.google.com\",\"google\",  \n\"width=400, height=500, left=50, top=10,scrollbars=no,toolbars=no,location=no\");  \n```\n\n* * *\n\n#### 1.1. 반환값(ret)\n\n새로 만들어진 창 객체가 반환됩니다.\n\n창의 생성에 실패하면 null을 반환합니다.\n\n이 객체를 통해서 새창을 제어할 수 있습니다.\n\n예로 ret.close(); 로 창을 닫을 수 있습니다.\n\n#### 1.2. url\n\n새창에 보여질 주소 입니다.\n\n선택적인 값으로 비워두면 빈창(about:blank)이 보입니다.\n\n    빈 창을 열고 내용을 동적으로 적을 수 도 있습니다.\n    var win = window.open(\"\", \"PopupWin\", \"width=500,height=600\");\n    win.document.write(\"<p>새창에 표시될 내용 입니다.</p>\");\n\n#### 1.3. name\n\n새로 열릴 참의 속성 또는 창의 이름을 지정합니다.\n\n선택적인 값으로 기본값은 “_blank” 입니다.\n\n사용 가능한 값을 다음과 같습니다.\n\n*   _blank : 새 창에 열립니다. 이것이 기본값입니다.\n    \n*   _parent : 부모 프레임에 열립니다.\n    \n*   _self : 현재 페이지를 대체합니다.\n    \n*   _top : 로드된 프레임셋을 대체합니다.\n    \n*   name(임의의 이름) : 새 창이 열리고 창의 이름을 지정합니다.  \n    동일한 이름에 다시 open() 을 하면 기존의 열린창의 내용이 바뀝니다.  \n    다른 이름을 사용하면 또다른 새창이 열립니다.\n    \n\n#### 1.4 specs\n\n\n| 속성        | 설명                                                   |\n|-------------|--------------------------------------------------------|\n| width       | 새 윈도우의 너비                                       |\n| height      | 새 윈도우의 높이                                       |\n| left        | 왼쪽 기준 팝업 위치 지정 **음수는 사용할 수 없습니다** |\n| top         | 상단 기준 팝업 위치 지정 **음수는 사용할 수 없습니다** |\n| status      | 상태 표시줄 유무                                       |\n| menubar     | 메뉴바 유무                                            |\n| resizable   | 화면 크기 조절 가능 여부                               |\n| location    | 주소 표시줄 유무 **Opera에서만 작동**                  |\n| scrollbars  | 스크롤바 유무 **IE,Firefox,Opera에서 작동**            |\n| toolbar     | 툴바 유무 **IE,Firefox에서 작동**                      |\n| resizable   | 창의 리사이즈 가능 유무 **IE에서만 작동**              |\n| fullscreen  | 전체화면모드. **IE에서만 작동**                        |\n| channelmode | 전체화면으로 창이 열립니다. **IE에서만 작동**          |\n\n\n#### 1.5 replace\n\n히스토리 목록에 새 항목을 만들지 현재 항목을 대체할지 지정합니다.\n\n*   true : 현재 히스토리를 대체합니다.\n    \n*   false : 히스토리에 새 항목을 만듭니다.\n    \n\n*   출처: [https://www.w3schools.com/jsref/met_win_open.asp](https://www.w3schools.com/jsref/met_win_open.asp)\n\n* * *\n\n### moveTo(), moveBy(), resizeTo(), resizeBy()\n\n* * *\n\n* moveTo() 메서드는 브라우저 창의 위치를 이동시킬때 사용합니다.\n\n    moveTo(100,200);\n    //브라우저 창을 x100,y200 위치에서 뜨게 합니다.\n\n* * *\n\n* moveBy() 메서드는 현재 브라우저 창의 위치를 기준으로 이동 시킵니다.\n\n    moveBy(100,200);\n    //실행될 때 마다 x100,y200만큼 이동합니다.\n\n* * *\n\n* resizeTo() 메서드는 브라우저 창의 너비와 높이를 바꿀때 사용합니다.\n\n    resizeTo(200,300);\n    //width 200px, height 300px로 바꿉니다.\n\n* * *\n\n* resizeBy() 메서드는 현재 창을 기준으로 지정된 픽셀 수만큼  \n창의 오른쪽 아래 모서리를 이동합니다.  \n**왼쪽 상단 모서리는 이동하지 않습니다 (원래 좌표로 유지됨).**\n\n    resizeBy(200,300);\n    //오른쪽 아래 모서리를 width 200px, height 300px 만큼 늘립니다.\n\n* * *\n\n### senInterval(), clearInterval()\n\n* * *\n\n**setInterval()**\n\n*   setInterval() 메소드는 function을 호출하거나\n    \n    일정한 간격 (밀리 초)으로 실행문을 반복하여 실행시킬 때 사용합니다.\n    \n*   setInterval() 메소드는 clearInterval()이 호출되거나\n    \n    window창이 닫힐 때까지 계속됩니다.\n    \n*   setInterval()에 의해 리턴 된 ID 값은\n    \n    clearInterval() 메소드의 매개 변수로 사용됩니다.\n    \n*   지정된 밀리 초 후에 함수를 한 번만 실행하려면 setTimeout() 메소드를 사용합니다.\n    \n*   1000ms = 1 초\n    \n*   4.0버젼 이전의 IE,Opera에서 실행되지 않을 수 있습니다.\n    \n\n    기본형\n    var 참조변수=setInterval(function, milliseconds, param1, param2, ...)\n\n#### 1.1 function\n\n필수 항목입니다. 실행될 기능(스크립트 실행문)항목 입니다.\n\n#### 1.2 milliseconds\n\n필수 할목입니다. 코드 실행 빈도에 대한 간격 (밀리 초)입니다.\n\n값이 10보다 작은 경우 값 10이 사용됩니다.\n\n#### 1.3 param\n\n선택 옵션입니다.\n\n함수에 전달할 추가 매개 변수가 있는 경우 사용합니다.  \n**IE9 및 이전 버전에서는 지원되지 않음**\n\n* * *\n\n**clearInterval()**\n\nclearInterval() 메소드는 setInterval()로 설정된 타이머를 지웁니다.\n\n*   clearInterval() 메소드를 사용하려면 setInterval() 메소드를 작성할 때  \n    변수를 선언 해줘야 합니다.\n\n```js\nmyVar = setInterval(\"javascript function\", milliseconds);  \n// clearInterval에 setInterval 변수를 선언해 줌으로써  \n// setInterval을 중지 할 수 있습니다.  \nclearInterval(myVar);  \n```\n\n* * *\n\n### setTimeout(), clearTimeout()\n\n* * *\n\nsetTimeout() 메서드는 일정한 간격 후 스크립트 실행문을\n\n**단 한번만 실행시킵니다.**\n\n반복되길 원하면 setInterval()을 사용합니다.\n\nsetTimeout()변수가 실행되지 않길 원하면 clearTimeout()을 사용합니다.\n\n* * *\n\n    기본형\n    var(참조변수)=setTimeout(function, milliseconds, param1, param2, ...)\n\n* * *\n\nsetTimeout()의 milliseconds는  \n코드를 실행하기전에 대기할 밀리 초를 뜻합니다.  \nsetInterval()의 mliiiseconds과 다르게 생략 할 수 있습니다.  \n생략하게 되면 0값을 갖게되어 바로 실행됩니다.\n\n* * *\n\nclearTimeout() 메서드는 아직 실행 되지않은 setTimeout()을 취소합니다.\n\n    clearTimeout(id_of_settimeout);\n\n* * *\n\n### screen\n\nscreen객체는 사용자의 모니터 정보(속성)을 제공하는 객체입니다.\n\n    screen.속성; 으로 사용합니다.\n\n\n| 속성        | 설명                                              |\n|-------------|---------------------------------------------------|\n| availHeight | 윈도우 작업표시줄을 제외한 스크린 높이 값을 반환. |\n| availWidth  | 윈도우 작업표시줄을 제외한 스크린 너비 값을 반환. |\n| height      | 화면의 총 높이값을 반환.                          |\n| width       | 화면의 총 너비값을 반환.                          |\n| colorDepth  | 사용자 모니터가 표현 가능한 컬러 bit를 반환.      |\n| pixelDepth  | 화면의 색상 해상도 (픽셀 당 비트 수)를 반환.      |\n\n* * *\n\n### location\n\nlocation 객체는 사용자 브라우저 주소창에 url정보(속성)와\n\n새로고침 기능(메서드)를 제공하는 객체 입니다.\n\n    location.속성;\n    또는\n    location.메서드() 으로 사용합니다.\n\n\n**location 객체 속성**\n\n| 속성     | 설명                                                       |\n|----------|------------------------------------------------------------|\n| hash     | URL의 **앵커 부분 (#)**을 설정하거나 반환합니다.           |\n| host     | URL의 **호스트 이름과 포트 번호**를 설정하거나 반환합니다. |\n| hostname | URL의 **호스트 이름**을 설정하거나 반환합니다.             |\n| href     | **주소 영역에 참조 주소**를 설정하거나 URL을 반환합니다.   |\n| origin   | URL의 **프로토콜, 호스트 이름 및 포트 번호**를 반환합니다. |\n| pathname | URL의 **경로 이름(pathname)**을 설정하거나 반환합니다.     |\n| port     | URL의 **포트 번호**를 설정하거나 반환합니다.               |\n| protocol | URL의 **프로토콜**을 설정하거나 반환합니다.                |\n| search   | URL의 **쿼리 값**을 설정하거나 반환합니다.                 |\n\n\n**location 객체 메서드**\n\n| 종류      | 설명                                              |\n|-----------|---------------------------------------------------|\n| assign()  | 새 문서(페이지)를 로드 합니다.                    |\n| reload()  | 현재 문서(페이지)를 새로고침 합니다.              |\n| replace() | 현재 문서(페이지)를 새 문서(페이지)로 교체합니다. |\n\n\n* * *\n\n### history\n\nhistory 객체에는 브라우저 창 내에서 사용자가 방문한 URL이 포함됩니다.\n\n\n| 속성                      | 설명                                                                                                                             |\n|---------------------------|----------------------------------------------------------------------------------------------------------------------------------|\n| History.length            | 현재 페이지를 포함해, 방문 기록에 저장된 목록의 개수를 나타내는 정수를 반환합니다.                                               |\n| History.scrollRestoration | 기록 탐색 시 **스크롤 위치 복원 여부**를 명시할 수 있습니다. 가능한 값은 auto와 manual입니다.                                    |\n| History.state             | 기록 스택 최상단의 상태를 나타내는 값을 반환합니다.**popstate 이벤트를 기다리지 않고 현재 기록의 상태를 볼 수 있는 방법입니다.** |\n\n* * *\n\n\n\n| 메서드 종류            | 설명                                                                                                                                                                                                                                                                                                                                       |\n|------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| History.back()         | 세션 기록의 바로 뒤 페이지로 이동하는 비동기 메서드입니다. 브라우저의 뒤로 가기 버튼을 눌렀을 때, 그리고 history.go(-1)을 사용했을 때와 같습니다.**참고**: 세션 기록의 제일 첫 번째 페이지에서 호출해도 오류는 발생하지 않습니다.                                                                                                          |\n| History.forward()      | 세션 기록의 바로 앞 페이지로 이동하는 비동기 메서드입니다. 브라우저의 앞으로 가기 버튼을 눌렀을 때, 그리고 history.go(1)을 사용했을 때와 같습니다.**참고**: 세션 기록의 제일 마지막 페이지에서 호출해도 오류는 발생하지 않습니다.                                                                                                          |\n| History.go()           | 현재 페이지를 기준으로, 상대적인 위치에 존재하는 세션 기록 내 페이지로 이동하는 비동기 메서드입니다. 예를 들어, 매개변수로 -1을 제공하면 바로 뒤로, 1을 제공하면 바로 앞으로 이동합니다.**세션 기록의 범위를 벗어나는 값을 제공하면 아무 일도 일어나지 않습니다. 매개변수를 제공하지 않거나, 0을 제공하면 현재 페이지를 다시 불러옵니다.** |\n| History.pushState()    | 주어진 데이터를 지정한 제목(제공한 경우 URL도)으로 방문 기록 스택에 넣습니다. 데이터는 DOM이 불투명(opaque)하게 취급하므로, 직렬화 가능한 모든 JavaScript 객체를 사용할 수 있습니다. 참고로, Safari를 제외한 모든 브라우저는 title 매개변수를 무시합니다.                                                                                  |\n| History.replaceState() | 세션 기록 스택의 제일 최근 항목을 주어진 데이터, 지정한 제목 및 URL로 대체합니다. 데이터는 DOM이 불투명(opaque)하게 취급하므로, 직렬화 가능한 모든 JavaScript 객체를 사용할 수 있습니다. 참고로, Safari를 제외한 모든 브라우저는 title 매개변수를 무시합니다.                                                                              |\n\n```html\n<button id=\"prevBtn\" onclick=\"history.back();\">  \n이전 페이지  \n</button>  \n  \n<button id=\"nextBtn\" onclick=\"history.forward();\">  \n다음 페이지  \n</button>  \n  \n<button onclick=\"history.go(-1);\">  \n1단계 이전 페이지  \n</button>  \n  \n<button onclick=\"history.go(-2);\">  \n2단계 이전 페이지  \n</button>  \n```\n\n* * *\n\n### navigator\n\nnavigator 객체는 현재 방문자가 사용하는 브라우저 정보와  \n운영체제의 정보를 제공하는 객체 입니다.\n\n> 기본형  \n> navigator.속성;\n\n| 속성          | 설명                                                                                                         |\n|---------------|--------------------------------------------------------------------------------------------------------------|\n| appCodeName   | 유저 브라우저의 내부 코드명을 반환합니다.                                                                    |\n| appName       | 유저 브라우저의 이름을 반환합니다.                                                                           |\n| appVersion    | 브라우저의 버젼 정보를 반환합니다.                                                                           |\n| cookieEnabled | 브라우저에서 쿠키가 활성화되어 있는지 확인합니다.쿠키가 무시되면false값 무시되지 않으면 true값을 반환합니다. |\n| geolocation   | **사용자의 위치를 ​​찾는 데 사용할 수있는 Geolocation 객체를 반환합니다.**                                     |\n| language      | 유저 브라우저의 언어를 반환합니다.                                                                           |\n| onLine        | 브라우저가 온라인 상태인지 확인합니다.                                                                       |\n| platform      | 브라우저 플랫폼을 나타내는 문자열을 반환합니다.                                                              |\n| product       | 유저 브라우저의 엔진 이름은 반환합니다.                                                                      |\n| userAgent     | 유저의 브라우저와 운영체제 종합 정보를 반환합니다.\n\n\n```js 예시\ndocument.write(\"appCodeName: \"+navigator.appCodeName,\"<br/>\");  \ndocument.write(\"appName: \"+navigator.appName,\"<br/>\");  \ndocument.write(\"appVersion: \"+navigator.appVersion,\"<br/>\");  \ndocument.write(\"language: \"+navigator.language,\"<br/>\");  \ndocument.write(\"product: \"+navigator.product,\"<br/>\");  \ndocument.write(\"platform: \"+navigator.platform,\"<br/>\");  \ndocument.write(\"userAgent: \"+navigator.userAgent,\"<br/>\");  \n```\n\n```html 총정리 실습\n<h1>운영체제 및 스크린 정보</h1>  \n<p id=\"info_wrap\"></p>  \n  \n<!-- 아래 버튼을 누를 때 마다 info1 함수의 중괄호 사이의   \n 자바스크립트 실행문 코드가 실행됩니다. -->  \n<button onclick=\"info1();\">운영체제 정보</button> <br />  \n<!-- 아래 버튼을 누를 때 마다 info2 함수의 중괄호 사이의   \n 자바스크립트 실행문 코드가 실행됩니다. -->  \n<button onclick=\"info2();\">스크린 정보</button> <br />  \n  \n<script type=\"text/javascript\">  \n /*① [운영 체제 정보]버튼을 누를 때마다 실행되는 함수입니다*/  \n function info1(){  \n /* 사용자 브라우저 운영체제 및 종합 정보를 반환하고,   \n 모두 소문자로 바꿉니다.*/  \n const os=navigator.userAgent.toLowerCase();  \n    \n // 요소값 중 id값이 \"info_wrap\"인 요소를 가져옵니다.  \n const info_wrap=document.getElementById(\"info_wrap\");  \n    \n /* navigator 객체를 이용해 반환받은 정보에   \n 다음과 같은 정보가 포함되어 있으면  \n 운영체제 명을 지정한 요소 사이에 텍스트로 출력합니다*/  \n if(os.indexOf(\"windows\")>=0){  \n info_wrap.innerHTML=\"윈도우\";  \n    \n }else if(os.indexOf(\"macintosh\")>=0){  \n info_wrap.innerHTML=\"맥킨토시\";  \n    \n }else if(os.indexOf(\"iphone\")>=0){  \n info_wrap.innerHTML=\"아이폰\";  \n    \n }else if(os.indexOf(\"android\")>=0){  \n info_wrap.innerHTML=\"안드로이드\";  \n }  \n //3초 후에  운영체제 정보를 지웁니다.  \n setTimeout(\"info_wrap.innerHTML=''\",3000);  \n }  \n    \n /*② [스크린 정보]버튼을 누를 때마다 실행되는 함수입니다*/  \n function info2(){  \n //사용자 스크린 너비와 높이값을 가져와 저장합니다.  \n const sc_w=screen.width;  \n const sc_h=screen.height;  \n // 요소 중 id가 \"info_wrap\"인 요소 객체를 가져옵니다.  \n const info_wrap=document.getElementById(\"info_wrap\");  \n    \n // 스크린 너비와 높이값을 텍스트로 출력합니다.  \n info_wrap.innerHTML=sc_w+\"X\"+sc_h;  \n //3초 후에 스크린 정보를 지웁니다.  \n setTimeout(\"info_wrap.innerHTml=''\",3000);  \n }  \n </script>  \n```","source":"_posts/BOM 브라우저 객체 모델.md","raw":"---\ntitle: BOM (브라우저 객체 모델)\ndate: 2020-03-04 10:18:19\ncategories: JavaScript\ndisqusId: tunas-blog-1\ntag: \n- JavaScript\n---\n\n브라우저에 내장된 객체를\n\n**브라우저 객체(BOM: Browser Object Model)**라고 합니다.\n\nwindow는 브라우저 객체의 최상위 객체 입니다.\n\nwindow 객체는 여러가지 하위 객체를 포함하고 있습니다.\n\n<!-- more -->\n\n* * *\n\n## window 객체 메서드 종류\n--------------------------------------------------------\n\n| 종류           | 설명                                             |\n|----------------|--------------------------------------------------|\n| open()         | 새 창(popup)을 열 때 사용                        |\n| alert()        | 경고 창을 띄울때 사용 (window객체 없이 작성가능) |\n| prompt()       | 질의응답 창을 띄움 (window객체 없이 작성가능)    |\n| confirm()      | 확인/취소 창을 띄움 (window객체 없이 작성가능)   |\n| scrollBy(x, y) | 윈도우 스크롤의 위치를 상대적으로 이동           |\n| scrollTo(x, y) | 윈도우 스크롤의 위치를 절대적으로 이동           |\n| setInterval()  | 일정 간격으로 지속적으로 실행문을 실행시킴       |\n| setTimeout()   | 일정 간격으로 한번만 실행문을 실행시킴           |\n| focus()        | 윈도우에 초점 맞춤                               |\n| blur()         | 윈도우에 맞춘 초점 제거                          |\n| close()        | 윈도우 닫음                                      |\n| window.onload  | 윈도우 객체 로드 완료시 실행되는 객체            |\n| moveTo(x, y)   | 윈도우의 위치를 절대적으로 이동                  |\n| moveBy(x, y)   | 윈도우의 위치를 상대적으로 이동                  |\n| resizeTo(x, y) | 윈도우의 크기를 절대적으로 지정                  |\n| resizeBy(x, y) | 윈도우의 크기를 상대적으로 지정                  |\n\n\n* * *\n\n### open()\n\nopen()는 새 브라우저 창을 띄울 때 사용합니다.  \n사이트에서 팝업 창을 띄울 때 자주 사용되는 메서드 입니다.\n\n    기본형\n    window.open(\"url\",\"name\",\"specs,replace\");\n\n사용예시\n\n```js\nwindow.open(\"https://www.google.com\",\"google\",  \n\"width=400, height=500, left=50, top=10,scrollbars=no,toolbars=no,location=no\");  \n```\n\n* * *\n\n#### 1.1. 반환값(ret)\n\n새로 만들어진 창 객체가 반환됩니다.\n\n창의 생성에 실패하면 null을 반환합니다.\n\n이 객체를 통해서 새창을 제어할 수 있습니다.\n\n예로 ret.close(); 로 창을 닫을 수 있습니다.\n\n#### 1.2. url\n\n새창에 보여질 주소 입니다.\n\n선택적인 값으로 비워두면 빈창(about:blank)이 보입니다.\n\n    빈 창을 열고 내용을 동적으로 적을 수 도 있습니다.\n    var win = window.open(\"\", \"PopupWin\", \"width=500,height=600\");\n    win.document.write(\"<p>새창에 표시될 내용 입니다.</p>\");\n\n#### 1.3. name\n\n새로 열릴 참의 속성 또는 창의 이름을 지정합니다.\n\n선택적인 값으로 기본값은 “_blank” 입니다.\n\n사용 가능한 값을 다음과 같습니다.\n\n*   _blank : 새 창에 열립니다. 이것이 기본값입니다.\n    \n*   _parent : 부모 프레임에 열립니다.\n    \n*   _self : 현재 페이지를 대체합니다.\n    \n*   _top : 로드된 프레임셋을 대체합니다.\n    \n*   name(임의의 이름) : 새 창이 열리고 창의 이름을 지정합니다.  \n    동일한 이름에 다시 open() 을 하면 기존의 열린창의 내용이 바뀝니다.  \n    다른 이름을 사용하면 또다른 새창이 열립니다.\n    \n\n#### 1.4 specs\n\n\n| 속성        | 설명                                                   |\n|-------------|--------------------------------------------------------|\n| width       | 새 윈도우의 너비                                       |\n| height      | 새 윈도우의 높이                                       |\n| left        | 왼쪽 기준 팝업 위치 지정 **음수는 사용할 수 없습니다** |\n| top         | 상단 기준 팝업 위치 지정 **음수는 사용할 수 없습니다** |\n| status      | 상태 표시줄 유무                                       |\n| menubar     | 메뉴바 유무                                            |\n| resizable   | 화면 크기 조절 가능 여부                               |\n| location    | 주소 표시줄 유무 **Opera에서만 작동**                  |\n| scrollbars  | 스크롤바 유무 **IE,Firefox,Opera에서 작동**            |\n| toolbar     | 툴바 유무 **IE,Firefox에서 작동**                      |\n| resizable   | 창의 리사이즈 가능 유무 **IE에서만 작동**              |\n| fullscreen  | 전체화면모드. **IE에서만 작동**                        |\n| channelmode | 전체화면으로 창이 열립니다. **IE에서만 작동**          |\n\n\n#### 1.5 replace\n\n히스토리 목록에 새 항목을 만들지 현재 항목을 대체할지 지정합니다.\n\n*   true : 현재 히스토리를 대체합니다.\n    \n*   false : 히스토리에 새 항목을 만듭니다.\n    \n\n*   출처: [https://www.w3schools.com/jsref/met_win_open.asp](https://www.w3schools.com/jsref/met_win_open.asp)\n\n* * *\n\n### moveTo(), moveBy(), resizeTo(), resizeBy()\n\n* * *\n\n* moveTo() 메서드는 브라우저 창의 위치를 이동시킬때 사용합니다.\n\n    moveTo(100,200);\n    //브라우저 창을 x100,y200 위치에서 뜨게 합니다.\n\n* * *\n\n* moveBy() 메서드는 현재 브라우저 창의 위치를 기준으로 이동 시킵니다.\n\n    moveBy(100,200);\n    //실행될 때 마다 x100,y200만큼 이동합니다.\n\n* * *\n\n* resizeTo() 메서드는 브라우저 창의 너비와 높이를 바꿀때 사용합니다.\n\n    resizeTo(200,300);\n    //width 200px, height 300px로 바꿉니다.\n\n* * *\n\n* resizeBy() 메서드는 현재 창을 기준으로 지정된 픽셀 수만큼  \n창의 오른쪽 아래 모서리를 이동합니다.  \n**왼쪽 상단 모서리는 이동하지 않습니다 (원래 좌표로 유지됨).**\n\n    resizeBy(200,300);\n    //오른쪽 아래 모서리를 width 200px, height 300px 만큼 늘립니다.\n\n* * *\n\n### senInterval(), clearInterval()\n\n* * *\n\n**setInterval()**\n\n*   setInterval() 메소드는 function을 호출하거나\n    \n    일정한 간격 (밀리 초)으로 실행문을 반복하여 실행시킬 때 사용합니다.\n    \n*   setInterval() 메소드는 clearInterval()이 호출되거나\n    \n    window창이 닫힐 때까지 계속됩니다.\n    \n*   setInterval()에 의해 리턴 된 ID 값은\n    \n    clearInterval() 메소드의 매개 변수로 사용됩니다.\n    \n*   지정된 밀리 초 후에 함수를 한 번만 실행하려면 setTimeout() 메소드를 사용합니다.\n    \n*   1000ms = 1 초\n    \n*   4.0버젼 이전의 IE,Opera에서 실행되지 않을 수 있습니다.\n    \n\n    기본형\n    var 참조변수=setInterval(function, milliseconds, param1, param2, ...)\n\n#### 1.1 function\n\n필수 항목입니다. 실행될 기능(스크립트 실행문)항목 입니다.\n\n#### 1.2 milliseconds\n\n필수 할목입니다. 코드 실행 빈도에 대한 간격 (밀리 초)입니다.\n\n값이 10보다 작은 경우 값 10이 사용됩니다.\n\n#### 1.3 param\n\n선택 옵션입니다.\n\n함수에 전달할 추가 매개 변수가 있는 경우 사용합니다.  \n**IE9 및 이전 버전에서는 지원되지 않음**\n\n* * *\n\n**clearInterval()**\n\nclearInterval() 메소드는 setInterval()로 설정된 타이머를 지웁니다.\n\n*   clearInterval() 메소드를 사용하려면 setInterval() 메소드를 작성할 때  \n    변수를 선언 해줘야 합니다.\n\n```js\nmyVar = setInterval(\"javascript function\", milliseconds);  \n// clearInterval에 setInterval 변수를 선언해 줌으로써  \n// setInterval을 중지 할 수 있습니다.  \nclearInterval(myVar);  \n```\n\n* * *\n\n### setTimeout(), clearTimeout()\n\n* * *\n\nsetTimeout() 메서드는 일정한 간격 후 스크립트 실행문을\n\n**단 한번만 실행시킵니다.**\n\n반복되길 원하면 setInterval()을 사용합니다.\n\nsetTimeout()변수가 실행되지 않길 원하면 clearTimeout()을 사용합니다.\n\n* * *\n\n    기본형\n    var(참조변수)=setTimeout(function, milliseconds, param1, param2, ...)\n\n* * *\n\nsetTimeout()의 milliseconds는  \n코드를 실행하기전에 대기할 밀리 초를 뜻합니다.  \nsetInterval()의 mliiiseconds과 다르게 생략 할 수 있습니다.  \n생략하게 되면 0값을 갖게되어 바로 실행됩니다.\n\n* * *\n\nclearTimeout() 메서드는 아직 실행 되지않은 setTimeout()을 취소합니다.\n\n    clearTimeout(id_of_settimeout);\n\n* * *\n\n### screen\n\nscreen객체는 사용자의 모니터 정보(속성)을 제공하는 객체입니다.\n\n    screen.속성; 으로 사용합니다.\n\n\n| 속성        | 설명                                              |\n|-------------|---------------------------------------------------|\n| availHeight | 윈도우 작업표시줄을 제외한 스크린 높이 값을 반환. |\n| availWidth  | 윈도우 작업표시줄을 제외한 스크린 너비 값을 반환. |\n| height      | 화면의 총 높이값을 반환.                          |\n| width       | 화면의 총 너비값을 반환.                          |\n| colorDepth  | 사용자 모니터가 표현 가능한 컬러 bit를 반환.      |\n| pixelDepth  | 화면의 색상 해상도 (픽셀 당 비트 수)를 반환.      |\n\n* * *\n\n### location\n\nlocation 객체는 사용자 브라우저 주소창에 url정보(속성)와\n\n새로고침 기능(메서드)를 제공하는 객체 입니다.\n\n    location.속성;\n    또는\n    location.메서드() 으로 사용합니다.\n\n\n**location 객체 속성**\n\n| 속성     | 설명                                                       |\n|----------|------------------------------------------------------------|\n| hash     | URL의 **앵커 부분 (#)**을 설정하거나 반환합니다.           |\n| host     | URL의 **호스트 이름과 포트 번호**를 설정하거나 반환합니다. |\n| hostname | URL의 **호스트 이름**을 설정하거나 반환합니다.             |\n| href     | **주소 영역에 참조 주소**를 설정하거나 URL을 반환합니다.   |\n| origin   | URL의 **프로토콜, 호스트 이름 및 포트 번호**를 반환합니다. |\n| pathname | URL의 **경로 이름(pathname)**을 설정하거나 반환합니다.     |\n| port     | URL의 **포트 번호**를 설정하거나 반환합니다.               |\n| protocol | URL의 **프로토콜**을 설정하거나 반환합니다.                |\n| search   | URL의 **쿼리 값**을 설정하거나 반환합니다.                 |\n\n\n**location 객체 메서드**\n\n| 종류      | 설명                                              |\n|-----------|---------------------------------------------------|\n| assign()  | 새 문서(페이지)를 로드 합니다.                    |\n| reload()  | 현재 문서(페이지)를 새로고침 합니다.              |\n| replace() | 현재 문서(페이지)를 새 문서(페이지)로 교체합니다. |\n\n\n* * *\n\n### history\n\nhistory 객체에는 브라우저 창 내에서 사용자가 방문한 URL이 포함됩니다.\n\n\n| 속성                      | 설명                                                                                                                             |\n|---------------------------|----------------------------------------------------------------------------------------------------------------------------------|\n| History.length            | 현재 페이지를 포함해, 방문 기록에 저장된 목록의 개수를 나타내는 정수를 반환합니다.                                               |\n| History.scrollRestoration | 기록 탐색 시 **스크롤 위치 복원 여부**를 명시할 수 있습니다. 가능한 값은 auto와 manual입니다.                                    |\n| History.state             | 기록 스택 최상단의 상태를 나타내는 값을 반환합니다.**popstate 이벤트를 기다리지 않고 현재 기록의 상태를 볼 수 있는 방법입니다.** |\n\n* * *\n\n\n\n| 메서드 종류            | 설명                                                                                                                                                                                                                                                                                                                                       |\n|------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| History.back()         | 세션 기록의 바로 뒤 페이지로 이동하는 비동기 메서드입니다. 브라우저의 뒤로 가기 버튼을 눌렀을 때, 그리고 history.go(-1)을 사용했을 때와 같습니다.**참고**: 세션 기록의 제일 첫 번째 페이지에서 호출해도 오류는 발생하지 않습니다.                                                                                                          |\n| History.forward()      | 세션 기록의 바로 앞 페이지로 이동하는 비동기 메서드입니다. 브라우저의 앞으로 가기 버튼을 눌렀을 때, 그리고 history.go(1)을 사용했을 때와 같습니다.**참고**: 세션 기록의 제일 마지막 페이지에서 호출해도 오류는 발생하지 않습니다.                                                                                                          |\n| History.go()           | 현재 페이지를 기준으로, 상대적인 위치에 존재하는 세션 기록 내 페이지로 이동하는 비동기 메서드입니다. 예를 들어, 매개변수로 -1을 제공하면 바로 뒤로, 1을 제공하면 바로 앞으로 이동합니다.**세션 기록의 범위를 벗어나는 값을 제공하면 아무 일도 일어나지 않습니다. 매개변수를 제공하지 않거나, 0을 제공하면 현재 페이지를 다시 불러옵니다.** |\n| History.pushState()    | 주어진 데이터를 지정한 제목(제공한 경우 URL도)으로 방문 기록 스택에 넣습니다. 데이터는 DOM이 불투명(opaque)하게 취급하므로, 직렬화 가능한 모든 JavaScript 객체를 사용할 수 있습니다. 참고로, Safari를 제외한 모든 브라우저는 title 매개변수를 무시합니다.                                                                                  |\n| History.replaceState() | 세션 기록 스택의 제일 최근 항목을 주어진 데이터, 지정한 제목 및 URL로 대체합니다. 데이터는 DOM이 불투명(opaque)하게 취급하므로, 직렬화 가능한 모든 JavaScript 객체를 사용할 수 있습니다. 참고로, Safari를 제외한 모든 브라우저는 title 매개변수를 무시합니다.                                                                              |\n\n```html\n<button id=\"prevBtn\" onclick=\"history.back();\">  \n이전 페이지  \n</button>  \n  \n<button id=\"nextBtn\" onclick=\"history.forward();\">  \n다음 페이지  \n</button>  \n  \n<button onclick=\"history.go(-1);\">  \n1단계 이전 페이지  \n</button>  \n  \n<button onclick=\"history.go(-2);\">  \n2단계 이전 페이지  \n</button>  \n```\n\n* * *\n\n### navigator\n\nnavigator 객체는 현재 방문자가 사용하는 브라우저 정보와  \n운영체제의 정보를 제공하는 객체 입니다.\n\n> 기본형  \n> navigator.속성;\n\n| 속성          | 설명                                                                                                         |\n|---------------|--------------------------------------------------------------------------------------------------------------|\n| appCodeName   | 유저 브라우저의 내부 코드명을 반환합니다.                                                                    |\n| appName       | 유저 브라우저의 이름을 반환합니다.                                                                           |\n| appVersion    | 브라우저의 버젼 정보를 반환합니다.                                                                           |\n| cookieEnabled | 브라우저에서 쿠키가 활성화되어 있는지 확인합니다.쿠키가 무시되면false값 무시되지 않으면 true값을 반환합니다. |\n| geolocation   | **사용자의 위치를 ​​찾는 데 사용할 수있는 Geolocation 객체를 반환합니다.**                                     |\n| language      | 유저 브라우저의 언어를 반환합니다.                                                                           |\n| onLine        | 브라우저가 온라인 상태인지 확인합니다.                                                                       |\n| platform      | 브라우저 플랫폼을 나타내는 문자열을 반환합니다.                                                              |\n| product       | 유저 브라우저의 엔진 이름은 반환합니다.                                                                      |\n| userAgent     | 유저의 브라우저와 운영체제 종합 정보를 반환합니다.\n\n\n```js 예시\ndocument.write(\"appCodeName: \"+navigator.appCodeName,\"<br/>\");  \ndocument.write(\"appName: \"+navigator.appName,\"<br/>\");  \ndocument.write(\"appVersion: \"+navigator.appVersion,\"<br/>\");  \ndocument.write(\"language: \"+navigator.language,\"<br/>\");  \ndocument.write(\"product: \"+navigator.product,\"<br/>\");  \ndocument.write(\"platform: \"+navigator.platform,\"<br/>\");  \ndocument.write(\"userAgent: \"+navigator.userAgent,\"<br/>\");  \n```\n\n```html 총정리 실습\n<h1>운영체제 및 스크린 정보</h1>  \n<p id=\"info_wrap\"></p>  \n  \n<!-- 아래 버튼을 누를 때 마다 info1 함수의 중괄호 사이의   \n 자바스크립트 실행문 코드가 실행됩니다. -->  \n<button onclick=\"info1();\">운영체제 정보</button> <br />  \n<!-- 아래 버튼을 누를 때 마다 info2 함수의 중괄호 사이의   \n 자바스크립트 실행문 코드가 실행됩니다. -->  \n<button onclick=\"info2();\">스크린 정보</button> <br />  \n  \n<script type=\"text/javascript\">  \n /*① [운영 체제 정보]버튼을 누를 때마다 실행되는 함수입니다*/  \n function info1(){  \n /* 사용자 브라우저 운영체제 및 종합 정보를 반환하고,   \n 모두 소문자로 바꿉니다.*/  \n const os=navigator.userAgent.toLowerCase();  \n    \n // 요소값 중 id값이 \"info_wrap\"인 요소를 가져옵니다.  \n const info_wrap=document.getElementById(\"info_wrap\");  \n    \n /* navigator 객체를 이용해 반환받은 정보에   \n 다음과 같은 정보가 포함되어 있으면  \n 운영체제 명을 지정한 요소 사이에 텍스트로 출력합니다*/  \n if(os.indexOf(\"windows\")>=0){  \n info_wrap.innerHTML=\"윈도우\";  \n    \n }else if(os.indexOf(\"macintosh\")>=0){  \n info_wrap.innerHTML=\"맥킨토시\";  \n    \n }else if(os.indexOf(\"iphone\")>=0){  \n info_wrap.innerHTML=\"아이폰\";  \n    \n }else if(os.indexOf(\"android\")>=0){  \n info_wrap.innerHTML=\"안드로이드\";  \n }  \n //3초 후에  운영체제 정보를 지웁니다.  \n setTimeout(\"info_wrap.innerHTML=''\",3000);  \n }  \n    \n /*② [스크린 정보]버튼을 누를 때마다 실행되는 함수입니다*/  \n function info2(){  \n //사용자 스크린 너비와 높이값을 가져와 저장합니다.  \n const sc_w=screen.width;  \n const sc_h=screen.height;  \n // 요소 중 id가 \"info_wrap\"인 요소 객체를 가져옵니다.  \n const info_wrap=document.getElementById(\"info_wrap\");  \n    \n // 스크린 너비와 높이값을 텍스트로 출력합니다.  \n info_wrap.innerHTML=sc_w+\"X\"+sc_h;  \n //3초 후에 스크린 정보를 지웁니다.  \n setTimeout(\"info_wrap.innerHTml=''\",3000);  \n }  \n </script>  \n```","slug":"BOM 브라우저 객체 모델","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrrs0006qgvqhg3whj7v","content":"<p>브라우저에 내장된 객체를</p>\n<p><strong>브라우저 객체(BOM: Browser Object Model)</strong>라고 합니다.</p>\n<p>window는 브라우저 객체의 최상위 객체 입니다.</p>\n<p>window 객체는 여러가지 하위 객체를 포함하고 있습니다.</p>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"window-객체-메서드-종류\"><a href=\"#window-객체-메서드-종류\" class=\"headerlink\" title=\"window 객체 메서드 종류\"></a>window 객체 메서드 종류</h2><hr>\n<table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>open()</td>\n<td>새 창(popup)을 열 때 사용</td>\n</tr>\n<tr>\n<td>alert()</td>\n<td>경고 창을 띄울때 사용 (window객체 없이 작성가능)</td>\n</tr>\n<tr>\n<td>prompt()</td>\n<td>질의응답 창을 띄움 (window객체 없이 작성가능)</td>\n</tr>\n<tr>\n<td>confirm()</td>\n<td>확인/취소 창을 띄움 (window객체 없이 작성가능)</td>\n</tr>\n<tr>\n<td>scrollBy(x, y)</td>\n<td>윈도우 스크롤의 위치를 상대적으로 이동</td>\n</tr>\n<tr>\n<td>scrollTo(x, y)</td>\n<td>윈도우 스크롤의 위치를 절대적으로 이동</td>\n</tr>\n<tr>\n<td>setInterval()</td>\n<td>일정 간격으로 지속적으로 실행문을 실행시킴</td>\n</tr>\n<tr>\n<td>setTimeout()</td>\n<td>일정 간격으로 한번만 실행문을 실행시킴</td>\n</tr>\n<tr>\n<td>focus()</td>\n<td>윈도우에 초점 맞춤</td>\n</tr>\n<tr>\n<td>blur()</td>\n<td>윈도우에 맞춘 초점 제거</td>\n</tr>\n<tr>\n<td>close()</td>\n<td>윈도우 닫음</td>\n</tr>\n<tr>\n<td>window.onload</td>\n<td>윈도우 객체 로드 완료시 실행되는 객체</td>\n</tr>\n<tr>\n<td>moveTo(x, y)</td>\n<td>윈도우의 위치를 절대적으로 이동</td>\n</tr>\n<tr>\n<td>moveBy(x, y)</td>\n<td>윈도우의 위치를 상대적으로 이동</td>\n</tr>\n<tr>\n<td>resizeTo(x, y)</td>\n<td>윈도우의 크기를 절대적으로 지정</td>\n</tr>\n<tr>\n<td>resizeBy(x, y)</td>\n<td>윈도우의 크기를 상대적으로 지정</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"open\"><a href=\"#open\" class=\"headerlink\" title=\"open()\"></a>open()</h3><p>open()는 새 브라우저 창을 띄울 때 사용합니다.<br>사이트에서 팝업 창을 띄울 때 자주 사용되는 메서드 입니다.</p>\n<pre><code>기본형\nwindow.open(&quot;url&quot;,&quot;name&quot;,&quot;specs,replace&quot;);</code></pre><p>사용예시</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.open(<span class=\"string\">\"https://www.google.com\"</span>,<span class=\"string\">\"google\"</span>,  </span><br><span class=\"line\"><span class=\"string\">\"width=400, height=500, left=50, top=10,scrollbars=no,toolbars=no,location=no\"</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"1-1-반환값-ret\"><a href=\"#1-1-반환값-ret\" class=\"headerlink\" title=\"1.1. 반환값(ret)\"></a>1.1. 반환값(ret)</h4><p>새로 만들어진 창 객체가 반환됩니다.</p>\n<p>창의 생성에 실패하면 null을 반환합니다.</p>\n<p>이 객체를 통해서 새창을 제어할 수 있습니다.</p>\n<p>예로 ret.close(); 로 창을 닫을 수 있습니다.</p>\n<h4 id=\"1-2-url\"><a href=\"#1-2-url\" class=\"headerlink\" title=\"1.2. url\"></a>1.2. url</h4><p>새창에 보여질 주소 입니다.</p>\n<p>선택적인 값으로 비워두면 빈창(about:blank)이 보입니다.</p>\n<pre><code>빈 창을 열고 내용을 동적으로 적을 수 도 있습니다.\nvar win = window.open(&quot;&quot;, &quot;PopupWin&quot;, &quot;width=500,height=600&quot;);\nwin.document.write(&quot;&lt;p&gt;새창에 표시될 내용 입니다.&lt;/p&gt;&quot;);</code></pre><h4 id=\"1-3-name\"><a href=\"#1-3-name\" class=\"headerlink\" title=\"1.3. name\"></a>1.3. name</h4><p>새로 열릴 참의 속성 또는 창의 이름을 지정합니다.</p>\n<p>선택적인 값으로 기본값은 “_blank” 입니다.</p>\n<p>사용 가능한 값을 다음과 같습니다.</p>\n<ul>\n<li><p>_blank : 새 창에 열립니다. 이것이 기본값입니다.</p>\n</li>\n<li><p>_parent : 부모 프레임에 열립니다.</p>\n</li>\n<li><p>_self : 현재 페이지를 대체합니다.</p>\n</li>\n<li><p>_top : 로드된 프레임셋을 대체합니다.</p>\n</li>\n<li><p>name(임의의 이름) : 새 창이 열리고 창의 이름을 지정합니다.<br>동일한 이름에 다시 open() 을 하면 기존의 열린창의 내용이 바뀝니다.<br>다른 이름을 사용하면 또다른 새창이 열립니다.</p>\n</li>\n</ul>\n<h4 id=\"1-4-specs\"><a href=\"#1-4-specs\" class=\"headerlink\" title=\"1.4 specs\"></a>1.4 specs</h4><table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>width</td>\n<td>새 윈도우의 너비</td>\n</tr>\n<tr>\n<td>height</td>\n<td>새 윈도우의 높이</td>\n</tr>\n<tr>\n<td>left</td>\n<td>왼쪽 기준 팝업 위치 지정 <strong>음수는 사용할 수 없습니다</strong></td>\n</tr>\n<tr>\n<td>top</td>\n<td>상단 기준 팝업 위치 지정 <strong>음수는 사용할 수 없습니다</strong></td>\n</tr>\n<tr>\n<td>status</td>\n<td>상태 표시줄 유무</td>\n</tr>\n<tr>\n<td>menubar</td>\n<td>메뉴바 유무</td>\n</tr>\n<tr>\n<td>resizable</td>\n<td>화면 크기 조절 가능 여부</td>\n</tr>\n<tr>\n<td>location</td>\n<td>주소 표시줄 유무 <strong>Opera에서만 작동</strong></td>\n</tr>\n<tr>\n<td>scrollbars</td>\n<td>스크롤바 유무 <strong>IE,Firefox,Opera에서 작동</strong></td>\n</tr>\n<tr>\n<td>toolbar</td>\n<td>툴바 유무 <strong>IE,Firefox에서 작동</strong></td>\n</tr>\n<tr>\n<td>resizable</td>\n<td>창의 리사이즈 가능 유무 <strong>IE에서만 작동</strong></td>\n</tr>\n<tr>\n<td>fullscreen</td>\n<td>전체화면모드. <strong>IE에서만 작동</strong></td>\n</tr>\n<tr>\n<td>channelmode</td>\n<td>전체화면으로 창이 열립니다. <strong>IE에서만 작동</strong></td>\n</tr>\n</tbody></table>\n<h4 id=\"1-5-replace\"><a href=\"#1-5-replace\" class=\"headerlink\" title=\"1.5 replace\"></a>1.5 replace</h4><p>히스토리 목록에 새 항목을 만들지 현재 항목을 대체할지 지정합니다.</p>\n<ul>\n<li><p>true : 현재 히스토리를 대체합니다.</p>\n</li>\n<li><p>false : 히스토리에 새 항목을 만듭니다.</p>\n</li>\n</ul>\n<ul>\n<li>출처: <a href=\"https://www.w3schools.com/jsref/met_win_open.asp\">https://www.w3schools.com/jsref/met_win_open.asp</a></li>\n</ul>\n<hr>\n<h3 id=\"moveTo-moveBy-resizeTo-resizeBy\"><a href=\"#moveTo-moveBy-resizeTo-resizeBy\" class=\"headerlink\" title=\"moveTo(), moveBy(), resizeTo(), resizeBy()\"></a>moveTo(), moveBy(), resizeTo(), resizeBy()</h3><hr>\n<ul>\n<li><p>moveTo() 메서드는 브라우저 창의 위치를 이동시킬때 사용합니다.</p>\n<p>  moveTo(100,200);<br>  //브라우저 창을 x100,y200 위치에서 뜨게 합니다.</p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>moveBy() 메서드는 현재 브라우저 창의 위치를 기준으로 이동 시킵니다.</p>\n<p>  moveBy(100,200);<br>  //실행될 때 마다 x100,y200만큼 이동합니다.</p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>resizeTo() 메서드는 브라우저 창의 너비와 높이를 바꿀때 사용합니다.</p>\n<p>  resizeTo(200,300);<br>  //width 200px, height 300px로 바꿉니다.</p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>resizeBy() 메서드는 현재 창을 기준으로 지정된 픽셀 수만큼<br>창의 오른쪽 아래 모서리를 이동합니다.  </p>\n</li>\n<li><p><em>왼쪽 상단 모서리는 이동하지 않습니다 (원래 좌표로 유지됨).*</em></p>\n<p>   resizeBy(200,300);<br>   //오른쪽 아래 모서리를 width 200px, height 300px 만큼 늘립니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"senInterval-clearInterval\"><a href=\"#senInterval-clearInterval\" class=\"headerlink\" title=\"senInterval(), clearInterval()\"></a>senInterval(), clearInterval()</h3><hr>\n<p><strong>setInterval()</strong></p>\n<ul>\n<li><p>setInterval() 메소드는 function을 호출하거나</p>\n<p>일정한 간격 (밀리 초)으로 실행문을 반복하여 실행시킬 때 사용합니다.</p>\n</li>\n<li><p>setInterval() 메소드는 clearInterval()이 호출되거나</p>\n<p>window창이 닫힐 때까지 계속됩니다.</p>\n</li>\n<li><p>setInterval()에 의해 리턴 된 ID 값은</p>\n<p>clearInterval() 메소드의 매개 변수로 사용됩니다.</p>\n</li>\n<li><p>지정된 밀리 초 후에 함수를 한 번만 실행하려면 setTimeout() 메소드를 사용합니다.</p>\n</li>\n<li><p>1000ms = 1 초</p>\n</li>\n<li><p>4.0버젼 이전의 IE,Opera에서 실행되지 않을 수 있습니다.</p>\n</li>\n</ul>\n<pre><code>기본형\nvar 참조변수=setInterval(function, milliseconds, param1, param2, ...)</code></pre><h4 id=\"1-1-function\"><a href=\"#1-1-function\" class=\"headerlink\" title=\"1.1 function\"></a>1.1 function</h4><p>필수 항목입니다. 실행될 기능(스크립트 실행문)항목 입니다.</p>\n<h4 id=\"1-2-milliseconds\"><a href=\"#1-2-milliseconds\" class=\"headerlink\" title=\"1.2 milliseconds\"></a>1.2 milliseconds</h4><p>필수 할목입니다. 코드 실행 빈도에 대한 간격 (밀리 초)입니다.</p>\n<p>값이 10보다 작은 경우 값 10이 사용됩니다.</p>\n<h4 id=\"1-3-param\"><a href=\"#1-3-param\" class=\"headerlink\" title=\"1.3 param\"></a>1.3 param</h4><p>선택 옵션입니다.</p>\n<p>함수에 전달할 추가 매개 변수가 있는 경우 사용합니다.<br><strong>IE9 및 이전 버전에서는 지원되지 않음</strong></p>\n<hr>\n<p><strong>clearInterval()</strong></p>\n<p>clearInterval() 메소드는 setInterval()로 설정된 타이머를 지웁니다.</p>\n<ul>\n<li>clearInterval() 메소드를 사용하려면 setInterval() 메소드를 작성할 때<br>변수를 선언 해줘야 합니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myVar = setInterval(<span class=\"string\">\"javascript function\"</span>, milliseconds);  </span><br><span class=\"line\"><span class=\"comment\">// clearInterval에 setInterval 변수를 선언해 줌으로써  </span></span><br><span class=\"line\"><span class=\"comment\">// setInterval을 중지 할 수 있습니다.  </span></span><br><span class=\"line\">clearInterval(myVar);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"setTimeout-clearTimeout\"><a href=\"#setTimeout-clearTimeout\" class=\"headerlink\" title=\"setTimeout(), clearTimeout()\"></a>setTimeout(), clearTimeout()</h3><hr>\n<p>setTimeout() 메서드는 일정한 간격 후 스크립트 실행문을</p>\n<p><strong>단 한번만 실행시킵니다.</strong></p>\n<p>반복되길 원하면 setInterval()을 사용합니다.</p>\n<p>setTimeout()변수가 실행되지 않길 원하면 clearTimeout()을 사용합니다.</p>\n<hr>\n<pre><code>기본형\nvar(참조변수)=setTimeout(function, milliseconds, param1, param2, ...)</code></pre><hr>\n<p>setTimeout()의 milliseconds는<br>코드를 실행하기전에 대기할 밀리 초를 뜻합니다.<br>setInterval()의 mliiiseconds과 다르게 생략 할 수 있습니다.<br>생략하게 되면 0값을 갖게되어 바로 실행됩니다.</p>\n<hr>\n<p>clearTimeout() 메서드는 아직 실행 되지않은 setTimeout()을 취소합니다.</p>\n<pre><code>clearTimeout(id_of_settimeout);</code></pre><hr>\n<h3 id=\"screen\"><a href=\"#screen\" class=\"headerlink\" title=\"screen\"></a>screen</h3><p>screen객체는 사용자의 모니터 정보(속성)을 제공하는 객체입니다.</p>\n<pre><code>screen.속성; 으로 사용합니다.</code></pre><table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>availHeight</td>\n<td>윈도우 작업표시줄을 제외한 스크린 높이 값을 반환.</td>\n</tr>\n<tr>\n<td>availWidth</td>\n<td>윈도우 작업표시줄을 제외한 스크린 너비 값을 반환.</td>\n</tr>\n<tr>\n<td>height</td>\n<td>화면의 총 높이값을 반환.</td>\n</tr>\n<tr>\n<td>width</td>\n<td>화면의 총 너비값을 반환.</td>\n</tr>\n<tr>\n<td>colorDepth</td>\n<td>사용자 모니터가 표현 가능한 컬러 bit를 반환.</td>\n</tr>\n<tr>\n<td>pixelDepth</td>\n<td>화면의 색상 해상도 (픽셀 당 비트 수)를 반환.</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"location\"></a>location</h3><p>location 객체는 사용자 브라우저 주소창에 url정보(속성)와</p>\n<p>새로고침 기능(메서드)를 제공하는 객체 입니다.</p>\n<pre><code>location.속성;\n또는\nlocation.메서드() 으로 사용합니다.</code></pre><p><strong>location 객체 속성</strong></p>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hash</td>\n<td>URL의 <strong>앵커 부분 (#)</strong>을 설정하거나 반환합니다.</td>\n</tr>\n<tr>\n<td>host</td>\n<td>URL의 <strong>호스트 이름과 포트 번호</strong>를 설정하거나 반환합니다.</td>\n</tr>\n<tr>\n<td>hostname</td>\n<td>URL의 <strong>호스트 이름</strong>을 설정하거나 반환합니다.</td>\n</tr>\n<tr>\n<td>href</td>\n<td><strong>주소 영역에 참조 주소</strong>를 설정하거나 URL을 반환합니다.</td>\n</tr>\n<tr>\n<td>origin</td>\n<td>URL의 <strong>프로토콜, 호스트 이름 및 포트 번호</strong>를 반환합니다.</td>\n</tr>\n<tr>\n<td>pathname</td>\n<td>URL의 <strong>경로 이름(pathname)</strong>을 설정하거나 반환합니다.</td>\n</tr>\n<tr>\n<td>port</td>\n<td>URL의 <strong>포트 번호</strong>를 설정하거나 반환합니다.</td>\n</tr>\n<tr>\n<td>protocol</td>\n<td>URL의 <strong>프로토콜</strong>을 설정하거나 반환합니다.</td>\n</tr>\n<tr>\n<td>search</td>\n<td>URL의 <strong>쿼리 값</strong>을 설정하거나 반환합니다.</td>\n</tr>\n</tbody></table>\n<p><strong>location 객체 메서드</strong></p>\n<table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>assign()</td>\n<td>새 문서(페이지)를 로드 합니다.</td>\n</tr>\n<tr>\n<td>reload()</td>\n<td>현재 문서(페이지)를 새로고침 합니다.</td>\n</tr>\n<tr>\n<td>replace()</td>\n<td>현재 문서(페이지)를 새 문서(페이지)로 교체합니다.</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h3><p>history 객체에는 브라우저 창 내에서 사용자가 방문한 URL이 포함됩니다.</p>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>History.length</td>\n<td>현재 페이지를 포함해, 방문 기록에 저장된 목록의 개수를 나타내는 정수를 반환합니다.</td>\n</tr>\n<tr>\n<td>History.scrollRestoration</td>\n<td>기록 탐색 시 <strong>스크롤 위치 복원 여부</strong>를 명시할 수 있습니다. 가능한 값은 auto와 manual입니다.</td>\n</tr>\n<tr>\n<td>History.state</td>\n<td>기록 스택 최상단의 상태를 나타내는 값을 반환합니다.<strong>popstate 이벤트를 기다리지 않고 현재 기록의 상태를 볼 수 있는 방법입니다.</strong></td>\n</tr>\n</tbody></table>\n<hr>\n<table>\n<thead>\n<tr>\n<th>메서드 종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>History.back()</td>\n<td>세션 기록의 바로 뒤 페이지로 이동하는 비동기 메서드입니다. 브라우저의 뒤로 가기 버튼을 눌렀을 때, 그리고 history.go(-1)을 사용했을 때와 같습니다.<strong>참고</strong>: 세션 기록의 제일 첫 번째 페이지에서 호출해도 오류는 발생하지 않습니다.</td>\n</tr>\n<tr>\n<td>History.forward()</td>\n<td>세션 기록의 바로 앞 페이지로 이동하는 비동기 메서드입니다. 브라우저의 앞으로 가기 버튼을 눌렀을 때, 그리고 history.go(1)을 사용했을 때와 같습니다.<strong>참고</strong>: 세션 기록의 제일 마지막 페이지에서 호출해도 오류는 발생하지 않습니다.</td>\n</tr>\n<tr>\n<td>History.go()</td>\n<td>현재 페이지를 기준으로, 상대적인 위치에 존재하는 세션 기록 내 페이지로 이동하는 비동기 메서드입니다. 예를 들어, 매개변수로 -1을 제공하면 바로 뒤로, 1을 제공하면 바로 앞으로 이동합니다.<strong>세션 기록의 범위를 벗어나는 값을 제공하면 아무 일도 일어나지 않습니다. 매개변수를 제공하지 않거나, 0을 제공하면 현재 페이지를 다시 불러옵니다.</strong></td>\n</tr>\n<tr>\n<td>History.pushState()</td>\n<td>주어진 데이터를 지정한 제목(제공한 경우 URL도)으로 방문 기록 스택에 넣습니다. 데이터는 DOM이 불투명(opaque)하게 취급하므로, 직렬화 가능한 모든 JavaScript 객체를 사용할 수 있습니다. 참고로, Safari를 제외한 모든 브라우저는 title 매개변수를 무시합니다.</td>\n</tr>\n<tr>\n<td>History.replaceState()</td>\n<td>세션 기록 스택의 제일 최근 항목을 주어진 데이터, 지정한 제목 및 URL로 대체합니다. 데이터는 DOM이 불투명(opaque)하게 취급하므로, 직렬화 가능한 모든 JavaScript 객체를 사용할 수 있습니다. 참고로, Safari를 제외한 모든 브라우저는 title 매개변수를 무시합니다.</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"prevBtn\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"history.back();\"</span>&gt;</span>  </span><br><span class=\"line\">이전 페이지  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"nextBtn\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"history.forward();\"</span>&gt;</span>  </span><br><span class=\"line\">다음 페이지  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"history.go(-1);\"</span>&gt;</span>  </span><br><span class=\"line\">1단계 이전 페이지  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"history.go(-2);\"</span>&gt;</span>  </span><br><span class=\"line\">2단계 이전 페이지  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"navigator\"><a href=\"#navigator\" class=\"headerlink\" title=\"navigator\"></a>navigator</h3><p>navigator 객체는 현재 방문자가 사용하는 브라우저 정보와<br>운영체제의 정보를 제공하는 객체 입니다.</p>\n<blockquote>\n<p>기본형<br>navigator.속성;</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>appCodeName</td>\n<td>유저 브라우저의 내부 코드명을 반환합니다.</td>\n</tr>\n<tr>\n<td>appName</td>\n<td>유저 브라우저의 이름을 반환합니다.</td>\n</tr>\n<tr>\n<td>appVersion</td>\n<td>브라우저의 버젼 정보를 반환합니다.</td>\n</tr>\n<tr>\n<td>cookieEnabled</td>\n<td>브라우저에서 쿠키가 활성화되어 있는지 확인합니다.쿠키가 무시되면false값 무시되지 않으면 true값을 반환합니다.</td>\n</tr>\n<tr>\n<td>geolocation</td>\n<td><strong>사용자의 위치를 ​​찾는 데 사용할 수있는 Geolocation 객체를 반환합니다.</strong></td>\n</tr>\n<tr>\n<td>language</td>\n<td>유저 브라우저의 언어를 반환합니다.</td>\n</tr>\n<tr>\n<td>onLine</td>\n<td>브라우저가 온라인 상태인지 확인합니다.</td>\n</tr>\n<tr>\n<td>platform</td>\n<td>브라우저 플랫폼을 나타내는 문자열을 반환합니다.</td>\n</tr>\n<tr>\n<td>product</td>\n<td>유저 브라우저의 엔진 이름은 반환합니다.</td>\n</tr>\n<tr>\n<td>userAgent</td>\n<td>유저의 브라우저와 운영체제 종합 정보를 반환합니다.</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight js\"><figcaption><span>예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"appCodeName: \"</span>+navigator.appCodeName,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"appName: \"</span>+navigator.appName,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"appVersion: \"</span>+navigator.appVersion,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"language: \"</span>+navigator.language,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"product: \"</span>+navigator.product,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"platform: \"</span>+navigator.platform,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"userAgent: \"</span>+navigator.userAgent,<span class=\"string\">\"&lt;br/&gt;\"</span>);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><figcaption><span>총정리 실습</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>운영체제 및 스크린 정보<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">id</span>=<span class=\"string\">\"info_wrap\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 아래 버튼을 누를 때 마다 info1 함수의 중괄호 사이의   </span></span><br><span class=\"line\"><span class=\"comment\"> 자바스크립트 실행문 코드가 실행됩니다. --&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"info1();\"</span>&gt;</span>운영체제 정보<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 아래 버튼을 누를 때 마다 info2 함수의 중괄호 사이의   </span></span><br><span class=\"line\"><span class=\"comment\"> 자바스크립트 실행문 코드가 실행됩니다. --&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"info2();\"</span>&gt;</span>스크린 정보<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">/*① [운영 체제 정보]버튼을 누를 때마다 실행되는 함수입니다*/</span>  </span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">info1</span><span class=\"params\">()</span></span>&#123;  </span></span><br><span class=\"line\"> /* 사용자 브라우저 운영체제 및 종합 정보를 반환하고,   </span><br><span class=\"line\"> 모두 소문자로 바꿉니다.*/  </span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"keyword\">const</span> os=navigator.userAgent.toLowerCase();  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">// 요소값 중 id값이 \"info_wrap\"인 요소를 가져옵니다.  </span></span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"keyword\">const</span> info_wrap=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"info_wrap\"</span>);  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"> /* navigator 객체를 이용해 반환받은 정보에   </span><br><span class=\"line\"> 다음과 같은 정보가 포함되어 있으면  </span><br><span class=\"line\"> 운영체제 명을 지정한 요소 사이에 텍스트로 출력합니다*/  </span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"keyword\">if</span>(os.indexOf(<span class=\"string\">\"windows\"</span>)&gt;=<span class=\"number\">0</span>)&#123;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> info_wrap.innerHTML=<span class=\"string\">\"윈도우\"</span>;  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"actionscript\"> &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(os.indexOf(<span class=\"string\">\"macintosh\"</span>)&gt;=<span class=\"number\">0</span>)&#123;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> info_wrap.innerHTML=<span class=\"string\">\"맥킨토시\"</span>;  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"actionscript\"> &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(os.indexOf(<span class=\"string\">\"iphone\"</span>)&gt;=<span class=\"number\">0</span>)&#123;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> info_wrap.innerHTML=<span class=\"string\">\"아이폰\"</span>;  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"actionscript\"> &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(os.indexOf(<span class=\"string\">\"android\"</span>)&gt;=<span class=\"number\">0</span>)&#123;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> info_wrap.innerHTML=<span class=\"string\">\"안드로이드\"</span>;  </span></span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">//3초 후에  운영체제 정보를 지웁니다.  </span></span></span><br><span class=\"line\"><span class=\"actionscript\"> setTimeout(<span class=\"string\">\"info_wrap.innerHTML=''\"</span>,<span class=\"number\">3000</span>);  </span></span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">/*② [스크린 정보]버튼을 누를 때마다 실행되는 함수입니다*/</span>  </span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">info2</span><span class=\"params\">()</span></span>&#123;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">//사용자 스크린 너비와 높이값을 가져와 저장합니다.  </span></span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"keyword\">const</span> sc_w=screen.width;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"keyword\">const</span> sc_h=screen.height;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">// 요소 중 id가 \"info_wrap\"인 요소 객체를 가져옵니다.  </span></span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"keyword\">const</span> info_wrap=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"info_wrap\"</span>);  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">// 스크린 너비와 높이값을 텍스트로 출력합니다.  </span></span></span><br><span class=\"line\"><span class=\"actionscript\"> info_wrap.innerHTML=sc_w+<span class=\"string\">\"X\"</span>+sc_h;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">//3초 후에 스크린 정보를 지웁니다.  </span></span></span><br><span class=\"line\"><span class=\"actionscript\"> setTimeout(<span class=\"string\">\"info_wrap.innerHTml=''\"</span>,<span class=\"number\">3000</span>);  </span></span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>브라우저에 내장된 객체를</p>\n<p><strong>브라우저 객체(BOM: Browser Object Model)</strong>라고 합니다.</p>\n<p>window는 브라우저 객체의 최상위 객체 입니다.</p>\n<p>window 객체는 여러가지 하위 객체를 포함하고 있습니다.</p>","more":"<hr>\n<h2 id=\"window-객체-메서드-종류\"><a href=\"#window-객체-메서드-종류\" class=\"headerlink\" title=\"window 객체 메서드 종류\"></a>window 객체 메서드 종류</h2><hr>\n<table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>open()</td>\n<td>새 창(popup)을 열 때 사용</td>\n</tr>\n<tr>\n<td>alert()</td>\n<td>경고 창을 띄울때 사용 (window객체 없이 작성가능)</td>\n</tr>\n<tr>\n<td>prompt()</td>\n<td>질의응답 창을 띄움 (window객체 없이 작성가능)</td>\n</tr>\n<tr>\n<td>confirm()</td>\n<td>확인/취소 창을 띄움 (window객체 없이 작성가능)</td>\n</tr>\n<tr>\n<td>scrollBy(x, y)</td>\n<td>윈도우 스크롤의 위치를 상대적으로 이동</td>\n</tr>\n<tr>\n<td>scrollTo(x, y)</td>\n<td>윈도우 스크롤의 위치를 절대적으로 이동</td>\n</tr>\n<tr>\n<td>setInterval()</td>\n<td>일정 간격으로 지속적으로 실행문을 실행시킴</td>\n</tr>\n<tr>\n<td>setTimeout()</td>\n<td>일정 간격으로 한번만 실행문을 실행시킴</td>\n</tr>\n<tr>\n<td>focus()</td>\n<td>윈도우에 초점 맞춤</td>\n</tr>\n<tr>\n<td>blur()</td>\n<td>윈도우에 맞춘 초점 제거</td>\n</tr>\n<tr>\n<td>close()</td>\n<td>윈도우 닫음</td>\n</tr>\n<tr>\n<td>window.onload</td>\n<td>윈도우 객체 로드 완료시 실행되는 객체</td>\n</tr>\n<tr>\n<td>moveTo(x, y)</td>\n<td>윈도우의 위치를 절대적으로 이동</td>\n</tr>\n<tr>\n<td>moveBy(x, y)</td>\n<td>윈도우의 위치를 상대적으로 이동</td>\n</tr>\n<tr>\n<td>resizeTo(x, y)</td>\n<td>윈도우의 크기를 절대적으로 지정</td>\n</tr>\n<tr>\n<td>resizeBy(x, y)</td>\n<td>윈도우의 크기를 상대적으로 지정</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"open\"><a href=\"#open\" class=\"headerlink\" title=\"open()\"></a>open()</h3><p>open()는 새 브라우저 창을 띄울 때 사용합니다.<br>사이트에서 팝업 창을 띄울 때 자주 사용되는 메서드 입니다.</p>\n<pre><code>기본형\nwindow.open(&quot;url&quot;,&quot;name&quot;,&quot;specs,replace&quot;);</code></pre><p>사용예시</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.open(<span class=\"string\">\"https://www.google.com\"</span>,<span class=\"string\">\"google\"</span>,  </span><br><span class=\"line\"><span class=\"string\">\"width=400, height=500, left=50, top=10,scrollbars=no,toolbars=no,location=no\"</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"1-1-반환값-ret\"><a href=\"#1-1-반환값-ret\" class=\"headerlink\" title=\"1.1. 반환값(ret)\"></a>1.1. 반환값(ret)</h4><p>새로 만들어진 창 객체가 반환됩니다.</p>\n<p>창의 생성에 실패하면 null을 반환합니다.</p>\n<p>이 객체를 통해서 새창을 제어할 수 있습니다.</p>\n<p>예로 ret.close(); 로 창을 닫을 수 있습니다.</p>\n<h4 id=\"1-2-url\"><a href=\"#1-2-url\" class=\"headerlink\" title=\"1.2. url\"></a>1.2. url</h4><p>새창에 보여질 주소 입니다.</p>\n<p>선택적인 값으로 비워두면 빈창(about:blank)이 보입니다.</p>\n<pre><code>빈 창을 열고 내용을 동적으로 적을 수 도 있습니다.\nvar win = window.open(&quot;&quot;, &quot;PopupWin&quot;, &quot;width=500,height=600&quot;);\nwin.document.write(&quot;&lt;p&gt;새창에 표시될 내용 입니다.&lt;/p&gt;&quot;);</code></pre><h4 id=\"1-3-name\"><a href=\"#1-3-name\" class=\"headerlink\" title=\"1.3. name\"></a>1.3. name</h4><p>새로 열릴 참의 속성 또는 창의 이름을 지정합니다.</p>\n<p>선택적인 값으로 기본값은 “_blank” 입니다.</p>\n<p>사용 가능한 값을 다음과 같습니다.</p>\n<ul>\n<li><p>_blank : 새 창에 열립니다. 이것이 기본값입니다.</p>\n</li>\n<li><p>_parent : 부모 프레임에 열립니다.</p>\n</li>\n<li><p>_self : 현재 페이지를 대체합니다.</p>\n</li>\n<li><p>_top : 로드된 프레임셋을 대체합니다.</p>\n</li>\n<li><p>name(임의의 이름) : 새 창이 열리고 창의 이름을 지정합니다.<br>동일한 이름에 다시 open() 을 하면 기존의 열린창의 내용이 바뀝니다.<br>다른 이름을 사용하면 또다른 새창이 열립니다.</p>\n</li>\n</ul>\n<h4 id=\"1-4-specs\"><a href=\"#1-4-specs\" class=\"headerlink\" title=\"1.4 specs\"></a>1.4 specs</h4><table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>width</td>\n<td>새 윈도우의 너비</td>\n</tr>\n<tr>\n<td>height</td>\n<td>새 윈도우의 높이</td>\n</tr>\n<tr>\n<td>left</td>\n<td>왼쪽 기준 팝업 위치 지정 <strong>음수는 사용할 수 없습니다</strong></td>\n</tr>\n<tr>\n<td>top</td>\n<td>상단 기준 팝업 위치 지정 <strong>음수는 사용할 수 없습니다</strong></td>\n</tr>\n<tr>\n<td>status</td>\n<td>상태 표시줄 유무</td>\n</tr>\n<tr>\n<td>menubar</td>\n<td>메뉴바 유무</td>\n</tr>\n<tr>\n<td>resizable</td>\n<td>화면 크기 조절 가능 여부</td>\n</tr>\n<tr>\n<td>location</td>\n<td>주소 표시줄 유무 <strong>Opera에서만 작동</strong></td>\n</tr>\n<tr>\n<td>scrollbars</td>\n<td>스크롤바 유무 <strong>IE,Firefox,Opera에서 작동</strong></td>\n</tr>\n<tr>\n<td>toolbar</td>\n<td>툴바 유무 <strong>IE,Firefox에서 작동</strong></td>\n</tr>\n<tr>\n<td>resizable</td>\n<td>창의 리사이즈 가능 유무 <strong>IE에서만 작동</strong></td>\n</tr>\n<tr>\n<td>fullscreen</td>\n<td>전체화면모드. <strong>IE에서만 작동</strong></td>\n</tr>\n<tr>\n<td>channelmode</td>\n<td>전체화면으로 창이 열립니다. <strong>IE에서만 작동</strong></td>\n</tr>\n</tbody></table>\n<h4 id=\"1-5-replace\"><a href=\"#1-5-replace\" class=\"headerlink\" title=\"1.5 replace\"></a>1.5 replace</h4><p>히스토리 목록에 새 항목을 만들지 현재 항목을 대체할지 지정합니다.</p>\n<ul>\n<li><p>true : 현재 히스토리를 대체합니다.</p>\n</li>\n<li><p>false : 히스토리에 새 항목을 만듭니다.</p>\n</li>\n</ul>\n<ul>\n<li>출처: <a href=\"https://www.w3schools.com/jsref/met_win_open.asp\">https://www.w3schools.com/jsref/met_win_open.asp</a></li>\n</ul>\n<hr>\n<h3 id=\"moveTo-moveBy-resizeTo-resizeBy\"><a href=\"#moveTo-moveBy-resizeTo-resizeBy\" class=\"headerlink\" title=\"moveTo(), moveBy(), resizeTo(), resizeBy()\"></a>moveTo(), moveBy(), resizeTo(), resizeBy()</h3><hr>\n<ul>\n<li><p>moveTo() 메서드는 브라우저 창의 위치를 이동시킬때 사용합니다.</p>\n<p>  moveTo(100,200);<br>  //브라우저 창을 x100,y200 위치에서 뜨게 합니다.</p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>moveBy() 메서드는 현재 브라우저 창의 위치를 기준으로 이동 시킵니다.</p>\n<p>  moveBy(100,200);<br>  //실행될 때 마다 x100,y200만큼 이동합니다.</p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>resizeTo() 메서드는 브라우저 창의 너비와 높이를 바꿀때 사용합니다.</p>\n<p>  resizeTo(200,300);<br>  //width 200px, height 300px로 바꿉니다.</p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>resizeBy() 메서드는 현재 창을 기준으로 지정된 픽셀 수만큼<br>창의 오른쪽 아래 모서리를 이동합니다.  </p>\n</li>\n<li><p><em>왼쪽 상단 모서리는 이동하지 않습니다 (원래 좌표로 유지됨).*</em></p>\n<p>   resizeBy(200,300);<br>   //오른쪽 아래 모서리를 width 200px, height 300px 만큼 늘립니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"senInterval-clearInterval\"><a href=\"#senInterval-clearInterval\" class=\"headerlink\" title=\"senInterval(), clearInterval()\"></a>senInterval(), clearInterval()</h3><hr>\n<p><strong>setInterval()</strong></p>\n<ul>\n<li><p>setInterval() 메소드는 function을 호출하거나</p>\n<p>일정한 간격 (밀리 초)으로 실행문을 반복하여 실행시킬 때 사용합니다.</p>\n</li>\n<li><p>setInterval() 메소드는 clearInterval()이 호출되거나</p>\n<p>window창이 닫힐 때까지 계속됩니다.</p>\n</li>\n<li><p>setInterval()에 의해 리턴 된 ID 값은</p>\n<p>clearInterval() 메소드의 매개 변수로 사용됩니다.</p>\n</li>\n<li><p>지정된 밀리 초 후에 함수를 한 번만 실행하려면 setTimeout() 메소드를 사용합니다.</p>\n</li>\n<li><p>1000ms = 1 초</p>\n</li>\n<li><p>4.0버젼 이전의 IE,Opera에서 실행되지 않을 수 있습니다.</p>\n</li>\n</ul>\n<pre><code>기본형\nvar 참조변수=setInterval(function, milliseconds, param1, param2, ...)</code></pre><h4 id=\"1-1-function\"><a href=\"#1-1-function\" class=\"headerlink\" title=\"1.1 function\"></a>1.1 function</h4><p>필수 항목입니다. 실행될 기능(스크립트 실행문)항목 입니다.</p>\n<h4 id=\"1-2-milliseconds\"><a href=\"#1-2-milliseconds\" class=\"headerlink\" title=\"1.2 milliseconds\"></a>1.2 milliseconds</h4><p>필수 할목입니다. 코드 실행 빈도에 대한 간격 (밀리 초)입니다.</p>\n<p>값이 10보다 작은 경우 값 10이 사용됩니다.</p>\n<h4 id=\"1-3-param\"><a href=\"#1-3-param\" class=\"headerlink\" title=\"1.3 param\"></a>1.3 param</h4><p>선택 옵션입니다.</p>\n<p>함수에 전달할 추가 매개 변수가 있는 경우 사용합니다.<br><strong>IE9 및 이전 버전에서는 지원되지 않음</strong></p>\n<hr>\n<p><strong>clearInterval()</strong></p>\n<p>clearInterval() 메소드는 setInterval()로 설정된 타이머를 지웁니다.</p>\n<ul>\n<li>clearInterval() 메소드를 사용하려면 setInterval() 메소드를 작성할 때<br>변수를 선언 해줘야 합니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myVar = setInterval(<span class=\"string\">\"javascript function\"</span>, milliseconds);  </span><br><span class=\"line\"><span class=\"comment\">// clearInterval에 setInterval 변수를 선언해 줌으로써  </span></span><br><span class=\"line\"><span class=\"comment\">// setInterval을 중지 할 수 있습니다.  </span></span><br><span class=\"line\">clearInterval(myVar);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"setTimeout-clearTimeout\"><a href=\"#setTimeout-clearTimeout\" class=\"headerlink\" title=\"setTimeout(), clearTimeout()\"></a>setTimeout(), clearTimeout()</h3><hr>\n<p>setTimeout() 메서드는 일정한 간격 후 스크립트 실행문을</p>\n<p><strong>단 한번만 실행시킵니다.</strong></p>\n<p>반복되길 원하면 setInterval()을 사용합니다.</p>\n<p>setTimeout()변수가 실행되지 않길 원하면 clearTimeout()을 사용합니다.</p>\n<hr>\n<pre><code>기본형\nvar(참조변수)=setTimeout(function, milliseconds, param1, param2, ...)</code></pre><hr>\n<p>setTimeout()의 milliseconds는<br>코드를 실행하기전에 대기할 밀리 초를 뜻합니다.<br>setInterval()의 mliiiseconds과 다르게 생략 할 수 있습니다.<br>생략하게 되면 0값을 갖게되어 바로 실행됩니다.</p>\n<hr>\n<p>clearTimeout() 메서드는 아직 실행 되지않은 setTimeout()을 취소합니다.</p>\n<pre><code>clearTimeout(id_of_settimeout);</code></pre><hr>\n<h3 id=\"screen\"><a href=\"#screen\" class=\"headerlink\" title=\"screen\"></a>screen</h3><p>screen객체는 사용자의 모니터 정보(속성)을 제공하는 객체입니다.</p>\n<pre><code>screen.속성; 으로 사용합니다.</code></pre><table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>availHeight</td>\n<td>윈도우 작업표시줄을 제외한 스크린 높이 값을 반환.</td>\n</tr>\n<tr>\n<td>availWidth</td>\n<td>윈도우 작업표시줄을 제외한 스크린 너비 값을 반환.</td>\n</tr>\n<tr>\n<td>height</td>\n<td>화면의 총 높이값을 반환.</td>\n</tr>\n<tr>\n<td>width</td>\n<td>화면의 총 너비값을 반환.</td>\n</tr>\n<tr>\n<td>colorDepth</td>\n<td>사용자 모니터가 표현 가능한 컬러 bit를 반환.</td>\n</tr>\n<tr>\n<td>pixelDepth</td>\n<td>화면의 색상 해상도 (픽셀 당 비트 수)를 반환.</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"location\"></a>location</h3><p>location 객체는 사용자 브라우저 주소창에 url정보(속성)와</p>\n<p>새로고침 기능(메서드)를 제공하는 객체 입니다.</p>\n<pre><code>location.속성;\n또는\nlocation.메서드() 으로 사용합니다.</code></pre><p><strong>location 객체 속성</strong></p>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hash</td>\n<td>URL의 <strong>앵커 부분 (#)</strong>을 설정하거나 반환합니다.</td>\n</tr>\n<tr>\n<td>host</td>\n<td>URL의 <strong>호스트 이름과 포트 번호</strong>를 설정하거나 반환합니다.</td>\n</tr>\n<tr>\n<td>hostname</td>\n<td>URL의 <strong>호스트 이름</strong>을 설정하거나 반환합니다.</td>\n</tr>\n<tr>\n<td>href</td>\n<td><strong>주소 영역에 참조 주소</strong>를 설정하거나 URL을 반환합니다.</td>\n</tr>\n<tr>\n<td>origin</td>\n<td>URL의 <strong>프로토콜, 호스트 이름 및 포트 번호</strong>를 반환합니다.</td>\n</tr>\n<tr>\n<td>pathname</td>\n<td>URL의 <strong>경로 이름(pathname)</strong>을 설정하거나 반환합니다.</td>\n</tr>\n<tr>\n<td>port</td>\n<td>URL의 <strong>포트 번호</strong>를 설정하거나 반환합니다.</td>\n</tr>\n<tr>\n<td>protocol</td>\n<td>URL의 <strong>프로토콜</strong>을 설정하거나 반환합니다.</td>\n</tr>\n<tr>\n<td>search</td>\n<td>URL의 <strong>쿼리 값</strong>을 설정하거나 반환합니다.</td>\n</tr>\n</tbody></table>\n<p><strong>location 객체 메서드</strong></p>\n<table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>assign()</td>\n<td>새 문서(페이지)를 로드 합니다.</td>\n</tr>\n<tr>\n<td>reload()</td>\n<td>현재 문서(페이지)를 새로고침 합니다.</td>\n</tr>\n<tr>\n<td>replace()</td>\n<td>현재 문서(페이지)를 새 문서(페이지)로 교체합니다.</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h3><p>history 객체에는 브라우저 창 내에서 사용자가 방문한 URL이 포함됩니다.</p>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>History.length</td>\n<td>현재 페이지를 포함해, 방문 기록에 저장된 목록의 개수를 나타내는 정수를 반환합니다.</td>\n</tr>\n<tr>\n<td>History.scrollRestoration</td>\n<td>기록 탐색 시 <strong>스크롤 위치 복원 여부</strong>를 명시할 수 있습니다. 가능한 값은 auto와 manual입니다.</td>\n</tr>\n<tr>\n<td>History.state</td>\n<td>기록 스택 최상단의 상태를 나타내는 값을 반환합니다.<strong>popstate 이벤트를 기다리지 않고 현재 기록의 상태를 볼 수 있는 방법입니다.</strong></td>\n</tr>\n</tbody></table>\n<hr>\n<table>\n<thead>\n<tr>\n<th>메서드 종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>History.back()</td>\n<td>세션 기록의 바로 뒤 페이지로 이동하는 비동기 메서드입니다. 브라우저의 뒤로 가기 버튼을 눌렀을 때, 그리고 history.go(-1)을 사용했을 때와 같습니다.<strong>참고</strong>: 세션 기록의 제일 첫 번째 페이지에서 호출해도 오류는 발생하지 않습니다.</td>\n</tr>\n<tr>\n<td>History.forward()</td>\n<td>세션 기록의 바로 앞 페이지로 이동하는 비동기 메서드입니다. 브라우저의 앞으로 가기 버튼을 눌렀을 때, 그리고 history.go(1)을 사용했을 때와 같습니다.<strong>참고</strong>: 세션 기록의 제일 마지막 페이지에서 호출해도 오류는 발생하지 않습니다.</td>\n</tr>\n<tr>\n<td>History.go()</td>\n<td>현재 페이지를 기준으로, 상대적인 위치에 존재하는 세션 기록 내 페이지로 이동하는 비동기 메서드입니다. 예를 들어, 매개변수로 -1을 제공하면 바로 뒤로, 1을 제공하면 바로 앞으로 이동합니다.<strong>세션 기록의 범위를 벗어나는 값을 제공하면 아무 일도 일어나지 않습니다. 매개변수를 제공하지 않거나, 0을 제공하면 현재 페이지를 다시 불러옵니다.</strong></td>\n</tr>\n<tr>\n<td>History.pushState()</td>\n<td>주어진 데이터를 지정한 제목(제공한 경우 URL도)으로 방문 기록 스택에 넣습니다. 데이터는 DOM이 불투명(opaque)하게 취급하므로, 직렬화 가능한 모든 JavaScript 객체를 사용할 수 있습니다. 참고로, Safari를 제외한 모든 브라우저는 title 매개변수를 무시합니다.</td>\n</tr>\n<tr>\n<td>History.replaceState()</td>\n<td>세션 기록 스택의 제일 최근 항목을 주어진 데이터, 지정한 제목 및 URL로 대체합니다. 데이터는 DOM이 불투명(opaque)하게 취급하므로, 직렬화 가능한 모든 JavaScript 객체를 사용할 수 있습니다. 참고로, Safari를 제외한 모든 브라우저는 title 매개변수를 무시합니다.</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"prevBtn\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"history.back();\"</span>&gt;</span>  </span><br><span class=\"line\">이전 페이지  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"nextBtn\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"history.forward();\"</span>&gt;</span>  </span><br><span class=\"line\">다음 페이지  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"history.go(-1);\"</span>&gt;</span>  </span><br><span class=\"line\">1단계 이전 페이지  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"history.go(-2);\"</span>&gt;</span>  </span><br><span class=\"line\">2단계 이전 페이지  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"navigator\"><a href=\"#navigator\" class=\"headerlink\" title=\"navigator\"></a>navigator</h3><p>navigator 객체는 현재 방문자가 사용하는 브라우저 정보와<br>운영체제의 정보를 제공하는 객체 입니다.</p>\n<blockquote>\n<p>기본형<br>navigator.속성;</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>appCodeName</td>\n<td>유저 브라우저의 내부 코드명을 반환합니다.</td>\n</tr>\n<tr>\n<td>appName</td>\n<td>유저 브라우저의 이름을 반환합니다.</td>\n</tr>\n<tr>\n<td>appVersion</td>\n<td>브라우저의 버젼 정보를 반환합니다.</td>\n</tr>\n<tr>\n<td>cookieEnabled</td>\n<td>브라우저에서 쿠키가 활성화되어 있는지 확인합니다.쿠키가 무시되면false값 무시되지 않으면 true값을 반환합니다.</td>\n</tr>\n<tr>\n<td>geolocation</td>\n<td><strong>사용자의 위치를 ​​찾는 데 사용할 수있는 Geolocation 객체를 반환합니다.</strong></td>\n</tr>\n<tr>\n<td>language</td>\n<td>유저 브라우저의 언어를 반환합니다.</td>\n</tr>\n<tr>\n<td>onLine</td>\n<td>브라우저가 온라인 상태인지 확인합니다.</td>\n</tr>\n<tr>\n<td>platform</td>\n<td>브라우저 플랫폼을 나타내는 문자열을 반환합니다.</td>\n</tr>\n<tr>\n<td>product</td>\n<td>유저 브라우저의 엔진 이름은 반환합니다.</td>\n</tr>\n<tr>\n<td>userAgent</td>\n<td>유저의 브라우저와 운영체제 종합 정보를 반환합니다.</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight js\"><figcaption><span>예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"appCodeName: \"</span>+navigator.appCodeName,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"appName: \"</span>+navigator.appName,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"appVersion: \"</span>+navigator.appVersion,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"language: \"</span>+navigator.language,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"product: \"</span>+navigator.product,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"platform: \"</span>+navigator.platform,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"userAgent: \"</span>+navigator.userAgent,<span class=\"string\">\"&lt;br/&gt;\"</span>);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><figcaption><span>총정리 실습</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>운영체제 및 스크린 정보<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">id</span>=<span class=\"string\">\"info_wrap\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 아래 버튼을 누를 때 마다 info1 함수의 중괄호 사이의   </span></span><br><span class=\"line\"><span class=\"comment\"> 자바스크립트 실행문 코드가 실행됩니다. --&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"info1();\"</span>&gt;</span>운영체제 정보<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 아래 버튼을 누를 때 마다 info2 함수의 중괄호 사이의   </span></span><br><span class=\"line\"><span class=\"comment\"> 자바스크립트 실행문 코드가 실행됩니다. --&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"info2();\"</span>&gt;</span>스크린 정보<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">/*① [운영 체제 정보]버튼을 누를 때마다 실행되는 함수입니다*/</span>  </span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">info1</span><span class=\"params\">()</span></span>&#123;  </span></span><br><span class=\"line\"> /* 사용자 브라우저 운영체제 및 종합 정보를 반환하고,   </span><br><span class=\"line\"> 모두 소문자로 바꿉니다.*/  </span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"keyword\">const</span> os=navigator.userAgent.toLowerCase();  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">// 요소값 중 id값이 \"info_wrap\"인 요소를 가져옵니다.  </span></span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"keyword\">const</span> info_wrap=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"info_wrap\"</span>);  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"> /* navigator 객체를 이용해 반환받은 정보에   </span><br><span class=\"line\"> 다음과 같은 정보가 포함되어 있으면  </span><br><span class=\"line\"> 운영체제 명을 지정한 요소 사이에 텍스트로 출력합니다*/  </span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"keyword\">if</span>(os.indexOf(<span class=\"string\">\"windows\"</span>)&gt;=<span class=\"number\">0</span>)&#123;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> info_wrap.innerHTML=<span class=\"string\">\"윈도우\"</span>;  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"actionscript\"> &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(os.indexOf(<span class=\"string\">\"macintosh\"</span>)&gt;=<span class=\"number\">0</span>)&#123;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> info_wrap.innerHTML=<span class=\"string\">\"맥킨토시\"</span>;  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"actionscript\"> &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(os.indexOf(<span class=\"string\">\"iphone\"</span>)&gt;=<span class=\"number\">0</span>)&#123;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> info_wrap.innerHTML=<span class=\"string\">\"아이폰\"</span>;  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"actionscript\"> &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(os.indexOf(<span class=\"string\">\"android\"</span>)&gt;=<span class=\"number\">0</span>)&#123;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> info_wrap.innerHTML=<span class=\"string\">\"안드로이드\"</span>;  </span></span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">//3초 후에  운영체제 정보를 지웁니다.  </span></span></span><br><span class=\"line\"><span class=\"actionscript\"> setTimeout(<span class=\"string\">\"info_wrap.innerHTML=''\"</span>,<span class=\"number\">3000</span>);  </span></span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">/*② [스크린 정보]버튼을 누를 때마다 실행되는 함수입니다*/</span>  </span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">info2</span><span class=\"params\">()</span></span>&#123;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">//사용자 스크린 너비와 높이값을 가져와 저장합니다.  </span></span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"keyword\">const</span> sc_w=screen.width;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"keyword\">const</span> sc_h=screen.height;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">// 요소 중 id가 \"info_wrap\"인 요소 객체를 가져옵니다.  </span></span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"keyword\">const</span> info_wrap=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"info_wrap\"</span>);  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">// 스크린 너비와 높이값을 텍스트로 출력합니다.  </span></span></span><br><span class=\"line\"><span class=\"actionscript\"> info_wrap.innerHTML=sc_w+<span class=\"string\">\"X\"</span>+sc_h;  </span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">//3초 후에 스크린 정보를 지웁니다.  </span></span></span><br><span class=\"line\"><span class=\"actionscript\"> setTimeout(<span class=\"string\">\"info_wrap.innerHTml=''\"</span>,<span class=\"number\">3000</span>);  </span></span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"Destructuring -ECMAScript","date":"2020-03-20T03:16:44.000Z","disqusId":"tunas-blog-1","_content":"\nDestructuring 은 배열의 값 또는 객체의 속성을  \n별개의 변수로 압축 해제 할 수있는 JavaScript 표현식입니다.\n\n```js 형태\nlet a, b, rest;  \n  \n[a, b] = [10, 20];  \nconsole.log(a); // 10  \nconsole.log(b); // 20  \n  \n[a, b, ...rest] = [10, 20, 30, 40, 50];  \nconsole.log(a); // 10  \nconsole.log(b); // 20  \nconsole.log(rest); // [30, 40, 50]  \n  \n({ a, b } = { a: 10, b: 20 });  \nconsole.log(a); // 10  \nconsole.log(b); // 20  \n  \n  \n// Stage 4(finished) proposal  \n({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});  \nconsole.log(a); // 10  \nconsole.log(b); // 20  \nconsole.log(rest); // {c: 30, d: 40}  \n```\n변수에 배열의 엘리먼트를 할당한다는 표현보다  \n배열의 엘리먼트를 변수에 할당한다는 표현이 더 정확합니다.  \n배열의 엘리먼트 값을 변수에 할당하기 위해서는  \n먼저, 배열의 엘리먼트를 분할하고 분할된 엘리먼트 값이 변수에 할당되기 때문입니다.\n\n<!-- more -->\n\n* * *\n\n## Array 분할 할당\n\n```js\nlet one, two, three, four, five;  \nconst values = [1, 2, 3];  \n  \n[one, two, three] = values; //== [1, 2, 3]  \nconsole.log(\"A:\", one, two, three); // A: 1 2 3  \n  \n[one, two] = values; //== [1, 2, 3]  \nconsole.log(\"B:\", one, two);// B: 1 2  \n  \n[one, two, three, four] = values; //== [1, 2, 3]  \nconsole.log(\"C:\", one, two, three, four); // C: 1 2 3 undefined  \n  \n[one, two, [three, four]] = [1, 2, [73, 74]];   \nconsole.log(\"D:\", one, two, three, four); // D: 1 2 73 74  \n//배열차원이 같지 않으면 에러가 발생합니다. [0,1,[0,1]] = [0,1,[0,1]] 같은 차원 형태  \n```\n\n```js spread 사용시\nlet one, two, three, four, other;  \n  \n[one, ...other] = [1, 2, 3, 4];  \nconsole.log(other);  \n/*  \n0: 2  \n1: 3  \n2: 4  \nlength: 3  \n*/  \n// [2, 3, 4]  \n```\n\n*   1 값은 one에 할당되고 할당되지 않은 [2, 3 ,4]는 other에 할당됩니다.\n\n* * *\n\n## Object 분할 할당\n\n```js\n1.   \nlet {one, two} = {one: 1, nine: 9};  \nconsole.log(one, two); // 1 undefined  \n  \n2.   \nlet three, four;  \n({three, four} = {three: 3, four: 4});  \nconsole.log(three, four); // 3 4  \n```\n\n*   오른쪽이 오브젝트이면 왼쪽도 오브젝트 여야 합니다.\n\n1.  let {one,two} 형태는 변수 선언과 할당을 한번에 하는 형식입니다.  \n    오른쪽 nine이 왼쪽 오브젝트에 없으므로 값을 할당하지 않습니다.  \n    왼쪽 two 변수에 값을 할당하지 않았으므로 초기값인 undefined가 유지됩니다.\n    \n2.  오브젝트 할당에서 사전에 선언된 변수를 사용하려면  \n    소괄호() 안에 할당 코드를 작성합니다.\n    \n\n* * *\n\n## 파라미터 분활 할당\n\n호출하는 function 파라미터에 오브젝트를 작성하고  \n호출받는 function 파라미터를 오브젝트 분할 할당 형태로 작성하면  \n함수 블록에서 직접 프로퍼티 이름을 사용할 수 있습니다.\n\n```js\n//호출 받는 function  \nfunction total( { one, plus: { two, five } } ) {  \n console.log(one + two + five); // 8  \n};  \n  \n//function 호출  \ntotal({one: 1, plus: {two: 2, five: 5}});  \n```","source":"_posts/Destructuring -ECMAScript.md","raw":"---\ntitle: Destructuring -ECMAScript\ndate: 2020-03-20 12:16:44\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\nDestructuring 은 배열의 값 또는 객체의 속성을  \n별개의 변수로 압축 해제 할 수있는 JavaScript 표현식입니다.\n\n```js 형태\nlet a, b, rest;  \n  \n[a, b] = [10, 20];  \nconsole.log(a); // 10  \nconsole.log(b); // 20  \n  \n[a, b, ...rest] = [10, 20, 30, 40, 50];  \nconsole.log(a); // 10  \nconsole.log(b); // 20  \nconsole.log(rest); // [30, 40, 50]  \n  \n({ a, b } = { a: 10, b: 20 });  \nconsole.log(a); // 10  \nconsole.log(b); // 20  \n  \n  \n// Stage 4(finished) proposal  \n({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});  \nconsole.log(a); // 10  \nconsole.log(b); // 20  \nconsole.log(rest); // {c: 30, d: 40}  \n```\n변수에 배열의 엘리먼트를 할당한다는 표현보다  \n배열의 엘리먼트를 변수에 할당한다는 표현이 더 정확합니다.  \n배열의 엘리먼트 값을 변수에 할당하기 위해서는  \n먼저, 배열의 엘리먼트를 분할하고 분할된 엘리먼트 값이 변수에 할당되기 때문입니다.\n\n<!-- more -->\n\n* * *\n\n## Array 분할 할당\n\n```js\nlet one, two, three, four, five;  \nconst values = [1, 2, 3];  \n  \n[one, two, three] = values; //== [1, 2, 3]  \nconsole.log(\"A:\", one, two, three); // A: 1 2 3  \n  \n[one, two] = values; //== [1, 2, 3]  \nconsole.log(\"B:\", one, two);// B: 1 2  \n  \n[one, two, three, four] = values; //== [1, 2, 3]  \nconsole.log(\"C:\", one, two, three, four); // C: 1 2 3 undefined  \n  \n[one, two, [three, four]] = [1, 2, [73, 74]];   \nconsole.log(\"D:\", one, two, three, four); // D: 1 2 73 74  \n//배열차원이 같지 않으면 에러가 발생합니다. [0,1,[0,1]] = [0,1,[0,1]] 같은 차원 형태  \n```\n\n```js spread 사용시\nlet one, two, three, four, other;  \n  \n[one, ...other] = [1, 2, 3, 4];  \nconsole.log(other);  \n/*  \n0: 2  \n1: 3  \n2: 4  \nlength: 3  \n*/  \n// [2, 3, 4]  \n```\n\n*   1 값은 one에 할당되고 할당되지 않은 [2, 3 ,4]는 other에 할당됩니다.\n\n* * *\n\n## Object 분할 할당\n\n```js\n1.   \nlet {one, two} = {one: 1, nine: 9};  \nconsole.log(one, two); // 1 undefined  \n  \n2.   \nlet three, four;  \n({three, four} = {three: 3, four: 4});  \nconsole.log(three, four); // 3 4  \n```\n\n*   오른쪽이 오브젝트이면 왼쪽도 오브젝트 여야 합니다.\n\n1.  let {one,two} 형태는 변수 선언과 할당을 한번에 하는 형식입니다.  \n    오른쪽 nine이 왼쪽 오브젝트에 없으므로 값을 할당하지 않습니다.  \n    왼쪽 two 변수에 값을 할당하지 않았으므로 초기값인 undefined가 유지됩니다.\n    \n2.  오브젝트 할당에서 사전에 선언된 변수를 사용하려면  \n    소괄호() 안에 할당 코드를 작성합니다.\n    \n\n* * *\n\n## 파라미터 분활 할당\n\n호출하는 function 파라미터에 오브젝트를 작성하고  \n호출받는 function 파라미터를 오브젝트 분할 할당 형태로 작성하면  \n함수 블록에서 직접 프로퍼티 이름을 사용할 수 있습니다.\n\n```js\n//호출 받는 function  \nfunction total( { one, plus: { two, five } } ) {  \n console.log(one + two + five); // 8  \n};  \n  \n//function 호출  \ntotal({one: 1, plus: {two: 2, five: 5}});  \n```","slug":"Destructuring -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrru0009qgvq45hy772h","content":"<p>Destructuring 은 배열의 값 또는 객체의 속성을<br>별개의 변수로 압축 해제 할 수있는 JavaScript 표현식입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>형태</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a, b, rest;  </span><br><span class=\"line\">  </span><br><span class=\"line\">[a, b] = [<span class=\"number\">10</span>, <span class=\"number\">20</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">[a, b, ...rest] = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest); <span class=\"comment\">// [30, 40, 50]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">(&#123; a, b &#125; = &#123; <span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span> &#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// Stage 4(finished) proposal  </span></span><br><span class=\"line\">(&#123;a, b, ...rest&#125; = &#123;<span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span>, <span class=\"attr\">c</span>: <span class=\"number\">30</span>, <span class=\"attr\">d</span>: <span class=\"number\">40</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest); <span class=\"comment\">// &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure>\n<p>변수에 배열의 엘리먼트를 할당한다는 표현보다<br>배열의 엘리먼트를 변수에 할당한다는 표현이 더 정확합니다.<br>배열의 엘리먼트 값을 변수에 할당하기 위해서는<br>먼저, 배열의 엘리먼트를 분할하고 분할된 엘리먼트 값이 변수에 할당되기 때문입니다.</p>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"Array-분할-할당\"><a href=\"#Array-분할-할당\" class=\"headerlink\" title=\"Array 분할 할당\"></a>Array 분할 할당</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one, two, three, four, five;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> values = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\">[one, two, three] = values; <span class=\"comment\">//== [1, 2, 3]  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"A:\"</span>, one, two, three); <span class=\"comment\">// A: 1 2 3  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">[one, two] = values; <span class=\"comment\">//== [1, 2, 3]  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"B:\"</span>, one, two);<span class=\"comment\">// B: 1 2  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">[one, two, three, four] = values; <span class=\"comment\">//== [1, 2, 3]  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"C:\"</span>, one, two, three, four); <span class=\"comment\">// C: 1 2 3 undefined  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">[one, two, [three, four]] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">73</span>, <span class=\"number\">74</span>]];   </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"D:\"</span>, one, two, three, four); <span class=\"comment\">// D: 1 2 73 74  </span></span><br><span class=\"line\"><span class=\"comment\">//배열차원이 같지 않으면 에러가 발생합니다. [0,1,[0,1]] = [0,1,[0,1]] 같은 차원 형태</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>spread 사용시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one, two, three, four, other;  </span><br><span class=\"line\">  </span><br><span class=\"line\">[one, ...other] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(other);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">0: 2  </span></span><br><span class=\"line\"><span class=\"comment\">1: 3  </span></span><br><span class=\"line\"><span class=\"comment\">2: 4  </span></span><br><span class=\"line\"><span class=\"comment\">length: 3  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"><span class=\"comment\">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1 값은 one에 할당되고 할당되지 않은 [2, 3 ,4]는 other에 할당됩니다.</li>\n</ul>\n<hr>\n<h2 id=\"Object-분할-할당\"><a href=\"#Object-분할-할당\" class=\"headerlink\" title=\"Object 분할 할당\"></a>Object 분할 할당</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>   </span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;one, two&#125; = &#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>, <span class=\"attr\">nine</span>: <span class=\"number\">9</span>&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(one, two); <span class=\"comment\">// 1 undefined  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span>   </span><br><span class=\"line\"><span class=\"keyword\">let</span> three, four;  </span><br><span class=\"line\">(&#123;three, four&#125; = &#123;<span class=\"attr\">three</span>: <span class=\"number\">3</span>, <span class=\"attr\">four</span>: <span class=\"number\">4</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(three, four); <span class=\"comment\">// 3 4</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>오른쪽이 오브젝트이면 왼쪽도 오브젝트 여야 합니다.</li>\n</ul>\n<ol>\n<li><p>let {one,two} 형태는 변수 선언과 할당을 한번에 하는 형식입니다.<br>오른쪽 nine이 왼쪽 오브젝트에 없으므로 값을 할당하지 않습니다.<br>왼쪽 two 변수에 값을 할당하지 않았으므로 초기값인 undefined가 유지됩니다.</p>\n</li>\n<li><p>오브젝트 할당에서 사전에 선언된 변수를 사용하려면<br>소괄호() 안에 할당 코드를 작성합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"파라미터-분활-할당\"><a href=\"#파라미터-분활-할당\" class=\"headerlink\" title=\"파라미터 분활 할당\"></a>파라미터 분활 할당</h2><p>호출하는 function 파라미터에 오브젝트를 작성하고<br>호출받는 function 파라미터를 오브젝트 분할 할당 형태로 작성하면<br>함수 블록에서 직접 프로퍼티 이름을 사용할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//호출 받는 function  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">total</span>(<span class=\"params\"> &#123; one, plus: &#123; two, five &#125; &#125; </span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(one + two + five); <span class=\"comment\">// 8  </span></span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//function 호출  </span></span><br><span class=\"line\">total(&#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>, <span class=\"attr\">plus</span>: &#123;<span class=\"attr\">two</span>: <span class=\"number\">2</span>, <span class=\"attr\">five</span>: <span class=\"number\">5</span>&#125;&#125;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>Destructuring 은 배열의 값 또는 객체의 속성을<br>별개의 변수로 압축 해제 할 수있는 JavaScript 표현식입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>형태</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a, b, rest;  </span><br><span class=\"line\">  </span><br><span class=\"line\">[a, b] = [<span class=\"number\">10</span>, <span class=\"number\">20</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">[a, b, ...rest] = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest); <span class=\"comment\">// [30, 40, 50]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">(&#123; a, b &#125; = &#123; <span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span> &#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// Stage 4(finished) proposal  </span></span><br><span class=\"line\">(&#123;a, b, ...rest&#125; = &#123;<span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span>, <span class=\"attr\">c</span>: <span class=\"number\">30</span>, <span class=\"attr\">d</span>: <span class=\"number\">40</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 10  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 20  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest); <span class=\"comment\">// &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure>\n<p>변수에 배열의 엘리먼트를 할당한다는 표현보다<br>배열의 엘리먼트를 변수에 할당한다는 표현이 더 정확합니다.<br>배열의 엘리먼트 값을 변수에 할당하기 위해서는<br>먼저, 배열의 엘리먼트를 분할하고 분할된 엘리먼트 값이 변수에 할당되기 때문입니다.</p>","more":"<hr>\n<h2 id=\"Array-분할-할당\"><a href=\"#Array-분할-할당\" class=\"headerlink\" title=\"Array 분할 할당\"></a>Array 분할 할당</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one, two, three, four, five;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> values = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\">[one, two, three] = values; <span class=\"comment\">//== [1, 2, 3]  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"A:\"</span>, one, two, three); <span class=\"comment\">// A: 1 2 3  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">[one, two] = values; <span class=\"comment\">//== [1, 2, 3]  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"B:\"</span>, one, two);<span class=\"comment\">// B: 1 2  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">[one, two, three, four] = values; <span class=\"comment\">//== [1, 2, 3]  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"C:\"</span>, one, two, three, four); <span class=\"comment\">// C: 1 2 3 undefined  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">[one, two, [three, four]] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">73</span>, <span class=\"number\">74</span>]];   </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"D:\"</span>, one, two, three, four); <span class=\"comment\">// D: 1 2 73 74  </span></span><br><span class=\"line\"><span class=\"comment\">//배열차원이 같지 않으면 에러가 발생합니다. [0,1,[0,1]] = [0,1,[0,1]] 같은 차원 형태</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>spread 사용시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one, two, three, four, other;  </span><br><span class=\"line\">  </span><br><span class=\"line\">[one, ...other] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(other);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">0: 2  </span></span><br><span class=\"line\"><span class=\"comment\">1: 3  </span></span><br><span class=\"line\"><span class=\"comment\">2: 4  </span></span><br><span class=\"line\"><span class=\"comment\">length: 3  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"><span class=\"comment\">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1 값은 one에 할당되고 할당되지 않은 [2, 3 ,4]는 other에 할당됩니다.</li>\n</ul>\n<hr>\n<h2 id=\"Object-분할-할당\"><a href=\"#Object-분할-할당\" class=\"headerlink\" title=\"Object 분할 할당\"></a>Object 분할 할당</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>   </span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;one, two&#125; = &#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>, <span class=\"attr\">nine</span>: <span class=\"number\">9</span>&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(one, two); <span class=\"comment\">// 1 undefined  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span>   </span><br><span class=\"line\"><span class=\"keyword\">let</span> three, four;  </span><br><span class=\"line\">(&#123;three, four&#125; = &#123;<span class=\"attr\">three</span>: <span class=\"number\">3</span>, <span class=\"attr\">four</span>: <span class=\"number\">4</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(three, four); <span class=\"comment\">// 3 4</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>오른쪽이 오브젝트이면 왼쪽도 오브젝트 여야 합니다.</li>\n</ul>\n<ol>\n<li><p>let {one,two} 형태는 변수 선언과 할당을 한번에 하는 형식입니다.<br>오른쪽 nine이 왼쪽 오브젝트에 없으므로 값을 할당하지 않습니다.<br>왼쪽 two 변수에 값을 할당하지 않았으므로 초기값인 undefined가 유지됩니다.</p>\n</li>\n<li><p>오브젝트 할당에서 사전에 선언된 변수를 사용하려면<br>소괄호() 안에 할당 코드를 작성합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"파라미터-분활-할당\"><a href=\"#파라미터-분활-할당\" class=\"headerlink\" title=\"파라미터 분활 할당\"></a>파라미터 분활 할당</h2><p>호출하는 function 파라미터에 오브젝트를 작성하고<br>호출받는 function 파라미터를 오브젝트 분할 할당 형태로 작성하면<br>함수 블록에서 직접 프로퍼티 이름을 사용할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//호출 받는 function  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">total</span>(<span class=\"params\"> &#123; one, plus: &#123; two, five &#125; &#125; </span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(one + two + five); <span class=\"comment\">// 8  </span></span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//function 호출  </span></span><br><span class=\"line\">total(&#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>, <span class=\"attr\">plus</span>: &#123;<span class=\"attr\">two</span>: <span class=\"number\">2</span>, <span class=\"attr\">five</span>: <span class=\"number\">5</span>&#125;&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"DOM (문서 객체 모델)","date":"2020-03-07T21:06:24.000Z","disqusId":"tunas-blog-1","_content":"\nHTML 문서의 구조를 가리켜 문서 객체 모델\n\n(DOM:Document Object Model)이라고 합니다.\n\nDOM을 배우는 주된 목적은 자바스크립트를 사용하여 문서 객체를 선택하고  \n속성 또는 스타일(css)을 적용하기 위해서 입니다.\n\n<!-- more -->\n\n* * *\n\n### 선택자\n\n\n| 구분            | 종류                          | 설명                                                                      |\n|-----------------|-------------------------------|---------------------------------------------------------------------------|\n| 직접 선택자     | document.getElementByid       | 아이디를 이용해 요소를 선택해 옵니다.                                     |\n|                 | document.getElementsByTagName | 요소의 이름을 이용해 요소를 선택해 옵니다.                                |\n|                 | document.formName.inputName   | 폼 요소의 name속성을 이용해 요소를 선택합니다.                            |\n| 인접 관계선택자 | parentNode                    | 선택한 요소의 부모 요소를 선택해 옵니다.                                  |\n|                 | childNodes                    | 선택한 요소의 모든 자식요소를 선택해 옵니다**배열 객체로 저장됩니다.**    |\n|                 | children                      | 선택한 요소의 자식요소인 태그만 선택해 옵니다.**배열 객체로 저장됩니다.** |\n|                 | firstChild                    | 선택한 요소의 첫 번째 자식 요소만 선택해 옵니다.                          |\n|                 | previousSibling               | 선택한 요소의 이전에 오는 형제 요소만 선택해 옵니다.                      |\n|                 | nextSibling                   | 선택한 요소의 다음에 오는 형제 요소만 선택해 옵니다.                      |\n|                 |                               |                                                                           |\n|                 |                               |                                                                           |\n|                 |                               |                                                                           |\n|                 |                               |                                                                           |\n\n\n```js\n//h1 태그를 불러와 style속성 color \"green\" 줍니다.  \ndocument.getElementsByTagName(\"h1\")[0].style.color=\"green\";  \n// title id속성을 가지고 있는 요소를 불러와 red로 적용합니다.  \ndocument.getElementById(\"title\").style.color=\"red\";  \n//id 값이 food_1인 요소의 하위 li 요소중 2번째 요소를 불러와 red로 적용합니다.  \nvar myList=document.getElementById(\"food_1\").getElementsByTagName(\"li\")[1];  \n myList.style.backgroundColor=\"red\";  \n  \n/*id 값이 wrap인 요소의 첫번째 요소가 선택 되야하지만  \nie를 제외한 브라우저에서는 요소가 아닌 공백 문자가 선택되어 표시되지 않습니다.  \n*/  \ndocument.getElementById(\"wrap\").firstChild.style.color=\"red\";  \n    \nvar p=document.getElementsByTagName(\"p\")[1]; // 공백 선택  \n p.nextSibling.style.backgroundColor=\"yellow\"; // 공백 선택  \n```\n\n*   파이어폭스,크롬,사파리 등의 브라우저들은 HTML코드에 공백이 있거나  \n    줄바꿈이 있으면 그것을 한칸의 공백문자로 인식합니다.  \n    하지만 IE 8 이하에서는 정상적으로 공백이나 줄바꿈이 있어도 문자로 인식하지 않습니다.\n\n* * *\n\n### CSS 적용법\n\n\n자바스크립트에서 css 속성을 작성할 때 주의해야 할 점은  \n자바스크립트가 -(하이픈) 문자를 산술 연산자로 인식한다는 것입니다.\n\n따라서\n\n| HTML 에서 CSS사용 시 | 자바스크립트에서 CSS 사용시 |\n|----------------------|-----------------------------|\n| background-color     | backgroundColor             |\n| font-size            | fontSize                    |\n\n* * *\n\n### Node 타입\n\n노드타입(nodeType)을 이용하면 인접 관계 선택자의 호환성 문제를 해결할 수 있습니다.  \nHTML 노드에는 HTML태그를 연결하는 요소(Element)노드와  \n텍스트를 연결하는 텍스트(Text)노드,  \nHTML태그의 속성을 연결해 주는 속성(Attribute)노드가 있습니다.\n\n선택자로 선택한 요소가 어떤 노드인가에 따라 노드 타입 값이 다음과 같이 표기 됩니다.\n\n| 종류                 | 타입 값 |\n|----------------------|---------|\n| 요소(Element) 노드   | 1       |\n| 속성(Attribute) 노드 | 2       |\n| 텍스트(Text) 노드    | 3       |\n\n\n```js 예시\n<a href=\"http://w3.org\" id=\"m\">W3C</a>;  \n\ndocument.getElementByid(\"m\").nodeType; // 1 \"<a>\"  \ndocument.getElementByid(\"m\").firstChild.nodeType; // 3 \"W3C\"  \ndocument.getElementByid(\"m\").getAttributNode(\"href\").nodeType; // 2 \"href\"  \n```\n\n```js 비표준 인접 관계 선택자 해결법\ndocument.getElementById(\"wrap\").children[0].style.color=\"red\";  \n    \nvar p=document.getElementsByTagName(\"p\")[1];  \nvar nextObj=p.nextSibling;  \n  \nwhile(nextObj.nodeType !=1){ //다음 요소 태그를 찾을때까지 반복합니다.  \n nextObj=nextObj.nextSibling;  \n }  \n nextObj.style.backgroundColor=\"yellow\";  \n```\n\n* * *\n\n#### getAttribute\n\ngetAttribute () 메소드는 지정된 이름을 가진 속성 값을 요소의 값으로 반한합니다.\n\n    기본형\n    element.getAttribute(attributename)\n\n* * *\n\n#### 1.1 .getAttribute\n\n.getAttribute(“속성”);  \n요소의 지정한 속성값을 불러옵니다.\n\n> var x = document.getElementsByTagName(“H1”)[0].getAttribute(“class”);\n\n* * *\n\n#### 1.2 .setAttribute\n\n.setAttribute(“속성”,”새 값”);  \nsetAttribute () 메소드는 지정된 속성을 요소에 추가하고 지정된 값을 제공합니다.  \n추가하려는 속성이 이미 존재한다면, 지정된 값만 추가/변경 됩니다.  \nIE 8.0 이전 버젼에서 작동하지 않을 수 있습니다.\n\n이 메소드를 사용하여 값에 스타일 속성을 요소에 추가 할 수 있지만 인라인 스타일링 대신 스타일 오브젝트의 속성을 사용하는 것이 좋습니다. 이는 **스타일에 지정된 다른 CSS 속성을 덮어 쓰지 않기 때문입니다.**\n\nBad:\n\n> element.setAttribute(“style”, “background-color: red;”);\n\nGood:\n\n> element.style.backgroundColor = “red”;\n\n* * *\n\n#### 1.3 .removeAttribute\n\nremoveAttribute () 메소드는 요소에서 지정된 속성을 제거합니다.\n\nremoveAttributNode() 메소드와 다른점은  \nremoveAttributeNode() 메소드는 지정된 Attr 오브젝트를 제거하고 이 메소드는 지정된 이름의 속성을 제거합니다.  \n둘의 결과는 다르지 않지만,  \nremoveAttribute() 메소드는 반환 값을 갖지 않는 반면  \nremoveAttributeNode() 메소드는 제거 된 속성을 Attr 오브젝트로 반환합니다.\n\n> document.getElementById(“myAnchor”).removeAttribute(“href”);\n\n* * *\n\n#### 1.4 .hasAtrribute\n\nhasAttribute () 메소드는 지정된 속성이 존재하면 true를, 그렇지 않으면 false를 리턴합니다.  \nIE 9.0 이전 버젼에서 작동하지 않을 수 있습니다.\n\n> var x = document.getElementById(“myBtn”).hasAttribute(“onclick”);\n\n* * *\n\n### innerHTML\n\ninnerHTML은 요소(element)내에 포함 된 HTML 또는 XML 마크업을 가져오거나 설정합니다.\n\n*   주의: < div>, < span> 노드가 (&), (<), (>) 문자를 포함하는 텍스트 노드를 자식으로 가지고 있다면,  \n    innerHTML은 이러한 문자들을 각각 “&amp ;”, “&lt ;” ,”&gt ;”로 반환합니다.  \n    Node.textContent를 사용하여 이러한 텍스트 노드 내용의 원본을 복사할 수 있습니다.\n\n종류|설명\n------|------\nelement.innerHTML | 선택한 요소의 모든 하위 요소를 문자 데이터로 반환합니다.\nelement.innerHTML= text; | 선택한 요소의 전체 하위 요소를 새 요소로 변경 또는 생성합니다.\n\n*   경고: 프로젝트가 보안 점검을 거치게 되는 프로젝트인 경우,  \n    innerHTML 을 사용하면 코드가 거부 될 가능성이 높습니다.  \n    예를 들어, 브라우저 확장에서 innerHTML을 사용하고  \n    addons.mozilla.org에 확장을 제출하면 자동 검토 프로세스를 통과하지 못합니다.\n\n* * *\n\n### 이벤트\n\n여기서는 이벤트를 적용시키는 방법과 몇 가지 종류만 다루고  \n자세한 내용은 뒤에서 다룹니다.\n\n| 이벤트      | 설명                                     |\n|-------------|------------------------------------------|\n| onclick     | 요소를 마우스 클릭했을 때 이벤트가 발생  |\n| onmouseover | 요소를 마우스 오버 했을 때 이벤트 발생.  |\n| onmounout   | 요소에 마우스가 벗어났을 때 이벤트 발생. |\n| submit      | 폼에 전송이 일어났을 때 이벤트 발생.     |\n\n    기본형\n    요소선택.이벤트종류=function(){\n   \n    }\n\n```js 예시\ndocument.getElementByid(\"btn1\").onclick=function(){  \n alert(\"welcome\")  \n}  \n```\n\n* * *\n\n### form 요소 선택자\n\n유저가 입력한 값이 유효한 값인지 검사하기 위해서는  \n폼에 입력 요소를 선택하고 속성을 제어할 수 있어야 합니다.  \n아래는 폼 요소를 선택할 때 사용하는 몇 가지 방식입니다.\n\n| 구분                 | 종류                                                                                           | 설명                                       |\n|----------------------|------------------------------------------------------------------------------------------------|--------------------------------------------|\n| 입력 요소 선택자     | document.getElementByid(“아이디 명)                                                            | 폼 요소를 아이디로 선택합니다.             |\n|                      | document.폼이름.입력 요소 이름                                                                 | 폼 요소를 이름으로 선택합니다.             |\n| select option 선택자 | document.폼이름.입력 요소 이름.option[ index]                                                  | < select>에< option>을 선택합니다.         |\n|                      | var i= document.폼이름.입력요소 이름.selectedIndex; document.폼 이름.입력요소 이름.option[ i]; | < select>에 선택된 < option>을 선택합니다. |\n\n\n**폼 요소 속성 종류**\n\n| 구분                  | 속성         | 설명                                                                                                                    |\n|-----------------------|--------------|-------------------------------------------------------------------------------------------------------------------------|\n| 전체                  | value        | 입력 요소의 value 속성을 변경하거나, 값을 가져옵니다.                                                                   |\n|                       | disabled     | 입력 요소의 disabled 속성을 변경하거나, 현재 상태의 값을 가져옵니다.                                                    |\n|                       | defaultValue | 입력 요소 초기에 입력된 value 값을 가져옵니다.                                                                          |\n| 선택박스              | selected     | < select>태그에 < option> 선택된 상태 값을 가져옵니다. 선택되있다면true 아니라면 false                                  |\n| 체크 박스 라디오 버튼 | checked      | 체크박스 또는 라디오 버튼태그 체크 상태 값을 반환하거나 체크 여부를 제어 합니다. 체크 되있으면 true 해제되 있다면 false |\n\n","source":"_posts/DOM 문서 객체 모델.md","raw":"---\ntitle: DOM (문서 객체 모델)\ndate: 2020-03-08 06:06:24\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\nHTML 문서의 구조를 가리켜 문서 객체 모델\n\n(DOM:Document Object Model)이라고 합니다.\n\nDOM을 배우는 주된 목적은 자바스크립트를 사용하여 문서 객체를 선택하고  \n속성 또는 스타일(css)을 적용하기 위해서 입니다.\n\n<!-- more -->\n\n* * *\n\n### 선택자\n\n\n| 구분            | 종류                          | 설명                                                                      |\n|-----------------|-------------------------------|---------------------------------------------------------------------------|\n| 직접 선택자     | document.getElementByid       | 아이디를 이용해 요소를 선택해 옵니다.                                     |\n|                 | document.getElementsByTagName | 요소의 이름을 이용해 요소를 선택해 옵니다.                                |\n|                 | document.formName.inputName   | 폼 요소의 name속성을 이용해 요소를 선택합니다.                            |\n| 인접 관계선택자 | parentNode                    | 선택한 요소의 부모 요소를 선택해 옵니다.                                  |\n|                 | childNodes                    | 선택한 요소의 모든 자식요소를 선택해 옵니다**배열 객체로 저장됩니다.**    |\n|                 | children                      | 선택한 요소의 자식요소인 태그만 선택해 옵니다.**배열 객체로 저장됩니다.** |\n|                 | firstChild                    | 선택한 요소의 첫 번째 자식 요소만 선택해 옵니다.                          |\n|                 | previousSibling               | 선택한 요소의 이전에 오는 형제 요소만 선택해 옵니다.                      |\n|                 | nextSibling                   | 선택한 요소의 다음에 오는 형제 요소만 선택해 옵니다.                      |\n|                 |                               |                                                                           |\n|                 |                               |                                                                           |\n|                 |                               |                                                                           |\n|                 |                               |                                                                           |\n\n\n```js\n//h1 태그를 불러와 style속성 color \"green\" 줍니다.  \ndocument.getElementsByTagName(\"h1\")[0].style.color=\"green\";  \n// title id속성을 가지고 있는 요소를 불러와 red로 적용합니다.  \ndocument.getElementById(\"title\").style.color=\"red\";  \n//id 값이 food_1인 요소의 하위 li 요소중 2번째 요소를 불러와 red로 적용합니다.  \nvar myList=document.getElementById(\"food_1\").getElementsByTagName(\"li\")[1];  \n myList.style.backgroundColor=\"red\";  \n  \n/*id 값이 wrap인 요소의 첫번째 요소가 선택 되야하지만  \nie를 제외한 브라우저에서는 요소가 아닌 공백 문자가 선택되어 표시되지 않습니다.  \n*/  \ndocument.getElementById(\"wrap\").firstChild.style.color=\"red\";  \n    \nvar p=document.getElementsByTagName(\"p\")[1]; // 공백 선택  \n p.nextSibling.style.backgroundColor=\"yellow\"; // 공백 선택  \n```\n\n*   파이어폭스,크롬,사파리 등의 브라우저들은 HTML코드에 공백이 있거나  \n    줄바꿈이 있으면 그것을 한칸의 공백문자로 인식합니다.  \n    하지만 IE 8 이하에서는 정상적으로 공백이나 줄바꿈이 있어도 문자로 인식하지 않습니다.\n\n* * *\n\n### CSS 적용법\n\n\n자바스크립트에서 css 속성을 작성할 때 주의해야 할 점은  \n자바스크립트가 -(하이픈) 문자를 산술 연산자로 인식한다는 것입니다.\n\n따라서\n\n| HTML 에서 CSS사용 시 | 자바스크립트에서 CSS 사용시 |\n|----------------------|-----------------------------|\n| background-color     | backgroundColor             |\n| font-size            | fontSize                    |\n\n* * *\n\n### Node 타입\n\n노드타입(nodeType)을 이용하면 인접 관계 선택자의 호환성 문제를 해결할 수 있습니다.  \nHTML 노드에는 HTML태그를 연결하는 요소(Element)노드와  \n텍스트를 연결하는 텍스트(Text)노드,  \nHTML태그의 속성을 연결해 주는 속성(Attribute)노드가 있습니다.\n\n선택자로 선택한 요소가 어떤 노드인가에 따라 노드 타입 값이 다음과 같이 표기 됩니다.\n\n| 종류                 | 타입 값 |\n|----------------------|---------|\n| 요소(Element) 노드   | 1       |\n| 속성(Attribute) 노드 | 2       |\n| 텍스트(Text) 노드    | 3       |\n\n\n```js 예시\n<a href=\"http://w3.org\" id=\"m\">W3C</a>;  \n\ndocument.getElementByid(\"m\").nodeType; // 1 \"<a>\"  \ndocument.getElementByid(\"m\").firstChild.nodeType; // 3 \"W3C\"  \ndocument.getElementByid(\"m\").getAttributNode(\"href\").nodeType; // 2 \"href\"  \n```\n\n```js 비표준 인접 관계 선택자 해결법\ndocument.getElementById(\"wrap\").children[0].style.color=\"red\";  \n    \nvar p=document.getElementsByTagName(\"p\")[1];  \nvar nextObj=p.nextSibling;  \n  \nwhile(nextObj.nodeType !=1){ //다음 요소 태그를 찾을때까지 반복합니다.  \n nextObj=nextObj.nextSibling;  \n }  \n nextObj.style.backgroundColor=\"yellow\";  \n```\n\n* * *\n\n#### getAttribute\n\ngetAttribute () 메소드는 지정된 이름을 가진 속성 값을 요소의 값으로 반한합니다.\n\n    기본형\n    element.getAttribute(attributename)\n\n* * *\n\n#### 1.1 .getAttribute\n\n.getAttribute(“속성”);  \n요소의 지정한 속성값을 불러옵니다.\n\n> var x = document.getElementsByTagName(“H1”)[0].getAttribute(“class”);\n\n* * *\n\n#### 1.2 .setAttribute\n\n.setAttribute(“속성”,”새 값”);  \nsetAttribute () 메소드는 지정된 속성을 요소에 추가하고 지정된 값을 제공합니다.  \n추가하려는 속성이 이미 존재한다면, 지정된 값만 추가/변경 됩니다.  \nIE 8.0 이전 버젼에서 작동하지 않을 수 있습니다.\n\n이 메소드를 사용하여 값에 스타일 속성을 요소에 추가 할 수 있지만 인라인 스타일링 대신 스타일 오브젝트의 속성을 사용하는 것이 좋습니다. 이는 **스타일에 지정된 다른 CSS 속성을 덮어 쓰지 않기 때문입니다.**\n\nBad:\n\n> element.setAttribute(“style”, “background-color: red;”);\n\nGood:\n\n> element.style.backgroundColor = “red”;\n\n* * *\n\n#### 1.3 .removeAttribute\n\nremoveAttribute () 메소드는 요소에서 지정된 속성을 제거합니다.\n\nremoveAttributNode() 메소드와 다른점은  \nremoveAttributeNode() 메소드는 지정된 Attr 오브젝트를 제거하고 이 메소드는 지정된 이름의 속성을 제거합니다.  \n둘의 결과는 다르지 않지만,  \nremoveAttribute() 메소드는 반환 값을 갖지 않는 반면  \nremoveAttributeNode() 메소드는 제거 된 속성을 Attr 오브젝트로 반환합니다.\n\n> document.getElementById(“myAnchor”).removeAttribute(“href”);\n\n* * *\n\n#### 1.4 .hasAtrribute\n\nhasAttribute () 메소드는 지정된 속성이 존재하면 true를, 그렇지 않으면 false를 리턴합니다.  \nIE 9.0 이전 버젼에서 작동하지 않을 수 있습니다.\n\n> var x = document.getElementById(“myBtn”).hasAttribute(“onclick”);\n\n* * *\n\n### innerHTML\n\ninnerHTML은 요소(element)내에 포함 된 HTML 또는 XML 마크업을 가져오거나 설정합니다.\n\n*   주의: < div>, < span> 노드가 (&), (<), (>) 문자를 포함하는 텍스트 노드를 자식으로 가지고 있다면,  \n    innerHTML은 이러한 문자들을 각각 “&amp ;”, “&lt ;” ,”&gt ;”로 반환합니다.  \n    Node.textContent를 사용하여 이러한 텍스트 노드 내용의 원본을 복사할 수 있습니다.\n\n종류|설명\n------|------\nelement.innerHTML | 선택한 요소의 모든 하위 요소를 문자 데이터로 반환합니다.\nelement.innerHTML= text; | 선택한 요소의 전체 하위 요소를 새 요소로 변경 또는 생성합니다.\n\n*   경고: 프로젝트가 보안 점검을 거치게 되는 프로젝트인 경우,  \n    innerHTML 을 사용하면 코드가 거부 될 가능성이 높습니다.  \n    예를 들어, 브라우저 확장에서 innerHTML을 사용하고  \n    addons.mozilla.org에 확장을 제출하면 자동 검토 프로세스를 통과하지 못합니다.\n\n* * *\n\n### 이벤트\n\n여기서는 이벤트를 적용시키는 방법과 몇 가지 종류만 다루고  \n자세한 내용은 뒤에서 다룹니다.\n\n| 이벤트      | 설명                                     |\n|-------------|------------------------------------------|\n| onclick     | 요소를 마우스 클릭했을 때 이벤트가 발생  |\n| onmouseover | 요소를 마우스 오버 했을 때 이벤트 발생.  |\n| onmounout   | 요소에 마우스가 벗어났을 때 이벤트 발생. |\n| submit      | 폼에 전송이 일어났을 때 이벤트 발생.     |\n\n    기본형\n    요소선택.이벤트종류=function(){\n   \n    }\n\n```js 예시\ndocument.getElementByid(\"btn1\").onclick=function(){  \n alert(\"welcome\")  \n}  \n```\n\n* * *\n\n### form 요소 선택자\n\n유저가 입력한 값이 유효한 값인지 검사하기 위해서는  \n폼에 입력 요소를 선택하고 속성을 제어할 수 있어야 합니다.  \n아래는 폼 요소를 선택할 때 사용하는 몇 가지 방식입니다.\n\n| 구분                 | 종류                                                                                           | 설명                                       |\n|----------------------|------------------------------------------------------------------------------------------------|--------------------------------------------|\n| 입력 요소 선택자     | document.getElementByid(“아이디 명)                                                            | 폼 요소를 아이디로 선택합니다.             |\n|                      | document.폼이름.입력 요소 이름                                                                 | 폼 요소를 이름으로 선택합니다.             |\n| select option 선택자 | document.폼이름.입력 요소 이름.option[ index]                                                  | < select>에< option>을 선택합니다.         |\n|                      | var i= document.폼이름.입력요소 이름.selectedIndex; document.폼 이름.입력요소 이름.option[ i]; | < select>에 선택된 < option>을 선택합니다. |\n\n\n**폼 요소 속성 종류**\n\n| 구분                  | 속성         | 설명                                                                                                                    |\n|-----------------------|--------------|-------------------------------------------------------------------------------------------------------------------------|\n| 전체                  | value        | 입력 요소의 value 속성을 변경하거나, 값을 가져옵니다.                                                                   |\n|                       | disabled     | 입력 요소의 disabled 속성을 변경하거나, 현재 상태의 값을 가져옵니다.                                                    |\n|                       | defaultValue | 입력 요소 초기에 입력된 value 값을 가져옵니다.                                                                          |\n| 선택박스              | selected     | < select>태그에 < option> 선택된 상태 값을 가져옵니다. 선택되있다면true 아니라면 false                                  |\n| 체크 박스 라디오 버튼 | checked      | 체크박스 또는 라디오 버튼태그 체크 상태 값을 반환하거나 체크 여부를 제어 합니다. 체크 되있으면 true 해제되 있다면 false |\n\n","slug":"DOM 문서 객체 모델","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrrx000aqgvq5r8x8t67","content":"<p>HTML 문서의 구조를 가리켜 문서 객체 모델</p>\n<p>(DOM:Document Object Model)이라고 합니다.</p>\n<p>DOM을 배우는 주된 목적은 자바스크립트를 사용하여 문서 객체를 선택하고<br>속성 또는 스타일(css)을 적용하기 위해서 입니다.</p>\n<a id=\"more\"></a>\n\n<hr>\n<h3 id=\"선택자\"><a href=\"#선택자\" class=\"headerlink\" title=\"선택자\"></a>선택자</h3><table>\n<thead>\n<tr>\n<th>구분</th>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>직접 선택자</td>\n<td>document.getElementByid</td>\n<td>아이디를 이용해 요소를 선택해 옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>document.getElementsByTagName</td>\n<td>요소의 이름을 이용해 요소를 선택해 옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>document.formName.inputName</td>\n<td>폼 요소의 name속성을 이용해 요소를 선택합니다.</td>\n</tr>\n<tr>\n<td>인접 관계선택자</td>\n<td>parentNode</td>\n<td>선택한 요소의 부모 요소를 선택해 옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>childNodes</td>\n<td>선택한 요소의 모든 자식요소를 선택해 옵니다<strong>배열 객체로 저장됩니다.</strong></td>\n</tr>\n<tr>\n<td></td>\n<td>children</td>\n<td>선택한 요소의 자식요소인 태그만 선택해 옵니다.<strong>배열 객체로 저장됩니다.</strong></td>\n</tr>\n<tr>\n<td></td>\n<td>firstChild</td>\n<td>선택한 요소의 첫 번째 자식 요소만 선택해 옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>previousSibling</td>\n<td>선택한 요소의 이전에 오는 형제 요소만 선택해 옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>nextSibling</td>\n<td>선택한 요소의 다음에 오는 형제 요소만 선택해 옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//h1 태그를 불러와 style속성 color \"green\" 줍니다.  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"h1\"</span>)[<span class=\"number\">0</span>].style.color=<span class=\"string\">\"green\"</span>;  </span><br><span class=\"line\"><span class=\"comment\">// title id속성을 가지고 있는 요소를 불러와 red로 적용합니다.  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"title\"</span>).style.color=<span class=\"string\">\"red\"</span>;  </span><br><span class=\"line\"><span class=\"comment\">//id 값이 food_1인 요소의 하위 li 요소중 2번째 요소를 불러와 red로 적용합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myList=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"food_1\"</span>).getElementsByTagName(<span class=\"string\">\"li\"</span>)[<span class=\"number\">1</span>];  </span><br><span class=\"line\"> myList.style.backgroundColor=<span class=\"string\">\"red\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/*id 값이 wrap인 요소의 첫번째 요소가 선택 되야하지만  </span></span><br><span class=\"line\"><span class=\"comment\">ie를 제외한 브라우저에서는 요소가 아닌 공백 문자가 선택되어 표시되지 않습니다.  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"wrap\"</span>).firstChild.style.color=<span class=\"string\">\"red\"</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">var</span> p=<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"p\"</span>)[<span class=\"number\">1</span>]; <span class=\"comment\">// 공백 선택  </span></span><br><span class=\"line\"> p.nextSibling.style.backgroundColor=<span class=\"string\">\"yellow\"</span>; <span class=\"comment\">// 공백 선택</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>파이어폭스,크롬,사파리 등의 브라우저들은 HTML코드에 공백이 있거나<br>줄바꿈이 있으면 그것을 한칸의 공백문자로 인식합니다.<br>하지만 IE 8 이하에서는 정상적으로 공백이나 줄바꿈이 있어도 문자로 인식하지 않습니다.</li>\n</ul>\n<hr>\n<h3 id=\"CSS-적용법\"><a href=\"#CSS-적용법\" class=\"headerlink\" title=\"CSS 적용법\"></a>CSS 적용법</h3><p>자바스크립트에서 css 속성을 작성할 때 주의해야 할 점은<br>자바스크립트가 -(하이픈) 문자를 산술 연산자로 인식한다는 것입니다.</p>\n<p>따라서</p>\n<table>\n<thead>\n<tr>\n<th>HTML 에서 CSS사용 시</th>\n<th>자바스크립트에서 CSS 사용시</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>background-color</td>\n<td>backgroundColor</td>\n</tr>\n<tr>\n<td>font-size</td>\n<td>fontSize</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"Node-타입\"><a href=\"#Node-타입\" class=\"headerlink\" title=\"Node 타입\"></a>Node 타입</h3><p>노드타입(nodeType)을 이용하면 인접 관계 선택자의 호환성 문제를 해결할 수 있습니다.<br>HTML 노드에는 HTML태그를 연결하는 요소(Element)노드와<br>텍스트를 연결하는 텍스트(Text)노드,<br>HTML태그의 속성을 연결해 주는 속성(Attribute)노드가 있습니다.</p>\n<p>선택자로 선택한 요소가 어떤 노드인가에 따라 노드 타입 값이 다음과 같이 표기 됩니다.</p>\n<table>\n<thead>\n<tr>\n<th>종류</th>\n<th>타입 값</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>요소(Element) 노드</td>\n<td>1</td>\n</tr>\n<tr>\n<td>속성(Attribute) 노드</td>\n<td>2</td>\n</tr>\n<tr>\n<td>텍스트(Text) 노드</td>\n<td>3</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight js\"><figcaption><span>예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">\"http://w3.org\"</span> id=<span class=\"string\">\"m\"</span>&gt;W3C&lt;<span class=\"regexp\">/a&gt;;  </span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">document.getElementByid(\"m\").nodeType; /</span><span class=\"regexp\">/ 1 \"&lt;a&gt;\"  </span></span><br><span class=\"line\"><span class=\"regexp\">document.getElementByid(\"m\").firstChild.nodeType; /</span><span class=\"regexp\">/ 3 \"W3C\"  </span></span><br><span class=\"line\"><span class=\"regexp\">document.getElementByid(\"m\").getAttributNode(\"href\").nodeType; /</span><span class=\"regexp\">/ 2 \"href\"</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>비표준 인접 관계 선택자 해결법</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"wrap\"</span>).children[<span class=\"number\">0</span>].style.color=<span class=\"string\">\"red\"</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">var</span> p=<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"p\"</span>)[<span class=\"number\">1</span>];  </span><br><span class=\"line\"><span class=\"keyword\">var</span> nextObj=p.nextSibling;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">while</span>(nextObj.nodeType !=<span class=\"number\">1</span>)&#123; <span class=\"comment\">//다음 요소 태그를 찾을때까지 반복합니다.  </span></span><br><span class=\"line\"> nextObj=nextObj.nextSibling;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> nextObj.style.backgroundColor=<span class=\"string\">\"yellow\"</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"getAttribute\"><a href=\"#getAttribute\" class=\"headerlink\" title=\"getAttribute\"></a>getAttribute</h4><p>getAttribute () 메소드는 지정된 이름을 가진 속성 값을 요소의 값으로 반한합니다.</p>\n<pre><code>기본형\nelement.getAttribute(attributename)</code></pre><hr>\n<h4 id=\"1-1-getAttribute\"><a href=\"#1-1-getAttribute\" class=\"headerlink\" title=\"1.1 .getAttribute\"></a>1.1 .getAttribute</h4><p>.getAttribute(“속성”);<br>요소의 지정한 속성값을 불러옵니다.</p>\n<blockquote>\n<p>var x = document.getElementsByTagName(“H1”)[0].getAttribute(“class”);</p>\n</blockquote>\n<hr>\n<h4 id=\"1-2-setAttribute\"><a href=\"#1-2-setAttribute\" class=\"headerlink\" title=\"1.2 .setAttribute\"></a>1.2 .setAttribute</h4><p>.setAttribute(“속성”,”새 값”);<br>setAttribute () 메소드는 지정된 속성을 요소에 추가하고 지정된 값을 제공합니다.<br>추가하려는 속성이 이미 존재한다면, 지정된 값만 추가/변경 됩니다.<br>IE 8.0 이전 버젼에서 작동하지 않을 수 있습니다.</p>\n<p>이 메소드를 사용하여 값에 스타일 속성을 요소에 추가 할 수 있지만 인라인 스타일링 대신 스타일 오브젝트의 속성을 사용하는 것이 좋습니다. 이는 <strong>스타일에 지정된 다른 CSS 속성을 덮어 쓰지 않기 때문입니다.</strong></p>\n<p>Bad:</p>\n<blockquote>\n<p>element.setAttribute(“style”, “background-color: red;”);</p>\n</blockquote>\n<p>Good:</p>\n<blockquote>\n<p>element.style.backgroundColor = “red”;</p>\n</blockquote>\n<hr>\n<h4 id=\"1-3-removeAttribute\"><a href=\"#1-3-removeAttribute\" class=\"headerlink\" title=\"1.3 .removeAttribute\"></a>1.3 .removeAttribute</h4><p>removeAttribute () 메소드는 요소에서 지정된 속성을 제거합니다.</p>\n<p>removeAttributNode() 메소드와 다른점은<br>removeAttributeNode() 메소드는 지정된 Attr 오브젝트를 제거하고 이 메소드는 지정된 이름의 속성을 제거합니다.<br>둘의 결과는 다르지 않지만,<br>removeAttribute() 메소드는 반환 값을 갖지 않는 반면<br>removeAttributeNode() 메소드는 제거 된 속성을 Attr 오브젝트로 반환합니다.</p>\n<blockquote>\n<p>document.getElementById(“myAnchor”).removeAttribute(“href”);</p>\n</blockquote>\n<hr>\n<h4 id=\"1-4-hasAtrribute\"><a href=\"#1-4-hasAtrribute\" class=\"headerlink\" title=\"1.4 .hasAtrribute\"></a>1.4 .hasAtrribute</h4><p>hasAttribute () 메소드는 지정된 속성이 존재하면 true를, 그렇지 않으면 false를 리턴합니다.<br>IE 9.0 이전 버젼에서 작동하지 않을 수 있습니다.</p>\n<blockquote>\n<p>var x = document.getElementById(“myBtn”).hasAttribute(“onclick”);</p>\n</blockquote>\n<hr>\n<h3 id=\"innerHTML\"><a href=\"#innerHTML\" class=\"headerlink\" title=\"innerHTML\"></a>innerHTML</h3><p>innerHTML은 요소(element)내에 포함 된 HTML 또는 XML 마크업을 가져오거나 설정합니다.</p>\n<ul>\n<li>주의: &lt; div&gt;, &lt; span&gt; 노드가 (&amp;), (&lt;), (&gt;) 문자를 포함하는 텍스트 노드를 자식으로 가지고 있다면,<br>innerHTML은 이러한 문자들을 각각 “&amp;amp ;”, “&amp;lt ;” ,”&amp;gt ;”로 반환합니다.<br>Node.textContent를 사용하여 이러한 텍스트 노드 내용의 원본을 복사할 수 있습니다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>element.innerHTML</td>\n<td>선택한 요소의 모든 하위 요소를 문자 데이터로 반환합니다.</td>\n</tr>\n<tr>\n<td>element.innerHTML= text;</td>\n<td>선택한 요소의 전체 하위 요소를 새 요소로 변경 또는 생성합니다.</td>\n</tr>\n</tbody></table>\n<ul>\n<li>경고: 프로젝트가 보안 점검을 거치게 되는 프로젝트인 경우,<br>innerHTML 을 사용하면 코드가 거부 될 가능성이 높습니다.<br>예를 들어, 브라우저 확장에서 innerHTML을 사용하고<br>addons.mozilla.org에 확장을 제출하면 자동 검토 프로세스를 통과하지 못합니다.</li>\n</ul>\n<hr>\n<h3 id=\"이벤트\"><a href=\"#이벤트\" class=\"headerlink\" title=\"이벤트\"></a>이벤트</h3><p>여기서는 이벤트를 적용시키는 방법과 몇 가지 종류만 다루고<br>자세한 내용은 뒤에서 다룹니다.</p>\n<table>\n<thead>\n<tr>\n<th>이벤트</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onclick</td>\n<td>요소를 마우스 클릭했을 때 이벤트가 발생</td>\n</tr>\n<tr>\n<td>onmouseover</td>\n<td>요소를 마우스 오버 했을 때 이벤트 발생.</td>\n</tr>\n<tr>\n<td>onmounout</td>\n<td>요소에 마우스가 벗어났을 때 이벤트 발생.</td>\n</tr>\n<tr>\n<td>submit</td>\n<td>폼에 전송이 일어났을 때 이벤트 발생.</td>\n</tr>\n</tbody></table>\n<pre><code>기본형\n요소선택.이벤트종류=function(){\n\n}</code></pre><figure class=\"highlight js\"><figcaption><span>예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementByid(<span class=\"string\">\"btn1\"</span>).onclick=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> alert(<span class=\"string\">\"welcome\"</span>)  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"form-요소-선택자\"><a href=\"#form-요소-선택자\" class=\"headerlink\" title=\"form 요소 선택자\"></a>form 요소 선택자</h3><p>유저가 입력한 값이 유효한 값인지 검사하기 위해서는<br>폼에 입력 요소를 선택하고 속성을 제어할 수 있어야 합니다.<br>아래는 폼 요소를 선택할 때 사용하는 몇 가지 방식입니다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>입력 요소 선택자</td>\n<td>document.getElementByid(“아이디 명)</td>\n<td>폼 요소를 아이디로 선택합니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>document.폼이름.입력 요소 이름</td>\n<td>폼 요소를 이름으로 선택합니다.</td>\n</tr>\n<tr>\n<td>select option 선택자</td>\n<td>document.폼이름.입력 요소 이름.option[ index]</td>\n<td>&lt; select&gt;에&lt; option&gt;을 선택합니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>var i= document.폼이름.입력요소 이름.selectedIndex; document.폼 이름.입력요소 이름.option[ i];</td>\n<td>&lt; select&gt;에 선택된 &lt; option&gt;을 선택합니다.</td>\n</tr>\n</tbody></table>\n<p><strong>폼 요소 속성 종류</strong></p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>전체</td>\n<td>value</td>\n<td>입력 요소의 value 속성을 변경하거나, 값을 가져옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>disabled</td>\n<td>입력 요소의 disabled 속성을 변경하거나, 현재 상태의 값을 가져옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>defaultValue</td>\n<td>입력 요소 초기에 입력된 value 값을 가져옵니다.</td>\n</tr>\n<tr>\n<td>선택박스</td>\n<td>selected</td>\n<td>&lt; select&gt;태그에 &lt; option&gt; 선택된 상태 값을 가져옵니다. 선택되있다면true 아니라면 false</td>\n</tr>\n<tr>\n<td>체크 박스 라디오 버튼</td>\n<td>checked</td>\n<td>체크박스 또는 라디오 버튼태그 체크 상태 값을 반환하거나 체크 여부를 제어 합니다. 체크 되있으면 true 해제되 있다면 false</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<p>HTML 문서의 구조를 가리켜 문서 객체 모델</p>\n<p>(DOM:Document Object Model)이라고 합니다.</p>\n<p>DOM을 배우는 주된 목적은 자바스크립트를 사용하여 문서 객체를 선택하고<br>속성 또는 스타일(css)을 적용하기 위해서 입니다.</p>","more":"<hr>\n<h3 id=\"선택자\"><a href=\"#선택자\" class=\"headerlink\" title=\"선택자\"></a>선택자</h3><table>\n<thead>\n<tr>\n<th>구분</th>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>직접 선택자</td>\n<td>document.getElementByid</td>\n<td>아이디를 이용해 요소를 선택해 옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>document.getElementsByTagName</td>\n<td>요소의 이름을 이용해 요소를 선택해 옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>document.formName.inputName</td>\n<td>폼 요소의 name속성을 이용해 요소를 선택합니다.</td>\n</tr>\n<tr>\n<td>인접 관계선택자</td>\n<td>parentNode</td>\n<td>선택한 요소의 부모 요소를 선택해 옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>childNodes</td>\n<td>선택한 요소의 모든 자식요소를 선택해 옵니다<strong>배열 객체로 저장됩니다.</strong></td>\n</tr>\n<tr>\n<td></td>\n<td>children</td>\n<td>선택한 요소의 자식요소인 태그만 선택해 옵니다.<strong>배열 객체로 저장됩니다.</strong></td>\n</tr>\n<tr>\n<td></td>\n<td>firstChild</td>\n<td>선택한 요소의 첫 번째 자식 요소만 선택해 옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>previousSibling</td>\n<td>선택한 요소의 이전에 오는 형제 요소만 선택해 옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>nextSibling</td>\n<td>선택한 요소의 다음에 오는 형제 요소만 선택해 옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//h1 태그를 불러와 style속성 color \"green\" 줍니다.  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"h1\"</span>)[<span class=\"number\">0</span>].style.color=<span class=\"string\">\"green\"</span>;  </span><br><span class=\"line\"><span class=\"comment\">// title id속성을 가지고 있는 요소를 불러와 red로 적용합니다.  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"title\"</span>).style.color=<span class=\"string\">\"red\"</span>;  </span><br><span class=\"line\"><span class=\"comment\">//id 값이 food_1인 요소의 하위 li 요소중 2번째 요소를 불러와 red로 적용합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myList=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"food_1\"</span>).getElementsByTagName(<span class=\"string\">\"li\"</span>)[<span class=\"number\">1</span>];  </span><br><span class=\"line\"> myList.style.backgroundColor=<span class=\"string\">\"red\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/*id 값이 wrap인 요소의 첫번째 요소가 선택 되야하지만  </span></span><br><span class=\"line\"><span class=\"comment\">ie를 제외한 브라우저에서는 요소가 아닌 공백 문자가 선택되어 표시되지 않습니다.  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"wrap\"</span>).firstChild.style.color=<span class=\"string\">\"red\"</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">var</span> p=<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"p\"</span>)[<span class=\"number\">1</span>]; <span class=\"comment\">// 공백 선택  </span></span><br><span class=\"line\"> p.nextSibling.style.backgroundColor=<span class=\"string\">\"yellow\"</span>; <span class=\"comment\">// 공백 선택</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>파이어폭스,크롬,사파리 등의 브라우저들은 HTML코드에 공백이 있거나<br>줄바꿈이 있으면 그것을 한칸의 공백문자로 인식합니다.<br>하지만 IE 8 이하에서는 정상적으로 공백이나 줄바꿈이 있어도 문자로 인식하지 않습니다.</li>\n</ul>\n<hr>\n<h3 id=\"CSS-적용법\"><a href=\"#CSS-적용법\" class=\"headerlink\" title=\"CSS 적용법\"></a>CSS 적용법</h3><p>자바스크립트에서 css 속성을 작성할 때 주의해야 할 점은<br>자바스크립트가 -(하이픈) 문자를 산술 연산자로 인식한다는 것입니다.</p>\n<p>따라서</p>\n<table>\n<thead>\n<tr>\n<th>HTML 에서 CSS사용 시</th>\n<th>자바스크립트에서 CSS 사용시</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>background-color</td>\n<td>backgroundColor</td>\n</tr>\n<tr>\n<td>font-size</td>\n<td>fontSize</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"Node-타입\"><a href=\"#Node-타입\" class=\"headerlink\" title=\"Node 타입\"></a>Node 타입</h3><p>노드타입(nodeType)을 이용하면 인접 관계 선택자의 호환성 문제를 해결할 수 있습니다.<br>HTML 노드에는 HTML태그를 연결하는 요소(Element)노드와<br>텍스트를 연결하는 텍스트(Text)노드,<br>HTML태그의 속성을 연결해 주는 속성(Attribute)노드가 있습니다.</p>\n<p>선택자로 선택한 요소가 어떤 노드인가에 따라 노드 타입 값이 다음과 같이 표기 됩니다.</p>\n<table>\n<thead>\n<tr>\n<th>종류</th>\n<th>타입 값</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>요소(Element) 노드</td>\n<td>1</td>\n</tr>\n<tr>\n<td>속성(Attribute) 노드</td>\n<td>2</td>\n</tr>\n<tr>\n<td>텍스트(Text) 노드</td>\n<td>3</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight js\"><figcaption><span>예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">\"http://w3.org\"</span> id=<span class=\"string\">\"m\"</span>&gt;W3C&lt;<span class=\"regexp\">/a&gt;;  </span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">document.getElementByid(\"m\").nodeType; /</span><span class=\"regexp\">/ 1 \"&lt;a&gt;\"  </span></span><br><span class=\"line\"><span class=\"regexp\">document.getElementByid(\"m\").firstChild.nodeType; /</span><span class=\"regexp\">/ 3 \"W3C\"  </span></span><br><span class=\"line\"><span class=\"regexp\">document.getElementByid(\"m\").getAttributNode(\"href\").nodeType; /</span><span class=\"regexp\">/ 2 \"href\"</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>비표준 인접 관계 선택자 해결법</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"wrap\"</span>).children[<span class=\"number\">0</span>].style.color=<span class=\"string\">\"red\"</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">var</span> p=<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"p\"</span>)[<span class=\"number\">1</span>];  </span><br><span class=\"line\"><span class=\"keyword\">var</span> nextObj=p.nextSibling;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">while</span>(nextObj.nodeType !=<span class=\"number\">1</span>)&#123; <span class=\"comment\">//다음 요소 태그를 찾을때까지 반복합니다.  </span></span><br><span class=\"line\"> nextObj=nextObj.nextSibling;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> nextObj.style.backgroundColor=<span class=\"string\">\"yellow\"</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"getAttribute\"><a href=\"#getAttribute\" class=\"headerlink\" title=\"getAttribute\"></a>getAttribute</h4><p>getAttribute () 메소드는 지정된 이름을 가진 속성 값을 요소의 값으로 반한합니다.</p>\n<pre><code>기본형\nelement.getAttribute(attributename)</code></pre><hr>\n<h4 id=\"1-1-getAttribute\"><a href=\"#1-1-getAttribute\" class=\"headerlink\" title=\"1.1 .getAttribute\"></a>1.1 .getAttribute</h4><p>.getAttribute(“속성”);<br>요소의 지정한 속성값을 불러옵니다.</p>\n<blockquote>\n<p>var x = document.getElementsByTagName(“H1”)[0].getAttribute(“class”);</p>\n</blockquote>\n<hr>\n<h4 id=\"1-2-setAttribute\"><a href=\"#1-2-setAttribute\" class=\"headerlink\" title=\"1.2 .setAttribute\"></a>1.2 .setAttribute</h4><p>.setAttribute(“속성”,”새 값”);<br>setAttribute () 메소드는 지정된 속성을 요소에 추가하고 지정된 값을 제공합니다.<br>추가하려는 속성이 이미 존재한다면, 지정된 값만 추가/변경 됩니다.<br>IE 8.0 이전 버젼에서 작동하지 않을 수 있습니다.</p>\n<p>이 메소드를 사용하여 값에 스타일 속성을 요소에 추가 할 수 있지만 인라인 스타일링 대신 스타일 오브젝트의 속성을 사용하는 것이 좋습니다. 이는 <strong>스타일에 지정된 다른 CSS 속성을 덮어 쓰지 않기 때문입니다.</strong></p>\n<p>Bad:</p>\n<blockquote>\n<p>element.setAttribute(“style”, “background-color: red;”);</p>\n</blockquote>\n<p>Good:</p>\n<blockquote>\n<p>element.style.backgroundColor = “red”;</p>\n</blockquote>\n<hr>\n<h4 id=\"1-3-removeAttribute\"><a href=\"#1-3-removeAttribute\" class=\"headerlink\" title=\"1.3 .removeAttribute\"></a>1.3 .removeAttribute</h4><p>removeAttribute () 메소드는 요소에서 지정된 속성을 제거합니다.</p>\n<p>removeAttributNode() 메소드와 다른점은<br>removeAttributeNode() 메소드는 지정된 Attr 오브젝트를 제거하고 이 메소드는 지정된 이름의 속성을 제거합니다.<br>둘의 결과는 다르지 않지만,<br>removeAttribute() 메소드는 반환 값을 갖지 않는 반면<br>removeAttributeNode() 메소드는 제거 된 속성을 Attr 오브젝트로 반환합니다.</p>\n<blockquote>\n<p>document.getElementById(“myAnchor”).removeAttribute(“href”);</p>\n</blockquote>\n<hr>\n<h4 id=\"1-4-hasAtrribute\"><a href=\"#1-4-hasAtrribute\" class=\"headerlink\" title=\"1.4 .hasAtrribute\"></a>1.4 .hasAtrribute</h4><p>hasAttribute () 메소드는 지정된 속성이 존재하면 true를, 그렇지 않으면 false를 리턴합니다.<br>IE 9.0 이전 버젼에서 작동하지 않을 수 있습니다.</p>\n<blockquote>\n<p>var x = document.getElementById(“myBtn”).hasAttribute(“onclick”);</p>\n</blockquote>\n<hr>\n<h3 id=\"innerHTML\"><a href=\"#innerHTML\" class=\"headerlink\" title=\"innerHTML\"></a>innerHTML</h3><p>innerHTML은 요소(element)내에 포함 된 HTML 또는 XML 마크업을 가져오거나 설정합니다.</p>\n<ul>\n<li>주의: &lt; div&gt;, &lt; span&gt; 노드가 (&amp;), (&lt;), (&gt;) 문자를 포함하는 텍스트 노드를 자식으로 가지고 있다면,<br>innerHTML은 이러한 문자들을 각각 “&amp;amp ;”, “&amp;lt ;” ,”&amp;gt ;”로 반환합니다.<br>Node.textContent를 사용하여 이러한 텍스트 노드 내용의 원본을 복사할 수 있습니다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>element.innerHTML</td>\n<td>선택한 요소의 모든 하위 요소를 문자 데이터로 반환합니다.</td>\n</tr>\n<tr>\n<td>element.innerHTML= text;</td>\n<td>선택한 요소의 전체 하위 요소를 새 요소로 변경 또는 생성합니다.</td>\n</tr>\n</tbody></table>\n<ul>\n<li>경고: 프로젝트가 보안 점검을 거치게 되는 프로젝트인 경우,<br>innerHTML 을 사용하면 코드가 거부 될 가능성이 높습니다.<br>예를 들어, 브라우저 확장에서 innerHTML을 사용하고<br>addons.mozilla.org에 확장을 제출하면 자동 검토 프로세스를 통과하지 못합니다.</li>\n</ul>\n<hr>\n<h3 id=\"이벤트\"><a href=\"#이벤트\" class=\"headerlink\" title=\"이벤트\"></a>이벤트</h3><p>여기서는 이벤트를 적용시키는 방법과 몇 가지 종류만 다루고<br>자세한 내용은 뒤에서 다룹니다.</p>\n<table>\n<thead>\n<tr>\n<th>이벤트</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onclick</td>\n<td>요소를 마우스 클릭했을 때 이벤트가 발생</td>\n</tr>\n<tr>\n<td>onmouseover</td>\n<td>요소를 마우스 오버 했을 때 이벤트 발생.</td>\n</tr>\n<tr>\n<td>onmounout</td>\n<td>요소에 마우스가 벗어났을 때 이벤트 발생.</td>\n</tr>\n<tr>\n<td>submit</td>\n<td>폼에 전송이 일어났을 때 이벤트 발생.</td>\n</tr>\n</tbody></table>\n<pre><code>기본형\n요소선택.이벤트종류=function(){\n\n}</code></pre><figure class=\"highlight js\"><figcaption><span>예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementByid(<span class=\"string\">\"btn1\"</span>).onclick=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> alert(<span class=\"string\">\"welcome\"</span>)  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"form-요소-선택자\"><a href=\"#form-요소-선택자\" class=\"headerlink\" title=\"form 요소 선택자\"></a>form 요소 선택자</h3><p>유저가 입력한 값이 유효한 값인지 검사하기 위해서는<br>폼에 입력 요소를 선택하고 속성을 제어할 수 있어야 합니다.<br>아래는 폼 요소를 선택할 때 사용하는 몇 가지 방식입니다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>입력 요소 선택자</td>\n<td>document.getElementByid(“아이디 명)</td>\n<td>폼 요소를 아이디로 선택합니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>document.폼이름.입력 요소 이름</td>\n<td>폼 요소를 이름으로 선택합니다.</td>\n</tr>\n<tr>\n<td>select option 선택자</td>\n<td>document.폼이름.입력 요소 이름.option[ index]</td>\n<td>&lt; select&gt;에&lt; option&gt;을 선택합니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>var i= document.폼이름.입력요소 이름.selectedIndex; document.폼 이름.입력요소 이름.option[ i];</td>\n<td>&lt; select&gt;에 선택된 &lt; option&gt;을 선택합니다.</td>\n</tr>\n</tbody></table>\n<p><strong>폼 요소 속성 종류</strong></p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>전체</td>\n<td>value</td>\n<td>입력 요소의 value 속성을 변경하거나, 값을 가져옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>disabled</td>\n<td>입력 요소의 disabled 속성을 변경하거나, 현재 상태의 값을 가져옵니다.</td>\n</tr>\n<tr>\n<td></td>\n<td>defaultValue</td>\n<td>입력 요소 초기에 입력된 value 값을 가져옵니다.</td>\n</tr>\n<tr>\n<td>선택박스</td>\n<td>selected</td>\n<td>&lt; select&gt;태그에 &lt; option&gt; 선택된 상태 값을 가져옵니다. 선택되있다면true 아니라면 false</td>\n</tr>\n<tr>\n<td>체크 박스 라디오 버튼</td>\n<td>checked</td>\n<td>체크박스 또는 라디오 버튼태그 체크 상태 값을 반환하거나 체크 여부를 제어 합니다. 체크 되있으면 true 해제되 있다면 false</td>\n</tr>\n</tbody></table>"},{"title":"ES6에 추가된 Operation -ECMAScript","date":"2020-03-21T22:14:37.000Z","disqusId":"tunas-blog-1","_content":"\nES6에 추가된 다양한 형태의 오퍼레이션 과 for-of 문,  \nES7에 추가된 거듭제곱 연산자를 살펴봅니다.\n\n*   Operation\n    *   [프로퍼티 이름조합](/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#프로퍼티_이름조합)\n    *   [Default Value](/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#Default_Value)\n    *   [Default 파라미터](/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#Default_파라미터)\n    *   [for-of](/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#for-of)\n    *   [거듭 제곱 연산자 (**)](/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#거듭_제곱_연산자_(**))\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"프로퍼티_이름조합\">프로퍼티 이름조합</h2>\n\n문자열과 변수를 조합하여 오브젝트의 프로퍼티 이름으로 사용하는 것을  \nComputed property name(프로퍼티 이름 조합)이라고 합니다.\n\n### 문자열 조합\n\n문자열을 조합하여 오브젝트의 프로퍼티 키로 사용할 수 있습니다.\n\n```js\nlet item = {  \n [\"one\" + \"two\"]: 12  \n};  \nconsole.log(item.onetwo); // 12  \n```\n\n조합하려는 이름을 대괄호[]안에 문자열로 작성한 형태입니다.  \n“one”과 “two”를 조합한 onetwo가 프로퍼티 키가 됩니다.  \nitem.onetwo 형태로 프로퍼티 값을 구할 수 있습니다.\n\n### 변수 값과 문자열 조합\n\n```js\nlet item = \"tennis\";  \nlet sports = {  \n [item]: 1,  \n [item + \"Game\"]: \"윔블던\",  \n [item + \"Method\"](){  \n return this[item];  \n }  \n};  \nconsole.log(sports.tennis); // 1  \nconsole.log(sports.tennisGame); // 윔블던  \nconsole.log(sports.tennisMethod()); // 1  \n```\n\n*   []안에 변수 이름을 작성하면 변수 값을 프로퍼티 키로 사용합니다.  \n    item 변수 값 “tennis”가 프로퍼티 키가 되고 1이 값이 됩니다.  \n    따라서 sports.tennis 형태로 값을 구할 수 있습니다.\n\n*   item 변수 값인 “tennis”와 문자열 “Game”을 조합하면  \n    “tennisGame”이 되며 이를 프로퍼티 키 값으로 사용하고 “윔블던”이 값이 됩니다.  \n    sport.tennisGame 형태로 값을 구할 수 있게 됩니다.\n\n*   [item + “Method”] (){  \n    []안에 변수 이름과 문자열을 조합하고 여기에 함수를 나타내는 소괄호()를 넣어 함수 이름으로 사용한 형태입니다.  \n    소괄호()는 대괄호[]밖에 작성합니다.  \n    sports.tennisMethod() 형태로 호출할 수 있습니다.\n\n### 디스트럭처링과 프로퍼티 이름 조합\n\n프로퍼티 이름을 조합하고 조합한 이름을 분할 할당하여 값을 넘겨줄 수 있습니다.\n\n```js\nlet one = \"sports\";  \nlet {[one]: value} = {sports: \"농구\"};  \nconsole.log(value); //농구  \n```\n\n변수 이름 one을 []안에 작성하여 프로퍼티 키로 사용하고 그 값은 sports가 됩니다.  \n{[one]: value}코드는 {sports: value}와 같습니다.\n\n{sports: value} = {sports: “농구”};  \nvalue에 “농구”가 할당됩니다.\n\n* * *\n\n<h2 id=\"Default_Value\">Default Value</h2> \n\n변수, 파라미터, 프로퍼티에 값이 할당되지 않을 때 사전에 정의한 값이 할당됩니다.  \n이 값을 Default value라고 합니다.\n\n일반적으로 사용되는 디폴트 값과는 차이가 있습니다.  \n예를 들어 let 변수로 선언하고 할당은 하지 않은 경우  \n디폴트 값으로 undefined가 설정됩니다.\n\n여기서의 Default value는 변수를 선언하고 할당은 되지 않은 경우  \n(=undefined 형태일 경우) 기본으로 할당될 값을 지정해 주는 형태 입니다.\n\n### Default 파라미터\n\n```js\nfunction multiply(a, b) {  \n return a * b;  \n}  \n  \nmultiply(5, 2); // 10  \nmultiply(5);    // NaN !  \n```\n\nmultiply(5) 함수 호출 형태는 매개 변수 b에게 값을 할당하지 않습니다  \n그러므로 b는 Defalut value값 undefined 되어  \nreturn a*b를 평가할 때 NaN이 반환됩니다.\n\n*   ES6에서 기본 매개변수라면, 함수 body 내 검사는 더 이상 필요치 않습니다. 이제, 간단히 함수 머리(head)에 b의 기본값으로 1을 둘 수 있습니다\n\n```js default value\nfunction multiply(a, b = 1) {  \n return a*b;  \n}  \n  \nmultiply(5, 2); // 10  \nmultiply(5); // 5  \nmultiply(5, undefined); // 5  \n```\n\n`호출하는 함수에서 파라미터 값을 넘겨주지 않거나 undefined를 넘겨주면 디폴트 값이 적용됩니다.`\n\n### 파라미터 디스트럭처링\n\n```js\nlet getTotal = ([one, two] = [10, 20]) => one + two;  \nconsole.log(getTotal()); // 30  \n```\n\n함수 파라미터에 디스트럭처링과 디폴트 값을 작성한 형태입니다.  \ngetTotal()을 호출하면서 파라미터 값은 넘겨주지 않으므로  \n호출 받는 함수의 디폴트값이 적용됩니다.  \n디폴트 값 [10, 20]이 분할 할당되어 10이 one에 20이 two에 할당됩니다.\n\n```js\nlet getValue = ({two: value} = {two: 20}) => value;  \nconsole.log(getValue()); // 20  \n```\n\n함수 파라미터에 디스트럭처링과 디폴트 값을 오브젝트로 작성한 형태입니다.  \n디폴트 값 {two: 20}이 분할 할당되어 20이 value에 할당됩니다.\n\n*   왼쪽에서 오른쪽으로 디폴트 값이 적용됩니다.\n\n```js 디폴트 값 적용 순서\nlet [one, two = one + 1, five = two + 3] = [1];  \nconsole.log(one, two, five);   \n// 1 2 5  \n```\n\n오른쪽의 []에서 1이 one에 할당됩니다. 이어서 two=one+1을 실행하고 할당됩니다.  \n다음으로 five=two+3을 실행하고 할당합니다.\n\n* * *\n\n<h2 id=\"for-of\">for-of</h2>\n\nfor-of 문은 이터러블 오브젝트를 반복하여 처리합니다.  \n반복하는 자체는 for-in문과 차이가 없지만 대상과 방법에서 차이가 있습니다.\n\n> for (variable of iterableObject) {  \n> 코드  \n> }\n\n*   variable  \n    `반복 할때 마다 서로 다른 속성값이 variable에 할당됩니다.`\n\n### Array 반복\n\n```js\nlet iterable = [10, 20, 30];  \n  \nfor (let value of iterable) {  \n console.log(value);  \n}  \n// 10  \n// 20  \n// 30  \n```\n\n블록 내부 변수를 변경하고 싶지 않은경우,  \nlet 대신 const를 사용할 수 있습니다,.\n\n```js const\nlet iterable = [10, 20, 30];  \n  \nfor (const value of iterable) {  \n console.log(value);  \n}  \n// 10  \n// 20  \n// 30  \n```\n\n### String 반복\n\n```js String\nlet iterable = \"boo\";  \n  \nfor (let value of iterable) {  \n console.log(value);  \n}  \n// \"b\"  \n// \"o\"  \n// \"o\"  \n```\n\n### TypedArray 반복\n\n```js TypedArray\nlet iterable = new Uint8Array([0x00, 0xff]);  \n  \nfor (let value of iterable) {  \n console.log(value);  \n}  \n// 0  \n// 255  \n```\n\n### Map 반복\n\n```js Map\nlet iterable = new Map([[\"a\", 1], [\"b\", 2], [\"c\", 3]]);  \n  \nfor (let entry of iterable) {  \n console.log(entry);  \n}  \n// [a, 1]  \n// [b, 2]  \n// [c, 3]  \n  \nfor (let [key, value] of iterable) {  \n console.log(value);  \n}  \n// 1  \n// 2  \n// 3  \n```\n\n### Set 반복\n\n```js Set\nlet iterable = new Set([1, 1, 2, 2, 3, 3]);  \n  \nfor (let value of iterable) {  \n console.log(value);  \n}  \n// 1  \n// 2  \n// 3  \n```\n\n### DOM 컬렉션 반복\n\nNodeList 같은 DOM 컬렉션에 대해 반복\n\ndocument.querySelectorAll()같은 DOM 메서드를 실행하여  \n반환된 NodeList를 반복할 수 있습니다\n\n*   주의: 이는 NodeList.prototype[Symbol.iterator]가  \n    구현된 플랫폼에서만 작동합니다.\n\n```html DOM-Symbol.iterator\n<ul>  \n <li>첫 번째</li>  \n <li>두 번째</li>  \n <li>세 번째</li>  \n</ul>  \n<script>  \nlet nodes = document.querySelectorAll(\"li\");  \nfor (var node of nodes) {  \n console.log(node.textContent);  \n //첫 번째  \n //두 번째  \n //세 번째  \n};  \n</script>  \n```\n\n### 생성기(Generator) 반복\n\nGenerator에 대해서도 반복할 수 있습니다\n\n```js Generator\nfunction* fibonacci() { // 생성기 함수  \n let [prev, curr] = [1, 1];  \n while (true) {  \n [prev, curr] = [curr, prev + curr];  \n yield curr;  \n }  \n}  \n  \nfor (let n of fibonacci()) {  \n console.log(n);  \n // 1000에서 수열을 자름  \n if (n >= 1000) {  \n break;  \n }  \n}  \n```\n\n### 다른 반복가능 객체에 대해 반복\n\niterable 프로토콜을 명시해서 구현하는 객체에 대해서도 반복할 수 있습니다.\n\n```js \nvar iterable = {  \n [Symbol.iterator]() {  \n    return {  \n        i: 0,  \n        next() {  \n            if (this.i < 3) {  \n            return { value: this.i++, done: false };  \n            }  \n        return { value: undefined, done: true };  \n        }  \n    };  \n }  \n};  \n  \nfor (var value of iterable) {  \n console.log(value);  \n}  \n// 0  \n// 1  \n// 2  \n```\n\n### 디스트럭처링\n\n이터러블 오브젝트 구조에 맞춰 for-of 문에 변수를 작성하면  \n디스트럭처링을 할 수 있습니다.\n\n```js\nlet values = [  \n {item: \"선물1\", amount: {apple: 10, candy: 20}},  \n {item: \"선물2\", amount: {apple: 30, candy: 40}}  \n];  \n  \nfor (var {item: one, amount: {apple: two, candy: five}} of values){  \n console.log(one, two, five);  \n};  \n// 선물1 10 20  \n// 선물2 30 40  \n```\n\nvalues 배열의 첫 번째 엘리먼트에서 item 프로퍼티 값인 “선물1”이  \none에 할당됩니다. amount는 구조이며 양쪽이 모두 같습니다.  \napple 프로퍼티 값 10이 two에 할당되고  \ncandy 프로퍼티 값 20이 five에 할당됩니다.\n\nvalues의 두 번째 엘리먼트도 같은 방법으로 진행됩니다.\n\n* * *\n\n### for-of와 for-in 차이\n\n**for-in 문의 대상은 Object**이며 열거 가능한 프로퍼티가 대상입니다.\n\n`즉 프로퍼티의 enumerable 속성 값이 false이면 반복에서 제외됩니다.`\n\n**for-of 문의 대상은 이터러블 오브젝트** 이며 `prototype에 연결된 프로퍼티는 대상이 아닙니다.`\n\n```js\n1. let values = [10, 20, 30];  \n  \n2. Array.prototype.music = function(){  \n return \"음악\"  \n};  \n  \n3. Object.prototype.sports = function(){  \n return \"스포츠\"  \n};  \n  \n4. for (var key in values) {  \n console.log(key, values[key]);  \n/*  \n0 10  \n1 20  \n2 30  \nmusic ƒ (){  \n return \"음악\"  \n}  \nsports ƒ (){  \n return \"스포츠\"  \n}  \n*/  \n};  \n  \n5. for (var value of values) {  \n console.log(value);  \n/*  \n10  \n20  \n30  \n*/  \n};  \n```\n\n1.  values [10, 20, 30] 는 Array 오브젝트 이므로  \n    Array.prototype에 연결된 프로퍼티가 values.__proto__에 첨부됩니다.\n\n\n2.  Array.prototype에 music 메서드를 추가하면  \n    values.__proto__와 Array.prototype이 연동되므로  \n    values.music()형태로 호출할 수 있습니다.  \n    ~~빌트인 오브젝트 prototype에 메서드를 추가하는 것은 좋은 방법이 아닙니다. 위는 예시를 위한 표현입니다.~~\n\n\n3.  Object.prototype에 메서드를 추가하는 것 역시 values.sports() 식으로 호출 할수 있게 해줍니다.\n\n\n4.  for-in 문으로 values 배열을 열거하면 Array.prototype에 추가된 music과  \n    Object.prototype에 추가된 sports가 출력됩니다.  \n    `Array.prototype에 빌트인으로 설정된 메서드는 열거되지 않고, 개발자 코드로 추가한 메서드만 열거됩니다.`\n\n\n5.  for-of 문으로 values 배열을 열거하면 prototype에 연결된 프로퍼티가 열거되지 않습니다. 이점이 for-in과 for-of의 차이입니다.\n\n* * *\n\n### for-of로 Object 열거 하는 방법\n\n오브젝트는 이터러블 오브젝트가 아니므로 for-of 문으로 열거할 수 없습니다.  \n개발자 코드로 사전처리 해줌으로써 for-of문에서 오브젝트를 열거할 수 있습니다.\n\n```js\nlet sports = {  \n soccer: \"축구\",  \n baseball: \"야구\"  \n};  \n  \nlet keyList = Object.keys(sports);  \nfor (var key of keyList){  \n console.log(key, sports[key]);  \n  \n// soccer 축구  \n// baseball 야구  \n};  \n```\n\nObject.keys(sports)는 파라미터의 sports 오브젝트에서 프로퍼티 키를 배열로 반환합니다. 배열은 이터러블 오브젝트이므로 이를 for-of문으로 반복하면서 sports[key]형태로 프로퍼티 값을 구할 수 있습니다.\n\n* * *\n\n<h2 id=\"거듭_제곱_연산자_(**)\">거듭 제곱 연산자 **</h2>\n\n거듭 제곱(Exponentiation) 연산자는 곱하기 문자(*)를 연속하여  \n2개 작성한 형태(**)입니다. ES7 스펙에 추가되었습니다.\n\n```js\nconsole.log(3**2);  \nconsole.log(3**3);  \nconsole.log(Math.pow(3, 3));  \n/*  \n9  \n27  \n27  \n*/  \n```\n\n3**2는 3의 2승 값 9 입니다.  \n3**3은 3의 3승 값 27 입니다.  \n**은 Math.pow()메소드와 같습니다.\n","source":"_posts/ES6에 추가된 Operation -ECMAScript.md","raw":"---\ntitle: ES6에 추가된 Operation -ECMAScript\ndate: 2020-03-22 07:14:37\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\nES6에 추가된 다양한 형태의 오퍼레이션 과 for-of 문,  \nES7에 추가된 거듭제곱 연산자를 살펴봅니다.\n\n*   Operation\n    *   [프로퍼티 이름조합](/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#프로퍼티_이름조합)\n    *   [Default Value](/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#Default_Value)\n    *   [Default 파라미터](/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#Default_파라미터)\n    *   [for-of](/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#for-of)\n    *   [거듭 제곱 연산자 (**)](/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#거듭_제곱_연산자_(**))\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"프로퍼티_이름조합\">프로퍼티 이름조합</h2>\n\n문자열과 변수를 조합하여 오브젝트의 프로퍼티 이름으로 사용하는 것을  \nComputed property name(프로퍼티 이름 조합)이라고 합니다.\n\n### 문자열 조합\n\n문자열을 조합하여 오브젝트의 프로퍼티 키로 사용할 수 있습니다.\n\n```js\nlet item = {  \n [\"one\" + \"two\"]: 12  \n};  \nconsole.log(item.onetwo); // 12  \n```\n\n조합하려는 이름을 대괄호[]안에 문자열로 작성한 형태입니다.  \n“one”과 “two”를 조합한 onetwo가 프로퍼티 키가 됩니다.  \nitem.onetwo 형태로 프로퍼티 값을 구할 수 있습니다.\n\n### 변수 값과 문자열 조합\n\n```js\nlet item = \"tennis\";  \nlet sports = {  \n [item]: 1,  \n [item + \"Game\"]: \"윔블던\",  \n [item + \"Method\"](){  \n return this[item];  \n }  \n};  \nconsole.log(sports.tennis); // 1  \nconsole.log(sports.tennisGame); // 윔블던  \nconsole.log(sports.tennisMethod()); // 1  \n```\n\n*   []안에 변수 이름을 작성하면 변수 값을 프로퍼티 키로 사용합니다.  \n    item 변수 값 “tennis”가 프로퍼티 키가 되고 1이 값이 됩니다.  \n    따라서 sports.tennis 형태로 값을 구할 수 있습니다.\n\n*   item 변수 값인 “tennis”와 문자열 “Game”을 조합하면  \n    “tennisGame”이 되며 이를 프로퍼티 키 값으로 사용하고 “윔블던”이 값이 됩니다.  \n    sport.tennisGame 형태로 값을 구할 수 있게 됩니다.\n\n*   [item + “Method”] (){  \n    []안에 변수 이름과 문자열을 조합하고 여기에 함수를 나타내는 소괄호()를 넣어 함수 이름으로 사용한 형태입니다.  \n    소괄호()는 대괄호[]밖에 작성합니다.  \n    sports.tennisMethod() 형태로 호출할 수 있습니다.\n\n### 디스트럭처링과 프로퍼티 이름 조합\n\n프로퍼티 이름을 조합하고 조합한 이름을 분할 할당하여 값을 넘겨줄 수 있습니다.\n\n```js\nlet one = \"sports\";  \nlet {[one]: value} = {sports: \"농구\"};  \nconsole.log(value); //농구  \n```\n\n변수 이름 one을 []안에 작성하여 프로퍼티 키로 사용하고 그 값은 sports가 됩니다.  \n{[one]: value}코드는 {sports: value}와 같습니다.\n\n{sports: value} = {sports: “농구”};  \nvalue에 “농구”가 할당됩니다.\n\n* * *\n\n<h2 id=\"Default_Value\">Default Value</h2> \n\n변수, 파라미터, 프로퍼티에 값이 할당되지 않을 때 사전에 정의한 값이 할당됩니다.  \n이 값을 Default value라고 합니다.\n\n일반적으로 사용되는 디폴트 값과는 차이가 있습니다.  \n예를 들어 let 변수로 선언하고 할당은 하지 않은 경우  \n디폴트 값으로 undefined가 설정됩니다.\n\n여기서의 Default value는 변수를 선언하고 할당은 되지 않은 경우  \n(=undefined 형태일 경우) 기본으로 할당될 값을 지정해 주는 형태 입니다.\n\n### Default 파라미터\n\n```js\nfunction multiply(a, b) {  \n return a * b;  \n}  \n  \nmultiply(5, 2); // 10  \nmultiply(5);    // NaN !  \n```\n\nmultiply(5) 함수 호출 형태는 매개 변수 b에게 값을 할당하지 않습니다  \n그러므로 b는 Defalut value값 undefined 되어  \nreturn a*b를 평가할 때 NaN이 반환됩니다.\n\n*   ES6에서 기본 매개변수라면, 함수 body 내 검사는 더 이상 필요치 않습니다. 이제, 간단히 함수 머리(head)에 b의 기본값으로 1을 둘 수 있습니다\n\n```js default value\nfunction multiply(a, b = 1) {  \n return a*b;  \n}  \n  \nmultiply(5, 2); // 10  \nmultiply(5); // 5  \nmultiply(5, undefined); // 5  \n```\n\n`호출하는 함수에서 파라미터 값을 넘겨주지 않거나 undefined를 넘겨주면 디폴트 값이 적용됩니다.`\n\n### 파라미터 디스트럭처링\n\n```js\nlet getTotal = ([one, two] = [10, 20]) => one + two;  \nconsole.log(getTotal()); // 30  \n```\n\n함수 파라미터에 디스트럭처링과 디폴트 값을 작성한 형태입니다.  \ngetTotal()을 호출하면서 파라미터 값은 넘겨주지 않으므로  \n호출 받는 함수의 디폴트값이 적용됩니다.  \n디폴트 값 [10, 20]이 분할 할당되어 10이 one에 20이 two에 할당됩니다.\n\n```js\nlet getValue = ({two: value} = {two: 20}) => value;  \nconsole.log(getValue()); // 20  \n```\n\n함수 파라미터에 디스트럭처링과 디폴트 값을 오브젝트로 작성한 형태입니다.  \n디폴트 값 {two: 20}이 분할 할당되어 20이 value에 할당됩니다.\n\n*   왼쪽에서 오른쪽으로 디폴트 값이 적용됩니다.\n\n```js 디폴트 값 적용 순서\nlet [one, two = one + 1, five = two + 3] = [1];  \nconsole.log(one, two, five);   \n// 1 2 5  \n```\n\n오른쪽의 []에서 1이 one에 할당됩니다. 이어서 two=one+1을 실행하고 할당됩니다.  \n다음으로 five=two+3을 실행하고 할당합니다.\n\n* * *\n\n<h2 id=\"for-of\">for-of</h2>\n\nfor-of 문은 이터러블 오브젝트를 반복하여 처리합니다.  \n반복하는 자체는 for-in문과 차이가 없지만 대상과 방법에서 차이가 있습니다.\n\n> for (variable of iterableObject) {  \n> 코드  \n> }\n\n*   variable  \n    `반복 할때 마다 서로 다른 속성값이 variable에 할당됩니다.`\n\n### Array 반복\n\n```js\nlet iterable = [10, 20, 30];  \n  \nfor (let value of iterable) {  \n console.log(value);  \n}  \n// 10  \n// 20  \n// 30  \n```\n\n블록 내부 변수를 변경하고 싶지 않은경우,  \nlet 대신 const를 사용할 수 있습니다,.\n\n```js const\nlet iterable = [10, 20, 30];  \n  \nfor (const value of iterable) {  \n console.log(value);  \n}  \n// 10  \n// 20  \n// 30  \n```\n\n### String 반복\n\n```js String\nlet iterable = \"boo\";  \n  \nfor (let value of iterable) {  \n console.log(value);  \n}  \n// \"b\"  \n// \"o\"  \n// \"o\"  \n```\n\n### TypedArray 반복\n\n```js TypedArray\nlet iterable = new Uint8Array([0x00, 0xff]);  \n  \nfor (let value of iterable) {  \n console.log(value);  \n}  \n// 0  \n// 255  \n```\n\n### Map 반복\n\n```js Map\nlet iterable = new Map([[\"a\", 1], [\"b\", 2], [\"c\", 3]]);  \n  \nfor (let entry of iterable) {  \n console.log(entry);  \n}  \n// [a, 1]  \n// [b, 2]  \n// [c, 3]  \n  \nfor (let [key, value] of iterable) {  \n console.log(value);  \n}  \n// 1  \n// 2  \n// 3  \n```\n\n### Set 반복\n\n```js Set\nlet iterable = new Set([1, 1, 2, 2, 3, 3]);  \n  \nfor (let value of iterable) {  \n console.log(value);  \n}  \n// 1  \n// 2  \n// 3  \n```\n\n### DOM 컬렉션 반복\n\nNodeList 같은 DOM 컬렉션에 대해 반복\n\ndocument.querySelectorAll()같은 DOM 메서드를 실행하여  \n반환된 NodeList를 반복할 수 있습니다\n\n*   주의: 이는 NodeList.prototype[Symbol.iterator]가  \n    구현된 플랫폼에서만 작동합니다.\n\n```html DOM-Symbol.iterator\n<ul>  \n <li>첫 번째</li>  \n <li>두 번째</li>  \n <li>세 번째</li>  \n</ul>  \n<script>  \nlet nodes = document.querySelectorAll(\"li\");  \nfor (var node of nodes) {  \n console.log(node.textContent);  \n //첫 번째  \n //두 번째  \n //세 번째  \n};  \n</script>  \n```\n\n### 생성기(Generator) 반복\n\nGenerator에 대해서도 반복할 수 있습니다\n\n```js Generator\nfunction* fibonacci() { // 생성기 함수  \n let [prev, curr] = [1, 1];  \n while (true) {  \n [prev, curr] = [curr, prev + curr];  \n yield curr;  \n }  \n}  \n  \nfor (let n of fibonacci()) {  \n console.log(n);  \n // 1000에서 수열을 자름  \n if (n >= 1000) {  \n break;  \n }  \n}  \n```\n\n### 다른 반복가능 객체에 대해 반복\n\niterable 프로토콜을 명시해서 구현하는 객체에 대해서도 반복할 수 있습니다.\n\n```js \nvar iterable = {  \n [Symbol.iterator]() {  \n    return {  \n        i: 0,  \n        next() {  \n            if (this.i < 3) {  \n            return { value: this.i++, done: false };  \n            }  \n        return { value: undefined, done: true };  \n        }  \n    };  \n }  \n};  \n  \nfor (var value of iterable) {  \n console.log(value);  \n}  \n// 0  \n// 1  \n// 2  \n```\n\n### 디스트럭처링\n\n이터러블 오브젝트 구조에 맞춰 for-of 문에 변수를 작성하면  \n디스트럭처링을 할 수 있습니다.\n\n```js\nlet values = [  \n {item: \"선물1\", amount: {apple: 10, candy: 20}},  \n {item: \"선물2\", amount: {apple: 30, candy: 40}}  \n];  \n  \nfor (var {item: one, amount: {apple: two, candy: five}} of values){  \n console.log(one, two, five);  \n};  \n// 선물1 10 20  \n// 선물2 30 40  \n```\n\nvalues 배열의 첫 번째 엘리먼트에서 item 프로퍼티 값인 “선물1”이  \none에 할당됩니다. amount는 구조이며 양쪽이 모두 같습니다.  \napple 프로퍼티 값 10이 two에 할당되고  \ncandy 프로퍼티 값 20이 five에 할당됩니다.\n\nvalues의 두 번째 엘리먼트도 같은 방법으로 진행됩니다.\n\n* * *\n\n### for-of와 for-in 차이\n\n**for-in 문의 대상은 Object**이며 열거 가능한 프로퍼티가 대상입니다.\n\n`즉 프로퍼티의 enumerable 속성 값이 false이면 반복에서 제외됩니다.`\n\n**for-of 문의 대상은 이터러블 오브젝트** 이며 `prototype에 연결된 프로퍼티는 대상이 아닙니다.`\n\n```js\n1. let values = [10, 20, 30];  \n  \n2. Array.prototype.music = function(){  \n return \"음악\"  \n};  \n  \n3. Object.prototype.sports = function(){  \n return \"스포츠\"  \n};  \n  \n4. for (var key in values) {  \n console.log(key, values[key]);  \n/*  \n0 10  \n1 20  \n2 30  \nmusic ƒ (){  \n return \"음악\"  \n}  \nsports ƒ (){  \n return \"스포츠\"  \n}  \n*/  \n};  \n  \n5. for (var value of values) {  \n console.log(value);  \n/*  \n10  \n20  \n30  \n*/  \n};  \n```\n\n1.  values [10, 20, 30] 는 Array 오브젝트 이므로  \n    Array.prototype에 연결된 프로퍼티가 values.__proto__에 첨부됩니다.\n\n\n2.  Array.prototype에 music 메서드를 추가하면  \n    values.__proto__와 Array.prototype이 연동되므로  \n    values.music()형태로 호출할 수 있습니다.  \n    ~~빌트인 오브젝트 prototype에 메서드를 추가하는 것은 좋은 방법이 아닙니다. 위는 예시를 위한 표현입니다.~~\n\n\n3.  Object.prototype에 메서드를 추가하는 것 역시 values.sports() 식으로 호출 할수 있게 해줍니다.\n\n\n4.  for-in 문으로 values 배열을 열거하면 Array.prototype에 추가된 music과  \n    Object.prototype에 추가된 sports가 출력됩니다.  \n    `Array.prototype에 빌트인으로 설정된 메서드는 열거되지 않고, 개발자 코드로 추가한 메서드만 열거됩니다.`\n\n\n5.  for-of 문으로 values 배열을 열거하면 prototype에 연결된 프로퍼티가 열거되지 않습니다. 이점이 for-in과 for-of의 차이입니다.\n\n* * *\n\n### for-of로 Object 열거 하는 방법\n\n오브젝트는 이터러블 오브젝트가 아니므로 for-of 문으로 열거할 수 없습니다.  \n개발자 코드로 사전처리 해줌으로써 for-of문에서 오브젝트를 열거할 수 있습니다.\n\n```js\nlet sports = {  \n soccer: \"축구\",  \n baseball: \"야구\"  \n};  \n  \nlet keyList = Object.keys(sports);  \nfor (var key of keyList){  \n console.log(key, sports[key]);  \n  \n// soccer 축구  \n// baseball 야구  \n};  \n```\n\nObject.keys(sports)는 파라미터의 sports 오브젝트에서 프로퍼티 키를 배열로 반환합니다. 배열은 이터러블 오브젝트이므로 이를 for-of문으로 반복하면서 sports[key]형태로 프로퍼티 값을 구할 수 있습니다.\n\n* * *\n\n<h2 id=\"거듭_제곱_연산자_(**)\">거듭 제곱 연산자 **</h2>\n\n거듭 제곱(Exponentiation) 연산자는 곱하기 문자(*)를 연속하여  \n2개 작성한 형태(**)입니다. ES7 스펙에 추가되었습니다.\n\n```js\nconsole.log(3**2);  \nconsole.log(3**3);  \nconsole.log(Math.pow(3, 3));  \n/*  \n9  \n27  \n27  \n*/  \n```\n\n3**2는 3의 2승 값 9 입니다.  \n3**3은 3의 3승 값 27 입니다.  \n**은 Math.pow()메소드와 같습니다.\n","slug":"ES6에 추가된 Operation -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrs4000fqgvqgc3n7csx","content":"<p>ES6에 추가된 다양한 형태의 오퍼레이션 과 for-of 문,<br>ES7에 추가된 거듭제곱 연산자를 살펴봅니다.</p>\n<ul>\n<li>Operation<ul>\n<li><a href=\"/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#프로퍼티_이름조합\">프로퍼티 이름조합</a></li>\n<li><a href=\"/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#Default_Value\">Default Value</a></li>\n<li><a href=\"/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#Default_파라미터\">Default 파라미터</a></li>\n<li><a href=\"/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#for-of\">for-of</a></li>\n<li><a href=\"/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#거듭_제곱_연산자_(**)\">거듭 제곱 연산자 (**)</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"프로퍼티_이름조합\">프로퍼티 이름조합</h2>\n\n<p>문자열과 변수를 조합하여 오브젝트의 프로퍼티 이름으로 사용하는 것을<br>Computed property name(프로퍼티 이름 조합)이라고 합니다.</p>\n<h3 id=\"문자열-조합\"><a href=\"#문자열-조합\" class=\"headerlink\" title=\"문자열 조합\"></a>문자열 조합</h3><p>문자열을 조합하여 오브젝트의 프로퍼티 키로 사용할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> item = &#123;  </span><br><span class=\"line\"> [<span class=\"string\">\"one\"</span> + <span class=\"string\">\"two\"</span>]: <span class=\"number\">12</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(item.onetwo); <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n\n<p>조합하려는 이름을 대괄호[]안에 문자열로 작성한 형태입니다.<br>“one”과 “two”를 조합한 onetwo가 프로퍼티 키가 됩니다.<br>item.onetwo 형태로 프로퍼티 값을 구할 수 있습니다.</p>\n<h3 id=\"변수-값과-문자열-조합\"><a href=\"#변수-값과-문자열-조합\" class=\"headerlink\" title=\"변수 값과 문자열 조합\"></a>변수 값과 문자열 조합</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> item = <span class=\"string\">\"tennis\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> sports = &#123;  </span><br><span class=\"line\"> [item]: <span class=\"number\">1</span>,  </span><br><span class=\"line\"> [item + <span class=\"string\">\"Game\"</span>]: <span class=\"string\">\"윔블던\"</span>,  </span><br><span class=\"line\"> [item + <span class=\"string\">\"Method\"</span>]()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>[item];  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sports.tennis); <span class=\"comment\">// 1  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sports.tennisGame); <span class=\"comment\">// 윔블던  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sports.tennisMethod()); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>[]안에 변수 이름을 작성하면 변수 값을 프로퍼티 키로 사용합니다.<br>item 변수 값 “tennis”가 프로퍼티 키가 되고 1이 값이 됩니다.<br>따라서 sports.tennis 형태로 값을 구할 수 있습니다.</p>\n</li>\n<li><p>item 변수 값인 “tennis”와 문자열 “Game”을 조합하면<br>“tennisGame”이 되며 이를 프로퍼티 키 값으로 사용하고 “윔블던”이 값이 됩니다.<br>sport.tennisGame 형태로 값을 구할 수 있게 됩니다.</p>\n</li>\n<li><p>[item + “Method”] (){<br>[]안에 변수 이름과 문자열을 조합하고 여기에 함수를 나타내는 소괄호()를 넣어 함수 이름으로 사용한 형태입니다.<br>소괄호()는 대괄호[]밖에 작성합니다.<br>sports.tennisMethod() 형태로 호출할 수 있습니다.</p>\n</li>\n</ul>\n<h3 id=\"디스트럭처링과-프로퍼티-이름-조합\"><a href=\"#디스트럭처링과-프로퍼티-이름-조합\" class=\"headerlink\" title=\"디스트럭처링과 프로퍼티 이름 조합\"></a>디스트럭처링과 프로퍼티 이름 조합</h3><p>프로퍼티 이름을 조합하고 조합한 이름을 분할 할당하여 값을 넘겨줄 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"string\">\"sports\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;[one]: value&#125; = &#123;<span class=\"attr\">sports</span>: <span class=\"string\">\"농구\"</span>&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(value); <span class=\"comment\">//농구</span></span><br></pre></td></tr></table></figure>\n\n<p>변수 이름 one을 []안에 작성하여 프로퍼티 키로 사용하고 그 값은 sports가 됩니다.<br>{[one]: value}코드는 {sports: value}와 같습니다.</p>\n<p>{sports: value} = {sports: “농구”};<br>value에 “농구”가 할당됩니다.</p>\n<hr>\n<h2 id=\"Default_Value\">Default Value</h2> \n\n<p>변수, 파라미터, 프로퍼티에 값이 할당되지 않을 때 사전에 정의한 값이 할당됩니다.<br>이 값을 Default value라고 합니다.</p>\n<p>일반적으로 사용되는 디폴트 값과는 차이가 있습니다.<br>예를 들어 let 변수로 선언하고 할당은 하지 않은 경우<br>디폴트 값으로 undefined가 설정됩니다.</p>\n<p>여기서의 Default value는 변수를 선언하고 할당은 되지 않은 경우<br>(=undefined 형태일 경우) 기본으로 할당될 값을 지정해 주는 형태 입니다.</p>\n<h3 id=\"Default-파라미터\"><a href=\"#Default-파라미터\" class=\"headerlink\" title=\"Default 파라미터\"></a>Default 파라미터</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">multiply</span>(<span class=\"params\">a, b</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> a * b;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">multiply(<span class=\"number\">5</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 10  </span></span><br><span class=\"line\">multiply(<span class=\"number\">5</span>);    <span class=\"comment\">// NaN !</span></span><br></pre></td></tr></table></figure>\n\n<p>multiply(5) 함수 호출 형태는 매개 변수 b에게 값을 할당하지 않습니다<br>그러므로 b는 Defalut value값 undefined 되어<br>return a*b를 평가할 때 NaN이 반환됩니다.</p>\n<ul>\n<li>ES6에서 기본 매개변수라면, 함수 body 내 검사는 더 이상 필요치 않습니다. 이제, 간단히 함수 머리(head)에 b의 기본값으로 1을 둘 수 있습니다</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>default value</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">multiply</span>(<span class=\"params\">a, b = <span class=\"number\">1</span></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> a*b;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">multiply(<span class=\"number\">5</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 10  </span></span><br><span class=\"line\">multiply(<span class=\"number\">5</span>); <span class=\"comment\">// 5  </span></span><br><span class=\"line\">multiply(<span class=\"number\">5</span>, <span class=\"literal\">undefined</span>); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p><code>호출하는 함수에서 파라미터 값을 넘겨주지 않거나 undefined를 넘겨주면 디폴트 값이 적용됩니다.</code></p>\n<h3 id=\"파라미터-디스트럭처링\"><a href=\"#파라미터-디스트럭처링\" class=\"headerlink\" title=\"파라미터 디스트럭처링\"></a>파라미터 디스트럭처링</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getTotal = <span class=\"function\">(<span class=\"params\">[one, two] = [<span class=\"number\">10</span>, <span class=\"number\">20</span>]</span>) =&gt;</span> one + two;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getTotal()); <span class=\"comment\">// 30</span></span><br></pre></td></tr></table></figure>\n\n<p>함수 파라미터에 디스트럭처링과 디폴트 값을 작성한 형태입니다.<br>getTotal()을 호출하면서 파라미터 값은 넘겨주지 않으므로<br>호출 받는 함수의 디폴트값이 적용됩니다.<br>디폴트 값 [10, 20]이 분할 할당되어 10이 one에 20이 two에 할당됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getValue = <span class=\"function\">(<span class=\"params\">&#123;two: value&#125; = &#123;two: <span class=\"number\">20</span>&#125;</span>) =&gt;</span> value;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getValue()); <span class=\"comment\">// 20</span></span><br></pre></td></tr></table></figure>\n\n<p>함수 파라미터에 디스트럭처링과 디폴트 값을 오브젝트로 작성한 형태입니다.<br>디폴트 값 {two: 20}이 분할 할당되어 20이 value에 할당됩니다.</p>\n<ul>\n<li>왼쪽에서 오른쪽으로 디폴트 값이 적용됩니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>디폴트 값 적용 순서</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [one, two = one + <span class=\"number\">1</span>, five = two + <span class=\"number\">3</span>] = [<span class=\"number\">1</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(one, two, five);   </span><br><span class=\"line\"><span class=\"comment\">// 1 2 5</span></span><br></pre></td></tr></table></figure>\n\n<p>오른쪽의 []에서 1이 one에 할당됩니다. 이어서 two=one+1을 실행하고 할당됩니다.<br>다음으로 five=two+3을 실행하고 할당합니다.</p>\n<hr>\n<h2 id=\"for-of\">for-of</h2>\n\n<p>for-of 문은 이터러블 오브젝트를 반복하여 처리합니다.<br>반복하는 자체는 for-in문과 차이가 없지만 대상과 방법에서 차이가 있습니다.</p>\n<blockquote>\n<p>for (variable of iterableObject) {<br>코드<br>}</p>\n</blockquote>\n<ul>\n<li>variable<br><code>반복 할때 마다 서로 다른 속성값이 variable에 할당됩니다.</code></li>\n</ul>\n<h3 id=\"Array-반복\"><a href=\"#Array-반복\" class=\"headerlink\" title=\"Array 반복\"></a>Array 반복</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterable = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// 10  </span></span><br><span class=\"line\"><span class=\"comment\">// 20  </span></span><br><span class=\"line\"><span class=\"comment\">// 30</span></span><br></pre></td></tr></table></figure>\n\n<p>블록 내부 변수를 변경하고 싶지 않은경우,<br>let 대신 const를 사용할 수 있습니다,.</p>\n<figure class=\"highlight js\"><figcaption><span>const</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterable = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> value <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// 10  </span></span><br><span class=\"line\"><span class=\"comment\">// 20  </span></span><br><span class=\"line\"><span class=\"comment\">// 30</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"String-반복\"><a href=\"#String-반복\" class=\"headerlink\" title=\"String 반복\"></a>String 반복</h3><figure class=\"highlight js\"><figcaption><span>String</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterable = <span class=\"string\">\"boo\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// \"b\"  </span></span><br><span class=\"line\"><span class=\"comment\">// \"o\"  </span></span><br><span class=\"line\"><span class=\"comment\">// \"o\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"TypedArray-반복\"><a href=\"#TypedArray-반복\" class=\"headerlink\" title=\"TypedArray 반복\"></a>TypedArray 반복</h3><figure class=\"highlight js\"><figcaption><span>TypedArray</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterable = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">0x00</span>, <span class=\"number\">0xff</span>]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// 0  </span></span><br><span class=\"line\"><span class=\"comment\">// 255</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Map-반복\"><a href=\"#Map-반복\" class=\"headerlink\" title=\"Map 반복\"></a>Map 반복</h3><figure class=\"highlight js\"><figcaption><span>Map</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterable = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"string\">\"a\"</span>, <span class=\"number\">1</span>], [<span class=\"string\">\"b\"</span>, <span class=\"number\">2</span>], [<span class=\"string\">\"c\"</span>, <span class=\"number\">3</span>]]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> entry <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(entry);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// [a, 1]  </span></span><br><span class=\"line\"><span class=\"comment\">// [b, 2]  </span></span><br><span class=\"line\"><span class=\"comment\">// [c, 3]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// 1  </span></span><br><span class=\"line\"><span class=\"comment\">// 2  </span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Set-반복\"><a href=\"#Set-반복\" class=\"headerlink\" title=\"Set 반복\"></a>Set 반복</h3><figure class=\"highlight js\"><figcaption><span>Set</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterable = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// 1  </span></span><br><span class=\"line\"><span class=\"comment\">// 2  </span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DOM-컬렉션-반복\"><a href=\"#DOM-컬렉션-반복\" class=\"headerlink\" title=\"DOM 컬렉션 반복\"></a>DOM 컬렉션 반복</h3><p>NodeList 같은 DOM 컬렉션에 대해 반복</p>\n<p>document.querySelectorAll()같은 DOM 메서드를 실행하여<br>반환된 NodeList를 반복할 수 있습니다</p>\n<ul>\n<li>주의: 이는 NodeList.prototype[Symbol.iterator]가<br>구현된 플랫폼에서만 작동합니다.</li>\n</ul>\n<figure class=\"highlight html\"><figcaption><span>DOM-Symbol.iterator</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span>  </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>첫 번째<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>두 번째<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>세 번째<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">let</span> nodes = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"li\"</span>);  </span></span><br><span class=\"line\"><span class=\"actionscript\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> node of nodes) &#123;  </span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"built_in\">console</span>.log(node.textContent);  </span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">//첫 번째  </span></span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">//두 번째  </span></span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">//세 번째  </span></span></span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"생성기-Generator-반복\"><a href=\"#생성기-Generator-반복\" class=\"headerlink\" title=\"생성기(Generator) 반복\"></a>생성기(Generator) 반복</h3><p>Generator에 대해서도 반복할 수 있습니다</p>\n<figure class=\"highlight js\"><figcaption><span>Generator</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">fibonacci</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 생성기 함수  </span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> [prev, curr] = [<span class=\"number\">1</span>, <span class=\"number\">1</span>];  </span><br><span class=\"line\"> <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;  </span><br><span class=\"line\"> [prev, curr] = [curr, prev + curr];  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> curr;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> n <span class=\"keyword\">of</span> fibonacci()) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(n);  </span><br><span class=\"line\"> <span class=\"comment\">// 1000에서 수열을 자름  </span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n &gt;= <span class=\"number\">1000</span>) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"다른-반복가능-객체에-대해-반복\"><a href=\"#다른-반복가능-객체에-대해-반복\" class=\"headerlink\" title=\"다른 반복가능 객체에 대해 반복\"></a>다른 반복가능 객체에 대해 반복</h3><p>iterable 프로토콜을 명시해서 구현하는 객체에 대해서도 반복할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> iterable = &#123;  </span><br><span class=\"line\"> [<span class=\"built_in\">Symbol</span>.iterator]() &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;  </span><br><span class=\"line\">        i: <span class=\"number\">0</span>,  </span><br><span class=\"line\">        next() &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.i &lt; <span class=\"number\">3</span>) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"keyword\">this</span>.i++, <span class=\"attr\">done</span>: <span class=\"literal\">false</span> &#125;;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"literal\">undefined</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span> &#125;;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> value <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// 0  </span></span><br><span class=\"line\"><span class=\"comment\">// 1  </span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"디스트럭처링\"><a href=\"#디스트럭처링\" class=\"headerlink\" title=\"디스트럭처링\"></a>디스트럭처링</h3><p>이터러블 오브젝트 구조에 맞춰 for-of 문에 변수를 작성하면<br>디스트럭처링을 할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> values = [  </span><br><span class=\"line\"> &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"선물1\"</span>, <span class=\"attr\">amount</span>: &#123;<span class=\"attr\">apple</span>: <span class=\"number\">10</span>, <span class=\"attr\">candy</span>: <span class=\"number\">20</span>&#125;&#125;,  </span><br><span class=\"line\"> &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"선물2\"</span>, <span class=\"attr\">amount</span>: &#123;<span class=\"attr\">apple</span>: <span class=\"number\">30</span>, <span class=\"attr\">candy</span>: <span class=\"number\">40</span>&#125;&#125;  </span><br><span class=\"line\">];  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> &#123;<span class=\"attr\">item</span>: one, <span class=\"attr\">amount</span>: &#123;<span class=\"attr\">apple</span>: two, <span class=\"attr\">candy</span>: five&#125;&#125; <span class=\"keyword\">of</span> values)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(one, two, five);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// 선물1 10 20  </span></span><br><span class=\"line\"><span class=\"comment\">// 선물2 30 40</span></span><br></pre></td></tr></table></figure>\n\n<p>values 배열의 첫 번째 엘리먼트에서 item 프로퍼티 값인 “선물1”이<br>one에 할당됩니다. amount는 구조이며 양쪽이 모두 같습니다.<br>apple 프로퍼티 값 10이 two에 할당되고<br>candy 프로퍼티 값 20이 five에 할당됩니다.</p>\n<p>values의 두 번째 엘리먼트도 같은 방법으로 진행됩니다.</p>\n<hr>\n<h3 id=\"for-of와-for-in-차이\"><a href=\"#for-of와-for-in-차이\" class=\"headerlink\" title=\"for-of와 for-in 차이\"></a>for-of와 for-in 차이</h3><p><strong>for-in 문의 대상은 Object</strong>이며 열거 가능한 프로퍼티가 대상입니다.</p>\n<p><code>즉 프로퍼티의 enumerable 속성 값이 false이면 반복에서 제외됩니다.</code></p>\n<p><strong>for-of 문의 대상은 이터러블 오브젝트</strong> 이며 <code>prototype에 연결된 프로퍼티는 대상이 아닙니다.</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> values = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">Array</span>.prototype.music = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"음악\"</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">Object</span>.prototype.sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"스포츠\"</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> values) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, values[key]);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">0 10  </span></span><br><span class=\"line\"><span class=\"comment\">1 20  </span></span><br><span class=\"line\"><span class=\"comment\">2 30  </span></span><br><span class=\"line\"><span class=\"comment\">music ƒ ()&#123;  </span></span><br><span class=\"line\"><span class=\"comment\"> return \"음악\"  </span></span><br><span class=\"line\"><span class=\"comment\">&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">sports ƒ ()&#123;  </span></span><br><span class=\"line\"><span class=\"comment\"> return \"스포츠\"  </span></span><br><span class=\"line\"><span class=\"comment\">&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> value <span class=\"keyword\">of</span> values) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">10  </span></span><br><span class=\"line\"><span class=\"comment\">20  </span></span><br><span class=\"line\"><span class=\"comment\">30  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>values [10, 20, 30] 는 Array 오브젝트 이므로<br>Array.prototype에 연결된 프로퍼티가 values.<strong>proto</strong>에 첨부됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li>Array.prototype에 music 메서드를 추가하면<br>values.<strong>proto</strong>와 Array.prototype이 연동되므로<br>values.music()형태로 호출할 수 있습니다.<br><del>빌트인 오브젝트 prototype에 메서드를 추가하는 것은 좋은 방법이 아닙니다. 위는 예시를 위한 표현입니다.</del></li>\n</ol>\n<ol start=\"3\">\n<li>Object.prototype에 메서드를 추가하는 것 역시 values.sports() 식으로 호출 할수 있게 해줍니다.</li>\n</ol>\n<ol start=\"4\">\n<li>for-in 문으로 values 배열을 열거하면 Array.prototype에 추가된 music과<br>Object.prototype에 추가된 sports가 출력됩니다.<br><code>Array.prototype에 빌트인으로 설정된 메서드는 열거되지 않고, 개발자 코드로 추가한 메서드만 열거됩니다.</code></li>\n</ol>\n<ol start=\"5\">\n<li>for-of 문으로 values 배열을 열거하면 prototype에 연결된 프로퍼티가 열거되지 않습니다. 이점이 for-in과 for-of의 차이입니다.</li>\n</ol>\n<hr>\n<h3 id=\"for-of로-Object-열거-하는-방법\"><a href=\"#for-of로-Object-열거-하는-방법\" class=\"headerlink\" title=\"for-of로 Object 열거 하는 방법\"></a>for-of로 Object 열거 하는 방법</h3><p>오브젝트는 이터러블 오브젝트가 아니므로 for-of 문으로 열거할 수 없습니다.<br>개발자 코드로 사전처리 해줌으로써 for-of문에서 오브젝트를 열거할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = &#123;  </span><br><span class=\"line\"> soccer: <span class=\"string\">\"축구\"</span>,  </span><br><span class=\"line\"> baseball: <span class=\"string\">\"야구\"</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> keyList = <span class=\"built_in\">Object</span>.keys(sports);  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">of</span> keyList)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, sports[key]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// soccer 축구  </span></span><br><span class=\"line\"><span class=\"comment\">// baseball 야구  </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Object.keys(sports)는 파라미터의 sports 오브젝트에서 프로퍼티 키를 배열로 반환합니다. 배열은 이터러블 오브젝트이므로 이를 for-of문으로 반복하면서 sports[key]형태로 프로퍼티 값을 구할 수 있습니다.</p>\n<hr>\n<h2 id=\"거듭_제곱_연산자_(**)\">거듭 제곱 연산자 **</h2>\n\n<p>거듭 제곱(Exponentiation) 연산자는 곱하기 문자(<em>)를 연속하여<br>2개 작성한 형태(*</em>)입니다. ES7 스펙에 추가되었습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>**<span class=\"number\">2</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>**<span class=\"number\">3</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.pow(<span class=\"number\">3</span>, <span class=\"number\">3</span>));  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">9  </span></span><br><span class=\"line\"><span class=\"comment\">27  </span></span><br><span class=\"line\"><span class=\"comment\">27  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>3<strong>2는 3의 2승 값 9 입니다.<br>3</strong>3은 3의 3승 값 27 입니다.<br>**은 Math.pow()메소드와 같습니다.</p>\n","site":{"data":{}},"excerpt":"<p>ES6에 추가된 다양한 형태의 오퍼레이션 과 for-of 문,<br>ES7에 추가된 거듭제곱 연산자를 살펴봅니다.</p>\n<ul>\n<li>Operation<ul>\n<li><a href=\"/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#프로퍼티_이름조합\">프로퍼티 이름조합</a></li>\n<li><a href=\"/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#Default_Value\">Default Value</a></li>\n<li><a href=\"/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#Default_파라미터\">Default 파라미터</a></li>\n<li><a href=\"/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#for-of\">for-of</a></li>\n<li><a href=\"/2020/03/22/ES6에%20추가된%20Operation%20-ECMAScript/#거듭_제곱_연산자_(**)\">거듭 제곱 연산자 (**)</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"프로퍼티_이름조합\">프로퍼티 이름조합</h2>\n\n<p>문자열과 변수를 조합하여 오브젝트의 프로퍼티 이름으로 사용하는 것을<br>Computed property name(프로퍼티 이름 조합)이라고 합니다.</p>\n<h3 id=\"문자열-조합\"><a href=\"#문자열-조합\" class=\"headerlink\" title=\"문자열 조합\"></a>문자열 조합</h3><p>문자열을 조합하여 오브젝트의 프로퍼티 키로 사용할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> item = &#123;  </span><br><span class=\"line\"> [<span class=\"string\">\"one\"</span> + <span class=\"string\">\"two\"</span>]: <span class=\"number\">12</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(item.onetwo); <span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n\n<p>조합하려는 이름을 대괄호[]안에 문자열로 작성한 형태입니다.<br>“one”과 “two”를 조합한 onetwo가 프로퍼티 키가 됩니다.<br>item.onetwo 형태로 프로퍼티 값을 구할 수 있습니다.</p>\n<h3 id=\"변수-값과-문자열-조합\"><a href=\"#변수-값과-문자열-조합\" class=\"headerlink\" title=\"변수 값과 문자열 조합\"></a>변수 값과 문자열 조합</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> item = <span class=\"string\">\"tennis\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> sports = &#123;  </span><br><span class=\"line\"> [item]: <span class=\"number\">1</span>,  </span><br><span class=\"line\"> [item + <span class=\"string\">\"Game\"</span>]: <span class=\"string\">\"윔블던\"</span>,  </span><br><span class=\"line\"> [item + <span class=\"string\">\"Method\"</span>]()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>[item];  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sports.tennis); <span class=\"comment\">// 1  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sports.tennisGame); <span class=\"comment\">// 윔블던  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sports.tennisMethod()); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>[]안에 변수 이름을 작성하면 변수 값을 프로퍼티 키로 사용합니다.<br>item 변수 값 “tennis”가 프로퍼티 키가 되고 1이 값이 됩니다.<br>따라서 sports.tennis 형태로 값을 구할 수 있습니다.</p>\n</li>\n<li><p>item 변수 값인 “tennis”와 문자열 “Game”을 조합하면<br>“tennisGame”이 되며 이를 프로퍼티 키 값으로 사용하고 “윔블던”이 값이 됩니다.<br>sport.tennisGame 형태로 값을 구할 수 있게 됩니다.</p>\n</li>\n<li><p>[item + “Method”] (){<br>[]안에 변수 이름과 문자열을 조합하고 여기에 함수를 나타내는 소괄호()를 넣어 함수 이름으로 사용한 형태입니다.<br>소괄호()는 대괄호[]밖에 작성합니다.<br>sports.tennisMethod() 형태로 호출할 수 있습니다.</p>\n</li>\n</ul>\n<h3 id=\"디스트럭처링과-프로퍼티-이름-조합\"><a href=\"#디스트럭처링과-프로퍼티-이름-조합\" class=\"headerlink\" title=\"디스트럭처링과 프로퍼티 이름 조합\"></a>디스트럭처링과 프로퍼티 이름 조합</h3><p>프로퍼티 이름을 조합하고 조합한 이름을 분할 할당하여 값을 넘겨줄 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"string\">\"sports\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;[one]: value&#125; = &#123;<span class=\"attr\">sports</span>: <span class=\"string\">\"농구\"</span>&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(value); <span class=\"comment\">//농구</span></span><br></pre></td></tr></table></figure>\n\n<p>변수 이름 one을 []안에 작성하여 프로퍼티 키로 사용하고 그 값은 sports가 됩니다.<br>{[one]: value}코드는 {sports: value}와 같습니다.</p>\n<p>{sports: value} = {sports: “농구”};<br>value에 “농구”가 할당됩니다.</p>\n<hr>\n<h2 id=\"Default_Value\">Default Value</h2> \n\n<p>변수, 파라미터, 프로퍼티에 값이 할당되지 않을 때 사전에 정의한 값이 할당됩니다.<br>이 값을 Default value라고 합니다.</p>\n<p>일반적으로 사용되는 디폴트 값과는 차이가 있습니다.<br>예를 들어 let 변수로 선언하고 할당은 하지 않은 경우<br>디폴트 값으로 undefined가 설정됩니다.</p>\n<p>여기서의 Default value는 변수를 선언하고 할당은 되지 않은 경우<br>(=undefined 형태일 경우) 기본으로 할당될 값을 지정해 주는 형태 입니다.</p>\n<h3 id=\"Default-파라미터\"><a href=\"#Default-파라미터\" class=\"headerlink\" title=\"Default 파라미터\"></a>Default 파라미터</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">multiply</span>(<span class=\"params\">a, b</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> a * b;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">multiply(<span class=\"number\">5</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 10  </span></span><br><span class=\"line\">multiply(<span class=\"number\">5</span>);    <span class=\"comment\">// NaN !</span></span><br></pre></td></tr></table></figure>\n\n<p>multiply(5) 함수 호출 형태는 매개 변수 b에게 값을 할당하지 않습니다<br>그러므로 b는 Defalut value값 undefined 되어<br>return a*b를 평가할 때 NaN이 반환됩니다.</p>\n<ul>\n<li>ES6에서 기본 매개변수라면, 함수 body 내 검사는 더 이상 필요치 않습니다. 이제, 간단히 함수 머리(head)에 b의 기본값으로 1을 둘 수 있습니다</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>default value</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">multiply</span>(<span class=\"params\">a, b = <span class=\"number\">1</span></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> a*b;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">multiply(<span class=\"number\">5</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 10  </span></span><br><span class=\"line\">multiply(<span class=\"number\">5</span>); <span class=\"comment\">// 5  </span></span><br><span class=\"line\">multiply(<span class=\"number\">5</span>, <span class=\"literal\">undefined</span>); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p><code>호출하는 함수에서 파라미터 값을 넘겨주지 않거나 undefined를 넘겨주면 디폴트 값이 적용됩니다.</code></p>\n<h3 id=\"파라미터-디스트럭처링\"><a href=\"#파라미터-디스트럭처링\" class=\"headerlink\" title=\"파라미터 디스트럭처링\"></a>파라미터 디스트럭처링</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getTotal = <span class=\"function\">(<span class=\"params\">[one, two] = [<span class=\"number\">10</span>, <span class=\"number\">20</span>]</span>) =&gt;</span> one + two;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getTotal()); <span class=\"comment\">// 30</span></span><br></pre></td></tr></table></figure>\n\n<p>함수 파라미터에 디스트럭처링과 디폴트 값을 작성한 형태입니다.<br>getTotal()을 호출하면서 파라미터 값은 넘겨주지 않으므로<br>호출 받는 함수의 디폴트값이 적용됩니다.<br>디폴트 값 [10, 20]이 분할 할당되어 10이 one에 20이 two에 할당됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getValue = <span class=\"function\">(<span class=\"params\">&#123;two: value&#125; = &#123;two: <span class=\"number\">20</span>&#125;</span>) =&gt;</span> value;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getValue()); <span class=\"comment\">// 20</span></span><br></pre></td></tr></table></figure>\n\n<p>함수 파라미터에 디스트럭처링과 디폴트 값을 오브젝트로 작성한 형태입니다.<br>디폴트 값 {two: 20}이 분할 할당되어 20이 value에 할당됩니다.</p>\n<ul>\n<li>왼쪽에서 오른쪽으로 디폴트 값이 적용됩니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>디폴트 값 적용 순서</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [one, two = one + <span class=\"number\">1</span>, five = two + <span class=\"number\">3</span>] = [<span class=\"number\">1</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(one, two, five);   </span><br><span class=\"line\"><span class=\"comment\">// 1 2 5</span></span><br></pre></td></tr></table></figure>\n\n<p>오른쪽의 []에서 1이 one에 할당됩니다. 이어서 two=one+1을 실행하고 할당됩니다.<br>다음으로 five=two+3을 실행하고 할당합니다.</p>\n<hr>\n<h2 id=\"for-of\">for-of</h2>\n\n<p>for-of 문은 이터러블 오브젝트를 반복하여 처리합니다.<br>반복하는 자체는 for-in문과 차이가 없지만 대상과 방법에서 차이가 있습니다.</p>\n<blockquote>\n<p>for (variable of iterableObject) {<br>코드<br>}</p>\n</blockquote>\n<ul>\n<li>variable<br><code>반복 할때 마다 서로 다른 속성값이 variable에 할당됩니다.</code></li>\n</ul>\n<h3 id=\"Array-반복\"><a href=\"#Array-반복\" class=\"headerlink\" title=\"Array 반복\"></a>Array 반복</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterable = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// 10  </span></span><br><span class=\"line\"><span class=\"comment\">// 20  </span></span><br><span class=\"line\"><span class=\"comment\">// 30</span></span><br></pre></td></tr></table></figure>\n\n<p>블록 내부 변수를 변경하고 싶지 않은경우,<br>let 대신 const를 사용할 수 있습니다,.</p>\n<figure class=\"highlight js\"><figcaption><span>const</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterable = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> value <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// 10  </span></span><br><span class=\"line\"><span class=\"comment\">// 20  </span></span><br><span class=\"line\"><span class=\"comment\">// 30</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"String-반복\"><a href=\"#String-반복\" class=\"headerlink\" title=\"String 반복\"></a>String 반복</h3><figure class=\"highlight js\"><figcaption><span>String</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterable = <span class=\"string\">\"boo\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// \"b\"  </span></span><br><span class=\"line\"><span class=\"comment\">// \"o\"  </span></span><br><span class=\"line\"><span class=\"comment\">// \"o\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"TypedArray-반복\"><a href=\"#TypedArray-반복\" class=\"headerlink\" title=\"TypedArray 반복\"></a>TypedArray 반복</h3><figure class=\"highlight js\"><figcaption><span>TypedArray</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterable = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">0x00</span>, <span class=\"number\">0xff</span>]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// 0  </span></span><br><span class=\"line\"><span class=\"comment\">// 255</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Map-반복\"><a href=\"#Map-반복\" class=\"headerlink\" title=\"Map 반복\"></a>Map 반복</h3><figure class=\"highlight js\"><figcaption><span>Map</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterable = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"string\">\"a\"</span>, <span class=\"number\">1</span>], [<span class=\"string\">\"b\"</span>, <span class=\"number\">2</span>], [<span class=\"string\">\"c\"</span>, <span class=\"number\">3</span>]]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> entry <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(entry);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// [a, 1]  </span></span><br><span class=\"line\"><span class=\"comment\">// [b, 2]  </span></span><br><span class=\"line\"><span class=\"comment\">// [c, 3]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// 1  </span></span><br><span class=\"line\"><span class=\"comment\">// 2  </span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Set-반복\"><a href=\"#Set-반복\" class=\"headerlink\" title=\"Set 반복\"></a>Set 반복</h3><figure class=\"highlight js\"><figcaption><span>Set</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> iterable = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// 1  </span></span><br><span class=\"line\"><span class=\"comment\">// 2  </span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DOM-컬렉션-반복\"><a href=\"#DOM-컬렉션-반복\" class=\"headerlink\" title=\"DOM 컬렉션 반복\"></a>DOM 컬렉션 반복</h3><p>NodeList 같은 DOM 컬렉션에 대해 반복</p>\n<p>document.querySelectorAll()같은 DOM 메서드를 실행하여<br>반환된 NodeList를 반복할 수 있습니다</p>\n<ul>\n<li>주의: 이는 NodeList.prototype[Symbol.iterator]가<br>구현된 플랫폼에서만 작동합니다.</li>\n</ul>\n<figure class=\"highlight html\"><figcaption><span>DOM-Symbol.iterator</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span>  </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>첫 번째<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>두 번째<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>세 번째<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">let</span> nodes = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"li\"</span>);  </span></span><br><span class=\"line\"><span class=\"actionscript\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> node of nodes) &#123;  </span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"built_in\">console</span>.log(node.textContent);  </span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">//첫 번째  </span></span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">//두 번째  </span></span></span><br><span class=\"line\"><span class=\"actionscript\"> <span class=\"comment\">//세 번째  </span></span></span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"생성기-Generator-반복\"><a href=\"#생성기-Generator-반복\" class=\"headerlink\" title=\"생성기(Generator) 반복\"></a>생성기(Generator) 반복</h3><p>Generator에 대해서도 반복할 수 있습니다</p>\n<figure class=\"highlight js\"><figcaption><span>Generator</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">fibonacci</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 생성기 함수  </span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> [prev, curr] = [<span class=\"number\">1</span>, <span class=\"number\">1</span>];  </span><br><span class=\"line\"> <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;  </span><br><span class=\"line\"> [prev, curr] = [curr, prev + curr];  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> curr;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> n <span class=\"keyword\">of</span> fibonacci()) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(n);  </span><br><span class=\"line\"> <span class=\"comment\">// 1000에서 수열을 자름  </span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (n &gt;= <span class=\"number\">1000</span>) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"다른-반복가능-객체에-대해-반복\"><a href=\"#다른-반복가능-객체에-대해-반복\" class=\"headerlink\" title=\"다른 반복가능 객체에 대해 반복\"></a>다른 반복가능 객체에 대해 반복</h3><p>iterable 프로토콜을 명시해서 구현하는 객체에 대해서도 반복할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> iterable = &#123;  </span><br><span class=\"line\"> [<span class=\"built_in\">Symbol</span>.iterator]() &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;  </span><br><span class=\"line\">        i: <span class=\"number\">0</span>,  </span><br><span class=\"line\">        next() &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.i &lt; <span class=\"number\">3</span>) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"keyword\">this</span>.i++, <span class=\"attr\">done</span>: <span class=\"literal\">false</span> &#125;;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123; <span class=\"attr\">value</span>: <span class=\"literal\">undefined</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span> &#125;;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> value <span class=\"keyword\">of</span> iterable) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// 0  </span></span><br><span class=\"line\"><span class=\"comment\">// 1  </span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"디스트럭처링\"><a href=\"#디스트럭처링\" class=\"headerlink\" title=\"디스트럭처링\"></a>디스트럭처링</h3><p>이터러블 오브젝트 구조에 맞춰 for-of 문에 변수를 작성하면<br>디스트럭처링을 할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> values = [  </span><br><span class=\"line\"> &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"선물1\"</span>, <span class=\"attr\">amount</span>: &#123;<span class=\"attr\">apple</span>: <span class=\"number\">10</span>, <span class=\"attr\">candy</span>: <span class=\"number\">20</span>&#125;&#125;,  </span><br><span class=\"line\"> &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"선물2\"</span>, <span class=\"attr\">amount</span>: &#123;<span class=\"attr\">apple</span>: <span class=\"number\">30</span>, <span class=\"attr\">candy</span>: <span class=\"number\">40</span>&#125;&#125;  </span><br><span class=\"line\">];  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> &#123;<span class=\"attr\">item</span>: one, <span class=\"attr\">amount</span>: &#123;<span class=\"attr\">apple</span>: two, <span class=\"attr\">candy</span>: five&#125;&#125; <span class=\"keyword\">of</span> values)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(one, two, five);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// 선물1 10 20  </span></span><br><span class=\"line\"><span class=\"comment\">// 선물2 30 40</span></span><br></pre></td></tr></table></figure>\n\n<p>values 배열의 첫 번째 엘리먼트에서 item 프로퍼티 값인 “선물1”이<br>one에 할당됩니다. amount는 구조이며 양쪽이 모두 같습니다.<br>apple 프로퍼티 값 10이 two에 할당되고<br>candy 프로퍼티 값 20이 five에 할당됩니다.</p>\n<p>values의 두 번째 엘리먼트도 같은 방법으로 진행됩니다.</p>\n<hr>\n<h3 id=\"for-of와-for-in-차이\"><a href=\"#for-of와-for-in-차이\" class=\"headerlink\" title=\"for-of와 for-in 차이\"></a>for-of와 for-in 차이</h3><p><strong>for-in 문의 대상은 Object</strong>이며 열거 가능한 프로퍼티가 대상입니다.</p>\n<p><code>즉 프로퍼티의 enumerable 속성 값이 false이면 반복에서 제외됩니다.</code></p>\n<p><strong>for-of 문의 대상은 이터러블 오브젝트</strong> 이며 <code>prototype에 연결된 프로퍼티는 대상이 아닙니다.</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> values = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">Array</span>.prototype.music = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"음악\"</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">Object</span>.prototype.sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"스포츠\"</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> values) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, values[key]);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">0 10  </span></span><br><span class=\"line\"><span class=\"comment\">1 20  </span></span><br><span class=\"line\"><span class=\"comment\">2 30  </span></span><br><span class=\"line\"><span class=\"comment\">music ƒ ()&#123;  </span></span><br><span class=\"line\"><span class=\"comment\"> return \"음악\"  </span></span><br><span class=\"line\"><span class=\"comment\">&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">sports ƒ ()&#123;  </span></span><br><span class=\"line\"><span class=\"comment\"> return \"스포츠\"  </span></span><br><span class=\"line\"><span class=\"comment\">&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> value <span class=\"keyword\">of</span> values) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">10  </span></span><br><span class=\"line\"><span class=\"comment\">20  </span></span><br><span class=\"line\"><span class=\"comment\">30  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>values [10, 20, 30] 는 Array 오브젝트 이므로<br>Array.prototype에 연결된 프로퍼티가 values.<strong>proto</strong>에 첨부됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li>Array.prototype에 music 메서드를 추가하면<br>values.<strong>proto</strong>와 Array.prototype이 연동되므로<br>values.music()형태로 호출할 수 있습니다.<br><del>빌트인 오브젝트 prototype에 메서드를 추가하는 것은 좋은 방법이 아닙니다. 위는 예시를 위한 표현입니다.</del></li>\n</ol>\n<ol start=\"3\">\n<li>Object.prototype에 메서드를 추가하는 것 역시 values.sports() 식으로 호출 할수 있게 해줍니다.</li>\n</ol>\n<ol start=\"4\">\n<li>for-in 문으로 values 배열을 열거하면 Array.prototype에 추가된 music과<br>Object.prototype에 추가된 sports가 출력됩니다.<br><code>Array.prototype에 빌트인으로 설정된 메서드는 열거되지 않고, 개발자 코드로 추가한 메서드만 열거됩니다.</code></li>\n</ol>\n<ol start=\"5\">\n<li>for-of 문으로 values 배열을 열거하면 prototype에 연결된 프로퍼티가 열거되지 않습니다. 이점이 for-in과 for-of의 차이입니다.</li>\n</ol>\n<hr>\n<h3 id=\"for-of로-Object-열거-하는-방법\"><a href=\"#for-of로-Object-열거-하는-방법\" class=\"headerlink\" title=\"for-of로 Object 열거 하는 방법\"></a>for-of로 Object 열거 하는 방법</h3><p>오브젝트는 이터러블 오브젝트가 아니므로 for-of 문으로 열거할 수 없습니다.<br>개발자 코드로 사전처리 해줌으로써 for-of문에서 오브젝트를 열거할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = &#123;  </span><br><span class=\"line\"> soccer: <span class=\"string\">\"축구\"</span>,  </span><br><span class=\"line\"> baseball: <span class=\"string\">\"야구\"</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> keyList = <span class=\"built_in\">Object</span>.keys(sports);  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">of</span> keyList)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, sports[key]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// soccer 축구  </span></span><br><span class=\"line\"><span class=\"comment\">// baseball 야구  </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Object.keys(sports)는 파라미터의 sports 오브젝트에서 프로퍼티 키를 배열로 반환합니다. 배열은 이터러블 오브젝트이므로 이를 for-of문으로 반복하면서 sports[key]형태로 프로퍼티 값을 구할 수 있습니다.</p>\n<hr>\n<h2 id=\"거듭_제곱_연산자_(**)\">거듭 제곱 연산자 **</h2>\n\n<p>거듭 제곱(Exponentiation) 연산자는 곱하기 문자(<em>)를 연속하여<br>2개 작성한 형태(*</em>)입니다. ES7 스펙에 추가되었습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>**<span class=\"number\">2</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>**<span class=\"number\">3</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.pow(<span class=\"number\">3</span>, <span class=\"number\">3</span>));  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">9  </span></span><br><span class=\"line\"><span class=\"comment\">27  </span></span><br><span class=\"line\"><span class=\"comment\">27  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>3<strong>2는 3의 2승 값 9 입니다.<br>3</strong>3은 3의 3승 값 27 입니다.<br>**은 Math.pow()메소드와 같습니다.</p>"},{"title":"Global Variable(전역변수)와 Local Variable(지역변수)","date":"2020-03-09T02:13:01.000Z","disqusId":"tunas-blog-1","_content":"\n* * *\n\n변수는 유효범위에 따라\n\n전역변수(Global Variable)와 지역변수(Local Variable)로 구분할 수 있습니다.\n\n이러한 유효범위를 scope라고 합니다.\n\n각각의 function은 각각의 scope를 만듭니다.\n\n*   전역변수는 함수 외부에서 선언된 변수로, javascript 전체에서 접근할 수 있는 변수입니다.\n    \n*   지역변수는 함수 내부에서 선언된 변수로, 함수가 실행되면 만들어지고 함수가 종료되면 소멸하는 변수입니다. 함수 외부에서는 접근할 수 없습니다.\n    \n```js\nvar num =200; // 전역 변수  \n  \nfunction myFnc(){ // 지역 변수 함수  \n var num=500;  \n}  \nmyFnc(); // 함수를 호출합니다.  \n  \ndocument.write(num);  \n/* 함수 내에 작성한 var(변수)는 지역 변수이므로   \n 함수 밖에서는 불러올 수 없습니다.  \n 따라서 전역 변수로 선언된 num값 200이 출력됩니다.  \n*/  \n```\n\n**의도하지 않는 전역 변수를 작성하게 된다면**  \n**전역 변수 및 함수를 덮어 쓸 수 있으므로 주의 하여 사용 해야 합니다.**\n","source":"_posts/Global Variable 전역변수 와 Local Variable 지역변수.md","raw":"---\ntitle: Global Variable(전역변수)와 Local Variable(지역변수)\ndate: 2020-03-09 11:13:01\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\n* * *\n\n변수는 유효범위에 따라\n\n전역변수(Global Variable)와 지역변수(Local Variable)로 구분할 수 있습니다.\n\n이러한 유효범위를 scope라고 합니다.\n\n각각의 function은 각각의 scope를 만듭니다.\n\n*   전역변수는 함수 외부에서 선언된 변수로, javascript 전체에서 접근할 수 있는 변수입니다.\n    \n*   지역변수는 함수 내부에서 선언된 변수로, 함수가 실행되면 만들어지고 함수가 종료되면 소멸하는 변수입니다. 함수 외부에서는 접근할 수 없습니다.\n    \n```js\nvar num =200; // 전역 변수  \n  \nfunction myFnc(){ // 지역 변수 함수  \n var num=500;  \n}  \nmyFnc(); // 함수를 호출합니다.  \n  \ndocument.write(num);  \n/* 함수 내에 작성한 var(변수)는 지역 변수이므로   \n 함수 밖에서는 불러올 수 없습니다.  \n 따라서 전역 변수로 선언된 num값 200이 출력됩니다.  \n*/  \n```\n\n**의도하지 않는 전역 변수를 작성하게 된다면**  \n**전역 변수 및 함수를 덮어 쓸 수 있으므로 주의 하여 사용 해야 합니다.**\n","slug":"Global Variable 전역변수 와 Local Variable 지역변수","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrs6000iqgvqelt3292j","content":"<hr>\n<p>변수는 유효범위에 따라</p>\n<p>전역변수(Global Variable)와 지역변수(Local Variable)로 구분할 수 있습니다.</p>\n<p>이러한 유효범위를 scope라고 합니다.</p>\n<p>각각의 function은 각각의 scope를 만듭니다.</p>\n<ul>\n<li><p>전역변수는 함수 외부에서 선언된 변수로, javascript 전체에서 접근할 수 있는 변수입니다.</p>\n</li>\n<li><p>지역변수는 함수 내부에서 선언된 변수로, 함수가 실행되면 만들어지고 함수가 종료되면 소멸하는 변수입니다. 함수 외부에서는 접근할 수 없습니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num =<span class=\"number\">200</span>; <span class=\"comment\">// 전역 변수  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFnc</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// 지역 변수 함수  </span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> num=<span class=\"number\">500</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">myFnc(); <span class=\"comment\">// 함수를 호출합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(num);  </span><br><span class=\"line\"><span class=\"comment\">/* 함수 내에 작성한 var(변수)는 지역 변수이므로   </span></span><br><span class=\"line\"><span class=\"comment\"> 함수 밖에서는 불러올 수 없습니다.  </span></span><br><span class=\"line\"><span class=\"comment\"> 따라서 전역 변수로 선언된 num값 200이 출력됩니다.  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>의도하지 않는 전역 변수를 작성하게 된다면</strong><br><strong>전역 변수 및 함수를 덮어 쓸 수 있으므로 주의 하여 사용 해야 합니다.</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p>변수는 유효범위에 따라</p>\n<p>전역변수(Global Variable)와 지역변수(Local Variable)로 구분할 수 있습니다.</p>\n<p>이러한 유효범위를 scope라고 합니다.</p>\n<p>각각의 function은 각각의 scope를 만듭니다.</p>\n<ul>\n<li><p>전역변수는 함수 외부에서 선언된 변수로, javascript 전체에서 접근할 수 있는 변수입니다.</p>\n</li>\n<li><p>지역변수는 함수 내부에서 선언된 변수로, 함수가 실행되면 만들어지고 함수가 종료되면 소멸하는 변수입니다. 함수 외부에서는 접근할 수 없습니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num =<span class=\"number\">200</span>; <span class=\"comment\">// 전역 변수  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFnc</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// 지역 변수 함수  </span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> num=<span class=\"number\">500</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">myFnc(); <span class=\"comment\">// 함수를 호출합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(num);  </span><br><span class=\"line\"><span class=\"comment\">/* 함수 내에 작성한 var(변수)는 지역 변수이므로   </span></span><br><span class=\"line\"><span class=\"comment\"> 함수 밖에서는 불러올 수 없습니다.  </span></span><br><span class=\"line\"><span class=\"comment\"> 따라서 전역 변수로 선언된 num값 200이 출력됩니다.  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>의도하지 않는 전역 변수를 작성하게 된다면</strong><br><strong>전역 변수 및 함수를 덮어 쓸 수 있으므로 주의 하여 사용 해야 합니다.</strong></p>\n"},{"title":"Generator 오브젝트 -ECMAScript","date":"2020-03-30T23:54:39.000Z","disqusId":"tunas-blog-1","_content":"\n* * *\n\n함수를 호출하면 함수 블록의 코드를 한 번에 실행하지만,  \n제너레이터(Generator)오브젝트는 나누어서 실행할 수 있습니다.\n\n*   Generator\n    *   [function* 선언문](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#function*_선언문)\n    *   [function* 표현식](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#function*_표현식)\n    *   [GeneratorFunction():제너레이터 함수 생성](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#GeneratorFunction)\n    *   [yield: 제너레이터 함수 실행,멈춤](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#yield)\n    *   [next():yield 단위로 실행](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#next)\n    *   [next() 활용 예제](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#next_ex)\n    *   [throw(): Error 발생](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#throw)\n    *   [yield* 키워드](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#yield*)\n\n<!-- more -->\n\n제너레이터 함수 작성 형식은 3가지가 있습니다.\n\n1.  function* 선언문\n    \n2.  function* 표현식\n    \n3.  GeneratorFunction\n    \n\nfunction* 선언문과 표현식은 기존의 function과 형태가 같습니다,  \n“*”를 사용하는 형태만 다릅니다.  \nGeneratorFunction은 new Function()과 같으며  \n파라미터에 지정한 문자열로 제너레이터 함수를 생성하여 반환합니다.\n\n### 중요 포인트\n\n제너레이터 함수를 호출하면 제너레이터 오브젝트를 생성하여 반환합니다.  \nfunction()을 호출하면 함수 블록을 실행하지만, 제너레이터 함수는 함수 블록을 실행하지 않고 제너레이터 오브젝트를 생성하여 반환합니다.  \n생성한 제너레이터 오브젝트에 호출한 함수에서 넘겨 준 파라미터 값이 설정됩니다.\n\n**생성된 제너레이터 오브젝트는 이터레이터 오브젝트입니다.**  \n이터레이터 오브젝트의 메서드를 호출했을 때 제너레이터 함수 블록을 실행합니다.  \n제너레이터 함수 블록에 yield 키워드를 작성하면 함수블록의 코드를 모두 실행하지 않고 yield 키워드 단위로 나누어 실행합니다.\n\n제너레이터 함수는 new 연산자를 사용할 수 없으며 사용시 TypeError가 발생합니다.\n\n* * *\n\n<h2 id=\"function*_선언문\">function* 선언문</h2>\n\n선언문 형태로 제너레이터 함수를 정의합니다.\n\n> function* name([param[, param[, … param]]]) {  \n> statements  \n> }\n\n*   name  \n    함수명.\n    \n*   param  \n    함수에 전달되는 인수의 이름. 함수는 인수를 255개까지 가질 수 있다.\n    \n*   statements  \n    함수의 본체를 구성하는 구문들.\n    \n*   반환 값  \n    Generator 객체를 반환합니다.\n    \n```js\n1. function* sports(one, two){  \n console.log(\"함수 블록\");  \n yield one + two;  \n};  \n2. console.log(typeof sports);  \n  \n  \n3. let genObj = sports(1, 2);  \n4. console.log(typeof genObj);  \n// function  \n// object  \n```\n\n1.  function* sports(one, two){} 형태를 제너레이터 선언문이라고 합니다.  \n    처음 제너레이터 함수를 호출하면서 넘겨주는 파라미터 값이 sports()의 파라미터에 작성한 이름(one, two)에 설정됩니다.\n\n2.  console.log(typeof sprts) 제너레이터 함수의 typeof는 function입니다.\n\n3.  let genObj = sports(1,2)  \n    sports(1,2)로 호출하면 sports 함수 블록을 수행하지 않고 제너레이터 오브젝트를 생성하여 반환합니다. 함수 블록을 수행하면 console.log(“함수 블록”)이 실행되어야 하는데 실행되지 않습니다.  \n    sports(1,2)에서 넘겨 준 파라미터 값이 function* sports(one,two){}의 파라미터 one 과 two에 설정됩니다. 따라서 제너레이터 오브젝트를 사용하여 제너레이터 함수를 호출했을 때 추가 처리를 하지 않아도 파라미터 값을 사용할 수 있습니다.\n\n4.  생성된 제너레이터 오브젝트의 type 인 object가 출력됩니다.\n\nGenerator 설명  \nGenerator는 빠져나갔다가 나중에 다시 돌아올 수 있는 함수입니다. 이때 컨텍스트(변수 값)는 출입 과정에서 저장된 상태로 남아 있습니다.\n\nGenerator 함수는 호출되어도 즉시 실행되지 않고, 대신 함수를 위한 Iterator 객체가 반환됩니다. Iterator의 next() 메서드를 호출하면 Generator 함수가 실행되어 yield 문을 만날 때까지 진행하고, 해당 표현식이 명시하는 Iterator로부터의 반환값을 반환합니다. yield* 표현식을 마주칠 경우, 다른 Generator 함수가 위임(delegate)되어 진행됩니다.\n\n이후 next() 메서드가 호출되면 진행이 멈췄던 위치에서부터 재실행합니다. next() 가 반환하는 객체는 yield문이 반환할 값(yielded value)을 나타내는 value 속성과, Generator 함수 안의 모든 yield 문의 실행 여부를 표시하는 boolean 타입의 done 속성을 갖습니다. next() 를 인자값과 함께 호출할 경우, 진행을 멈췄던 위치의 yield 문을 next() 메서드에서 받은 인자값으로 치환하고 그 위치에서 다시 실행하게 됩니다.\n\n* * *\n\n<h2 id=\"function*_표현식\">function* 표현식</h2>\n\n표현식 형태로 제너레이터 함수를 정의합니다.\n\n> function* [name]([param1[, param2[, …, paramN]]]) {  \n> statements  \n> }\n\n*   name  \n    함수명. 생략하면 익명 함수가 됩니다. 함수명은 함수내에만 한정됩니다.\n\n*   paramN  \n    함수에 전달되는 인수의 이름. 함수는 최대 255 개의 인수를 가질 수 있습니다.\n\n*   statements  \n    함수의 본체를 구성하는 구문들.\n\n*   반환 값  \n    Generator 객체\n\n*   function* expression 은 function* statement 과 매우 유사하고 형식도 같습니다. function* expression 과 function* statement 의 주요한 차이점은 함수명으로, function* expressions 에서는 익명 함수로 만들기 위해 함수명이 생략될 수 있습니다.\n\n```js function* expression\n1. let sports = function*(one, two){  \n 4. console.log(\"함수 블록\");  \n yield one + two;  \n};  \n2. let genObj = sports(10, 20);  \n  \n3. console.log(genObj.next());  \n//함수 블록  \n// Object {value: 30, done: false}  \n```\n\n1.  function 이름이 없는 무명(혹은 익명) 함수입니다.  \n    함수를 변수에 할당해 줌으로써 sports를 함수 이름으로 사용할 수 있습니다.  \n    function_에 직접 함수 이름을 작성할 수 있지만, 외부에서 함수를 호출할 때는 sports()로 호출해야 합니다.  \n    function_ 함수 이름은 함수 안에서 자신을 호출할 때 사용됩니다.(재귀 함수 호출)  \n    ~~하지만 변수에 할당하며 작성한 함수 이름으로 재귀 호출할 수 있으므로  \n    function* 에 직접 함수이름을 작성하는 방법은 잘 사용하지 않습니다.  \n    자바스크립트 초기 버전에서 사용했습니다.~~\n\n2.  sports(10, 20)으로 호출하여 제너레이터 오브젝트를 생성하고, 10을 파라미터 one에 설정하고 20을 two에 설정합니다.  \n    이때, 함수 블록의 코드를 실행하지 않고 생성한 제너레이터 오브젝트를 반환합니다.\n\n3.  생성된 제너레이터 오브젝트는 이터레이터 오브젝트입니다. 제너레이터 오브젝트의 next()를 호출하면 이터레이터 오브젝트와 같은 처리를 수행합니다.  \n    next()를 호출하여 sports 제너레이터 함수의 함수 블록을 수행합니다.\n\n4.  제너레이터 함수 블록의 코드 입니다.  \n    console에 “함수 블록”을 출력합니다.  \n    sports(10, 20)으로 호출했을 때, one과 two에 값을 설정했으므로  \n    yield 키워드에서 파라미터 이름으로 값을 구할 수 있습니다.  \n    yield 키워드는 yield 오른쪽의 표현식을 평가하고,  \n    평가 결과를 {value: 30, done: false} 형태로 반환합니다.\n\n* * *\n\n**개발자 도구에서 sports 제너레이터 함수** (== 크롬브라우저)\n\n<img src=\"/images/sportsConsole.JPG\">\n\n엔진이 function* 키워드를 만나면 제너레이터 함수 오브젝트를 생성하여  \nsports 변수에 할당 합니다.\n\nsports(10, 20)을 호출하면 sports.prototype에 연결된 프로퍼티로 제너레이터 오브젝트를 생성하여 반환합니다.\n\n&#95;&#95;proto&#95;&#95;.constructor는 생성자 함수로 이름이 GeneratorFunction입니다.\n\n반환된 제너레이터 오브젝트에  \n&#95;&#95;proto&#95;&#95;.&#95;&#95;proto&#95;&#95;에 next()가 있으므로  \ngenObj.next()형태로 호출할 수 있습니다.\n\n* * *\n\n<h2 id=\"GeneratorFunction\">GeneratorFunction(): 제너레이터 함수 생성</h2>\n\n제너레이터 함수를 생성하여 반환합니다.\n\nGeneratorFunction 생성자는 새로운 generator function 객체를 생성합니다. JavaScript 에서 모든 generator function 은 실제로 GeneratorFunction object 입니다.\n\n주의할 점은, GeneratorFunction 이 전역 객체(global object)가 아니란 점입니다. GeneratorFunction은 다음의 코드를 실행해서 얻을 수 있습니다.\n\n> Object.getPrototypeOf(function*(){}).constructor\n\nnew 연산자로 GeneratorFunction() 함수를 호출할 수 없습니다. 이름 없는 제너레이터 함수를 생성하고, 여기에 연결된 constructor를 사용하여 제너레이터 함수를 생성합니다.\n\n```js\n1. let GenConst = Object.getPrototypeOf(function*(){}).constructor;  \n2. let sports = new GenConst(  \n \"one\", \"two\",  \n \"console.log('함수 블록'); yield one + two\"  \n);  \n3. let genObj = sports(3, 4);  \n  \n4. console.log(genObj.next());  \n// 함수 블록  \n// Object {value: 7, done: false}  \n```\n\n1.  제너레이터 함수를 생성하기 위한 생성자(constructor)를 구합니다.  \n    function*(){}으로 익명 제너레이터 함수를 생성하여 Object.getPrototypeOf()의 파라미터 값으로 지정합니다. 익명 제너레이터 함수의 prototype 오브젝트가 반환됩니다. prototype에 constructor가 있으므로 이를 반환하고 GenConst에 할당합니다. (Genconst 변수가 생성자 함수가 되는 것 입니다.)\n\n2.  new 연산자로 GenConst 생성자를 호출하여 제너레이터 함수를 생성합니다.  \n    (GenConst의 파라미터에 생성될 제너레이터 함수에서 사용할 파라미터와 함수 블록 코드를 문자열로 작성합니다.)  \n    첫 번째 one 과 두 번째 two가 제너레이터 함수의 파라미터가 되고,  \n    세 번째 파라미터가 함수 블록 코드가 됩니다.\n\n파라미터의 문자열을 parsing(문자열 해석?)하면 다음과 같은 형태가 되는 것입니다.\n\n```js new GenConst parsing\n(function*(one,two){  \n console.log('함수 블록');  \n yield one + two  \n})  \n```\n\n3.  sports(3,4)로 호출하면 제너레이터 오브젝트를 생성하여 반환합니다.  \n    function*(one, two){}에서 3이 one에 4가 two에 설정됩니다.\n\n4.  next()를 호출하면 함수 블록 코드를 실행합니다.  \n    Object {value: 7, done: false}를 반환합니다.\n\n* * *\n\n<h2 id=\"yield\">yield: 제너레이터 함수 실행, 멈춤</h2>\n\nyield 키워드는 제너레이터 함수를 멈추게 하거나 다시 실행하는데 사용됩니다.\n\n> [returnValue] = yield [expression];\n\n*   expression  \n    제너레이터 함수에서 제너레이터 프로토콜을 통해 반환할 값을 정의합니다(표현식). 값이 생략되면, undefined를 반환합니다.\n\n*   returnValue  \n    제너레이터 실행을 재개 하기 위해서, optional value을 제너레이터의 next() 메서드로 전달하여 반환합니다.\n\n*   yield의 표현식 평가 결과를 왼쪽의 returnValue에 할당하지 않습니다.  \n    제너레이터 오브젝트의 next()를 호출하면 next() 파라미터 값이 returnValue에 할당됩니다.\n\n*   next()로 제너레이터 함수를 호출하면 yield 작성에 관계없이 “{value: 값, done: false/true}” 형태로 반환합니다.\n\n*   yield를 수행하면 표현식 평가 결과가 value 값에 설정되고, yield를 수행하지 못하면 undefined가 설정됩니다.\n\n```js\nfunction* sports(one){  \n let two = yield one;  \n let param = yield two + one;  \n yield param + one;  \n}  \n1. let generatorObj = sports(10);  \n  \n2. console.log(generatorObj.next());  \n3. console.log(generatorObj.next());  \n4. console.log(generatorObj.next(20));  \n//Object {value: 10, done: false}  \n//Object {value: NaN, done: false}  \n//Object {value: 30, done: false}  \n```\n\n1.  sports(10)으로 호출하여 제너레이터 함수의 one 파라미터에 10이 설정되고  \n    제너레이터 오브젝트를 생성하여 반환합니다. (함수 블록의 코드는 실행하지 않습니다.)\n\n2.  generatorObj.next()를 호출하면 sports 제너레이터 함수 블록의 첫 줄부터 첫 번째 yield까지 수행합니다. == (let two = yield one;)  \n    yield의 표현식 평과 결과 {value: 10, done: false}형태를 반환합니다.  \n    할당연산자(=)는 오른쪽 값을 왼쪽 변수에 할당하지만, yield 의 할당연산자(=)는 할당하지 않습니다.\n\n3.  next()를 다시한번 호출하면 파라미터 값을 (let two = yield one)에서 two 변수에 설정합니다. 파라미터 값이 지정되지 않았으며 undefined가 two 변수에 설정됩니다. 그리고 아래 코드를 실행합니다.  \n    two 변수에 undefined가 설정되어 있고, one 변수에 10이 설정되어 있으므로  \n    Object {value: NaN, done: false}를 반환합니다. NaN을 param 변수에 설정하지 않습니다.\n\n4.  next(20)으로 호출하면 파라미터 값 20을 (let param = yield two + one)에서 param 변수에 설정합니다. param 변수 값이 20이고 one 변수 값이 10이므로  \n    {value: 30, done: false}를 반환합니다.\n\n```js\nfunction* sports(one){  \n yield one;  \n 4. let check = 10;  \n}  \n1. let genObj = sports(10);  \n  \n2. console.log(genObj.next());  \n3. console.log(genObj.next());  \n//Object {value: 10, done: false}  \n//Object {value: undefined, done: true}  \n```\n\n1.  sports(10) 으로 호출하면 제너레이터 함수의 one 파라미터에 10이 설정되고  \n    제너레이터 오브젝트를 생성하여 반환합니다.\n\n2.  next()를 호출하면 함수 블록의 첫 줄부터 첫 번째 yield의 표현식까지 수행합니다. yield one; = {value: 10, done: false} 형태로 반환합니다.\n\n3.  next()를 호출하면 파라미터 값을 바로 앞 yield 왼쪽에 있는 변수에 할당합니다.  \n    그런데 왼쪽의 변수가 없으므로 값을 할당하지 않습니다.  \n    이후에 아래 코드를 실행합니다.\n\n4.  check에 10을 할당하는 코드이지만 더 이상 수행할 yield는 없고  \n    함수 안에 더 처리해야할 코드도 없습니다. 반환할 값이 없습니다.  \n    value 프로퍼티 값에 undefined를 설정하고, done 프로퍼티 값에 true를 설정합니다. {value: undefined, done: true} 형태로 반환됩니다.\n\n* * *\n\n<h2 id=\"next\">next(): yield 단위로 실행</h2>\n\n제너레이터 함수에서 yield 단위로 실행합니다.\n\nnext()를 호출하면 yield를 기준으로 이전 yield의 다음 줄부터 yield까지 수행합니다.\n\n제너레이터 함수에 yield가 여러개 작성되어 있으면, yield 수만큼 next()를 작성해줘야 제너레이터 함수 전체를 실행하게 됩니다.\n\n파라미터는 선택으로 제너레이터 함수가 멈춘 yield의 왼쪽 변수에 설정합니다.\n\n```js\nlet gen = function*(value){  \n value = value + 10;  \n yield ++value;  \n value = value + 7;  \n yield ++value;  \n};  \n1. let genObj = gen(1);  \n  \nconsole.log(genObj.next());  \nconsole.log(genObj.next());  \nconsole.log(genObj.next());  \n//Object {value: 12, done: false}  \n//Object {value: 20, done: false}  \n//Object {value: undefined, done: false}  \n```\n\n1.  gen(1)로 호출하면 제너레이터 함수의 value 파라미터에 1이 설정되며 제너레이터 오브젝트를 생성하여 반환합니다.\n\n2.  next()를 호출하면 제너레이터 함수 첫 줄부터 yield의 표현식까지 수행합니다.  \n    즉, 다음 코드를 실행합니다.  \n    value = value + 10;  \n    yield ++value;  \n    파라미터로 받은 1에 10을 더해 value에 할당합니다.  \n    다음으로 yield ++value;를 실행하여 value값에 1을 더합니다.  \n    {value: 12, done: false}가 반환됩니다.\n\n3.  다시 next()를 호출하면 yield ++value에서 yield 왼쪽에 파라미터 값을 설정합니다. 그런데 왼쪽에 변수가 없으므로 다음 코드를 실행합니다.  \n    value = value + 7;  \n    yield ++value;  \n    value 변수 값이 12이므로 7을 더해 19를 value에 할당합니다.  \n    다음으로 yield ++value;을 실행하여 {value: 20, done: false}를 반환합니다.\n\n4.  다시 next()를 호출하면 제너레이터 함수에 yield가 없으므로  \n    {value: undefined, done: false}를 반환합니다.\n\n* * *\n\n<h2 id=\"next_ex\">next() 활용 예제</h2>\n\n청구 금액과 할인 금액 계산하여 반환\n\n1.  청구 금액을 계싼하는 제너레이터 함수와 할인 금액을 계산하는 일반 함수를 정의합니다.\n    \n2.  청구 금액 계산 제너레이터 함수는 수량과 단가를 파라미터로 받아 금액을 계산합니다.\n    \n3.  계산한 금액을 yield로 반환합니다.\n    \n4.  할인 금액 함수를 호출하면서 yield로 반환된 값을 파라미터 값으로 넘겨 줍니다.\n    \n5.  파라미터의 금액에 따라 할인 금액을 계산하여 반환합니다.\n    \n6.  청구 금액 계산 제너레이터 함수를 호출하면서 할인 금액을 파라미터로 넘겨줍니다.\n    \n7.  합계 금액에서 할인 금액을 빼서 청구 금액을 계산합니다,\n    \n8.  계산된 청구 금액을 반환합니다.\n    \n\n```js next(), yield 활용 예제\n// 청구 금액을 계산하는 제너레이터 함수 getAmount  \n// 파라미터 qty = 수량 , price = 단가  \nlet getAmount = function*(qty, price){  \n// 함수가 처음 호출될 때 수량에 단가를 곱해 합계 금액을 구하고 소숫점은 버립니다.  \n let amount = Math.floor(qty * price);  \n// 두 번째 호출될 때 할인 금액(discount)을 받아   \n// 합계 금액에서 할인 금액을 빼서 반환합니다.  \n let discount = yield amount;  \n return amount - discount;  \n};  \n// 할인 금액을 구하는 함수 getDiscount  \n// 파라미터 값인 amount가 1000 보다 크면 0.2를 곱하고  \n// 아니면 0.1을 곱합니다.  \nlet getDiscount = function(amount){  \n return amount > 1000 ? amount * 0.2 : amount * 0.1;  \n};  \n// getAmount(10, 60)으로 호출하여 qty값 10 price값 60이 설정됩니다.  \n// 제너레이터 오브젝트를 생성하여 반환합니다.  \nlet amountObj = getAmount(10, 60);  \n// next()를 호출하여 제너레이터 함수를 실행시키고 반환된 결과를  \n// result 변수에 할당합니다.  \n /*  \n let amount = Math.floor(qty * price);  \n 10 * 60 = 600  \n amount에 600이 할당됩니다.  \n {value: 600, done: false} 반환  \n */  \nlet result = amountObj.next();  \nconsole.log(result);  \n//할인 금액을 구하는 함수  \n//앞의 next()에서 value:600을 반환했으므로 파라미터 값으로 600을 넘겨줍니다.  \n//호출된 dcAmount에서 60을 반환합니다.  \nlet dcAmount = getDiscount(result.value);  \nconsole.log(dcAmount);  \n//next(dcAmount)로 호출하여 파라미터 값 60을 넘겨줍니다  \n// let discount = yield amount 에서 60이 discount에 설정됩니다.  \n// 그리고 return amount - discount 를 실행하여  \n// {value: 540, done: true}를 반환합니다.  \nconsole.log(amountObj.next(dcAmount));  \n```\n\n* * *\n\n### next()의 다양한 형태\n\nnext()와 yield를 조합한 다양한 형태를 살펴 봅니다.  \n제너레이터 함수를 계속 호출 하려면 yield가 이에 대응할 수 있어야 합니다.  \n이를 위해 한 줄에 다수의 yield를 작성할 수도 있고,  \n배열 안에 다수의 yield를 작성할 수도 있습니다.\n\n```js next-while\nlet gen = function*(value) {  \n let count = 0;  \n while (value){  \n yield ++count;  \n }  \n};  \nlet genObj = gen(true);  \n  \n1. console.log(genObj.next());  \n2. console.log(genObj.next());  \n// Object {value: 1, done: false}  \n// Object {value: 2, done: false}  \n```\n\n제너레이터 함수에 while문을 작성하고 그 안에 yield를 작성한 형태입니다.\n\n1.  처음 next()를 호출하면 gen()함수의 첫 줄부터 yield까지 수행한 후 그 값을 반환합니다.  \n    (let count = 0;)는 처음 한 번만 실행되고 다음부터는 실행하지 않습니다.  \n    while(value){}에서 value 파라미터 값이 true이므로 블락을 실행합니다.  \n    yield ++count가 실행되어 {value: 1, done: false}를 반환합니다.\n\n2.  다시 next()를 호출하면 앞에서 증가된 count 변수 값이 유지되므로 값을 누적할 수 있습니다. yield ++count를 실행하여 {value: 2, done: false}를 반환합니다.  \n    이와 같이 while문 안에 yield를 작성하면 next()를 호출할 때마다 yield가 수행됩니다.\n\n```js next-return-yield\nlet gen = function*(){  \n return yield yield yield;  \n}  \nlet genObj = gen();  \n  \n1. console.log(genObj.next());  \n2. console.log(genObj.next(10));  \n  \n3. console.log(genObj.next(20));  \n4. console.log(genObj.next(30));  \n// Object {value: undefined, done: false}  \n// Object {value: 10, done: false}  \n// Object {value: 20, done: false}  \n// Object {value: 30, done: true}  \n```\n\n제너레이터 함수의 return 문에 다수의 yield를 작성한 형태입니다.  \nreturn 문의 표현식에 yield가 3개 작성되어 있습니다.\n\n1.  처음 next()를 호출하면 첫 번째 yield를 수행합니다.  \n    yield에 반환 값이 없으므로 {value: undefined, done: false}를 반환합니다.\n\n2.  두 번째로 next(10)을 호출하면 두 번째 yield를 수행합니다.  \n    왼쪽에 파라미터 값을 받을 변수가 없으므로 파라미터로 넘겨준 값 그대로 반환합니다. 따라서 {value: 10, done: false}를 반환합니다.\n\n3.  세 번째로 next(20)을 호출하면 세 번째 yield를 수행합니다.  \n    {value: 20, done: false}를 반환합니다.\n\n4.  마지막으로 next(30)을 호출하면 수행할 yield가 없습니다.  \n    {done: true}를 반환하고, return을 작성했으므로 파라미터로 넘겨준 값을  \n    반환 합니다. 즉 {value: 30, done: false}이 반환됩니다.  \n    return을 작성하지 않으면 {value: undefined, done: true}를 반환합니다.\n\n```js next-array-yield\nlet gen = function*(){  \n return [yield yield];  \n};  \nlet genObj = gen();  \n  \n1. console.log(genObj.next());  \n2. console.log(genObj.next(10));  \n3. console.log(genObj.next(20));  \n// Object {value: undefined, done: false}  \n// Object {value: 10, done: false}  \n// Object {value: Array[1], done: true}  \n```\n\n제너레이터 함수의 return 문에 배열안에 다수의 yield를 작성한 형태입니다.\n\n1.  2.  는 return문에 yield을 연속으로 작성한 것과 같습니다.  \n        yield가 2개 뿐이므로 더 이상 수행할 yield가 없는 상태가 됩니다.\n\n3.  마지막으로 next(20)을 호출하면 (return [yield yield])에서 yield를 제외한  \n    []안에 파라미터로 넘겨준 값을 작성합니다.  \n    {value: Array[1], done: true} 형태로 반환됩니다.  \n    Array[1]은 {0:20} 입니다.\n\n```js for-of-yield\nlet gen = function*(start){  \n let value = start;  \n while (true){  \n yield ++value;  \n }  \n};  \n  \nfor (var count of gen(10)){  \n console.log(count);  \n if (count > 12){  \n break;  \n }  \n};  \n// 11  \n// 12  \n// 13  \n```\n\nfor-of() 문에 제너레이터 함수를 호출하는 코드를 작성한 형태입니다.\n\n*   처음 for-of 문을 시작하면 gen(10)을 호출하여 제너레이터 함수의 start 파라미터에 10을 설정하고 제너레이터 오브젝트를 생성하여 반환합니다.  \n    호출한 gen(10) 위치로 돌아오면 반환받은 오브젝트를 할당할 변수가 없으므로 엔진 내부에 저장합니다.\n\n*   gen() 함수를 호출하며 이는 next()를 호출한 것과 같습니다.  \n    let value = start;를 수행한 후 while (true){yield ++value;}를 수행합니다.  \n    {value: 11, done:false}를 반환하게 되며 value 프로퍼티 값이 count 변수에 설정됩니다.\n\n*   for-of 문의 블록에 작성한 코드를 수행하며 콘솔에 11이 출력됩니다.  \n    count 변수 값이 11이므로 다시 for-of 문을 반복하게 됩니다.  \n    count 변수 값이 12보다 클때 까지 for-of문을 반복합니다.\n\n* * *\n\n<h2 id=\"throw\">throw(): Error 발생</h2>\n\nthrow() 메서드는 Generator의 실행을 재개시키고 Generator 함수의 실행 문맥 속으로 error를 주입합니다.\n\n제너레이터 함수를 호출하여 받은 제너레이터 오브젝트의 throw()를 호출하면  \n에러가 발생합니다. 에러가 발생하면 제너레이터 함수의 catch()문에서 에러를 받습니다.\n\n```js\nlet gen = function*(){  \n try {  \n yield 10;  \n } catch (message) {  \n yield message;  \n }  \n yield 20;  \n}  \nlet genObj = gen();  \n  \n1. console.log(genObj.next());  \n2. console.log(genObj.throw(\"에러 발생\"));  \n3. console.log(genObj.next());  \n// Object {value: 10, done: false}  \n// Object {value: \"에러 발생\", done: false}  \n// Object {value: 20, done: false}  \n```\n\n1.  next()를 호출하면 try문 의 (yield 10;)을 실행합니다.  \n    에러가 발생하지않으며 {value: 10, done: false}를 반환합니다.\n\n2.  throw(“에러 발생”)를 호출하면 제너레이터 함수의 catch(message)가 실행됩니다.  \n    throw()의 파라미터 값이 catch(message)의 message 파라미터에 설정됩니다.  \n    catch() 블록{}의 (yield message;)가 실행되어 {value: “에러 발생”, done: false}가 반환됩니다.  \n    중요한 점은 done: false를 반환한다는 점입니다. 즉, 에러는 발생했지만 다음에 next()를 호출할 수 있습니다.\n    *   genObj.throw(Error(“에러 발생”)); 과 같이 파라미터에 Error 오브젝트를 작성할 수도 있습니다.\n\n3.  앞에서 throw()를 호출하며 catch()블록을 수행했지만 이터레이터가 종료된 것은 아닙니다. 따라서 다시 next()를 호출할 수 있으며 함수의 (yield 20;)을 수행하여  \n    {value: 20, done: false}를 반환합니다.\n\n```js 제너레이터 함수에서 에러가 발생\nlet gen = function*(){  \n throw \"에러 발생\";  \n yield 20;  \n};  \nlet genObj = gen();  \n  \n1. try {  \n let result = genObj.next();  \n} catch (error) {  \n console.log(error);  \n}  \n2. console.log(genObj.next());  \n//에러 발생  \n// Object {value: undefined, done: true}  \n```\n\n1.  try문에서 next()를 호출하면 제너레이터 함수 첫 줄에서 throw문으로 인해 에러가 발생하며, catch(error)에서 에러를 받습니다.  \n    (throw “에러 발생”)에서 “에러 발생”이 catch(error)의 error 파라미터에 설정됩니다.\n\n2.  제너레이터 함수에서 에러가 발생하면 이터레이터가 종료됩니다.  \n    따라서 next()를 실행하면 제너레이터 함수내에 throw “에러 발생” 밑에  \n    yield 20;이 있지만 실행되지 않습니다.  \n    {value: undefined, done: true}가 반환됩니다.\n\n* * *\n\n<h2 id=\"yield*\">yield* 키워드</h2>\n\n> yield* [[expression]]\n\n표현식(expression)에 이터러블 오브젝트를 작성합니다. next()를 호출할 때 마다  \n이터러블 오브젝트를 하나씩 실행하며, 결과 값을 yield의 반환 값으로 사용합니다.\n\n표현식에 제너레이터 함수를 작성할 수 있습니다.  \n표현식으로 호출된 함수에 다수의 yield가 있으면 호출된 함수의 yield를 전부 처리한 후 yield* 아래에 작성한 코드를 실행합니다.\n\n```js yield* 표현식에 제너레이터 함수 작성 형태\nlet plusGen = function*(value) {  \n yield value + 5;  \n yield value + 10;  \n};  \nlet gen = function*(value) {  \n yield* plusGen(value);  \n yield value + 20;  \n};  \nlet genObj = gen(10);  \n\n1. console.log(\"1:\", genObj.next());  \n2. console.log(\"2:\", genObj.next());  \n3. console.log(\"3:\", genObj.next());  \n// Object {value: 15, done: false}  \n// Object {value: 20, done: false}  \n// Object {value: 30, done: false}  \n```\n\n1.  console.log로 genObj.next()를 호출하면 실행되는 순서가 다음과 같습니다.\n    \n    1.  gen() 함수의 yield* plusGen(value)을 실행합니다.\n        \n    2.  yield*를 작성했으므로 plusGen(value)을 호출하면서 파라미터 값으로 10을 넘겨줍니다.\n        \n    3.  plusGen()이 제너레이터 함수이므로 제너레이터 오브젝트를 생성하여 반환합니다.\n        \n    4.  next()로 호출헤야 plusGen() 함수의 yield를 수행하지만, 이때는 자동으로 plusGen()의 첫 번째 (yield value + 5)를 수행하며 {value: 15, done: false}를 반환합니다.\n        \n    5.  plusGen()을 호출한 곳에서 다시 yield를 수행하므로 plusGen()에서 반환된 값을 반환합니다.\n        \n    6.  콘솔에 Object {value: 15, done: false}를 출력합니다.\n        \n\n2.  next()를 호출하면 plusGen()에서 수행하지 않은 (yield value + 10;)을 실행하며 Object {value: 20, done: false}를 반환합니다.\n\n3.  next()를 호출하면 plusGen()에 더 이상 실행할 yield가 없으므로  \n    plusGen()을 호출한 gen() 함수 내의 코드 아래의 코드를 수행합니다.  \n    (yield value + 20;) 을 실행하게 되며 Object {value: 30, done: false}를 반환합니다.\n\n```js yield* 표현식 재귀 호출 형태\nlet gen = function*(value) {  \n yield value;  \n yield* gen(value + 10);  \n}  \nlet genObj = gen(1);  \n  \n1. console.log(genObj.next());  \n2. console.log(genObj.next());  \n3. console.log(genObj.next());  \n// Object {value: 1, done: false}  \n// Object {value: 11, done: false}  \n// Object {value: 21, done: false}  \n```\n\n1.  처음 next()를 호출하면 제너레이터 함수 첫째 줄의 (yield value;)를 실행하며  \n    {value: 1, done: false}를 반환합니다.\n\n2.  두 번째로 next()를 호출하면 (yield* gen(value + 10);)을 실행합니다.  \n    그런데 yield* 표현식에서 자신 함수(gen)를 호출합니다. 파라미터 값으로 11을 넘겨주며 next()가 없지만 엔진에서 반환받은 오브젝트의 제너레이터 함수를 호출합니다. (yield value;)가 실행되며 {value: 11, done: false}를 반환합니다.  \n    <mark>이때, yield value;가 없다면 계속해서 자신을 호출하게 되므로 무한 루프를 돌게됩니다.</mark>\n\n3.  세 번째로 next()를 호출하면 (yield* gen(value + 10);)을 실행하고  \n    자신을 호출합니다. 위와 같이 진행되어 {value: 21, done: false}를 반환합니다.\n","source":"_posts/Generator 오브젝트 -ECMAScript.md","raw":"---\ntitle: Generator 오브젝트 -ECMAScript\ndate: 2020-03-31 08:54:39\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n* * *\n\n함수를 호출하면 함수 블록의 코드를 한 번에 실행하지만,  \n제너레이터(Generator)오브젝트는 나누어서 실행할 수 있습니다.\n\n*   Generator\n    *   [function* 선언문](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#function*_선언문)\n    *   [function* 표현식](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#function*_표현식)\n    *   [GeneratorFunction():제너레이터 함수 생성](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#GeneratorFunction)\n    *   [yield: 제너레이터 함수 실행,멈춤](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#yield)\n    *   [next():yield 단위로 실행](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#next)\n    *   [next() 활용 예제](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#next_ex)\n    *   [throw(): Error 발생](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#throw)\n    *   [yield* 키워드](/2020/03/31/Generator%20오브젝트%20-ECMAScript/#yield*)\n\n<!-- more -->\n\n제너레이터 함수 작성 형식은 3가지가 있습니다.\n\n1.  function* 선언문\n    \n2.  function* 표현식\n    \n3.  GeneratorFunction\n    \n\nfunction* 선언문과 표현식은 기존의 function과 형태가 같습니다,  \n“*”를 사용하는 형태만 다릅니다.  \nGeneratorFunction은 new Function()과 같으며  \n파라미터에 지정한 문자열로 제너레이터 함수를 생성하여 반환합니다.\n\n### 중요 포인트\n\n제너레이터 함수를 호출하면 제너레이터 오브젝트를 생성하여 반환합니다.  \nfunction()을 호출하면 함수 블록을 실행하지만, 제너레이터 함수는 함수 블록을 실행하지 않고 제너레이터 오브젝트를 생성하여 반환합니다.  \n생성한 제너레이터 오브젝트에 호출한 함수에서 넘겨 준 파라미터 값이 설정됩니다.\n\n**생성된 제너레이터 오브젝트는 이터레이터 오브젝트입니다.**  \n이터레이터 오브젝트의 메서드를 호출했을 때 제너레이터 함수 블록을 실행합니다.  \n제너레이터 함수 블록에 yield 키워드를 작성하면 함수블록의 코드를 모두 실행하지 않고 yield 키워드 단위로 나누어 실행합니다.\n\n제너레이터 함수는 new 연산자를 사용할 수 없으며 사용시 TypeError가 발생합니다.\n\n* * *\n\n<h2 id=\"function*_선언문\">function* 선언문</h2>\n\n선언문 형태로 제너레이터 함수를 정의합니다.\n\n> function* name([param[, param[, … param]]]) {  \n> statements  \n> }\n\n*   name  \n    함수명.\n    \n*   param  \n    함수에 전달되는 인수의 이름. 함수는 인수를 255개까지 가질 수 있다.\n    \n*   statements  \n    함수의 본체를 구성하는 구문들.\n    \n*   반환 값  \n    Generator 객체를 반환합니다.\n    \n```js\n1. function* sports(one, two){  \n console.log(\"함수 블록\");  \n yield one + two;  \n};  \n2. console.log(typeof sports);  \n  \n  \n3. let genObj = sports(1, 2);  \n4. console.log(typeof genObj);  \n// function  \n// object  \n```\n\n1.  function* sports(one, two){} 형태를 제너레이터 선언문이라고 합니다.  \n    처음 제너레이터 함수를 호출하면서 넘겨주는 파라미터 값이 sports()의 파라미터에 작성한 이름(one, two)에 설정됩니다.\n\n2.  console.log(typeof sprts) 제너레이터 함수의 typeof는 function입니다.\n\n3.  let genObj = sports(1,2)  \n    sports(1,2)로 호출하면 sports 함수 블록을 수행하지 않고 제너레이터 오브젝트를 생성하여 반환합니다. 함수 블록을 수행하면 console.log(“함수 블록”)이 실행되어야 하는데 실행되지 않습니다.  \n    sports(1,2)에서 넘겨 준 파라미터 값이 function* sports(one,two){}의 파라미터 one 과 two에 설정됩니다. 따라서 제너레이터 오브젝트를 사용하여 제너레이터 함수를 호출했을 때 추가 처리를 하지 않아도 파라미터 값을 사용할 수 있습니다.\n\n4.  생성된 제너레이터 오브젝트의 type 인 object가 출력됩니다.\n\nGenerator 설명  \nGenerator는 빠져나갔다가 나중에 다시 돌아올 수 있는 함수입니다. 이때 컨텍스트(변수 값)는 출입 과정에서 저장된 상태로 남아 있습니다.\n\nGenerator 함수는 호출되어도 즉시 실행되지 않고, 대신 함수를 위한 Iterator 객체가 반환됩니다. Iterator의 next() 메서드를 호출하면 Generator 함수가 실행되어 yield 문을 만날 때까지 진행하고, 해당 표현식이 명시하는 Iterator로부터의 반환값을 반환합니다. yield* 표현식을 마주칠 경우, 다른 Generator 함수가 위임(delegate)되어 진행됩니다.\n\n이후 next() 메서드가 호출되면 진행이 멈췄던 위치에서부터 재실행합니다. next() 가 반환하는 객체는 yield문이 반환할 값(yielded value)을 나타내는 value 속성과, Generator 함수 안의 모든 yield 문의 실행 여부를 표시하는 boolean 타입의 done 속성을 갖습니다. next() 를 인자값과 함께 호출할 경우, 진행을 멈췄던 위치의 yield 문을 next() 메서드에서 받은 인자값으로 치환하고 그 위치에서 다시 실행하게 됩니다.\n\n* * *\n\n<h2 id=\"function*_표현식\">function* 표현식</h2>\n\n표현식 형태로 제너레이터 함수를 정의합니다.\n\n> function* [name]([param1[, param2[, …, paramN]]]) {  \n> statements  \n> }\n\n*   name  \n    함수명. 생략하면 익명 함수가 됩니다. 함수명은 함수내에만 한정됩니다.\n\n*   paramN  \n    함수에 전달되는 인수의 이름. 함수는 최대 255 개의 인수를 가질 수 있습니다.\n\n*   statements  \n    함수의 본체를 구성하는 구문들.\n\n*   반환 값  \n    Generator 객체\n\n*   function* expression 은 function* statement 과 매우 유사하고 형식도 같습니다. function* expression 과 function* statement 의 주요한 차이점은 함수명으로, function* expressions 에서는 익명 함수로 만들기 위해 함수명이 생략될 수 있습니다.\n\n```js function* expression\n1. let sports = function*(one, two){  \n 4. console.log(\"함수 블록\");  \n yield one + two;  \n};  \n2. let genObj = sports(10, 20);  \n  \n3. console.log(genObj.next());  \n//함수 블록  \n// Object {value: 30, done: false}  \n```\n\n1.  function 이름이 없는 무명(혹은 익명) 함수입니다.  \n    함수를 변수에 할당해 줌으로써 sports를 함수 이름으로 사용할 수 있습니다.  \n    function_에 직접 함수 이름을 작성할 수 있지만, 외부에서 함수를 호출할 때는 sports()로 호출해야 합니다.  \n    function_ 함수 이름은 함수 안에서 자신을 호출할 때 사용됩니다.(재귀 함수 호출)  \n    ~~하지만 변수에 할당하며 작성한 함수 이름으로 재귀 호출할 수 있으므로  \n    function* 에 직접 함수이름을 작성하는 방법은 잘 사용하지 않습니다.  \n    자바스크립트 초기 버전에서 사용했습니다.~~\n\n2.  sports(10, 20)으로 호출하여 제너레이터 오브젝트를 생성하고, 10을 파라미터 one에 설정하고 20을 two에 설정합니다.  \n    이때, 함수 블록의 코드를 실행하지 않고 생성한 제너레이터 오브젝트를 반환합니다.\n\n3.  생성된 제너레이터 오브젝트는 이터레이터 오브젝트입니다. 제너레이터 오브젝트의 next()를 호출하면 이터레이터 오브젝트와 같은 처리를 수행합니다.  \n    next()를 호출하여 sports 제너레이터 함수의 함수 블록을 수행합니다.\n\n4.  제너레이터 함수 블록의 코드 입니다.  \n    console에 “함수 블록”을 출력합니다.  \n    sports(10, 20)으로 호출했을 때, one과 two에 값을 설정했으므로  \n    yield 키워드에서 파라미터 이름으로 값을 구할 수 있습니다.  \n    yield 키워드는 yield 오른쪽의 표현식을 평가하고,  \n    평가 결과를 {value: 30, done: false} 형태로 반환합니다.\n\n* * *\n\n**개발자 도구에서 sports 제너레이터 함수** (== 크롬브라우저)\n\n<img src=\"/images/sportsConsole.JPG\">\n\n엔진이 function* 키워드를 만나면 제너레이터 함수 오브젝트를 생성하여  \nsports 변수에 할당 합니다.\n\nsports(10, 20)을 호출하면 sports.prototype에 연결된 프로퍼티로 제너레이터 오브젝트를 생성하여 반환합니다.\n\n&#95;&#95;proto&#95;&#95;.constructor는 생성자 함수로 이름이 GeneratorFunction입니다.\n\n반환된 제너레이터 오브젝트에  \n&#95;&#95;proto&#95;&#95;.&#95;&#95;proto&#95;&#95;에 next()가 있으므로  \ngenObj.next()형태로 호출할 수 있습니다.\n\n* * *\n\n<h2 id=\"GeneratorFunction\">GeneratorFunction(): 제너레이터 함수 생성</h2>\n\n제너레이터 함수를 생성하여 반환합니다.\n\nGeneratorFunction 생성자는 새로운 generator function 객체를 생성합니다. JavaScript 에서 모든 generator function 은 실제로 GeneratorFunction object 입니다.\n\n주의할 점은, GeneratorFunction 이 전역 객체(global object)가 아니란 점입니다. GeneratorFunction은 다음의 코드를 실행해서 얻을 수 있습니다.\n\n> Object.getPrototypeOf(function*(){}).constructor\n\nnew 연산자로 GeneratorFunction() 함수를 호출할 수 없습니다. 이름 없는 제너레이터 함수를 생성하고, 여기에 연결된 constructor를 사용하여 제너레이터 함수를 생성합니다.\n\n```js\n1. let GenConst = Object.getPrototypeOf(function*(){}).constructor;  \n2. let sports = new GenConst(  \n \"one\", \"two\",  \n \"console.log('함수 블록'); yield one + two\"  \n);  \n3. let genObj = sports(3, 4);  \n  \n4. console.log(genObj.next());  \n// 함수 블록  \n// Object {value: 7, done: false}  \n```\n\n1.  제너레이터 함수를 생성하기 위한 생성자(constructor)를 구합니다.  \n    function*(){}으로 익명 제너레이터 함수를 생성하여 Object.getPrototypeOf()의 파라미터 값으로 지정합니다. 익명 제너레이터 함수의 prototype 오브젝트가 반환됩니다. prototype에 constructor가 있으므로 이를 반환하고 GenConst에 할당합니다. (Genconst 변수가 생성자 함수가 되는 것 입니다.)\n\n2.  new 연산자로 GenConst 생성자를 호출하여 제너레이터 함수를 생성합니다.  \n    (GenConst의 파라미터에 생성될 제너레이터 함수에서 사용할 파라미터와 함수 블록 코드를 문자열로 작성합니다.)  \n    첫 번째 one 과 두 번째 two가 제너레이터 함수의 파라미터가 되고,  \n    세 번째 파라미터가 함수 블록 코드가 됩니다.\n\n파라미터의 문자열을 parsing(문자열 해석?)하면 다음과 같은 형태가 되는 것입니다.\n\n```js new GenConst parsing\n(function*(one,two){  \n console.log('함수 블록');  \n yield one + two  \n})  \n```\n\n3.  sports(3,4)로 호출하면 제너레이터 오브젝트를 생성하여 반환합니다.  \n    function*(one, two){}에서 3이 one에 4가 two에 설정됩니다.\n\n4.  next()를 호출하면 함수 블록 코드를 실행합니다.  \n    Object {value: 7, done: false}를 반환합니다.\n\n* * *\n\n<h2 id=\"yield\">yield: 제너레이터 함수 실행, 멈춤</h2>\n\nyield 키워드는 제너레이터 함수를 멈추게 하거나 다시 실행하는데 사용됩니다.\n\n> [returnValue] = yield [expression];\n\n*   expression  \n    제너레이터 함수에서 제너레이터 프로토콜을 통해 반환할 값을 정의합니다(표현식). 값이 생략되면, undefined를 반환합니다.\n\n*   returnValue  \n    제너레이터 실행을 재개 하기 위해서, optional value을 제너레이터의 next() 메서드로 전달하여 반환합니다.\n\n*   yield의 표현식 평가 결과를 왼쪽의 returnValue에 할당하지 않습니다.  \n    제너레이터 오브젝트의 next()를 호출하면 next() 파라미터 값이 returnValue에 할당됩니다.\n\n*   next()로 제너레이터 함수를 호출하면 yield 작성에 관계없이 “{value: 값, done: false/true}” 형태로 반환합니다.\n\n*   yield를 수행하면 표현식 평가 결과가 value 값에 설정되고, yield를 수행하지 못하면 undefined가 설정됩니다.\n\n```js\nfunction* sports(one){  \n let two = yield one;  \n let param = yield two + one;  \n yield param + one;  \n}  \n1. let generatorObj = sports(10);  \n  \n2. console.log(generatorObj.next());  \n3. console.log(generatorObj.next());  \n4. console.log(generatorObj.next(20));  \n//Object {value: 10, done: false}  \n//Object {value: NaN, done: false}  \n//Object {value: 30, done: false}  \n```\n\n1.  sports(10)으로 호출하여 제너레이터 함수의 one 파라미터에 10이 설정되고  \n    제너레이터 오브젝트를 생성하여 반환합니다. (함수 블록의 코드는 실행하지 않습니다.)\n\n2.  generatorObj.next()를 호출하면 sports 제너레이터 함수 블록의 첫 줄부터 첫 번째 yield까지 수행합니다. == (let two = yield one;)  \n    yield의 표현식 평과 결과 {value: 10, done: false}형태를 반환합니다.  \n    할당연산자(=)는 오른쪽 값을 왼쪽 변수에 할당하지만, yield 의 할당연산자(=)는 할당하지 않습니다.\n\n3.  next()를 다시한번 호출하면 파라미터 값을 (let two = yield one)에서 two 변수에 설정합니다. 파라미터 값이 지정되지 않았으며 undefined가 two 변수에 설정됩니다. 그리고 아래 코드를 실행합니다.  \n    two 변수에 undefined가 설정되어 있고, one 변수에 10이 설정되어 있으므로  \n    Object {value: NaN, done: false}를 반환합니다. NaN을 param 변수에 설정하지 않습니다.\n\n4.  next(20)으로 호출하면 파라미터 값 20을 (let param = yield two + one)에서 param 변수에 설정합니다. param 변수 값이 20이고 one 변수 값이 10이므로  \n    {value: 30, done: false}를 반환합니다.\n\n```js\nfunction* sports(one){  \n yield one;  \n 4. let check = 10;  \n}  \n1. let genObj = sports(10);  \n  \n2. console.log(genObj.next());  \n3. console.log(genObj.next());  \n//Object {value: 10, done: false}  \n//Object {value: undefined, done: true}  \n```\n\n1.  sports(10) 으로 호출하면 제너레이터 함수의 one 파라미터에 10이 설정되고  \n    제너레이터 오브젝트를 생성하여 반환합니다.\n\n2.  next()를 호출하면 함수 블록의 첫 줄부터 첫 번째 yield의 표현식까지 수행합니다. yield one; = {value: 10, done: false} 형태로 반환합니다.\n\n3.  next()를 호출하면 파라미터 값을 바로 앞 yield 왼쪽에 있는 변수에 할당합니다.  \n    그런데 왼쪽의 변수가 없으므로 값을 할당하지 않습니다.  \n    이후에 아래 코드를 실행합니다.\n\n4.  check에 10을 할당하는 코드이지만 더 이상 수행할 yield는 없고  \n    함수 안에 더 처리해야할 코드도 없습니다. 반환할 값이 없습니다.  \n    value 프로퍼티 값에 undefined를 설정하고, done 프로퍼티 값에 true를 설정합니다. {value: undefined, done: true} 형태로 반환됩니다.\n\n* * *\n\n<h2 id=\"next\">next(): yield 단위로 실행</h2>\n\n제너레이터 함수에서 yield 단위로 실행합니다.\n\nnext()를 호출하면 yield를 기준으로 이전 yield의 다음 줄부터 yield까지 수행합니다.\n\n제너레이터 함수에 yield가 여러개 작성되어 있으면, yield 수만큼 next()를 작성해줘야 제너레이터 함수 전체를 실행하게 됩니다.\n\n파라미터는 선택으로 제너레이터 함수가 멈춘 yield의 왼쪽 변수에 설정합니다.\n\n```js\nlet gen = function*(value){  \n value = value + 10;  \n yield ++value;  \n value = value + 7;  \n yield ++value;  \n};  \n1. let genObj = gen(1);  \n  \nconsole.log(genObj.next());  \nconsole.log(genObj.next());  \nconsole.log(genObj.next());  \n//Object {value: 12, done: false}  \n//Object {value: 20, done: false}  \n//Object {value: undefined, done: false}  \n```\n\n1.  gen(1)로 호출하면 제너레이터 함수의 value 파라미터에 1이 설정되며 제너레이터 오브젝트를 생성하여 반환합니다.\n\n2.  next()를 호출하면 제너레이터 함수 첫 줄부터 yield의 표현식까지 수행합니다.  \n    즉, 다음 코드를 실행합니다.  \n    value = value + 10;  \n    yield ++value;  \n    파라미터로 받은 1에 10을 더해 value에 할당합니다.  \n    다음으로 yield ++value;를 실행하여 value값에 1을 더합니다.  \n    {value: 12, done: false}가 반환됩니다.\n\n3.  다시 next()를 호출하면 yield ++value에서 yield 왼쪽에 파라미터 값을 설정합니다. 그런데 왼쪽에 변수가 없으므로 다음 코드를 실행합니다.  \n    value = value + 7;  \n    yield ++value;  \n    value 변수 값이 12이므로 7을 더해 19를 value에 할당합니다.  \n    다음으로 yield ++value;을 실행하여 {value: 20, done: false}를 반환합니다.\n\n4.  다시 next()를 호출하면 제너레이터 함수에 yield가 없으므로  \n    {value: undefined, done: false}를 반환합니다.\n\n* * *\n\n<h2 id=\"next_ex\">next() 활용 예제</h2>\n\n청구 금액과 할인 금액 계산하여 반환\n\n1.  청구 금액을 계싼하는 제너레이터 함수와 할인 금액을 계산하는 일반 함수를 정의합니다.\n    \n2.  청구 금액 계산 제너레이터 함수는 수량과 단가를 파라미터로 받아 금액을 계산합니다.\n    \n3.  계산한 금액을 yield로 반환합니다.\n    \n4.  할인 금액 함수를 호출하면서 yield로 반환된 값을 파라미터 값으로 넘겨 줍니다.\n    \n5.  파라미터의 금액에 따라 할인 금액을 계산하여 반환합니다.\n    \n6.  청구 금액 계산 제너레이터 함수를 호출하면서 할인 금액을 파라미터로 넘겨줍니다.\n    \n7.  합계 금액에서 할인 금액을 빼서 청구 금액을 계산합니다,\n    \n8.  계산된 청구 금액을 반환합니다.\n    \n\n```js next(), yield 활용 예제\n// 청구 금액을 계산하는 제너레이터 함수 getAmount  \n// 파라미터 qty = 수량 , price = 단가  \nlet getAmount = function*(qty, price){  \n// 함수가 처음 호출될 때 수량에 단가를 곱해 합계 금액을 구하고 소숫점은 버립니다.  \n let amount = Math.floor(qty * price);  \n// 두 번째 호출될 때 할인 금액(discount)을 받아   \n// 합계 금액에서 할인 금액을 빼서 반환합니다.  \n let discount = yield amount;  \n return amount - discount;  \n};  \n// 할인 금액을 구하는 함수 getDiscount  \n// 파라미터 값인 amount가 1000 보다 크면 0.2를 곱하고  \n// 아니면 0.1을 곱합니다.  \nlet getDiscount = function(amount){  \n return amount > 1000 ? amount * 0.2 : amount * 0.1;  \n};  \n// getAmount(10, 60)으로 호출하여 qty값 10 price값 60이 설정됩니다.  \n// 제너레이터 오브젝트를 생성하여 반환합니다.  \nlet amountObj = getAmount(10, 60);  \n// next()를 호출하여 제너레이터 함수를 실행시키고 반환된 결과를  \n// result 변수에 할당합니다.  \n /*  \n let amount = Math.floor(qty * price);  \n 10 * 60 = 600  \n amount에 600이 할당됩니다.  \n {value: 600, done: false} 반환  \n */  \nlet result = amountObj.next();  \nconsole.log(result);  \n//할인 금액을 구하는 함수  \n//앞의 next()에서 value:600을 반환했으므로 파라미터 값으로 600을 넘겨줍니다.  \n//호출된 dcAmount에서 60을 반환합니다.  \nlet dcAmount = getDiscount(result.value);  \nconsole.log(dcAmount);  \n//next(dcAmount)로 호출하여 파라미터 값 60을 넘겨줍니다  \n// let discount = yield amount 에서 60이 discount에 설정됩니다.  \n// 그리고 return amount - discount 를 실행하여  \n// {value: 540, done: true}를 반환합니다.  \nconsole.log(amountObj.next(dcAmount));  \n```\n\n* * *\n\n### next()의 다양한 형태\n\nnext()와 yield를 조합한 다양한 형태를 살펴 봅니다.  \n제너레이터 함수를 계속 호출 하려면 yield가 이에 대응할 수 있어야 합니다.  \n이를 위해 한 줄에 다수의 yield를 작성할 수도 있고,  \n배열 안에 다수의 yield를 작성할 수도 있습니다.\n\n```js next-while\nlet gen = function*(value) {  \n let count = 0;  \n while (value){  \n yield ++count;  \n }  \n};  \nlet genObj = gen(true);  \n  \n1. console.log(genObj.next());  \n2. console.log(genObj.next());  \n// Object {value: 1, done: false}  \n// Object {value: 2, done: false}  \n```\n\n제너레이터 함수에 while문을 작성하고 그 안에 yield를 작성한 형태입니다.\n\n1.  처음 next()를 호출하면 gen()함수의 첫 줄부터 yield까지 수행한 후 그 값을 반환합니다.  \n    (let count = 0;)는 처음 한 번만 실행되고 다음부터는 실행하지 않습니다.  \n    while(value){}에서 value 파라미터 값이 true이므로 블락을 실행합니다.  \n    yield ++count가 실행되어 {value: 1, done: false}를 반환합니다.\n\n2.  다시 next()를 호출하면 앞에서 증가된 count 변수 값이 유지되므로 값을 누적할 수 있습니다. yield ++count를 실행하여 {value: 2, done: false}를 반환합니다.  \n    이와 같이 while문 안에 yield를 작성하면 next()를 호출할 때마다 yield가 수행됩니다.\n\n```js next-return-yield\nlet gen = function*(){  \n return yield yield yield;  \n}  \nlet genObj = gen();  \n  \n1. console.log(genObj.next());  \n2. console.log(genObj.next(10));  \n  \n3. console.log(genObj.next(20));  \n4. console.log(genObj.next(30));  \n// Object {value: undefined, done: false}  \n// Object {value: 10, done: false}  \n// Object {value: 20, done: false}  \n// Object {value: 30, done: true}  \n```\n\n제너레이터 함수의 return 문에 다수의 yield를 작성한 형태입니다.  \nreturn 문의 표현식에 yield가 3개 작성되어 있습니다.\n\n1.  처음 next()를 호출하면 첫 번째 yield를 수행합니다.  \n    yield에 반환 값이 없으므로 {value: undefined, done: false}를 반환합니다.\n\n2.  두 번째로 next(10)을 호출하면 두 번째 yield를 수행합니다.  \n    왼쪽에 파라미터 값을 받을 변수가 없으므로 파라미터로 넘겨준 값 그대로 반환합니다. 따라서 {value: 10, done: false}를 반환합니다.\n\n3.  세 번째로 next(20)을 호출하면 세 번째 yield를 수행합니다.  \n    {value: 20, done: false}를 반환합니다.\n\n4.  마지막으로 next(30)을 호출하면 수행할 yield가 없습니다.  \n    {done: true}를 반환하고, return을 작성했으므로 파라미터로 넘겨준 값을  \n    반환 합니다. 즉 {value: 30, done: false}이 반환됩니다.  \n    return을 작성하지 않으면 {value: undefined, done: true}를 반환합니다.\n\n```js next-array-yield\nlet gen = function*(){  \n return [yield yield];  \n};  \nlet genObj = gen();  \n  \n1. console.log(genObj.next());  \n2. console.log(genObj.next(10));  \n3. console.log(genObj.next(20));  \n// Object {value: undefined, done: false}  \n// Object {value: 10, done: false}  \n// Object {value: Array[1], done: true}  \n```\n\n제너레이터 함수의 return 문에 배열안에 다수의 yield를 작성한 형태입니다.\n\n1.  2.  는 return문에 yield을 연속으로 작성한 것과 같습니다.  \n        yield가 2개 뿐이므로 더 이상 수행할 yield가 없는 상태가 됩니다.\n\n3.  마지막으로 next(20)을 호출하면 (return [yield yield])에서 yield를 제외한  \n    []안에 파라미터로 넘겨준 값을 작성합니다.  \n    {value: Array[1], done: true} 형태로 반환됩니다.  \n    Array[1]은 {0:20} 입니다.\n\n```js for-of-yield\nlet gen = function*(start){  \n let value = start;  \n while (true){  \n yield ++value;  \n }  \n};  \n  \nfor (var count of gen(10)){  \n console.log(count);  \n if (count > 12){  \n break;  \n }  \n};  \n// 11  \n// 12  \n// 13  \n```\n\nfor-of() 문에 제너레이터 함수를 호출하는 코드를 작성한 형태입니다.\n\n*   처음 for-of 문을 시작하면 gen(10)을 호출하여 제너레이터 함수의 start 파라미터에 10을 설정하고 제너레이터 오브젝트를 생성하여 반환합니다.  \n    호출한 gen(10) 위치로 돌아오면 반환받은 오브젝트를 할당할 변수가 없으므로 엔진 내부에 저장합니다.\n\n*   gen() 함수를 호출하며 이는 next()를 호출한 것과 같습니다.  \n    let value = start;를 수행한 후 while (true){yield ++value;}를 수행합니다.  \n    {value: 11, done:false}를 반환하게 되며 value 프로퍼티 값이 count 변수에 설정됩니다.\n\n*   for-of 문의 블록에 작성한 코드를 수행하며 콘솔에 11이 출력됩니다.  \n    count 변수 값이 11이므로 다시 for-of 문을 반복하게 됩니다.  \n    count 변수 값이 12보다 클때 까지 for-of문을 반복합니다.\n\n* * *\n\n<h2 id=\"throw\">throw(): Error 발생</h2>\n\nthrow() 메서드는 Generator의 실행을 재개시키고 Generator 함수의 실행 문맥 속으로 error를 주입합니다.\n\n제너레이터 함수를 호출하여 받은 제너레이터 오브젝트의 throw()를 호출하면  \n에러가 발생합니다. 에러가 발생하면 제너레이터 함수의 catch()문에서 에러를 받습니다.\n\n```js\nlet gen = function*(){  \n try {  \n yield 10;  \n } catch (message) {  \n yield message;  \n }  \n yield 20;  \n}  \nlet genObj = gen();  \n  \n1. console.log(genObj.next());  \n2. console.log(genObj.throw(\"에러 발생\"));  \n3. console.log(genObj.next());  \n// Object {value: 10, done: false}  \n// Object {value: \"에러 발생\", done: false}  \n// Object {value: 20, done: false}  \n```\n\n1.  next()를 호출하면 try문 의 (yield 10;)을 실행합니다.  \n    에러가 발생하지않으며 {value: 10, done: false}를 반환합니다.\n\n2.  throw(“에러 발생”)를 호출하면 제너레이터 함수의 catch(message)가 실행됩니다.  \n    throw()의 파라미터 값이 catch(message)의 message 파라미터에 설정됩니다.  \n    catch() 블록{}의 (yield message;)가 실행되어 {value: “에러 발생”, done: false}가 반환됩니다.  \n    중요한 점은 done: false를 반환한다는 점입니다. 즉, 에러는 발생했지만 다음에 next()를 호출할 수 있습니다.\n    *   genObj.throw(Error(“에러 발생”)); 과 같이 파라미터에 Error 오브젝트를 작성할 수도 있습니다.\n\n3.  앞에서 throw()를 호출하며 catch()블록을 수행했지만 이터레이터가 종료된 것은 아닙니다. 따라서 다시 next()를 호출할 수 있으며 함수의 (yield 20;)을 수행하여  \n    {value: 20, done: false}를 반환합니다.\n\n```js 제너레이터 함수에서 에러가 발생\nlet gen = function*(){  \n throw \"에러 발생\";  \n yield 20;  \n};  \nlet genObj = gen();  \n  \n1. try {  \n let result = genObj.next();  \n} catch (error) {  \n console.log(error);  \n}  \n2. console.log(genObj.next());  \n//에러 발생  \n// Object {value: undefined, done: true}  \n```\n\n1.  try문에서 next()를 호출하면 제너레이터 함수 첫 줄에서 throw문으로 인해 에러가 발생하며, catch(error)에서 에러를 받습니다.  \n    (throw “에러 발생”)에서 “에러 발생”이 catch(error)의 error 파라미터에 설정됩니다.\n\n2.  제너레이터 함수에서 에러가 발생하면 이터레이터가 종료됩니다.  \n    따라서 next()를 실행하면 제너레이터 함수내에 throw “에러 발생” 밑에  \n    yield 20;이 있지만 실행되지 않습니다.  \n    {value: undefined, done: true}가 반환됩니다.\n\n* * *\n\n<h2 id=\"yield*\">yield* 키워드</h2>\n\n> yield* [[expression]]\n\n표현식(expression)에 이터러블 오브젝트를 작성합니다. next()를 호출할 때 마다  \n이터러블 오브젝트를 하나씩 실행하며, 결과 값을 yield의 반환 값으로 사용합니다.\n\n표현식에 제너레이터 함수를 작성할 수 있습니다.  \n표현식으로 호출된 함수에 다수의 yield가 있으면 호출된 함수의 yield를 전부 처리한 후 yield* 아래에 작성한 코드를 실행합니다.\n\n```js yield* 표현식에 제너레이터 함수 작성 형태\nlet plusGen = function*(value) {  \n yield value + 5;  \n yield value + 10;  \n};  \nlet gen = function*(value) {  \n yield* plusGen(value);  \n yield value + 20;  \n};  \nlet genObj = gen(10);  \n\n1. console.log(\"1:\", genObj.next());  \n2. console.log(\"2:\", genObj.next());  \n3. console.log(\"3:\", genObj.next());  \n// Object {value: 15, done: false}  \n// Object {value: 20, done: false}  \n// Object {value: 30, done: false}  \n```\n\n1.  console.log로 genObj.next()를 호출하면 실행되는 순서가 다음과 같습니다.\n    \n    1.  gen() 함수의 yield* plusGen(value)을 실행합니다.\n        \n    2.  yield*를 작성했으므로 plusGen(value)을 호출하면서 파라미터 값으로 10을 넘겨줍니다.\n        \n    3.  plusGen()이 제너레이터 함수이므로 제너레이터 오브젝트를 생성하여 반환합니다.\n        \n    4.  next()로 호출헤야 plusGen() 함수의 yield를 수행하지만, 이때는 자동으로 plusGen()의 첫 번째 (yield value + 5)를 수행하며 {value: 15, done: false}를 반환합니다.\n        \n    5.  plusGen()을 호출한 곳에서 다시 yield를 수행하므로 plusGen()에서 반환된 값을 반환합니다.\n        \n    6.  콘솔에 Object {value: 15, done: false}를 출력합니다.\n        \n\n2.  next()를 호출하면 plusGen()에서 수행하지 않은 (yield value + 10;)을 실행하며 Object {value: 20, done: false}를 반환합니다.\n\n3.  next()를 호출하면 plusGen()에 더 이상 실행할 yield가 없으므로  \n    plusGen()을 호출한 gen() 함수 내의 코드 아래의 코드를 수행합니다.  \n    (yield value + 20;) 을 실행하게 되며 Object {value: 30, done: false}를 반환합니다.\n\n```js yield* 표현식 재귀 호출 형태\nlet gen = function*(value) {  \n yield value;  \n yield* gen(value + 10);  \n}  \nlet genObj = gen(1);  \n  \n1. console.log(genObj.next());  \n2. console.log(genObj.next());  \n3. console.log(genObj.next());  \n// Object {value: 1, done: false}  \n// Object {value: 11, done: false}  \n// Object {value: 21, done: false}  \n```\n\n1.  처음 next()를 호출하면 제너레이터 함수 첫째 줄의 (yield value;)를 실행하며  \n    {value: 1, done: false}를 반환합니다.\n\n2.  두 번째로 next()를 호출하면 (yield* gen(value + 10);)을 실행합니다.  \n    그런데 yield* 표현식에서 자신 함수(gen)를 호출합니다. 파라미터 값으로 11을 넘겨주며 next()가 없지만 엔진에서 반환받은 오브젝트의 제너레이터 함수를 호출합니다. (yield value;)가 실행되며 {value: 11, done: false}를 반환합니다.  \n    <mark>이때, yield value;가 없다면 계속해서 자신을 호출하게 되므로 무한 루프를 돌게됩니다.</mark>\n\n3.  세 번째로 next()를 호출하면 (yield* gen(value + 10);)을 실행하고  \n    자신을 호출합니다. 위와 같이 진행되어 {value: 21, done: false}를 반환합니다.\n","slug":"Generator 오브젝트 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrse000nqgvqenfidki6","content":"<hr>\n<p>함수를 호출하면 함수 블록의 코드를 한 번에 실행하지만,<br>제너레이터(Generator)오브젝트는 나누어서 실행할 수 있습니다.</p>\n<ul>\n<li>Generator<ul>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#function*_선언문\">function* 선언문</a></li>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#function*_표현식\">function* 표현식</a></li>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#GeneratorFunction\">GeneratorFunction():제너레이터 함수 생성</a></li>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#yield\">yield: 제너레이터 함수 실행,멈춤</a></li>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#next\">next():yield 단위로 실행</a></li>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#next_ex\">next() 활용 예제</a></li>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#throw\">throw(): Error 발생</a></li>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#yield*\">yield* 키워드</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<p>제너레이터 함수 작성 형식은 3가지가 있습니다.</p>\n<ol>\n<li><p>function* 선언문</p>\n</li>\n<li><p>function* 표현식</p>\n</li>\n<li><p>GeneratorFunction</p>\n</li>\n</ol>\n<p>function* 선언문과 표현식은 기존의 function과 형태가 같습니다,<br>“*”를 사용하는 형태만 다릅니다.<br>GeneratorFunction은 new Function()과 같으며<br>파라미터에 지정한 문자열로 제너레이터 함수를 생성하여 반환합니다.</p>\n<h3 id=\"중요-포인트\"><a href=\"#중요-포인트\" class=\"headerlink\" title=\"중요 포인트\"></a>중요 포인트</h3><p>제너레이터 함수를 호출하면 제너레이터 오브젝트를 생성하여 반환합니다.<br>function()을 호출하면 함수 블록을 실행하지만, 제너레이터 함수는 함수 블록을 실행하지 않고 제너레이터 오브젝트를 생성하여 반환합니다.<br>생성한 제너레이터 오브젝트에 호출한 함수에서 넘겨 준 파라미터 값이 설정됩니다.</p>\n<p><strong>생성된 제너레이터 오브젝트는 이터레이터 오브젝트입니다.</strong><br>이터레이터 오브젝트의 메서드를 호출했을 때 제너레이터 함수 블록을 실행합니다.<br>제너레이터 함수 블록에 yield 키워드를 작성하면 함수블록의 코드를 모두 실행하지 않고 yield 키워드 단위로 나누어 실행합니다.</p>\n<p>제너레이터 함수는 new 연산자를 사용할 수 없으며 사용시 TypeError가 발생합니다.</p>\n<hr>\n<h2 id=\"function*_선언문\">function* 선언문</h2>\n\n<p>선언문 형태로 제너레이터 함수를 정의합니다.</p>\n<blockquote>\n<p>function* name([param[, param[, … param]]]) {<br>statements<br>}</p>\n</blockquote>\n<ul>\n<li><p>name<br>함수명.</p>\n</li>\n<li><p>param<br>함수에 전달되는 인수의 이름. 함수는 인수를 255개까지 가질 수 있다.</p>\n</li>\n<li><p>statements<br>함수의 본체를 구성하는 구문들.</p>\n</li>\n<li><p>반환 값<br>Generator 객체를 반환합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">sports</span>(<span class=\"params\">one, two</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"함수 블록\"</span>);  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> one + two;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> sports);  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> genObj = sports(<span class=\"number\">1</span>, <span class=\"number\">2</span>);  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> genObj);  </span><br><span class=\"line\"><span class=\"comment\">// function  </span></span><br><span class=\"line\"><span class=\"comment\">// object</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>function* sports(one, two){} 형태를 제너레이터 선언문이라고 합니다.<br>처음 제너레이터 함수를 호출하면서 넘겨주는 파라미터 값이 sports()의 파라미터에 작성한 이름(one, two)에 설정됩니다.</p>\n</li>\n<li><p>console.log(typeof sprts) 제너레이터 함수의 typeof는 function입니다.</p>\n</li>\n<li><p>let genObj = sports(1,2)<br>sports(1,2)로 호출하면 sports 함수 블록을 수행하지 않고 제너레이터 오브젝트를 생성하여 반환합니다. 함수 블록을 수행하면 console.log(“함수 블록”)이 실행되어야 하는데 실행되지 않습니다.<br>sports(1,2)에서 넘겨 준 파라미터 값이 function* sports(one,two){}의 파라미터 one 과 two에 설정됩니다. 따라서 제너레이터 오브젝트를 사용하여 제너레이터 함수를 호출했을 때 추가 처리를 하지 않아도 파라미터 값을 사용할 수 있습니다.</p>\n</li>\n<li><p>생성된 제너레이터 오브젝트의 type 인 object가 출력됩니다.</p>\n</li>\n</ol>\n<p>Generator 설명<br>Generator는 빠져나갔다가 나중에 다시 돌아올 수 있는 함수입니다. 이때 컨텍스트(변수 값)는 출입 과정에서 저장된 상태로 남아 있습니다.</p>\n<p>Generator 함수는 호출되어도 즉시 실행되지 않고, 대신 함수를 위한 Iterator 객체가 반환됩니다. Iterator의 next() 메서드를 호출하면 Generator 함수가 실행되어 yield 문을 만날 때까지 진행하고, 해당 표현식이 명시하는 Iterator로부터의 반환값을 반환합니다. yield* 표현식을 마주칠 경우, 다른 Generator 함수가 위임(delegate)되어 진행됩니다.</p>\n<p>이후 next() 메서드가 호출되면 진행이 멈췄던 위치에서부터 재실행합니다. next() 가 반환하는 객체는 yield문이 반환할 값(yielded value)을 나타내는 value 속성과, Generator 함수 안의 모든 yield 문의 실행 여부를 표시하는 boolean 타입의 done 속성을 갖습니다. next() 를 인자값과 함께 호출할 경우, 진행을 멈췄던 위치의 yield 문을 next() 메서드에서 받은 인자값으로 치환하고 그 위치에서 다시 실행하게 됩니다.</p>\n<hr>\n<h2 id=\"function*_표현식\">function* 표현식</h2>\n\n<p>표현식 형태로 제너레이터 함수를 정의합니다.</p>\n<blockquote>\n<p>function* [name]([param1[, param2[, …, paramN]]]) {<br>statements<br>}</p>\n</blockquote>\n<ul>\n<li><p>name<br>함수명. 생략하면 익명 함수가 됩니다. 함수명은 함수내에만 한정됩니다.</p>\n</li>\n<li><p>paramN<br>함수에 전달되는 인수의 이름. 함수는 최대 255 개의 인수를 가질 수 있습니다.</p>\n</li>\n<li><p>statements<br>함수의 본체를 구성하는 구문들.</p>\n</li>\n<li><p>반환 값<br>Generator 객체</p>\n</li>\n<li><p>function* expression 은 function* statement 과 매우 유사하고 형식도 같습니다. function* expression 과 function* statement 의 주요한 차이점은 함수명으로, function* expressions 에서는 익명 함수로 만들기 위해 함수명이 생략될 수 있습니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>function* expression</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> sports = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">one, two</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"함수 블록\"</span>);  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> one + two;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> genObj = sports(<span class=\"number\">10</span>, <span class=\"number\">20</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">//함수 블록  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 30, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>function 이름이 없는 무명(혹은 익명) 함수입니다.<br>함수를 변수에 할당해 줌으로써 sports를 함수 이름으로 사용할 수 있습니다.<br>function_에 직접 함수 이름을 작성할 수 있지만, 외부에서 함수를 호출할 때는 sports()로 호출해야 합니다.<br>function_ 함수 이름은 함수 안에서 자신을 호출할 때 사용됩니다.(재귀 함수 호출)<br><del>하지만 변수에 할당하며 작성한 함수 이름으로 재귀 호출할 수 있으므로<br>function* 에 직접 함수이름을 작성하는 방법은 잘 사용하지 않습니다.<br>자바스크립트 초기 버전에서 사용했습니다.</del></p>\n</li>\n<li><p>sports(10, 20)으로 호출하여 제너레이터 오브젝트를 생성하고, 10을 파라미터 one에 설정하고 20을 two에 설정합니다.<br>이때, 함수 블록의 코드를 실행하지 않고 생성한 제너레이터 오브젝트를 반환합니다.</p>\n</li>\n<li><p>생성된 제너레이터 오브젝트는 이터레이터 오브젝트입니다. 제너레이터 오브젝트의 next()를 호출하면 이터레이터 오브젝트와 같은 처리를 수행합니다.<br>next()를 호출하여 sports 제너레이터 함수의 함수 블록을 수행합니다.</p>\n</li>\n<li><p>제너레이터 함수 블록의 코드 입니다.<br>console에 “함수 블록”을 출력합니다.<br>sports(10, 20)으로 호출했을 때, one과 two에 값을 설정했으므로<br>yield 키워드에서 파라미터 이름으로 값을 구할 수 있습니다.<br>yield 키워드는 yield 오른쪽의 표현식을 평가하고,<br>평가 결과를 {value: 30, done: false} 형태로 반환합니다.</p>\n</li>\n</ol>\n<hr>\n<p><strong>개발자 도구에서 sports 제너레이터 함수</strong> (== 크롬브라우저)</p>\n<img src=\"/images/sportsConsole.JPG\">\n\n<p>엔진이 function* 키워드를 만나면 제너레이터 함수 오브젝트를 생성하여<br>sports 변수에 할당 합니다.</p>\n<p>sports(10, 20)을 호출하면 sports.prototype에 연결된 프로퍼티로 제너레이터 오브젝트를 생성하여 반환합니다.</p>\n<p>&#95;&#95;proto&#95;&#95;.constructor는 생성자 함수로 이름이 GeneratorFunction입니다.</p>\n<p>반환된 제너레이터 오브젝트에<br>&#95;&#95;proto&#95;&#95;.&#95;&#95;proto&#95;&#95;에 next()가 있으므로<br>genObj.next()형태로 호출할 수 있습니다.</p>\n<hr>\n<h2 id=\"GeneratorFunction\">GeneratorFunction(): 제너레이터 함수 생성</h2>\n\n<p>제너레이터 함수를 생성하여 반환합니다.</p>\n<p>GeneratorFunction 생성자는 새로운 generator function 객체를 생성합니다. JavaScript 에서 모든 generator function 은 실제로 GeneratorFunction object 입니다.</p>\n<p>주의할 점은, GeneratorFunction 이 전역 객체(global object)가 아니란 점입니다. GeneratorFunction은 다음의 코드를 실행해서 얻을 수 있습니다.</p>\n<blockquote>\n<p>Object.getPrototypeOf(function*(){}).constructor</p>\n</blockquote>\n<p>new 연산자로 GeneratorFunction() 함수를 호출할 수 없습니다. 이름 없는 제너레이터 함수를 생성하고, 여기에 연결된 constructor를 사용하여 제너레이터 함수를 생성합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> GenConst = <span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;&#125;).constructor;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> sports = <span class=\"keyword\">new</span> GenConst(  </span><br><span class=\"line\"> <span class=\"string\">\"one\"</span>, <span class=\"string\">\"two\"</span>,  </span><br><span class=\"line\"> <span class=\"string\">\"console.log('함수 블록'); yield one + two\"</span>  </span><br><span class=\"line\">);  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> genObj = sports(<span class=\"number\">3</span>, <span class=\"number\">4</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// 함수 블록  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 7, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>제너레이터 함수를 생성하기 위한 생성자(constructor)를 구합니다.<br>function*(){}으로 익명 제너레이터 함수를 생성하여 Object.getPrototypeOf()의 파라미터 값으로 지정합니다. 익명 제너레이터 함수의 prototype 오브젝트가 반환됩니다. prototype에 constructor가 있으므로 이를 반환하고 GenConst에 할당합니다. (Genconst 변수가 생성자 함수가 되는 것 입니다.)</p>\n</li>\n<li><p>new 연산자로 GenConst 생성자를 호출하여 제너레이터 함수를 생성합니다.<br>(GenConst의 파라미터에 생성될 제너레이터 함수에서 사용할 파라미터와 함수 블록 코드를 문자열로 작성합니다.)<br>첫 번째 one 과 두 번째 two가 제너레이터 함수의 파라미터가 되고,<br>세 번째 파라미터가 함수 블록 코드가 됩니다.</p>\n</li>\n</ol>\n<p>파라미터의 문자열을 parsing(문자열 해석?)하면 다음과 같은 형태가 되는 것입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>new GenConst parsing</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">one,two</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'함수 블록'</span>);  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> one + two  </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>sports(3,4)로 호출하면 제너레이터 오브젝트를 생성하여 반환합니다.<br>function*(one, two){}에서 3이 one에 4가 two에 설정됩니다.</p>\n</li>\n<li><p>next()를 호출하면 함수 블록 코드를 실행합니다.<br>Object {value: 7, done: false}를 반환합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"yield\">yield: 제너레이터 함수 실행, 멈춤</h2>\n\n<p>yield 키워드는 제너레이터 함수를 멈추게 하거나 다시 실행하는데 사용됩니다.</p>\n<blockquote>\n<p>[returnValue] = yield [expression];</p>\n</blockquote>\n<ul>\n<li><p>expression<br>제너레이터 함수에서 제너레이터 프로토콜을 통해 반환할 값을 정의합니다(표현식). 값이 생략되면, undefined를 반환합니다.</p>\n</li>\n<li><p>returnValue<br>제너레이터 실행을 재개 하기 위해서, optional value을 제너레이터의 next() 메서드로 전달하여 반환합니다.</p>\n</li>\n<li><p>yield의 표현식 평가 결과를 왼쪽의 returnValue에 할당하지 않습니다.<br>제너레이터 오브젝트의 next()를 호출하면 next() 파라미터 값이 returnValue에 할당됩니다.</p>\n</li>\n<li><p>next()로 제너레이터 함수를 호출하면 yield 작성에 관계없이 “{value: 값, done: false/true}” 형태로 반환합니다.</p>\n</li>\n<li><p>yield를 수행하면 표현식 평가 결과가 value 값에 설정되고, yield를 수행하지 못하면 undefined가 설정됩니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">sports</span>(<span class=\"params\">one</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> two = <span class=\"keyword\">yield</span> one;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> param = <span class=\"keyword\">yield</span> two + one;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> param + one;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> generatorObj = sports(<span class=\"number\">10</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(generatorObj.next());  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(generatorObj.next());  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(generatorObj.next(<span class=\"number\">20</span>));  </span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: 10, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: NaN, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: 30, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>sports(10)으로 호출하여 제너레이터 함수의 one 파라미터에 10이 설정되고<br>제너레이터 오브젝트를 생성하여 반환합니다. (함수 블록의 코드는 실행하지 않습니다.)</p>\n</li>\n<li><p>generatorObj.next()를 호출하면 sports 제너레이터 함수 블록의 첫 줄부터 첫 번째 yield까지 수행합니다. == (let two = yield one;)<br>yield의 표현식 평과 결과 {value: 10, done: false}형태를 반환합니다.<br>할당연산자(=)는 오른쪽 값을 왼쪽 변수에 할당하지만, yield 의 할당연산자(=)는 할당하지 않습니다.</p>\n</li>\n<li><p>next()를 다시한번 호출하면 파라미터 값을 (let two = yield one)에서 two 변수에 설정합니다. 파라미터 값이 지정되지 않았으며 undefined가 two 변수에 설정됩니다. 그리고 아래 코드를 실행합니다.<br>two 변수에 undefined가 설정되어 있고, one 변수에 10이 설정되어 있으므로<br>Object {value: NaN, done: false}를 반환합니다. NaN을 param 변수에 설정하지 않습니다.</p>\n</li>\n<li><p>next(20)으로 호출하면 파라미터 값 20을 (let param = yield two + one)에서 param 변수에 설정합니다. param 변수 값이 20이고 one 변수 값이 10이므로<br>{value: 30, done: false}를 반환합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">sports</span>(<span class=\"params\">one</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> one;  </span><br><span class=\"line\"> <span class=\"number\">4.</span> <span class=\"keyword\">let</span> check = <span class=\"number\">10</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> genObj = sports(<span class=\"number\">10</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: 10, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>sports(10) 으로 호출하면 제너레이터 함수의 one 파라미터에 10이 설정되고<br>제너레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>next()를 호출하면 함수 블록의 첫 줄부터 첫 번째 yield의 표현식까지 수행합니다. yield one; = {value: 10, done: false} 형태로 반환합니다.</p>\n</li>\n<li><p>next()를 호출하면 파라미터 값을 바로 앞 yield 왼쪽에 있는 변수에 할당합니다.<br>그런데 왼쪽의 변수가 없으므로 값을 할당하지 않습니다.<br>이후에 아래 코드를 실행합니다.</p>\n</li>\n<li><p>check에 10을 할당하는 코드이지만 더 이상 수행할 yield는 없고<br>함수 안에 더 처리해야할 코드도 없습니다. 반환할 값이 없습니다.<br>value 프로퍼티 값에 undefined를 설정하고, done 프로퍼티 값에 true를 설정합니다. {value: undefined, done: true} 형태로 반환됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"next\">next(): yield 단위로 실행</h2>\n\n<p>제너레이터 함수에서 yield 단위로 실행합니다.</p>\n<p>next()를 호출하면 yield를 기준으로 이전 yield의 다음 줄부터 yield까지 수행합니다.</p>\n<p>제너레이터 함수에 yield가 여러개 작성되어 있으면, yield 수만큼 next()를 작성해줘야 제너레이터 함수 전체를 실행하게 됩니다.</p>\n<p>파라미터는 선택으로 제너레이터 함수가 멈춘 yield의 왼쪽 변수에 설정합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">value</span>)</span>&#123;  </span><br><span class=\"line\"> value = value + <span class=\"number\">10</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> ++value;  </span><br><span class=\"line\"> value = value + <span class=\"number\">7</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> ++value;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> genObj = gen(<span class=\"number\">1</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: 12, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: 20, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: undefined, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>gen(1)로 호출하면 제너레이터 함수의 value 파라미터에 1이 설정되며 제너레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>next()를 호출하면 제너레이터 함수 첫 줄부터 yield의 표현식까지 수행합니다.<br>즉, 다음 코드를 실행합니다.<br>value = value + 10;<br>yield ++value;<br>파라미터로 받은 1에 10을 더해 value에 할당합니다.<br>다음으로 yield ++value;를 실행하여 value값에 1을 더합니다.<br>{value: 12, done: false}가 반환됩니다.</p>\n</li>\n<li><p>다시 next()를 호출하면 yield ++value에서 yield 왼쪽에 파라미터 값을 설정합니다. 그런데 왼쪽에 변수가 없으므로 다음 코드를 실행합니다.<br>value = value + 7;<br>yield ++value;<br>value 변수 값이 12이므로 7을 더해 19를 value에 할당합니다.<br>다음으로 yield ++value;을 실행하여 {value: 20, done: false}를 반환합니다.</p>\n</li>\n<li><p>다시 next()를 호출하면 제너레이터 함수에 yield가 없으므로<br>{value: undefined, done: false}를 반환합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"next_ex\">next() 활용 예제</h2>\n\n<p>청구 금액과 할인 금액 계산하여 반환</p>\n<ol>\n<li><p>청구 금액을 계싼하는 제너레이터 함수와 할인 금액을 계산하는 일반 함수를 정의합니다.</p>\n</li>\n<li><p>청구 금액 계산 제너레이터 함수는 수량과 단가를 파라미터로 받아 금액을 계산합니다.</p>\n</li>\n<li><p>계산한 금액을 yield로 반환합니다.</p>\n</li>\n<li><p>할인 금액 함수를 호출하면서 yield로 반환된 값을 파라미터 값으로 넘겨 줍니다.</p>\n</li>\n<li><p>파라미터의 금액에 따라 할인 금액을 계산하여 반환합니다.</p>\n</li>\n<li><p>청구 금액 계산 제너레이터 함수를 호출하면서 할인 금액을 파라미터로 넘겨줍니다.</p>\n</li>\n<li><p>합계 금액에서 할인 금액을 빼서 청구 금액을 계산합니다,</p>\n</li>\n<li><p>계산된 청구 금액을 반환합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>next(), yield 활용 예제</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 청구 금액을 계산하는 제너레이터 함수 getAmount  </span></span><br><span class=\"line\"><span class=\"comment\">// 파라미터 qty = 수량 , price = 단가  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> getAmount = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">qty, price</span>)</span>&#123;  </span><br><span class=\"line\"><span class=\"comment\">// 함수가 처음 호출될 때 수량에 단가를 곱해 합계 금액을 구하고 소숫점은 버립니다.  </span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> amount = <span class=\"built_in\">Math</span>.floor(qty * price);  </span><br><span class=\"line\"><span class=\"comment\">// 두 번째 호출될 때 할인 금액(discount)을 받아   </span></span><br><span class=\"line\"><span class=\"comment\">// 합계 금액에서 할인 금액을 빼서 반환합니다.  </span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> discount = <span class=\"keyword\">yield</span> amount;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> amount - discount;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// 할인 금액을 구하는 함수 getDiscount  </span></span><br><span class=\"line\"><span class=\"comment\">// 파라미터 값인 amount가 1000 보다 크면 0.2를 곱하고  </span></span><br><span class=\"line\"><span class=\"comment\">// 아니면 0.1을 곱합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> getDiscount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">amount</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> amount &gt; <span class=\"number\">1000</span> ? amount * <span class=\"number\">0.2</span> : amount * <span class=\"number\">0.1</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// getAmount(10, 60)으로 호출하여 qty값 10 price값 60이 설정됩니다.  </span></span><br><span class=\"line\"><span class=\"comment\">// 제너레이터 오브젝트를 생성하여 반환합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> amountObj = getAmount(<span class=\"number\">10</span>, <span class=\"number\">60</span>);  </span><br><span class=\"line\"><span class=\"comment\">// next()를 호출하여 제너레이터 함수를 실행시키고 반환된 결과를  </span></span><br><span class=\"line\"><span class=\"comment\">// result 변수에 할당합니다.  </span></span><br><span class=\"line\"> <span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\"> let amount = Math.floor(qty * price);  </span></span><br><span class=\"line\"><span class=\"comment\"> 10 * 60 = 600  </span></span><br><span class=\"line\"><span class=\"comment\"> amount에 600이 할당됩니다.  </span></span><br><span class=\"line\"><span class=\"comment\"> &#123;value: 600, done: false&#125; 반환  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = amountObj.next();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\"><span class=\"comment\">//할인 금액을 구하는 함수  </span></span><br><span class=\"line\"><span class=\"comment\">//앞의 next()에서 value:600을 반환했으므로 파라미터 값으로 600을 넘겨줍니다.  </span></span><br><span class=\"line\"><span class=\"comment\">//호출된 dcAmount에서 60을 반환합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dcAmount = getDiscount(result.value);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dcAmount);  </span><br><span class=\"line\"><span class=\"comment\">//next(dcAmount)로 호출하여 파라미터 값 60을 넘겨줍니다  </span></span><br><span class=\"line\"><span class=\"comment\">// let discount = yield amount 에서 60이 discount에 설정됩니다.  </span></span><br><span class=\"line\"><span class=\"comment\">// 그리고 return amount - discount 를 실행하여  </span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 540, done: true&#125;를 반환합니다.  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(amountObj.next(dcAmount));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"next-의-다양한-형태\"><a href=\"#next-의-다양한-형태\" class=\"headerlink\" title=\"next()의 다양한 형태\"></a>next()의 다양한 형태</h3><p>next()와 yield를 조합한 다양한 형태를 살펴 봅니다.<br>제너레이터 함수를 계속 호출 하려면 yield가 이에 대응할 수 있어야 합니다.<br>이를 위해 한 줄에 다수의 yield를 작성할 수도 있고,<br>배열 안에 다수의 yield를 작성할 수도 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>next-while</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">value</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">while</span> (value)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> ++count;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = gen(<span class=\"literal\">true</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 1, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 2, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>제너레이터 함수에 while문을 작성하고 그 안에 yield를 작성한 형태입니다.</p>\n<ol>\n<li><p>처음 next()를 호출하면 gen()함수의 첫 줄부터 yield까지 수행한 후 그 값을 반환합니다.<br>(let count = 0;)는 처음 한 번만 실행되고 다음부터는 실행하지 않습니다.<br>while(value){}에서 value 파라미터 값이 true이므로 블락을 실행합니다.<br>yield ++count가 실행되어 {value: 1, done: false}를 반환합니다.</p>\n</li>\n<li><p>다시 next()를 호출하면 앞에서 증가된 count 변수 값이 유지되므로 값을 누적할 수 있습니다. yield ++count를 실행하여 {value: 2, done: false}를 반환합니다.<br>이와 같이 while문 안에 yield를 작성하면 next()를 호출할 때마다 yield가 수행됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>next-return-yield</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">yield</span> <span class=\"keyword\">yield</span> <span class=\"keyword\">yield</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = gen();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(genObj.next(<span class=\"number\">10</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(genObj.next(<span class=\"number\">20</span>));  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(genObj.next(<span class=\"number\">30</span>));  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: undefined, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 10, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 20, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 30, done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>제너레이터 함수의 return 문에 다수의 yield를 작성한 형태입니다.<br>return 문의 표현식에 yield가 3개 작성되어 있습니다.</p>\n<ol>\n<li><p>처음 next()를 호출하면 첫 번째 yield를 수행합니다.<br>yield에 반환 값이 없으므로 {value: undefined, done: false}를 반환합니다.</p>\n</li>\n<li><p>두 번째로 next(10)을 호출하면 두 번째 yield를 수행합니다.<br>왼쪽에 파라미터 값을 받을 변수가 없으므로 파라미터로 넘겨준 값 그대로 반환합니다. 따라서 {value: 10, done: false}를 반환합니다.</p>\n</li>\n<li><p>세 번째로 next(20)을 호출하면 세 번째 yield를 수행합니다.<br>{value: 20, done: false}를 반환합니다.</p>\n</li>\n<li><p>마지막으로 next(30)을 호출하면 수행할 yield가 없습니다.<br>{done: true}를 반환하고, return을 작성했으므로 파라미터로 넘겨준 값을<br>반환 합니다. 즉 {value: 30, done: false}이 반환됩니다.<br>return을 작성하지 않으면 {value: undefined, done: true}를 반환합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>next-array-yield</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> [<span class=\"keyword\">yield</span> <span class=\"keyword\">yield</span>];  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = gen();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(genObj.next(<span class=\"number\">10</span>));  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(genObj.next(<span class=\"number\">20</span>));  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: undefined, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 10, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Array[1], done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>제너레이터 함수의 return 문에 배열안에 다수의 yield를 작성한 형태입니다.</p>\n<ol>\n<li><ol start=\"2\">\n<li>는 return문에 yield을 연속으로 작성한 것과 같습니다.<br>yield가 2개 뿐이므로 더 이상 수행할 yield가 없는 상태가 됩니다.</li>\n</ol>\n</li>\n<li><p>마지막으로 next(20)을 호출하면 (return [yield yield])에서 yield를 제외한<br>[]안에 파라미터로 넘겨준 값을 작성합니다.<br>{value: Array[1], done: true} 형태로 반환됩니다.<br>Array[1]은 {0:20} 입니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>for-of-yield</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">start</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> value = start;  </span><br><span class=\"line\"> <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> ++value;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> count <span class=\"keyword\">of</span> gen(<span class=\"number\">10</span>))&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(count);  </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">12</span>)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// 11  </span></span><br><span class=\"line\"><span class=\"comment\">// 12  </span></span><br><span class=\"line\"><span class=\"comment\">// 13</span></span><br></pre></td></tr></table></figure>\n\n<p>for-of() 문에 제너레이터 함수를 호출하는 코드를 작성한 형태입니다.</p>\n<ul>\n<li><p>처음 for-of 문을 시작하면 gen(10)을 호출하여 제너레이터 함수의 start 파라미터에 10을 설정하고 제너레이터 오브젝트를 생성하여 반환합니다.<br>호출한 gen(10) 위치로 돌아오면 반환받은 오브젝트를 할당할 변수가 없으므로 엔진 내부에 저장합니다.</p>\n</li>\n<li><p>gen() 함수를 호출하며 이는 next()를 호출한 것과 같습니다.<br>let value = start;를 수행한 후 while (true){yield ++value;}를 수행합니다.<br>{value: 11, done:false}를 반환하게 되며 value 프로퍼티 값이 count 변수에 설정됩니다.</p>\n</li>\n<li><p>for-of 문의 블록에 작성한 코드를 수행하며 콘솔에 11이 출력됩니다.<br>count 변수 값이 11이므로 다시 for-of 문을 반복하게 됩니다.<br>count 변수 값이 12보다 클때 까지 for-of문을 반복합니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"throw\">throw(): Error 발생</h2>\n\n<p>throw() 메서드는 Generator의 실행을 재개시키고 Generator 함수의 실행 문맥 속으로 error를 주입합니다.</p>\n<p>제너레이터 함수를 호출하여 받은 제너레이터 오브젝트의 throw()를 호출하면<br>에러가 발생합니다. 에러가 발생하면 제너레이터 함수의 catch()문에서 에러를 받습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">10</span>;  </span><br><span class=\"line\"> &#125; <span class=\"keyword\">catch</span> (message) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> message;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">20</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = gen();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(genObj.throw(<span class=\"string\">\"에러 발생\"</span>));  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 10, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"에러 발생\", done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 20, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>next()를 호출하면 try문 의 (yield 10;)을 실행합니다.<br>에러가 발생하지않으며 {value: 10, done: false}를 반환합니다.</p>\n</li>\n<li><p>throw(“에러 발생”)를 호출하면 제너레이터 함수의 catch(message)가 실행됩니다.<br>throw()의 파라미터 값이 catch(message)의 message 파라미터에 설정됩니다.<br>catch() 블록{}의 (yield message;)가 실행되어 {value: “에러 발생”, done: false}가 반환됩니다.<br>중요한 점은 done: false를 반환한다는 점입니다. 즉, 에러는 발생했지만 다음에 next()를 호출할 수 있습니다.</p>\n<ul>\n<li>genObj.throw(Error(“에러 발생”)); 과 같이 파라미터에 Error 오브젝트를 작성할 수도 있습니다.</li>\n</ul>\n</li>\n<li><p>앞에서 throw()를 호출하며 catch()블록을 수행했지만 이터레이터가 종료된 것은 아닙니다. 따라서 다시 next()를 호출할 수 있으며 함수의 (yield 20;)을 수행하여<br>{value: 20, done: false}를 반환합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>제너레이터 함수에서 에러가 발생</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">throw</span> <span class=\"string\">\"에러 발생\"</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">20</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = gen();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> result = genObj.next();  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (error) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(error);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">//에러 발생  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>try문에서 next()를 호출하면 제너레이터 함수 첫 줄에서 throw문으로 인해 에러가 발생하며, catch(error)에서 에러를 받습니다.<br>(throw “에러 발생”)에서 “에러 발생”이 catch(error)의 error 파라미터에 설정됩니다.</p>\n</li>\n<li><p>제너레이터 함수에서 에러가 발생하면 이터레이터가 종료됩니다.<br>따라서 next()를 실행하면 제너레이터 함수내에 throw “에러 발생” 밑에<br>yield 20;이 있지만 실행되지 않습니다.<br>{value: undefined, done: true}가 반환됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"yield*\">yield* 키워드</h2>\n\n<blockquote>\n<p>yield* [[expression]]</p>\n</blockquote>\n<p>표현식(expression)에 이터러블 오브젝트를 작성합니다. next()를 호출할 때 마다<br>이터러블 오브젝트를 하나씩 실행하며, 결과 값을 yield의 반환 값으로 사용합니다.</p>\n<p>표현식에 제너레이터 함수를 작성할 수 있습니다.<br>표현식으로 호출된 함수에 다수의 yield가 있으면 호출된 함수의 yield를 전부 처리한 후 yield* 아래에 작성한 코드를 실행합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>yield* 표현식에 제너레이터 함수 작성 형태</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> plusGen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">value</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> value + <span class=\"number\">5</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> value + <span class=\"number\">10</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">value</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span>* plusGen(value);  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> value + <span class=\"number\">20</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = gen(<span class=\"number\">10</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, genObj.next());  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, genObj.next());  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 15, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 20, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 30, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>console.log로 genObj.next()를 호출하면 실행되는 순서가 다음과 같습니다.</p>\n<ol>\n<li><p>gen() 함수의 yield* plusGen(value)을 실행합니다.</p>\n</li>\n<li><p>yield*를 작성했으므로 plusGen(value)을 호출하면서 파라미터 값으로 10을 넘겨줍니다.</p>\n</li>\n<li><p>plusGen()이 제너레이터 함수이므로 제너레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>next()로 호출헤야 plusGen() 함수의 yield를 수행하지만, 이때는 자동으로 plusGen()의 첫 번째 (yield value + 5)를 수행하며 {value: 15, done: false}를 반환합니다.</p>\n</li>\n<li><p>plusGen()을 호출한 곳에서 다시 yield를 수행하므로 plusGen()에서 반환된 값을 반환합니다.</p>\n</li>\n<li><p>콘솔에 Object {value: 15, done: false}를 출력합니다.</p>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>next()를 호출하면 plusGen()에서 수행하지 않은 (yield value + 10;)을 실행하며 Object {value: 20, done: false}를 반환합니다.</p>\n</li>\n<li><p>next()를 호출하면 plusGen()에 더 이상 실행할 yield가 없으므로<br>plusGen()을 호출한 gen() 함수 내의 코드 아래의 코드를 수행합니다.<br>(yield value + 20;) 을 실행하게 되며 Object {value: 30, done: false}를 반환합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>yield* 표현식 재귀 호출 형태</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">value</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> value;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span>* gen(value + <span class=\"number\">10</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = gen(<span class=\"number\">1</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 1, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 11, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 21, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>처음 next()를 호출하면 제너레이터 함수 첫째 줄의 (yield value;)를 실행하며<br>{value: 1, done: false}를 반환합니다.</p>\n</li>\n<li><p>두 번째로 next()를 호출하면 (yield* gen(value + 10);)을 실행합니다.<br>그런데 yield* 표현식에서 자신 함수(gen)를 호출합니다. 파라미터 값으로 11을 넘겨주며 next()가 없지만 엔진에서 반환받은 오브젝트의 제너레이터 함수를 호출합니다. (yield value;)가 실행되며 {value: 11, done: false}를 반환합니다.<br><mark>이때, yield value;가 없다면 계속해서 자신을 호출하게 되므로 무한 루프를 돌게됩니다.</mark></p>\n</li>\n<li><p>세 번째로 next()를 호출하면 (yield* gen(value + 10);)을 실행하고<br>자신을 호출합니다. 위와 같이 진행되어 {value: 21, done: false}를 반환합니다.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<hr>\n<p>함수를 호출하면 함수 블록의 코드를 한 번에 실행하지만,<br>제너레이터(Generator)오브젝트는 나누어서 실행할 수 있습니다.</p>\n<ul>\n<li>Generator<ul>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#function*_선언문\">function* 선언문</a></li>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#function*_표현식\">function* 표현식</a></li>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#GeneratorFunction\">GeneratorFunction():제너레이터 함수 생성</a></li>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#yield\">yield: 제너레이터 함수 실행,멈춤</a></li>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#next\">next():yield 단위로 실행</a></li>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#next_ex\">next() 활용 예제</a></li>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#throw\">throw(): Error 발생</a></li>\n<li><a href=\"/2020/03/31/Generator%20오브젝트%20-ECMAScript/#yield*\">yield* 키워드</a></li>\n</ul>\n</li>\n</ul>","more":"<p>제너레이터 함수 작성 형식은 3가지가 있습니다.</p>\n<ol>\n<li><p>function* 선언문</p>\n</li>\n<li><p>function* 표현식</p>\n</li>\n<li><p>GeneratorFunction</p>\n</li>\n</ol>\n<p>function* 선언문과 표현식은 기존의 function과 형태가 같습니다,<br>“*”를 사용하는 형태만 다릅니다.<br>GeneratorFunction은 new Function()과 같으며<br>파라미터에 지정한 문자열로 제너레이터 함수를 생성하여 반환합니다.</p>\n<h3 id=\"중요-포인트\"><a href=\"#중요-포인트\" class=\"headerlink\" title=\"중요 포인트\"></a>중요 포인트</h3><p>제너레이터 함수를 호출하면 제너레이터 오브젝트를 생성하여 반환합니다.<br>function()을 호출하면 함수 블록을 실행하지만, 제너레이터 함수는 함수 블록을 실행하지 않고 제너레이터 오브젝트를 생성하여 반환합니다.<br>생성한 제너레이터 오브젝트에 호출한 함수에서 넘겨 준 파라미터 값이 설정됩니다.</p>\n<p><strong>생성된 제너레이터 오브젝트는 이터레이터 오브젝트입니다.</strong><br>이터레이터 오브젝트의 메서드를 호출했을 때 제너레이터 함수 블록을 실행합니다.<br>제너레이터 함수 블록에 yield 키워드를 작성하면 함수블록의 코드를 모두 실행하지 않고 yield 키워드 단위로 나누어 실행합니다.</p>\n<p>제너레이터 함수는 new 연산자를 사용할 수 없으며 사용시 TypeError가 발생합니다.</p>\n<hr>\n<h2 id=\"function*_선언문\">function* 선언문</h2>\n\n<p>선언문 형태로 제너레이터 함수를 정의합니다.</p>\n<blockquote>\n<p>function* name([param[, param[, … param]]]) {<br>statements<br>}</p>\n</blockquote>\n<ul>\n<li><p>name<br>함수명.</p>\n</li>\n<li><p>param<br>함수에 전달되는 인수의 이름. 함수는 인수를 255개까지 가질 수 있다.</p>\n</li>\n<li><p>statements<br>함수의 본체를 구성하는 구문들.</p>\n</li>\n<li><p>반환 값<br>Generator 객체를 반환합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">sports</span>(<span class=\"params\">one, two</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"함수 블록\"</span>);  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> one + two;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> sports);  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> genObj = sports(<span class=\"number\">1</span>, <span class=\"number\">2</span>);  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> genObj);  </span><br><span class=\"line\"><span class=\"comment\">// function  </span></span><br><span class=\"line\"><span class=\"comment\">// object</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>function* sports(one, two){} 형태를 제너레이터 선언문이라고 합니다.<br>처음 제너레이터 함수를 호출하면서 넘겨주는 파라미터 값이 sports()의 파라미터에 작성한 이름(one, two)에 설정됩니다.</p>\n</li>\n<li><p>console.log(typeof sprts) 제너레이터 함수의 typeof는 function입니다.</p>\n</li>\n<li><p>let genObj = sports(1,2)<br>sports(1,2)로 호출하면 sports 함수 블록을 수행하지 않고 제너레이터 오브젝트를 생성하여 반환합니다. 함수 블록을 수행하면 console.log(“함수 블록”)이 실행되어야 하는데 실행되지 않습니다.<br>sports(1,2)에서 넘겨 준 파라미터 값이 function* sports(one,two){}의 파라미터 one 과 two에 설정됩니다. 따라서 제너레이터 오브젝트를 사용하여 제너레이터 함수를 호출했을 때 추가 처리를 하지 않아도 파라미터 값을 사용할 수 있습니다.</p>\n</li>\n<li><p>생성된 제너레이터 오브젝트의 type 인 object가 출력됩니다.</p>\n</li>\n</ol>\n<p>Generator 설명<br>Generator는 빠져나갔다가 나중에 다시 돌아올 수 있는 함수입니다. 이때 컨텍스트(변수 값)는 출입 과정에서 저장된 상태로 남아 있습니다.</p>\n<p>Generator 함수는 호출되어도 즉시 실행되지 않고, 대신 함수를 위한 Iterator 객체가 반환됩니다. Iterator의 next() 메서드를 호출하면 Generator 함수가 실행되어 yield 문을 만날 때까지 진행하고, 해당 표현식이 명시하는 Iterator로부터의 반환값을 반환합니다. yield* 표현식을 마주칠 경우, 다른 Generator 함수가 위임(delegate)되어 진행됩니다.</p>\n<p>이후 next() 메서드가 호출되면 진행이 멈췄던 위치에서부터 재실행합니다. next() 가 반환하는 객체는 yield문이 반환할 값(yielded value)을 나타내는 value 속성과, Generator 함수 안의 모든 yield 문의 실행 여부를 표시하는 boolean 타입의 done 속성을 갖습니다. next() 를 인자값과 함께 호출할 경우, 진행을 멈췄던 위치의 yield 문을 next() 메서드에서 받은 인자값으로 치환하고 그 위치에서 다시 실행하게 됩니다.</p>\n<hr>\n<h2 id=\"function*_표현식\">function* 표현식</h2>\n\n<p>표현식 형태로 제너레이터 함수를 정의합니다.</p>\n<blockquote>\n<p>function* [name]([param1[, param2[, …, paramN]]]) {<br>statements<br>}</p>\n</blockquote>\n<ul>\n<li><p>name<br>함수명. 생략하면 익명 함수가 됩니다. 함수명은 함수내에만 한정됩니다.</p>\n</li>\n<li><p>paramN<br>함수에 전달되는 인수의 이름. 함수는 최대 255 개의 인수를 가질 수 있습니다.</p>\n</li>\n<li><p>statements<br>함수의 본체를 구성하는 구문들.</p>\n</li>\n<li><p>반환 값<br>Generator 객체</p>\n</li>\n<li><p>function* expression 은 function* statement 과 매우 유사하고 형식도 같습니다. function* expression 과 function* statement 의 주요한 차이점은 함수명으로, function* expressions 에서는 익명 함수로 만들기 위해 함수명이 생략될 수 있습니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>function* expression</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> sports = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">one, two</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"함수 블록\"</span>);  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> one + two;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> genObj = sports(<span class=\"number\">10</span>, <span class=\"number\">20</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">//함수 블록  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 30, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>function 이름이 없는 무명(혹은 익명) 함수입니다.<br>함수를 변수에 할당해 줌으로써 sports를 함수 이름으로 사용할 수 있습니다.<br>function_에 직접 함수 이름을 작성할 수 있지만, 외부에서 함수를 호출할 때는 sports()로 호출해야 합니다.<br>function_ 함수 이름은 함수 안에서 자신을 호출할 때 사용됩니다.(재귀 함수 호출)<br><del>하지만 변수에 할당하며 작성한 함수 이름으로 재귀 호출할 수 있으므로<br>function* 에 직접 함수이름을 작성하는 방법은 잘 사용하지 않습니다.<br>자바스크립트 초기 버전에서 사용했습니다.</del></p>\n</li>\n<li><p>sports(10, 20)으로 호출하여 제너레이터 오브젝트를 생성하고, 10을 파라미터 one에 설정하고 20을 two에 설정합니다.<br>이때, 함수 블록의 코드를 실행하지 않고 생성한 제너레이터 오브젝트를 반환합니다.</p>\n</li>\n<li><p>생성된 제너레이터 오브젝트는 이터레이터 오브젝트입니다. 제너레이터 오브젝트의 next()를 호출하면 이터레이터 오브젝트와 같은 처리를 수행합니다.<br>next()를 호출하여 sports 제너레이터 함수의 함수 블록을 수행합니다.</p>\n</li>\n<li><p>제너레이터 함수 블록의 코드 입니다.<br>console에 “함수 블록”을 출력합니다.<br>sports(10, 20)으로 호출했을 때, one과 two에 값을 설정했으므로<br>yield 키워드에서 파라미터 이름으로 값을 구할 수 있습니다.<br>yield 키워드는 yield 오른쪽의 표현식을 평가하고,<br>평가 결과를 {value: 30, done: false} 형태로 반환합니다.</p>\n</li>\n</ol>\n<hr>\n<p><strong>개발자 도구에서 sports 제너레이터 함수</strong> (== 크롬브라우저)</p>\n<img src=\"/images/sportsConsole.JPG\">\n\n<p>엔진이 function* 키워드를 만나면 제너레이터 함수 오브젝트를 생성하여<br>sports 변수에 할당 합니다.</p>\n<p>sports(10, 20)을 호출하면 sports.prototype에 연결된 프로퍼티로 제너레이터 오브젝트를 생성하여 반환합니다.</p>\n<p>&#95;&#95;proto&#95;&#95;.constructor는 생성자 함수로 이름이 GeneratorFunction입니다.</p>\n<p>반환된 제너레이터 오브젝트에<br>&#95;&#95;proto&#95;&#95;.&#95;&#95;proto&#95;&#95;에 next()가 있으므로<br>genObj.next()형태로 호출할 수 있습니다.</p>\n<hr>\n<h2 id=\"GeneratorFunction\">GeneratorFunction(): 제너레이터 함수 생성</h2>\n\n<p>제너레이터 함수를 생성하여 반환합니다.</p>\n<p>GeneratorFunction 생성자는 새로운 generator function 객체를 생성합니다. JavaScript 에서 모든 generator function 은 실제로 GeneratorFunction object 입니다.</p>\n<p>주의할 점은, GeneratorFunction 이 전역 객체(global object)가 아니란 점입니다. GeneratorFunction은 다음의 코드를 실행해서 얻을 수 있습니다.</p>\n<blockquote>\n<p>Object.getPrototypeOf(function*(){}).constructor</p>\n</blockquote>\n<p>new 연산자로 GeneratorFunction() 함수를 호출할 수 없습니다. 이름 없는 제너레이터 함수를 생성하고, 여기에 연결된 constructor를 사용하여 제너레이터 함수를 생성합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> GenConst = <span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;&#125;).constructor;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> sports = <span class=\"keyword\">new</span> GenConst(  </span><br><span class=\"line\"> <span class=\"string\">\"one\"</span>, <span class=\"string\">\"two\"</span>,  </span><br><span class=\"line\"> <span class=\"string\">\"console.log('함수 블록'); yield one + two\"</span>  </span><br><span class=\"line\">);  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> genObj = sports(<span class=\"number\">3</span>, <span class=\"number\">4</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// 함수 블록  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 7, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>제너레이터 함수를 생성하기 위한 생성자(constructor)를 구합니다.<br>function*(){}으로 익명 제너레이터 함수를 생성하여 Object.getPrototypeOf()의 파라미터 값으로 지정합니다. 익명 제너레이터 함수의 prototype 오브젝트가 반환됩니다. prototype에 constructor가 있으므로 이를 반환하고 GenConst에 할당합니다. (Genconst 변수가 생성자 함수가 되는 것 입니다.)</p>\n</li>\n<li><p>new 연산자로 GenConst 생성자를 호출하여 제너레이터 함수를 생성합니다.<br>(GenConst의 파라미터에 생성될 제너레이터 함수에서 사용할 파라미터와 함수 블록 코드를 문자열로 작성합니다.)<br>첫 번째 one 과 두 번째 two가 제너레이터 함수의 파라미터가 되고,<br>세 번째 파라미터가 함수 블록 코드가 됩니다.</p>\n</li>\n</ol>\n<p>파라미터의 문자열을 parsing(문자열 해석?)하면 다음과 같은 형태가 되는 것입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>new GenConst parsing</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">one,two</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'함수 블록'</span>);  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> one + two  </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>sports(3,4)로 호출하면 제너레이터 오브젝트를 생성하여 반환합니다.<br>function*(one, two){}에서 3이 one에 4가 two에 설정됩니다.</p>\n</li>\n<li><p>next()를 호출하면 함수 블록 코드를 실행합니다.<br>Object {value: 7, done: false}를 반환합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"yield\">yield: 제너레이터 함수 실행, 멈춤</h2>\n\n<p>yield 키워드는 제너레이터 함수를 멈추게 하거나 다시 실행하는데 사용됩니다.</p>\n<blockquote>\n<p>[returnValue] = yield [expression];</p>\n</blockquote>\n<ul>\n<li><p>expression<br>제너레이터 함수에서 제너레이터 프로토콜을 통해 반환할 값을 정의합니다(표현식). 값이 생략되면, undefined를 반환합니다.</p>\n</li>\n<li><p>returnValue<br>제너레이터 실행을 재개 하기 위해서, optional value을 제너레이터의 next() 메서드로 전달하여 반환합니다.</p>\n</li>\n<li><p>yield의 표현식 평가 결과를 왼쪽의 returnValue에 할당하지 않습니다.<br>제너레이터 오브젝트의 next()를 호출하면 next() 파라미터 값이 returnValue에 할당됩니다.</p>\n</li>\n<li><p>next()로 제너레이터 함수를 호출하면 yield 작성에 관계없이 “{value: 값, done: false/true}” 형태로 반환합니다.</p>\n</li>\n<li><p>yield를 수행하면 표현식 평가 결과가 value 값에 설정되고, yield를 수행하지 못하면 undefined가 설정됩니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">sports</span>(<span class=\"params\">one</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> two = <span class=\"keyword\">yield</span> one;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> param = <span class=\"keyword\">yield</span> two + one;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> param + one;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> generatorObj = sports(<span class=\"number\">10</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(generatorObj.next());  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(generatorObj.next());  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(generatorObj.next(<span class=\"number\">20</span>));  </span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: 10, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: NaN, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: 30, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>sports(10)으로 호출하여 제너레이터 함수의 one 파라미터에 10이 설정되고<br>제너레이터 오브젝트를 생성하여 반환합니다. (함수 블록의 코드는 실행하지 않습니다.)</p>\n</li>\n<li><p>generatorObj.next()를 호출하면 sports 제너레이터 함수 블록의 첫 줄부터 첫 번째 yield까지 수행합니다. == (let two = yield one;)<br>yield의 표현식 평과 결과 {value: 10, done: false}형태를 반환합니다.<br>할당연산자(=)는 오른쪽 값을 왼쪽 변수에 할당하지만, yield 의 할당연산자(=)는 할당하지 않습니다.</p>\n</li>\n<li><p>next()를 다시한번 호출하면 파라미터 값을 (let two = yield one)에서 two 변수에 설정합니다. 파라미터 값이 지정되지 않았으며 undefined가 two 변수에 설정됩니다. 그리고 아래 코드를 실행합니다.<br>two 변수에 undefined가 설정되어 있고, one 변수에 10이 설정되어 있으므로<br>Object {value: NaN, done: false}를 반환합니다. NaN을 param 변수에 설정하지 않습니다.</p>\n</li>\n<li><p>next(20)으로 호출하면 파라미터 값 20을 (let param = yield two + one)에서 param 변수에 설정합니다. param 변수 값이 20이고 one 변수 값이 10이므로<br>{value: 30, done: false}를 반환합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">sports</span>(<span class=\"params\">one</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> one;  </span><br><span class=\"line\"> <span class=\"number\">4.</span> <span class=\"keyword\">let</span> check = <span class=\"number\">10</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> genObj = sports(<span class=\"number\">10</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: 10, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>sports(10) 으로 호출하면 제너레이터 함수의 one 파라미터에 10이 설정되고<br>제너레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>next()를 호출하면 함수 블록의 첫 줄부터 첫 번째 yield의 표현식까지 수행합니다. yield one; = {value: 10, done: false} 형태로 반환합니다.</p>\n</li>\n<li><p>next()를 호출하면 파라미터 값을 바로 앞 yield 왼쪽에 있는 변수에 할당합니다.<br>그런데 왼쪽의 변수가 없으므로 값을 할당하지 않습니다.<br>이후에 아래 코드를 실행합니다.</p>\n</li>\n<li><p>check에 10을 할당하는 코드이지만 더 이상 수행할 yield는 없고<br>함수 안에 더 처리해야할 코드도 없습니다. 반환할 값이 없습니다.<br>value 프로퍼티 값에 undefined를 설정하고, done 프로퍼티 값에 true를 설정합니다. {value: undefined, done: true} 형태로 반환됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"next\">next(): yield 단위로 실행</h2>\n\n<p>제너레이터 함수에서 yield 단위로 실행합니다.</p>\n<p>next()를 호출하면 yield를 기준으로 이전 yield의 다음 줄부터 yield까지 수행합니다.</p>\n<p>제너레이터 함수에 yield가 여러개 작성되어 있으면, yield 수만큼 next()를 작성해줘야 제너레이터 함수 전체를 실행하게 됩니다.</p>\n<p>파라미터는 선택으로 제너레이터 함수가 멈춘 yield의 왼쪽 변수에 설정합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">value</span>)</span>&#123;  </span><br><span class=\"line\"> value = value + <span class=\"number\">10</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> ++value;  </span><br><span class=\"line\"> value = value + <span class=\"number\">7</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> ++value;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> genObj = gen(<span class=\"number\">1</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: 12, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: 20, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">//Object &#123;value: undefined, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>gen(1)로 호출하면 제너레이터 함수의 value 파라미터에 1이 설정되며 제너레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>next()를 호출하면 제너레이터 함수 첫 줄부터 yield의 표현식까지 수행합니다.<br>즉, 다음 코드를 실행합니다.<br>value = value + 10;<br>yield ++value;<br>파라미터로 받은 1에 10을 더해 value에 할당합니다.<br>다음으로 yield ++value;를 실행하여 value값에 1을 더합니다.<br>{value: 12, done: false}가 반환됩니다.</p>\n</li>\n<li><p>다시 next()를 호출하면 yield ++value에서 yield 왼쪽에 파라미터 값을 설정합니다. 그런데 왼쪽에 변수가 없으므로 다음 코드를 실행합니다.<br>value = value + 7;<br>yield ++value;<br>value 변수 값이 12이므로 7을 더해 19를 value에 할당합니다.<br>다음으로 yield ++value;을 실행하여 {value: 20, done: false}를 반환합니다.</p>\n</li>\n<li><p>다시 next()를 호출하면 제너레이터 함수에 yield가 없으므로<br>{value: undefined, done: false}를 반환합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"next_ex\">next() 활용 예제</h2>\n\n<p>청구 금액과 할인 금액 계산하여 반환</p>\n<ol>\n<li><p>청구 금액을 계싼하는 제너레이터 함수와 할인 금액을 계산하는 일반 함수를 정의합니다.</p>\n</li>\n<li><p>청구 금액 계산 제너레이터 함수는 수량과 단가를 파라미터로 받아 금액을 계산합니다.</p>\n</li>\n<li><p>계산한 금액을 yield로 반환합니다.</p>\n</li>\n<li><p>할인 금액 함수를 호출하면서 yield로 반환된 값을 파라미터 값으로 넘겨 줍니다.</p>\n</li>\n<li><p>파라미터의 금액에 따라 할인 금액을 계산하여 반환합니다.</p>\n</li>\n<li><p>청구 금액 계산 제너레이터 함수를 호출하면서 할인 금액을 파라미터로 넘겨줍니다.</p>\n</li>\n<li><p>합계 금액에서 할인 금액을 빼서 청구 금액을 계산합니다,</p>\n</li>\n<li><p>계산된 청구 금액을 반환합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>next(), yield 활용 예제</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 청구 금액을 계산하는 제너레이터 함수 getAmount  </span></span><br><span class=\"line\"><span class=\"comment\">// 파라미터 qty = 수량 , price = 단가  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> getAmount = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">qty, price</span>)</span>&#123;  </span><br><span class=\"line\"><span class=\"comment\">// 함수가 처음 호출될 때 수량에 단가를 곱해 합계 금액을 구하고 소숫점은 버립니다.  </span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> amount = <span class=\"built_in\">Math</span>.floor(qty * price);  </span><br><span class=\"line\"><span class=\"comment\">// 두 번째 호출될 때 할인 금액(discount)을 받아   </span></span><br><span class=\"line\"><span class=\"comment\">// 합계 금액에서 할인 금액을 빼서 반환합니다.  </span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> discount = <span class=\"keyword\">yield</span> amount;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> amount - discount;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// 할인 금액을 구하는 함수 getDiscount  </span></span><br><span class=\"line\"><span class=\"comment\">// 파라미터 값인 amount가 1000 보다 크면 0.2를 곱하고  </span></span><br><span class=\"line\"><span class=\"comment\">// 아니면 0.1을 곱합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> getDiscount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">amount</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> amount &gt; <span class=\"number\">1000</span> ? amount * <span class=\"number\">0.2</span> : amount * <span class=\"number\">0.1</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// getAmount(10, 60)으로 호출하여 qty값 10 price값 60이 설정됩니다.  </span></span><br><span class=\"line\"><span class=\"comment\">// 제너레이터 오브젝트를 생성하여 반환합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> amountObj = getAmount(<span class=\"number\">10</span>, <span class=\"number\">60</span>);  </span><br><span class=\"line\"><span class=\"comment\">// next()를 호출하여 제너레이터 함수를 실행시키고 반환된 결과를  </span></span><br><span class=\"line\"><span class=\"comment\">// result 변수에 할당합니다.  </span></span><br><span class=\"line\"> <span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\"> let amount = Math.floor(qty * price);  </span></span><br><span class=\"line\"><span class=\"comment\"> 10 * 60 = 600  </span></span><br><span class=\"line\"><span class=\"comment\"> amount에 600이 할당됩니다.  </span></span><br><span class=\"line\"><span class=\"comment\"> &#123;value: 600, done: false&#125; 반환  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = amountObj.next();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\"><span class=\"comment\">//할인 금액을 구하는 함수  </span></span><br><span class=\"line\"><span class=\"comment\">//앞의 next()에서 value:600을 반환했으므로 파라미터 값으로 600을 넘겨줍니다.  </span></span><br><span class=\"line\"><span class=\"comment\">//호출된 dcAmount에서 60을 반환합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dcAmount = getDiscount(result.value);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dcAmount);  </span><br><span class=\"line\"><span class=\"comment\">//next(dcAmount)로 호출하여 파라미터 값 60을 넘겨줍니다  </span></span><br><span class=\"line\"><span class=\"comment\">// let discount = yield amount 에서 60이 discount에 설정됩니다.  </span></span><br><span class=\"line\"><span class=\"comment\">// 그리고 return amount - discount 를 실행하여  </span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 540, done: true&#125;를 반환합니다.  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(amountObj.next(dcAmount));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"next-의-다양한-형태\"><a href=\"#next-의-다양한-형태\" class=\"headerlink\" title=\"next()의 다양한 형태\"></a>next()의 다양한 형태</h3><p>next()와 yield를 조합한 다양한 형태를 살펴 봅니다.<br>제너레이터 함수를 계속 호출 하려면 yield가 이에 대응할 수 있어야 합니다.<br>이를 위해 한 줄에 다수의 yield를 작성할 수도 있고,<br>배열 안에 다수의 yield를 작성할 수도 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>next-while</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">value</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">while</span> (value)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> ++count;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = gen(<span class=\"literal\">true</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 1, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 2, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>제너레이터 함수에 while문을 작성하고 그 안에 yield를 작성한 형태입니다.</p>\n<ol>\n<li><p>처음 next()를 호출하면 gen()함수의 첫 줄부터 yield까지 수행한 후 그 값을 반환합니다.<br>(let count = 0;)는 처음 한 번만 실행되고 다음부터는 실행하지 않습니다.<br>while(value){}에서 value 파라미터 값이 true이므로 블락을 실행합니다.<br>yield ++count가 실행되어 {value: 1, done: false}를 반환합니다.</p>\n</li>\n<li><p>다시 next()를 호출하면 앞에서 증가된 count 변수 값이 유지되므로 값을 누적할 수 있습니다. yield ++count를 실행하여 {value: 2, done: false}를 반환합니다.<br>이와 같이 while문 안에 yield를 작성하면 next()를 호출할 때마다 yield가 수행됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>next-return-yield</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">yield</span> <span class=\"keyword\">yield</span> <span class=\"keyword\">yield</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = gen();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(genObj.next(<span class=\"number\">10</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(genObj.next(<span class=\"number\">20</span>));  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(genObj.next(<span class=\"number\">30</span>));  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: undefined, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 10, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 20, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 30, done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>제너레이터 함수의 return 문에 다수의 yield를 작성한 형태입니다.<br>return 문의 표현식에 yield가 3개 작성되어 있습니다.</p>\n<ol>\n<li><p>처음 next()를 호출하면 첫 번째 yield를 수행합니다.<br>yield에 반환 값이 없으므로 {value: undefined, done: false}를 반환합니다.</p>\n</li>\n<li><p>두 번째로 next(10)을 호출하면 두 번째 yield를 수행합니다.<br>왼쪽에 파라미터 값을 받을 변수가 없으므로 파라미터로 넘겨준 값 그대로 반환합니다. 따라서 {value: 10, done: false}를 반환합니다.</p>\n</li>\n<li><p>세 번째로 next(20)을 호출하면 세 번째 yield를 수행합니다.<br>{value: 20, done: false}를 반환합니다.</p>\n</li>\n<li><p>마지막으로 next(30)을 호출하면 수행할 yield가 없습니다.<br>{done: true}를 반환하고, return을 작성했으므로 파라미터로 넘겨준 값을<br>반환 합니다. 즉 {value: 30, done: false}이 반환됩니다.<br>return을 작성하지 않으면 {value: undefined, done: true}를 반환합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>next-array-yield</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> [<span class=\"keyword\">yield</span> <span class=\"keyword\">yield</span>];  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = gen();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(genObj.next(<span class=\"number\">10</span>));  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(genObj.next(<span class=\"number\">20</span>));  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: undefined, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 10, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Array[1], done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>제너레이터 함수의 return 문에 배열안에 다수의 yield를 작성한 형태입니다.</p>\n<ol>\n<li><ol start=\"2\">\n<li>는 return문에 yield을 연속으로 작성한 것과 같습니다.<br>yield가 2개 뿐이므로 더 이상 수행할 yield가 없는 상태가 됩니다.</li>\n</ol>\n</li>\n<li><p>마지막으로 next(20)을 호출하면 (return [yield yield])에서 yield를 제외한<br>[]안에 파라미터로 넘겨준 값을 작성합니다.<br>{value: Array[1], done: true} 형태로 반환됩니다.<br>Array[1]은 {0:20} 입니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>for-of-yield</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">start</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> value = start;  </span><br><span class=\"line\"> <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> ++value;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> count <span class=\"keyword\">of</span> gen(<span class=\"number\">10</span>))&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(count);  </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">12</span>)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// 11  </span></span><br><span class=\"line\"><span class=\"comment\">// 12  </span></span><br><span class=\"line\"><span class=\"comment\">// 13</span></span><br></pre></td></tr></table></figure>\n\n<p>for-of() 문에 제너레이터 함수를 호출하는 코드를 작성한 형태입니다.</p>\n<ul>\n<li><p>처음 for-of 문을 시작하면 gen(10)을 호출하여 제너레이터 함수의 start 파라미터에 10을 설정하고 제너레이터 오브젝트를 생성하여 반환합니다.<br>호출한 gen(10) 위치로 돌아오면 반환받은 오브젝트를 할당할 변수가 없으므로 엔진 내부에 저장합니다.</p>\n</li>\n<li><p>gen() 함수를 호출하며 이는 next()를 호출한 것과 같습니다.<br>let value = start;를 수행한 후 while (true){yield ++value;}를 수행합니다.<br>{value: 11, done:false}를 반환하게 되며 value 프로퍼티 값이 count 변수에 설정됩니다.</p>\n</li>\n<li><p>for-of 문의 블록에 작성한 코드를 수행하며 콘솔에 11이 출력됩니다.<br>count 변수 값이 11이므로 다시 for-of 문을 반복하게 됩니다.<br>count 변수 값이 12보다 클때 까지 for-of문을 반복합니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"throw\">throw(): Error 발생</h2>\n\n<p>throw() 메서드는 Generator의 실행을 재개시키고 Generator 함수의 실행 문맥 속으로 error를 주입합니다.</p>\n<p>제너레이터 함수를 호출하여 받은 제너레이터 오브젝트의 throw()를 호출하면<br>에러가 발생합니다. 에러가 발생하면 제너레이터 함수의 catch()문에서 에러를 받습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">10</span>;  </span><br><span class=\"line\"> &#125; <span class=\"keyword\">catch</span> (message) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> message;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">20</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = gen();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(genObj.throw(<span class=\"string\">\"에러 발생\"</span>));  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 10, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"에러 발생\", done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 20, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>next()를 호출하면 try문 의 (yield 10;)을 실행합니다.<br>에러가 발생하지않으며 {value: 10, done: false}를 반환합니다.</p>\n</li>\n<li><p>throw(“에러 발생”)를 호출하면 제너레이터 함수의 catch(message)가 실행됩니다.<br>throw()의 파라미터 값이 catch(message)의 message 파라미터에 설정됩니다.<br>catch() 블록{}의 (yield message;)가 실행되어 {value: “에러 발생”, done: false}가 반환됩니다.<br>중요한 점은 done: false를 반환한다는 점입니다. 즉, 에러는 발생했지만 다음에 next()를 호출할 수 있습니다.</p>\n<ul>\n<li>genObj.throw(Error(“에러 발생”)); 과 같이 파라미터에 Error 오브젝트를 작성할 수도 있습니다.</li>\n</ul>\n</li>\n<li><p>앞에서 throw()를 호출하며 catch()블록을 수행했지만 이터레이터가 종료된 것은 아닙니다. 따라서 다시 next()를 호출할 수 있으며 함수의 (yield 20;)을 수행하여<br>{value: 20, done: false}를 반환합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>제너레이터 함수에서 에러가 발생</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">throw</span> <span class=\"string\">\"에러 발생\"</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">20</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = gen();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> result = genObj.next();  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (error) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(error);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">//에러 발생  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>try문에서 next()를 호출하면 제너레이터 함수 첫 줄에서 throw문으로 인해 에러가 발생하며, catch(error)에서 에러를 받습니다.<br>(throw “에러 발생”)에서 “에러 발생”이 catch(error)의 error 파라미터에 설정됩니다.</p>\n</li>\n<li><p>제너레이터 함수에서 에러가 발생하면 이터레이터가 종료됩니다.<br>따라서 next()를 실행하면 제너레이터 함수내에 throw “에러 발생” 밑에<br>yield 20;이 있지만 실행되지 않습니다.<br>{value: undefined, done: true}가 반환됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"yield*\">yield* 키워드</h2>\n\n<blockquote>\n<p>yield* [[expression]]</p>\n</blockquote>\n<p>표현식(expression)에 이터러블 오브젝트를 작성합니다. next()를 호출할 때 마다<br>이터러블 오브젝트를 하나씩 실행하며, 결과 값을 yield의 반환 값으로 사용합니다.</p>\n<p>표현식에 제너레이터 함수를 작성할 수 있습니다.<br>표현식으로 호출된 함수에 다수의 yield가 있으면 호출된 함수의 yield를 전부 처리한 후 yield* 아래에 작성한 코드를 실행합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>yield* 표현식에 제너레이터 함수 작성 형태</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> plusGen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">value</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> value + <span class=\"number\">5</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> value + <span class=\"number\">10</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">value</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span>* plusGen(value);  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> value + <span class=\"number\">20</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = gen(<span class=\"number\">10</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, genObj.next());  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, genObj.next());  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 15, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 20, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 30, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>console.log로 genObj.next()를 호출하면 실행되는 순서가 다음과 같습니다.</p>\n<ol>\n<li><p>gen() 함수의 yield* plusGen(value)을 실행합니다.</p>\n</li>\n<li><p>yield*를 작성했으므로 plusGen(value)을 호출하면서 파라미터 값으로 10을 넘겨줍니다.</p>\n</li>\n<li><p>plusGen()이 제너레이터 함수이므로 제너레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>next()로 호출헤야 plusGen() 함수의 yield를 수행하지만, 이때는 자동으로 plusGen()의 첫 번째 (yield value + 5)를 수행하며 {value: 15, done: false}를 반환합니다.</p>\n</li>\n<li><p>plusGen()을 호출한 곳에서 다시 yield를 수행하므로 plusGen()에서 반환된 값을 반환합니다.</p>\n</li>\n<li><p>콘솔에 Object {value: 15, done: false}를 출력합니다.</p>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>next()를 호출하면 plusGen()에서 수행하지 않은 (yield value + 10;)을 실행하며 Object {value: 20, done: false}를 반환합니다.</p>\n</li>\n<li><p>next()를 호출하면 plusGen()에 더 이상 실행할 yield가 없으므로<br>plusGen()을 호출한 gen() 함수 내의 코드 아래의 코드를 수행합니다.<br>(yield value + 20;) 을 실행하게 되며 Object {value: 30, done: false}를 반환합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>yield* 표현식 재귀 호출 형태</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">value</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> value;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span>* gen(value + <span class=\"number\">10</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = gen(<span class=\"number\">1</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(genObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 1, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 11, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 21, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>처음 next()를 호출하면 제너레이터 함수 첫째 줄의 (yield value;)를 실행하며<br>{value: 1, done: false}를 반환합니다.</p>\n</li>\n<li><p>두 번째로 next()를 호출하면 (yield* gen(value + 10);)을 실행합니다.<br>그런데 yield* 표현식에서 자신 함수(gen)를 호출합니다. 파라미터 값으로 11을 넘겨주며 next()가 없지만 엔진에서 반환받은 오브젝트의 제너레이터 함수를 호출합니다. (yield value;)가 실행되며 {value: 11, done: false}를 반환합니다.<br><mark>이때, yield value;가 없다면 계속해서 자신을 호출하게 되므로 무한 루프를 돌게됩니다.</mark></p>\n</li>\n<li><p>세 번째로 next()를 호출하면 (yield* gen(value + 10);)을 실행하고<br>자신을 호출합니다. 위와 같이 진행되어 {value: 21, done: false}를 반환합니다.</p>\n</li>\n</ol>"},{"title":"Iteration -ECMAScript","date":"2020-03-18T03:54:51.000Z","disqusId":"tunas-blog-1","_content":"\n\n* * *\n\n## 1. 개요\n\n**Iteration은 반복 처리를 나타내며 이를 위한 프로토콜(Protocol)을 갖고 있습니다.**\n\nprotocol 이라고 하면 통신이 연상되는데  \n통신에 있어 프로토콜은 약속된 기준과 방법으로 데이터를 송수신하는 것을 의미합니다. (통신 프로토콜 = 통신규약)\n\nES6에서 프로토콜도 규약입니다.  \nIteration을 위한 규약이 있으며 이를 지켜야 반복 처리가 가능합니다.\n\n예를 들어 자바스크립트에서 Array(배열)를 반복 처리 하기 위해서는  \n배열이 반복할 수 있는 Object(오브젝트)여야 하며,  \n오브젝트에 반복 처리를 할 수 있는 method(메서드)가 필요합니다.  \n이러한 규약이 ES6의 Iteration Protocol (반복 처리 규약) 입니다.\n\n<!-- more -->\n\n* * *\n\n## iterable protocol\n\niterable protocol (이터러블 프로토콜)은 **오브젝트의 반복 처리 규약을 정의** 합니다.  \n빌트인 오브젝트 String, Array, Map, Set, TypedArray, Argument 와  \nDOM의 NodeList 는 기본 값으로 이터러블 프로토콜을 갖고 있습니다.\n\n이와 같은 오브젝트는 자바스크립트 엔진이 렌더링될 때 이터러블 프로토콜이 설정되기 때문에 사전처리를 하지 않아도 반복 처리를 할 수 있습니다.  \n오브젝트에 이터러블 프로토콜이 설정되면 이터러블 오브젝트라고 합니다.\n\n자바스크립트는 이터러블 오브젝트에 Symbol.iterator가 있어야 합니다.(protocol 규약)  \nSymbol.iterator가 있으면 이터러블 오브젝트 입니다.  \nex) 이터러블 오브젝트가 아닌 오브젝트에 Symbol.iterator 코드를 추가하면 이터러블 오브젝트가 됩니다.\n\n자체 오브젝트에는 없지만, 상속받은 prototype chain에 있어도 이터러블 오브젝트가 됩니다.\n\nex) 빌트인 Array 오브젝트를 상속받은 오브젝트는 이터러블 오브젝트.\n\n```js\nlet arrayObj = [];  \nlet result = arrayObj[Symbol.iterator];  \nconsole.log(result); // function values() { [native code] }  \n```\n\n오브젝트에 프로퍼티 존재 여부를 체크할 때  \n1.arrayObj.propertyKey  \n또는  \n2.arrayObj[propertyKey]형태로 작성하지만,\n\nSymbol은 2번과 같이 []안에  \narrayObj[Symbol.iterator] 형태로 작성해야 합니다.\n\n빌트인 오브젝트 Array에 Symbol.iterator가 설정되어 있으므로  \nfunction values() { [native code] } 함수코드가 출력됩니다.\n\n```js\nlet objectObj = {};  \nlet result = objectObj[Symbol.iterator];  \nconsole.log(result); //undefined  \n```\n\nobjectObj는 Symbol.iterator가 존재 하지 않으므로  \nundefined가 출력됩니다.  \n이는 objectObj가 이터러블 오브젝트가 아니라는 뜻이 됩니다.\n\n* * *\n\n## iterator protocol\n\niterator protocol(이터레이터 프로토콜)은 next()메서드를 사용해  \n오브젝트의 값을 차례대로 처리할 수 있는 방법을 제공합니다.\n\n자바스크립트에서 {key: value} 형태의 오브젝트는 작성한 순서대로 열거되는 것이 보장되지 않습니다.  \n이는 오브젝트에 next()가 없다는 의미이기도 합니다.  \n~~ES6에서는 오브젝트에 추가한 순서대로 key, value가 열거되는  \nMap 오브젝트가 있습니다. 자세한 사항은 Map오브젝트에서 다룹니다.~~\n\n```js\nlet arrayObj = [1, 2];  \nlet iteratorObj = arrayObj[Symbol.iterator]();  \n  \nconsole.log(\"1:\", typeof iteratorObj);  \n  \nconsole.log(\"2:\", iteratorObj.next());  \nconsole.log(\"3:\", iteratorObj.next());  \nconsole.log(\"4:\", iteratorObj.next());  \n```\n\n1.  Array 오브젝트를 생성하여 [1,2]값을 arrayObj에 할당합니다.\n    \n2.  arrayObj의 Symbol.iterator()을 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.\n    \n\n**1: object**  \nSymbol.iterator()로 반환받은 iteratorObj 타입.  \n(이터러블 오브젝트에 Symbol.iterator()로 반환받은 오브젝트이므로 이터레이터 오브젝트 입니다.)  \n이터레이터 오브젝트 이므로 next()메소드를 사용 할 수있습니다.\n\n**2: Object {value: 1, done: false}**  \nvalue: 1 = 이터러블 오브젝트의 값 [1,2] 중 1  \ndone: false = 이터레이터가 끝나지 않은 것을 의미합니다.\n\n**3: Object {value: 2, done: false}**  \nvalue: 2 = 이터러블 오브젝트의 값 [1,2] 중 2  \ndone: false = 이터레이터가 끝나지 않은 것을 의미합니다.\n\n**4: Object {value: undefined, done: true}**  \nvalue: undefined = 이터러블 오브젝트의 값 [1,2] 중 이터레이터로 읽은 값이 없음  \ndone: true = 이터레이터 종료됨.\n\n이와 같이 이터레이터를 사용하여 이터러블 오브젝트의 값을 작성한 순서대로 읽을 수 있습니다. for()문으로 반복하는 것과는 차이가 있습니다.(목적도 다름)","source":"_posts/Iteration -ECMAScript.md","raw":"---\ntitle: Iteration -ECMAScript\ndate: 2020-03-18 12:54:51\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n\n* * *\n\n## 1. 개요\n\n**Iteration은 반복 처리를 나타내며 이를 위한 프로토콜(Protocol)을 갖고 있습니다.**\n\nprotocol 이라고 하면 통신이 연상되는데  \n통신에 있어 프로토콜은 약속된 기준과 방법으로 데이터를 송수신하는 것을 의미합니다. (통신 프로토콜 = 통신규약)\n\nES6에서 프로토콜도 규약입니다.  \nIteration을 위한 규약이 있으며 이를 지켜야 반복 처리가 가능합니다.\n\n예를 들어 자바스크립트에서 Array(배열)를 반복 처리 하기 위해서는  \n배열이 반복할 수 있는 Object(오브젝트)여야 하며,  \n오브젝트에 반복 처리를 할 수 있는 method(메서드)가 필요합니다.  \n이러한 규약이 ES6의 Iteration Protocol (반복 처리 규약) 입니다.\n\n<!-- more -->\n\n* * *\n\n## iterable protocol\n\niterable protocol (이터러블 프로토콜)은 **오브젝트의 반복 처리 규약을 정의** 합니다.  \n빌트인 오브젝트 String, Array, Map, Set, TypedArray, Argument 와  \nDOM의 NodeList 는 기본 값으로 이터러블 프로토콜을 갖고 있습니다.\n\n이와 같은 오브젝트는 자바스크립트 엔진이 렌더링될 때 이터러블 프로토콜이 설정되기 때문에 사전처리를 하지 않아도 반복 처리를 할 수 있습니다.  \n오브젝트에 이터러블 프로토콜이 설정되면 이터러블 오브젝트라고 합니다.\n\n자바스크립트는 이터러블 오브젝트에 Symbol.iterator가 있어야 합니다.(protocol 규약)  \nSymbol.iterator가 있으면 이터러블 오브젝트 입니다.  \nex) 이터러블 오브젝트가 아닌 오브젝트에 Symbol.iterator 코드를 추가하면 이터러블 오브젝트가 됩니다.\n\n자체 오브젝트에는 없지만, 상속받은 prototype chain에 있어도 이터러블 오브젝트가 됩니다.\n\nex) 빌트인 Array 오브젝트를 상속받은 오브젝트는 이터러블 오브젝트.\n\n```js\nlet arrayObj = [];  \nlet result = arrayObj[Symbol.iterator];  \nconsole.log(result); // function values() { [native code] }  \n```\n\n오브젝트에 프로퍼티 존재 여부를 체크할 때  \n1.arrayObj.propertyKey  \n또는  \n2.arrayObj[propertyKey]형태로 작성하지만,\n\nSymbol은 2번과 같이 []안에  \narrayObj[Symbol.iterator] 형태로 작성해야 합니다.\n\n빌트인 오브젝트 Array에 Symbol.iterator가 설정되어 있으므로  \nfunction values() { [native code] } 함수코드가 출력됩니다.\n\n```js\nlet objectObj = {};  \nlet result = objectObj[Symbol.iterator];  \nconsole.log(result); //undefined  \n```\n\nobjectObj는 Symbol.iterator가 존재 하지 않으므로  \nundefined가 출력됩니다.  \n이는 objectObj가 이터러블 오브젝트가 아니라는 뜻이 됩니다.\n\n* * *\n\n## iterator protocol\n\niterator protocol(이터레이터 프로토콜)은 next()메서드를 사용해  \n오브젝트의 값을 차례대로 처리할 수 있는 방법을 제공합니다.\n\n자바스크립트에서 {key: value} 형태의 오브젝트는 작성한 순서대로 열거되는 것이 보장되지 않습니다.  \n이는 오브젝트에 next()가 없다는 의미이기도 합니다.  \n~~ES6에서는 오브젝트에 추가한 순서대로 key, value가 열거되는  \nMap 오브젝트가 있습니다. 자세한 사항은 Map오브젝트에서 다룹니다.~~\n\n```js\nlet arrayObj = [1, 2];  \nlet iteratorObj = arrayObj[Symbol.iterator]();  \n  \nconsole.log(\"1:\", typeof iteratorObj);  \n  \nconsole.log(\"2:\", iteratorObj.next());  \nconsole.log(\"3:\", iteratorObj.next());  \nconsole.log(\"4:\", iteratorObj.next());  \n```\n\n1.  Array 오브젝트를 생성하여 [1,2]값을 arrayObj에 할당합니다.\n    \n2.  arrayObj의 Symbol.iterator()을 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.\n    \n\n**1: object**  \nSymbol.iterator()로 반환받은 iteratorObj 타입.  \n(이터러블 오브젝트에 Symbol.iterator()로 반환받은 오브젝트이므로 이터레이터 오브젝트 입니다.)  \n이터레이터 오브젝트 이므로 next()메소드를 사용 할 수있습니다.\n\n**2: Object {value: 1, done: false}**  \nvalue: 1 = 이터러블 오브젝트의 값 [1,2] 중 1  \ndone: false = 이터레이터가 끝나지 않은 것을 의미합니다.\n\n**3: Object {value: 2, done: false}**  \nvalue: 2 = 이터러블 오브젝트의 값 [1,2] 중 2  \ndone: false = 이터레이터가 끝나지 않은 것을 의미합니다.\n\n**4: Object {value: undefined, done: true}**  \nvalue: undefined = 이터러블 오브젝트의 값 [1,2] 중 이터레이터로 읽은 값이 없음  \ndone: true = 이터레이터 종료됨.\n\n이와 같이 이터레이터를 사용하여 이터러블 오브젝트의 값을 작성한 순서대로 읽을 수 있습니다. for()문으로 반복하는 것과는 차이가 있습니다.(목적도 다름)","slug":"Iteration -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrsg000qqgvqf5z1dd20","content":"<hr>\n<h2 id=\"1-개요\"><a href=\"#1-개요\" class=\"headerlink\" title=\"1. 개요\"></a>1. 개요</h2><p><strong>Iteration은 반복 처리를 나타내며 이를 위한 프로토콜(Protocol)을 갖고 있습니다.</strong></p>\n<p>protocol 이라고 하면 통신이 연상되는데<br>통신에 있어 프로토콜은 약속된 기준과 방법으로 데이터를 송수신하는 것을 의미합니다. (통신 프로토콜 = 통신규약)</p>\n<p>ES6에서 프로토콜도 규약입니다.<br>Iteration을 위한 규약이 있으며 이를 지켜야 반복 처리가 가능합니다.</p>\n<p>예를 들어 자바스크립트에서 Array(배열)를 반복 처리 하기 위해서는<br>배열이 반복할 수 있는 Object(오브젝트)여야 하며,<br>오브젝트에 반복 처리를 할 수 있는 method(메서드)가 필요합니다.<br>이러한 규약이 ES6의 Iteration Protocol (반복 처리 규약) 입니다.</p>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"iterable-protocol\"><a href=\"#iterable-protocol\" class=\"headerlink\" title=\"iterable protocol\"></a>iterable protocol</h2><p>iterable protocol (이터러블 프로토콜)은 <strong>오브젝트의 반복 처리 규약을 정의</strong> 합니다.<br>빌트인 오브젝트 String, Array, Map, Set, TypedArray, Argument 와<br>DOM의 NodeList 는 기본 값으로 이터러블 프로토콜을 갖고 있습니다.</p>\n<p>이와 같은 오브젝트는 자바스크립트 엔진이 렌더링될 때 이터러블 프로토콜이 설정되기 때문에 사전처리를 하지 않아도 반복 처리를 할 수 있습니다.<br>오브젝트에 이터러블 프로토콜이 설정되면 이터러블 오브젝트라고 합니다.</p>\n<p>자바스크립트는 이터러블 오브젝트에 Symbol.iterator가 있어야 합니다.(protocol 규약)<br>Symbol.iterator가 있으면 이터러블 오브젝트 입니다.<br>ex) 이터러블 오브젝트가 아닌 오브젝트에 Symbol.iterator 코드를 추가하면 이터러블 오브젝트가 됩니다.</p>\n<p>자체 오브젝트에는 없지만, 상속받은 prototype chain에 있어도 이터러블 오브젝트가 됩니다.</p>\n<p>ex) 빌트인 Array 오브젝트를 상속받은 오브젝트는 이터러블 오브젝트.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayObj = [];  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arrayObj[<span class=\"built_in\">Symbol</span>.iterator];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// function values() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>오브젝트에 프로퍼티 존재 여부를 체크할 때<br>1.arrayObj.propertyKey<br>또는<br>2.arrayObj[propertyKey]형태로 작성하지만,</p>\n<p>Symbol은 2번과 같이 []안에<br>arrayObj[Symbol.iterator] 형태로 작성해야 합니다.</p>\n<p>빌트인 오브젝트 Array에 Symbol.iterator가 설정되어 있으므로<br>function values() { [native code] } 함수코드가 출력됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> objectObj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = objectObj[<span class=\"built_in\">Symbol</span>.iterator];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>objectObj는 Symbol.iterator가 존재 하지 않으므로<br>undefined가 출력됩니다.<br>이는 objectObj가 이터러블 오브젝트가 아니라는 뜻이 됩니다.</p>\n<hr>\n<h2 id=\"iterator-protocol\"><a href=\"#iterator-protocol\" class=\"headerlink\" title=\"iterator protocol\"></a>iterator protocol</h2><p>iterator protocol(이터레이터 프로토콜)은 next()메서드를 사용해<br>오브젝트의 값을 차례대로 처리할 수 있는 방법을 제공합니다.</p>\n<p>자바스크립트에서 {key: value} 형태의 오브젝트는 작성한 순서대로 열거되는 것이 보장되지 않습니다.<br>이는 오브젝트에 next()가 없다는 의미이기도 합니다.<br><del>ES6에서는 오브젝트에 추가한 순서대로 key, value가 열거되는<br>Map 오브젝트가 있습니다. 자세한 사항은 Map오브젝트에서 다룹니다.</del></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayObj = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iteratorObj = arrayObj[<span class=\"built_in\">Symbol</span>.iterator]();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"keyword\">typeof</span> iteratorObj);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, iteratorObj.next());</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Array 오브젝트를 생성하여 [1,2]값을 arrayObj에 할당합니다.</p>\n</li>\n<li><p>arrayObj의 Symbol.iterator()을 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n</ol>\n<p><strong>1: object</strong><br>Symbol.iterator()로 반환받은 iteratorObj 타입.<br>(이터러블 오브젝트에 Symbol.iterator()로 반환받은 오브젝트이므로 이터레이터 오브젝트 입니다.)<br>이터레이터 오브젝트 이므로 next()메소드를 사용 할 수있습니다.</p>\n<p><strong>2: Object {value: 1, done: false}</strong><br>value: 1 = 이터러블 오브젝트의 값 [1,2] 중 1<br>done: false = 이터레이터가 끝나지 않은 것을 의미합니다.</p>\n<p><strong>3: Object {value: 2, done: false}</strong><br>value: 2 = 이터러블 오브젝트의 값 [1,2] 중 2<br>done: false = 이터레이터가 끝나지 않은 것을 의미합니다.</p>\n<p><strong>4: Object {value: undefined, done: true}</strong><br>value: undefined = 이터러블 오브젝트의 값 [1,2] 중 이터레이터로 읽은 값이 없음<br>done: true = 이터레이터 종료됨.</p>\n<p>이와 같이 이터레이터를 사용하여 이터러블 오브젝트의 값을 작성한 순서대로 읽을 수 있습니다. for()문으로 반복하는 것과는 차이가 있습니다.(목적도 다름)</p>\n","site":{"data":{}},"excerpt":"<hr>\n<h2 id=\"1-개요\"><a href=\"#1-개요\" class=\"headerlink\" title=\"1. 개요\"></a>1. 개요</h2><p><strong>Iteration은 반복 처리를 나타내며 이를 위한 프로토콜(Protocol)을 갖고 있습니다.</strong></p>\n<p>protocol 이라고 하면 통신이 연상되는데<br>통신에 있어 프로토콜은 약속된 기준과 방법으로 데이터를 송수신하는 것을 의미합니다. (통신 프로토콜 = 통신규약)</p>\n<p>ES6에서 프로토콜도 규약입니다.<br>Iteration을 위한 규약이 있으며 이를 지켜야 반복 처리가 가능합니다.</p>\n<p>예를 들어 자바스크립트에서 Array(배열)를 반복 처리 하기 위해서는<br>배열이 반복할 수 있는 Object(오브젝트)여야 하며,<br>오브젝트에 반복 처리를 할 수 있는 method(메서드)가 필요합니다.<br>이러한 규약이 ES6의 Iteration Protocol (반복 처리 규약) 입니다.</p>","more":"<hr>\n<h2 id=\"iterable-protocol\"><a href=\"#iterable-protocol\" class=\"headerlink\" title=\"iterable protocol\"></a>iterable protocol</h2><p>iterable protocol (이터러블 프로토콜)은 <strong>오브젝트의 반복 처리 규약을 정의</strong> 합니다.<br>빌트인 오브젝트 String, Array, Map, Set, TypedArray, Argument 와<br>DOM의 NodeList 는 기본 값으로 이터러블 프로토콜을 갖고 있습니다.</p>\n<p>이와 같은 오브젝트는 자바스크립트 엔진이 렌더링될 때 이터러블 프로토콜이 설정되기 때문에 사전처리를 하지 않아도 반복 처리를 할 수 있습니다.<br>오브젝트에 이터러블 프로토콜이 설정되면 이터러블 오브젝트라고 합니다.</p>\n<p>자바스크립트는 이터러블 오브젝트에 Symbol.iterator가 있어야 합니다.(protocol 규약)<br>Symbol.iterator가 있으면 이터러블 오브젝트 입니다.<br>ex) 이터러블 오브젝트가 아닌 오브젝트에 Symbol.iterator 코드를 추가하면 이터러블 오브젝트가 됩니다.</p>\n<p>자체 오브젝트에는 없지만, 상속받은 prototype chain에 있어도 이터러블 오브젝트가 됩니다.</p>\n<p>ex) 빌트인 Array 오브젝트를 상속받은 오브젝트는 이터러블 오브젝트.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayObj = [];  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arrayObj[<span class=\"built_in\">Symbol</span>.iterator];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// function values() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>오브젝트에 프로퍼티 존재 여부를 체크할 때<br>1.arrayObj.propertyKey<br>또는<br>2.arrayObj[propertyKey]형태로 작성하지만,</p>\n<p>Symbol은 2번과 같이 []안에<br>arrayObj[Symbol.iterator] 형태로 작성해야 합니다.</p>\n<p>빌트인 오브젝트 Array에 Symbol.iterator가 설정되어 있으므로<br>function values() { [native code] } 함수코드가 출력됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> objectObj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = objectObj[<span class=\"built_in\">Symbol</span>.iterator];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>objectObj는 Symbol.iterator가 존재 하지 않으므로<br>undefined가 출력됩니다.<br>이는 objectObj가 이터러블 오브젝트가 아니라는 뜻이 됩니다.</p>\n<hr>\n<h2 id=\"iterator-protocol\"><a href=\"#iterator-protocol\" class=\"headerlink\" title=\"iterator protocol\"></a>iterator protocol</h2><p>iterator protocol(이터레이터 프로토콜)은 next()메서드를 사용해<br>오브젝트의 값을 차례대로 처리할 수 있는 방법을 제공합니다.</p>\n<p>자바스크립트에서 {key: value} 형태의 오브젝트는 작성한 순서대로 열거되는 것이 보장되지 않습니다.<br>이는 오브젝트에 next()가 없다는 의미이기도 합니다.<br><del>ES6에서는 오브젝트에 추가한 순서대로 key, value가 열거되는<br>Map 오브젝트가 있습니다. 자세한 사항은 Map오브젝트에서 다룹니다.</del></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayObj = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iteratorObj = arrayObj[<span class=\"built_in\">Symbol</span>.iterator]();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"keyword\">typeof</span> iteratorObj);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, iteratorObj.next());</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Array 오브젝트를 생성하여 [1,2]값을 arrayObj에 할당합니다.</p>\n</li>\n<li><p>arrayObj의 Symbol.iterator()을 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n</ol>\n<p><strong>1: object</strong><br>Symbol.iterator()로 반환받은 iteratorObj 타입.<br>(이터러블 오브젝트에 Symbol.iterator()로 반환받은 오브젝트이므로 이터레이터 오브젝트 입니다.)<br>이터레이터 오브젝트 이므로 next()메소드를 사용 할 수있습니다.</p>\n<p><strong>2: Object {value: 1, done: false}</strong><br>value: 1 = 이터러블 오브젝트의 값 [1,2] 중 1<br>done: false = 이터레이터가 끝나지 않은 것을 의미합니다.</p>\n<p><strong>3: Object {value: 2, done: false}</strong><br>value: 2 = 이터러블 오브젝트의 값 [1,2] 중 2<br>done: false = 이터레이터가 끝나지 않은 것을 의미합니다.</p>\n<p><strong>4: Object {value: undefined, done: true}</strong><br>value: undefined = 이터러블 오브젝트의 값 [1,2] 중 이터레이터로 읽은 값이 없음<br>done: true = 이터레이터 종료됨.</p>\n<p>이와 같이 이터레이터를 사용하여 이터러블 오브젝트의 값을 작성한 순서대로 읽을 수 있습니다. for()문으로 반복하는 것과는 차이가 있습니다.(목적도 다름)</p>"},{"title":"Map 오브젝트 -ECMAScript","date":"2020-04-10T00:48:25.000Z","disqusId":"tunas-blog-1","_content":"\nMap 오브젝트는 Object 오브젝트와 비슷하지만,  \n다양한 타입을 프로퍼티 키로 사용할 수 있는 점이 다릅니다.\n\n*   Map 오브젝트\n    *   [개요](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#MapObjcet)\n    *   [new Map(): Map 인스턴스 생성](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#new_Map)\n    *   [set(): key와 value 설정](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_set)\n    *   [get(): key가 같은 value 반환](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_get)\n    *   [has(): key 존재 여부](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_has)\n    *   [entries(): 이터레이터 오브젝트 생성](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_entries)\n    *   [keys(): key 반환 이터레이터 오브젝트 생성](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_keys)\n    *   [values(): value 반환 이터레이터 오브젝트 생성](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_values)\n    *   [forEach(): 엘리먼트마다 콜백 함수 호출](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_forEach)\n    *   [delete(): 엘리먼트 삭제](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_delete)\n    *   [clear(): 모든 key,value 지움](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_clear)\n    *   [Symbol.iterator(): 이터레이터 오브젝트 생성](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_Symbol_iterator)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"MapObjcet\">개요</h2>\n\nMap 오브젝트는 key와 value로 구성됩니다. key, value  \nObject 오브젝트의 key 타입은 String 또는 Symbol이지만  \nMap 오브젝트는 아무 객체와 원시값(Object,Function 등등)이라도 key 와 value로 사용할 수 있습니다.  \nkey 와 value 값을 저장하며 각 쌍의 삽입 순서도 기억합니다.\n\nMap 오브젝트는 key, value로 구성되지만 {key: value}형태로 작성하지 않고,  \n[“key”, “value”]와 같이 이터러블 형태로 작성합니다.\n\n<mark>key에 다양한 타입을 작성할 수 있는 것과 이러터블 형태로 작성하는 것이  \nMap 오브젝트와 Object 오브젝트의 차이입니다.</mark>\n\nMap 오브젝트는 key 값이 같으면 추가하지 않고 value 값이 대체되며 추가한 순서대로 읽습니다.\n\n*   참고 용도 : Map 과 Object 차이 정리\n\n\n\n| (●’◡’●)         | Map                                                                     | Object                                                                                                                                                                                                                                    |\n|-----------------|-------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 의도치 않은 key | Map은 명시적으로 제공한 키 외에는 어떤 키도 가지지 않습니다.            | Object는 프로토타입을 가지므로 기본 키가 존재할 수 있습니다. 주의하지 않으면 직접 제공한 키와 충돌할 수도 있습니다. * 참고: ES5부터, 프로토타입으로 인한 키 충돌은 Object.create(null)로 해결할 수 있지만, 실제로 쓰이는 경우는 적습니다. |\n| key 타입        | Map의 key는 함수, 객체 등을 포함한 모든 값이 가능합니다.                | Object의 키는 반드시 String 또는 Symbol이어야 합니다.                                                                                                                                                                                     |\n| key 정렬        | Map의 키는 정렬됩니다. 따라서 Map의 이터레이션은 삽입순으로 이뤄집니다. | Object의 키는 정렬되지 않습니다. * 참고: ECMAScript 2015 이후로, 객체도 문자열과 Symbol 키의 생성 순서를 유지합니다. ECMEScript 2015 명세를 준수하는 JavaScript 엔진에서 문자열 키만 가진 객체를 순회하면 삽입 순을 따라갑니다.           |\n| 크기            | Map의 항목 수는 size 속성을 통해 쉽게 알아낼 수 있습니다.               | Object의 항목 수는 직접 알아내야 합니다.                                                                                                                                                                                                  |\n| 이터러블        | Map은 이터러블이므로, 바로 이터레이션할 수 있습니다.                    | Object를 순회하려면 먼저 모든 키를 알아낸 후, 그 키의 배열을 순회해야 합니다.                                                                                                                                                             |\n| 성능            | 잦은 키-값 쌍의 추가와 제거에서 더 좋은 성능을 보입니다.                | 키-값 쌍의 빈번한 추가 및 제거에 최적화되지 않았습니다.                                                                                                                                                                                   |\n\n*   Map 오브젝트가 편리하고 유용성이 높습니다. 그러나 모든 상황에 해당하지는 않습니다.  \n    Map 오브젝트는 컬렉션에서 효율이 높습니다. key, value 형태이고 이터러블일 때는 Map 오브젝트를 사용하고  \n    값과 함수가 혼합된 형태면 Object 오브젝트를 사용하는 것이 좋습니다.\n\n* * *\n\n<h2 id=\"new_Map\">new Map(): Map 인스턴스 생성</h2>\n\nMap 인스턴스를 생성하여 반환합니다.\n\n> new Map([iterable])\n\n*   iterable 선택적 파라미터  \n    요소가 키-값 쌍인 Array 또는 다른 순회 가능한 객체(예: [[1, ‘one’], [2, ‘two’]]). 각 키-값 쌍은 새로운 Map에 포함됩니다.\n\n```js for-of\nlet emptyMap = new Map();  \n  \n1. let newMap = new Map([  \n [\"key1\", \"value1\"],  \n [\"key2\", \"value2\"],  \n [\"key1\", \"sports\"]  \n]);  \n  \n2. for (var element of newMap){  \n console.log(element);  \n};  \n// [\"key1\", \"sports\"]  \n// [\"key2\", \"value2\"]  \n```\n\n*   emptyMap = new Map()과 같이 파라미터를 작성하지 않고 Map 인스턴스를 생성할 수 있습니다. [key, value]가 없는 형태로 생성됩니다. 이는 Map 오브젝트 메서드를 사용하여 [key, value]를 추가해줄 수 있습니다.\n\n1.  Map() 파라미터는 이터러블 오브젝트이어야 하므로 대괄호[]를 작성하였으며, 그 안에 [“key1”, “value1”]형태로 작성하였습니다. key1이 key가 되고 value이 value가 됩니다. 다음은 newMap 인스턴스 구조입니다.\n    <img src=\"/images/newMapInstance.JPG\">\n    \n    1.  &#95;&#95;proto&#95;&#95;: Map은 new Map()을 실행하면 Map.prototype에 연결된 프로퍼티로 인스턴스를 생성한다는 것을 암시합니다.\n        \n    2.  0: {“key1” => “sports”}에서 0은 인덱스이며 Map() 파라미터에 작성한 값이 아닙니다. Map은 엔진이 파라미터의 이터러블 오브젝트에 작성한 순서로 인덱스를 부여합니다. 따라서 작성한 순서대로 읽을 수 있습니다.\n        \n\n2.  for-of 문 출력 결과가 [“key1”, “sports”], [“key2”, “value2”]  \n    두 개만 표시된 이유는 첫 번째의 “key1”과 세 번째 “key1”이 같기 때문입니다.  \n    이와 같이 key 값이 같으면 추가되지 않고, value 값을 나중에 작성한 값으로 대체합니다.\n\n~~인덱스를 부여하여 작성한 순서로 저장하더라도 key 값의 일치 여부를 체크 하기 때문에 첫 번째의 value값을 세 번째의 value 값으로 대체하고 세 번째를 추가하지 않습니다.~~\n\n```js for.Each()\nlet newMap = new Map([  \n [\"key1\", \"value1\"],  \n [\"key2\", \"value2\"]  \n]);  \n  \nfor (var element of newMap){  \n element.forEach((keyValue, index) => {  \n console.log(index, keyValue);  \n });  \n};  \n  \nfor (var [key, value] of newMap){  \n console.log(key, value);  \n};  \n/*  \n0 \"key1\"  \n1 \"value1\"  \n0 \"key2\"  \n1 \"value2\"  \nkey1 value1  \nkey2 value2  \n*/  \n```\n\n*   Map() 파라미터에 이터러블 오브젝트를 작성하고, 그 안에 두 개의 [key, value]를 작성했습니다. for-of 문을 반복하면 element 변수에 [“key1”, “value1”]형태로 설정됩니다. 배열 형태이므로 for.Each() 메서드를 사용할 수 있습니다. for.Each()가 [“key1”, “value1”]형태를 첫 번째로 읽으면 for.Each() 의 keyValue 파라미터에 “key1”이 설정되고 index에 0이 설정됩니다. 두 번째를 읽으면 keyValue 파라미터에 “value1”이 설정되고 index에 1이 설정됩니다.\n\n*   for-of 문을 처음 반복하면 [“key1”, “value1”]이 읽힙니다. 이때 “key1”이 for-of 문의 [key, value]에서 key에 설정되고 “value1”이 value에 설정됩니다. key, value가 모두 설정되므로 앞 코드와 같이 forEach()로 배열을 전개하지 않아도 됩니다.\n\n```js Error\n1. try {  \n new Map([\"one\", 1]);  \n}catch(e){  \n console.log(\"[one, 1]\");  \n};  \n  \n2. try {  \n new Map({one: 1});  \n}catch(e){  \n console.log(\"{one: 1}\");  \n};  \n  \n3. let newMap = new Map([{one: 1}]);  \nconsole.log(newMap);  \n// [one, 1]  \n// {one: 1}  \n// {undefined => undefined}  \n```\n\n1.  Map() 파라미터에 이터러블 오브젝트를 작성하고 그 안에 배열로 엘리먼트를 작성합니다.  \n    [“one”, 1]에서 대괄호[]가 이터러블이므로 이를 제외하면 “one”, 1 형태가 되어 에러가 발생합니다.  \n    [[“one”, 1]]형태로 작성해야 합니다.\n\n2.  Map() 파라미터에 key,value를 작성하지만, {key: value} 형태로 작성할 수 없으며 TypeError가 발생합니다.  \n    [[“one”, 1]]형태로 작성해야 합니다.\n\n3.  Map() 파라미터에 대괄호[]를 작성하고, 그 안에 {one: 1}형태로 작성하면 에러가 발생하지 않고  \n    Map 인스턴스가 생성됩니다. 하지만 실행 결과에서 볼 수 있듯이 key,value에 값이 설정되지 않아 undefined가 출력됩니다.\n\n* * *\n\n<h2 id=\"Map_set\">set(): key와 value 설정</h2>\n\nset() 메서드는 Map 오브젝트에서 주어진 key를 가진 엘리먼트를 추가하고, key에 엘리먼트가 이미 있다면 대체합니다.\n\n> Map.prototype.set(key, value)\n\n첫 번째 파라미터에 key가 될 String 또는 오브젝트를 작성하고 두 번째 파라미터에 value를 작성합니다.  \nset()을 실행한 후 Map인스턴스를 반환하므로 메서드 체인(method chain)형태로 계속해서 Map 인스턴스의 메서드를 호출할 수 있습니다.\n\n```js set\n1. const newMap = new Map();  \n2. newMap.set(\"one\", 100);  \n3. console.log(newMap.size);  \n  \n4. newMap.set({}, \"오브젝트\");  \n5. newMap.set(function(){}, \"Function\");  \n  \n6. newMap.set(new Number(\"123\"), \"인스턴스\");  \n7. newMap.set(NaN, \"Not a Number\");  \n  \n8. for (var [key, value] of newMap) {  \n console.log(key, value);  \n};  \n/*  \n1  \none 100  \nObject {} : \"오브젝트\"  \nfunction (){} : \"Function\"  \nNumber {[[PrimitiveValue]]: 123} \"인스턴스\"  \nNaN \"Not a Number\"  \n*/  \n```\n\n1.  new Map() 파라미터를 작성하지 않고 인스턴스를 생성했습니다.  \n    인스턴스에 key, value를 추가할 수는 있으나 인스턴스를 삭제할 수는 없습니다.\n\n2.  newMap.set()으로 newMap 인스턴스에 [key, value]값을 추가합니다. “one”이 키가 되고 100이 value가 됩니다.\n\n3.  size 프로퍼티는 Map 인스턴스의 엘리먼트 수를 반환합니다. 이 값은 바꿀 수 없습니다. 바꾸면 TypeError가 발생합니다.\n\n4.  set()의 첫 번째 파라미터에 Object {}가 key가 되고, 두 번째 파라미터인 “오브젝트”가 value가 됩니다.\n\n5.  set()의 첫 번째 파라미터인 function 오브젝트가 key가 되고 두 번째 파라미터인 “Function”이 value가 됩니다.\n\n6.  첫 번째 파라미터인 Number 인스턴스가 key가 되고, 두 번째 파라미터인 “인스턴스”가 value가 됩니다.\n\n7.  첫 번째 파라미터인 NaN이 key가 되고, 두 번째 파라미터인 “Not a Number”가 value가 됩니다. NaN을 key로 사용할 수 있습니다.\n    \n8.  newMap 인스턴스를 for-of 문으로 반복하면 추가한 순서대로 전개됩니다.\n    \n    *   newMap의 인스턴스 구조\n        \n            Map(5)\n                [[Entries]]\n                0: {\"one\" => 100}\n                1: {Object => \"오브젝트\"}\n                2: {function(){} => \"Function\"}\n                3: {Number => \"인스턴스\"}\n                4: {NaN => \"Not a Number\"}\n        \n\n```js\nconst newMap = new Map();  \nnewMap.set(\"one\", 100);  \nnewMap.set(\"one\", 123);  \n  \nlet sportsObj = {sports: \"스포츠\"};  \n1. newMap.set(sportsObj, \"Sports Object\");  \n2. newMap.set(sportsObj, \"Sports Object-변경\");  \n  \n3. newMap.set({}, \"Object-1\");  \n4. newMap.set({}, \"Object-2\");  \n```\n\n*   newMap 인스턴스에 “one”을 key로 하여 100을 설정한 후, 다시 “one”을 key로 하여 123을 설정하면  \n    key 값이 같으므로 100 이 123으로 대체됩니다.\n\n1.  set()의 첫 번째 파라미터에 Object 오브젝트를 직접 작성하지 않고 별도로 작성한 sportsObj 오브젝트를 지정했습니다. sportsObj가 key가 되고 “Sports Object”가 value가 됩니다.\n\n2.  sportsObj key가 존재하므로 value가 대체됩니다.\n\n3.  set()의 첫 번째 파라미터에 Object 리터럴 {}을 지정했습니다. Object 오브젝트를 생성하여 메모리에 저장하고 newMap 인스턴스에 key로 사용하여 “Object-1”을 추가합니다.\n\n4.  set()의 첫 번째 파라미터에 Object 리터럴을 지정해도 앞의 key값과 중복되지 않습니다.  \n    왜냐하면 첫 번째 파라미터의 Object 리터럴이 새로운 Object 오브젝트를 생성하므로 앞의 코드와 다른 메모리 주소에 저장되기 때문입니다. 앞의 Object 오브젝트가 저장된 메모리 주소와 생성한 Object 오브젝트의 메모리 주소가 다르므로 value가 대체되지 않고 추가됩니다.\n\n* * *\n\n<h2 id=\"Map_get\">get(): key가 같은 value 반환</h2>\n\nMap 인스턴스에서 key 값이 같은 value를 반환합니다.\n\n> Map.prototype.get(key)\n\n파라미터에 검색할 key 값을 작성합니다. 파라미터의 key가 Map 인스턴스에 존재하면 value를 반환하고, 존재하지 않으면 undefined를 반환합니다. key의 값 타입까지 체크합니다 (123 와 “123”은 같지 않습니다.)\n\n```js get()\nconst newMap = new Map();  \n1. newMap.set(\"one\", 100);  \nconsole.log(newMap.get(\"one\"));  \n  \n2. console.log(newMap.get(\"two\"));  \n  \n3. let sportsObj = {sports: \"스포츠\"};  \nnewMap.set(sportsObj, \"Sports Object\");  \nconsole.log(newMap.get(sportsObj));  \n//100  \n//undefined  \n//Sports Object  \n```\n\n1.  set()을 실행하면 [“one”, 100]형태로 등록됩니다. get() 파라미터에 검색할 key 값을 작성합니다. “one”이 newMap 인스턴스에 존재하므로 value인 100을 반환합니다.\n\n2.  get()의 파라미터 값인 “two”가 newMap 인스턴스 key에 존재하지 않으므로 undefined 입니다.\n\n3.  set()의 첫 번째 파라미터에 sportsObj의 메모리 주소를 key로 지정하여 newMap 인스턴스에 추가합니다.  \n    다시 sportsObj의 메모리 주소를 파라미터 값으로 지정하여 get()을 수행하므로 “Sports Object”가 반환됩니다.\n\n```js\nconst newMap = new Map();  \n  \n1. newMap.set({}, \"Object\");  \nconsole.log(newMap.get({}));  \n  \n2. newMap.set(123, \"값 123\");  \nconsole.log(newMap.get(123));  \nconsole.log(newMap.get(\"123\"));  \n  \n3. newMap.set(NaN, \"Not a Number\");  \nconsole.log(newMap.get(NaN));  \n// undefined  \n// 값 123  \n// undefined  \n// Not a Number  \n```\n\n1.  set() 파라미터인 Object 오브젝트와 get() 파라미터인 Object 오브젝트의 메모리 주소가 다름으로 undefined를 반환합니다.\n\n2.  get(123)으로 검색하면 key 의 타입까지 체크하여 value를 반환합니다.  \n    get(“123”)으로 값을 구하면 “123”이 String 타입이므로 타입이 같지않습니다. undefined가 반환됩니다.\n\n3.  set()의 파라미터에 NaN을 지정하고 get()의 파라미터에 NaN을 지정하면 key 값이 같으므로 value 값을 반환합니다. ~~ES5에서 (NaN === NaN) 비교 결과가 true가 아닌 문제가 있었지만 Map 오브젝트에 반영되었습니다.~~\n\n* * *\n\n<h2 id=\"Map_has\">has(): key 존재 여부</h2>\n\nMap 인스턴스에서 key 값의 존재 여부를 반환합니다.\n\n> Map.prototype.has(key)\n\nkey 값이 존재하면 true, 아니라면 false를 반환합니다.\n\n```js\nconst newMap = new Map();  \nnewMap.set(\"one\", 100);  \n  \nconsole.log(newMap.has(\"one\"));  \n// true  \n```\n\n*   key 를 비교한다는 점은 get()과 같습니다.  \n    get()은 해당 key의 value를 반환.  \n    has()는 key값 존재 여부를 체크, true/false 값을 반환합니다.\n\n* * *\n\n<h2 id=\"Map_entries\">entries(): 이터레이터 오브젝트 생성</h2>\n\n[key, value]를 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Map.prototype.entries()\n\n생성한 이터레이터 오브젝트에 next()를 호출하면 [key, value]를 반환합니다.  \nnext()를 호출할 때마다 Map 인스턴스에 추가한 순서대로 읽힙니다.\n\n```js\nconst newMap = new Map([  \n [\"key1\", \"value1\"],  \n [\"key2\", \"value2\"]  \n]);  \n  \nlet iteratorObj = newMap.entries();  \n  \nlet result = iteratorObj.next();  \nconsole.log(result);  \n  \nconsole.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \n// Object {value: Array[2], done: false}  \n// Object {value: Array[2], done: false}  \n// Object {value: undefined, done: true}  \n```\n\n1.  new Map()으로 두 개의 엘리먼트를 가진 Map 인스턴스를 생성합니다.  \n    생성한 Map 인스턴스의 entries()를 호출하여 이터러블 오브젝트를 생성하고 반환합니다.\n\n2.  next()를 호출하면 첫 번째의 [“key1”, “value1”]를 {value: Array[2], done: false} 형태의 value에 설정하여 반환합니다. Array[2]로 표시된 이유는 [“key1”, “value1”] 형태이기 때문입니다.\n\n* * *\n\n<h2 id=\"Map_keys\">keys(): key 반환 이터레이터 오브젝트 생성</h2>\n\nkey 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Map.prototype.keys()\n\n생성한 이터레이터 오브젝트의 next()를 호출하면 [key, value]형태에서 key 값만 반환합니다.  \nMap 인스턴스에 추가한 순서대로 읽힙니다.\n\n```js\nconst newMap = new Map([  \n [\"key1\", \"value1\"]  \n]);  \nnewMap.set({}, \"오브젝트\");  \n  \n1. let iteratorObj = newMap.keys();  \n2. console.log(iteratorObj.next());  \n  \n3. console.log(iteratorObj.next());  \n// Object {value: \"key1\", done:false}  \n// Object {value: Object, done:false}  \n```\n\n1.  newMap.keys()로 key 값만 반환하는 이터레이터 오브젝트를 생성해 iteratorObj에 할당합니다.\n\n2.  next()를 호출하면 [“key1”, “value1”]에서 “key1”을 {value: “key1”, done:false} 형태로  \n    value에 설정하여 반환합니다.\n\n3.  ({}, “오브젝트”) 형태로 추가했으므로 Object 오브젝트가 key가 됩니다.  \n    {value: Object, done: false} 형태가 반환됩니다.\n\n* * *\n\n<h2 id=\"Map_values\">values(): value 반환 이터레이터 오브젝트 생성</h2>\n\nvalue 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Map.prototype.values()\n\n생성한 이터레이터 오브젝트의 next()를 호출하면 value 값 만 반환합니다.\n\n```js\nconst newMap = new Map([  \n [\"key1\", \"value1\"]  \n]);  \nnewMap.set({}, \"오브젝트\");  \n  \n1. let iteratorObj = newMap.values();  \n2. console.log(iteratorObj.next());  \n  \n3. console.log(iteratorObj.next());  \n// Object {value: \"value1\", done: false}  \n// Object {value: \"오브젝트\", done: false}  \n```\n\n1.  newMap.values()로 value 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n2.  next()를 호출하면 [“key1”, “value1”]에서 “value1”을 {value: “value1”, done: false}의 value에 설정하여 반환합니다.\n\n3.  “오브젝트”가 value가 됩니다. {value: “오브젝트”, done:false} 형태로 반환됩니다.\n\n* * *\n\n<h2 id=\"Map_forEach\">forEach(): 엘리먼트마다 콜백 함수 호출</h2>\n\nMap 인스턴스를 반복할 때 마다 callback 함수를 호출합니다.\n\n> Map.prototype.forEach(function)\n\n첫 번째 파라미터에 반복할 때마다 호출할 콜백 함수를 작성합니다.\n\n두 번째 파라미터는 선택적 파라미터로 콜백 함수에서 this로 참조할 오브젝트를 지정합니다.\n\n### 중요 포인트\n\nforEach()는 호출할 때마다 세 개의 파라미터를 넘겨줍니다.\n\n1.  [key, value]에서 value\n2.  [key, value]에서 key\n3.  실행 중인 Map 인스턴스\n\n`key, value 순서가 아닌 value, key 순서입니다.`\n\n```js\nconst newMap = new Map([  \n [\"key1\", \"value1\"],  \n [{}, \"오브젝트\"]  \n]);  \n  \nnewMap.forEach((value, key, map) => {  \n console.log(key, value);  \n});  \n// key1 value1  \n// Object { } \"오브젝트\"  \n```\n\n*   forEach()가 처음 호출되면 [“key1”, “value1”]을 읽으며 파라미터 value에 “value1”이 설정되고 파라미터 key에 “key1”이 설정됩니다. 세 번째의 map 파라미터에 newMap 인스턴스가 설정됩니다.  \n    두 번째 호출 역시 마찬가지로 설정됩니다.\n\n* * *\n\n<h2 id=\"Map_delete\">delete(): 엘리먼트 삭제</h2>\n\nMap 인스턴스에서 key 값이 같은 엘리먼트를 삭제합니다.\n\n> Map.prototype.delete(key)\n\n파라미터에 삭제할 key 값을 지정합니다. Map 인스턴스에 같은 key가 존재하면 엘리먼트를 삭제하고 true를 반환합니다. key값이 존재하지 않으면 false를 반환합니다.\n\n```js\nconst newMap = new Map([  \n [\"key1\", \"value1\"],  \n [{}, \"오브젝트\"]  \n]);  \nlet sportsObj = {};  \nnewMap.set(sportsObj, \"추가\");  \n  \n1. console.log(newMap.delete(\"key1\"));  \n2. console.log(newMap.delete({}));  \n3. console.log(newMap.delete(sportsObj));  \n//true  \n//false  \n//true  \n```\n\n1.  delete() 파라미터에 작성한 “key1”이 newMap 인스턴스에 존재하므로 [“key1”, “value1”] 엘리먼트를 삭제하고 true를 반환합니다.\n\n2.  delete() 파라미터에 작성한 Object 오브젝트{}가 newMap 인스턴스에 존재하는 것처럼 보이지만,  \n    새로운 Object 오브젝트를 생성하여 메모리에 저장하므로 newMap 인스턴스에 저장된 Object 오브젝트와 메모리 주소가 달라서 삭제하지 못합니다. false가 반환됩니다.\n\n3.  delete() 파라미터의 sportsObj와 newMap 인스턴스의 sportsObj가 같은 메모리 주소를 참조하므로 삭제가 되며 true를 반환합니다.\n\n* * *\n\n<h2 id=\"Map_clear\">clear(): 모든 key, value 지움</h2>\n\nMap 인스턴스의 모든 [key, value]를 지웁니다.\n\n> Map.prototype.clear()\n\nMap 인스턴스를 삭제하는 것이 아니라 [key, value]만 지웁니다.  \n나중에 Map 인스턴스에 [key, value]를 추가해 줄 수 있습니다.\n\n```js\nconst newMap = new Map([  \n [\"key1\", \"value1\"],  \n [{}, \"오브젝트\"]  \n]);  \n  \n1. console.log(newMap.size);  \n  \nnewMap.clear();  \n2. console.log(newMap.size);  \n//0  \n//2  \n```\n\n1.  size 프로퍼티는 newMap 인스턴스의 [key, value]엘리먼트 수를 반환합니다. 2가 출력됩니다.\n\n2.  clear()는 newMap 인스턴스의 모든 [key, value]를 지웁니다. 따라서 size 값으로 0이 출력됩니다.\n\n* * *\n\n<h2 id=\"Map_Symbol_iterator\">Symbol.iterator(): 이터레이터 오브젝트 생성</h2>\n\n이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Map.prototype.[Symbol.iterator]\n\n생성한 이터레이터 오브젝트의 next()를 호출하면 Map 인스턴스에 작성된 순서대로 [key, value]를 반환합니다.  \nMap.prototype.entries()와 같습니다.\n\n```js\nlet newMap = new Map([  \n [\"1\", \"music\"],  \n [\"2\", \"sports\"]  \n]);  \n  \n1. let iteratorObj = newMap[Symbol.iterator]();  \n  \n2. console.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \n// Object {value: Array[2], done: false}  \n// Object {value: Array[2], done: false}  \n```\n\n1.  newMap 인스턴스의 Symbol.iterator를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.\n\n2.  next()를 호출할 때마다 [“1”, “music”] 과 [“2”, “sports”]를 순서대로 읽어  \n    {value: Array[2], done: false} 형태로 반환합니다.  \n    Array[2]에 읽은 [key, value]가 설정됩니다.\n","source":"_posts/Map 오브젝트 -ECMAScriprt.md","raw":"---\ntitle: Map 오브젝트 -ECMAScript\ndate: 2020-04-10 09:48:25\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\nMap 오브젝트는 Object 오브젝트와 비슷하지만,  \n다양한 타입을 프로퍼티 키로 사용할 수 있는 점이 다릅니다.\n\n*   Map 오브젝트\n    *   [개요](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#MapObjcet)\n    *   [new Map(): Map 인스턴스 생성](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#new_Map)\n    *   [set(): key와 value 설정](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_set)\n    *   [get(): key가 같은 value 반환](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_get)\n    *   [has(): key 존재 여부](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_has)\n    *   [entries(): 이터레이터 오브젝트 생성](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_entries)\n    *   [keys(): key 반환 이터레이터 오브젝트 생성](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_keys)\n    *   [values(): value 반환 이터레이터 오브젝트 생성](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_values)\n    *   [forEach(): 엘리먼트마다 콜백 함수 호출](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_forEach)\n    *   [delete(): 엘리먼트 삭제](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_delete)\n    *   [clear(): 모든 key,value 지움](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_clear)\n    *   [Symbol.iterator(): 이터레이터 오브젝트 생성](/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_Symbol_iterator)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"MapObjcet\">개요</h2>\n\nMap 오브젝트는 key와 value로 구성됩니다. key, value  \nObject 오브젝트의 key 타입은 String 또는 Symbol이지만  \nMap 오브젝트는 아무 객체와 원시값(Object,Function 등등)이라도 key 와 value로 사용할 수 있습니다.  \nkey 와 value 값을 저장하며 각 쌍의 삽입 순서도 기억합니다.\n\nMap 오브젝트는 key, value로 구성되지만 {key: value}형태로 작성하지 않고,  \n[“key”, “value”]와 같이 이터러블 형태로 작성합니다.\n\n<mark>key에 다양한 타입을 작성할 수 있는 것과 이러터블 형태로 작성하는 것이  \nMap 오브젝트와 Object 오브젝트의 차이입니다.</mark>\n\nMap 오브젝트는 key 값이 같으면 추가하지 않고 value 값이 대체되며 추가한 순서대로 읽습니다.\n\n*   참고 용도 : Map 과 Object 차이 정리\n\n\n\n| (●’◡’●)         | Map                                                                     | Object                                                                                                                                                                                                                                    |\n|-----------------|-------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 의도치 않은 key | Map은 명시적으로 제공한 키 외에는 어떤 키도 가지지 않습니다.            | Object는 프로토타입을 가지므로 기본 키가 존재할 수 있습니다. 주의하지 않으면 직접 제공한 키와 충돌할 수도 있습니다. * 참고: ES5부터, 프로토타입으로 인한 키 충돌은 Object.create(null)로 해결할 수 있지만, 실제로 쓰이는 경우는 적습니다. |\n| key 타입        | Map의 key는 함수, 객체 등을 포함한 모든 값이 가능합니다.                | Object의 키는 반드시 String 또는 Symbol이어야 합니다.                                                                                                                                                                                     |\n| key 정렬        | Map의 키는 정렬됩니다. 따라서 Map의 이터레이션은 삽입순으로 이뤄집니다. | Object의 키는 정렬되지 않습니다. * 참고: ECMAScript 2015 이후로, 객체도 문자열과 Symbol 키의 생성 순서를 유지합니다. ECMEScript 2015 명세를 준수하는 JavaScript 엔진에서 문자열 키만 가진 객체를 순회하면 삽입 순을 따라갑니다.           |\n| 크기            | Map의 항목 수는 size 속성을 통해 쉽게 알아낼 수 있습니다.               | Object의 항목 수는 직접 알아내야 합니다.                                                                                                                                                                                                  |\n| 이터러블        | Map은 이터러블이므로, 바로 이터레이션할 수 있습니다.                    | Object를 순회하려면 먼저 모든 키를 알아낸 후, 그 키의 배열을 순회해야 합니다.                                                                                                                                                             |\n| 성능            | 잦은 키-값 쌍의 추가와 제거에서 더 좋은 성능을 보입니다.                | 키-값 쌍의 빈번한 추가 및 제거에 최적화되지 않았습니다.                                                                                                                                                                                   |\n\n*   Map 오브젝트가 편리하고 유용성이 높습니다. 그러나 모든 상황에 해당하지는 않습니다.  \n    Map 오브젝트는 컬렉션에서 효율이 높습니다. key, value 형태이고 이터러블일 때는 Map 오브젝트를 사용하고  \n    값과 함수가 혼합된 형태면 Object 오브젝트를 사용하는 것이 좋습니다.\n\n* * *\n\n<h2 id=\"new_Map\">new Map(): Map 인스턴스 생성</h2>\n\nMap 인스턴스를 생성하여 반환합니다.\n\n> new Map([iterable])\n\n*   iterable 선택적 파라미터  \n    요소가 키-값 쌍인 Array 또는 다른 순회 가능한 객체(예: [[1, ‘one’], [2, ‘two’]]). 각 키-값 쌍은 새로운 Map에 포함됩니다.\n\n```js for-of\nlet emptyMap = new Map();  \n  \n1. let newMap = new Map([  \n [\"key1\", \"value1\"],  \n [\"key2\", \"value2\"],  \n [\"key1\", \"sports\"]  \n]);  \n  \n2. for (var element of newMap){  \n console.log(element);  \n};  \n// [\"key1\", \"sports\"]  \n// [\"key2\", \"value2\"]  \n```\n\n*   emptyMap = new Map()과 같이 파라미터를 작성하지 않고 Map 인스턴스를 생성할 수 있습니다. [key, value]가 없는 형태로 생성됩니다. 이는 Map 오브젝트 메서드를 사용하여 [key, value]를 추가해줄 수 있습니다.\n\n1.  Map() 파라미터는 이터러블 오브젝트이어야 하므로 대괄호[]를 작성하였으며, 그 안에 [“key1”, “value1”]형태로 작성하였습니다. key1이 key가 되고 value이 value가 됩니다. 다음은 newMap 인스턴스 구조입니다.\n    <img src=\"/images/newMapInstance.JPG\">\n    \n    1.  &#95;&#95;proto&#95;&#95;: Map은 new Map()을 실행하면 Map.prototype에 연결된 프로퍼티로 인스턴스를 생성한다는 것을 암시합니다.\n        \n    2.  0: {“key1” => “sports”}에서 0은 인덱스이며 Map() 파라미터에 작성한 값이 아닙니다. Map은 엔진이 파라미터의 이터러블 오브젝트에 작성한 순서로 인덱스를 부여합니다. 따라서 작성한 순서대로 읽을 수 있습니다.\n        \n\n2.  for-of 문 출력 결과가 [“key1”, “sports”], [“key2”, “value2”]  \n    두 개만 표시된 이유는 첫 번째의 “key1”과 세 번째 “key1”이 같기 때문입니다.  \n    이와 같이 key 값이 같으면 추가되지 않고, value 값을 나중에 작성한 값으로 대체합니다.\n\n~~인덱스를 부여하여 작성한 순서로 저장하더라도 key 값의 일치 여부를 체크 하기 때문에 첫 번째의 value값을 세 번째의 value 값으로 대체하고 세 번째를 추가하지 않습니다.~~\n\n```js for.Each()\nlet newMap = new Map([  \n [\"key1\", \"value1\"],  \n [\"key2\", \"value2\"]  \n]);  \n  \nfor (var element of newMap){  \n element.forEach((keyValue, index) => {  \n console.log(index, keyValue);  \n });  \n};  \n  \nfor (var [key, value] of newMap){  \n console.log(key, value);  \n};  \n/*  \n0 \"key1\"  \n1 \"value1\"  \n0 \"key2\"  \n1 \"value2\"  \nkey1 value1  \nkey2 value2  \n*/  \n```\n\n*   Map() 파라미터에 이터러블 오브젝트를 작성하고, 그 안에 두 개의 [key, value]를 작성했습니다. for-of 문을 반복하면 element 변수에 [“key1”, “value1”]형태로 설정됩니다. 배열 형태이므로 for.Each() 메서드를 사용할 수 있습니다. for.Each()가 [“key1”, “value1”]형태를 첫 번째로 읽으면 for.Each() 의 keyValue 파라미터에 “key1”이 설정되고 index에 0이 설정됩니다. 두 번째를 읽으면 keyValue 파라미터에 “value1”이 설정되고 index에 1이 설정됩니다.\n\n*   for-of 문을 처음 반복하면 [“key1”, “value1”]이 읽힙니다. 이때 “key1”이 for-of 문의 [key, value]에서 key에 설정되고 “value1”이 value에 설정됩니다. key, value가 모두 설정되므로 앞 코드와 같이 forEach()로 배열을 전개하지 않아도 됩니다.\n\n```js Error\n1. try {  \n new Map([\"one\", 1]);  \n}catch(e){  \n console.log(\"[one, 1]\");  \n};  \n  \n2. try {  \n new Map({one: 1});  \n}catch(e){  \n console.log(\"{one: 1}\");  \n};  \n  \n3. let newMap = new Map([{one: 1}]);  \nconsole.log(newMap);  \n// [one, 1]  \n// {one: 1}  \n// {undefined => undefined}  \n```\n\n1.  Map() 파라미터에 이터러블 오브젝트를 작성하고 그 안에 배열로 엘리먼트를 작성합니다.  \n    [“one”, 1]에서 대괄호[]가 이터러블이므로 이를 제외하면 “one”, 1 형태가 되어 에러가 발생합니다.  \n    [[“one”, 1]]형태로 작성해야 합니다.\n\n2.  Map() 파라미터에 key,value를 작성하지만, {key: value} 형태로 작성할 수 없으며 TypeError가 발생합니다.  \n    [[“one”, 1]]형태로 작성해야 합니다.\n\n3.  Map() 파라미터에 대괄호[]를 작성하고, 그 안에 {one: 1}형태로 작성하면 에러가 발생하지 않고  \n    Map 인스턴스가 생성됩니다. 하지만 실행 결과에서 볼 수 있듯이 key,value에 값이 설정되지 않아 undefined가 출력됩니다.\n\n* * *\n\n<h2 id=\"Map_set\">set(): key와 value 설정</h2>\n\nset() 메서드는 Map 오브젝트에서 주어진 key를 가진 엘리먼트를 추가하고, key에 엘리먼트가 이미 있다면 대체합니다.\n\n> Map.prototype.set(key, value)\n\n첫 번째 파라미터에 key가 될 String 또는 오브젝트를 작성하고 두 번째 파라미터에 value를 작성합니다.  \nset()을 실행한 후 Map인스턴스를 반환하므로 메서드 체인(method chain)형태로 계속해서 Map 인스턴스의 메서드를 호출할 수 있습니다.\n\n```js set\n1. const newMap = new Map();  \n2. newMap.set(\"one\", 100);  \n3. console.log(newMap.size);  \n  \n4. newMap.set({}, \"오브젝트\");  \n5. newMap.set(function(){}, \"Function\");  \n  \n6. newMap.set(new Number(\"123\"), \"인스턴스\");  \n7. newMap.set(NaN, \"Not a Number\");  \n  \n8. for (var [key, value] of newMap) {  \n console.log(key, value);  \n};  \n/*  \n1  \none 100  \nObject {} : \"오브젝트\"  \nfunction (){} : \"Function\"  \nNumber {[[PrimitiveValue]]: 123} \"인스턴스\"  \nNaN \"Not a Number\"  \n*/  \n```\n\n1.  new Map() 파라미터를 작성하지 않고 인스턴스를 생성했습니다.  \n    인스턴스에 key, value를 추가할 수는 있으나 인스턴스를 삭제할 수는 없습니다.\n\n2.  newMap.set()으로 newMap 인스턴스에 [key, value]값을 추가합니다. “one”이 키가 되고 100이 value가 됩니다.\n\n3.  size 프로퍼티는 Map 인스턴스의 엘리먼트 수를 반환합니다. 이 값은 바꿀 수 없습니다. 바꾸면 TypeError가 발생합니다.\n\n4.  set()의 첫 번째 파라미터에 Object {}가 key가 되고, 두 번째 파라미터인 “오브젝트”가 value가 됩니다.\n\n5.  set()의 첫 번째 파라미터인 function 오브젝트가 key가 되고 두 번째 파라미터인 “Function”이 value가 됩니다.\n\n6.  첫 번째 파라미터인 Number 인스턴스가 key가 되고, 두 번째 파라미터인 “인스턴스”가 value가 됩니다.\n\n7.  첫 번째 파라미터인 NaN이 key가 되고, 두 번째 파라미터인 “Not a Number”가 value가 됩니다. NaN을 key로 사용할 수 있습니다.\n    \n8.  newMap 인스턴스를 for-of 문으로 반복하면 추가한 순서대로 전개됩니다.\n    \n    *   newMap의 인스턴스 구조\n        \n            Map(5)\n                [[Entries]]\n                0: {\"one\" => 100}\n                1: {Object => \"오브젝트\"}\n                2: {function(){} => \"Function\"}\n                3: {Number => \"인스턴스\"}\n                4: {NaN => \"Not a Number\"}\n        \n\n```js\nconst newMap = new Map();  \nnewMap.set(\"one\", 100);  \nnewMap.set(\"one\", 123);  \n  \nlet sportsObj = {sports: \"스포츠\"};  \n1. newMap.set(sportsObj, \"Sports Object\");  \n2. newMap.set(sportsObj, \"Sports Object-변경\");  \n  \n3. newMap.set({}, \"Object-1\");  \n4. newMap.set({}, \"Object-2\");  \n```\n\n*   newMap 인스턴스에 “one”을 key로 하여 100을 설정한 후, 다시 “one”을 key로 하여 123을 설정하면  \n    key 값이 같으므로 100 이 123으로 대체됩니다.\n\n1.  set()의 첫 번째 파라미터에 Object 오브젝트를 직접 작성하지 않고 별도로 작성한 sportsObj 오브젝트를 지정했습니다. sportsObj가 key가 되고 “Sports Object”가 value가 됩니다.\n\n2.  sportsObj key가 존재하므로 value가 대체됩니다.\n\n3.  set()의 첫 번째 파라미터에 Object 리터럴 {}을 지정했습니다. Object 오브젝트를 생성하여 메모리에 저장하고 newMap 인스턴스에 key로 사용하여 “Object-1”을 추가합니다.\n\n4.  set()의 첫 번째 파라미터에 Object 리터럴을 지정해도 앞의 key값과 중복되지 않습니다.  \n    왜냐하면 첫 번째 파라미터의 Object 리터럴이 새로운 Object 오브젝트를 생성하므로 앞의 코드와 다른 메모리 주소에 저장되기 때문입니다. 앞의 Object 오브젝트가 저장된 메모리 주소와 생성한 Object 오브젝트의 메모리 주소가 다르므로 value가 대체되지 않고 추가됩니다.\n\n* * *\n\n<h2 id=\"Map_get\">get(): key가 같은 value 반환</h2>\n\nMap 인스턴스에서 key 값이 같은 value를 반환합니다.\n\n> Map.prototype.get(key)\n\n파라미터에 검색할 key 값을 작성합니다. 파라미터의 key가 Map 인스턴스에 존재하면 value를 반환하고, 존재하지 않으면 undefined를 반환합니다. key의 값 타입까지 체크합니다 (123 와 “123”은 같지 않습니다.)\n\n```js get()\nconst newMap = new Map();  \n1. newMap.set(\"one\", 100);  \nconsole.log(newMap.get(\"one\"));  \n  \n2. console.log(newMap.get(\"two\"));  \n  \n3. let sportsObj = {sports: \"스포츠\"};  \nnewMap.set(sportsObj, \"Sports Object\");  \nconsole.log(newMap.get(sportsObj));  \n//100  \n//undefined  \n//Sports Object  \n```\n\n1.  set()을 실행하면 [“one”, 100]형태로 등록됩니다. get() 파라미터에 검색할 key 값을 작성합니다. “one”이 newMap 인스턴스에 존재하므로 value인 100을 반환합니다.\n\n2.  get()의 파라미터 값인 “two”가 newMap 인스턴스 key에 존재하지 않으므로 undefined 입니다.\n\n3.  set()의 첫 번째 파라미터에 sportsObj의 메모리 주소를 key로 지정하여 newMap 인스턴스에 추가합니다.  \n    다시 sportsObj의 메모리 주소를 파라미터 값으로 지정하여 get()을 수행하므로 “Sports Object”가 반환됩니다.\n\n```js\nconst newMap = new Map();  \n  \n1. newMap.set({}, \"Object\");  \nconsole.log(newMap.get({}));  \n  \n2. newMap.set(123, \"값 123\");  \nconsole.log(newMap.get(123));  \nconsole.log(newMap.get(\"123\"));  \n  \n3. newMap.set(NaN, \"Not a Number\");  \nconsole.log(newMap.get(NaN));  \n// undefined  \n// 값 123  \n// undefined  \n// Not a Number  \n```\n\n1.  set() 파라미터인 Object 오브젝트와 get() 파라미터인 Object 오브젝트의 메모리 주소가 다름으로 undefined를 반환합니다.\n\n2.  get(123)으로 검색하면 key 의 타입까지 체크하여 value를 반환합니다.  \n    get(“123”)으로 값을 구하면 “123”이 String 타입이므로 타입이 같지않습니다. undefined가 반환됩니다.\n\n3.  set()의 파라미터에 NaN을 지정하고 get()의 파라미터에 NaN을 지정하면 key 값이 같으므로 value 값을 반환합니다. ~~ES5에서 (NaN === NaN) 비교 결과가 true가 아닌 문제가 있었지만 Map 오브젝트에 반영되었습니다.~~\n\n* * *\n\n<h2 id=\"Map_has\">has(): key 존재 여부</h2>\n\nMap 인스턴스에서 key 값의 존재 여부를 반환합니다.\n\n> Map.prototype.has(key)\n\nkey 값이 존재하면 true, 아니라면 false를 반환합니다.\n\n```js\nconst newMap = new Map();  \nnewMap.set(\"one\", 100);  \n  \nconsole.log(newMap.has(\"one\"));  \n// true  \n```\n\n*   key 를 비교한다는 점은 get()과 같습니다.  \n    get()은 해당 key의 value를 반환.  \n    has()는 key값 존재 여부를 체크, true/false 값을 반환합니다.\n\n* * *\n\n<h2 id=\"Map_entries\">entries(): 이터레이터 오브젝트 생성</h2>\n\n[key, value]를 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Map.prototype.entries()\n\n생성한 이터레이터 오브젝트에 next()를 호출하면 [key, value]를 반환합니다.  \nnext()를 호출할 때마다 Map 인스턴스에 추가한 순서대로 읽힙니다.\n\n```js\nconst newMap = new Map([  \n [\"key1\", \"value1\"],  \n [\"key2\", \"value2\"]  \n]);  \n  \nlet iteratorObj = newMap.entries();  \n  \nlet result = iteratorObj.next();  \nconsole.log(result);  \n  \nconsole.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \n// Object {value: Array[2], done: false}  \n// Object {value: Array[2], done: false}  \n// Object {value: undefined, done: true}  \n```\n\n1.  new Map()으로 두 개의 엘리먼트를 가진 Map 인스턴스를 생성합니다.  \n    생성한 Map 인스턴스의 entries()를 호출하여 이터러블 오브젝트를 생성하고 반환합니다.\n\n2.  next()를 호출하면 첫 번째의 [“key1”, “value1”]를 {value: Array[2], done: false} 형태의 value에 설정하여 반환합니다. Array[2]로 표시된 이유는 [“key1”, “value1”] 형태이기 때문입니다.\n\n* * *\n\n<h2 id=\"Map_keys\">keys(): key 반환 이터레이터 오브젝트 생성</h2>\n\nkey 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Map.prototype.keys()\n\n생성한 이터레이터 오브젝트의 next()를 호출하면 [key, value]형태에서 key 값만 반환합니다.  \nMap 인스턴스에 추가한 순서대로 읽힙니다.\n\n```js\nconst newMap = new Map([  \n [\"key1\", \"value1\"]  \n]);  \nnewMap.set({}, \"오브젝트\");  \n  \n1. let iteratorObj = newMap.keys();  \n2. console.log(iteratorObj.next());  \n  \n3. console.log(iteratorObj.next());  \n// Object {value: \"key1\", done:false}  \n// Object {value: Object, done:false}  \n```\n\n1.  newMap.keys()로 key 값만 반환하는 이터레이터 오브젝트를 생성해 iteratorObj에 할당합니다.\n\n2.  next()를 호출하면 [“key1”, “value1”]에서 “key1”을 {value: “key1”, done:false} 형태로  \n    value에 설정하여 반환합니다.\n\n3.  ({}, “오브젝트”) 형태로 추가했으므로 Object 오브젝트가 key가 됩니다.  \n    {value: Object, done: false} 형태가 반환됩니다.\n\n* * *\n\n<h2 id=\"Map_values\">values(): value 반환 이터레이터 오브젝트 생성</h2>\n\nvalue 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Map.prototype.values()\n\n생성한 이터레이터 오브젝트의 next()를 호출하면 value 값 만 반환합니다.\n\n```js\nconst newMap = new Map([  \n [\"key1\", \"value1\"]  \n]);  \nnewMap.set({}, \"오브젝트\");  \n  \n1. let iteratorObj = newMap.values();  \n2. console.log(iteratorObj.next());  \n  \n3. console.log(iteratorObj.next());  \n// Object {value: \"value1\", done: false}  \n// Object {value: \"오브젝트\", done: false}  \n```\n\n1.  newMap.values()로 value 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n2.  next()를 호출하면 [“key1”, “value1”]에서 “value1”을 {value: “value1”, done: false}의 value에 설정하여 반환합니다.\n\n3.  “오브젝트”가 value가 됩니다. {value: “오브젝트”, done:false} 형태로 반환됩니다.\n\n* * *\n\n<h2 id=\"Map_forEach\">forEach(): 엘리먼트마다 콜백 함수 호출</h2>\n\nMap 인스턴스를 반복할 때 마다 callback 함수를 호출합니다.\n\n> Map.prototype.forEach(function)\n\n첫 번째 파라미터에 반복할 때마다 호출할 콜백 함수를 작성합니다.\n\n두 번째 파라미터는 선택적 파라미터로 콜백 함수에서 this로 참조할 오브젝트를 지정합니다.\n\n### 중요 포인트\n\nforEach()는 호출할 때마다 세 개의 파라미터를 넘겨줍니다.\n\n1.  [key, value]에서 value\n2.  [key, value]에서 key\n3.  실행 중인 Map 인스턴스\n\n`key, value 순서가 아닌 value, key 순서입니다.`\n\n```js\nconst newMap = new Map([  \n [\"key1\", \"value1\"],  \n [{}, \"오브젝트\"]  \n]);  \n  \nnewMap.forEach((value, key, map) => {  \n console.log(key, value);  \n});  \n// key1 value1  \n// Object { } \"오브젝트\"  \n```\n\n*   forEach()가 처음 호출되면 [“key1”, “value1”]을 읽으며 파라미터 value에 “value1”이 설정되고 파라미터 key에 “key1”이 설정됩니다. 세 번째의 map 파라미터에 newMap 인스턴스가 설정됩니다.  \n    두 번째 호출 역시 마찬가지로 설정됩니다.\n\n* * *\n\n<h2 id=\"Map_delete\">delete(): 엘리먼트 삭제</h2>\n\nMap 인스턴스에서 key 값이 같은 엘리먼트를 삭제합니다.\n\n> Map.prototype.delete(key)\n\n파라미터에 삭제할 key 값을 지정합니다. Map 인스턴스에 같은 key가 존재하면 엘리먼트를 삭제하고 true를 반환합니다. key값이 존재하지 않으면 false를 반환합니다.\n\n```js\nconst newMap = new Map([  \n [\"key1\", \"value1\"],  \n [{}, \"오브젝트\"]  \n]);  \nlet sportsObj = {};  \nnewMap.set(sportsObj, \"추가\");  \n  \n1. console.log(newMap.delete(\"key1\"));  \n2. console.log(newMap.delete({}));  \n3. console.log(newMap.delete(sportsObj));  \n//true  \n//false  \n//true  \n```\n\n1.  delete() 파라미터에 작성한 “key1”이 newMap 인스턴스에 존재하므로 [“key1”, “value1”] 엘리먼트를 삭제하고 true를 반환합니다.\n\n2.  delete() 파라미터에 작성한 Object 오브젝트{}가 newMap 인스턴스에 존재하는 것처럼 보이지만,  \n    새로운 Object 오브젝트를 생성하여 메모리에 저장하므로 newMap 인스턴스에 저장된 Object 오브젝트와 메모리 주소가 달라서 삭제하지 못합니다. false가 반환됩니다.\n\n3.  delete() 파라미터의 sportsObj와 newMap 인스턴스의 sportsObj가 같은 메모리 주소를 참조하므로 삭제가 되며 true를 반환합니다.\n\n* * *\n\n<h2 id=\"Map_clear\">clear(): 모든 key, value 지움</h2>\n\nMap 인스턴스의 모든 [key, value]를 지웁니다.\n\n> Map.prototype.clear()\n\nMap 인스턴스를 삭제하는 것이 아니라 [key, value]만 지웁니다.  \n나중에 Map 인스턴스에 [key, value]를 추가해 줄 수 있습니다.\n\n```js\nconst newMap = new Map([  \n [\"key1\", \"value1\"],  \n [{}, \"오브젝트\"]  \n]);  \n  \n1. console.log(newMap.size);  \n  \nnewMap.clear();  \n2. console.log(newMap.size);  \n//0  \n//2  \n```\n\n1.  size 프로퍼티는 newMap 인스턴스의 [key, value]엘리먼트 수를 반환합니다. 2가 출력됩니다.\n\n2.  clear()는 newMap 인스턴스의 모든 [key, value]를 지웁니다. 따라서 size 값으로 0이 출력됩니다.\n\n* * *\n\n<h2 id=\"Map_Symbol_iterator\">Symbol.iterator(): 이터레이터 오브젝트 생성</h2>\n\n이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Map.prototype.[Symbol.iterator]\n\n생성한 이터레이터 오브젝트의 next()를 호출하면 Map 인스턴스에 작성된 순서대로 [key, value]를 반환합니다.  \nMap.prototype.entries()와 같습니다.\n\n```js\nlet newMap = new Map([  \n [\"1\", \"music\"],  \n [\"2\", \"sports\"]  \n]);  \n  \n1. let iteratorObj = newMap[Symbol.iterator]();  \n  \n2. console.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \n// Object {value: Array[2], done: false}  \n// Object {value: Array[2], done: false}  \n```\n\n1.  newMap 인스턴스의 Symbol.iterator를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.\n\n2.  next()를 호출할 때마다 [“1”, “music”] 과 [“2”, “sports”]를 순서대로 읽어  \n    {value: Array[2], done: false} 형태로 반환합니다.  \n    Array[2]에 읽은 [key, value]가 설정됩니다.\n","slug":"Map 오브젝트 -ECMAScriprt","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrsi000uqgvqh2vjfrw3","content":"<p>Map 오브젝트는 Object 오브젝트와 비슷하지만,<br>다양한 타입을 프로퍼티 키로 사용할 수 있는 점이 다릅니다.</p>\n<ul>\n<li>Map 오브젝트<ul>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#MapObjcet\">개요</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#new_Map\">new Map(): Map 인스턴스 생성</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_set\">set(): key와 value 설정</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_get\">get(): key가 같은 value 반환</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_has\">has(): key 존재 여부</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_entries\">entries(): 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_keys\">keys(): key 반환 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_values\">values(): value 반환 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_forEach\">forEach(): 엘리먼트마다 콜백 함수 호출</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_delete\">delete(): 엘리먼트 삭제</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_clear\">clear(): 모든 key,value 지움</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_Symbol_iterator\">Symbol.iterator(): 이터레이터 오브젝트 생성</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"MapObjcet\">개요</h2>\n\n<p>Map 오브젝트는 key와 value로 구성됩니다. key, value<br>Object 오브젝트의 key 타입은 String 또는 Symbol이지만<br>Map 오브젝트는 아무 객체와 원시값(Object,Function 등등)이라도 key 와 value로 사용할 수 있습니다.<br>key 와 value 값을 저장하며 각 쌍의 삽입 순서도 기억합니다.</p>\n<p>Map 오브젝트는 key, value로 구성되지만 {key: value}형태로 작성하지 않고,<br>[“key”, “value”]와 같이 이터러블 형태로 작성합니다.</p>\n<p><mark>key에 다양한 타입을 작성할 수 있는 것과 이러터블 형태로 작성하는 것이<br>Map 오브젝트와 Object 오브젝트의 차이입니다.</mark></p>\n<p>Map 오브젝트는 key 값이 같으면 추가하지 않고 value 값이 대체되며 추가한 순서대로 읽습니다.</p>\n<ul>\n<li>참고 용도 : Map 과 Object 차이 정리</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>(●’◡’●)</th>\n<th>Map</th>\n<th>Object</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>의도치 않은 key</td>\n<td>Map은 명시적으로 제공한 키 외에는 어떤 키도 가지지 않습니다.</td>\n<td>Object는 프로토타입을 가지므로 기본 키가 존재할 수 있습니다. 주의하지 않으면 직접 제공한 키와 충돌할 수도 있습니다. * 참고: ES5부터, 프로토타입으로 인한 키 충돌은 Object.create(null)로 해결할 수 있지만, 실제로 쓰이는 경우는 적습니다.</td>\n</tr>\n<tr>\n<td>key 타입</td>\n<td>Map의 key는 함수, 객체 등을 포함한 모든 값이 가능합니다.</td>\n<td>Object의 키는 반드시 String 또는 Symbol이어야 합니다.</td>\n</tr>\n<tr>\n<td>key 정렬</td>\n<td>Map의 키는 정렬됩니다. 따라서 Map의 이터레이션은 삽입순으로 이뤄집니다.</td>\n<td>Object의 키는 정렬되지 않습니다. * 참고: ECMAScript 2015 이후로, 객체도 문자열과 Symbol 키의 생성 순서를 유지합니다. ECMEScript 2015 명세를 준수하는 JavaScript 엔진에서 문자열 키만 가진 객체를 순회하면 삽입 순을 따라갑니다.</td>\n</tr>\n<tr>\n<td>크기</td>\n<td>Map의 항목 수는 size 속성을 통해 쉽게 알아낼 수 있습니다.</td>\n<td>Object의 항목 수는 직접 알아내야 합니다.</td>\n</tr>\n<tr>\n<td>이터러블</td>\n<td>Map은 이터러블이므로, 바로 이터레이션할 수 있습니다.</td>\n<td>Object를 순회하려면 먼저 모든 키를 알아낸 후, 그 키의 배열을 순회해야 합니다.</td>\n</tr>\n<tr>\n<td>성능</td>\n<td>잦은 키-값 쌍의 추가와 제거에서 더 좋은 성능을 보입니다.</td>\n<td>키-값 쌍의 빈번한 추가 및 제거에 최적화되지 않았습니다.</td>\n</tr>\n</tbody></table>\n<ul>\n<li>Map 오브젝트가 편리하고 유용성이 높습니다. 그러나 모든 상황에 해당하지는 않습니다.<br>Map 오브젝트는 컬렉션에서 효율이 높습니다. key, value 형태이고 이터러블일 때는 Map 오브젝트를 사용하고<br>값과 함수가 혼합된 형태면 Object 오브젝트를 사용하는 것이 좋습니다.</li>\n</ul>\n<hr>\n<h2 id=\"new_Map\">new Map(): Map 인스턴스 생성</h2>\n\n<p>Map 인스턴스를 생성하여 반환합니다.</p>\n<blockquote>\n<p>new Map([iterable])</p>\n</blockquote>\n<ul>\n<li>iterable 선택적 파라미터<br>요소가 키-값 쌍인 Array 또는 다른 순회 가능한 객체(예: [[1, ‘one’], [2, ‘two’]]). 각 키-값 쌍은 새로운 Map에 포함됩니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>for-of</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> emptyMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>],  </span><br><span class=\"line\"> [<span class=\"string\">\"key2\"</span>, <span class=\"string\">\"value2\"</span>],  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"sports\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> element <span class=\"keyword\">of</span> newMap)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(element);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// [\"key1\", \"sports\"]  </span></span><br><span class=\"line\"><span class=\"comment\">// [\"key2\", \"value2\"]</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>emptyMap = new Map()과 같이 파라미터를 작성하지 않고 Map 인스턴스를 생성할 수 있습니다. [key, value]가 없는 형태로 생성됩니다. 이는 Map 오브젝트 메서드를 사용하여 [key, value]를 추가해줄 수 있습니다.</li>\n</ul>\n<ol>\n<li><p>Map() 파라미터는 이터러블 오브젝트이어야 하므로 대괄호[]를 작성하였으며, 그 안에 [“key1”, “value1”]형태로 작성하였습니다. key1이 key가 되고 value이 value가 됩니다. 다음은 newMap 인스턴스 구조입니다.</p>\n<img src=\"/images/newMapInstance.JPG\">\n\n<ol>\n<li><p>&#95;&#95;proto&#95;&#95;: Map은 new Map()을 실행하면 Map.prototype에 연결된 프로퍼티로 인스턴스를 생성한다는 것을 암시합니다.</p>\n</li>\n<li><p>0: {“key1” =&gt; “sports”}에서 0은 인덱스이며 Map() 파라미터에 작성한 값이 아닙니다. Map은 엔진이 파라미터의 이터러블 오브젝트에 작성한 순서로 인덱스를 부여합니다. 따라서 작성한 순서대로 읽을 수 있습니다.</p>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"2\">\n<li>for-of 문 출력 결과가 [“key1”, “sports”], [“key2”, “value2”]<br>두 개만 표시된 이유는 첫 번째의 “key1”과 세 번째 “key1”이 같기 때문입니다.<br>이와 같이 key 값이 같으면 추가되지 않고, value 값을 나중에 작성한 값으로 대체합니다.</li>\n</ol>\n<p><del>인덱스를 부여하여 작성한 순서로 저장하더라도 key 값의 일치 여부를 체크 하기 때문에 첫 번째의 value값을 세 번째의 value 값으로 대체하고 세 번째를 추가하지 않습니다.</del></p>\n<figure class=\"highlight js\"><figcaption><span>for.Each()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>],  </span><br><span class=\"line\"> [<span class=\"string\">\"key2\"</span>, <span class=\"string\">\"value2\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> element <span class=\"keyword\">of</span> newMap)&#123;  </span><br><span class=\"line\"> element.forEach(<span class=\"function\">(<span class=\"params\">keyValue, index</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(index, keyValue);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> [key, value] <span class=\"keyword\">of</span> newMap)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, value);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">0 \"key1\"  </span></span><br><span class=\"line\"><span class=\"comment\">1 \"value1\"  </span></span><br><span class=\"line\"><span class=\"comment\">0 \"key2\"  </span></span><br><span class=\"line\"><span class=\"comment\">1 \"value2\"  </span></span><br><span class=\"line\"><span class=\"comment\">key1 value1  </span></span><br><span class=\"line\"><span class=\"comment\">key2 value2  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Map() 파라미터에 이터러블 오브젝트를 작성하고, 그 안에 두 개의 [key, value]를 작성했습니다. for-of 문을 반복하면 element 변수에 [“key1”, “value1”]형태로 설정됩니다. 배열 형태이므로 for.Each() 메서드를 사용할 수 있습니다. for.Each()가 [“key1”, “value1”]형태를 첫 번째로 읽으면 for.Each() 의 keyValue 파라미터에 “key1”이 설정되고 index에 0이 설정됩니다. 두 번째를 읽으면 keyValue 파라미터에 “value1”이 설정되고 index에 1이 설정됩니다.</p>\n</li>\n<li><p>for-of 문을 처음 반복하면 [“key1”, “value1”]이 읽힙니다. 이때 “key1”이 for-of 문의 [key, value]에서 key에 설정되고 “value1”이 value에 설정됩니다. key, value가 모두 설정되므로 앞 코드와 같이 forEach()로 배열을 전개하지 않아도 됩니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>Error</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([<span class=\"string\">\"one\"</span>, <span class=\"number\">1</span>]);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(e)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"[one, 1]\"</span>);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(&#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>&#125;);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(e)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"&#123;one: 1&#125;\"</span>);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([&#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>&#125;]);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap);  </span><br><span class=\"line\"><span class=\"comment\">// [one, 1]  </span></span><br><span class=\"line\"><span class=\"comment\">// &#123;one: 1&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// &#123;undefined =&gt; undefined&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Map() 파라미터에 이터러블 오브젝트를 작성하고 그 안에 배열로 엘리먼트를 작성합니다.<br>[“one”, 1]에서 대괄호[]가 이터러블이므로 이를 제외하면 “one”, 1 형태가 되어 에러가 발생합니다.<br>[[“one”, 1]]형태로 작성해야 합니다.</p>\n</li>\n<li><p>Map() 파라미터에 key,value를 작성하지만, {key: value} 형태로 작성할 수 없으며 TypeError가 발생합니다.<br>[[“one”, 1]]형태로 작성해야 합니다.</p>\n</li>\n<li><p>Map() 파라미터에 대괄호[]를 작성하고, 그 안에 {one: 1}형태로 작성하면 에러가 발생하지 않고<br>Map 인스턴스가 생성됩니다. 하지만 실행 결과에서 볼 수 있듯이 key,value에 값이 설정되지 않아 undefined가 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_set\">set(): key와 value 설정</h2>\n\n<p>set() 메서드는 Map 오브젝트에서 주어진 key를 가진 엘리먼트를 추가하고, key에 엘리먼트가 이미 있다면 대체합니다.</p>\n<blockquote>\n<p>Map.prototype.set(key, value)</p>\n</blockquote>\n<p>첫 번째 파라미터에 key가 될 String 또는 오브젝트를 작성하고 두 번째 파라미터에 value를 작성합니다.<br>set()을 실행한 후 Map인스턴스를 반환하므로 메서드 체인(method chain)형태로 계속해서 Map 인스턴스의 메서드를 호출할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>set</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();  </span><br><span class=\"line\"><span class=\"number\">2.</span> newMap.set(<span class=\"string\">\"one\"</span>, <span class=\"number\">100</span>);  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(newMap.size);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> newMap.set(&#123;&#125;, <span class=\"string\">\"오브젝트\"</span>);  </span><br><span class=\"line\"><span class=\"number\">5.</span> newMap.set(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;, <span class=\"string\">\"Function\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">6.</span> newMap.set(<span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"string\">\"123\"</span>), <span class=\"string\">\"인스턴스\"</span>);  </span><br><span class=\"line\"><span class=\"number\">7.</span> newMap.set(<span class=\"literal\">NaN</span>, <span class=\"string\">\"Not a Number\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">8.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> [key, value] <span class=\"keyword\">of</span> newMap) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, value);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">1  </span></span><br><span class=\"line\"><span class=\"comment\">one 100  </span></span><br><span class=\"line\"><span class=\"comment\">Object &#123;&#125; : \"오브젝트\"  </span></span><br><span class=\"line\"><span class=\"comment\">function ()&#123;&#125; : \"Function\"  </span></span><br><span class=\"line\"><span class=\"comment\">Number &#123;[[PrimitiveValue]]: 123&#125; \"인스턴스\"  </span></span><br><span class=\"line\"><span class=\"comment\">NaN \"Not a Number\"  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>new Map() 파라미터를 작성하지 않고 인스턴스를 생성했습니다.<br>인스턴스에 key, value를 추가할 수는 있으나 인스턴스를 삭제할 수는 없습니다.</p>\n</li>\n<li><p>newMap.set()으로 newMap 인스턴스에 [key, value]값을 추가합니다. “one”이 키가 되고 100이 value가 됩니다.</p>\n</li>\n<li><p>size 프로퍼티는 Map 인스턴스의 엘리먼트 수를 반환합니다. 이 값은 바꿀 수 없습니다. 바꾸면 TypeError가 발생합니다.</p>\n</li>\n<li><p>set()의 첫 번째 파라미터에 Object {}가 key가 되고, 두 번째 파라미터인 “오브젝트”가 value가 됩니다.</p>\n</li>\n<li><p>set()의 첫 번째 파라미터인 function 오브젝트가 key가 되고 두 번째 파라미터인 “Function”이 value가 됩니다.</p>\n</li>\n<li><p>첫 번째 파라미터인 Number 인스턴스가 key가 되고, 두 번째 파라미터인 “인스턴스”가 value가 됩니다.</p>\n</li>\n<li><p>첫 번째 파라미터인 NaN이 key가 되고, 두 번째 파라미터인 “Not a Number”가 value가 됩니다. NaN을 key로 사용할 수 있습니다.</p>\n</li>\n<li><p>newMap 인스턴스를 for-of 문으로 반복하면 추가한 순서대로 전개됩니다.</p>\n<ul>\n<li><p>newMap의 인스턴스 구조</p>\n<pre><code>Map(5)\n    [[Entries]]\n    0: {&quot;one&quot; =&gt; 100}\n    1: {Object =&gt; &quot;오브젝트&quot;}\n    2: {function(){} =&gt; &quot;Function&quot;}\n    3: {Number =&gt; &quot;인스턴스&quot;}\n    4: {NaN =&gt; &quot;Not a Number&quot;}</code></pre></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();  </span><br><span class=\"line\">newMap.set(<span class=\"string\">\"one\"</span>, <span class=\"number\">100</span>);  </span><br><span class=\"line\">newMap.set(<span class=\"string\">\"one\"</span>, <span class=\"number\">123</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> sportsObj = &#123;<span class=\"attr\">sports</span>: <span class=\"string\">\"스포츠\"</span>&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> newMap.set(sportsObj, <span class=\"string\">\"Sports Object\"</span>);  </span><br><span class=\"line\"><span class=\"number\">2.</span> newMap.set(sportsObj, <span class=\"string\">\"Sports Object-변경\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> newMap.set(&#123;&#125;, <span class=\"string\">\"Object-1\"</span>);  </span><br><span class=\"line\"><span class=\"number\">4.</span> newMap.set(&#123;&#125;, <span class=\"string\">\"Object-2\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>newMap 인스턴스에 “one”을 key로 하여 100을 설정한 후, 다시 “one”을 key로 하여 123을 설정하면<br>key 값이 같으므로 100 이 123으로 대체됩니다.</li>\n</ul>\n<ol>\n<li><p>set()의 첫 번째 파라미터에 Object 오브젝트를 직접 작성하지 않고 별도로 작성한 sportsObj 오브젝트를 지정했습니다. sportsObj가 key가 되고 “Sports Object”가 value가 됩니다.</p>\n</li>\n<li><p>sportsObj key가 존재하므로 value가 대체됩니다.</p>\n</li>\n<li><p>set()의 첫 번째 파라미터에 Object 리터럴 {}을 지정했습니다. Object 오브젝트를 생성하여 메모리에 저장하고 newMap 인스턴스에 key로 사용하여 “Object-1”을 추가합니다.</p>\n</li>\n<li><p>set()의 첫 번째 파라미터에 Object 리터럴을 지정해도 앞의 key값과 중복되지 않습니다.<br>왜냐하면 첫 번째 파라미터의 Object 리터럴이 새로운 Object 오브젝트를 생성하므로 앞의 코드와 다른 메모리 주소에 저장되기 때문입니다. 앞의 Object 오브젝트가 저장된 메모리 주소와 생성한 Object 오브젝트의 메모리 주소가 다르므로 value가 대체되지 않고 추가됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_get\">get(): key가 같은 value 반환</h2>\n\n<p>Map 인스턴스에서 key 값이 같은 value를 반환합니다.</p>\n<blockquote>\n<p>Map.prototype.get(key)</p>\n</blockquote>\n<p>파라미터에 검색할 key 값을 작성합니다. 파라미터의 key가 Map 인스턴스에 존재하면 value를 반환하고, 존재하지 않으면 undefined를 반환합니다. key의 값 타입까지 체크합니다 (123 와 “123”은 같지 않습니다.)</p>\n<figure class=\"highlight js\"><figcaption><span>get()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();  </span><br><span class=\"line\"><span class=\"number\">1.</span> newMap.set(<span class=\"string\">\"one\"</span>, <span class=\"number\">100</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap.get(<span class=\"string\">\"one\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(newMap.get(<span class=\"string\">\"two\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> sportsObj = &#123;<span class=\"attr\">sports</span>: <span class=\"string\">\"스포츠\"</span>&#125;;  </span><br><span class=\"line\">newMap.set(sportsObj, <span class=\"string\">\"Sports Object\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap.get(sportsObj));  </span><br><span class=\"line\"><span class=\"comment\">//100  </span></span><br><span class=\"line\"><span class=\"comment\">//undefined  </span></span><br><span class=\"line\"><span class=\"comment\">//Sports Object</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>set()을 실행하면 [“one”, 100]형태로 등록됩니다. get() 파라미터에 검색할 key 값을 작성합니다. “one”이 newMap 인스턴스에 존재하므로 value인 100을 반환합니다.</p>\n</li>\n<li><p>get()의 파라미터 값인 “two”가 newMap 인스턴스 key에 존재하지 않으므로 undefined 입니다.</p>\n</li>\n<li><p>set()의 첫 번째 파라미터에 sportsObj의 메모리 주소를 key로 지정하여 newMap 인스턴스에 추가합니다.<br>다시 sportsObj의 메모리 주소를 파라미터 값으로 지정하여 get()을 수행하므로 “Sports Object”가 반환됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> newMap.set(&#123;&#125;, <span class=\"string\">\"Object\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap.get(&#123;&#125;));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> newMap.set(<span class=\"number\">123</span>, <span class=\"string\">\"값 123\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap.get(<span class=\"number\">123</span>));  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap.get(<span class=\"string\">\"123\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> newMap.set(<span class=\"literal\">NaN</span>, <span class=\"string\">\"Not a Number\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap.get(<span class=\"literal\">NaN</span>));  </span><br><span class=\"line\"><span class=\"comment\">// undefined  </span></span><br><span class=\"line\"><span class=\"comment\">// 값 123  </span></span><br><span class=\"line\"><span class=\"comment\">// undefined  </span></span><br><span class=\"line\"><span class=\"comment\">// Not a Number</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>set() 파라미터인 Object 오브젝트와 get() 파라미터인 Object 오브젝트의 메모리 주소가 다름으로 undefined를 반환합니다.</p>\n</li>\n<li><p>get(123)으로 검색하면 key 의 타입까지 체크하여 value를 반환합니다.<br>get(“123”)으로 값을 구하면 “123”이 String 타입이므로 타입이 같지않습니다. undefined가 반환됩니다.</p>\n</li>\n<li><p>set()의 파라미터에 NaN을 지정하고 get()의 파라미터에 NaN을 지정하면 key 값이 같으므로 value 값을 반환합니다. <del>ES5에서 (NaN === NaN) 비교 결과가 true가 아닌 문제가 있었지만 Map 오브젝트에 반영되었습니다.</del></p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_has\">has(): key 존재 여부</h2>\n\n<p>Map 인스턴스에서 key 값의 존재 여부를 반환합니다.</p>\n<blockquote>\n<p>Map.prototype.has(key)</p>\n</blockquote>\n<p>key 값이 존재하면 true, 아니라면 false를 반환합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();  </span><br><span class=\"line\">newMap.set(<span class=\"string\">\"one\"</span>, <span class=\"number\">100</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap.has(<span class=\"string\">\"one\"</span>));  </span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>key 를 비교한다는 점은 get()과 같습니다.<br>get()은 해당 key의 value를 반환.<br>has()는 key값 존재 여부를 체크, true/false 값을 반환합니다.</li>\n</ul>\n<hr>\n<h2 id=\"Map_entries\">entries(): 이터레이터 오브젝트 생성</h2>\n\n<p>[key, value]를 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Map.prototype.entries()</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트에 next()를 호출하면 [key, value]를 반환합니다.<br>next()를 호출할 때마다 Map 인스턴스에 추가한 순서대로 읽힙니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>],  </span><br><span class=\"line\"> [<span class=\"string\">\"key2\"</span>, <span class=\"string\">\"value2\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iteratorObj = newMap.entries();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = iteratorObj.next();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Array[2], done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Array[2], done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>new Map()으로 두 개의 엘리먼트를 가진 Map 인스턴스를 생성합니다.<br>생성한 Map 인스턴스의 entries()를 호출하여 이터러블 오브젝트를 생성하고 반환합니다.</p>\n</li>\n<li><p>next()를 호출하면 첫 번째의 [“key1”, “value1”]를 {value: Array[2], done: false} 형태의 value에 설정하여 반환합니다. Array[2]로 표시된 이유는 [“key1”, “value1”] 형태이기 때문입니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_keys\">keys(): key 반환 이터레이터 오브젝트 생성</h2>\n\n<p>key 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Map.prototype.keys()</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트의 next()를 호출하면 [key, value]형태에서 key 값만 반환합니다.<br>Map 인스턴스에 추가한 순서대로 읽힙니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">newMap.set(&#123;&#125;, <span class=\"string\">\"오브젝트\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> iteratorObj = newMap.keys();  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"key1\", done:false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Object, done:false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>newMap.keys()로 key 값만 반환하는 이터레이터 오브젝트를 생성해 iteratorObj에 할당합니다.</p>\n</li>\n<li><p>next()를 호출하면 [“key1”, “value1”]에서 “key1”을 {value: “key1”, done:false} 형태로<br>value에 설정하여 반환합니다.</p>\n</li>\n<li><p>({}, “오브젝트”) 형태로 추가했으므로 Object 오브젝트가 key가 됩니다.<br>{value: Object, done: false} 형태가 반환됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_values\">values(): value 반환 이터레이터 오브젝트 생성</h2>\n\n<p>value 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Map.prototype.values()</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트의 next()를 호출하면 value 값 만 반환합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">newMap.set(&#123;&#125;, <span class=\"string\">\"오브젝트\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> iteratorObj = newMap.values();  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"value1\", done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"오브젝트\", done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>newMap.values()로 value 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>next()를 호출하면 [“key1”, “value1”]에서 “value1”을 {value: “value1”, done: false}의 value에 설정하여 반환합니다.</p>\n</li>\n<li><p>“오브젝트”가 value가 됩니다. {value: “오브젝트”, done:false} 형태로 반환됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_forEach\">forEach(): 엘리먼트마다 콜백 함수 호출</h2>\n\n<p>Map 인스턴스를 반복할 때 마다 callback 함수를 호출합니다.</p>\n<blockquote>\n<p>Map.prototype.forEach(function)</p>\n</blockquote>\n<p>첫 번째 파라미터에 반복할 때마다 호출할 콜백 함수를 작성합니다.</p>\n<p>두 번째 파라미터는 선택적 파라미터로 콜백 함수에서 this로 참조할 오브젝트를 지정합니다.</p>\n<h3 id=\"중요-포인트\"><a href=\"#중요-포인트\" class=\"headerlink\" title=\"중요 포인트\"></a>중요 포인트</h3><p>forEach()는 호출할 때마다 세 개의 파라미터를 넘겨줍니다.</p>\n<ol>\n<li>[key, value]에서 value</li>\n<li>[key, value]에서 key</li>\n<li>실행 중인 Map 인스턴스</li>\n</ol>\n<p><code>key, value 순서가 아닌 value, key 순서입니다.</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>],  </span><br><span class=\"line\"> [&#123;&#125;, <span class=\"string\">\"오브젝트\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">  </span><br><span class=\"line\">newMap.forEach(<span class=\"function\">(<span class=\"params\">value, key, map</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, value);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"comment\">// key1 value1  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123; &#125; \"오브젝트\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>forEach()가 처음 호출되면 [“key1”, “value1”]을 읽으며 파라미터 value에 “value1”이 설정되고 파라미터 key에 “key1”이 설정됩니다. 세 번째의 map 파라미터에 newMap 인스턴스가 설정됩니다.<br>두 번째 호출 역시 마찬가지로 설정됩니다.</li>\n</ul>\n<hr>\n<h2 id=\"Map_delete\">delete(): 엘리먼트 삭제</h2>\n\n<p>Map 인스턴스에서 key 값이 같은 엘리먼트를 삭제합니다.</p>\n<blockquote>\n<p>Map.prototype.delete(key)</p>\n</blockquote>\n<p>파라미터에 삭제할 key 값을 지정합니다. Map 인스턴스에 같은 key가 존재하면 엘리먼트를 삭제하고 true를 반환합니다. key값이 존재하지 않으면 false를 반환합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>],  </span><br><span class=\"line\"> [&#123;&#125;, <span class=\"string\">\"오브젝트\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> sportsObj = &#123;&#125;;  </span><br><span class=\"line\">newMap.set(sportsObj, <span class=\"string\">\"추가\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(newMap.delete(<span class=\"string\">\"key1\"</span>));  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(newMap.delete(&#123;&#125;));  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(newMap.delete(sportsObj));  </span><br><span class=\"line\"><span class=\"comment\">//true  </span></span><br><span class=\"line\"><span class=\"comment\">//false  </span></span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>delete() 파라미터에 작성한 “key1”이 newMap 인스턴스에 존재하므로 [“key1”, “value1”] 엘리먼트를 삭제하고 true를 반환합니다.</p>\n</li>\n<li><p>delete() 파라미터에 작성한 Object 오브젝트{}가 newMap 인스턴스에 존재하는 것처럼 보이지만,<br>새로운 Object 오브젝트를 생성하여 메모리에 저장하므로 newMap 인스턴스에 저장된 Object 오브젝트와 메모리 주소가 달라서 삭제하지 못합니다. false가 반환됩니다.</p>\n</li>\n<li><p>delete() 파라미터의 sportsObj와 newMap 인스턴스의 sportsObj가 같은 메모리 주소를 참조하므로 삭제가 되며 true를 반환합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_clear\">clear(): 모든 key, value 지움</h2>\n\n<p>Map 인스턴스의 모든 [key, value]를 지웁니다.</p>\n<blockquote>\n<p>Map.prototype.clear()</p>\n</blockquote>\n<p>Map 인스턴스를 삭제하는 것이 아니라 [key, value]만 지웁니다.<br>나중에 Map 인스턴스에 [key, value]를 추가해 줄 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>],  </span><br><span class=\"line\"> [&#123;&#125;, <span class=\"string\">\"오브젝트\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(newMap.size);  </span><br><span class=\"line\">  </span><br><span class=\"line\">newMap.clear();  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(newMap.size);  </span><br><span class=\"line\"><span class=\"comment\">//0  </span></span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>size 프로퍼티는 newMap 인스턴스의 [key, value]엘리먼트 수를 반환합니다. 2가 출력됩니다.</p>\n</li>\n<li><p>clear()는 newMap 인스턴스의 모든 [key, value]를 지웁니다. 따라서 size 값으로 0이 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_Symbol_iterator\">Symbol.iterator(): 이터레이터 오브젝트 생성</h2>\n\n<p>이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Map.prototype.[Symbol.iterator]</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트의 next()를 호출하면 Map 인스턴스에 작성된 순서대로 [key, value]를 반환합니다.<br>Map.prototype.entries()와 같습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"1\"</span>, <span class=\"string\">\"music\"</span>],  </span><br><span class=\"line\"> [<span class=\"string\">\"2\"</span>, <span class=\"string\">\"sports\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> iteratorObj = newMap[<span class=\"built_in\">Symbol</span>.iterator]();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Array[2], done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Array[2], done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>newMap 인스턴스의 Symbol.iterator를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>next()를 호출할 때마다 [“1”, “music”] 과 [“2”, “sports”]를 순서대로 읽어<br>{value: Array[2], done: false} 형태로 반환합니다.<br>Array[2]에 읽은 [key, value]가 설정됩니다.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Map 오브젝트는 Object 오브젝트와 비슷하지만,<br>다양한 타입을 프로퍼티 키로 사용할 수 있는 점이 다릅니다.</p>\n<ul>\n<li>Map 오브젝트<ul>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#MapObjcet\">개요</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#new_Map\">new Map(): Map 인스턴스 생성</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_set\">set(): key와 value 설정</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_get\">get(): key가 같은 value 반환</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_has\">has(): key 존재 여부</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_entries\">entries(): 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_keys\">keys(): key 반환 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_values\">values(): value 반환 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_forEach\">forEach(): 엘리먼트마다 콜백 함수 호출</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_delete\">delete(): 엘리먼트 삭제</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_clear\">clear(): 모든 key,value 지움</a></li>\n<li><a href=\"/2020/04/10/Map%20오브젝트%20-ECMAScriprt/#Map_Symbol_iterator\">Symbol.iterator(): 이터레이터 오브젝트 생성</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"MapObjcet\">개요</h2>\n\n<p>Map 오브젝트는 key와 value로 구성됩니다. key, value<br>Object 오브젝트의 key 타입은 String 또는 Symbol이지만<br>Map 오브젝트는 아무 객체와 원시값(Object,Function 등등)이라도 key 와 value로 사용할 수 있습니다.<br>key 와 value 값을 저장하며 각 쌍의 삽입 순서도 기억합니다.</p>\n<p>Map 오브젝트는 key, value로 구성되지만 {key: value}형태로 작성하지 않고,<br>[“key”, “value”]와 같이 이터러블 형태로 작성합니다.</p>\n<p><mark>key에 다양한 타입을 작성할 수 있는 것과 이러터블 형태로 작성하는 것이<br>Map 오브젝트와 Object 오브젝트의 차이입니다.</mark></p>\n<p>Map 오브젝트는 key 값이 같으면 추가하지 않고 value 값이 대체되며 추가한 순서대로 읽습니다.</p>\n<ul>\n<li>참고 용도 : Map 과 Object 차이 정리</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>(●’◡’●)</th>\n<th>Map</th>\n<th>Object</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>의도치 않은 key</td>\n<td>Map은 명시적으로 제공한 키 외에는 어떤 키도 가지지 않습니다.</td>\n<td>Object는 프로토타입을 가지므로 기본 키가 존재할 수 있습니다. 주의하지 않으면 직접 제공한 키와 충돌할 수도 있습니다. * 참고: ES5부터, 프로토타입으로 인한 키 충돌은 Object.create(null)로 해결할 수 있지만, 실제로 쓰이는 경우는 적습니다.</td>\n</tr>\n<tr>\n<td>key 타입</td>\n<td>Map의 key는 함수, 객체 등을 포함한 모든 값이 가능합니다.</td>\n<td>Object의 키는 반드시 String 또는 Symbol이어야 합니다.</td>\n</tr>\n<tr>\n<td>key 정렬</td>\n<td>Map의 키는 정렬됩니다. 따라서 Map의 이터레이션은 삽입순으로 이뤄집니다.</td>\n<td>Object의 키는 정렬되지 않습니다. * 참고: ECMAScript 2015 이후로, 객체도 문자열과 Symbol 키의 생성 순서를 유지합니다. ECMEScript 2015 명세를 준수하는 JavaScript 엔진에서 문자열 키만 가진 객체를 순회하면 삽입 순을 따라갑니다.</td>\n</tr>\n<tr>\n<td>크기</td>\n<td>Map의 항목 수는 size 속성을 통해 쉽게 알아낼 수 있습니다.</td>\n<td>Object의 항목 수는 직접 알아내야 합니다.</td>\n</tr>\n<tr>\n<td>이터러블</td>\n<td>Map은 이터러블이므로, 바로 이터레이션할 수 있습니다.</td>\n<td>Object를 순회하려면 먼저 모든 키를 알아낸 후, 그 키의 배열을 순회해야 합니다.</td>\n</tr>\n<tr>\n<td>성능</td>\n<td>잦은 키-값 쌍의 추가와 제거에서 더 좋은 성능을 보입니다.</td>\n<td>키-값 쌍의 빈번한 추가 및 제거에 최적화되지 않았습니다.</td>\n</tr>\n</tbody></table>\n<ul>\n<li>Map 오브젝트가 편리하고 유용성이 높습니다. 그러나 모든 상황에 해당하지는 않습니다.<br>Map 오브젝트는 컬렉션에서 효율이 높습니다. key, value 형태이고 이터러블일 때는 Map 오브젝트를 사용하고<br>값과 함수가 혼합된 형태면 Object 오브젝트를 사용하는 것이 좋습니다.</li>\n</ul>\n<hr>\n<h2 id=\"new_Map\">new Map(): Map 인스턴스 생성</h2>\n\n<p>Map 인스턴스를 생성하여 반환합니다.</p>\n<blockquote>\n<p>new Map([iterable])</p>\n</blockquote>\n<ul>\n<li>iterable 선택적 파라미터<br>요소가 키-값 쌍인 Array 또는 다른 순회 가능한 객체(예: [[1, ‘one’], [2, ‘two’]]). 각 키-값 쌍은 새로운 Map에 포함됩니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>for-of</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> emptyMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>],  </span><br><span class=\"line\"> [<span class=\"string\">\"key2\"</span>, <span class=\"string\">\"value2\"</span>],  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"sports\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> element <span class=\"keyword\">of</span> newMap)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(element);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// [\"key1\", \"sports\"]  </span></span><br><span class=\"line\"><span class=\"comment\">// [\"key2\", \"value2\"]</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>emptyMap = new Map()과 같이 파라미터를 작성하지 않고 Map 인스턴스를 생성할 수 있습니다. [key, value]가 없는 형태로 생성됩니다. 이는 Map 오브젝트 메서드를 사용하여 [key, value]를 추가해줄 수 있습니다.</li>\n</ul>\n<ol>\n<li><p>Map() 파라미터는 이터러블 오브젝트이어야 하므로 대괄호[]를 작성하였으며, 그 안에 [“key1”, “value1”]형태로 작성하였습니다. key1이 key가 되고 value이 value가 됩니다. 다음은 newMap 인스턴스 구조입니다.</p>\n<img src=\"/images/newMapInstance.JPG\">\n\n<ol>\n<li><p>&#95;&#95;proto&#95;&#95;: Map은 new Map()을 실행하면 Map.prototype에 연결된 프로퍼티로 인스턴스를 생성한다는 것을 암시합니다.</p>\n</li>\n<li><p>0: {“key1” =&gt; “sports”}에서 0은 인덱스이며 Map() 파라미터에 작성한 값이 아닙니다. Map은 엔진이 파라미터의 이터러블 오브젝트에 작성한 순서로 인덱스를 부여합니다. 따라서 작성한 순서대로 읽을 수 있습니다.</p>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"2\">\n<li>for-of 문 출력 결과가 [“key1”, “sports”], [“key2”, “value2”]<br>두 개만 표시된 이유는 첫 번째의 “key1”과 세 번째 “key1”이 같기 때문입니다.<br>이와 같이 key 값이 같으면 추가되지 않고, value 값을 나중에 작성한 값으로 대체합니다.</li>\n</ol>\n<p><del>인덱스를 부여하여 작성한 순서로 저장하더라도 key 값의 일치 여부를 체크 하기 때문에 첫 번째의 value값을 세 번째의 value 값으로 대체하고 세 번째를 추가하지 않습니다.</del></p>\n<figure class=\"highlight js\"><figcaption><span>for.Each()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>],  </span><br><span class=\"line\"> [<span class=\"string\">\"key2\"</span>, <span class=\"string\">\"value2\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> element <span class=\"keyword\">of</span> newMap)&#123;  </span><br><span class=\"line\"> element.forEach(<span class=\"function\">(<span class=\"params\">keyValue, index</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(index, keyValue);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> [key, value] <span class=\"keyword\">of</span> newMap)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, value);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">0 \"key1\"  </span></span><br><span class=\"line\"><span class=\"comment\">1 \"value1\"  </span></span><br><span class=\"line\"><span class=\"comment\">0 \"key2\"  </span></span><br><span class=\"line\"><span class=\"comment\">1 \"value2\"  </span></span><br><span class=\"line\"><span class=\"comment\">key1 value1  </span></span><br><span class=\"line\"><span class=\"comment\">key2 value2  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Map() 파라미터에 이터러블 오브젝트를 작성하고, 그 안에 두 개의 [key, value]를 작성했습니다. for-of 문을 반복하면 element 변수에 [“key1”, “value1”]형태로 설정됩니다. 배열 형태이므로 for.Each() 메서드를 사용할 수 있습니다. for.Each()가 [“key1”, “value1”]형태를 첫 번째로 읽으면 for.Each() 의 keyValue 파라미터에 “key1”이 설정되고 index에 0이 설정됩니다. 두 번째를 읽으면 keyValue 파라미터에 “value1”이 설정되고 index에 1이 설정됩니다.</p>\n</li>\n<li><p>for-of 문을 처음 반복하면 [“key1”, “value1”]이 읽힙니다. 이때 “key1”이 for-of 문의 [key, value]에서 key에 설정되고 “value1”이 value에 설정됩니다. key, value가 모두 설정되므로 앞 코드와 같이 forEach()로 배열을 전개하지 않아도 됩니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>Error</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([<span class=\"string\">\"one\"</span>, <span class=\"number\">1</span>]);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(e)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"[one, 1]\"</span>);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(&#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>&#125;);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(e)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"&#123;one: 1&#125;\"</span>);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([&#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>&#125;]);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap);  </span><br><span class=\"line\"><span class=\"comment\">// [one, 1]  </span></span><br><span class=\"line\"><span class=\"comment\">// &#123;one: 1&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// &#123;undefined =&gt; undefined&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Map() 파라미터에 이터러블 오브젝트를 작성하고 그 안에 배열로 엘리먼트를 작성합니다.<br>[“one”, 1]에서 대괄호[]가 이터러블이므로 이를 제외하면 “one”, 1 형태가 되어 에러가 발생합니다.<br>[[“one”, 1]]형태로 작성해야 합니다.</p>\n</li>\n<li><p>Map() 파라미터에 key,value를 작성하지만, {key: value} 형태로 작성할 수 없으며 TypeError가 발생합니다.<br>[[“one”, 1]]형태로 작성해야 합니다.</p>\n</li>\n<li><p>Map() 파라미터에 대괄호[]를 작성하고, 그 안에 {one: 1}형태로 작성하면 에러가 발생하지 않고<br>Map 인스턴스가 생성됩니다. 하지만 실행 결과에서 볼 수 있듯이 key,value에 값이 설정되지 않아 undefined가 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_set\">set(): key와 value 설정</h2>\n\n<p>set() 메서드는 Map 오브젝트에서 주어진 key를 가진 엘리먼트를 추가하고, key에 엘리먼트가 이미 있다면 대체합니다.</p>\n<blockquote>\n<p>Map.prototype.set(key, value)</p>\n</blockquote>\n<p>첫 번째 파라미터에 key가 될 String 또는 오브젝트를 작성하고 두 번째 파라미터에 value를 작성합니다.<br>set()을 실행한 후 Map인스턴스를 반환하므로 메서드 체인(method chain)형태로 계속해서 Map 인스턴스의 메서드를 호출할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>set</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();  </span><br><span class=\"line\"><span class=\"number\">2.</span> newMap.set(<span class=\"string\">\"one\"</span>, <span class=\"number\">100</span>);  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(newMap.size);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> newMap.set(&#123;&#125;, <span class=\"string\">\"오브젝트\"</span>);  </span><br><span class=\"line\"><span class=\"number\">5.</span> newMap.set(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;, <span class=\"string\">\"Function\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">6.</span> newMap.set(<span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"string\">\"123\"</span>), <span class=\"string\">\"인스턴스\"</span>);  </span><br><span class=\"line\"><span class=\"number\">7.</span> newMap.set(<span class=\"literal\">NaN</span>, <span class=\"string\">\"Not a Number\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">8.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> [key, value] <span class=\"keyword\">of</span> newMap) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, value);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">1  </span></span><br><span class=\"line\"><span class=\"comment\">one 100  </span></span><br><span class=\"line\"><span class=\"comment\">Object &#123;&#125; : \"오브젝트\"  </span></span><br><span class=\"line\"><span class=\"comment\">function ()&#123;&#125; : \"Function\"  </span></span><br><span class=\"line\"><span class=\"comment\">Number &#123;[[PrimitiveValue]]: 123&#125; \"인스턴스\"  </span></span><br><span class=\"line\"><span class=\"comment\">NaN \"Not a Number\"  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>new Map() 파라미터를 작성하지 않고 인스턴스를 생성했습니다.<br>인스턴스에 key, value를 추가할 수는 있으나 인스턴스를 삭제할 수는 없습니다.</p>\n</li>\n<li><p>newMap.set()으로 newMap 인스턴스에 [key, value]값을 추가합니다. “one”이 키가 되고 100이 value가 됩니다.</p>\n</li>\n<li><p>size 프로퍼티는 Map 인스턴스의 엘리먼트 수를 반환합니다. 이 값은 바꿀 수 없습니다. 바꾸면 TypeError가 발생합니다.</p>\n</li>\n<li><p>set()의 첫 번째 파라미터에 Object {}가 key가 되고, 두 번째 파라미터인 “오브젝트”가 value가 됩니다.</p>\n</li>\n<li><p>set()의 첫 번째 파라미터인 function 오브젝트가 key가 되고 두 번째 파라미터인 “Function”이 value가 됩니다.</p>\n</li>\n<li><p>첫 번째 파라미터인 Number 인스턴스가 key가 되고, 두 번째 파라미터인 “인스턴스”가 value가 됩니다.</p>\n</li>\n<li><p>첫 번째 파라미터인 NaN이 key가 되고, 두 번째 파라미터인 “Not a Number”가 value가 됩니다. NaN을 key로 사용할 수 있습니다.</p>\n</li>\n<li><p>newMap 인스턴스를 for-of 문으로 반복하면 추가한 순서대로 전개됩니다.</p>\n<ul>\n<li><p>newMap의 인스턴스 구조</p>\n<pre><code>Map(5)\n    [[Entries]]\n    0: {&quot;one&quot; =&gt; 100}\n    1: {Object =&gt; &quot;오브젝트&quot;}\n    2: {function(){} =&gt; &quot;Function&quot;}\n    3: {Number =&gt; &quot;인스턴스&quot;}\n    4: {NaN =&gt; &quot;Not a Number&quot;}</code></pre></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();  </span><br><span class=\"line\">newMap.set(<span class=\"string\">\"one\"</span>, <span class=\"number\">100</span>);  </span><br><span class=\"line\">newMap.set(<span class=\"string\">\"one\"</span>, <span class=\"number\">123</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> sportsObj = &#123;<span class=\"attr\">sports</span>: <span class=\"string\">\"스포츠\"</span>&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> newMap.set(sportsObj, <span class=\"string\">\"Sports Object\"</span>);  </span><br><span class=\"line\"><span class=\"number\">2.</span> newMap.set(sportsObj, <span class=\"string\">\"Sports Object-변경\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> newMap.set(&#123;&#125;, <span class=\"string\">\"Object-1\"</span>);  </span><br><span class=\"line\"><span class=\"number\">4.</span> newMap.set(&#123;&#125;, <span class=\"string\">\"Object-2\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>newMap 인스턴스에 “one”을 key로 하여 100을 설정한 후, 다시 “one”을 key로 하여 123을 설정하면<br>key 값이 같으므로 100 이 123으로 대체됩니다.</li>\n</ul>\n<ol>\n<li><p>set()의 첫 번째 파라미터에 Object 오브젝트를 직접 작성하지 않고 별도로 작성한 sportsObj 오브젝트를 지정했습니다. sportsObj가 key가 되고 “Sports Object”가 value가 됩니다.</p>\n</li>\n<li><p>sportsObj key가 존재하므로 value가 대체됩니다.</p>\n</li>\n<li><p>set()의 첫 번째 파라미터에 Object 리터럴 {}을 지정했습니다. Object 오브젝트를 생성하여 메모리에 저장하고 newMap 인스턴스에 key로 사용하여 “Object-1”을 추가합니다.</p>\n</li>\n<li><p>set()의 첫 번째 파라미터에 Object 리터럴을 지정해도 앞의 key값과 중복되지 않습니다.<br>왜냐하면 첫 번째 파라미터의 Object 리터럴이 새로운 Object 오브젝트를 생성하므로 앞의 코드와 다른 메모리 주소에 저장되기 때문입니다. 앞의 Object 오브젝트가 저장된 메모리 주소와 생성한 Object 오브젝트의 메모리 주소가 다르므로 value가 대체되지 않고 추가됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_get\">get(): key가 같은 value 반환</h2>\n\n<p>Map 인스턴스에서 key 값이 같은 value를 반환합니다.</p>\n<blockquote>\n<p>Map.prototype.get(key)</p>\n</blockquote>\n<p>파라미터에 검색할 key 값을 작성합니다. 파라미터의 key가 Map 인스턴스에 존재하면 value를 반환하고, 존재하지 않으면 undefined를 반환합니다. key의 값 타입까지 체크합니다 (123 와 “123”은 같지 않습니다.)</p>\n<figure class=\"highlight js\"><figcaption><span>get()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();  </span><br><span class=\"line\"><span class=\"number\">1.</span> newMap.set(<span class=\"string\">\"one\"</span>, <span class=\"number\">100</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap.get(<span class=\"string\">\"one\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(newMap.get(<span class=\"string\">\"two\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> sportsObj = &#123;<span class=\"attr\">sports</span>: <span class=\"string\">\"스포츠\"</span>&#125;;  </span><br><span class=\"line\">newMap.set(sportsObj, <span class=\"string\">\"Sports Object\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap.get(sportsObj));  </span><br><span class=\"line\"><span class=\"comment\">//100  </span></span><br><span class=\"line\"><span class=\"comment\">//undefined  </span></span><br><span class=\"line\"><span class=\"comment\">//Sports Object</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>set()을 실행하면 [“one”, 100]형태로 등록됩니다. get() 파라미터에 검색할 key 값을 작성합니다. “one”이 newMap 인스턴스에 존재하므로 value인 100을 반환합니다.</p>\n</li>\n<li><p>get()의 파라미터 값인 “two”가 newMap 인스턴스 key에 존재하지 않으므로 undefined 입니다.</p>\n</li>\n<li><p>set()의 첫 번째 파라미터에 sportsObj의 메모리 주소를 key로 지정하여 newMap 인스턴스에 추가합니다.<br>다시 sportsObj의 메모리 주소를 파라미터 값으로 지정하여 get()을 수행하므로 “Sports Object”가 반환됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> newMap.set(&#123;&#125;, <span class=\"string\">\"Object\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap.get(&#123;&#125;));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> newMap.set(<span class=\"number\">123</span>, <span class=\"string\">\"값 123\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap.get(<span class=\"number\">123</span>));  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap.get(<span class=\"string\">\"123\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> newMap.set(<span class=\"literal\">NaN</span>, <span class=\"string\">\"Not a Number\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap.get(<span class=\"literal\">NaN</span>));  </span><br><span class=\"line\"><span class=\"comment\">// undefined  </span></span><br><span class=\"line\"><span class=\"comment\">// 값 123  </span></span><br><span class=\"line\"><span class=\"comment\">// undefined  </span></span><br><span class=\"line\"><span class=\"comment\">// Not a Number</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>set() 파라미터인 Object 오브젝트와 get() 파라미터인 Object 오브젝트의 메모리 주소가 다름으로 undefined를 반환합니다.</p>\n</li>\n<li><p>get(123)으로 검색하면 key 의 타입까지 체크하여 value를 반환합니다.<br>get(“123”)으로 값을 구하면 “123”이 String 타입이므로 타입이 같지않습니다. undefined가 반환됩니다.</p>\n</li>\n<li><p>set()의 파라미터에 NaN을 지정하고 get()의 파라미터에 NaN을 지정하면 key 값이 같으므로 value 값을 반환합니다. <del>ES5에서 (NaN === NaN) 비교 결과가 true가 아닌 문제가 있었지만 Map 오브젝트에 반영되었습니다.</del></p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_has\">has(): key 존재 여부</h2>\n\n<p>Map 인스턴스에서 key 값의 존재 여부를 반환합니다.</p>\n<blockquote>\n<p>Map.prototype.has(key)</p>\n</blockquote>\n<p>key 값이 존재하면 true, 아니라면 false를 반환합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();  </span><br><span class=\"line\">newMap.set(<span class=\"string\">\"one\"</span>, <span class=\"number\">100</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newMap.has(<span class=\"string\">\"one\"</span>));  </span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>key 를 비교한다는 점은 get()과 같습니다.<br>get()은 해당 key의 value를 반환.<br>has()는 key값 존재 여부를 체크, true/false 값을 반환합니다.</li>\n</ul>\n<hr>\n<h2 id=\"Map_entries\">entries(): 이터레이터 오브젝트 생성</h2>\n\n<p>[key, value]를 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Map.prototype.entries()</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트에 next()를 호출하면 [key, value]를 반환합니다.<br>next()를 호출할 때마다 Map 인스턴스에 추가한 순서대로 읽힙니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>],  </span><br><span class=\"line\"> [<span class=\"string\">\"key2\"</span>, <span class=\"string\">\"value2\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iteratorObj = newMap.entries();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = iteratorObj.next();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Array[2], done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Array[2], done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>new Map()으로 두 개의 엘리먼트를 가진 Map 인스턴스를 생성합니다.<br>생성한 Map 인스턴스의 entries()를 호출하여 이터러블 오브젝트를 생성하고 반환합니다.</p>\n</li>\n<li><p>next()를 호출하면 첫 번째의 [“key1”, “value1”]를 {value: Array[2], done: false} 형태의 value에 설정하여 반환합니다. Array[2]로 표시된 이유는 [“key1”, “value1”] 형태이기 때문입니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_keys\">keys(): key 반환 이터레이터 오브젝트 생성</h2>\n\n<p>key 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Map.prototype.keys()</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트의 next()를 호출하면 [key, value]형태에서 key 값만 반환합니다.<br>Map 인스턴스에 추가한 순서대로 읽힙니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">newMap.set(&#123;&#125;, <span class=\"string\">\"오브젝트\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> iteratorObj = newMap.keys();  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"key1\", done:false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Object, done:false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>newMap.keys()로 key 값만 반환하는 이터레이터 오브젝트를 생성해 iteratorObj에 할당합니다.</p>\n</li>\n<li><p>next()를 호출하면 [“key1”, “value1”]에서 “key1”을 {value: “key1”, done:false} 형태로<br>value에 설정하여 반환합니다.</p>\n</li>\n<li><p>({}, “오브젝트”) 형태로 추가했으므로 Object 오브젝트가 key가 됩니다.<br>{value: Object, done: false} 형태가 반환됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_values\">values(): value 반환 이터레이터 오브젝트 생성</h2>\n\n<p>value 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Map.prototype.values()</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트의 next()를 호출하면 value 값 만 반환합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">newMap.set(&#123;&#125;, <span class=\"string\">\"오브젝트\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> iteratorObj = newMap.values();  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"value1\", done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"오브젝트\", done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>newMap.values()로 value 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>next()를 호출하면 [“key1”, “value1”]에서 “value1”을 {value: “value1”, done: false}의 value에 설정하여 반환합니다.</p>\n</li>\n<li><p>“오브젝트”가 value가 됩니다. {value: “오브젝트”, done:false} 형태로 반환됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_forEach\">forEach(): 엘리먼트마다 콜백 함수 호출</h2>\n\n<p>Map 인스턴스를 반복할 때 마다 callback 함수를 호출합니다.</p>\n<blockquote>\n<p>Map.prototype.forEach(function)</p>\n</blockquote>\n<p>첫 번째 파라미터에 반복할 때마다 호출할 콜백 함수를 작성합니다.</p>\n<p>두 번째 파라미터는 선택적 파라미터로 콜백 함수에서 this로 참조할 오브젝트를 지정합니다.</p>\n<h3 id=\"중요-포인트\"><a href=\"#중요-포인트\" class=\"headerlink\" title=\"중요 포인트\"></a>중요 포인트</h3><p>forEach()는 호출할 때마다 세 개의 파라미터를 넘겨줍니다.</p>\n<ol>\n<li>[key, value]에서 value</li>\n<li>[key, value]에서 key</li>\n<li>실행 중인 Map 인스턴스</li>\n</ol>\n<p><code>key, value 순서가 아닌 value, key 순서입니다.</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>],  </span><br><span class=\"line\"> [&#123;&#125;, <span class=\"string\">\"오브젝트\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">  </span><br><span class=\"line\">newMap.forEach(<span class=\"function\">(<span class=\"params\">value, key, map</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, value);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"comment\">// key1 value1  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123; &#125; \"오브젝트\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>forEach()가 처음 호출되면 [“key1”, “value1”]을 읽으며 파라미터 value에 “value1”이 설정되고 파라미터 key에 “key1”이 설정됩니다. 세 번째의 map 파라미터에 newMap 인스턴스가 설정됩니다.<br>두 번째 호출 역시 마찬가지로 설정됩니다.</li>\n</ul>\n<hr>\n<h2 id=\"Map_delete\">delete(): 엘리먼트 삭제</h2>\n\n<p>Map 인스턴스에서 key 값이 같은 엘리먼트를 삭제합니다.</p>\n<blockquote>\n<p>Map.prototype.delete(key)</p>\n</blockquote>\n<p>파라미터에 삭제할 key 값을 지정합니다. Map 인스턴스에 같은 key가 존재하면 엘리먼트를 삭제하고 true를 반환합니다. key값이 존재하지 않으면 false를 반환합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>],  </span><br><span class=\"line\"> [&#123;&#125;, <span class=\"string\">\"오브젝트\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> sportsObj = &#123;&#125;;  </span><br><span class=\"line\">newMap.set(sportsObj, <span class=\"string\">\"추가\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(newMap.delete(<span class=\"string\">\"key1\"</span>));  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(newMap.delete(&#123;&#125;));  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(newMap.delete(sportsObj));  </span><br><span class=\"line\"><span class=\"comment\">//true  </span></span><br><span class=\"line\"><span class=\"comment\">//false  </span></span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>delete() 파라미터에 작성한 “key1”이 newMap 인스턴스에 존재하므로 [“key1”, “value1”] 엘리먼트를 삭제하고 true를 반환합니다.</p>\n</li>\n<li><p>delete() 파라미터에 작성한 Object 오브젝트{}가 newMap 인스턴스에 존재하는 것처럼 보이지만,<br>새로운 Object 오브젝트를 생성하여 메모리에 저장하므로 newMap 인스턴스에 저장된 Object 오브젝트와 메모리 주소가 달라서 삭제하지 못합니다. false가 반환됩니다.</p>\n</li>\n<li><p>delete() 파라미터의 sportsObj와 newMap 인스턴스의 sportsObj가 같은 메모리 주소를 참조하므로 삭제가 되며 true를 반환합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_clear\">clear(): 모든 key, value 지움</h2>\n\n<p>Map 인스턴스의 모든 [key, value]를 지웁니다.</p>\n<blockquote>\n<p>Map.prototype.clear()</p>\n</blockquote>\n<p>Map 인스턴스를 삭제하는 것이 아니라 [key, value]만 지웁니다.<br>나중에 Map 인스턴스에 [key, value]를 추가해 줄 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>],  </span><br><span class=\"line\"> [&#123;&#125;, <span class=\"string\">\"오브젝트\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(newMap.size);  </span><br><span class=\"line\">  </span><br><span class=\"line\">newMap.clear();  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(newMap.size);  </span><br><span class=\"line\"><span class=\"comment\">//0  </span></span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>size 프로퍼티는 newMap 인스턴스의 [key, value]엘리먼트 수를 반환합니다. 2가 출력됩니다.</p>\n</li>\n<li><p>clear()는 newMap 인스턴스의 모든 [key, value]를 지웁니다. 따라서 size 값으로 0이 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Map_Symbol_iterator\">Symbol.iterator(): 이터레이터 오브젝트 생성</h2>\n\n<p>이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Map.prototype.[Symbol.iterator]</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트의 next()를 호출하면 Map 인스턴스에 작성된 순서대로 [key, value]를 반환합니다.<br>Map.prototype.entries()와 같습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([  </span><br><span class=\"line\"> [<span class=\"string\">\"1\"</span>, <span class=\"string\">\"music\"</span>],  </span><br><span class=\"line\"> [<span class=\"string\">\"2\"</span>, <span class=\"string\">\"sports\"</span>]  </span><br><span class=\"line\">]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> iteratorObj = newMap[<span class=\"built_in\">Symbol</span>.iterator]();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Array[2], done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Array[2], done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>newMap 인스턴스의 Symbol.iterator를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>next()를 호출할 때마다 [“1”, “music”] 과 [“2”, “sports”]를 순서대로 읽어<br>{value: Array[2], done: false} 형태로 반환합니다.<br>Array[2]에 읽은 [key, value]가 설정됩니다.</p>\n</li>\n</ol>"},{"title":"Math 오브젝트 -ECMAScript","date":"2020-03-28T20:11:55.000Z","disqusId":"tunas-blog-1","_content":"\n* * *\n\nMath는 수학적인 상수와 함수를 위한 속성과 메서드를 가진 내장 객체입니다. 함수 객체가 아닙니다.\n\nMath는 Number 자료형만 지원하며 [BigInt](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/BigInt)와는 사용할 수 없습니다.\n\nBigInt는 Number 원시 값이 안정적으로 나타낼 수 있는 최대치인 253 - 1보다 큰 정수를 표현할 수 있는 내장 객체입니다.\n\n다른 전역 객체와 달리 Math는 생성자가 아닙니다. Math의 모든 속성과 메서드는 정적입니다.\n\n<!-- more -->\n\n* * *\n\n## 속성\n\n*   math.E  \n    오일러의 상수이며 자연로그의 밑. 약 2.718.\n\n*   math.LN2  \n    2의 자연로그. 약 0.693.\n\n*   math.LN10  \n    10의 자연로그. 약 2.303.\n\n*   math.LOG2E  \n    밑이 2인 로그 E. 약 1.443.\n\n*   math.LOG10E  \n    밑이 10인 로그 E. 약 0.434.\n\n*   math.PI  \n    원의 둘레와 지름의 비율. 약 3.14159.\n\n*   math.SQRT1_2  \n    ½의 제곱근. 약 0.707.\n\n*   math.SQRT2  \n    2의 제곱근. 약 1.414.\n\n* * *\n\n## 메서드\n\n*   참고: 삼각 함수(sin(), cos(), tan(), asin(), *acos(), atan(), atan2())는 매개변수와 반환값 모두 호도법(라디안)을 사용합니다.  \n    라디안 값을 각도 값으로 변환하려면 (Math.PI / 180)으로 나누세요. 반대로 각도 값에 곱하면 라디안 값이 됩니다.\n\n*   참고: 많은 수의 Math 함수 정확도는 구현에 따라 다를 수 있습니다. 즉, 각 브라우저의 결과가 다를 수 있으며, 서로 같은 JS 엔진이라도 운영체제나 아키텍쳐에 따라서 불일치하는 값을 반환할 수 있습니다.\n    \n*   math.abs(x)  \n    숫자의 절댓값을 반환합니다.\n    \n\n*   math.acos(x)  \n    숫자의 아크코사인 값을 반환합니다.\n\n*   math.acosh(x)  \n    숫자의 쌍곡아크코사인 값을 반환합니다.\n\n*   math.asin(x)  \n    숫자의 아크사인 값을 반환합니다.\n\n*   math.asinh(x)  \n    숫자의 쌍곡아크사인 값을 반환합니다.\n\n*   math.atan(x)  \n    숫자의 아크탄젠트 값을 반환합니다.\n\n*   math.atanh(x)  \n    숫자의 쌍곡아크탄젠트 값을 반환합니다.\n\n*   math.atan2(y, x)  \n    인수 몫의 아크탄젠트 값을 반환합니다.\n\n*   math.cbrt(x)  \n    숫자의 세제곱근을 반환합니다.\n\n*   math.ceil(x)  \n    인수보다 크거나 같은 수 중에서 가장 작은 정수를 반환합니다.\n\n*   math.clz32(x)  \n    주어진 32비트 정수의 선행 0 개수를 반환합니다.\n\n*   math.cos(x)  \n    숫자의 코사인 값을 반환합니다.\n\n*   math.cosh(x)  \n    숫자의 쌍곡코사인 값을 반환합니다.\n\n*   math.exp(x)  \n    Ex 를 반환합니다. x는 인수이며 E 는 오일러 상수(2.718…) 또는 자연로그의 밑입니다.\n\n*   math.expm1(x)  \n    exp(x)에서 1을 뺀 값을 반환합니다.\n\n*   math.floor(x)  \n    인수보다 작거나 같은 수 중에서 가장 큰 정수를 반환합니다.\n\n*   math.fround(x)  \n    인수의 가장 가까운 단일 정밀도 표현을 반환합니다. 32비트 유동 소수 값\n\n*   math.hypot([x[, y[, …]]])  \n    인수의 제곱합의 제곱근을 반환합니다.\n\n*   math.imul(x, y)  \n    두 32비트 정수의 곱을 반환합니다.\n\n*   math.log(x)  \n    숫자의 자연로그(loge 또는 ln) 값을 반환합니다.\n\n*   math.log1p(x)  \n    숫자 x에 대해 1 + x의 자연로그(loge 또는 ln) 값을 반환합니다.\n\n*   math.log10(x)  \n    숫자의 밑이 10인 로그를 반환합니다.\n\n*   math.log2(x)  \n    숫자의 밑이 2인 로그를 반환합니다.\n\n*   math.max([x[, y[, …]]])  \n    0개 이상의 인수에서 제일 큰 수를 반환합니다.\n\n*   math.min([x[, y[, …]]])  \n    0개 이상의 인수에서 제일 작은 수를 반환합니다.\n\n*   math.pow(x, y)  \n    x의 y 제곱을 반환합니다.\n\n*   math.random()  \n    0과 1 사이의 난수를 반환합니다.\n\n*   math.round(x)  \n    숫자에서 가장 가까운 정수를 반환합니다.\n\n*   math.sign(x)  \n    x의 양의 수인지 음의 수인지 나타내는 부호를 반환합니다.\n\n*   math.sin(x)  \n    숫자의 사인 값을 반환합니다.\n\n*   math.sinh(x)  \n    숫자의 쌍곡사인 값을 반환합니다.\n\n*   math.sqrt(x)  \n    숫자의 제곱근을 반환합니다.\n\n*   math.tan(x)  \n    숫자의 탄젠트 값을 반환합니다.\n\n*   math.tanh(x)  \n    숫자의 쌍곡탄젠트 값을 반환합니다.\n\n*   math.toSource()  \n    문자열 “Math”를 반환합니다.\n\n*   math.trunc(x)  \n    숫자의 정수 부분을 반환합니다.","source":"_posts/Math 오브젝트 -ECMAScript.md","raw":"---\ntitle: Math 오브젝트 -ECMAScript\ndate: 2020-03-29 05:11:55\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n* * *\n\nMath는 수학적인 상수와 함수를 위한 속성과 메서드를 가진 내장 객체입니다. 함수 객체가 아닙니다.\n\nMath는 Number 자료형만 지원하며 [BigInt](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/BigInt)와는 사용할 수 없습니다.\n\nBigInt는 Number 원시 값이 안정적으로 나타낼 수 있는 최대치인 253 - 1보다 큰 정수를 표현할 수 있는 내장 객체입니다.\n\n다른 전역 객체와 달리 Math는 생성자가 아닙니다. Math의 모든 속성과 메서드는 정적입니다.\n\n<!-- more -->\n\n* * *\n\n## 속성\n\n*   math.E  \n    오일러의 상수이며 자연로그의 밑. 약 2.718.\n\n*   math.LN2  \n    2의 자연로그. 약 0.693.\n\n*   math.LN10  \n    10의 자연로그. 약 2.303.\n\n*   math.LOG2E  \n    밑이 2인 로그 E. 약 1.443.\n\n*   math.LOG10E  \n    밑이 10인 로그 E. 약 0.434.\n\n*   math.PI  \n    원의 둘레와 지름의 비율. 약 3.14159.\n\n*   math.SQRT1_2  \n    ½의 제곱근. 약 0.707.\n\n*   math.SQRT2  \n    2의 제곱근. 약 1.414.\n\n* * *\n\n## 메서드\n\n*   참고: 삼각 함수(sin(), cos(), tan(), asin(), *acos(), atan(), atan2())는 매개변수와 반환값 모두 호도법(라디안)을 사용합니다.  \n    라디안 값을 각도 값으로 변환하려면 (Math.PI / 180)으로 나누세요. 반대로 각도 값에 곱하면 라디안 값이 됩니다.\n\n*   참고: 많은 수의 Math 함수 정확도는 구현에 따라 다를 수 있습니다. 즉, 각 브라우저의 결과가 다를 수 있으며, 서로 같은 JS 엔진이라도 운영체제나 아키텍쳐에 따라서 불일치하는 값을 반환할 수 있습니다.\n    \n*   math.abs(x)  \n    숫자의 절댓값을 반환합니다.\n    \n\n*   math.acos(x)  \n    숫자의 아크코사인 값을 반환합니다.\n\n*   math.acosh(x)  \n    숫자의 쌍곡아크코사인 값을 반환합니다.\n\n*   math.asin(x)  \n    숫자의 아크사인 값을 반환합니다.\n\n*   math.asinh(x)  \n    숫자의 쌍곡아크사인 값을 반환합니다.\n\n*   math.atan(x)  \n    숫자의 아크탄젠트 값을 반환합니다.\n\n*   math.atanh(x)  \n    숫자의 쌍곡아크탄젠트 값을 반환합니다.\n\n*   math.atan2(y, x)  \n    인수 몫의 아크탄젠트 값을 반환합니다.\n\n*   math.cbrt(x)  \n    숫자의 세제곱근을 반환합니다.\n\n*   math.ceil(x)  \n    인수보다 크거나 같은 수 중에서 가장 작은 정수를 반환합니다.\n\n*   math.clz32(x)  \n    주어진 32비트 정수의 선행 0 개수를 반환합니다.\n\n*   math.cos(x)  \n    숫자의 코사인 값을 반환합니다.\n\n*   math.cosh(x)  \n    숫자의 쌍곡코사인 값을 반환합니다.\n\n*   math.exp(x)  \n    Ex 를 반환합니다. x는 인수이며 E 는 오일러 상수(2.718…) 또는 자연로그의 밑입니다.\n\n*   math.expm1(x)  \n    exp(x)에서 1을 뺀 값을 반환합니다.\n\n*   math.floor(x)  \n    인수보다 작거나 같은 수 중에서 가장 큰 정수를 반환합니다.\n\n*   math.fround(x)  \n    인수의 가장 가까운 단일 정밀도 표현을 반환합니다. 32비트 유동 소수 값\n\n*   math.hypot([x[, y[, …]]])  \n    인수의 제곱합의 제곱근을 반환합니다.\n\n*   math.imul(x, y)  \n    두 32비트 정수의 곱을 반환합니다.\n\n*   math.log(x)  \n    숫자의 자연로그(loge 또는 ln) 값을 반환합니다.\n\n*   math.log1p(x)  \n    숫자 x에 대해 1 + x의 자연로그(loge 또는 ln) 값을 반환합니다.\n\n*   math.log10(x)  \n    숫자의 밑이 10인 로그를 반환합니다.\n\n*   math.log2(x)  \n    숫자의 밑이 2인 로그를 반환합니다.\n\n*   math.max([x[, y[, …]]])  \n    0개 이상의 인수에서 제일 큰 수를 반환합니다.\n\n*   math.min([x[, y[, …]]])  \n    0개 이상의 인수에서 제일 작은 수를 반환합니다.\n\n*   math.pow(x, y)  \n    x의 y 제곱을 반환합니다.\n\n*   math.random()  \n    0과 1 사이의 난수를 반환합니다.\n\n*   math.round(x)  \n    숫자에서 가장 가까운 정수를 반환합니다.\n\n*   math.sign(x)  \n    x의 양의 수인지 음의 수인지 나타내는 부호를 반환합니다.\n\n*   math.sin(x)  \n    숫자의 사인 값을 반환합니다.\n\n*   math.sinh(x)  \n    숫자의 쌍곡사인 값을 반환합니다.\n\n*   math.sqrt(x)  \n    숫자의 제곱근을 반환합니다.\n\n*   math.tan(x)  \n    숫자의 탄젠트 값을 반환합니다.\n\n*   math.tanh(x)  \n    숫자의 쌍곡탄젠트 값을 반환합니다.\n\n*   math.toSource()  \n    문자열 “Math”를 반환합니다.\n\n*   math.trunc(x)  \n    숫자의 정수 부분을 반환합니다.","slug":"Math 오브젝트 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrsj000xqgvqfm08eh04","content":"<hr>\n<p>Math는 수학적인 상수와 함수를 위한 속성과 메서드를 가진 내장 객체입니다. 함수 객체가 아닙니다.</p>\n<p>Math는 Number 자료형만 지원하며 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/BigInt\">BigInt</a>와는 사용할 수 없습니다.</p>\n<p>BigInt는 Number 원시 값이 안정적으로 나타낼 수 있는 최대치인 253 - 1보다 큰 정수를 표현할 수 있는 내장 객체입니다.</p>\n<p>다른 전역 객체와 달리 Math는 생성자가 아닙니다. Math의 모든 속성과 메서드는 정적입니다.</p>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"속성\"><a href=\"#속성\" class=\"headerlink\" title=\"속성\"></a>속성</h2><ul>\n<li><p>math.E<br>오일러의 상수이며 자연로그의 밑. 약 2.718.</p>\n</li>\n<li><p>math.LN2<br>2의 자연로그. 약 0.693.</p>\n</li>\n<li><p>math.LN10<br>10의 자연로그. 약 2.303.</p>\n</li>\n<li><p>math.LOG2E<br>밑이 2인 로그 E. 약 1.443.</p>\n</li>\n<li><p>math.LOG10E<br>밑이 10인 로그 E. 약 0.434.</p>\n</li>\n<li><p>math.PI<br>원의 둘레와 지름의 비율. 약 3.14159.</p>\n</li>\n<li><p>math.SQRT1_2<br>½의 제곱근. 약 0.707.</p>\n</li>\n<li><p>math.SQRT2<br>2의 제곱근. 약 1.414.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"메서드\"><a href=\"#메서드\" class=\"headerlink\" title=\"메서드\"></a>메서드</h2><ul>\n<li><p>참고: 삼각 함수(sin(), cos(), tan(), asin(), *acos(), atan(), atan2())는 매개변수와 반환값 모두 호도법(라디안)을 사용합니다.<br>라디안 값을 각도 값으로 변환하려면 (Math.PI / 180)으로 나누세요. 반대로 각도 값에 곱하면 라디안 값이 됩니다.</p>\n</li>\n<li><p>참고: 많은 수의 Math 함수 정확도는 구현에 따라 다를 수 있습니다. 즉, 각 브라우저의 결과가 다를 수 있으며, 서로 같은 JS 엔진이라도 운영체제나 아키텍쳐에 따라서 불일치하는 값을 반환할 수 있습니다.</p>\n</li>\n<li><p>math.abs(x)<br>숫자의 절댓값을 반환합니다.</p>\n</li>\n</ul>\n<ul>\n<li><p>math.acos(x)<br>숫자의 아크코사인 값을 반환합니다.</p>\n</li>\n<li><p>math.acosh(x)<br>숫자의 쌍곡아크코사인 값을 반환합니다.</p>\n</li>\n<li><p>math.asin(x)<br>숫자의 아크사인 값을 반환합니다.</p>\n</li>\n<li><p>math.asinh(x)<br>숫자의 쌍곡아크사인 값을 반환합니다.</p>\n</li>\n<li><p>math.atan(x)<br>숫자의 아크탄젠트 값을 반환합니다.</p>\n</li>\n<li><p>math.atanh(x)<br>숫자의 쌍곡아크탄젠트 값을 반환합니다.</p>\n</li>\n<li><p>math.atan2(y, x)<br>인수 몫의 아크탄젠트 값을 반환합니다.</p>\n</li>\n<li><p>math.cbrt(x)<br>숫자의 세제곱근을 반환합니다.</p>\n</li>\n<li><p>math.ceil(x)<br>인수보다 크거나 같은 수 중에서 가장 작은 정수를 반환합니다.</p>\n</li>\n<li><p>math.clz32(x)<br>주어진 32비트 정수의 선행 0 개수를 반환합니다.</p>\n</li>\n<li><p>math.cos(x)<br>숫자의 코사인 값을 반환합니다.</p>\n</li>\n<li><p>math.cosh(x)<br>숫자의 쌍곡코사인 값을 반환합니다.</p>\n</li>\n<li><p>math.exp(x)<br>Ex 를 반환합니다. x는 인수이며 E 는 오일러 상수(2.718…) 또는 자연로그의 밑입니다.</p>\n</li>\n<li><p>math.expm1(x)<br>exp(x)에서 1을 뺀 값을 반환합니다.</p>\n</li>\n<li><p>math.floor(x)<br>인수보다 작거나 같은 수 중에서 가장 큰 정수를 반환합니다.</p>\n</li>\n<li><p>math.fround(x)<br>인수의 가장 가까운 단일 정밀도 표현을 반환합니다. 32비트 유동 소수 값</p>\n</li>\n<li><p>math.hypot([x[, y[, …]]])<br>인수의 제곱합의 제곱근을 반환합니다.</p>\n</li>\n<li><p>math.imul(x, y)<br>두 32비트 정수의 곱을 반환합니다.</p>\n</li>\n<li><p>math.log(x)<br>숫자의 자연로그(loge 또는 ln) 값을 반환합니다.</p>\n</li>\n<li><p>math.log1p(x)<br>숫자 x에 대해 1 + x의 자연로그(loge 또는 ln) 값을 반환합니다.</p>\n</li>\n<li><p>math.log10(x)<br>숫자의 밑이 10인 로그를 반환합니다.</p>\n</li>\n<li><p>math.log2(x)<br>숫자의 밑이 2인 로그를 반환합니다.</p>\n</li>\n<li><p>math.max([x[, y[, …]]])<br>0개 이상의 인수에서 제일 큰 수를 반환합니다.</p>\n</li>\n<li><p>math.min([x[, y[, …]]])<br>0개 이상의 인수에서 제일 작은 수를 반환합니다.</p>\n</li>\n<li><p>math.pow(x, y)<br>x의 y 제곱을 반환합니다.</p>\n</li>\n<li><p>math.random()<br>0과 1 사이의 난수를 반환합니다.</p>\n</li>\n<li><p>math.round(x)<br>숫자에서 가장 가까운 정수를 반환합니다.</p>\n</li>\n<li><p>math.sign(x)<br>x의 양의 수인지 음의 수인지 나타내는 부호를 반환합니다.</p>\n</li>\n<li><p>math.sin(x)<br>숫자의 사인 값을 반환합니다.</p>\n</li>\n<li><p>math.sinh(x)<br>숫자의 쌍곡사인 값을 반환합니다.</p>\n</li>\n<li><p>math.sqrt(x)<br>숫자의 제곱근을 반환합니다.</p>\n</li>\n<li><p>math.tan(x)<br>숫자의 탄젠트 값을 반환합니다.</p>\n</li>\n<li><p>math.tanh(x)<br>숫자의 쌍곡탄젠트 값을 반환합니다.</p>\n</li>\n<li><p>math.toSource()<br>문자열 “Math”를 반환합니다.</p>\n</li>\n<li><p>math.trunc(x)<br>숫자의 정수 부분을 반환합니다.</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<hr>\n<p>Math는 수학적인 상수와 함수를 위한 속성과 메서드를 가진 내장 객체입니다. 함수 객체가 아닙니다.</p>\n<p>Math는 Number 자료형만 지원하며 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/BigInt\">BigInt</a>와는 사용할 수 없습니다.</p>\n<p>BigInt는 Number 원시 값이 안정적으로 나타낼 수 있는 최대치인 253 - 1보다 큰 정수를 표현할 수 있는 내장 객체입니다.</p>\n<p>다른 전역 객체와 달리 Math는 생성자가 아닙니다. Math의 모든 속성과 메서드는 정적입니다.</p>","more":"<hr>\n<h2 id=\"속성\"><a href=\"#속성\" class=\"headerlink\" title=\"속성\"></a>속성</h2><ul>\n<li><p>math.E<br>오일러의 상수이며 자연로그의 밑. 약 2.718.</p>\n</li>\n<li><p>math.LN2<br>2의 자연로그. 약 0.693.</p>\n</li>\n<li><p>math.LN10<br>10의 자연로그. 약 2.303.</p>\n</li>\n<li><p>math.LOG2E<br>밑이 2인 로그 E. 약 1.443.</p>\n</li>\n<li><p>math.LOG10E<br>밑이 10인 로그 E. 약 0.434.</p>\n</li>\n<li><p>math.PI<br>원의 둘레와 지름의 비율. 약 3.14159.</p>\n</li>\n<li><p>math.SQRT1_2<br>½의 제곱근. 약 0.707.</p>\n</li>\n<li><p>math.SQRT2<br>2의 제곱근. 약 1.414.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"메서드\"><a href=\"#메서드\" class=\"headerlink\" title=\"메서드\"></a>메서드</h2><ul>\n<li><p>참고: 삼각 함수(sin(), cos(), tan(), asin(), *acos(), atan(), atan2())는 매개변수와 반환값 모두 호도법(라디안)을 사용합니다.<br>라디안 값을 각도 값으로 변환하려면 (Math.PI / 180)으로 나누세요. 반대로 각도 값에 곱하면 라디안 값이 됩니다.</p>\n</li>\n<li><p>참고: 많은 수의 Math 함수 정확도는 구현에 따라 다를 수 있습니다. 즉, 각 브라우저의 결과가 다를 수 있으며, 서로 같은 JS 엔진이라도 운영체제나 아키텍쳐에 따라서 불일치하는 값을 반환할 수 있습니다.</p>\n</li>\n<li><p>math.abs(x)<br>숫자의 절댓값을 반환합니다.</p>\n</li>\n</ul>\n<ul>\n<li><p>math.acos(x)<br>숫자의 아크코사인 값을 반환합니다.</p>\n</li>\n<li><p>math.acosh(x)<br>숫자의 쌍곡아크코사인 값을 반환합니다.</p>\n</li>\n<li><p>math.asin(x)<br>숫자의 아크사인 값을 반환합니다.</p>\n</li>\n<li><p>math.asinh(x)<br>숫자의 쌍곡아크사인 값을 반환합니다.</p>\n</li>\n<li><p>math.atan(x)<br>숫자의 아크탄젠트 값을 반환합니다.</p>\n</li>\n<li><p>math.atanh(x)<br>숫자의 쌍곡아크탄젠트 값을 반환합니다.</p>\n</li>\n<li><p>math.atan2(y, x)<br>인수 몫의 아크탄젠트 값을 반환합니다.</p>\n</li>\n<li><p>math.cbrt(x)<br>숫자의 세제곱근을 반환합니다.</p>\n</li>\n<li><p>math.ceil(x)<br>인수보다 크거나 같은 수 중에서 가장 작은 정수를 반환합니다.</p>\n</li>\n<li><p>math.clz32(x)<br>주어진 32비트 정수의 선행 0 개수를 반환합니다.</p>\n</li>\n<li><p>math.cos(x)<br>숫자의 코사인 값을 반환합니다.</p>\n</li>\n<li><p>math.cosh(x)<br>숫자의 쌍곡코사인 값을 반환합니다.</p>\n</li>\n<li><p>math.exp(x)<br>Ex 를 반환합니다. x는 인수이며 E 는 오일러 상수(2.718…) 또는 자연로그의 밑입니다.</p>\n</li>\n<li><p>math.expm1(x)<br>exp(x)에서 1을 뺀 값을 반환합니다.</p>\n</li>\n<li><p>math.floor(x)<br>인수보다 작거나 같은 수 중에서 가장 큰 정수를 반환합니다.</p>\n</li>\n<li><p>math.fround(x)<br>인수의 가장 가까운 단일 정밀도 표현을 반환합니다. 32비트 유동 소수 값</p>\n</li>\n<li><p>math.hypot([x[, y[, …]]])<br>인수의 제곱합의 제곱근을 반환합니다.</p>\n</li>\n<li><p>math.imul(x, y)<br>두 32비트 정수의 곱을 반환합니다.</p>\n</li>\n<li><p>math.log(x)<br>숫자의 자연로그(loge 또는 ln) 값을 반환합니다.</p>\n</li>\n<li><p>math.log1p(x)<br>숫자 x에 대해 1 + x의 자연로그(loge 또는 ln) 값을 반환합니다.</p>\n</li>\n<li><p>math.log10(x)<br>숫자의 밑이 10인 로그를 반환합니다.</p>\n</li>\n<li><p>math.log2(x)<br>숫자의 밑이 2인 로그를 반환합니다.</p>\n</li>\n<li><p>math.max([x[, y[, …]]])<br>0개 이상의 인수에서 제일 큰 수를 반환합니다.</p>\n</li>\n<li><p>math.min([x[, y[, …]]])<br>0개 이상의 인수에서 제일 작은 수를 반환합니다.</p>\n</li>\n<li><p>math.pow(x, y)<br>x의 y 제곱을 반환합니다.</p>\n</li>\n<li><p>math.random()<br>0과 1 사이의 난수를 반환합니다.</p>\n</li>\n<li><p>math.round(x)<br>숫자에서 가장 가까운 정수를 반환합니다.</p>\n</li>\n<li><p>math.sign(x)<br>x의 양의 수인지 음의 수인지 나타내는 부호를 반환합니다.</p>\n</li>\n<li><p>math.sin(x)<br>숫자의 사인 값을 반환합니다.</p>\n</li>\n<li><p>math.sinh(x)<br>숫자의 쌍곡사인 값을 반환합니다.</p>\n</li>\n<li><p>math.sqrt(x)<br>숫자의 제곱근을 반환합니다.</p>\n</li>\n<li><p>math.tan(x)<br>숫자의 탄젠트 값을 반환합니다.</p>\n</li>\n<li><p>math.tanh(x)<br>숫자의 쌍곡탄젠트 값을 반환합니다.</p>\n</li>\n<li><p>math.toSource()<br>문자열 “Math”를 반환합니다.</p>\n</li>\n<li><p>math.trunc(x)<br>숫자의 정수 부분을 반환합니다.</p>\n</li>\n</ul>"},{"title":"Number 오브젝트 -ECMAScript","date":"2020-03-26T02:01:34.000Z","disqusId":"tunas-blog-1","_content":"\n* * *\n\nES6에서 Number 오브젝트에 상수와 메서드가 추가되었습니다.  \n2진수가 추가되었고 8진수가 재정의 되었습니다.\n\n*   Number 오브젝트\n    *   [Number 상수](/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_상수)\n        *   64비트 유동 소수점\n    *   [EPSILON](/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_EPSILON)\n    *   [진수 리터럴](/2020/03/26/Number%20오브젝트%20-ECMAScript/#진수_리터럴)\n        *   2진수(Binary)\n        *   8진수(Octal)\n    *   [isNaN(): NaN 여부](/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isNaN)\n    *   [isInteger(): 정수 여부](/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isInteger)\n    *   [isSafeInteger(): 안정 정수 여부](/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isSafeInterger)\n    *   [isFinite(): 유한 값 여부](/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isFinite)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Number_상수\">Number 상수</h2>\n\nES6에 다음과 같이 두 개의 Number 상수가 추가되었습니다.\n\n| 상수 이름               | 값                                    |\n|-------------------------|---------------------------------------|\n| Number.MAX_SAFE_INTEGER | 9007199254740991 (253 - 1) 최댓값     |\n| Number.MIN_SAFE_INTEGER | -9007199254740991 (-(253 - 1)) 최솟값 |\n\n\nsafe integer(안전 정수)란, 지수(e)를 사용하지 않고 나타낼 수 있는 값을 의미합니다. 2의 64승이 아닌 2의 53승입니다. 위와 같이 최댓값과 최솟값이 있습니다.\n\n### 64비트 유동 소수점\n\n자바스크립트는 IEEE(Institute of Electrical and Electronics Engineers) 754에 정의된 “doble-precision floating-point format numbers”로 숫자 값을 표현합니다.  \n64비트 유동 소수점으로 정수와 소수를 포함하여 64개의 비트로 값을 표현합니다.\n\n![https://commons.wikimedia.org/wiki/File:IEEE_754_Double_Floating_Point_Format.svg](https://upload.wikimedia.org/wikipedia/commons/7/76/General_double_precision_float.png)\n\n*   사인 비트(sign bit)  \n    MSB(most significant bit): 최상위 비트, 즉 제일 왼 쪽에 있는 63번 비트를 뜻하며 0이면 양수, 1이면 음수를 나타낸다.\n*   지수(exponent): 62번 비트에서 52번 비트까지의 11개 비트입니다.\n*   유효 숫자(fraction): 51번 비트부터 0번 비트까지의 52개 비트에 사인 비트를 포함시켜 53개 비트입니다.\n\n```js\n// 9007199254740991  \nconsole.log(\"1:\", Number.MAX_SAFE_INTEGER);  \nconsole.log(\"2:\", Math.pow(2, 53) - 1);  \n  \n// -9007199254740991  \nconsole.log(\"3:\", Number.MIN_SAFE_INTEGER );  \nconsole.log(\"4:\", -(Math.pow(2, 53) - 1));  \n  \n1: 9007199254740991  \n2: 9007199254740991  \n3: -9007199254740991  \n4: -9007199254740991  \n```\n\n자바스크립트 안정 정수 최댓값과 최솟값을 출력한 결과입니다.\n\n* * *\n\n자바스크립트에는 64비트 형식 IEEE 754 정의 값 외에도  \n상징적인 값을 표현하는 Infinity,NaN(숫자가 아님)이 있습니다.\n\n**Number 타입의 값 중에는 두 가지 방식으로 표현할 수 있는 유일한 값이 있는데, 0 이다. 0 은 -0 이나 +0 으로 표시할 수 있다. (“0” 은 물론 +0 이다.) 실제로 이러한 방식은 거의 효력이 없다. 그 예로, +0 === -0 은 true 이다. 하지만 0으로 나누는 경우 그 차이가 눈에 띌 보일 것입니다.**\n\n```js Javascript / 0\n42 / +0  \n// Infinity  \n42 / -0  \n// -Infinity  \n```\n\n* * *\n\n<h2 id=\"Number_EPSILON\">EPSILON</h2>\n\n*   Number.EPSILON 속성(property)은 Number 형으로 표현될 수 있는 1과 1보다 큰 값 중에서 가장 작은 값의, 차이 값입니다.\n\n*   EPSILON 속성은 대략 2.2204460492503130808472633361816E-16 또는 2-52의 값을 갖습니다.\n\n[[Writable]]: false, \n\n[[Enumerable]]: false, \n\n[[Configurable]]: false 값을 갖습니다.\n\n[부동소수점에 대한 이해](https://thrillfighter.tistory.com/349)  \n[Number.EPSILON IEEE754 표현식의 문제](https://perfectacle.github.io/2016/12/24/ES6-Number-object-and-function/#Number-EPSILON)  \n[Number.EPSILON은 왜 2.220446049250313e-16인가?](https://perfectacle.github.io/2017/08/04/ES6-EPSILON/)\n\n\n```js\n1. let total = 0.1 + 0.2;  \nconsole.log(total);  \n  \n2. let result = (Math.abs(0.1 + 0.2 - 0.3) < Number.EPSILON);  \nconsole.log(result);  \n  \n3. let value = (Math.pow(10, 1) * 0.1) + (Math.pow(10, 1) * 0.2);  \nconsole.log(value / 10 === 0.3);  \n// 0.30000000000000004  \n// true  \n// true  \n```\n\n1.  자바스크립트에서 0.1 과 0.2 를 더하면 0.3이 아니라\n\n\n2.  30000000000000004이 출력됩니다. 이는 자바스크립트가 2진 유동 소수점 방식으로 값을 계산하기 때문입니다. 이와 같이 미세한 값 차이로 인해 값이 일치하지 않을 때  \nNumber.EPSILON을 사용합니다. ~~0.1+0.2 == 0.3 // false~~\n\n\n2.  0.1과 0.2를 더하고 0.3을 뺸 절댓값이 Number.EPSILON 값보다 작으면 2진 유동 소수점으로 인한 차이로 처리합니다. Number.EPSILON 값보다 작으므로 true가 출력됩니다.\n\n\n\n3.  소수를 정수로 변환하여 계산한 후, 소수를 정수로 변환할 때 곱했던 값으로 나누면 차이가 나지 않습니다. ES5에서 사용가능한 방법입니다.\n\n* * *\n\n<h2 id=\"진수_리터럴\">진수 리터널</h2>\n\n* * *\n\n### 2진수(Binary)\n\n첫 번째 숫자 0을 작성하고 두 번째에 소문자 b 또는 대문자 B를 작성합니다.  \n세 번째 부터 값을 0 또는 1로 작성합니다.  \n예시로 5값은 0b0101 또는 0B0101 형태의 값 입니다.\n\n* * *\n\n### 8진수(Octal)\n\n첫 번째 숫자 0을 작성하고 두 번째에 소문자 o 또는 대문자 O를 작성합니다.  \n세 번째 부터 값을 0에서 7까지 작성합니다. 0o0105 또는 0O0105 형태입니다.  \nES5에서는 첫 번째에 o 또는 O를 작성 했었습니다.\n\n```js literal\n// 2진수  \nlet two = 0b0101;  \nconsole.log(two);  \n  \n// 8진수  \nlet eight = 0o0101;  \nconsole.log(eight);  \n// 5 65  \n```\n\n0b0101는 2진수로 값이 5이며, 0o0101는 8진수로 값이 65입니다.  \n웹 개발자에게는 CSS에서 #0012FF 형태의 16진수를 사용하므로 16진수가 더 익숙합니다.\n\n* * *\n\n<h2 id=\"Number_isNaN\">isNaN() : NaN 여부</h2>\n\nNumber.isNaN() 메서드는 주어진 값이 NaN인지 판별합니다.  \n(NaN === NaN)의 체크 결과가 false로 반환되는 문제가 있어  \nES5에서 글로벌 오브젝트 isNaN()을 추가했지만 이 또한 문제가 많아  \nES6에서 Number.isNaN() 이 새로 추가되었습니다.  \n기존부터 존재한 전역 isNaN() 함수의 더 엄격한 버전입니다.\n\n> Number.isNaN(value)\n\n파라미터에 비교 대상 값을 지정합니다.\n\n주어진 값이 Number이고 값이 NaN이면 true, 아니면 false를 반환합니다.\n\n*   글로벌 오브젝트 isNaN() 함수와 달리, Number.isNaN()은 강제로 매개변수를 숫자로 변환하는 문제를 겪지 않습니다. 이는 보통NaN으로 변환됐을 값이 안전하게 전달되지만, 실제로는 NaN과 같은 값이 아님을 의미합니다. 이는 또한 오직 숫자형이고 또한 NaN인 값만이 true를 반환함을 뜻합니다. (엄-격)\n\n```js isNaN\n// 예를 들면 아래 예시는 global isNaN()으로 true가 됐을 것임  \nNumber.isNaN(\"NaN\");      // false  \nNumber.isNaN(undefined);  // false  \nNumber.isNaN({});         // false  \nNumber.isNaN(\"blabla\");   // false  \n```\n\nNaN의 재미난? 특징은 자바스크립트에서 유일하게 자기자신과 값이 같지 않다는 것입니다.  \n`NaN === NaN; // false`\n\n* * *\n\n<h2 id=\"Number_isInteger\">isInteger(): 정수 여부</h2>\n\n파라미터 값이 정수이면 true, 아니면 false를 반환합니다.\n\n```js isInteger\nconsole.log(\"1:\", Number.isInteger(0));// 정수  \nconsole.log(\"2:\", Number.isInteger(1.0));// 정수  \nconsole.log(\"3:\", Number.isInteger(-123));// 정수  \n  \nconsole.log(\"4:\", Number.isInteger(\"12\"));// false  \nconsole.log(\"5:\", Number.isInteger(1.02));// false  \nconsole.log(\"6:\", Number.isInteger(NaN));// false  \nconsole.log(\"7:\", Number.isInteger(true));// false  \n```\n\n파라미터 값이 Number 타입의 정수가 아니면 모두 false를 반환합니다.\n\n* * *\n\n<h2 id=\"Number_isSafeInterger\">isSafeInteger(): 안정 정수 여부</h2>\n\n```js isSafeInteger\nconsole.log(Number.isSafeInteger(7.0)); //true  \nconsole.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER));//true  \nconsole.log(Number.isSafeInteger(Number.MIN_SAFE_INTEGER));//true  \n```\n\n정수 값 이면서 안정 정수의 범위 이면 true를 반환합니다.  \n그 외에는 모두 false를 반환합니다.\n\n* * *\n\n<h2 id=\"Number_isFinite\">isFinite(): 유한 값 여부</h2>\n\n파라미터에 비교 대상 값을 지정합니다.  \n그 값이 유한 값이면 true, 아니면 false를 반환합니다.\n\n글로벌 오브젝트의 isFinite()와 값 차이가 있으므로 주의합니다.\n\n```js isFinite\nconsole.log(\"1:\", Number.isFinite(Infinity), isFinite(Infinity));  \nconsole.log(\"2:\", Number.isFinite(-Infinity), isFinite(-Infinity));  \nconsole.log(\"3:\", Number.isFinite(0), isFinite(0));  \n  \n///////////////////////////////////////  \nconsole.log(\"4:\", Number.isFinite(\"0\"), isFinite(\"0\"));  \n  \nconsole.log(\"5:\", Number.isFinite(null), isFinite(null));  \nconsole.log(\"6:\", Number.isFinite(NaN), isFinite(NaN));  \n  \nconsole.log(\"7:\", Number.isFinite(undefined), isFinite(undefined));  \nconsole.log(\"8:\", Number.isFinite(true), isFinite(true));  \n/*  \n1: false false  \n2: false false  \n3: true true  \n//////////////////  \n4: false true  \n5: false true  \n6: false false  \n7: false false  \n8: false true  \n*/  \n```\n","source":"_posts/Number 오브젝트 -ECMAScript.md","raw":"---\ntitle: Number 오브젝트 -ECMAScript\ndate: 2020-03-26 11:01:34\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n* * *\n\nES6에서 Number 오브젝트에 상수와 메서드가 추가되었습니다.  \n2진수가 추가되었고 8진수가 재정의 되었습니다.\n\n*   Number 오브젝트\n    *   [Number 상수](/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_상수)\n        *   64비트 유동 소수점\n    *   [EPSILON](/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_EPSILON)\n    *   [진수 리터럴](/2020/03/26/Number%20오브젝트%20-ECMAScript/#진수_리터럴)\n        *   2진수(Binary)\n        *   8진수(Octal)\n    *   [isNaN(): NaN 여부](/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isNaN)\n    *   [isInteger(): 정수 여부](/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isInteger)\n    *   [isSafeInteger(): 안정 정수 여부](/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isSafeInterger)\n    *   [isFinite(): 유한 값 여부](/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isFinite)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Number_상수\">Number 상수</h2>\n\nES6에 다음과 같이 두 개의 Number 상수가 추가되었습니다.\n\n| 상수 이름               | 값                                    |\n|-------------------------|---------------------------------------|\n| Number.MAX_SAFE_INTEGER | 9007199254740991 (253 - 1) 최댓값     |\n| Number.MIN_SAFE_INTEGER | -9007199254740991 (-(253 - 1)) 최솟값 |\n\n\nsafe integer(안전 정수)란, 지수(e)를 사용하지 않고 나타낼 수 있는 값을 의미합니다. 2의 64승이 아닌 2의 53승입니다. 위와 같이 최댓값과 최솟값이 있습니다.\n\n### 64비트 유동 소수점\n\n자바스크립트는 IEEE(Institute of Electrical and Electronics Engineers) 754에 정의된 “doble-precision floating-point format numbers”로 숫자 값을 표현합니다.  \n64비트 유동 소수점으로 정수와 소수를 포함하여 64개의 비트로 값을 표현합니다.\n\n![https://commons.wikimedia.org/wiki/File:IEEE_754_Double_Floating_Point_Format.svg](https://upload.wikimedia.org/wikipedia/commons/7/76/General_double_precision_float.png)\n\n*   사인 비트(sign bit)  \n    MSB(most significant bit): 최상위 비트, 즉 제일 왼 쪽에 있는 63번 비트를 뜻하며 0이면 양수, 1이면 음수를 나타낸다.\n*   지수(exponent): 62번 비트에서 52번 비트까지의 11개 비트입니다.\n*   유효 숫자(fraction): 51번 비트부터 0번 비트까지의 52개 비트에 사인 비트를 포함시켜 53개 비트입니다.\n\n```js\n// 9007199254740991  \nconsole.log(\"1:\", Number.MAX_SAFE_INTEGER);  \nconsole.log(\"2:\", Math.pow(2, 53) - 1);  \n  \n// -9007199254740991  \nconsole.log(\"3:\", Number.MIN_SAFE_INTEGER );  \nconsole.log(\"4:\", -(Math.pow(2, 53) - 1));  \n  \n1: 9007199254740991  \n2: 9007199254740991  \n3: -9007199254740991  \n4: -9007199254740991  \n```\n\n자바스크립트 안정 정수 최댓값과 최솟값을 출력한 결과입니다.\n\n* * *\n\n자바스크립트에는 64비트 형식 IEEE 754 정의 값 외에도  \n상징적인 값을 표현하는 Infinity,NaN(숫자가 아님)이 있습니다.\n\n**Number 타입의 값 중에는 두 가지 방식으로 표현할 수 있는 유일한 값이 있는데, 0 이다. 0 은 -0 이나 +0 으로 표시할 수 있다. (“0” 은 물론 +0 이다.) 실제로 이러한 방식은 거의 효력이 없다. 그 예로, +0 === -0 은 true 이다. 하지만 0으로 나누는 경우 그 차이가 눈에 띌 보일 것입니다.**\n\n```js Javascript / 0\n42 / +0  \n// Infinity  \n42 / -0  \n// -Infinity  \n```\n\n* * *\n\n<h2 id=\"Number_EPSILON\">EPSILON</h2>\n\n*   Number.EPSILON 속성(property)은 Number 형으로 표현될 수 있는 1과 1보다 큰 값 중에서 가장 작은 값의, 차이 값입니다.\n\n*   EPSILON 속성은 대략 2.2204460492503130808472633361816E-16 또는 2-52의 값을 갖습니다.\n\n[[Writable]]: false, \n\n[[Enumerable]]: false, \n\n[[Configurable]]: false 값을 갖습니다.\n\n[부동소수점에 대한 이해](https://thrillfighter.tistory.com/349)  \n[Number.EPSILON IEEE754 표현식의 문제](https://perfectacle.github.io/2016/12/24/ES6-Number-object-and-function/#Number-EPSILON)  \n[Number.EPSILON은 왜 2.220446049250313e-16인가?](https://perfectacle.github.io/2017/08/04/ES6-EPSILON/)\n\n\n```js\n1. let total = 0.1 + 0.2;  \nconsole.log(total);  \n  \n2. let result = (Math.abs(0.1 + 0.2 - 0.3) < Number.EPSILON);  \nconsole.log(result);  \n  \n3. let value = (Math.pow(10, 1) * 0.1) + (Math.pow(10, 1) * 0.2);  \nconsole.log(value / 10 === 0.3);  \n// 0.30000000000000004  \n// true  \n// true  \n```\n\n1.  자바스크립트에서 0.1 과 0.2 를 더하면 0.3이 아니라\n\n\n2.  30000000000000004이 출력됩니다. 이는 자바스크립트가 2진 유동 소수점 방식으로 값을 계산하기 때문입니다. 이와 같이 미세한 값 차이로 인해 값이 일치하지 않을 때  \nNumber.EPSILON을 사용합니다. ~~0.1+0.2 == 0.3 // false~~\n\n\n2.  0.1과 0.2를 더하고 0.3을 뺸 절댓값이 Number.EPSILON 값보다 작으면 2진 유동 소수점으로 인한 차이로 처리합니다. Number.EPSILON 값보다 작으므로 true가 출력됩니다.\n\n\n\n3.  소수를 정수로 변환하여 계산한 후, 소수를 정수로 변환할 때 곱했던 값으로 나누면 차이가 나지 않습니다. ES5에서 사용가능한 방법입니다.\n\n* * *\n\n<h2 id=\"진수_리터럴\">진수 리터널</h2>\n\n* * *\n\n### 2진수(Binary)\n\n첫 번째 숫자 0을 작성하고 두 번째에 소문자 b 또는 대문자 B를 작성합니다.  \n세 번째 부터 값을 0 또는 1로 작성합니다.  \n예시로 5값은 0b0101 또는 0B0101 형태의 값 입니다.\n\n* * *\n\n### 8진수(Octal)\n\n첫 번째 숫자 0을 작성하고 두 번째에 소문자 o 또는 대문자 O를 작성합니다.  \n세 번째 부터 값을 0에서 7까지 작성합니다. 0o0105 또는 0O0105 형태입니다.  \nES5에서는 첫 번째에 o 또는 O를 작성 했었습니다.\n\n```js literal\n// 2진수  \nlet two = 0b0101;  \nconsole.log(two);  \n  \n// 8진수  \nlet eight = 0o0101;  \nconsole.log(eight);  \n// 5 65  \n```\n\n0b0101는 2진수로 값이 5이며, 0o0101는 8진수로 값이 65입니다.  \n웹 개발자에게는 CSS에서 #0012FF 형태의 16진수를 사용하므로 16진수가 더 익숙합니다.\n\n* * *\n\n<h2 id=\"Number_isNaN\">isNaN() : NaN 여부</h2>\n\nNumber.isNaN() 메서드는 주어진 값이 NaN인지 판별합니다.  \n(NaN === NaN)의 체크 결과가 false로 반환되는 문제가 있어  \nES5에서 글로벌 오브젝트 isNaN()을 추가했지만 이 또한 문제가 많아  \nES6에서 Number.isNaN() 이 새로 추가되었습니다.  \n기존부터 존재한 전역 isNaN() 함수의 더 엄격한 버전입니다.\n\n> Number.isNaN(value)\n\n파라미터에 비교 대상 값을 지정합니다.\n\n주어진 값이 Number이고 값이 NaN이면 true, 아니면 false를 반환합니다.\n\n*   글로벌 오브젝트 isNaN() 함수와 달리, Number.isNaN()은 강제로 매개변수를 숫자로 변환하는 문제를 겪지 않습니다. 이는 보통NaN으로 변환됐을 값이 안전하게 전달되지만, 실제로는 NaN과 같은 값이 아님을 의미합니다. 이는 또한 오직 숫자형이고 또한 NaN인 값만이 true를 반환함을 뜻합니다. (엄-격)\n\n```js isNaN\n// 예를 들면 아래 예시는 global isNaN()으로 true가 됐을 것임  \nNumber.isNaN(\"NaN\");      // false  \nNumber.isNaN(undefined);  // false  \nNumber.isNaN({});         // false  \nNumber.isNaN(\"blabla\");   // false  \n```\n\nNaN의 재미난? 특징은 자바스크립트에서 유일하게 자기자신과 값이 같지 않다는 것입니다.  \n`NaN === NaN; // false`\n\n* * *\n\n<h2 id=\"Number_isInteger\">isInteger(): 정수 여부</h2>\n\n파라미터 값이 정수이면 true, 아니면 false를 반환합니다.\n\n```js isInteger\nconsole.log(\"1:\", Number.isInteger(0));// 정수  \nconsole.log(\"2:\", Number.isInteger(1.0));// 정수  \nconsole.log(\"3:\", Number.isInteger(-123));// 정수  \n  \nconsole.log(\"4:\", Number.isInteger(\"12\"));// false  \nconsole.log(\"5:\", Number.isInteger(1.02));// false  \nconsole.log(\"6:\", Number.isInteger(NaN));// false  \nconsole.log(\"7:\", Number.isInteger(true));// false  \n```\n\n파라미터 값이 Number 타입의 정수가 아니면 모두 false를 반환합니다.\n\n* * *\n\n<h2 id=\"Number_isSafeInterger\">isSafeInteger(): 안정 정수 여부</h2>\n\n```js isSafeInteger\nconsole.log(Number.isSafeInteger(7.0)); //true  \nconsole.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER));//true  \nconsole.log(Number.isSafeInteger(Number.MIN_SAFE_INTEGER));//true  \n```\n\n정수 값 이면서 안정 정수의 범위 이면 true를 반환합니다.  \n그 외에는 모두 false를 반환합니다.\n\n* * *\n\n<h2 id=\"Number_isFinite\">isFinite(): 유한 값 여부</h2>\n\n파라미터에 비교 대상 값을 지정합니다.  \n그 값이 유한 값이면 true, 아니면 false를 반환합니다.\n\n글로벌 오브젝트의 isFinite()와 값 차이가 있으므로 주의합니다.\n\n```js isFinite\nconsole.log(\"1:\", Number.isFinite(Infinity), isFinite(Infinity));  \nconsole.log(\"2:\", Number.isFinite(-Infinity), isFinite(-Infinity));  \nconsole.log(\"3:\", Number.isFinite(0), isFinite(0));  \n  \n///////////////////////////////////////  \nconsole.log(\"4:\", Number.isFinite(\"0\"), isFinite(\"0\"));  \n  \nconsole.log(\"5:\", Number.isFinite(null), isFinite(null));  \nconsole.log(\"6:\", Number.isFinite(NaN), isFinite(NaN));  \n  \nconsole.log(\"7:\", Number.isFinite(undefined), isFinite(undefined));  \nconsole.log(\"8:\", Number.isFinite(true), isFinite(true));  \n/*  \n1: false false  \n2: false false  \n3: true true  \n//////////////////  \n4: false true  \n5: false true  \n6: false false  \n7: false false  \n8: false true  \n*/  \n```\n","slug":"Number 오브젝트 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrsl0011qgvq2oejfpwn","content":"<hr>\n<p>ES6에서 Number 오브젝트에 상수와 메서드가 추가되었습니다.<br>2진수가 추가되었고 8진수가 재정의 되었습니다.</p>\n<ul>\n<li>Number 오브젝트<ul>\n<li><a href=\"/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_상수\">Number 상수</a><ul>\n<li>64비트 유동 소수점</li>\n</ul>\n</li>\n<li><a href=\"/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_EPSILON\">EPSILON</a></li>\n<li><a href=\"/2020/03/26/Number%20오브젝트%20-ECMAScript/#진수_리터럴\">진수 리터럴</a><ul>\n<li>2진수(Binary)</li>\n<li>8진수(Octal)</li>\n</ul>\n</li>\n<li><a href=\"/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isNaN\">isNaN(): NaN 여부</a></li>\n<li><a href=\"/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isInteger\">isInteger(): 정수 여부</a></li>\n<li><a href=\"/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isSafeInterger\">isSafeInteger(): 안정 정수 여부</a></li>\n<li><a href=\"/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isFinite\">isFinite(): 유한 값 여부</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"Number_상수\">Number 상수</h2>\n\n<p>ES6에 다음과 같이 두 개의 Number 상수가 추가되었습니다.</p>\n<table>\n<thead>\n<tr>\n<th>상수 이름</th>\n<th>값</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Number.MAX_SAFE_INTEGER</td>\n<td>9007199254740991 (253 - 1) 최댓값</td>\n</tr>\n<tr>\n<td>Number.MIN_SAFE_INTEGER</td>\n<td>-9007199254740991 (-(253 - 1)) 최솟값</td>\n</tr>\n</tbody></table>\n<p>safe integer(안전 정수)란, 지수(e)를 사용하지 않고 나타낼 수 있는 값을 의미합니다. 2의 64승이 아닌 2의 53승입니다. 위와 같이 최댓값과 최솟값이 있습니다.</p>\n<h3 id=\"64비트-유동-소수점\"><a href=\"#64비트-유동-소수점\" class=\"headerlink\" title=\"64비트 유동 소수점\"></a>64비트 유동 소수점</h3><p>자바스크립트는 IEEE(Institute of Electrical and Electronics Engineers) 754에 정의된 “doble-precision floating-point format numbers”로 숫자 값을 표현합니다.<br>64비트 유동 소수점으로 정수와 소수를 포함하여 64개의 비트로 값을 표현합니다.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/7/76/General_double_precision_float.png\" alt=\"https://commons.wikimedia.org/wiki/File:IEEE_754_Double_Floating_Point_Format.svg\"></p>\n<ul>\n<li>사인 비트(sign bit)<br>MSB(most significant bit): 최상위 비트, 즉 제일 왼 쪽에 있는 63번 비트를 뜻하며 0이면 양수, 1이면 음수를 나타낸다.</li>\n<li>지수(exponent): 62번 비트에서 52번 비트까지의 11개 비트입니다.</li>\n<li>유효 숫자(fraction): 51번 비트부터 0번 비트까지의 52개 비트에 사인 비트를 포함시켜 53개 비트입니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 9007199254740991  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) - <span class=\"number\">1</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// -9007199254740991  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">Number</span>.MIN_SAFE_INTEGER );  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, -(<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) - <span class=\"number\">1</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1</span>: <span class=\"number\">9007199254740991</span>  </span><br><span class=\"line\"><span class=\"number\">2</span>: <span class=\"number\">9007199254740991</span>  </span><br><span class=\"line\"><span class=\"number\">3</span>: <span class=\"number\">-9007199254740991</span>  </span><br><span class=\"line\"><span class=\"number\">4</span>: <span class=\"number\">-9007199254740991</span></span><br></pre></td></tr></table></figure>\n\n<p>자바스크립트 안정 정수 최댓값과 최솟값을 출력한 결과입니다.</p>\n<hr>\n<p>자바스크립트에는 64비트 형식 IEEE 754 정의 값 외에도<br>상징적인 값을 표현하는 Infinity,NaN(숫자가 아님)이 있습니다.</p>\n<p><strong>Number 타입의 값 중에는 두 가지 방식으로 표현할 수 있는 유일한 값이 있는데, 0 이다. 0 은 -0 이나 +0 으로 표시할 수 있다. (“0” 은 물론 +0 이다.) 실제로 이러한 방식은 거의 효력이 없다. 그 예로, +0 === -0 은 true 이다. 하지만 0으로 나누는 경우 그 차이가 눈에 띌 보일 것입니다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>Javascript / 0</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">42</span> / +<span class=\"number\">0</span>  </span><br><span class=\"line\"><span class=\"comment\">// Infinity  </span></span><br><span class=\"line\"><span class=\"number\">42</span> / <span class=\"number\">-0</span>  </span><br><span class=\"line\"><span class=\"comment\">// -Infinity</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Number_EPSILON\">EPSILON</h2>\n\n<ul>\n<li><p>Number.EPSILON 속성(property)은 Number 형으로 표현될 수 있는 1과 1보다 큰 값 중에서 가장 작은 값의, 차이 값입니다.</p>\n</li>\n<li><p>EPSILON 속성은 대략 2.2204460492503130808472633361816E-16 또는 2-52의 값을 갖습니다.</p>\n</li>\n</ul>\n<p>[[Writable]]: false, </p>\n<p>[[Enumerable]]: false, </p>\n<p>[[Configurable]]: false 값을 갖습니다.</p>\n<p><a href=\"https://thrillfighter.tistory.com/349\">부동소수점에 대한 이해</a><br><a href=\"https://perfectacle.github.io/2016/12/24/ES6-Number-object-and-function/#Number-EPSILON\">Number.EPSILON IEEE754 표현식의 문제</a><br><a href=\"https://perfectacle.github.io/2017/08/04/ES6-EPSILON/\">Number.EPSILON은 왜 2.220446049250313e-16인가?</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> total = <span class=\"number\">0.1</span> + <span class=\"number\">0.2</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(total);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> result = (<span class=\"built_in\">Math</span>.abs(<span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> - <span class=\"number\">0.3</span>) &lt; <span class=\"built_in\">Number</span>.EPSILON);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> value = (<span class=\"built_in\">Math</span>.pow(<span class=\"number\">10</span>, <span class=\"number\">1</span>) * <span class=\"number\">0.1</span>) + (<span class=\"built_in\">Math</span>.pow(<span class=\"number\">10</span>, <span class=\"number\">1</span>) * <span class=\"number\">0.2</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(value / <span class=\"number\">10</span> === <span class=\"number\">0.3</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 0.30000000000000004  </span></span><br><span class=\"line\"><span class=\"comment\">// true  </span></span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>자바스크립트에서 0.1 과 0.2 를 더하면 0.3이 아니라</li>\n</ol>\n<ol start=\"2\">\n<li>30000000000000004이 출력됩니다. 이는 자바스크립트가 2진 유동 소수점 방식으로 값을 계산하기 때문입니다. 이와 같이 미세한 값 차이로 인해 값이 일치하지 않을 때<br>Number.EPSILON을 사용합니다. <del>0.1+0.2 == 0.3 // false</del></li>\n</ol>\n<ol start=\"2\">\n<li>0.1과 0.2를 더하고 0.3을 뺸 절댓값이 Number.EPSILON 값보다 작으면 2진 유동 소수점으로 인한 차이로 처리합니다. Number.EPSILON 값보다 작으므로 true가 출력됩니다.</li>\n</ol>\n<ol start=\"3\">\n<li>소수를 정수로 변환하여 계산한 후, 소수를 정수로 변환할 때 곱했던 값으로 나누면 차이가 나지 않습니다. ES5에서 사용가능한 방법입니다.</li>\n</ol>\n<hr>\n<h2 id=\"진수_리터럴\">진수 리터널</h2>\n\n<hr>\n<h3 id=\"2진수-Binary\"><a href=\"#2진수-Binary\" class=\"headerlink\" title=\"2진수(Binary)\"></a>2진수(Binary)</h3><p>첫 번째 숫자 0을 작성하고 두 번째에 소문자 b 또는 대문자 B를 작성합니다.<br>세 번째 부터 값을 0 또는 1로 작성합니다.<br>예시로 5값은 0b0101 또는 0B0101 형태의 값 입니다.</p>\n<hr>\n<h3 id=\"8진수-Octal\"><a href=\"#8진수-Octal\" class=\"headerlink\" title=\"8진수(Octal)\"></a>8진수(Octal)</h3><p>첫 번째 숫자 0을 작성하고 두 번째에 소문자 o 또는 대문자 O를 작성합니다.<br>세 번째 부터 값을 0에서 7까지 작성합니다. 0o0105 또는 0O0105 형태입니다.<br>ES5에서는 첫 번째에 o 또는 O를 작성 했었습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>literal</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2진수  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> two = <span class=\"number\">0b0101</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(two);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 8진수  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> eight = <span class=\"number\">0o0101</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(eight);  </span><br><span class=\"line\"><span class=\"comment\">// 5 65</span></span><br></pre></td></tr></table></figure>\n\n<p>0b0101는 2진수로 값이 5이며, 0o0101는 8진수로 값이 65입니다.<br>웹 개발자에게는 CSS에서 #0012FF 형태의 16진수를 사용하므로 16진수가 더 익숙합니다.</p>\n<hr>\n<h2 id=\"Number_isNaN\">isNaN() : NaN 여부</h2>\n\n<p>Number.isNaN() 메서드는 주어진 값이 NaN인지 판별합니다.<br>(NaN === NaN)의 체크 결과가 false로 반환되는 문제가 있어<br>ES5에서 글로벌 오브젝트 isNaN()을 추가했지만 이 또한 문제가 많아<br>ES6에서 Number.isNaN() 이 새로 추가되었습니다.<br>기존부터 존재한 전역 isNaN() 함수의 더 엄격한 버전입니다.</p>\n<blockquote>\n<p>Number.isNaN(value)</p>\n</blockquote>\n<p>파라미터에 비교 대상 값을 지정합니다.</p>\n<p>주어진 값이 Number이고 값이 NaN이면 true, 아니면 false를 반환합니다.</p>\n<ul>\n<li>글로벌 오브젝트 isNaN() 함수와 달리, Number.isNaN()은 강제로 매개변수를 숫자로 변환하는 문제를 겪지 않습니다. 이는 보통NaN으로 변환됐을 값이 안전하게 전달되지만, 실제로는 NaN과 같은 값이 아님을 의미합니다. 이는 또한 오직 숫자형이고 또한 NaN인 값만이 true를 반환함을 뜻합니다. (엄-격)</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>isNaN</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 예를 들면 아래 예시는 global isNaN()으로 true가 됐을 것임  </span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"NaN\"</span>);      <span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">undefined</span>);  <span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(&#123;&#125;);         <span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"blabla\"</span>);   <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>NaN의 재미난? 특징은 자바스크립트에서 유일하게 자기자신과 값이 같지 않다는 것입니다.<br><code>NaN === NaN; // false</code></p>\n<hr>\n<h2 id=\"Number_isInteger\">isInteger(): 정수 여부</h2>\n\n<p>파라미터 값이 정수이면 true, 아니면 false를 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>isInteger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">0</span>));<span class=\"comment\">// 정수  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">1.0</span>));<span class=\"comment\">// 정수  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">-123</span>));<span class=\"comment\">// 정수  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"built_in\">Number</span>.isInteger(<span class=\"string\">\"12\"</span>));<span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, <span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">1.02</span>));<span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"6:\"</span>, <span class=\"built_in\">Number</span>.isInteger(<span class=\"literal\">NaN</span>));<span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"7:\"</span>, <span class=\"built_in\">Number</span>.isInteger(<span class=\"literal\">true</span>));<span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>파라미터 값이 Number 타입의 정수가 아니면 모두 false를 반환합니다.</p>\n<hr>\n<h2 id=\"Number_isSafeInterger\">isSafeInteger(): 안정 정수 여부</h2>\n\n<figure class=\"highlight js\"><figcaption><span>isSafeInteger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"number\">7.0</span>)); <span class=\"comment\">//true  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER));<span class=\"comment\">//true  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"built_in\">Number</span>.MIN_SAFE_INTEGER));<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>정수 값 이면서 안정 정수의 범위 이면 true를 반환합니다.<br>그 외에는 모두 false를 반환합니다.</p>\n<hr>\n<h2 id=\"Number_isFinite\">isFinite(): 유한 값 여부</h2>\n\n<p>파라미터에 비교 대상 값을 지정합니다.<br>그 값이 유한 값이면 true, 아니면 false를 반환합니다.</p>\n<p>글로벌 오브젝트의 isFinite()와 값 차이가 있으므로 주의합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>isFinite</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">Infinity</span>), <span class=\"built_in\">isFinite</span>(<span class=\"literal\">Infinity</span>));  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"built_in\">Number</span>.isFinite(-<span class=\"literal\">Infinity</span>), <span class=\"built_in\">isFinite</span>(-<span class=\"literal\">Infinity</span>));  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">0</span>), <span class=\"built_in\">isFinite</span>(<span class=\"number\">0</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">///////////////////////////////////////  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">\"0\"</span>), <span class=\"built_in\">isFinite</span>(<span class=\"string\">\"0\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, <span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">null</span>), <span class=\"built_in\">isFinite</span>(<span class=\"literal\">null</span>));  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"6:\"</span>, <span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">NaN</span>), <span class=\"built_in\">isFinite</span>(<span class=\"literal\">NaN</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"7:\"</span>, <span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">undefined</span>), <span class=\"built_in\">isFinite</span>(<span class=\"literal\">undefined</span>));  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"8:\"</span>, <span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">true</span>), <span class=\"built_in\">isFinite</span>(<span class=\"literal\">true</span>));  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">1: false false  </span></span><br><span class=\"line\"><span class=\"comment\">2: false false  </span></span><br><span class=\"line\"><span class=\"comment\">3: true true  </span></span><br><span class=\"line\"><span class=\"comment\">//////////////////  </span></span><br><span class=\"line\"><span class=\"comment\">4: false true  </span></span><br><span class=\"line\"><span class=\"comment\">5: false true  </span></span><br><span class=\"line\"><span class=\"comment\">6: false false  </span></span><br><span class=\"line\"><span class=\"comment\">7: false false  </span></span><br><span class=\"line\"><span class=\"comment\">8: false true  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<hr>\n<p>ES6에서 Number 오브젝트에 상수와 메서드가 추가되었습니다.<br>2진수가 추가되었고 8진수가 재정의 되었습니다.</p>\n<ul>\n<li>Number 오브젝트<ul>\n<li><a href=\"/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_상수\">Number 상수</a><ul>\n<li>64비트 유동 소수점</li>\n</ul>\n</li>\n<li><a href=\"/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_EPSILON\">EPSILON</a></li>\n<li><a href=\"/2020/03/26/Number%20오브젝트%20-ECMAScript/#진수_리터럴\">진수 리터럴</a><ul>\n<li>2진수(Binary)</li>\n<li>8진수(Octal)</li>\n</ul>\n</li>\n<li><a href=\"/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isNaN\">isNaN(): NaN 여부</a></li>\n<li><a href=\"/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isInteger\">isInteger(): 정수 여부</a></li>\n<li><a href=\"/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isSafeInterger\">isSafeInteger(): 안정 정수 여부</a></li>\n<li><a href=\"/2020/03/26/Number%20오브젝트%20-ECMAScript/#Number_isFinite\">isFinite(): 유한 값 여부</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"Number_상수\">Number 상수</h2>\n\n<p>ES6에 다음과 같이 두 개의 Number 상수가 추가되었습니다.</p>\n<table>\n<thead>\n<tr>\n<th>상수 이름</th>\n<th>값</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Number.MAX_SAFE_INTEGER</td>\n<td>9007199254740991 (253 - 1) 최댓값</td>\n</tr>\n<tr>\n<td>Number.MIN_SAFE_INTEGER</td>\n<td>-9007199254740991 (-(253 - 1)) 최솟값</td>\n</tr>\n</tbody></table>\n<p>safe integer(안전 정수)란, 지수(e)를 사용하지 않고 나타낼 수 있는 값을 의미합니다. 2의 64승이 아닌 2의 53승입니다. 위와 같이 최댓값과 최솟값이 있습니다.</p>\n<h3 id=\"64비트-유동-소수점\"><a href=\"#64비트-유동-소수점\" class=\"headerlink\" title=\"64비트 유동 소수점\"></a>64비트 유동 소수점</h3><p>자바스크립트는 IEEE(Institute of Electrical and Electronics Engineers) 754에 정의된 “doble-precision floating-point format numbers”로 숫자 값을 표현합니다.<br>64비트 유동 소수점으로 정수와 소수를 포함하여 64개의 비트로 값을 표현합니다.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/7/76/General_double_precision_float.png\" alt=\"https://commons.wikimedia.org/wiki/File:IEEE_754_Double_Floating_Point_Format.svg\"></p>\n<ul>\n<li>사인 비트(sign bit)<br>MSB(most significant bit): 최상위 비트, 즉 제일 왼 쪽에 있는 63번 비트를 뜻하며 0이면 양수, 1이면 음수를 나타낸다.</li>\n<li>지수(exponent): 62번 비트에서 52번 비트까지의 11개 비트입니다.</li>\n<li>유효 숫자(fraction): 51번 비트부터 0번 비트까지의 52개 비트에 사인 비트를 포함시켜 53개 비트입니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 9007199254740991  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) - <span class=\"number\">1</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// -9007199254740991  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">Number</span>.MIN_SAFE_INTEGER );  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, -(<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) - <span class=\"number\">1</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1</span>: <span class=\"number\">9007199254740991</span>  </span><br><span class=\"line\"><span class=\"number\">2</span>: <span class=\"number\">9007199254740991</span>  </span><br><span class=\"line\"><span class=\"number\">3</span>: <span class=\"number\">-9007199254740991</span>  </span><br><span class=\"line\"><span class=\"number\">4</span>: <span class=\"number\">-9007199254740991</span></span><br></pre></td></tr></table></figure>\n\n<p>자바스크립트 안정 정수 최댓값과 최솟값을 출력한 결과입니다.</p>\n<hr>\n<p>자바스크립트에는 64비트 형식 IEEE 754 정의 값 외에도<br>상징적인 값을 표현하는 Infinity,NaN(숫자가 아님)이 있습니다.</p>\n<p><strong>Number 타입의 값 중에는 두 가지 방식으로 표현할 수 있는 유일한 값이 있는데, 0 이다. 0 은 -0 이나 +0 으로 표시할 수 있다. (“0” 은 물론 +0 이다.) 실제로 이러한 방식은 거의 효력이 없다. 그 예로, +0 === -0 은 true 이다. 하지만 0으로 나누는 경우 그 차이가 눈에 띌 보일 것입니다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>Javascript / 0</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">42</span> / +<span class=\"number\">0</span>  </span><br><span class=\"line\"><span class=\"comment\">// Infinity  </span></span><br><span class=\"line\"><span class=\"number\">42</span> / <span class=\"number\">-0</span>  </span><br><span class=\"line\"><span class=\"comment\">// -Infinity</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Number_EPSILON\">EPSILON</h2>\n\n<ul>\n<li><p>Number.EPSILON 속성(property)은 Number 형으로 표현될 수 있는 1과 1보다 큰 값 중에서 가장 작은 값의, 차이 값입니다.</p>\n</li>\n<li><p>EPSILON 속성은 대략 2.2204460492503130808472633361816E-16 또는 2-52의 값을 갖습니다.</p>\n</li>\n</ul>\n<p>[[Writable]]: false, </p>\n<p>[[Enumerable]]: false, </p>\n<p>[[Configurable]]: false 값을 갖습니다.</p>\n<p><a href=\"https://thrillfighter.tistory.com/349\">부동소수점에 대한 이해</a><br><a href=\"https://perfectacle.github.io/2016/12/24/ES6-Number-object-and-function/#Number-EPSILON\">Number.EPSILON IEEE754 표현식의 문제</a><br><a href=\"https://perfectacle.github.io/2017/08/04/ES6-EPSILON/\">Number.EPSILON은 왜 2.220446049250313e-16인가?</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> total = <span class=\"number\">0.1</span> + <span class=\"number\">0.2</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(total);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> result = (<span class=\"built_in\">Math</span>.abs(<span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> - <span class=\"number\">0.3</span>) &lt; <span class=\"built_in\">Number</span>.EPSILON);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> value = (<span class=\"built_in\">Math</span>.pow(<span class=\"number\">10</span>, <span class=\"number\">1</span>) * <span class=\"number\">0.1</span>) + (<span class=\"built_in\">Math</span>.pow(<span class=\"number\">10</span>, <span class=\"number\">1</span>) * <span class=\"number\">0.2</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(value / <span class=\"number\">10</span> === <span class=\"number\">0.3</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 0.30000000000000004  </span></span><br><span class=\"line\"><span class=\"comment\">// true  </span></span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>자바스크립트에서 0.1 과 0.2 를 더하면 0.3이 아니라</li>\n</ol>\n<ol start=\"2\">\n<li>30000000000000004이 출력됩니다. 이는 자바스크립트가 2진 유동 소수점 방식으로 값을 계산하기 때문입니다. 이와 같이 미세한 값 차이로 인해 값이 일치하지 않을 때<br>Number.EPSILON을 사용합니다. <del>0.1+0.2 == 0.3 // false</del></li>\n</ol>\n<ol start=\"2\">\n<li>0.1과 0.2를 더하고 0.3을 뺸 절댓값이 Number.EPSILON 값보다 작으면 2진 유동 소수점으로 인한 차이로 처리합니다. Number.EPSILON 값보다 작으므로 true가 출력됩니다.</li>\n</ol>\n<ol start=\"3\">\n<li>소수를 정수로 변환하여 계산한 후, 소수를 정수로 변환할 때 곱했던 값으로 나누면 차이가 나지 않습니다. ES5에서 사용가능한 방법입니다.</li>\n</ol>\n<hr>\n<h2 id=\"진수_리터럴\">진수 리터널</h2>\n\n<hr>\n<h3 id=\"2진수-Binary\"><a href=\"#2진수-Binary\" class=\"headerlink\" title=\"2진수(Binary)\"></a>2진수(Binary)</h3><p>첫 번째 숫자 0을 작성하고 두 번째에 소문자 b 또는 대문자 B를 작성합니다.<br>세 번째 부터 값을 0 또는 1로 작성합니다.<br>예시로 5값은 0b0101 또는 0B0101 형태의 값 입니다.</p>\n<hr>\n<h3 id=\"8진수-Octal\"><a href=\"#8진수-Octal\" class=\"headerlink\" title=\"8진수(Octal)\"></a>8진수(Octal)</h3><p>첫 번째 숫자 0을 작성하고 두 번째에 소문자 o 또는 대문자 O를 작성합니다.<br>세 번째 부터 값을 0에서 7까지 작성합니다. 0o0105 또는 0O0105 형태입니다.<br>ES5에서는 첫 번째에 o 또는 O를 작성 했었습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>literal</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2진수  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> two = <span class=\"number\">0b0101</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(two);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 8진수  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> eight = <span class=\"number\">0o0101</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(eight);  </span><br><span class=\"line\"><span class=\"comment\">// 5 65</span></span><br></pre></td></tr></table></figure>\n\n<p>0b0101는 2진수로 값이 5이며, 0o0101는 8진수로 값이 65입니다.<br>웹 개발자에게는 CSS에서 #0012FF 형태의 16진수를 사용하므로 16진수가 더 익숙합니다.</p>\n<hr>\n<h2 id=\"Number_isNaN\">isNaN() : NaN 여부</h2>\n\n<p>Number.isNaN() 메서드는 주어진 값이 NaN인지 판별합니다.<br>(NaN === NaN)의 체크 결과가 false로 반환되는 문제가 있어<br>ES5에서 글로벌 오브젝트 isNaN()을 추가했지만 이 또한 문제가 많아<br>ES6에서 Number.isNaN() 이 새로 추가되었습니다.<br>기존부터 존재한 전역 isNaN() 함수의 더 엄격한 버전입니다.</p>\n<blockquote>\n<p>Number.isNaN(value)</p>\n</blockquote>\n<p>파라미터에 비교 대상 값을 지정합니다.</p>\n<p>주어진 값이 Number이고 값이 NaN이면 true, 아니면 false를 반환합니다.</p>\n<ul>\n<li>글로벌 오브젝트 isNaN() 함수와 달리, Number.isNaN()은 강제로 매개변수를 숫자로 변환하는 문제를 겪지 않습니다. 이는 보통NaN으로 변환됐을 값이 안전하게 전달되지만, 실제로는 NaN과 같은 값이 아님을 의미합니다. 이는 또한 오직 숫자형이고 또한 NaN인 값만이 true를 반환함을 뜻합니다. (엄-격)</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>isNaN</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 예를 들면 아래 예시는 global isNaN()으로 true가 됐을 것임  </span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"NaN\"</span>);      <span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">undefined</span>);  <span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(&#123;&#125;);         <span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"blabla\"</span>);   <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>NaN의 재미난? 특징은 자바스크립트에서 유일하게 자기자신과 값이 같지 않다는 것입니다.<br><code>NaN === NaN; // false</code></p>\n<hr>\n<h2 id=\"Number_isInteger\">isInteger(): 정수 여부</h2>\n\n<p>파라미터 값이 정수이면 true, 아니면 false를 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>isInteger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">0</span>));<span class=\"comment\">// 정수  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">1.0</span>));<span class=\"comment\">// 정수  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">-123</span>));<span class=\"comment\">// 정수  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"built_in\">Number</span>.isInteger(<span class=\"string\">\"12\"</span>));<span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, <span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">1.02</span>));<span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"6:\"</span>, <span class=\"built_in\">Number</span>.isInteger(<span class=\"literal\">NaN</span>));<span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"7:\"</span>, <span class=\"built_in\">Number</span>.isInteger(<span class=\"literal\">true</span>));<span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>파라미터 값이 Number 타입의 정수가 아니면 모두 false를 반환합니다.</p>\n<hr>\n<h2 id=\"Number_isSafeInterger\">isSafeInteger(): 안정 정수 여부</h2>\n\n<figure class=\"highlight js\"><figcaption><span>isSafeInteger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"number\">7.0</span>)); <span class=\"comment\">//true  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER));<span class=\"comment\">//true  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"built_in\">Number</span>.MIN_SAFE_INTEGER));<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>정수 값 이면서 안정 정수의 범위 이면 true를 반환합니다.<br>그 외에는 모두 false를 반환합니다.</p>\n<hr>\n<h2 id=\"Number_isFinite\">isFinite(): 유한 값 여부</h2>\n\n<p>파라미터에 비교 대상 값을 지정합니다.<br>그 값이 유한 값이면 true, 아니면 false를 반환합니다.</p>\n<p>글로벌 오브젝트의 isFinite()와 값 차이가 있으므로 주의합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>isFinite</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">Infinity</span>), <span class=\"built_in\">isFinite</span>(<span class=\"literal\">Infinity</span>));  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"built_in\">Number</span>.isFinite(-<span class=\"literal\">Infinity</span>), <span class=\"built_in\">isFinite</span>(-<span class=\"literal\">Infinity</span>));  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">0</span>), <span class=\"built_in\">isFinite</span>(<span class=\"number\">0</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">///////////////////////////////////////  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">\"0\"</span>), <span class=\"built_in\">isFinite</span>(<span class=\"string\">\"0\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, <span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">null</span>), <span class=\"built_in\">isFinite</span>(<span class=\"literal\">null</span>));  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"6:\"</span>, <span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">NaN</span>), <span class=\"built_in\">isFinite</span>(<span class=\"literal\">NaN</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"7:\"</span>, <span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">undefined</span>), <span class=\"built_in\">isFinite</span>(<span class=\"literal\">undefined</span>));  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"8:\"</span>, <span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">true</span>), <span class=\"built_in\">isFinite</span>(<span class=\"literal\">true</span>));  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">1: false false  </span></span><br><span class=\"line\"><span class=\"comment\">2: false false  </span></span><br><span class=\"line\"><span class=\"comment\">3: true true  </span></span><br><span class=\"line\"><span class=\"comment\">//////////////////  </span></span><br><span class=\"line\"><span class=\"comment\">4: false true  </span></span><br><span class=\"line\"><span class=\"comment\">5: false true  </span></span><br><span class=\"line\"><span class=\"comment\">6: false false  </span></span><br><span class=\"line\"><span class=\"comment\">7: false false  </span></span><br><span class=\"line\"><span class=\"comment\">8: false true  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>"},{"title":"Promise 오브젝트 -ECMAScript","date":"2020-04-14T00:44:27.000Z","disqusId":"tunas-blog-1","_content":"\n\nPromise 오브젝트는 비동기(Asynchronous)처리를 위한 메커니즘을 제공합니다.  \nES5까지 없었던 개념으로 ES6에 추가되었습니다.\n\n*   Promise 오브젝트\n    *   [개요](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise)\n        *   Promise 처리 순서\n    *   [Promise 상태](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_상태)\n        *   settled 상태\n        *   fulfill (성공)\n        *   reject (실패)\n    *   [new Promise(): Promise 인스턴스 생성](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#newPromise)\n    *   [then(): 성공, 실패 핸들러](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_then)\n    *   [catch(): 실패 핸들러](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_catch)\n    *   [resolve(): 성공 상태의 인스턴스 반환](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_resolve)\n        *   thenable\n    *   [reject(): 실패 상태의 인스턴스 반환](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_reject)\n    *   [all(): 모두 성공이면 핸들러 실행](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_all)\n    *   [race(): 처음 한 번만 핸들러 호출](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_race)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Promise\">개요</h2>\n\n자바스크립트는 기본적으로 동기(Synchronous)로 실행합니다. 동기 실행이란 현재 코드가 실행을 완료해야 다음 코드가 실행되는 것을 의미합니다. 여러 줄의 코드가 있다고 했을 때, 첫째 줄의 코드가 실행을 완료해야 둘째 줄이 실행되며, 둘째 줄이 실행을 완료해야 셋째 줄이 실행되는 형태입니다.\n\n반면, Promise는 비동기(Asynchronous)로 실행합니다. XMLHttp Request의 비동기 통신과 비슷합니다.  \n클라이언트에서 서버로 보낸 요청(Request)에 서버가 응답(Response)할 때까지 통신이 연결된 상태에서 기다리지 않습니다. 따라서 서버가 처리하는 동안 다른 처리를 할 수 있습니다. 클라이언트에서 서버가 응답했을 때의 처리를 사전에 정의해 두면, 서버가 응답했을 때 정의한 코드가 자동으로 실행됩니다.  \nPromise도 이와 개념이 비슷합니다.\n\n코드 구현 관점에서 보면 Promise는 하나의 오브젝트입니다. Promise 오브젝트에서 비동기 처리 방법을 제공하므로 이에 맞추어 코드를 작성하면 됩니다.\n\nPromise 오브젝트는 DOM(Document Object Model)에서 처음 제시되었으나 현재는 JavaScript 스펙에 포함되었습니다. 따라서 DOM에서도 사용이 가능하며 이는 DOM을 사용하는 다른 언어에서도 Promise를 사용할 수 있다는 것이 됩니다.\n\n### Promise 처리 순서\n\nPromise 개념을 이해하기 위해 Promise의 비동기 처리 흐름을 간단하게 살펴봅니다.\n\n```js Promise 처리 흐름\n1. function create(){  \n 3. return new Promise(function(resolve, reject){  \n resolve();  \n console.log(\"1: resolve\");  \n });  \n};  \n  \n2. 4. 6. create().then(function(){  \n console.log(\"3: 성공\");  \n}, function(){  \n console.log(\"3: 실패\");  \n});  \n5. console.log(\"2: 끝\");  \n// 1: resolve  \n// 2: 끝  \n// 3: 성공  \n```\n\n1.  엔진이 function 키워드를 만나면 create()를 호출할 수 있도록 Function 오브젝트로 생성합니다.  \n    함수 안에 코드는 실행하지 않고 다음 줄로 이동합니다.\n\n2.  create() 함수를 호출합니다. 함수 안에 코드가 실행됩니다.\n\n3.  1.  return 문의 표현식을 평가하므로 new Promise()로 인스턴스를 생성합니다.\n    2.  이때, Promise() 파라미터에 작성한 function(){}을 실행합니다. (function을 executer(실행자)라고 합니다.)\n    3.  function(executer) 블록의 첫째 줄에 resolve()가 작성되어 있습니다. 그런데 호출을 받아서 처리할 같은 이름의 함수가 소스 코드에 없습니다. 단지 파라미터에 resolve가 작성되어 있을 뿐입니다.\n    4.  resolve() 형태가 함수를 호출하는 형태이지만 호출하지 않습니다. 이에 대해서는 사전 설명이 필요하므로 뒤에서 다룹니다.\n    5.  다음 줄에 console.log()를 실행하여 “1: resolve”를 출력합니다.\n    6.  생성한 인스턴스를 반환합니다.  \n        <mark>여기서 중요한 점이 executer가 실행된다는 것과 resolve()가 호출되지 않는다는 점입니다. resolve()를 바로 호출하지 않고 호출할 수 있는 환경이 되었을 때 호출합니다.<mark>\n\n4.  create() 실행이 끝나면 생성한 Promise 인스턴스를 반환합니다. Promise 인스턴스에 then()이 있으므로 이어서 then()을 호출할 수 있습니다. 하지만 then()을 호출하지 않고, 아래 코드로 이동합니다.  \n    <mark>앞에서 resolve()를 호출할 수 있는 환경이 되었을 때 호출하는 것과 then()을 실행하지 않고 아래 코드로 이동하는 것이 Promise 비동기 처리의 핵심 매커니즘 입니다.</mark>\n\n5.  create() 실행 이후에 then()을 호출하지 않고 다음 줄로 이동했을 때 만나는 코드입니다.  \n    “2: 끝”이 출력됩니다. 이제 더 이상 남아있는 코드가 없습니다.\n\n6.  이제 남은 것은 then()에 작성한 function()의 실행입니다.  \n    then()은 두 개의 파라미터를 갖고 있습니다.  \n    위 코드에서는 첫 번째 파라미터의 function이 실행되어 “3: 성공”이 출력됩니다.  \n    두 번째 파라미터의 function은 실행되지 않습니다. 첫 번째 파라미터 function이 실행된 이유는 뒤에서 다룹니다.\n\n*   console.log 출력 순서를 보면\n    1.  “1: resolve”는 new Promise()로 인스턴스를 생성할 때 executer에서 출력합니다.  \n        Promise 인스턴스를 생성해야 메서드를 사용할 수 있으므로 먼저 인스턴스를 생성합니다.\n    2.  “2: 끝”은 create()에 연결된 then()을 실행하지 않으므로 두 번째로 실행됩니다.\n    3.  “3: 성공”은 소스 코드 전체를 끝까지 처리한 후 실행되어 세 번째로 출력됩니다.\n\n* * *\n\n<h2 id=\"Promise_상태\">Promise 상태</h2>\n\nPromise는 코드를 실행할 때마다 진행 상태를[[PromiseState]]에 저장합니다.  \n상태를 저장하는 이유는 연속해서 코드를 실행하지 않고, 소스 코드 끝까지 내려갔다 다시 올라와서 실행하므로 진행 상태가 필요하기 때문입니다. 상태에 따라 다음 단계를 처리하기 위해서 입니다.\n\n<img src=\"/images/promise.SVG\">\n\nPromise 진행 상태는 크게 두 가지로 나눌 수 있습니다.  \npending 과 settled로 나뉩니다.  \nsettled 상태는 다시 fulfill(성공) 과 reject(실패)로 나눌 수 있습니다.  \npending 과 settled는 상태이면서 발생 단계입니다. 먼저 pending 상태가 되었다가 settled 상태로 넘어갑니다.  \n단계로 보면 두 단계 (pending, settled)이지만 상태 측면에서 보면 세 개이므로 세 개의 상태로 분류하기도 합니다.\n\n### pending 상태\n\n```js pending\nfunction create(){  \n return new Promise(function(resolve, reject){  \n resolve();  \n console.log(\"1: resolve\");  \n });  \n};  \n```\n\npending 상태(단계)에서는 위 코드와 같이 우선 new Promise()로 인스턴스를 생성합니다. 그리고 <mark>executer를 실행하여 성공과 실패에 따라 호출할 핸들러 함수를 바인딩 합니다.</mark>\n바인딩이란 resolve()와 같이 바로 함수를 호출하지 않고 나중에 호출하므로, 그때를 위한 호출 환경을 설정하는 것을 의미합니다.\n\nexecuter 블록의 코드를 실행하지 않고 소스 코드 끝까지 처리한 후 실행하므로 이 시점에서 Promise 처리의 성공과 실패를 알 수 없습니다. 따라서 성공 또는 실패가 발생했을 때, 이에 따라 함수가 호출될 수 있도록 환경 설정이 필요합니다.\n\n### settled 상태\n\n```js settled\ncreate().then(function(){  \n console.log(\"3: 성공\");  \n}, function(){  \n console.log(\"4: 실패\");  \n});  \n```\n\npending 상태가 종료되면 settled 상태로 변환됩니다. 이때 처리의 성공과 실패를 알 수 있습니다.  \nsettled 상태는 다시 fulfill(성공) 상태와 reject(실패) 상태로 구분됩니다. 상태에 따라 pending 단계에서 바인딩한 핸들러 함수가 호출됩니다.\n\n#### fulfill (성공)\n\nexecuter 불록의 코드가 성공적으로 실핸된 상태를 나타냅니다.  \nthen()의 첫 번째 파라미터의 핸들러(function)가 실행됩니다. - 핸들러 안에 성공에 따른 코드를 작성합니다.\n\n#### reject (실패)\n\nexecuter 블록의 코드 실행이 실패한 상태를 나타냅니다.  \nthen()의 두 번째 파라미터의 핸들러가 실행됩니다. - 핸들러 안에 실패에 따른 코드를 작성합니다.\n\n* * *\n\n<h2 id=\"newPromise\">new Promise(): Promise 인스턴스 생성</h2>\n\nPromise 인스턴스를 생성하여 반환합니다.\n\n> new Promise()\n\n```js\nnew Promise(function(resolve, reject){  \n resolve( );  \n reject( );  \n });  \n```\n\n*   executer에 두 개의 파라미터를 작성할 수 있습니다. 첫 번째 파라미터에 executer 블록에서 처리를 성공했을 때 호출할 핸들러 이름(resolve)를 작성합니다. 두 번째 파라미터에 실패했을 때 호출할 핸들러 이름(reject)를 작성합니다. resolve 와 reject는 가독성을 위한 것으로 다른 이름을 사용해도 됩니다.\n    \n*   executer 블록에 핸들러 함수를 작성하지 않으면, then()의 파라미터에 작성한 함수가 실행되지 않습니다.  \n    핸들러 함수 이름과 executer의 파라미터에 작성한 이름과 같아야 하며, 같지 않으면 에러가 발생합니다.  \n    예를 들어, resolve() 와 function(resolve)와 같이 resolve 이름이 같아야 합니다.\n    \n```js\nfunction create(param){  \n 2. return new Promise(function(resolve, reject){  \n 3. if (param === \"ok\"){  \n resolve(param);  \n 4. console.log(\"1: resolve\");  \n } else {  \n reject(param);  \n }  \n });  \n};  \n1. 5. create(\"ok\").then(function(param){  \n 7. console.log(\"3: 성공,\", param);  \n}, function(param){  \n console.log(\"3: 실패,\", param);  \n});  \n6. console.log(\"2: 끝\");  \n// 1: resolve  \n// 2: 끝  \n// 3: 성공, ok  \n```\n\n1.  create()를 호출하면서 “ok”를 파라미터 값으로 넘겨 줍니다. 호출받은 create() 함수의 파라마터 param에 설정됩니다.\n\n2.  executer의 파라미터에 resolve 와 reject를 작성했습니다. Function 오브젝트를 생성하여 resolve 와 reject에 할당합니다. Promise 인스턴스를 생성하여 return 한 후, create()에 연결된 then()의 파라미터에 작성한 함수와 연결합니다.  \n    이렇게 설정함으로써 executer 블록에서 resolve()를 호출하면 then()의 첫 번째 파라미터의 함수가 호출되고, reject()를 호출하면 then()의 두 번째 파라미터의 함수가 호출됩니다.  \n    executer 파라미터의 resolve와 executer 블록의 resolve()와 then()의 첫 번째 파라미터 함수가 연결되고,  \n    executer 파라미터의 reject와 executer 블록의 reject()와 then()의 두 번째 파라미터 함수가 연결되는 것입니다.\n\n3.  param 값으로 받은 파라미터가 “ok”이므로 true가 되어 if 문 블록을 수행합니다.  \n    resolve(param)가 함수를 호출하는 형태이지만, 지금 호출하지 않고 소스 코드를 끝까지 실행한 후 되돌아와서 호출합니다. 되돌아와서 resolve()를 호출하면 이를 받아 실행할 같은 이름의 함수가 없습니다.  \n    <mark>이때 executer 파라미터의 resolve에 설정된 함수를 호출합니다. 그러면 resolve 와 then()의 첫 번째 파라미터의 함수와 연결되어 있으므로 then()의 첫 번째 함수가 연결되어 있으므로 then()의 첫 번째 함수가 실행됩니다. 이것이 Promise의 비동기 처리 메커니즘입니다.</mark>\n\n4.  resolve(param) 다음 줄에 console.log을 실행하며 “1: resolve”를 출력합니다.  \n    이제 남은 것은 생성한 인스턴스를 반환하는 것입니다.\n\n5.  create(“ok”)의 호출이 완료되면 Promise 인스턴스를 반환하므로 “인스턴스.then()” 형태가 되어 then()을 실행할 수 있지만 바로 실행하지 않습니다. 우선 then()의 첫 번째 파라미터를 executer의 resolve에 바인딩하고, then()의 두 번째 파라미터를 executer의 reject에 바인딩 합니다.  \n    이렇게 바인딩을 함으로써 executer 블록에서 resolve()를 호출했을 때 then()의 첫 번째 파라미터에 작성한 함수가 실행됩니다.\n\n6.  소스 코드의 마지막 코드로 console에 “2: 끝”을 출력합니다. 모든 코드를 읽었으므로 이제 남은 것은 resolve()를 실행하는 것입니다.\n\n7.  executer 블록에서 resolve(param)을 호출하면, then()의 첫 번째 파라미터 함수가 호출됩니다.  \n    이때, resolve(param)에서 param 값인 “ok”가 핸들러 함수인 function(param)의 param에 설정됩니다.  \n    따라서 console에 “3: 성공, ok”가 출력됩니다.\n\n```js fail\nfunction create(param){  \n return new Promise(function(resolve, reject){  \n if (param === \"ok\"){  \n resolve(param);  \n } else {  \n reject(param);  \n console.log(\"1: reject\");  \n }  \n });  \n};  \n1. create(\"fail\").then(function(param){  \n console.log(\"3: 성공,\", param);  \n}, function(param){  \n console.log(\"3: 실패,\", param);  \n});  \nconsole.log(\"2: 끝\");  \n// 1: reject  \n// 2: 끝  \n// 3: 실패, fail  \n```\n\n*   바로 앞에서 다룬 코드는 성공 기준이며 위 코드는 실패 기준입니다.  \n    Promise 처리 흐름은 같습니다. then()의 두 번째 파라미터에 작성한 함수가 실행된다는 점이 다릅니다.\n\n1.  create()를 호출하면서 “fail”을 파라미터 값으로 넘겨 줍니다.  \n    호출된 create() 함수에서 if 문의 else 블록 reject(param)과 console.log(“1: reject”)를 실행하게 됩니다.  \n    물론 reject(param)은 이때 호출되지 않고 소스 코드를 끝까지 실행한 후 되돌아와서 호출 환경이 설정되있을 때 호출됩니다.  \n    executer 블록에서 reject()가 호출되면 then()의 두 번째 파라미터에 작성한 함수가 실행됩니다.  \n    따라서 콘솔에 “3: 실패, fail”이 출력됩니다.\n\n* * *\n\n<h2 id=\"Promise_then\">then(): 성공, 실패 핸들러</h2>\n\n성공과 실패 핸들러를 정의합니다.\n\n> Promise.prototype.then(onFulfilled, onRejected)\n\n첫 번째 파라미터에 Promise가 성공 상태가 되었을 때 실행될 핸들러 함수를 작성합니다.  \n두 번째 파라미터에 Promise가 실패 상태가 되었을 때 실행될 핸들러 함수를 작성합니다.\n\n*   executer 블록의 resolve() 와 reject()에서 다수의 파라미터 값을 넘겨주더라도 핸들러 함수에서 첫 번째 파라미터 하나만 받습니다. 따라서 여러 개의 파라미터 값을 넘겨 주려면 resolve()와 reject()의 파라미터에 배열과 같은 형태로 작성해야 합니다.\n\n*   resolve(성공) 와 reject(실패) 핸들러 함수에서 return 문의 작성 여부와 관계없이 현재 실행 중인 Promise 인스턴스를 반환합니다. return 문을 작성하면 return 문의 표현식을 평가하고 그 결과를 [[PromiseValue]]에 undefined를 설정합니다.\n\n*   then() 에서 Promise 인스턴스를 반환하므로 then(one).then(two)와 같이 then()을 연속해서 작성할 수 있습니다. 이때, 첫 번째 then()에서 [[PromiseValue]]에 설정한 값이 두 번째 then(two)의 파라미터인 two에 설정됩니다. 핸들러 함수에서 Promise 인스턴스를 반환하여 연속해서 메서드를 호출할 수 있도록 하고, return 문의 반환 값을 [[PromiseValue]]에 설정하여 다음 then()의 핸들러 함수의 파라미터에 설정합니다.\n\n```js then()\n1. function create(){  \n return new Promise((resolve) => resolve(100));  \n};  \n2. create().then(() => console.log(\"1:then\"));  \n  \n  \n3. create().then((param) => {  \n console.log(\"2:then,\", param);  \n return param + 50;  \n});  \n  \n  \n4. create().then((param) => {  \n console.log(\"3:then,\", param);  \n return param + 70;  \n}).then((param) => console.log(\"4:then,\", param));  \n// 1:then  \n// 2:then, 100  \n// 3:then, 100  \n// 4:then, 170  \n```\n\n1.  create()가 호출되면 executer 블록의 resolve()를 수행하게 됩니다.  \n    하지만 호출받을 resolve 함수가 없으므로 호출 환경이 되었을 때 호출합니다.  \n    즉, 소스 코드 끝까지 처리하고 되돌아와 호출합니다.  \n    실패가 발생하지 않으면 executer의 파라미터와 블록에 reject를 작성하지 않아도 됩니다.\n\n2.  then()의 첫 번째 파라미터에 핸들러 함수를 작성하여 연결합니다. executer 블록에서 resolve 파라미터 값으로 100을 넘겨 주지만 이 코드에서는 사용되지 않습니다. “1:then”을 출력합니다.\n\n3.  두 번째로 create()를 호출하여 Promise 인스턴스를 생성합니다. executer 블록에서 resolve(100)으로 호출하면, then()의 첫 번째 파라미터의 핸들러 함수가 실행되며 100이 param에 설정됩니다.  \n    return문의 표현식을 평가한 150을 [[PromiseValue]]에 설정만하고 반환하지 않으며, 실행 중인 Promise 인스턴스를 반환합니다.\n\n4.  세 번째로 create()를 호출하여 Promise 인스턴스를 생성합니다. then()의 첫 번째 파라미터의 핸들러 함수가 호출되면 param 파라미터에 100이 설정됩니다. return 문의 표현식을 평가한 170을 [[PromiseValue]]에 설정하고 실행중인 Promise 인스턴스를 반환합니다.  \n    then()에서 Promise 인스턴스를 반환하므로 두 번째 .then() 으로 호출할 수 있습니다.  \n    [[PromiseValue]]에 설정된 170이 param 파라미터에 설정되며 “4: then, 170”이 출력됩니다.\n\n코드 실행 순서 정리 :\n\n1.  첫 번째 create() 함수를 호출합니다. Promise 인스턴스를 반환합니다.  \n    연결된 then()의 핸들러 함수를 실행하지 않고 아래로 이동합니다.\n\n2.  두 번째 create() 함수를 호출합니다. Promise 인스턴스를 반환합니다.  \n    연결된 then()의 핸들러 함수를 실행하지 않고 아래로 이동합니다.\n\n3.  세 번째 create() 함수를 호출합니다. Promise 인스턴스를 반환합니다.  \n    연결된 then()의 핸들러 함수를 실행하지 않고 아래로 이동합니다.\n\n4.  더 이상 처리할 코드가 없습니다.\n\n5.  첫 번째의 executer 블록의 resolve()가 호출되며 then()의 핸들러 함수가 실행됩니다.  \n    콘솔에 “1:then”이 출력됩니다.\n\n6.  두 번째의 executer 블록의 resolve()가 호출되며 then()의 핸들러 함수가 실행됩니다.  \n    콘솔에 “2:then, 100”이 출력됩니다.\n\n7.  세 번째의 executer 블록의 resolve()가 호출되며 then()의 핸들러 함수가 실행됩니다.  \n    콘솔에 “3:then, 100”이 출력됩니다.\n\n8.  세 번째의 then()에 연결된 then()의 핸들러 함수가 실행됩니다.  \n    콘솔에 “4:then, 170”이 출력됩니다.\n\n<mark>then().then()과 같이 then()이 연결되어 있으면, 처음 then()의 핸들러 함수를 실행한 후, 두 번째 then()의 함수 코드를 실행합니다. 이때 처음 then()의 return 값이 두 번째 then()함수의 파라미터 값으로 설정됩니다.</mark>\n\n* * *\n\n<h2 id=\"Promise_catch\">catch(): 실패 핸들러</h2>\n\n실패(reject) 핸들러를 정의합니다.\n\n> Promise.prototype.catch(onRejected)\n\n*   파라미터에 Promise가 reject 상태가 되었을 때 실행될 핸들러 함수를 작성합니다.  \n    then()의 첫 번째 파라미터에 함수를 작성하고, 두 번째 파라미터는 작성하지 않습니다.  \n    대신 then().catch() 형태로 작성하여 then()의 두 번째 파라미터에 작성할 함수를 catch()의 파라미터에 작성합니다. then()은 성공했을 때 실행되며 catch()는 실패했을 때 실행됩니다.\n    \n*   catch() 의 핸들러 함수에 파라미터를 하나만 작성할 수 있습니다.  \n    executer 블록의 reject() 에서 다수의 파라미터를 넘겨주려면 배열과 같은 형태로 작성해야 합니다.\n    \n*   catch()의 핸들러 함수에서 return 문의 작성 여부와 관계없이 현재 실행 중인 Promise 인스턴스를 반환합니다.\n    \n*   catch().then()과 같이 catch() 다음에 then()을 연결할 수 있으며, catch()에서 설정한 [[PromiseValue]] 값을 then()의 파라미터 값으로 넘겨줍니다.\n    \n```js\nfunction create(param){  \n return new Promise((resolve, reject) =>{  \n 1. param === \"ok\" ? resolve(param) : reject(param);  \n });  \n};  \n  \n2. create(\"fail\").then((param) => {  \n console.log(\"성공:\", param);  \n}).catch((param) => {  \n console.log(\"실패:\", param);  \n});  \n// 실패 : fail  \n```\n\n1.  파라미터로 받은 param 값이 “ok”이면 resolve(param)을 호출하고, 아니면 reject(param)을 호출합니다.  \n    “fail”값으로 create()를 호출합니다. 따라서 reject()를 호출하게 되며, catch()의 핸들러 함수가 실행됩니다.\n\n2.  create(“fail”)로 호출하여 Promise 인스턴스를 생성합니다.  \n    executer 블록에서 reject()가 호출되므로 catch()의 핸들러 함수가 실행됩니다.  \n    reject(param)에서 param 값이 핸들러 함수의 파라미터인 param에 설정됩니다.  \n    실패만 발생하므로 then()의 핸들러 함수는 실행되지 않고, catch() 핸들러 함수만 실행됩니다.\n\n```js\nfunction create(param){  \n return new Promise((resolve, reject) =>{  \n resolve(\"resolve\");  \n });  \n};  \n  \n1.   \ncreate().then((param) => {  \n console.log(\"1:then,\", param);  \n throw \"에러 발생 시킴\";  \n2.  \n}).catch((param) => {  \n console.log(\"2:catch,\", param);  \n3.  \n}).then((param) => {  \n console.log(\"3:then,\", param);  \n}).catch((param) => {  \n console.log(\"4:catch,\", param);  \n});  \n// 1: then, resolve  \n// 2: catch, 에러 발생 시킴  \n// 3: then, undefined  \n```\n\n1.  then()의 핸들러 함수가 실행되면 콘솔에 “1:then, resolve”가 출력됩니다.  \n    이어서 throw 문으로 에러를 발생시킵니다. 그러면 then()에 이어서 작성한 catch()핸들러 함수가 실행됩니다.\n\n2.  executer 블록에서 reject()를 호출해도 catch()의 핸들러 함수가 실행되지만,  \n    then()에서 에러가 발생해도 catch()의 핸들러 함수가 실행됩니다.  \n    이때, 앞 then()의 throw문에 작성한 “에러 발생 시킴”이 catch() 핸들러 함수의 param 파라미터에 설정됩니다. 콘솔에 “2:catch, 에러 발생 시킴”이 출력됩니다.  \n    핸들러 함수에 return 문을 작성하지 않았으므로 [[PromiseValue]]에 undefined가 설정되며 실행 중인 Promise 인스턴스가 반환됩니다. catch()에서 에러가 발생하지 않으면 then().catch().then().catch() 형태에서 catch()에 연결된 두 번째 then()이 실행됩니다. 만약 에러가 발생하여 두 번째 catch()를 실행하더라도 소스 코드 전체가 종료되지 않습니다.\n\n3.  then()이 실행되면 catch()에서 [[PromiseValue]]에 설정한 undefined가 param 파라미터에 설정됩니다.  \n    콘솔에 “3:then, undefined”가 출력됩니다. then()에 이어서 catch()가 있지만, then()에서 에러가 발생하지 않았으므로 catch()가 실행되지 않습니다. then()의 핸들러 함수를 실행한 후, 소스 코드 전체가 종료됩니다.\n\n* * *\n\n<h2 id=\"Promise_resolve\">resolve(): 성공 상태의 인스턴스 반환</h2>\n\nfulfill(성공) 상태의 Promise 인스턴스를 반환합니다.\n\n> Promise.resolve()\n\n*   파라미터  \n    value, promise, thenable\n    \n*   반환 값  \n    파라미터 값에 따라 반환 형태가 다릅니다.\n    \n\n파라미터에 값을 작성하면 성공 상태의 Promise 인스턴스를 생성하여 반환합니다.  \n이어서 then()을 작성하면 then()의 첫 번째 파라미터에 작성한 함수가 호출됩니다.  \n파라미터에 Promise 인스턴스를 지정하면 인스턴스를 성공 상태로 변환하여 반환합니다.\n\n```js\n1. let promiseObj = Promise.resolve(  \n {sports: \"스포츠\", music: \"음악\"}  \n);  \n2. promiseObj.then((param) =>{  \n for (let name in param){  \n console.log(name, param[name]);  \n }  \n});  \n  \n3. Promise.resolve(  \n [\"sports\", \"music\"]  \n).then((param) => console.log(param));  \n// sports 스포츠  \n// music 음악  \n// [\"sports\", \"music\"]  \n```\n\n1.  Promise.resolve()를 호출하면 Promise 인스턴스를 생성하고 Promise를 성공 상태로 설정하여 반환합니다.  \n    then()의 핸들러 함수에 파라미터 하나만 작성할 수 있으므로 다 수의 파라미터 값을 넘겨주기 위해 Object 오브젝트로 작성했습니다.\n    \n    *   다음은 promiseObj 인스턴스 구조입니다.\n    <img src=\"/images/resolvePromiseObj.JPG\">\n    \n    1.  __proto__에 첨부된 프로퍼티가 Promise.prototype에 연결된 프로퍼티와 같습니다.  \n        이는 new 연산자를 사용하지 않고 Promise.resolve()를 실행해도 Promise 인스턴스를 생성한다는 의미입니다.\n        \n    2.  [[PromiseState]] 값이 “resolve”로 설정되어 있습니다. 따라서 then()의 첫 번째 파라미터의 핸들러 함수가 실행됩니다.\n        \n    3.  Promise.resolve()의 파라미터 값이 [[PromiseValue]]에 설정되었으며 then()의 핸들러 함수의 파라미터에 설정됩니다.\n        \n\n2.  PromiseObj의 Promise 인스턴스가 성공 상태이므로 then()의 첫 번째 파라미터 함수가 실행됩니다.  \n    이 시점에서 실행되지 않고 소스 코드에 작성된 코드를 끝까지 처리한 후 실행됩니다.  \n    핸들러 함수의 param 파라미터에 {sports: “스포츠”, music: “음악”}이 설정됩니다.\n\n3.  Promise.resolve() 가 Promise 인스턴스를 생성하여 반환하므로 then()을 연결하여 작성할 수 있습니다.  \n    지금 then()의 핸들러 함수를 실행하지 않고, 위에 작성한 then()의 핸들러 함수를 먼저 실행한 후 실행합니다.  \n    resolve()파라미터 값인 [“sports”, “music”]이 then()의 핸들러 함수의 param 파라미터에 설정됩니다.\n\n```js\n1. let oneObj = Promise.resolve(  \n {sports: \"스포츠\"}  \n);  \n2. Promise.resolve(oneObj).then((param) =>{  \n console.log(param);  \n});  \n// Object {sports: \"스포츠\"}  \n```\n\n*   promise.resolve() 파라미터에 promise.resolve()로 생성한 인스턴스를 지정한 형태입니다.\n\n1.  Promise 인스턴스를 생성하여 반환합니다. 이때 resolve( )의 파라미터 값이 [[PromiseValue]]에 설정됩니다.\n\n2.  Promise.resolve() 파라미터에 앞에서 생성한 Promise 인스턴스를 지정했습니다.  \n    then()의 핸들러 함수가 실행되면 oneObj 인스턴스 [[PromiseValue]]에 설정된 값이 핸들러 함수의 param 파라미터에 설정됩니다. 즉, {sports: “스포츠”}가 설정됩니다.\n\n### thenable\n\n> let obj = {then(resolve,reject) {…} }와 같이 오브젝트 안에 then()을 작성한 형태를 thenable이라고 합니다.\n\n```js\n1. let oneObj = Promise.resolve({  \n then(resolve){  \n console.log(\"1: then\");  \n resolve(\"thenable\");  \n }  \n});  \n2. oneObj.then((value) => console.log(\"2:\",value));  \n// 1: then  \n// 2: thenable  \n```\n\n1.  Promise.resolve()의 파라미터에 Object 오브젝트를 작성하고, 그 안에 then()을 작성했습니다.  \n    이를 thenable이라고 합니다.이 시점에서는 Promise 인스턴스만 생성하고 then()을 실행하지 않습니다.  \n    소스 코드의 마지막 코드까지 실행한 후 then()을 실행합니다.  \n    oneObj에 생성한 인스턴스를 할당한 시점의 [[PromiseState]]값은 “pending”입니다.  \n    then()의 resolve(“thenable”)을 호출하기 전까지 “pending”상태 이며 호출하면 “resolved”로 바뀝니다.\n\n2.  oneObj 인스턴스에 then()이 포함되어 있으므로 위 코드를 연결하면 oneObj.then().then() 형태가 됩니다.  \n    이 형태는 다음과 같은 순서와 방법으로 실행됩니다.\n    1.  oneObj 인스턴스의 then(resolve)가 실행됩니다.\n    2.  콘솔에 “1:then”을 출력합니다.\n    3.  resolve(“thenable”)을 호출합니다. 이때[[PromiseValue]]에 “thenable”을 설정합니다.\n    4.  oneObj.then().then() 형태에서 두 번째 then()이 호출됩니다.\n    5.  두 번째 then()의 value 파라미터에 [[PromiseValue]] 값인 “thenable”이 설정됩니다.\n    6.  콘솔에 “2:thenable”을 출력합니다.\n\n```js\nlet thenable = {  \n then(resolve, reject){  \n resolve(\"resolve\");  \n reject(\"에러\");  \n }  \n};  \n1. let oneObj = Promise.resolve(thenable);  \n  \n2. oneObj.then(  \n (value) => console.log(value),  \n (value) => console.log(\"실행되지 않음\")  \n);  \n// resolve  \n```\n\n*   Object 오브젝트에 then(resolve,reject)를 작성하였으며, resolve() 다음 줄에 reject()를 작성하였습니다. 작성 형태만 보면 resolve()를 호출하고 reject()를 호출할 것으로 보이지만,  \n    <mark>성공 또는 실패 하나만 발생하므로 먼저 작성한 resolve()만 호출됩니다.  \n    반대로 reject(), resolve() 순서로 작성하면 reject()만 호출되고 resolve()는 호출되지 않습니다.</mark>\n\n1.  Promise.resolve() 파라미터에 thenable 오브젝트를 지정하여 Promise 인스턴스를 생성합니다. 이때 then()은 실행되지 않습니다.\n\n2.  oneObj.then()에 두 개의 파라미터를 작성했습니다.  \n    첫 번째 파라미터는 resolve()로 호출했을 때 실행되는 함수이고  \n    두 번째 파라미터는 reject()로 호출했을 때 실행되는 함수입니다.  \n    oneObj 인스턴스에 then()이 있으므로 oneObj.then()은 then().then() 형태가 됩니다.  \n    첫 번째 then()에서 resolve(“resolve”)를 호출하면 [[PromiseValue]]에 “resolve”가 설정됩니다.  \n    두 번째 then()의 첫 번째 파라미터 함수가 실행되며, value 파라미터에 “resolve”가 설정됩니다.  \n    두 번째 파라미터 함수는 reject()를 호출하였을 때 실행되므로 위 코드에서는 실행되지 않습니다.\n\n* * *\n\n<h2 id=\"Promise_reject\">reject(): 실패 상태의 인스턴스 반환</h2>\n\nreject(실패) 상태의 Promise 인스턴스를 반환합니다.\n\n> Promise.reject()\n\n*   파라미터에 실패 사유를 작성합니다.\n    \n*   reject 상태로 변환된 Promise 인스턴스를 반환합니다.\n    \n```js\n1. let promiseObj = Promise.reject(\"reject 처리\");  \n2. promiseObj.then(  \n (param) => console.log(param),  \n (param) => console.log(\"에러:\", param));  \n// 에러: reject 처리  \n```\n\n1.  Promise.reject()를 실행하면 reject 상태의 Promise 인스턴스를 생성하여 반환합니다.  \n    파라미터 값이 [[PromiseValue]]에 설정되며, then()의 두 번째 파라미터 함수의 파라미터 값으로 설정됩니다.  \n    다음은 promiseObj 인스턴스 구조입니다.\n    <img src=\"/images/rejectPromiseObj.JPG\">\n    \n    1.  Promise 인스턴스의 상태는 “reject”입니다. 따라서 then()의 두 번째 파라미터 함수가 호출됩니다.\n    2.  Promise.reject() 파라미터에 작성한 “reject 처리”가 [[PromiseValue]]에 설정됩니다.\n\n2.  promiseObj.then()에 두 개의 파라미터를 작성했습니다. 첫 번째 파라미터 함수는 resolve()로 호출했을 때 실행되고, 두 번째 파라미터 함수는 reject()로 호출했을 때 실행됩니다. 현재 reject 상태이므로 두 번째 파라미터 함수가 실행됩니다.\n\n* * *\n\n<h2 id=\"Promise_all\">all(): 모두 성공이면 핸들러 실행</h2>\n\n파라미터의 모든 Promise 인스턴스가 성공 상태이면 then()의 핸들러 함수를 실행합니다.\n\n> Promise.all()\n\n*   파라미터에 이터러블 오브젝트를 작성합니다.  \n    이터러블 오브젝트에 작성한 순서로 Promise 인스턴스를 생성합니다.\n\n<mark>생성한 모든 Promise 인스턴스가 성공 상태이면, then()의 첫 번째 파라미터 함수를 실행합니다.  \nPromise 인스턴스가 하나라도 실패한다면, then()의 핸들러 함수를 실행하지 않습니다.</mark>\n\nexecuter 블록에서 resolve()를 호출한 순서가 아닌 Promise 인스턴스를 생성한 순서로 파라미터 값을 배열에 첨부하여 [[PromiseValue]]에 설정합니다. then()의 첫 번째 파라미터 함수에서 파라미터 값으로 사용합니다.\n\n```js\n1. function order(mili) {  \n return new Promise((resolve) => {  \n setTimeout(() => {  \n console.log(\"실행\", mili);  \n resolve(mili);  \n }, mili);  \n });  \n};  \n  \n2. Promise.all([order(300), order(200), order(100)])  \n .then((milis) => console.log(\"호출\", milis));  \n// 실행 100  \n// 실행 200  \n// 실행 300  \n// 호출 [300, 200, 100]  \n```\n\n1.  order(mili)가 호출되면 Promise 인스턴스를 생성하면서 setTimeout()을 실행합니다.  \n    파라미터로 받은 mili 값을 지연 시간으로 사용합니다. 지연 시간이 경과한 후에 setTimeout의 콜백 함수가 실행됩니다. order()를 여러 번 호출했을 때, 호출한 순서가 아닌 mili 값에 따라 콜백 함수가 실행되므로 실행 순서가 달라질 수 있습니다. 즉, 콜백 함수에서 resolve() 호출 순서가 바뀔 수 있습니다.\n\n2.  Promise.all()의 파라미터에 order() 호출을 배열로 작성했습니다.  \n    따라서 첫 번째 엘리먼트부터 차례로 order() 함수를 호출하게 됩니다. 호출된 order() 함수에서 setTimeout()을 실행하며, 파라미터로 넘겨준 값을 지연 시간으로 사용합니다.  \n    함수 호출에는 시간이 걸리지 않아 (0.1초 안에) 세 개의 order() 300,200,100 순서로 호출됩니다.  \n    하지만 setTimeout()의 콜백 함수는 지연 시간으로 인해 100, 200, 300 순서로 실행되게 됩니다.\n\nsetTimeout()에서 지연 시간이 경과하면 콜백 함수에서 resolve(mili)를 호출하게 되며  \nthen()의 핸들러 함수가 실행됩니다. 이때, Promise.all()은 resolve(mili)를 호출할 때 마다 then()의 핸들러 함수가 실행되지 않습니다. Promise.all()의 파라미터에서 order() 호출로 생성한 Promise 인스턴스가 모두 성공적으로 처리되었을 때 한 번만 호출합니다.  \nPromise.all()에서 order()함수를 총 세 번 호출하지만, 생성된 인스턴스가 모두 성공적으로 처리돼야 then()의 핸들러 함수를 실행하는 것입니다.\n\n실행 결과 “실행 100”, “실행 200”, “실행 300”은 setTimeout의 콜백 함수가 실행한 출력 값이고,  \n호출 [300, 200, 100]은 then()의 핸들러 함수에서 출력한 값입니다.\n\n* * *\n\n<h2 id=\"Promise_race\">race(): 처음 한 번만 핸들러 호출</h2>\n\n처음 한 번만 then()의 핸들러 함수를 실행합니다.\n\n> Promise.race()\n\n*   파라미터에 이터러블 오브젝트를 작성합니다. 이터러블 오브젝트에 작성한 순서로 Promise 인스턴스를 생성합니다. 처음 한 번만 Promise 인스턴스 성공과 실패에 따라 then()의 핸들러 함수를 호출하고, 그 다음 부터는 호출하지 않습니다.\n\n```js\nfunction order(mili) {  \n return new Promise((resolve, reject) => {  \n setTimeout(() => {  \n console.log(mili);  \n resolve(mili);  \n }, mili);  \n });  \n};  \n  \n1. Promise.race([order(300), order(200), order(100)])  \n .then((milis) => console.log(\"then:\", milis),  \n (error) => console.log(error));  \n// 100  \n// then: 100  \n// 200  \n// 300  \n```\n\n1.  Promise.race()에서 order(300), order(200), order(100) 순서로 order() 함수를 호출합니다.  \n    하지만 Promise.race()는 처음 한 번만 then()의 핸들러 함수가 실행되므로  \n    order(200), order(100)의 핸들러 함수는 실행되지 않습니다.\n","source":"_posts/Promise 오브젝트 -ECMAScript.md","raw":"---\ntitle: Promise 오브젝트 -ECMAScript\ndate: 2020-04-14 09:44:27\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n\nPromise 오브젝트는 비동기(Asynchronous)처리를 위한 메커니즘을 제공합니다.  \nES5까지 없었던 개념으로 ES6에 추가되었습니다.\n\n*   Promise 오브젝트\n    *   [개요](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise)\n        *   Promise 처리 순서\n    *   [Promise 상태](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_상태)\n        *   settled 상태\n        *   fulfill (성공)\n        *   reject (실패)\n    *   [new Promise(): Promise 인스턴스 생성](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#newPromise)\n    *   [then(): 성공, 실패 핸들러](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_then)\n    *   [catch(): 실패 핸들러](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_catch)\n    *   [resolve(): 성공 상태의 인스턴스 반환](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_resolve)\n        *   thenable\n    *   [reject(): 실패 상태의 인스턴스 반환](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_reject)\n    *   [all(): 모두 성공이면 핸들러 실행](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_all)\n    *   [race(): 처음 한 번만 핸들러 호출](/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_race)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Promise\">개요</h2>\n\n자바스크립트는 기본적으로 동기(Synchronous)로 실행합니다. 동기 실행이란 현재 코드가 실행을 완료해야 다음 코드가 실행되는 것을 의미합니다. 여러 줄의 코드가 있다고 했을 때, 첫째 줄의 코드가 실행을 완료해야 둘째 줄이 실행되며, 둘째 줄이 실행을 완료해야 셋째 줄이 실행되는 형태입니다.\n\n반면, Promise는 비동기(Asynchronous)로 실행합니다. XMLHttp Request의 비동기 통신과 비슷합니다.  \n클라이언트에서 서버로 보낸 요청(Request)에 서버가 응답(Response)할 때까지 통신이 연결된 상태에서 기다리지 않습니다. 따라서 서버가 처리하는 동안 다른 처리를 할 수 있습니다. 클라이언트에서 서버가 응답했을 때의 처리를 사전에 정의해 두면, 서버가 응답했을 때 정의한 코드가 자동으로 실행됩니다.  \nPromise도 이와 개념이 비슷합니다.\n\n코드 구현 관점에서 보면 Promise는 하나의 오브젝트입니다. Promise 오브젝트에서 비동기 처리 방법을 제공하므로 이에 맞추어 코드를 작성하면 됩니다.\n\nPromise 오브젝트는 DOM(Document Object Model)에서 처음 제시되었으나 현재는 JavaScript 스펙에 포함되었습니다. 따라서 DOM에서도 사용이 가능하며 이는 DOM을 사용하는 다른 언어에서도 Promise를 사용할 수 있다는 것이 됩니다.\n\n### Promise 처리 순서\n\nPromise 개념을 이해하기 위해 Promise의 비동기 처리 흐름을 간단하게 살펴봅니다.\n\n```js Promise 처리 흐름\n1. function create(){  \n 3. return new Promise(function(resolve, reject){  \n resolve();  \n console.log(\"1: resolve\");  \n });  \n};  \n  \n2. 4. 6. create().then(function(){  \n console.log(\"3: 성공\");  \n}, function(){  \n console.log(\"3: 실패\");  \n});  \n5. console.log(\"2: 끝\");  \n// 1: resolve  \n// 2: 끝  \n// 3: 성공  \n```\n\n1.  엔진이 function 키워드를 만나면 create()를 호출할 수 있도록 Function 오브젝트로 생성합니다.  \n    함수 안에 코드는 실행하지 않고 다음 줄로 이동합니다.\n\n2.  create() 함수를 호출합니다. 함수 안에 코드가 실행됩니다.\n\n3.  1.  return 문의 표현식을 평가하므로 new Promise()로 인스턴스를 생성합니다.\n    2.  이때, Promise() 파라미터에 작성한 function(){}을 실행합니다. (function을 executer(실행자)라고 합니다.)\n    3.  function(executer) 블록의 첫째 줄에 resolve()가 작성되어 있습니다. 그런데 호출을 받아서 처리할 같은 이름의 함수가 소스 코드에 없습니다. 단지 파라미터에 resolve가 작성되어 있을 뿐입니다.\n    4.  resolve() 형태가 함수를 호출하는 형태이지만 호출하지 않습니다. 이에 대해서는 사전 설명이 필요하므로 뒤에서 다룹니다.\n    5.  다음 줄에 console.log()를 실행하여 “1: resolve”를 출력합니다.\n    6.  생성한 인스턴스를 반환합니다.  \n        <mark>여기서 중요한 점이 executer가 실행된다는 것과 resolve()가 호출되지 않는다는 점입니다. resolve()를 바로 호출하지 않고 호출할 수 있는 환경이 되었을 때 호출합니다.<mark>\n\n4.  create() 실행이 끝나면 생성한 Promise 인스턴스를 반환합니다. Promise 인스턴스에 then()이 있으므로 이어서 then()을 호출할 수 있습니다. 하지만 then()을 호출하지 않고, 아래 코드로 이동합니다.  \n    <mark>앞에서 resolve()를 호출할 수 있는 환경이 되었을 때 호출하는 것과 then()을 실행하지 않고 아래 코드로 이동하는 것이 Promise 비동기 처리의 핵심 매커니즘 입니다.</mark>\n\n5.  create() 실행 이후에 then()을 호출하지 않고 다음 줄로 이동했을 때 만나는 코드입니다.  \n    “2: 끝”이 출력됩니다. 이제 더 이상 남아있는 코드가 없습니다.\n\n6.  이제 남은 것은 then()에 작성한 function()의 실행입니다.  \n    then()은 두 개의 파라미터를 갖고 있습니다.  \n    위 코드에서는 첫 번째 파라미터의 function이 실행되어 “3: 성공”이 출력됩니다.  \n    두 번째 파라미터의 function은 실행되지 않습니다. 첫 번째 파라미터 function이 실행된 이유는 뒤에서 다룹니다.\n\n*   console.log 출력 순서를 보면\n    1.  “1: resolve”는 new Promise()로 인스턴스를 생성할 때 executer에서 출력합니다.  \n        Promise 인스턴스를 생성해야 메서드를 사용할 수 있으므로 먼저 인스턴스를 생성합니다.\n    2.  “2: 끝”은 create()에 연결된 then()을 실행하지 않으므로 두 번째로 실행됩니다.\n    3.  “3: 성공”은 소스 코드 전체를 끝까지 처리한 후 실행되어 세 번째로 출력됩니다.\n\n* * *\n\n<h2 id=\"Promise_상태\">Promise 상태</h2>\n\nPromise는 코드를 실행할 때마다 진행 상태를[[PromiseState]]에 저장합니다.  \n상태를 저장하는 이유는 연속해서 코드를 실행하지 않고, 소스 코드 끝까지 내려갔다 다시 올라와서 실행하므로 진행 상태가 필요하기 때문입니다. 상태에 따라 다음 단계를 처리하기 위해서 입니다.\n\n<img src=\"/images/promise.SVG\">\n\nPromise 진행 상태는 크게 두 가지로 나눌 수 있습니다.  \npending 과 settled로 나뉩니다.  \nsettled 상태는 다시 fulfill(성공) 과 reject(실패)로 나눌 수 있습니다.  \npending 과 settled는 상태이면서 발생 단계입니다. 먼저 pending 상태가 되었다가 settled 상태로 넘어갑니다.  \n단계로 보면 두 단계 (pending, settled)이지만 상태 측면에서 보면 세 개이므로 세 개의 상태로 분류하기도 합니다.\n\n### pending 상태\n\n```js pending\nfunction create(){  \n return new Promise(function(resolve, reject){  \n resolve();  \n console.log(\"1: resolve\");  \n });  \n};  \n```\n\npending 상태(단계)에서는 위 코드와 같이 우선 new Promise()로 인스턴스를 생성합니다. 그리고 <mark>executer를 실행하여 성공과 실패에 따라 호출할 핸들러 함수를 바인딩 합니다.</mark>\n바인딩이란 resolve()와 같이 바로 함수를 호출하지 않고 나중에 호출하므로, 그때를 위한 호출 환경을 설정하는 것을 의미합니다.\n\nexecuter 블록의 코드를 실행하지 않고 소스 코드 끝까지 처리한 후 실행하므로 이 시점에서 Promise 처리의 성공과 실패를 알 수 없습니다. 따라서 성공 또는 실패가 발생했을 때, 이에 따라 함수가 호출될 수 있도록 환경 설정이 필요합니다.\n\n### settled 상태\n\n```js settled\ncreate().then(function(){  \n console.log(\"3: 성공\");  \n}, function(){  \n console.log(\"4: 실패\");  \n});  \n```\n\npending 상태가 종료되면 settled 상태로 변환됩니다. 이때 처리의 성공과 실패를 알 수 있습니다.  \nsettled 상태는 다시 fulfill(성공) 상태와 reject(실패) 상태로 구분됩니다. 상태에 따라 pending 단계에서 바인딩한 핸들러 함수가 호출됩니다.\n\n#### fulfill (성공)\n\nexecuter 불록의 코드가 성공적으로 실핸된 상태를 나타냅니다.  \nthen()의 첫 번째 파라미터의 핸들러(function)가 실행됩니다. - 핸들러 안에 성공에 따른 코드를 작성합니다.\n\n#### reject (실패)\n\nexecuter 블록의 코드 실행이 실패한 상태를 나타냅니다.  \nthen()의 두 번째 파라미터의 핸들러가 실행됩니다. - 핸들러 안에 실패에 따른 코드를 작성합니다.\n\n* * *\n\n<h2 id=\"newPromise\">new Promise(): Promise 인스턴스 생성</h2>\n\nPromise 인스턴스를 생성하여 반환합니다.\n\n> new Promise()\n\n```js\nnew Promise(function(resolve, reject){  \n resolve( );  \n reject( );  \n });  \n```\n\n*   executer에 두 개의 파라미터를 작성할 수 있습니다. 첫 번째 파라미터에 executer 블록에서 처리를 성공했을 때 호출할 핸들러 이름(resolve)를 작성합니다. 두 번째 파라미터에 실패했을 때 호출할 핸들러 이름(reject)를 작성합니다. resolve 와 reject는 가독성을 위한 것으로 다른 이름을 사용해도 됩니다.\n    \n*   executer 블록에 핸들러 함수를 작성하지 않으면, then()의 파라미터에 작성한 함수가 실행되지 않습니다.  \n    핸들러 함수 이름과 executer의 파라미터에 작성한 이름과 같아야 하며, 같지 않으면 에러가 발생합니다.  \n    예를 들어, resolve() 와 function(resolve)와 같이 resolve 이름이 같아야 합니다.\n    \n```js\nfunction create(param){  \n 2. return new Promise(function(resolve, reject){  \n 3. if (param === \"ok\"){  \n resolve(param);  \n 4. console.log(\"1: resolve\");  \n } else {  \n reject(param);  \n }  \n });  \n};  \n1. 5. create(\"ok\").then(function(param){  \n 7. console.log(\"3: 성공,\", param);  \n}, function(param){  \n console.log(\"3: 실패,\", param);  \n});  \n6. console.log(\"2: 끝\");  \n// 1: resolve  \n// 2: 끝  \n// 3: 성공, ok  \n```\n\n1.  create()를 호출하면서 “ok”를 파라미터 값으로 넘겨 줍니다. 호출받은 create() 함수의 파라마터 param에 설정됩니다.\n\n2.  executer의 파라미터에 resolve 와 reject를 작성했습니다. Function 오브젝트를 생성하여 resolve 와 reject에 할당합니다. Promise 인스턴스를 생성하여 return 한 후, create()에 연결된 then()의 파라미터에 작성한 함수와 연결합니다.  \n    이렇게 설정함으로써 executer 블록에서 resolve()를 호출하면 then()의 첫 번째 파라미터의 함수가 호출되고, reject()를 호출하면 then()의 두 번째 파라미터의 함수가 호출됩니다.  \n    executer 파라미터의 resolve와 executer 블록의 resolve()와 then()의 첫 번째 파라미터 함수가 연결되고,  \n    executer 파라미터의 reject와 executer 블록의 reject()와 then()의 두 번째 파라미터 함수가 연결되는 것입니다.\n\n3.  param 값으로 받은 파라미터가 “ok”이므로 true가 되어 if 문 블록을 수행합니다.  \n    resolve(param)가 함수를 호출하는 형태이지만, 지금 호출하지 않고 소스 코드를 끝까지 실행한 후 되돌아와서 호출합니다. 되돌아와서 resolve()를 호출하면 이를 받아 실행할 같은 이름의 함수가 없습니다.  \n    <mark>이때 executer 파라미터의 resolve에 설정된 함수를 호출합니다. 그러면 resolve 와 then()의 첫 번째 파라미터의 함수와 연결되어 있으므로 then()의 첫 번째 함수가 연결되어 있으므로 then()의 첫 번째 함수가 실행됩니다. 이것이 Promise의 비동기 처리 메커니즘입니다.</mark>\n\n4.  resolve(param) 다음 줄에 console.log을 실행하며 “1: resolve”를 출력합니다.  \n    이제 남은 것은 생성한 인스턴스를 반환하는 것입니다.\n\n5.  create(“ok”)의 호출이 완료되면 Promise 인스턴스를 반환하므로 “인스턴스.then()” 형태가 되어 then()을 실행할 수 있지만 바로 실행하지 않습니다. 우선 then()의 첫 번째 파라미터를 executer의 resolve에 바인딩하고, then()의 두 번째 파라미터를 executer의 reject에 바인딩 합니다.  \n    이렇게 바인딩을 함으로써 executer 블록에서 resolve()를 호출했을 때 then()의 첫 번째 파라미터에 작성한 함수가 실행됩니다.\n\n6.  소스 코드의 마지막 코드로 console에 “2: 끝”을 출력합니다. 모든 코드를 읽었으므로 이제 남은 것은 resolve()를 실행하는 것입니다.\n\n7.  executer 블록에서 resolve(param)을 호출하면, then()의 첫 번째 파라미터 함수가 호출됩니다.  \n    이때, resolve(param)에서 param 값인 “ok”가 핸들러 함수인 function(param)의 param에 설정됩니다.  \n    따라서 console에 “3: 성공, ok”가 출력됩니다.\n\n```js fail\nfunction create(param){  \n return new Promise(function(resolve, reject){  \n if (param === \"ok\"){  \n resolve(param);  \n } else {  \n reject(param);  \n console.log(\"1: reject\");  \n }  \n });  \n};  \n1. create(\"fail\").then(function(param){  \n console.log(\"3: 성공,\", param);  \n}, function(param){  \n console.log(\"3: 실패,\", param);  \n});  \nconsole.log(\"2: 끝\");  \n// 1: reject  \n// 2: 끝  \n// 3: 실패, fail  \n```\n\n*   바로 앞에서 다룬 코드는 성공 기준이며 위 코드는 실패 기준입니다.  \n    Promise 처리 흐름은 같습니다. then()의 두 번째 파라미터에 작성한 함수가 실행된다는 점이 다릅니다.\n\n1.  create()를 호출하면서 “fail”을 파라미터 값으로 넘겨 줍니다.  \n    호출된 create() 함수에서 if 문의 else 블록 reject(param)과 console.log(“1: reject”)를 실행하게 됩니다.  \n    물론 reject(param)은 이때 호출되지 않고 소스 코드를 끝까지 실행한 후 되돌아와서 호출 환경이 설정되있을 때 호출됩니다.  \n    executer 블록에서 reject()가 호출되면 then()의 두 번째 파라미터에 작성한 함수가 실행됩니다.  \n    따라서 콘솔에 “3: 실패, fail”이 출력됩니다.\n\n* * *\n\n<h2 id=\"Promise_then\">then(): 성공, 실패 핸들러</h2>\n\n성공과 실패 핸들러를 정의합니다.\n\n> Promise.prototype.then(onFulfilled, onRejected)\n\n첫 번째 파라미터에 Promise가 성공 상태가 되었을 때 실행될 핸들러 함수를 작성합니다.  \n두 번째 파라미터에 Promise가 실패 상태가 되었을 때 실행될 핸들러 함수를 작성합니다.\n\n*   executer 블록의 resolve() 와 reject()에서 다수의 파라미터 값을 넘겨주더라도 핸들러 함수에서 첫 번째 파라미터 하나만 받습니다. 따라서 여러 개의 파라미터 값을 넘겨 주려면 resolve()와 reject()의 파라미터에 배열과 같은 형태로 작성해야 합니다.\n\n*   resolve(성공) 와 reject(실패) 핸들러 함수에서 return 문의 작성 여부와 관계없이 현재 실행 중인 Promise 인스턴스를 반환합니다. return 문을 작성하면 return 문의 표현식을 평가하고 그 결과를 [[PromiseValue]]에 undefined를 설정합니다.\n\n*   then() 에서 Promise 인스턴스를 반환하므로 then(one).then(two)와 같이 then()을 연속해서 작성할 수 있습니다. 이때, 첫 번째 then()에서 [[PromiseValue]]에 설정한 값이 두 번째 then(two)의 파라미터인 two에 설정됩니다. 핸들러 함수에서 Promise 인스턴스를 반환하여 연속해서 메서드를 호출할 수 있도록 하고, return 문의 반환 값을 [[PromiseValue]]에 설정하여 다음 then()의 핸들러 함수의 파라미터에 설정합니다.\n\n```js then()\n1. function create(){  \n return new Promise((resolve) => resolve(100));  \n};  \n2. create().then(() => console.log(\"1:then\"));  \n  \n  \n3. create().then((param) => {  \n console.log(\"2:then,\", param);  \n return param + 50;  \n});  \n  \n  \n4. create().then((param) => {  \n console.log(\"3:then,\", param);  \n return param + 70;  \n}).then((param) => console.log(\"4:then,\", param));  \n// 1:then  \n// 2:then, 100  \n// 3:then, 100  \n// 4:then, 170  \n```\n\n1.  create()가 호출되면 executer 블록의 resolve()를 수행하게 됩니다.  \n    하지만 호출받을 resolve 함수가 없으므로 호출 환경이 되었을 때 호출합니다.  \n    즉, 소스 코드 끝까지 처리하고 되돌아와 호출합니다.  \n    실패가 발생하지 않으면 executer의 파라미터와 블록에 reject를 작성하지 않아도 됩니다.\n\n2.  then()의 첫 번째 파라미터에 핸들러 함수를 작성하여 연결합니다. executer 블록에서 resolve 파라미터 값으로 100을 넘겨 주지만 이 코드에서는 사용되지 않습니다. “1:then”을 출력합니다.\n\n3.  두 번째로 create()를 호출하여 Promise 인스턴스를 생성합니다. executer 블록에서 resolve(100)으로 호출하면, then()의 첫 번째 파라미터의 핸들러 함수가 실행되며 100이 param에 설정됩니다.  \n    return문의 표현식을 평가한 150을 [[PromiseValue]]에 설정만하고 반환하지 않으며, 실행 중인 Promise 인스턴스를 반환합니다.\n\n4.  세 번째로 create()를 호출하여 Promise 인스턴스를 생성합니다. then()의 첫 번째 파라미터의 핸들러 함수가 호출되면 param 파라미터에 100이 설정됩니다. return 문의 표현식을 평가한 170을 [[PromiseValue]]에 설정하고 실행중인 Promise 인스턴스를 반환합니다.  \n    then()에서 Promise 인스턴스를 반환하므로 두 번째 .then() 으로 호출할 수 있습니다.  \n    [[PromiseValue]]에 설정된 170이 param 파라미터에 설정되며 “4: then, 170”이 출력됩니다.\n\n코드 실행 순서 정리 :\n\n1.  첫 번째 create() 함수를 호출합니다. Promise 인스턴스를 반환합니다.  \n    연결된 then()의 핸들러 함수를 실행하지 않고 아래로 이동합니다.\n\n2.  두 번째 create() 함수를 호출합니다. Promise 인스턴스를 반환합니다.  \n    연결된 then()의 핸들러 함수를 실행하지 않고 아래로 이동합니다.\n\n3.  세 번째 create() 함수를 호출합니다. Promise 인스턴스를 반환합니다.  \n    연결된 then()의 핸들러 함수를 실행하지 않고 아래로 이동합니다.\n\n4.  더 이상 처리할 코드가 없습니다.\n\n5.  첫 번째의 executer 블록의 resolve()가 호출되며 then()의 핸들러 함수가 실행됩니다.  \n    콘솔에 “1:then”이 출력됩니다.\n\n6.  두 번째의 executer 블록의 resolve()가 호출되며 then()의 핸들러 함수가 실행됩니다.  \n    콘솔에 “2:then, 100”이 출력됩니다.\n\n7.  세 번째의 executer 블록의 resolve()가 호출되며 then()의 핸들러 함수가 실행됩니다.  \n    콘솔에 “3:then, 100”이 출력됩니다.\n\n8.  세 번째의 then()에 연결된 then()의 핸들러 함수가 실행됩니다.  \n    콘솔에 “4:then, 170”이 출력됩니다.\n\n<mark>then().then()과 같이 then()이 연결되어 있으면, 처음 then()의 핸들러 함수를 실행한 후, 두 번째 then()의 함수 코드를 실행합니다. 이때 처음 then()의 return 값이 두 번째 then()함수의 파라미터 값으로 설정됩니다.</mark>\n\n* * *\n\n<h2 id=\"Promise_catch\">catch(): 실패 핸들러</h2>\n\n실패(reject) 핸들러를 정의합니다.\n\n> Promise.prototype.catch(onRejected)\n\n*   파라미터에 Promise가 reject 상태가 되었을 때 실행될 핸들러 함수를 작성합니다.  \n    then()의 첫 번째 파라미터에 함수를 작성하고, 두 번째 파라미터는 작성하지 않습니다.  \n    대신 then().catch() 형태로 작성하여 then()의 두 번째 파라미터에 작성할 함수를 catch()의 파라미터에 작성합니다. then()은 성공했을 때 실행되며 catch()는 실패했을 때 실행됩니다.\n    \n*   catch() 의 핸들러 함수에 파라미터를 하나만 작성할 수 있습니다.  \n    executer 블록의 reject() 에서 다수의 파라미터를 넘겨주려면 배열과 같은 형태로 작성해야 합니다.\n    \n*   catch()의 핸들러 함수에서 return 문의 작성 여부와 관계없이 현재 실행 중인 Promise 인스턴스를 반환합니다.\n    \n*   catch().then()과 같이 catch() 다음에 then()을 연결할 수 있으며, catch()에서 설정한 [[PromiseValue]] 값을 then()의 파라미터 값으로 넘겨줍니다.\n    \n```js\nfunction create(param){  \n return new Promise((resolve, reject) =>{  \n 1. param === \"ok\" ? resolve(param) : reject(param);  \n });  \n};  \n  \n2. create(\"fail\").then((param) => {  \n console.log(\"성공:\", param);  \n}).catch((param) => {  \n console.log(\"실패:\", param);  \n});  \n// 실패 : fail  \n```\n\n1.  파라미터로 받은 param 값이 “ok”이면 resolve(param)을 호출하고, 아니면 reject(param)을 호출합니다.  \n    “fail”값으로 create()를 호출합니다. 따라서 reject()를 호출하게 되며, catch()의 핸들러 함수가 실행됩니다.\n\n2.  create(“fail”)로 호출하여 Promise 인스턴스를 생성합니다.  \n    executer 블록에서 reject()가 호출되므로 catch()의 핸들러 함수가 실행됩니다.  \n    reject(param)에서 param 값이 핸들러 함수의 파라미터인 param에 설정됩니다.  \n    실패만 발생하므로 then()의 핸들러 함수는 실행되지 않고, catch() 핸들러 함수만 실행됩니다.\n\n```js\nfunction create(param){  \n return new Promise((resolve, reject) =>{  \n resolve(\"resolve\");  \n });  \n};  \n  \n1.   \ncreate().then((param) => {  \n console.log(\"1:then,\", param);  \n throw \"에러 발생 시킴\";  \n2.  \n}).catch((param) => {  \n console.log(\"2:catch,\", param);  \n3.  \n}).then((param) => {  \n console.log(\"3:then,\", param);  \n}).catch((param) => {  \n console.log(\"4:catch,\", param);  \n});  \n// 1: then, resolve  \n// 2: catch, 에러 발생 시킴  \n// 3: then, undefined  \n```\n\n1.  then()의 핸들러 함수가 실행되면 콘솔에 “1:then, resolve”가 출력됩니다.  \n    이어서 throw 문으로 에러를 발생시킵니다. 그러면 then()에 이어서 작성한 catch()핸들러 함수가 실행됩니다.\n\n2.  executer 블록에서 reject()를 호출해도 catch()의 핸들러 함수가 실행되지만,  \n    then()에서 에러가 발생해도 catch()의 핸들러 함수가 실행됩니다.  \n    이때, 앞 then()의 throw문에 작성한 “에러 발생 시킴”이 catch() 핸들러 함수의 param 파라미터에 설정됩니다. 콘솔에 “2:catch, 에러 발생 시킴”이 출력됩니다.  \n    핸들러 함수에 return 문을 작성하지 않았으므로 [[PromiseValue]]에 undefined가 설정되며 실행 중인 Promise 인스턴스가 반환됩니다. catch()에서 에러가 발생하지 않으면 then().catch().then().catch() 형태에서 catch()에 연결된 두 번째 then()이 실행됩니다. 만약 에러가 발생하여 두 번째 catch()를 실행하더라도 소스 코드 전체가 종료되지 않습니다.\n\n3.  then()이 실행되면 catch()에서 [[PromiseValue]]에 설정한 undefined가 param 파라미터에 설정됩니다.  \n    콘솔에 “3:then, undefined”가 출력됩니다. then()에 이어서 catch()가 있지만, then()에서 에러가 발생하지 않았으므로 catch()가 실행되지 않습니다. then()의 핸들러 함수를 실행한 후, 소스 코드 전체가 종료됩니다.\n\n* * *\n\n<h2 id=\"Promise_resolve\">resolve(): 성공 상태의 인스턴스 반환</h2>\n\nfulfill(성공) 상태의 Promise 인스턴스를 반환합니다.\n\n> Promise.resolve()\n\n*   파라미터  \n    value, promise, thenable\n    \n*   반환 값  \n    파라미터 값에 따라 반환 형태가 다릅니다.\n    \n\n파라미터에 값을 작성하면 성공 상태의 Promise 인스턴스를 생성하여 반환합니다.  \n이어서 then()을 작성하면 then()의 첫 번째 파라미터에 작성한 함수가 호출됩니다.  \n파라미터에 Promise 인스턴스를 지정하면 인스턴스를 성공 상태로 변환하여 반환합니다.\n\n```js\n1. let promiseObj = Promise.resolve(  \n {sports: \"스포츠\", music: \"음악\"}  \n);  \n2. promiseObj.then((param) =>{  \n for (let name in param){  \n console.log(name, param[name]);  \n }  \n});  \n  \n3. Promise.resolve(  \n [\"sports\", \"music\"]  \n).then((param) => console.log(param));  \n// sports 스포츠  \n// music 음악  \n// [\"sports\", \"music\"]  \n```\n\n1.  Promise.resolve()를 호출하면 Promise 인스턴스를 생성하고 Promise를 성공 상태로 설정하여 반환합니다.  \n    then()의 핸들러 함수에 파라미터 하나만 작성할 수 있으므로 다 수의 파라미터 값을 넘겨주기 위해 Object 오브젝트로 작성했습니다.\n    \n    *   다음은 promiseObj 인스턴스 구조입니다.\n    <img src=\"/images/resolvePromiseObj.JPG\">\n    \n    1.  __proto__에 첨부된 프로퍼티가 Promise.prototype에 연결된 프로퍼티와 같습니다.  \n        이는 new 연산자를 사용하지 않고 Promise.resolve()를 실행해도 Promise 인스턴스를 생성한다는 의미입니다.\n        \n    2.  [[PromiseState]] 값이 “resolve”로 설정되어 있습니다. 따라서 then()의 첫 번째 파라미터의 핸들러 함수가 실행됩니다.\n        \n    3.  Promise.resolve()의 파라미터 값이 [[PromiseValue]]에 설정되었으며 then()의 핸들러 함수의 파라미터에 설정됩니다.\n        \n\n2.  PromiseObj의 Promise 인스턴스가 성공 상태이므로 then()의 첫 번째 파라미터 함수가 실행됩니다.  \n    이 시점에서 실행되지 않고 소스 코드에 작성된 코드를 끝까지 처리한 후 실행됩니다.  \n    핸들러 함수의 param 파라미터에 {sports: “스포츠”, music: “음악”}이 설정됩니다.\n\n3.  Promise.resolve() 가 Promise 인스턴스를 생성하여 반환하므로 then()을 연결하여 작성할 수 있습니다.  \n    지금 then()의 핸들러 함수를 실행하지 않고, 위에 작성한 then()의 핸들러 함수를 먼저 실행한 후 실행합니다.  \n    resolve()파라미터 값인 [“sports”, “music”]이 then()의 핸들러 함수의 param 파라미터에 설정됩니다.\n\n```js\n1. let oneObj = Promise.resolve(  \n {sports: \"스포츠\"}  \n);  \n2. Promise.resolve(oneObj).then((param) =>{  \n console.log(param);  \n});  \n// Object {sports: \"스포츠\"}  \n```\n\n*   promise.resolve() 파라미터에 promise.resolve()로 생성한 인스턴스를 지정한 형태입니다.\n\n1.  Promise 인스턴스를 생성하여 반환합니다. 이때 resolve( )의 파라미터 값이 [[PromiseValue]]에 설정됩니다.\n\n2.  Promise.resolve() 파라미터에 앞에서 생성한 Promise 인스턴스를 지정했습니다.  \n    then()의 핸들러 함수가 실행되면 oneObj 인스턴스 [[PromiseValue]]에 설정된 값이 핸들러 함수의 param 파라미터에 설정됩니다. 즉, {sports: “스포츠”}가 설정됩니다.\n\n### thenable\n\n> let obj = {then(resolve,reject) {…} }와 같이 오브젝트 안에 then()을 작성한 형태를 thenable이라고 합니다.\n\n```js\n1. let oneObj = Promise.resolve({  \n then(resolve){  \n console.log(\"1: then\");  \n resolve(\"thenable\");  \n }  \n});  \n2. oneObj.then((value) => console.log(\"2:\",value));  \n// 1: then  \n// 2: thenable  \n```\n\n1.  Promise.resolve()의 파라미터에 Object 오브젝트를 작성하고, 그 안에 then()을 작성했습니다.  \n    이를 thenable이라고 합니다.이 시점에서는 Promise 인스턴스만 생성하고 then()을 실행하지 않습니다.  \n    소스 코드의 마지막 코드까지 실행한 후 then()을 실행합니다.  \n    oneObj에 생성한 인스턴스를 할당한 시점의 [[PromiseState]]값은 “pending”입니다.  \n    then()의 resolve(“thenable”)을 호출하기 전까지 “pending”상태 이며 호출하면 “resolved”로 바뀝니다.\n\n2.  oneObj 인스턴스에 then()이 포함되어 있으므로 위 코드를 연결하면 oneObj.then().then() 형태가 됩니다.  \n    이 형태는 다음과 같은 순서와 방법으로 실행됩니다.\n    1.  oneObj 인스턴스의 then(resolve)가 실행됩니다.\n    2.  콘솔에 “1:then”을 출력합니다.\n    3.  resolve(“thenable”)을 호출합니다. 이때[[PromiseValue]]에 “thenable”을 설정합니다.\n    4.  oneObj.then().then() 형태에서 두 번째 then()이 호출됩니다.\n    5.  두 번째 then()의 value 파라미터에 [[PromiseValue]] 값인 “thenable”이 설정됩니다.\n    6.  콘솔에 “2:thenable”을 출력합니다.\n\n```js\nlet thenable = {  \n then(resolve, reject){  \n resolve(\"resolve\");  \n reject(\"에러\");  \n }  \n};  \n1. let oneObj = Promise.resolve(thenable);  \n  \n2. oneObj.then(  \n (value) => console.log(value),  \n (value) => console.log(\"실행되지 않음\")  \n);  \n// resolve  \n```\n\n*   Object 오브젝트에 then(resolve,reject)를 작성하였으며, resolve() 다음 줄에 reject()를 작성하였습니다. 작성 형태만 보면 resolve()를 호출하고 reject()를 호출할 것으로 보이지만,  \n    <mark>성공 또는 실패 하나만 발생하므로 먼저 작성한 resolve()만 호출됩니다.  \n    반대로 reject(), resolve() 순서로 작성하면 reject()만 호출되고 resolve()는 호출되지 않습니다.</mark>\n\n1.  Promise.resolve() 파라미터에 thenable 오브젝트를 지정하여 Promise 인스턴스를 생성합니다. 이때 then()은 실행되지 않습니다.\n\n2.  oneObj.then()에 두 개의 파라미터를 작성했습니다.  \n    첫 번째 파라미터는 resolve()로 호출했을 때 실행되는 함수이고  \n    두 번째 파라미터는 reject()로 호출했을 때 실행되는 함수입니다.  \n    oneObj 인스턴스에 then()이 있으므로 oneObj.then()은 then().then() 형태가 됩니다.  \n    첫 번째 then()에서 resolve(“resolve”)를 호출하면 [[PromiseValue]]에 “resolve”가 설정됩니다.  \n    두 번째 then()의 첫 번째 파라미터 함수가 실행되며, value 파라미터에 “resolve”가 설정됩니다.  \n    두 번째 파라미터 함수는 reject()를 호출하였을 때 실행되므로 위 코드에서는 실행되지 않습니다.\n\n* * *\n\n<h2 id=\"Promise_reject\">reject(): 실패 상태의 인스턴스 반환</h2>\n\nreject(실패) 상태의 Promise 인스턴스를 반환합니다.\n\n> Promise.reject()\n\n*   파라미터에 실패 사유를 작성합니다.\n    \n*   reject 상태로 변환된 Promise 인스턴스를 반환합니다.\n    \n```js\n1. let promiseObj = Promise.reject(\"reject 처리\");  \n2. promiseObj.then(  \n (param) => console.log(param),  \n (param) => console.log(\"에러:\", param));  \n// 에러: reject 처리  \n```\n\n1.  Promise.reject()를 실행하면 reject 상태의 Promise 인스턴스를 생성하여 반환합니다.  \n    파라미터 값이 [[PromiseValue]]에 설정되며, then()의 두 번째 파라미터 함수의 파라미터 값으로 설정됩니다.  \n    다음은 promiseObj 인스턴스 구조입니다.\n    <img src=\"/images/rejectPromiseObj.JPG\">\n    \n    1.  Promise 인스턴스의 상태는 “reject”입니다. 따라서 then()의 두 번째 파라미터 함수가 호출됩니다.\n    2.  Promise.reject() 파라미터에 작성한 “reject 처리”가 [[PromiseValue]]에 설정됩니다.\n\n2.  promiseObj.then()에 두 개의 파라미터를 작성했습니다. 첫 번째 파라미터 함수는 resolve()로 호출했을 때 실행되고, 두 번째 파라미터 함수는 reject()로 호출했을 때 실행됩니다. 현재 reject 상태이므로 두 번째 파라미터 함수가 실행됩니다.\n\n* * *\n\n<h2 id=\"Promise_all\">all(): 모두 성공이면 핸들러 실행</h2>\n\n파라미터의 모든 Promise 인스턴스가 성공 상태이면 then()의 핸들러 함수를 실행합니다.\n\n> Promise.all()\n\n*   파라미터에 이터러블 오브젝트를 작성합니다.  \n    이터러블 오브젝트에 작성한 순서로 Promise 인스턴스를 생성합니다.\n\n<mark>생성한 모든 Promise 인스턴스가 성공 상태이면, then()의 첫 번째 파라미터 함수를 실행합니다.  \nPromise 인스턴스가 하나라도 실패한다면, then()의 핸들러 함수를 실행하지 않습니다.</mark>\n\nexecuter 블록에서 resolve()를 호출한 순서가 아닌 Promise 인스턴스를 생성한 순서로 파라미터 값을 배열에 첨부하여 [[PromiseValue]]에 설정합니다. then()의 첫 번째 파라미터 함수에서 파라미터 값으로 사용합니다.\n\n```js\n1. function order(mili) {  \n return new Promise((resolve) => {  \n setTimeout(() => {  \n console.log(\"실행\", mili);  \n resolve(mili);  \n }, mili);  \n });  \n};  \n  \n2. Promise.all([order(300), order(200), order(100)])  \n .then((milis) => console.log(\"호출\", milis));  \n// 실행 100  \n// 실행 200  \n// 실행 300  \n// 호출 [300, 200, 100]  \n```\n\n1.  order(mili)가 호출되면 Promise 인스턴스를 생성하면서 setTimeout()을 실행합니다.  \n    파라미터로 받은 mili 값을 지연 시간으로 사용합니다. 지연 시간이 경과한 후에 setTimeout의 콜백 함수가 실행됩니다. order()를 여러 번 호출했을 때, 호출한 순서가 아닌 mili 값에 따라 콜백 함수가 실행되므로 실행 순서가 달라질 수 있습니다. 즉, 콜백 함수에서 resolve() 호출 순서가 바뀔 수 있습니다.\n\n2.  Promise.all()의 파라미터에 order() 호출을 배열로 작성했습니다.  \n    따라서 첫 번째 엘리먼트부터 차례로 order() 함수를 호출하게 됩니다. 호출된 order() 함수에서 setTimeout()을 실행하며, 파라미터로 넘겨준 값을 지연 시간으로 사용합니다.  \n    함수 호출에는 시간이 걸리지 않아 (0.1초 안에) 세 개의 order() 300,200,100 순서로 호출됩니다.  \n    하지만 setTimeout()의 콜백 함수는 지연 시간으로 인해 100, 200, 300 순서로 실행되게 됩니다.\n\nsetTimeout()에서 지연 시간이 경과하면 콜백 함수에서 resolve(mili)를 호출하게 되며  \nthen()의 핸들러 함수가 실행됩니다. 이때, Promise.all()은 resolve(mili)를 호출할 때 마다 then()의 핸들러 함수가 실행되지 않습니다. Promise.all()의 파라미터에서 order() 호출로 생성한 Promise 인스턴스가 모두 성공적으로 처리되었을 때 한 번만 호출합니다.  \nPromise.all()에서 order()함수를 총 세 번 호출하지만, 생성된 인스턴스가 모두 성공적으로 처리돼야 then()의 핸들러 함수를 실행하는 것입니다.\n\n실행 결과 “실행 100”, “실행 200”, “실행 300”은 setTimeout의 콜백 함수가 실행한 출력 값이고,  \n호출 [300, 200, 100]은 then()의 핸들러 함수에서 출력한 값입니다.\n\n* * *\n\n<h2 id=\"Promise_race\">race(): 처음 한 번만 핸들러 호출</h2>\n\n처음 한 번만 then()의 핸들러 함수를 실행합니다.\n\n> Promise.race()\n\n*   파라미터에 이터러블 오브젝트를 작성합니다. 이터러블 오브젝트에 작성한 순서로 Promise 인스턴스를 생성합니다. 처음 한 번만 Promise 인스턴스 성공과 실패에 따라 then()의 핸들러 함수를 호출하고, 그 다음 부터는 호출하지 않습니다.\n\n```js\nfunction order(mili) {  \n return new Promise((resolve, reject) => {  \n setTimeout(() => {  \n console.log(mili);  \n resolve(mili);  \n }, mili);  \n });  \n};  \n  \n1. Promise.race([order(300), order(200), order(100)])  \n .then((milis) => console.log(\"then:\", milis),  \n (error) => console.log(error));  \n// 100  \n// then: 100  \n// 200  \n// 300  \n```\n\n1.  Promise.race()에서 order(300), order(200), order(100) 순서로 order() 함수를 호출합니다.  \n    하지만 Promise.race()는 처음 한 번만 then()의 핸들러 함수가 실행되므로  \n    order(200), order(100)의 핸들러 함수는 실행되지 않습니다.\n","slug":"Promise 오브젝트 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrsm0014qgvqa9y8cnaz","content":"<p>Promise 오브젝트는 비동기(Asynchronous)처리를 위한 메커니즘을 제공합니다.<br>ES5까지 없었던 개념으로 ES6에 추가되었습니다.</p>\n<ul>\n<li>Promise 오브젝트<ul>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise\">개요</a><ul>\n<li>Promise 처리 순서</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_상태\">Promise 상태</a><ul>\n<li>settled 상태</li>\n<li>fulfill (성공)</li>\n<li>reject (실패)</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#newPromise\">new Promise(): Promise 인스턴스 생성</a></li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_then\">then(): 성공, 실패 핸들러</a></li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_catch\">catch(): 실패 핸들러</a></li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_resolve\">resolve(): 성공 상태의 인스턴스 반환</a><ul>\n<li>thenable</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_reject\">reject(): 실패 상태의 인스턴스 반환</a></li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_all\">all(): 모두 성공이면 핸들러 실행</a></li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_race\">race(): 처음 한 번만 핸들러 호출</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"Promise\">개요</h2>\n\n<p>자바스크립트는 기본적으로 동기(Synchronous)로 실행합니다. 동기 실행이란 현재 코드가 실행을 완료해야 다음 코드가 실행되는 것을 의미합니다. 여러 줄의 코드가 있다고 했을 때, 첫째 줄의 코드가 실행을 완료해야 둘째 줄이 실행되며, 둘째 줄이 실행을 완료해야 셋째 줄이 실행되는 형태입니다.</p>\n<p>반면, Promise는 비동기(Asynchronous)로 실행합니다. XMLHttp Request의 비동기 통신과 비슷합니다.<br>클라이언트에서 서버로 보낸 요청(Request)에 서버가 응답(Response)할 때까지 통신이 연결된 상태에서 기다리지 않습니다. 따라서 서버가 처리하는 동안 다른 처리를 할 수 있습니다. 클라이언트에서 서버가 응답했을 때의 처리를 사전에 정의해 두면, 서버가 응답했을 때 정의한 코드가 자동으로 실행됩니다.<br>Promise도 이와 개념이 비슷합니다.</p>\n<p>코드 구현 관점에서 보면 Promise는 하나의 오브젝트입니다. Promise 오브젝트에서 비동기 처리 방법을 제공하므로 이에 맞추어 코드를 작성하면 됩니다.</p>\n<p>Promise 오브젝트는 DOM(Document Object Model)에서 처음 제시되었으나 현재는 JavaScript 스펙에 포함되었습니다. 따라서 DOM에서도 사용이 가능하며 이는 DOM을 사용하는 다른 언어에서도 Promise를 사용할 수 있다는 것이 됩니다.</p>\n<h3 id=\"Promise-처리-순서\"><a href=\"#Promise-처리-순서\" class=\"headerlink\" title=\"Promise 처리 순서\"></a>Promise 처리 순서</h3><p>Promise 개념을 이해하기 위해 Promise의 비동기 처리 흐름을 간단하게 살펴봅니다.</p>\n<figure class=\"highlight js\"><figcaption><span>Promise 처리 흐름</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;  </span><br><span class=\"line\"> resolve();  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1: resolve\"</span>);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"number\">4.</span> <span class=\"number\">6.</span> create().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: 성공\"</span>);  </span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: 실패\"</span>);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2: 끝\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 1: resolve  </span></span><br><span class=\"line\"><span class=\"comment\">// 2: 끝  </span></span><br><span class=\"line\"><span class=\"comment\">// 3: 성공</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>엔진이 function 키워드를 만나면 create()를 호출할 수 있도록 Function 오브젝트로 생성합니다.<br>함수 안에 코드는 실행하지 않고 다음 줄로 이동합니다.</p>\n</li>\n<li><p>create() 함수를 호출합니다. 함수 안에 코드가 실행됩니다.</p>\n</li>\n<li><ol>\n<li>return 문의 표현식을 평가하므로 new Promise()로 인스턴스를 생성합니다.</li>\n<li>이때, Promise() 파라미터에 작성한 function(){}을 실행합니다. (function을 executer(실행자)라고 합니다.)</li>\n<li>function(executer) 블록의 첫째 줄에 resolve()가 작성되어 있습니다. 그런데 호출을 받아서 처리할 같은 이름의 함수가 소스 코드에 없습니다. 단지 파라미터에 resolve가 작성되어 있을 뿐입니다.</li>\n<li>resolve() 형태가 함수를 호출하는 형태이지만 호출하지 않습니다. 이에 대해서는 사전 설명이 필요하므로 뒤에서 다룹니다.</li>\n<li>다음 줄에 console.log()를 실행하여 “1: resolve”를 출력합니다.</li>\n<li>생성한 인스턴스를 반환합니다.<br><mark>여기서 중요한 점이 executer가 실행된다는 것과 resolve()가 호출되지 않는다는 점입니다. resolve()를 바로 호출하지 않고 호출할 수 있는 환경이 되었을 때 호출합니다.<mark></li>\n</ol>\n</li>\n<li><p>create() 실행이 끝나면 생성한 Promise 인스턴스를 반환합니다. Promise 인스턴스에 then()이 있으므로 이어서 then()을 호출할 수 있습니다. 하지만 then()을 호출하지 않고, 아래 코드로 이동합니다.<br><mark>앞에서 resolve()를 호출할 수 있는 환경이 되었을 때 호출하는 것과 then()을 실행하지 않고 아래 코드로 이동하는 것이 Promise 비동기 처리의 핵심 매커니즘 입니다.</mark></p>\n</li>\n<li><p>create() 실행 이후에 then()을 호출하지 않고 다음 줄로 이동했을 때 만나는 코드입니다.<br>“2: 끝”이 출력됩니다. 이제 더 이상 남아있는 코드가 없습니다.</p>\n</li>\n<li><p>이제 남은 것은 then()에 작성한 function()의 실행입니다.<br>then()은 두 개의 파라미터를 갖고 있습니다.<br>위 코드에서는 첫 번째 파라미터의 function이 실행되어 “3: 성공”이 출력됩니다.<br>두 번째 파라미터의 function은 실행되지 않습니다. 첫 번째 파라미터 function이 실행된 이유는 뒤에서 다룹니다.</p>\n</li>\n</ol>\n<ul>\n<li>console.log 출력 순서를 보면<ol>\n<li>“1: resolve”는 new Promise()로 인스턴스를 생성할 때 executer에서 출력합니다.<br>Promise 인스턴스를 생성해야 메서드를 사용할 수 있으므로 먼저 인스턴스를 생성합니다.</li>\n<li>“2: 끝”은 create()에 연결된 then()을 실행하지 않으므로 두 번째로 실행됩니다.</li>\n<li>“3: 성공”은 소스 코드 전체를 끝까지 처리한 후 실행되어 세 번째로 출력됩니다.</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"Promise_상태\">Promise 상태</h2>\n\n<p>Promise는 코드를 실행할 때마다 진행 상태를[[PromiseState]]에 저장합니다.<br>상태를 저장하는 이유는 연속해서 코드를 실행하지 않고, 소스 코드 끝까지 내려갔다 다시 올라와서 실행하므로 진행 상태가 필요하기 때문입니다. 상태에 따라 다음 단계를 처리하기 위해서 입니다.</p>\n<img src=\"/images/promise.SVG\">\n\n<p>Promise 진행 상태는 크게 두 가지로 나눌 수 있습니다.<br>pending 과 settled로 나뉩니다.<br>settled 상태는 다시 fulfill(성공) 과 reject(실패)로 나눌 수 있습니다.<br>pending 과 settled는 상태이면서 발생 단계입니다. 먼저 pending 상태가 되었다가 settled 상태로 넘어갑니다.<br>단계로 보면 두 단계 (pending, settled)이지만 상태 측면에서 보면 세 개이므로 세 개의 상태로 분류하기도 합니다.</p>\n<h3 id=\"pending-상태\"><a href=\"#pending-상태\" class=\"headerlink\" title=\"pending 상태\"></a>pending 상태</h3><figure class=\"highlight js\"><figcaption><span>pending</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;  </span><br><span class=\"line\"> resolve();  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1: resolve\"</span>);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>pending 상태(단계)에서는 위 코드와 같이 우선 new Promise()로 인스턴스를 생성합니다. 그리고 <mark>executer를 실행하여 성공과 실패에 따라 호출할 핸들러 함수를 바인딩 합니다.</mark><br>바인딩이란 resolve()와 같이 바로 함수를 호출하지 않고 나중에 호출하므로, 그때를 위한 호출 환경을 설정하는 것을 의미합니다.</p>\n<p>executer 블록의 코드를 실행하지 않고 소스 코드 끝까지 처리한 후 실행하므로 이 시점에서 Promise 처리의 성공과 실패를 알 수 없습니다. 따라서 성공 또는 실패가 발생했을 때, 이에 따라 함수가 호출될 수 있도록 환경 설정이 필요합니다.</p>\n<h3 id=\"settled-상태\"><a href=\"#settled-상태\" class=\"headerlink\" title=\"settled 상태\"></a>settled 상태</h3><figure class=\"highlight js\"><figcaption><span>settled</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: 성공\"</span>);  </span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4: 실패\"</span>);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>pending 상태가 종료되면 settled 상태로 변환됩니다. 이때 처리의 성공과 실패를 알 수 있습니다.<br>settled 상태는 다시 fulfill(성공) 상태와 reject(실패) 상태로 구분됩니다. 상태에 따라 pending 단계에서 바인딩한 핸들러 함수가 호출됩니다.</p>\n<h4 id=\"fulfill-성공\"><a href=\"#fulfill-성공\" class=\"headerlink\" title=\"fulfill (성공)\"></a>fulfill (성공)</h4><p>executer 불록의 코드가 성공적으로 실핸된 상태를 나타냅니다.<br>then()의 첫 번째 파라미터의 핸들러(function)가 실행됩니다. - 핸들러 안에 성공에 따른 코드를 작성합니다.</p>\n<h4 id=\"reject-실패\"><a href=\"#reject-실패\" class=\"headerlink\" title=\"reject (실패)\"></a>reject (실패)</h4><p>executer 블록의 코드 실행이 실패한 상태를 나타냅니다.<br>then()의 두 번째 파라미터의 핸들러가 실행됩니다. - 핸들러 안에 실패에 따른 코드를 작성합니다.</p>\n<hr>\n<h2 id=\"newPromise\">new Promise(): Promise 인스턴스 생성</h2>\n\n<p>Promise 인스턴스를 생성하여 반환합니다.</p>\n<blockquote>\n<p>new Promise()</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;  </span><br><span class=\"line\"> resolve( );  </span><br><span class=\"line\"> reject( );  </span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>executer에 두 개의 파라미터를 작성할 수 있습니다. 첫 번째 파라미터에 executer 블록에서 처리를 성공했을 때 호출할 핸들러 이름(resolve)를 작성합니다. 두 번째 파라미터에 실패했을 때 호출할 핸들러 이름(reject)를 작성합니다. resolve 와 reject는 가독성을 위한 것으로 다른 이름을 사용해도 됩니다.</p>\n</li>\n<li><p>executer 블록에 핸들러 함수를 작성하지 않으면, then()의 파라미터에 작성한 함수가 실행되지 않습니다.<br>핸들러 함수 이름과 executer의 파라미터에 작성한 이름과 같아야 하며, 같지 않으면 에러가 발생합니다.<br>예를 들어, resolve() 와 function(resolve)와 같이 resolve 이름이 같아야 합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"keyword\">if</span> (param === <span class=\"string\">\"ok\"</span>)&#123;  </span><br><span class=\"line\"> resolve(param);  </span><br><span class=\"line\"> <span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1: resolve\"</span>);  </span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\"> reject(param);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"number\">5.</span> create(<span class=\"string\">\"ok\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">7.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: 성공,\"</span>, param);  </span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: 실패,\"</span>, param);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"number\">6.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2: 끝\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 1: resolve  </span></span><br><span class=\"line\"><span class=\"comment\">// 2: 끝  </span></span><br><span class=\"line\"><span class=\"comment\">// 3: 성공, ok</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>create()를 호출하면서 “ok”를 파라미터 값으로 넘겨 줍니다. 호출받은 create() 함수의 파라마터 param에 설정됩니다.</p>\n</li>\n<li><p>executer의 파라미터에 resolve 와 reject를 작성했습니다. Function 오브젝트를 생성하여 resolve 와 reject에 할당합니다. Promise 인스턴스를 생성하여 return 한 후, create()에 연결된 then()의 파라미터에 작성한 함수와 연결합니다.<br>이렇게 설정함으로써 executer 블록에서 resolve()를 호출하면 then()의 첫 번째 파라미터의 함수가 호출되고, reject()를 호출하면 then()의 두 번째 파라미터의 함수가 호출됩니다.<br>executer 파라미터의 resolve와 executer 블록의 resolve()와 then()의 첫 번째 파라미터 함수가 연결되고,<br>executer 파라미터의 reject와 executer 블록의 reject()와 then()의 두 번째 파라미터 함수가 연결되는 것입니다.</p>\n</li>\n<li><p>param 값으로 받은 파라미터가 “ok”이므로 true가 되어 if 문 블록을 수행합니다.<br>resolve(param)가 함수를 호출하는 형태이지만, 지금 호출하지 않고 소스 코드를 끝까지 실행한 후 되돌아와서 호출합니다. 되돌아와서 resolve()를 호출하면 이를 받아 실행할 같은 이름의 함수가 없습니다.<br><mark>이때 executer 파라미터의 resolve에 설정된 함수를 호출합니다. 그러면 resolve 와 then()의 첫 번째 파라미터의 함수와 연결되어 있으므로 then()의 첫 번째 함수가 연결되어 있으므로 then()의 첫 번째 함수가 실행됩니다. 이것이 Promise의 비동기 처리 메커니즘입니다.</mark></p>\n</li>\n<li><p>resolve(param) 다음 줄에 console.log을 실행하며 “1: resolve”를 출력합니다.<br>이제 남은 것은 생성한 인스턴스를 반환하는 것입니다.</p>\n</li>\n<li><p>create(“ok”)의 호출이 완료되면 Promise 인스턴스를 반환하므로 “인스턴스.then()” 형태가 되어 then()을 실행할 수 있지만 바로 실행하지 않습니다. 우선 then()의 첫 번째 파라미터를 executer의 resolve에 바인딩하고, then()의 두 번째 파라미터를 executer의 reject에 바인딩 합니다.<br>이렇게 바인딩을 함으로써 executer 블록에서 resolve()를 호출했을 때 then()의 첫 번째 파라미터에 작성한 함수가 실행됩니다.</p>\n</li>\n<li><p>소스 코드의 마지막 코드로 console에 “2: 끝”을 출력합니다. 모든 코드를 읽었으므로 이제 남은 것은 resolve()를 실행하는 것입니다.</p>\n</li>\n<li><p>executer 블록에서 resolve(param)을 호출하면, then()의 첫 번째 파라미터 함수가 호출됩니다.<br>이때, resolve(param)에서 param 값인 “ok”가 핸들러 함수인 function(param)의 param에 설정됩니다.<br>따라서 console에 “3: 성공, ok”가 출력됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>fail</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (param === <span class=\"string\">\"ok\"</span>)&#123;  </span><br><span class=\"line\"> resolve(param);  </span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\"> reject(param);  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1: reject\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> create(<span class=\"string\">\"fail\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: 성공,\"</span>, param);  </span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: 실패,\"</span>, param);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2: 끝\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 1: reject  </span></span><br><span class=\"line\"><span class=\"comment\">// 2: 끝  </span></span><br><span class=\"line\"><span class=\"comment\">// 3: 실패, fail</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>바로 앞에서 다룬 코드는 성공 기준이며 위 코드는 실패 기준입니다.<br>Promise 처리 흐름은 같습니다. then()의 두 번째 파라미터에 작성한 함수가 실행된다는 점이 다릅니다.</li>\n</ul>\n<ol>\n<li>create()를 호출하면서 “fail”을 파라미터 값으로 넘겨 줍니다.<br>호출된 create() 함수에서 if 문의 else 블록 reject(param)과 console.log(“1: reject”)를 실행하게 됩니다.<br>물론 reject(param)은 이때 호출되지 않고 소스 코드를 끝까지 실행한 후 되돌아와서 호출 환경이 설정되있을 때 호출됩니다.<br>executer 블록에서 reject()가 호출되면 then()의 두 번째 파라미터에 작성한 함수가 실행됩니다.<br>따라서 콘솔에 “3: 실패, fail”이 출력됩니다.</li>\n</ol>\n<hr>\n<h2 id=\"Promise_then\">then(): 성공, 실패 핸들러</h2>\n\n<p>성공과 실패 핸들러를 정의합니다.</p>\n<blockquote>\n<p>Promise.prototype.then(onFulfilled, onRejected)</p>\n</blockquote>\n<p>첫 번째 파라미터에 Promise가 성공 상태가 되었을 때 실행될 핸들러 함수를 작성합니다.<br>두 번째 파라미터에 Promise가 실패 상태가 되었을 때 실행될 핸들러 함수를 작성합니다.</p>\n<ul>\n<li><p>executer 블록의 resolve() 와 reject()에서 다수의 파라미터 값을 넘겨주더라도 핸들러 함수에서 첫 번째 파라미터 하나만 받습니다. 따라서 여러 개의 파라미터 값을 넘겨 주려면 resolve()와 reject()의 파라미터에 배열과 같은 형태로 작성해야 합니다.</p>\n</li>\n<li><p>resolve(성공) 와 reject(실패) 핸들러 함수에서 return 문의 작성 여부와 관계없이 현재 실행 중인 Promise 인스턴스를 반환합니다. return 문을 작성하면 return 문의 표현식을 평가하고 그 결과를 [[PromiseValue]]에 undefined를 설정합니다.</p>\n</li>\n<li><p>then() 에서 Promise 인스턴스를 반환하므로 then(one).then(two)와 같이 then()을 연속해서 작성할 수 있습니다. 이때, 첫 번째 then()에서 [[PromiseValue]]에 설정한 값이 두 번째 then(two)의 파라미터인 two에 설정됩니다. 핸들러 함수에서 Promise 인스턴스를 반환하여 연속해서 메서드를 호출할 수 있도록 하고, return 문의 반환 값을 [[PromiseValue]]에 설정하여 다음 then()의 핸들러 함수의 파라미터에 설정합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>then()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> resolve(<span class=\"number\">100</span>));  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> create().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:then\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> create().then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:then,\"</span>, param);  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> param + <span class=\"number\">50</span>;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> create().then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:then,\"</span>, param);  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> param + <span class=\"number\">70</span>;  </span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:then,\"</span>, param));  </span><br><span class=\"line\"><span class=\"comment\">// 1:then  </span></span><br><span class=\"line\"><span class=\"comment\">// 2:then, 100  </span></span><br><span class=\"line\"><span class=\"comment\">// 3:then, 100  </span></span><br><span class=\"line\"><span class=\"comment\">// 4:then, 170</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>create()가 호출되면 executer 블록의 resolve()를 수행하게 됩니다.<br>하지만 호출받을 resolve 함수가 없으므로 호출 환경이 되었을 때 호출합니다.<br>즉, 소스 코드 끝까지 처리하고 되돌아와 호출합니다.<br>실패가 발생하지 않으면 executer의 파라미터와 블록에 reject를 작성하지 않아도 됩니다.</p>\n</li>\n<li><p>then()의 첫 번째 파라미터에 핸들러 함수를 작성하여 연결합니다. executer 블록에서 resolve 파라미터 값으로 100을 넘겨 주지만 이 코드에서는 사용되지 않습니다. “1:then”을 출력합니다.</p>\n</li>\n<li><p>두 번째로 create()를 호출하여 Promise 인스턴스를 생성합니다. executer 블록에서 resolve(100)으로 호출하면, then()의 첫 번째 파라미터의 핸들러 함수가 실행되며 100이 param에 설정됩니다.<br>return문의 표현식을 평가한 150을 [[PromiseValue]]에 설정만하고 반환하지 않으며, 실행 중인 Promise 인스턴스를 반환합니다.</p>\n</li>\n<li><p>세 번째로 create()를 호출하여 Promise 인스턴스를 생성합니다. then()의 첫 번째 파라미터의 핸들러 함수가 호출되면 param 파라미터에 100이 설정됩니다. return 문의 표현식을 평가한 170을 [[PromiseValue]]에 설정하고 실행중인 Promise 인스턴스를 반환합니다.<br>then()에서 Promise 인스턴스를 반환하므로 두 번째 .then() 으로 호출할 수 있습니다.<br>[[PromiseValue]]에 설정된 170이 param 파라미터에 설정되며 “4: then, 170”이 출력됩니다.</p>\n</li>\n</ol>\n<p>코드 실행 순서 정리 :</p>\n<ol>\n<li><p>첫 번째 create() 함수를 호출합니다. Promise 인스턴스를 반환합니다.<br>연결된 then()의 핸들러 함수를 실행하지 않고 아래로 이동합니다.</p>\n</li>\n<li><p>두 번째 create() 함수를 호출합니다. Promise 인스턴스를 반환합니다.<br>연결된 then()의 핸들러 함수를 실행하지 않고 아래로 이동합니다.</p>\n</li>\n<li><p>세 번째 create() 함수를 호출합니다. Promise 인스턴스를 반환합니다.<br>연결된 then()의 핸들러 함수를 실행하지 않고 아래로 이동합니다.</p>\n</li>\n<li><p>더 이상 처리할 코드가 없습니다.</p>\n</li>\n<li><p>첫 번째의 executer 블록의 resolve()가 호출되며 then()의 핸들러 함수가 실행됩니다.<br>콘솔에 “1:then”이 출력됩니다.</p>\n</li>\n<li><p>두 번째의 executer 블록의 resolve()가 호출되며 then()의 핸들러 함수가 실행됩니다.<br>콘솔에 “2:then, 100”이 출력됩니다.</p>\n</li>\n<li><p>세 번째의 executer 블록의 resolve()가 호출되며 then()의 핸들러 함수가 실행됩니다.<br>콘솔에 “3:then, 100”이 출력됩니다.</p>\n</li>\n<li><p>세 번째의 then()에 연결된 then()의 핸들러 함수가 실행됩니다.<br>콘솔에 “4:then, 170”이 출력됩니다.</p>\n</li>\n</ol>\n<p><mark>then().then()과 같이 then()이 연결되어 있으면, 처음 then()의 핸들러 함수를 실행한 후, 두 번째 then()의 함수 코드를 실행합니다. 이때 처음 then()의 return 값이 두 번째 then()함수의 파라미터 값으로 설정됩니다.</mark></p>\n<hr>\n<h2 id=\"Promise_catch\">catch(): 실패 핸들러</h2>\n\n<p>실패(reject) 핸들러를 정의합니다.</p>\n<blockquote>\n<p>Promise.prototype.catch(onRejected)</p>\n</blockquote>\n<ul>\n<li><p>파라미터에 Promise가 reject 상태가 되었을 때 실행될 핸들러 함수를 작성합니다.<br>then()의 첫 번째 파라미터에 함수를 작성하고, 두 번째 파라미터는 작성하지 않습니다.<br>대신 then().catch() 형태로 작성하여 then()의 두 번째 파라미터에 작성할 함수를 catch()의 파라미터에 작성합니다. then()은 성공했을 때 실행되며 catch()는 실패했을 때 실행됩니다.</p>\n</li>\n<li><p>catch() 의 핸들러 함수에 파라미터를 하나만 작성할 수 있습니다.<br>executer 블록의 reject() 에서 다수의 파라미터를 넘겨주려면 배열과 같은 형태로 작성해야 합니다.</p>\n</li>\n<li><p>catch()의 핸들러 함수에서 return 문의 작성 여부와 관계없이 현재 실행 중인 Promise 인스턴스를 반환합니다.</p>\n</li>\n<li><p>catch().then()과 같이 catch() 다음에 then()을 연결할 수 있으며, catch()에서 설정한 [[PromiseValue]] 값을 then()의 파라미터 값으로 넘겨줍니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> param === <span class=\"string\">\"ok\"</span> ? resolve(param) : reject(param);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> create(<span class=\"string\">\"fail\"</span>).then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"성공:\"</span>, param);  </span><br><span class=\"line\">&#125;).catch(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"실패:\"</span>, param);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"comment\">// 실패 : fail</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>파라미터로 받은 param 값이 “ok”이면 resolve(param)을 호출하고, 아니면 reject(param)을 호출합니다.<br>“fail”값으로 create()를 호출합니다. 따라서 reject()를 호출하게 되며, catch()의 핸들러 함수가 실행됩니다.</p>\n</li>\n<li><p>create(“fail”)로 호출하여 Promise 인스턴스를 생성합니다.<br>executer 블록에서 reject()가 호출되므로 catch()의 핸들러 함수가 실행됩니다.<br>reject(param)에서 param 값이 핸들러 함수의 파라미터인 param에 설정됩니다.<br>실패만 발생하므로 then()의 핸들러 함수는 실행되지 않고, catch() 핸들러 함수만 실행됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span>&#123;  </span><br><span class=\"line\"> resolve(<span class=\"string\">\"resolve\"</span>);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span>   </span><br><span class=\"line\">create().then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:then,\"</span>, param);  </span><br><span class=\"line\"> <span class=\"keyword\">throw</span> <span class=\"string\">\"에러 발생 시킴\"</span>;  </span><br><span class=\"line\"><span class=\"number\">2.</span>  </span><br><span class=\"line\">&#125;).catch(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:catch,\"</span>, param);  </span><br><span class=\"line\"><span class=\"number\">3.</span>  </span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:then,\"</span>, param);  </span><br><span class=\"line\">&#125;).catch(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:catch,\"</span>, param);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"comment\">// 1: then, resolve  </span></span><br><span class=\"line\"><span class=\"comment\">// 2: catch, 에러 발생 시킴  </span></span><br><span class=\"line\"><span class=\"comment\">// 3: then, undefined</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>then()의 핸들러 함수가 실행되면 콘솔에 “1:then, resolve”가 출력됩니다.<br>이어서 throw 문으로 에러를 발생시킵니다. 그러면 then()에 이어서 작성한 catch()핸들러 함수가 실행됩니다.</p>\n</li>\n<li><p>executer 블록에서 reject()를 호출해도 catch()의 핸들러 함수가 실행되지만,<br>then()에서 에러가 발생해도 catch()의 핸들러 함수가 실행됩니다.<br>이때, 앞 then()의 throw문에 작성한 “에러 발생 시킴”이 catch() 핸들러 함수의 param 파라미터에 설정됩니다. 콘솔에 “2:catch, 에러 발생 시킴”이 출력됩니다.<br>핸들러 함수에 return 문을 작성하지 않았으므로 [[PromiseValue]]에 undefined가 설정되며 실행 중인 Promise 인스턴스가 반환됩니다. catch()에서 에러가 발생하지 않으면 then().catch().then().catch() 형태에서 catch()에 연결된 두 번째 then()이 실행됩니다. 만약 에러가 발생하여 두 번째 catch()를 실행하더라도 소스 코드 전체가 종료되지 않습니다.</p>\n</li>\n<li><p>then()이 실행되면 catch()에서 [[PromiseValue]]에 설정한 undefined가 param 파라미터에 설정됩니다.<br>콘솔에 “3:then, undefined”가 출력됩니다. then()에 이어서 catch()가 있지만, then()에서 에러가 발생하지 않았으므로 catch()가 실행되지 않습니다. then()의 핸들러 함수를 실행한 후, 소스 코드 전체가 종료됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Promise_resolve\">resolve(): 성공 상태의 인스턴스 반환</h2>\n\n<p>fulfill(성공) 상태의 Promise 인스턴스를 반환합니다.</p>\n<blockquote>\n<p>Promise.resolve()</p>\n</blockquote>\n<ul>\n<li><p>파라미터<br>value, promise, thenable</p>\n</li>\n<li><p>반환 값<br>파라미터 값에 따라 반환 형태가 다릅니다.</p>\n</li>\n</ul>\n<p>파라미터에 값을 작성하면 성공 상태의 Promise 인스턴스를 생성하여 반환합니다.<br>이어서 then()을 작성하면 then()의 첫 번째 파라미터에 작성한 함수가 호출됩니다.<br>파라미터에 Promise 인스턴스를 지정하면 인스턴스를 성공 상태로 변환하여 반환합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> promiseObj = <span class=\"built_in\">Promise</span>.resolve(  </span><br><span class=\"line\"> &#123;<span class=\"attr\">sports</span>: <span class=\"string\">\"스포츠\"</span>, <span class=\"attr\">music</span>: <span class=\"string\">\"음악\"</span>&#125;  </span><br><span class=\"line\">);  </span><br><span class=\"line\"><span class=\"number\">2.</span> promiseObj.then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> param)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(name, param[name]);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">Promise</span>.resolve(  </span><br><span class=\"line\"> [<span class=\"string\">\"sports\"</span>, <span class=\"string\">\"music\"</span>]  </span><br><span class=\"line\">).then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(param));  </span><br><span class=\"line\"><span class=\"comment\">// sports 스포츠  </span></span><br><span class=\"line\"><span class=\"comment\">// music 음악  </span></span><br><span class=\"line\"><span class=\"comment\">// [\"sports\", \"music\"]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Promise.resolve()를 호출하면 Promise 인스턴스를 생성하고 Promise를 성공 상태로 설정하여 반환합니다.<br>then()의 핸들러 함수에 파라미터 하나만 작성할 수 있으므로 다 수의 파라미터 값을 넘겨주기 위해 Object 오브젝트로 작성했습니다.</p>\n<ul>\n<li>다음은 promiseObj 인스턴스 구조입니다.<img src=\"/images/resolvePromiseObj.JPG\">\n</li>\n</ul>\n<ol>\n<li><p><strong>proto</strong>에 첨부된 프로퍼티가 Promise.prototype에 연결된 프로퍼티와 같습니다.<br>이는 new 연산자를 사용하지 않고 Promise.resolve()를 실행해도 Promise 인스턴스를 생성한다는 의미입니다.</p>\n</li>\n<li><p>[[PromiseState]] 값이 “resolve”로 설정되어 있습니다. 따라서 then()의 첫 번째 파라미터의 핸들러 함수가 실행됩니다.</p>\n</li>\n<li><p>Promise.resolve()의 파라미터 값이 [[PromiseValue]]에 설정되었으며 then()의 핸들러 함수의 파라미터에 설정됩니다.</p>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>PromiseObj의 Promise 인스턴스가 성공 상태이므로 then()의 첫 번째 파라미터 함수가 실행됩니다.<br>이 시점에서 실행되지 않고 소스 코드에 작성된 코드를 끝까지 처리한 후 실행됩니다.<br>핸들러 함수의 param 파라미터에 {sports: “스포츠”, music: “음악”}이 설정됩니다.</p>\n</li>\n<li><p>Promise.resolve() 가 Promise 인스턴스를 생성하여 반환하므로 then()을 연결하여 작성할 수 있습니다.<br>지금 then()의 핸들러 함수를 실행하지 않고, 위에 작성한 then()의 핸들러 함수를 먼저 실행한 후 실행합니다.<br>resolve()파라미터 값인 [“sports”, “music”]이 then()의 핸들러 함수의 param 파라미터에 설정됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> oneObj = <span class=\"built_in\">Promise</span>.resolve(  </span><br><span class=\"line\"> &#123;<span class=\"attr\">sports</span>: <span class=\"string\">\"스포츠\"</span>&#125;  </span><br><span class=\"line\">);  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">Promise</span>.resolve(oneObj).then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(param);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;sports: \"스포츠\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>promise.resolve() 파라미터에 promise.resolve()로 생성한 인스턴스를 지정한 형태입니다.</li>\n</ul>\n<ol>\n<li><p>Promise 인스턴스를 생성하여 반환합니다. 이때 resolve( )의 파라미터 값이 [[PromiseValue]]에 설정됩니다.</p>\n</li>\n<li><p>Promise.resolve() 파라미터에 앞에서 생성한 Promise 인스턴스를 지정했습니다.<br>then()의 핸들러 함수가 실행되면 oneObj 인스턴스 [[PromiseValue]]에 설정된 값이 핸들러 함수의 param 파라미터에 설정됩니다. 즉, {sports: “스포츠”}가 설정됩니다.</p>\n</li>\n</ol>\n<h3 id=\"thenable\"><a href=\"#thenable\" class=\"headerlink\" title=\"thenable\"></a>thenable</h3><blockquote>\n<p>let obj = {then(resolve,reject) {…} }와 같이 오브젝트 안에 then()을 작성한 형태를 thenable이라고 합니다.</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> oneObj = <span class=\"built_in\">Promise</span>.resolve(&#123;  </span><br><span class=\"line\"> then(resolve)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1: then\"</span>);  </span><br><span class=\"line\"> resolve(<span class=\"string\">\"thenable\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"number\">2.</span> oneObj.then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>,value));  </span><br><span class=\"line\"><span class=\"comment\">// 1: then  </span></span><br><span class=\"line\"><span class=\"comment\">// 2: thenable</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Promise.resolve()의 파라미터에 Object 오브젝트를 작성하고, 그 안에 then()을 작성했습니다.<br>이를 thenable이라고 합니다.이 시점에서는 Promise 인스턴스만 생성하고 then()을 실행하지 않습니다.<br>소스 코드의 마지막 코드까지 실행한 후 then()을 실행합니다.<br>oneObj에 생성한 인스턴스를 할당한 시점의 [[PromiseState]]값은 “pending”입니다.<br>then()의 resolve(“thenable”)을 호출하기 전까지 “pending”상태 이며 호출하면 “resolved”로 바뀝니다.</p>\n</li>\n<li><p>oneObj 인스턴스에 then()이 포함되어 있으므로 위 코드를 연결하면 oneObj.then().then() 형태가 됩니다.<br>이 형태는 다음과 같은 순서와 방법으로 실행됩니다.</p>\n<ol>\n<li>oneObj 인스턴스의 then(resolve)가 실행됩니다.</li>\n<li>콘솔에 “1:then”을 출력합니다.</li>\n<li>resolve(“thenable”)을 호출합니다. 이때[[PromiseValue]]에 “thenable”을 설정합니다.</li>\n<li>oneObj.then().then() 형태에서 두 번째 then()이 호출됩니다.</li>\n<li>두 번째 then()의 value 파라미터에 [[PromiseValue]] 값인 “thenable”이 설정됩니다.</li>\n<li>콘솔에 “2:thenable”을 출력합니다.</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> thenable = &#123;  </span><br><span class=\"line\"> then(resolve, reject)&#123;  </span><br><span class=\"line\"> resolve(<span class=\"string\">\"resolve\"</span>);  </span><br><span class=\"line\"> reject(<span class=\"string\">\"에러\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> oneObj = <span class=\"built_in\">Promise</span>.resolve(thenable);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> oneObj.then(  </span><br><span class=\"line\"> (value) =&gt; <span class=\"built_in\">console</span>.log(value),  </span><br><span class=\"line\"> (value) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"실행되지 않음\"</span>)  </span><br><span class=\"line\">);  </span><br><span class=\"line\"><span class=\"comment\">// resolve</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Object 오브젝트에 then(resolve,reject)를 작성하였으며, resolve() 다음 줄에 reject()를 작성하였습니다. 작성 형태만 보면 resolve()를 호출하고 reject()를 호출할 것으로 보이지만,<br><mark>성공 또는 실패 하나만 발생하므로 먼저 작성한 resolve()만 호출됩니다.<br>반대로 reject(), resolve() 순서로 작성하면 reject()만 호출되고 resolve()는 호출되지 않습니다.</mark></li>\n</ul>\n<ol>\n<li><p>Promise.resolve() 파라미터에 thenable 오브젝트를 지정하여 Promise 인스턴스를 생성합니다. 이때 then()은 실행되지 않습니다.</p>\n</li>\n<li><p>oneObj.then()에 두 개의 파라미터를 작성했습니다.<br>첫 번째 파라미터는 resolve()로 호출했을 때 실행되는 함수이고<br>두 번째 파라미터는 reject()로 호출했을 때 실행되는 함수입니다.<br>oneObj 인스턴스에 then()이 있으므로 oneObj.then()은 then().then() 형태가 됩니다.<br>첫 번째 then()에서 resolve(“resolve”)를 호출하면 [[PromiseValue]]에 “resolve”가 설정됩니다.<br>두 번째 then()의 첫 번째 파라미터 함수가 실행되며, value 파라미터에 “resolve”가 설정됩니다.<br>두 번째 파라미터 함수는 reject()를 호출하였을 때 실행되므로 위 코드에서는 실행되지 않습니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Promise_reject\">reject(): 실패 상태의 인스턴스 반환</h2>\n\n<p>reject(실패) 상태의 Promise 인스턴스를 반환합니다.</p>\n<blockquote>\n<p>Promise.reject()</p>\n</blockquote>\n<ul>\n<li><p>파라미터에 실패 사유를 작성합니다.</p>\n</li>\n<li><p>reject 상태로 변환된 Promise 인스턴스를 반환합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> promiseObj = <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">\"reject 처리\"</span>);  </span><br><span class=\"line\"><span class=\"number\">2.</span> promiseObj.then(  </span><br><span class=\"line\"> (param) =&gt; <span class=\"built_in\">console</span>.log(param),  </span><br><span class=\"line\"> (param) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"에러:\"</span>, param));  </span><br><span class=\"line\"><span class=\"comment\">// 에러: reject 처리</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Promise.reject()를 실행하면 reject 상태의 Promise 인스턴스를 생성하여 반환합니다.<br>파라미터 값이 [[PromiseValue]]에 설정되며, then()의 두 번째 파라미터 함수의 파라미터 값으로 설정됩니다.<br>다음은 promiseObj 인스턴스 구조입니다.</p>\n<img src=\"/images/rejectPromiseObj.JPG\">\n\n<ol>\n<li>Promise 인스턴스의 상태는 “reject”입니다. 따라서 then()의 두 번째 파라미터 함수가 호출됩니다.</li>\n<li>Promise.reject() 파라미터에 작성한 “reject 처리”가 [[PromiseValue]]에 설정됩니다.</li>\n</ol>\n</li>\n<li><p>promiseObj.then()에 두 개의 파라미터를 작성했습니다. 첫 번째 파라미터 함수는 resolve()로 호출했을 때 실행되고, 두 번째 파라미터 함수는 reject()로 호출했을 때 실행됩니다. 현재 reject 상태이므로 두 번째 파라미터 함수가 실행됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Promise_all\">all(): 모두 성공이면 핸들러 실행</h2>\n\n<p>파라미터의 모든 Promise 인스턴스가 성공 상태이면 then()의 핸들러 함수를 실행합니다.</p>\n<blockquote>\n<p>Promise.all()</p>\n</blockquote>\n<ul>\n<li>파라미터에 이터러블 오브젝트를 작성합니다.<br>이터러블 오브젝트에 작성한 순서로 Promise 인스턴스를 생성합니다.</li>\n</ul>\n<p><mark>생성한 모든 Promise 인스턴스가 성공 상태이면, then()의 첫 번째 파라미터 함수를 실행합니다.<br>Promise 인스턴스가 하나라도 실패한다면, then()의 핸들러 함수를 실행하지 않습니다.</mark></p>\n<p>executer 블록에서 resolve()를 호출한 순서가 아닌 Promise 인스턴스를 생성한 순서로 파라미터 값을 배열에 첨부하여 [[PromiseValue]]에 설정합니다. then()의 첫 번째 파라미터 함수에서 파라미터 값으로 사용합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">order</span>(<span class=\"params\">mili</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"실행\"</span>, mili);  </span><br><span class=\"line\"> resolve(mili);  </span><br><span class=\"line\"> &#125;, mili);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">Promise</span>.all([order(<span class=\"number\">300</span>), order(<span class=\"number\">200</span>), order(<span class=\"number\">100</span>)])  </span><br><span class=\"line\"> .then(<span class=\"function\">(<span class=\"params\">milis</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"호출\"</span>, milis));  </span><br><span class=\"line\"><span class=\"comment\">// 실행 100  </span></span><br><span class=\"line\"><span class=\"comment\">// 실행 200  </span></span><br><span class=\"line\"><span class=\"comment\">// 실행 300  </span></span><br><span class=\"line\"><span class=\"comment\">// 호출 [300, 200, 100]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>order(mili)가 호출되면 Promise 인스턴스를 생성하면서 setTimeout()을 실행합니다.<br>파라미터로 받은 mili 값을 지연 시간으로 사용합니다. 지연 시간이 경과한 후에 setTimeout의 콜백 함수가 실행됩니다. order()를 여러 번 호출했을 때, 호출한 순서가 아닌 mili 값에 따라 콜백 함수가 실행되므로 실행 순서가 달라질 수 있습니다. 즉, 콜백 함수에서 resolve() 호출 순서가 바뀔 수 있습니다.</p>\n</li>\n<li><p>Promise.all()의 파라미터에 order() 호출을 배열로 작성했습니다.<br>따라서 첫 번째 엘리먼트부터 차례로 order() 함수를 호출하게 됩니다. 호출된 order() 함수에서 setTimeout()을 실행하며, 파라미터로 넘겨준 값을 지연 시간으로 사용합니다.<br>함수 호출에는 시간이 걸리지 않아 (0.1초 안에) 세 개의 order() 300,200,100 순서로 호출됩니다.<br>하지만 setTimeout()의 콜백 함수는 지연 시간으로 인해 100, 200, 300 순서로 실행되게 됩니다.</p>\n</li>\n</ol>\n<p>setTimeout()에서 지연 시간이 경과하면 콜백 함수에서 resolve(mili)를 호출하게 되며<br>then()의 핸들러 함수가 실행됩니다. 이때, Promise.all()은 resolve(mili)를 호출할 때 마다 then()의 핸들러 함수가 실행되지 않습니다. Promise.all()의 파라미터에서 order() 호출로 생성한 Promise 인스턴스가 모두 성공적으로 처리되었을 때 한 번만 호출합니다.<br>Promise.all()에서 order()함수를 총 세 번 호출하지만, 생성된 인스턴스가 모두 성공적으로 처리돼야 then()의 핸들러 함수를 실행하는 것입니다.</p>\n<p>실행 결과 “실행 100”, “실행 200”, “실행 300”은 setTimeout의 콜백 함수가 실행한 출력 값이고,<br>호출 [300, 200, 100]은 then()의 핸들러 함수에서 출력한 값입니다.</p>\n<hr>\n<h2 id=\"Promise_race\">race(): 처음 한 번만 핸들러 호출</h2>\n\n<p>처음 한 번만 then()의 핸들러 함수를 실행합니다.</p>\n<blockquote>\n<p>Promise.race()</p>\n</blockquote>\n<ul>\n<li>파라미터에 이터러블 오브젝트를 작성합니다. 이터러블 오브젝트에 작성한 순서로 Promise 인스턴스를 생성합니다. 처음 한 번만 Promise 인스턴스 성공과 실패에 따라 then()의 핸들러 함수를 호출하고, 그 다음 부터는 호출하지 않습니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">order</span>(<span class=\"params\">mili</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(mili);  </span><br><span class=\"line\"> resolve(mili);  </span><br><span class=\"line\"> &#125;, mili);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">Promise</span>.race([order(<span class=\"number\">300</span>), order(<span class=\"number\">200</span>), order(<span class=\"number\">100</span>)])  </span><br><span class=\"line\"> .then(<span class=\"function\">(<span class=\"params\">milis</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"then:\"</span>, milis),  </span><br><span class=\"line\"> (error) =&gt; <span class=\"built_in\">console</span>.log(error));  </span><br><span class=\"line\"><span class=\"comment\">// 100  </span></span><br><span class=\"line\"><span class=\"comment\">// then: 100  </span></span><br><span class=\"line\"><span class=\"comment\">// 200  </span></span><br><span class=\"line\"><span class=\"comment\">// 300</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Promise.race()에서 order(300), order(200), order(100) 순서로 order() 함수를 호출합니다.<br>하지만 Promise.race()는 처음 한 번만 then()의 핸들러 함수가 실행되므로<br>order(200), order(100)의 핸들러 함수는 실행되지 않습니다.</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Promise 오브젝트는 비동기(Asynchronous)처리를 위한 메커니즘을 제공합니다.<br>ES5까지 없었던 개념으로 ES6에 추가되었습니다.</p>\n<ul>\n<li>Promise 오브젝트<ul>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise\">개요</a><ul>\n<li>Promise 처리 순서</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_상태\">Promise 상태</a><ul>\n<li>settled 상태</li>\n<li>fulfill (성공)</li>\n<li>reject (실패)</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#newPromise\">new Promise(): Promise 인스턴스 생성</a></li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_then\">then(): 성공, 실패 핸들러</a></li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_catch\">catch(): 실패 핸들러</a></li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_resolve\">resolve(): 성공 상태의 인스턴스 반환</a><ul>\n<li>thenable</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_reject\">reject(): 실패 상태의 인스턴스 반환</a></li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_all\">all(): 모두 성공이면 핸들러 실행</a></li>\n<li><a href=\"/2020/04/14/Promise%20오브젝트%20-ECMAScript/#Promise_race\">race(): 처음 한 번만 핸들러 호출</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"Promise\">개요</h2>\n\n<p>자바스크립트는 기본적으로 동기(Synchronous)로 실행합니다. 동기 실행이란 현재 코드가 실행을 완료해야 다음 코드가 실행되는 것을 의미합니다. 여러 줄의 코드가 있다고 했을 때, 첫째 줄의 코드가 실행을 완료해야 둘째 줄이 실행되며, 둘째 줄이 실행을 완료해야 셋째 줄이 실행되는 형태입니다.</p>\n<p>반면, Promise는 비동기(Asynchronous)로 실행합니다. XMLHttp Request의 비동기 통신과 비슷합니다.<br>클라이언트에서 서버로 보낸 요청(Request)에 서버가 응답(Response)할 때까지 통신이 연결된 상태에서 기다리지 않습니다. 따라서 서버가 처리하는 동안 다른 처리를 할 수 있습니다. 클라이언트에서 서버가 응답했을 때의 처리를 사전에 정의해 두면, 서버가 응답했을 때 정의한 코드가 자동으로 실행됩니다.<br>Promise도 이와 개념이 비슷합니다.</p>\n<p>코드 구현 관점에서 보면 Promise는 하나의 오브젝트입니다. Promise 오브젝트에서 비동기 처리 방법을 제공하므로 이에 맞추어 코드를 작성하면 됩니다.</p>\n<p>Promise 오브젝트는 DOM(Document Object Model)에서 처음 제시되었으나 현재는 JavaScript 스펙에 포함되었습니다. 따라서 DOM에서도 사용이 가능하며 이는 DOM을 사용하는 다른 언어에서도 Promise를 사용할 수 있다는 것이 됩니다.</p>\n<h3 id=\"Promise-처리-순서\"><a href=\"#Promise-처리-순서\" class=\"headerlink\" title=\"Promise 처리 순서\"></a>Promise 처리 순서</h3><p>Promise 개념을 이해하기 위해 Promise의 비동기 처리 흐름을 간단하게 살펴봅니다.</p>\n<figure class=\"highlight js\"><figcaption><span>Promise 처리 흐름</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;  </span><br><span class=\"line\"> resolve();  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1: resolve\"</span>);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"number\">4.</span> <span class=\"number\">6.</span> create().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: 성공\"</span>);  </span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: 실패\"</span>);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2: 끝\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 1: resolve  </span></span><br><span class=\"line\"><span class=\"comment\">// 2: 끝  </span></span><br><span class=\"line\"><span class=\"comment\">// 3: 성공</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>엔진이 function 키워드를 만나면 create()를 호출할 수 있도록 Function 오브젝트로 생성합니다.<br>함수 안에 코드는 실행하지 않고 다음 줄로 이동합니다.</p>\n</li>\n<li><p>create() 함수를 호출합니다. 함수 안에 코드가 실행됩니다.</p>\n</li>\n<li><ol>\n<li>return 문의 표현식을 평가하므로 new Promise()로 인스턴스를 생성합니다.</li>\n<li>이때, Promise() 파라미터에 작성한 function(){}을 실행합니다. (function을 executer(실행자)라고 합니다.)</li>\n<li>function(executer) 블록의 첫째 줄에 resolve()가 작성되어 있습니다. 그런데 호출을 받아서 처리할 같은 이름의 함수가 소스 코드에 없습니다. 단지 파라미터에 resolve가 작성되어 있을 뿐입니다.</li>\n<li>resolve() 형태가 함수를 호출하는 형태이지만 호출하지 않습니다. 이에 대해서는 사전 설명이 필요하므로 뒤에서 다룹니다.</li>\n<li>다음 줄에 console.log()를 실행하여 “1: resolve”를 출력합니다.</li>\n<li>생성한 인스턴스를 반환합니다.<br><mark>여기서 중요한 점이 executer가 실행된다는 것과 resolve()가 호출되지 않는다는 점입니다. resolve()를 바로 호출하지 않고 호출할 수 있는 환경이 되었을 때 호출합니다.<mark></li>\n</ol>\n</li>\n<li><p>create() 실행이 끝나면 생성한 Promise 인스턴스를 반환합니다. Promise 인스턴스에 then()이 있으므로 이어서 then()을 호출할 수 있습니다. 하지만 then()을 호출하지 않고, 아래 코드로 이동합니다.<br><mark>앞에서 resolve()를 호출할 수 있는 환경이 되었을 때 호출하는 것과 then()을 실행하지 않고 아래 코드로 이동하는 것이 Promise 비동기 처리의 핵심 매커니즘 입니다.</mark></p>\n</li>\n<li><p>create() 실행 이후에 then()을 호출하지 않고 다음 줄로 이동했을 때 만나는 코드입니다.<br>“2: 끝”이 출력됩니다. 이제 더 이상 남아있는 코드가 없습니다.</p>\n</li>\n<li><p>이제 남은 것은 then()에 작성한 function()의 실행입니다.<br>then()은 두 개의 파라미터를 갖고 있습니다.<br>위 코드에서는 첫 번째 파라미터의 function이 실행되어 “3: 성공”이 출력됩니다.<br>두 번째 파라미터의 function은 실행되지 않습니다. 첫 번째 파라미터 function이 실행된 이유는 뒤에서 다룹니다.</p>\n</li>\n</ol>\n<ul>\n<li>console.log 출력 순서를 보면<ol>\n<li>“1: resolve”는 new Promise()로 인스턴스를 생성할 때 executer에서 출력합니다.<br>Promise 인스턴스를 생성해야 메서드를 사용할 수 있으므로 먼저 인스턴스를 생성합니다.</li>\n<li>“2: 끝”은 create()에 연결된 then()을 실행하지 않으므로 두 번째로 실행됩니다.</li>\n<li>“3: 성공”은 소스 코드 전체를 끝까지 처리한 후 실행되어 세 번째로 출력됩니다.</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"Promise_상태\">Promise 상태</h2>\n\n<p>Promise는 코드를 실행할 때마다 진행 상태를[[PromiseState]]에 저장합니다.<br>상태를 저장하는 이유는 연속해서 코드를 실행하지 않고, 소스 코드 끝까지 내려갔다 다시 올라와서 실행하므로 진행 상태가 필요하기 때문입니다. 상태에 따라 다음 단계를 처리하기 위해서 입니다.</p>\n<img src=\"/images/promise.SVG\">\n\n<p>Promise 진행 상태는 크게 두 가지로 나눌 수 있습니다.<br>pending 과 settled로 나뉩니다.<br>settled 상태는 다시 fulfill(성공) 과 reject(실패)로 나눌 수 있습니다.<br>pending 과 settled는 상태이면서 발생 단계입니다. 먼저 pending 상태가 되었다가 settled 상태로 넘어갑니다.<br>단계로 보면 두 단계 (pending, settled)이지만 상태 측면에서 보면 세 개이므로 세 개의 상태로 분류하기도 합니다.</p>\n<h3 id=\"pending-상태\"><a href=\"#pending-상태\" class=\"headerlink\" title=\"pending 상태\"></a>pending 상태</h3><figure class=\"highlight js\"><figcaption><span>pending</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;  </span><br><span class=\"line\"> resolve();  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1: resolve\"</span>);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>pending 상태(단계)에서는 위 코드와 같이 우선 new Promise()로 인스턴스를 생성합니다. 그리고 <mark>executer를 실행하여 성공과 실패에 따라 호출할 핸들러 함수를 바인딩 합니다.</mark><br>바인딩이란 resolve()와 같이 바로 함수를 호출하지 않고 나중에 호출하므로, 그때를 위한 호출 환경을 설정하는 것을 의미합니다.</p>\n<p>executer 블록의 코드를 실행하지 않고 소스 코드 끝까지 처리한 후 실행하므로 이 시점에서 Promise 처리의 성공과 실패를 알 수 없습니다. 따라서 성공 또는 실패가 발생했을 때, 이에 따라 함수가 호출될 수 있도록 환경 설정이 필요합니다.</p>\n<h3 id=\"settled-상태\"><a href=\"#settled-상태\" class=\"headerlink\" title=\"settled 상태\"></a>settled 상태</h3><figure class=\"highlight js\"><figcaption><span>settled</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: 성공\"</span>);  </span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4: 실패\"</span>);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>pending 상태가 종료되면 settled 상태로 변환됩니다. 이때 처리의 성공과 실패를 알 수 있습니다.<br>settled 상태는 다시 fulfill(성공) 상태와 reject(실패) 상태로 구분됩니다. 상태에 따라 pending 단계에서 바인딩한 핸들러 함수가 호출됩니다.</p>\n<h4 id=\"fulfill-성공\"><a href=\"#fulfill-성공\" class=\"headerlink\" title=\"fulfill (성공)\"></a>fulfill (성공)</h4><p>executer 불록의 코드가 성공적으로 실핸된 상태를 나타냅니다.<br>then()의 첫 번째 파라미터의 핸들러(function)가 실행됩니다. - 핸들러 안에 성공에 따른 코드를 작성합니다.</p>\n<h4 id=\"reject-실패\"><a href=\"#reject-실패\" class=\"headerlink\" title=\"reject (실패)\"></a>reject (실패)</h4><p>executer 블록의 코드 실행이 실패한 상태를 나타냅니다.<br>then()의 두 번째 파라미터의 핸들러가 실행됩니다. - 핸들러 안에 실패에 따른 코드를 작성합니다.</p>\n<hr>\n<h2 id=\"newPromise\">new Promise(): Promise 인스턴스 생성</h2>\n\n<p>Promise 인스턴스를 생성하여 반환합니다.</p>\n<blockquote>\n<p>new Promise()</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;  </span><br><span class=\"line\"> resolve( );  </span><br><span class=\"line\"> reject( );  </span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>executer에 두 개의 파라미터를 작성할 수 있습니다. 첫 번째 파라미터에 executer 블록에서 처리를 성공했을 때 호출할 핸들러 이름(resolve)를 작성합니다. 두 번째 파라미터에 실패했을 때 호출할 핸들러 이름(reject)를 작성합니다. resolve 와 reject는 가독성을 위한 것으로 다른 이름을 사용해도 됩니다.</p>\n</li>\n<li><p>executer 블록에 핸들러 함수를 작성하지 않으면, then()의 파라미터에 작성한 함수가 실행되지 않습니다.<br>핸들러 함수 이름과 executer의 파라미터에 작성한 이름과 같아야 하며, 같지 않으면 에러가 발생합니다.<br>예를 들어, resolve() 와 function(resolve)와 같이 resolve 이름이 같아야 합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"keyword\">if</span> (param === <span class=\"string\">\"ok\"</span>)&#123;  </span><br><span class=\"line\"> resolve(param);  </span><br><span class=\"line\"> <span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1: resolve\"</span>);  </span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\"> reject(param);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"number\">5.</span> create(<span class=\"string\">\"ok\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">7.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: 성공,\"</span>, param);  </span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: 실패,\"</span>, param);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"number\">6.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2: 끝\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 1: resolve  </span></span><br><span class=\"line\"><span class=\"comment\">// 2: 끝  </span></span><br><span class=\"line\"><span class=\"comment\">// 3: 성공, ok</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>create()를 호출하면서 “ok”를 파라미터 값으로 넘겨 줍니다. 호출받은 create() 함수의 파라마터 param에 설정됩니다.</p>\n</li>\n<li><p>executer의 파라미터에 resolve 와 reject를 작성했습니다. Function 오브젝트를 생성하여 resolve 와 reject에 할당합니다. Promise 인스턴스를 생성하여 return 한 후, create()에 연결된 then()의 파라미터에 작성한 함수와 연결합니다.<br>이렇게 설정함으로써 executer 블록에서 resolve()를 호출하면 then()의 첫 번째 파라미터의 함수가 호출되고, reject()를 호출하면 then()의 두 번째 파라미터의 함수가 호출됩니다.<br>executer 파라미터의 resolve와 executer 블록의 resolve()와 then()의 첫 번째 파라미터 함수가 연결되고,<br>executer 파라미터의 reject와 executer 블록의 reject()와 then()의 두 번째 파라미터 함수가 연결되는 것입니다.</p>\n</li>\n<li><p>param 값으로 받은 파라미터가 “ok”이므로 true가 되어 if 문 블록을 수행합니다.<br>resolve(param)가 함수를 호출하는 형태이지만, 지금 호출하지 않고 소스 코드를 끝까지 실행한 후 되돌아와서 호출합니다. 되돌아와서 resolve()를 호출하면 이를 받아 실행할 같은 이름의 함수가 없습니다.<br><mark>이때 executer 파라미터의 resolve에 설정된 함수를 호출합니다. 그러면 resolve 와 then()의 첫 번째 파라미터의 함수와 연결되어 있으므로 then()의 첫 번째 함수가 연결되어 있으므로 then()의 첫 번째 함수가 실행됩니다. 이것이 Promise의 비동기 처리 메커니즘입니다.</mark></p>\n</li>\n<li><p>resolve(param) 다음 줄에 console.log을 실행하며 “1: resolve”를 출력합니다.<br>이제 남은 것은 생성한 인스턴스를 반환하는 것입니다.</p>\n</li>\n<li><p>create(“ok”)의 호출이 완료되면 Promise 인스턴스를 반환하므로 “인스턴스.then()” 형태가 되어 then()을 실행할 수 있지만 바로 실행하지 않습니다. 우선 then()의 첫 번째 파라미터를 executer의 resolve에 바인딩하고, then()의 두 번째 파라미터를 executer의 reject에 바인딩 합니다.<br>이렇게 바인딩을 함으로써 executer 블록에서 resolve()를 호출했을 때 then()의 첫 번째 파라미터에 작성한 함수가 실행됩니다.</p>\n</li>\n<li><p>소스 코드의 마지막 코드로 console에 “2: 끝”을 출력합니다. 모든 코드를 읽었으므로 이제 남은 것은 resolve()를 실행하는 것입니다.</p>\n</li>\n<li><p>executer 블록에서 resolve(param)을 호출하면, then()의 첫 번째 파라미터 함수가 호출됩니다.<br>이때, resolve(param)에서 param 값인 “ok”가 핸들러 함수인 function(param)의 param에 설정됩니다.<br>따라서 console에 “3: 성공, ok”가 출력됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>fail</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (param === <span class=\"string\">\"ok\"</span>)&#123;  </span><br><span class=\"line\"> resolve(param);  </span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\"> reject(param);  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1: reject\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> create(<span class=\"string\">\"fail\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: 성공,\"</span>, param);  </span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: 실패,\"</span>, param);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2: 끝\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 1: reject  </span></span><br><span class=\"line\"><span class=\"comment\">// 2: 끝  </span></span><br><span class=\"line\"><span class=\"comment\">// 3: 실패, fail</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>바로 앞에서 다룬 코드는 성공 기준이며 위 코드는 실패 기준입니다.<br>Promise 처리 흐름은 같습니다. then()의 두 번째 파라미터에 작성한 함수가 실행된다는 점이 다릅니다.</li>\n</ul>\n<ol>\n<li>create()를 호출하면서 “fail”을 파라미터 값으로 넘겨 줍니다.<br>호출된 create() 함수에서 if 문의 else 블록 reject(param)과 console.log(“1: reject”)를 실행하게 됩니다.<br>물론 reject(param)은 이때 호출되지 않고 소스 코드를 끝까지 실행한 후 되돌아와서 호출 환경이 설정되있을 때 호출됩니다.<br>executer 블록에서 reject()가 호출되면 then()의 두 번째 파라미터에 작성한 함수가 실행됩니다.<br>따라서 콘솔에 “3: 실패, fail”이 출력됩니다.</li>\n</ol>\n<hr>\n<h2 id=\"Promise_then\">then(): 성공, 실패 핸들러</h2>\n\n<p>성공과 실패 핸들러를 정의합니다.</p>\n<blockquote>\n<p>Promise.prototype.then(onFulfilled, onRejected)</p>\n</blockquote>\n<p>첫 번째 파라미터에 Promise가 성공 상태가 되었을 때 실행될 핸들러 함수를 작성합니다.<br>두 번째 파라미터에 Promise가 실패 상태가 되었을 때 실행될 핸들러 함수를 작성합니다.</p>\n<ul>\n<li><p>executer 블록의 resolve() 와 reject()에서 다수의 파라미터 값을 넘겨주더라도 핸들러 함수에서 첫 번째 파라미터 하나만 받습니다. 따라서 여러 개의 파라미터 값을 넘겨 주려면 resolve()와 reject()의 파라미터에 배열과 같은 형태로 작성해야 합니다.</p>\n</li>\n<li><p>resolve(성공) 와 reject(실패) 핸들러 함수에서 return 문의 작성 여부와 관계없이 현재 실행 중인 Promise 인스턴스를 반환합니다. return 문을 작성하면 return 문의 표현식을 평가하고 그 결과를 [[PromiseValue]]에 undefined를 설정합니다.</p>\n</li>\n<li><p>then() 에서 Promise 인스턴스를 반환하므로 then(one).then(two)와 같이 then()을 연속해서 작성할 수 있습니다. 이때, 첫 번째 then()에서 [[PromiseValue]]에 설정한 값이 두 번째 then(two)의 파라미터인 two에 설정됩니다. 핸들러 함수에서 Promise 인스턴스를 반환하여 연속해서 메서드를 호출할 수 있도록 하고, return 문의 반환 값을 [[PromiseValue]]에 설정하여 다음 then()의 핸들러 함수의 파라미터에 설정합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>then()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> resolve(<span class=\"number\">100</span>));  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> create().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:then\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> create().then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:then,\"</span>, param);  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> param + <span class=\"number\">50</span>;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> create().then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:then,\"</span>, param);  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> param + <span class=\"number\">70</span>;  </span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:then,\"</span>, param));  </span><br><span class=\"line\"><span class=\"comment\">// 1:then  </span></span><br><span class=\"line\"><span class=\"comment\">// 2:then, 100  </span></span><br><span class=\"line\"><span class=\"comment\">// 3:then, 100  </span></span><br><span class=\"line\"><span class=\"comment\">// 4:then, 170</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>create()가 호출되면 executer 블록의 resolve()를 수행하게 됩니다.<br>하지만 호출받을 resolve 함수가 없으므로 호출 환경이 되었을 때 호출합니다.<br>즉, 소스 코드 끝까지 처리하고 되돌아와 호출합니다.<br>실패가 발생하지 않으면 executer의 파라미터와 블록에 reject를 작성하지 않아도 됩니다.</p>\n</li>\n<li><p>then()의 첫 번째 파라미터에 핸들러 함수를 작성하여 연결합니다. executer 블록에서 resolve 파라미터 값으로 100을 넘겨 주지만 이 코드에서는 사용되지 않습니다. “1:then”을 출력합니다.</p>\n</li>\n<li><p>두 번째로 create()를 호출하여 Promise 인스턴스를 생성합니다. executer 블록에서 resolve(100)으로 호출하면, then()의 첫 번째 파라미터의 핸들러 함수가 실행되며 100이 param에 설정됩니다.<br>return문의 표현식을 평가한 150을 [[PromiseValue]]에 설정만하고 반환하지 않으며, 실행 중인 Promise 인스턴스를 반환합니다.</p>\n</li>\n<li><p>세 번째로 create()를 호출하여 Promise 인스턴스를 생성합니다. then()의 첫 번째 파라미터의 핸들러 함수가 호출되면 param 파라미터에 100이 설정됩니다. return 문의 표현식을 평가한 170을 [[PromiseValue]]에 설정하고 실행중인 Promise 인스턴스를 반환합니다.<br>then()에서 Promise 인스턴스를 반환하므로 두 번째 .then() 으로 호출할 수 있습니다.<br>[[PromiseValue]]에 설정된 170이 param 파라미터에 설정되며 “4: then, 170”이 출력됩니다.</p>\n</li>\n</ol>\n<p>코드 실행 순서 정리 :</p>\n<ol>\n<li><p>첫 번째 create() 함수를 호출합니다. Promise 인스턴스를 반환합니다.<br>연결된 then()의 핸들러 함수를 실행하지 않고 아래로 이동합니다.</p>\n</li>\n<li><p>두 번째 create() 함수를 호출합니다. Promise 인스턴스를 반환합니다.<br>연결된 then()의 핸들러 함수를 실행하지 않고 아래로 이동합니다.</p>\n</li>\n<li><p>세 번째 create() 함수를 호출합니다. Promise 인스턴스를 반환합니다.<br>연결된 then()의 핸들러 함수를 실행하지 않고 아래로 이동합니다.</p>\n</li>\n<li><p>더 이상 처리할 코드가 없습니다.</p>\n</li>\n<li><p>첫 번째의 executer 블록의 resolve()가 호출되며 then()의 핸들러 함수가 실행됩니다.<br>콘솔에 “1:then”이 출력됩니다.</p>\n</li>\n<li><p>두 번째의 executer 블록의 resolve()가 호출되며 then()의 핸들러 함수가 실행됩니다.<br>콘솔에 “2:then, 100”이 출력됩니다.</p>\n</li>\n<li><p>세 번째의 executer 블록의 resolve()가 호출되며 then()의 핸들러 함수가 실행됩니다.<br>콘솔에 “3:then, 100”이 출력됩니다.</p>\n</li>\n<li><p>세 번째의 then()에 연결된 then()의 핸들러 함수가 실행됩니다.<br>콘솔에 “4:then, 170”이 출력됩니다.</p>\n</li>\n</ol>\n<p><mark>then().then()과 같이 then()이 연결되어 있으면, 처음 then()의 핸들러 함수를 실행한 후, 두 번째 then()의 함수 코드를 실행합니다. 이때 처음 then()의 return 값이 두 번째 then()함수의 파라미터 값으로 설정됩니다.</mark></p>\n<hr>\n<h2 id=\"Promise_catch\">catch(): 실패 핸들러</h2>\n\n<p>실패(reject) 핸들러를 정의합니다.</p>\n<blockquote>\n<p>Promise.prototype.catch(onRejected)</p>\n</blockquote>\n<ul>\n<li><p>파라미터에 Promise가 reject 상태가 되었을 때 실행될 핸들러 함수를 작성합니다.<br>then()의 첫 번째 파라미터에 함수를 작성하고, 두 번째 파라미터는 작성하지 않습니다.<br>대신 then().catch() 형태로 작성하여 then()의 두 번째 파라미터에 작성할 함수를 catch()의 파라미터에 작성합니다. then()은 성공했을 때 실행되며 catch()는 실패했을 때 실행됩니다.</p>\n</li>\n<li><p>catch() 의 핸들러 함수에 파라미터를 하나만 작성할 수 있습니다.<br>executer 블록의 reject() 에서 다수의 파라미터를 넘겨주려면 배열과 같은 형태로 작성해야 합니다.</p>\n</li>\n<li><p>catch()의 핸들러 함수에서 return 문의 작성 여부와 관계없이 현재 실행 중인 Promise 인스턴스를 반환합니다.</p>\n</li>\n<li><p>catch().then()과 같이 catch() 다음에 then()을 연결할 수 있으며, catch()에서 설정한 [[PromiseValue]] 값을 then()의 파라미터 값으로 넘겨줍니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> param === <span class=\"string\">\"ok\"</span> ? resolve(param) : reject(param);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> create(<span class=\"string\">\"fail\"</span>).then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"성공:\"</span>, param);  </span><br><span class=\"line\">&#125;).catch(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"실패:\"</span>, param);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"comment\">// 실패 : fail</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>파라미터로 받은 param 값이 “ok”이면 resolve(param)을 호출하고, 아니면 reject(param)을 호출합니다.<br>“fail”값으로 create()를 호출합니다. 따라서 reject()를 호출하게 되며, catch()의 핸들러 함수가 실행됩니다.</p>\n</li>\n<li><p>create(“fail”)로 호출하여 Promise 인스턴스를 생성합니다.<br>executer 블록에서 reject()가 호출되므로 catch()의 핸들러 함수가 실행됩니다.<br>reject(param)에서 param 값이 핸들러 함수의 파라미터인 param에 설정됩니다.<br>실패만 발생하므로 then()의 핸들러 함수는 실행되지 않고, catch() 핸들러 함수만 실행됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span>&#123;  </span><br><span class=\"line\"> resolve(<span class=\"string\">\"resolve\"</span>);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span>   </span><br><span class=\"line\">create().then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:then,\"</span>, param);  </span><br><span class=\"line\"> <span class=\"keyword\">throw</span> <span class=\"string\">\"에러 발생 시킴\"</span>;  </span><br><span class=\"line\"><span class=\"number\">2.</span>  </span><br><span class=\"line\">&#125;).catch(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:catch,\"</span>, param);  </span><br><span class=\"line\"><span class=\"number\">3.</span>  </span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:then,\"</span>, param);  </span><br><span class=\"line\">&#125;).catch(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:catch,\"</span>, param);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"comment\">// 1: then, resolve  </span></span><br><span class=\"line\"><span class=\"comment\">// 2: catch, 에러 발생 시킴  </span></span><br><span class=\"line\"><span class=\"comment\">// 3: then, undefined</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>then()의 핸들러 함수가 실행되면 콘솔에 “1:then, resolve”가 출력됩니다.<br>이어서 throw 문으로 에러를 발생시킵니다. 그러면 then()에 이어서 작성한 catch()핸들러 함수가 실행됩니다.</p>\n</li>\n<li><p>executer 블록에서 reject()를 호출해도 catch()의 핸들러 함수가 실행되지만,<br>then()에서 에러가 발생해도 catch()의 핸들러 함수가 실행됩니다.<br>이때, 앞 then()의 throw문에 작성한 “에러 발생 시킴”이 catch() 핸들러 함수의 param 파라미터에 설정됩니다. 콘솔에 “2:catch, 에러 발생 시킴”이 출력됩니다.<br>핸들러 함수에 return 문을 작성하지 않았으므로 [[PromiseValue]]에 undefined가 설정되며 실행 중인 Promise 인스턴스가 반환됩니다. catch()에서 에러가 발생하지 않으면 then().catch().then().catch() 형태에서 catch()에 연결된 두 번째 then()이 실행됩니다. 만약 에러가 발생하여 두 번째 catch()를 실행하더라도 소스 코드 전체가 종료되지 않습니다.</p>\n</li>\n<li><p>then()이 실행되면 catch()에서 [[PromiseValue]]에 설정한 undefined가 param 파라미터에 설정됩니다.<br>콘솔에 “3:then, undefined”가 출력됩니다. then()에 이어서 catch()가 있지만, then()에서 에러가 발생하지 않았으므로 catch()가 실행되지 않습니다. then()의 핸들러 함수를 실행한 후, 소스 코드 전체가 종료됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Promise_resolve\">resolve(): 성공 상태의 인스턴스 반환</h2>\n\n<p>fulfill(성공) 상태의 Promise 인스턴스를 반환합니다.</p>\n<blockquote>\n<p>Promise.resolve()</p>\n</blockquote>\n<ul>\n<li><p>파라미터<br>value, promise, thenable</p>\n</li>\n<li><p>반환 값<br>파라미터 값에 따라 반환 형태가 다릅니다.</p>\n</li>\n</ul>\n<p>파라미터에 값을 작성하면 성공 상태의 Promise 인스턴스를 생성하여 반환합니다.<br>이어서 then()을 작성하면 then()의 첫 번째 파라미터에 작성한 함수가 호출됩니다.<br>파라미터에 Promise 인스턴스를 지정하면 인스턴스를 성공 상태로 변환하여 반환합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> promiseObj = <span class=\"built_in\">Promise</span>.resolve(  </span><br><span class=\"line\"> &#123;<span class=\"attr\">sports</span>: <span class=\"string\">\"스포츠\"</span>, <span class=\"attr\">music</span>: <span class=\"string\">\"음악\"</span>&#125;  </span><br><span class=\"line\">);  </span><br><span class=\"line\"><span class=\"number\">2.</span> promiseObj.then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> param)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(name, param[name]);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">Promise</span>.resolve(  </span><br><span class=\"line\"> [<span class=\"string\">\"sports\"</span>, <span class=\"string\">\"music\"</span>]  </span><br><span class=\"line\">).then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(param));  </span><br><span class=\"line\"><span class=\"comment\">// sports 스포츠  </span></span><br><span class=\"line\"><span class=\"comment\">// music 음악  </span></span><br><span class=\"line\"><span class=\"comment\">// [\"sports\", \"music\"]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Promise.resolve()를 호출하면 Promise 인스턴스를 생성하고 Promise를 성공 상태로 설정하여 반환합니다.<br>then()의 핸들러 함수에 파라미터 하나만 작성할 수 있으므로 다 수의 파라미터 값을 넘겨주기 위해 Object 오브젝트로 작성했습니다.</p>\n<ul>\n<li>다음은 promiseObj 인스턴스 구조입니다.<img src=\"/images/resolvePromiseObj.JPG\">\n</li>\n</ul>\n<ol>\n<li><p><strong>proto</strong>에 첨부된 프로퍼티가 Promise.prototype에 연결된 프로퍼티와 같습니다.<br>이는 new 연산자를 사용하지 않고 Promise.resolve()를 실행해도 Promise 인스턴스를 생성한다는 의미입니다.</p>\n</li>\n<li><p>[[PromiseState]] 값이 “resolve”로 설정되어 있습니다. 따라서 then()의 첫 번째 파라미터의 핸들러 함수가 실행됩니다.</p>\n</li>\n<li><p>Promise.resolve()의 파라미터 값이 [[PromiseValue]]에 설정되었으며 then()의 핸들러 함수의 파라미터에 설정됩니다.</p>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>PromiseObj의 Promise 인스턴스가 성공 상태이므로 then()의 첫 번째 파라미터 함수가 실행됩니다.<br>이 시점에서 실행되지 않고 소스 코드에 작성된 코드를 끝까지 처리한 후 실행됩니다.<br>핸들러 함수의 param 파라미터에 {sports: “스포츠”, music: “음악”}이 설정됩니다.</p>\n</li>\n<li><p>Promise.resolve() 가 Promise 인스턴스를 생성하여 반환하므로 then()을 연결하여 작성할 수 있습니다.<br>지금 then()의 핸들러 함수를 실행하지 않고, 위에 작성한 then()의 핸들러 함수를 먼저 실행한 후 실행합니다.<br>resolve()파라미터 값인 [“sports”, “music”]이 then()의 핸들러 함수의 param 파라미터에 설정됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> oneObj = <span class=\"built_in\">Promise</span>.resolve(  </span><br><span class=\"line\"> &#123;<span class=\"attr\">sports</span>: <span class=\"string\">\"스포츠\"</span>&#125;  </span><br><span class=\"line\">);  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">Promise</span>.resolve(oneObj).then(<span class=\"function\">(<span class=\"params\">param</span>) =&gt;</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(param);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;sports: \"스포츠\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>promise.resolve() 파라미터에 promise.resolve()로 생성한 인스턴스를 지정한 형태입니다.</li>\n</ul>\n<ol>\n<li><p>Promise 인스턴스를 생성하여 반환합니다. 이때 resolve( )의 파라미터 값이 [[PromiseValue]]에 설정됩니다.</p>\n</li>\n<li><p>Promise.resolve() 파라미터에 앞에서 생성한 Promise 인스턴스를 지정했습니다.<br>then()의 핸들러 함수가 실행되면 oneObj 인스턴스 [[PromiseValue]]에 설정된 값이 핸들러 함수의 param 파라미터에 설정됩니다. 즉, {sports: “스포츠”}가 설정됩니다.</p>\n</li>\n</ol>\n<h3 id=\"thenable\"><a href=\"#thenable\" class=\"headerlink\" title=\"thenable\"></a>thenable</h3><blockquote>\n<p>let obj = {then(resolve,reject) {…} }와 같이 오브젝트 안에 then()을 작성한 형태를 thenable이라고 합니다.</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> oneObj = <span class=\"built_in\">Promise</span>.resolve(&#123;  </span><br><span class=\"line\"> then(resolve)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1: then\"</span>);  </span><br><span class=\"line\"> resolve(<span class=\"string\">\"thenable\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"number\">2.</span> oneObj.then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>,value));  </span><br><span class=\"line\"><span class=\"comment\">// 1: then  </span></span><br><span class=\"line\"><span class=\"comment\">// 2: thenable</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Promise.resolve()의 파라미터에 Object 오브젝트를 작성하고, 그 안에 then()을 작성했습니다.<br>이를 thenable이라고 합니다.이 시점에서는 Promise 인스턴스만 생성하고 then()을 실행하지 않습니다.<br>소스 코드의 마지막 코드까지 실행한 후 then()을 실행합니다.<br>oneObj에 생성한 인스턴스를 할당한 시점의 [[PromiseState]]값은 “pending”입니다.<br>then()의 resolve(“thenable”)을 호출하기 전까지 “pending”상태 이며 호출하면 “resolved”로 바뀝니다.</p>\n</li>\n<li><p>oneObj 인스턴스에 then()이 포함되어 있으므로 위 코드를 연결하면 oneObj.then().then() 형태가 됩니다.<br>이 형태는 다음과 같은 순서와 방법으로 실행됩니다.</p>\n<ol>\n<li>oneObj 인스턴스의 then(resolve)가 실행됩니다.</li>\n<li>콘솔에 “1:then”을 출력합니다.</li>\n<li>resolve(“thenable”)을 호출합니다. 이때[[PromiseValue]]에 “thenable”을 설정합니다.</li>\n<li>oneObj.then().then() 형태에서 두 번째 then()이 호출됩니다.</li>\n<li>두 번째 then()의 value 파라미터에 [[PromiseValue]] 값인 “thenable”이 설정됩니다.</li>\n<li>콘솔에 “2:thenable”을 출력합니다.</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> thenable = &#123;  </span><br><span class=\"line\"> then(resolve, reject)&#123;  </span><br><span class=\"line\"> resolve(<span class=\"string\">\"resolve\"</span>);  </span><br><span class=\"line\"> reject(<span class=\"string\">\"에러\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> oneObj = <span class=\"built_in\">Promise</span>.resolve(thenable);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> oneObj.then(  </span><br><span class=\"line\"> (value) =&gt; <span class=\"built_in\">console</span>.log(value),  </span><br><span class=\"line\"> (value) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"실행되지 않음\"</span>)  </span><br><span class=\"line\">);  </span><br><span class=\"line\"><span class=\"comment\">// resolve</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Object 오브젝트에 then(resolve,reject)를 작성하였으며, resolve() 다음 줄에 reject()를 작성하였습니다. 작성 형태만 보면 resolve()를 호출하고 reject()를 호출할 것으로 보이지만,<br><mark>성공 또는 실패 하나만 발생하므로 먼저 작성한 resolve()만 호출됩니다.<br>반대로 reject(), resolve() 순서로 작성하면 reject()만 호출되고 resolve()는 호출되지 않습니다.</mark></li>\n</ul>\n<ol>\n<li><p>Promise.resolve() 파라미터에 thenable 오브젝트를 지정하여 Promise 인스턴스를 생성합니다. 이때 then()은 실행되지 않습니다.</p>\n</li>\n<li><p>oneObj.then()에 두 개의 파라미터를 작성했습니다.<br>첫 번째 파라미터는 resolve()로 호출했을 때 실행되는 함수이고<br>두 번째 파라미터는 reject()로 호출했을 때 실행되는 함수입니다.<br>oneObj 인스턴스에 then()이 있으므로 oneObj.then()은 then().then() 형태가 됩니다.<br>첫 번째 then()에서 resolve(“resolve”)를 호출하면 [[PromiseValue]]에 “resolve”가 설정됩니다.<br>두 번째 then()의 첫 번째 파라미터 함수가 실행되며, value 파라미터에 “resolve”가 설정됩니다.<br>두 번째 파라미터 함수는 reject()를 호출하였을 때 실행되므로 위 코드에서는 실행되지 않습니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Promise_reject\">reject(): 실패 상태의 인스턴스 반환</h2>\n\n<p>reject(실패) 상태의 Promise 인스턴스를 반환합니다.</p>\n<blockquote>\n<p>Promise.reject()</p>\n</blockquote>\n<ul>\n<li><p>파라미터에 실패 사유를 작성합니다.</p>\n</li>\n<li><p>reject 상태로 변환된 Promise 인스턴스를 반환합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> promiseObj = <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">\"reject 처리\"</span>);  </span><br><span class=\"line\"><span class=\"number\">2.</span> promiseObj.then(  </span><br><span class=\"line\"> (param) =&gt; <span class=\"built_in\">console</span>.log(param),  </span><br><span class=\"line\"> (param) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"에러:\"</span>, param));  </span><br><span class=\"line\"><span class=\"comment\">// 에러: reject 처리</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Promise.reject()를 실행하면 reject 상태의 Promise 인스턴스를 생성하여 반환합니다.<br>파라미터 값이 [[PromiseValue]]에 설정되며, then()의 두 번째 파라미터 함수의 파라미터 값으로 설정됩니다.<br>다음은 promiseObj 인스턴스 구조입니다.</p>\n<img src=\"/images/rejectPromiseObj.JPG\">\n\n<ol>\n<li>Promise 인스턴스의 상태는 “reject”입니다. 따라서 then()의 두 번째 파라미터 함수가 호출됩니다.</li>\n<li>Promise.reject() 파라미터에 작성한 “reject 처리”가 [[PromiseValue]]에 설정됩니다.</li>\n</ol>\n</li>\n<li><p>promiseObj.then()에 두 개의 파라미터를 작성했습니다. 첫 번째 파라미터 함수는 resolve()로 호출했을 때 실행되고, 두 번째 파라미터 함수는 reject()로 호출했을 때 실행됩니다. 현재 reject 상태이므로 두 번째 파라미터 함수가 실행됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Promise_all\">all(): 모두 성공이면 핸들러 실행</h2>\n\n<p>파라미터의 모든 Promise 인스턴스가 성공 상태이면 then()의 핸들러 함수를 실행합니다.</p>\n<blockquote>\n<p>Promise.all()</p>\n</blockquote>\n<ul>\n<li>파라미터에 이터러블 오브젝트를 작성합니다.<br>이터러블 오브젝트에 작성한 순서로 Promise 인스턴스를 생성합니다.</li>\n</ul>\n<p><mark>생성한 모든 Promise 인스턴스가 성공 상태이면, then()의 첫 번째 파라미터 함수를 실행합니다.<br>Promise 인스턴스가 하나라도 실패한다면, then()의 핸들러 함수를 실행하지 않습니다.</mark></p>\n<p>executer 블록에서 resolve()를 호출한 순서가 아닌 Promise 인스턴스를 생성한 순서로 파라미터 값을 배열에 첨부하여 [[PromiseValue]]에 설정합니다. then()의 첫 번째 파라미터 함수에서 파라미터 값으로 사용합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">order</span>(<span class=\"params\">mili</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"실행\"</span>, mili);  </span><br><span class=\"line\"> resolve(mili);  </span><br><span class=\"line\"> &#125;, mili);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">Promise</span>.all([order(<span class=\"number\">300</span>), order(<span class=\"number\">200</span>), order(<span class=\"number\">100</span>)])  </span><br><span class=\"line\"> .then(<span class=\"function\">(<span class=\"params\">milis</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"호출\"</span>, milis));  </span><br><span class=\"line\"><span class=\"comment\">// 실행 100  </span></span><br><span class=\"line\"><span class=\"comment\">// 실행 200  </span></span><br><span class=\"line\"><span class=\"comment\">// 실행 300  </span></span><br><span class=\"line\"><span class=\"comment\">// 호출 [300, 200, 100]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>order(mili)가 호출되면 Promise 인스턴스를 생성하면서 setTimeout()을 실행합니다.<br>파라미터로 받은 mili 값을 지연 시간으로 사용합니다. 지연 시간이 경과한 후에 setTimeout의 콜백 함수가 실행됩니다. order()를 여러 번 호출했을 때, 호출한 순서가 아닌 mili 값에 따라 콜백 함수가 실행되므로 실행 순서가 달라질 수 있습니다. 즉, 콜백 함수에서 resolve() 호출 순서가 바뀔 수 있습니다.</p>\n</li>\n<li><p>Promise.all()의 파라미터에 order() 호출을 배열로 작성했습니다.<br>따라서 첫 번째 엘리먼트부터 차례로 order() 함수를 호출하게 됩니다. 호출된 order() 함수에서 setTimeout()을 실행하며, 파라미터로 넘겨준 값을 지연 시간으로 사용합니다.<br>함수 호출에는 시간이 걸리지 않아 (0.1초 안에) 세 개의 order() 300,200,100 순서로 호출됩니다.<br>하지만 setTimeout()의 콜백 함수는 지연 시간으로 인해 100, 200, 300 순서로 실행되게 됩니다.</p>\n</li>\n</ol>\n<p>setTimeout()에서 지연 시간이 경과하면 콜백 함수에서 resolve(mili)를 호출하게 되며<br>then()의 핸들러 함수가 실행됩니다. 이때, Promise.all()은 resolve(mili)를 호출할 때 마다 then()의 핸들러 함수가 실행되지 않습니다. Promise.all()의 파라미터에서 order() 호출로 생성한 Promise 인스턴스가 모두 성공적으로 처리되었을 때 한 번만 호출합니다.<br>Promise.all()에서 order()함수를 총 세 번 호출하지만, 생성된 인스턴스가 모두 성공적으로 처리돼야 then()의 핸들러 함수를 실행하는 것입니다.</p>\n<p>실행 결과 “실행 100”, “실행 200”, “실행 300”은 setTimeout의 콜백 함수가 실행한 출력 값이고,<br>호출 [300, 200, 100]은 then()의 핸들러 함수에서 출력한 값입니다.</p>\n<hr>\n<h2 id=\"Promise_race\">race(): 처음 한 번만 핸들러 호출</h2>\n\n<p>처음 한 번만 then()의 핸들러 함수를 실행합니다.</p>\n<blockquote>\n<p>Promise.race()</p>\n</blockquote>\n<ul>\n<li>파라미터에 이터러블 오브젝트를 작성합니다. 이터러블 오브젝트에 작성한 순서로 Promise 인스턴스를 생성합니다. 처음 한 번만 Promise 인스턴스 성공과 실패에 따라 then()의 핸들러 함수를 호출하고, 그 다음 부터는 호출하지 않습니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">order</span>(<span class=\"params\">mili</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;  </span><br><span class=\"line\"> setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(mili);  </span><br><span class=\"line\"> resolve(mili);  </span><br><span class=\"line\"> &#125;, mili);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">Promise</span>.race([order(<span class=\"number\">300</span>), order(<span class=\"number\">200</span>), order(<span class=\"number\">100</span>)])  </span><br><span class=\"line\"> .then(<span class=\"function\">(<span class=\"params\">milis</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"then:\"</span>, milis),  </span><br><span class=\"line\"> (error) =&gt; <span class=\"built_in\">console</span>.log(error));  </span><br><span class=\"line\"><span class=\"comment\">// 100  </span></span><br><span class=\"line\"><span class=\"comment\">// then: 100  </span></span><br><span class=\"line\"><span class=\"comment\">// 200  </span></span><br><span class=\"line\"><span class=\"comment\">// 300</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Promise.race()에서 order(300), order(200), order(100) 순서로 order() 함수를 호출합니다.<br>하지만 Promise.race()는 처음 한 번만 then()의 핸들러 함수가 실행되므로<br>order(200), order(100)의 핸들러 함수는 실행되지 않습니다.</li>\n</ol>"},{"title":"Object 오브젝트 -ECMAScript","date":"2020-03-23T01:28:44.000Z","disqusId":"tunas-blog-1","_content":"\n\nES6에서 Object 오브젝트에 작성하고 제어하는 방법이 추가 되었습니다.  \n어떤것은 ES5와 다르게 변경된 것도 있습니다.\n\n*   Object\n    \n    * [오퍼레이션](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_Operation)\n    * [디스크립터](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_Descriptor)\n    * [get, set 속성](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_get_set)\n    * [getter](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_getter)\n    * [setter](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_setter)\n    * [is(): 값과 값 타입 비교](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_is)\n    * [assign(): 오브젝트 프로퍼티 복사](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign)\n    * [assign() 필요성](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign_necessity)\n    * [assign() 고려사항](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign_consider)\n    * [assign() getter](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign_getter)\n    * [setPrototypeOf():&#95;&#95;proto&#95;&#95;에 첨부](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_setPrototypeOf)\n    * [&#95;&#95;proto&#95;&#95;](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_proto)\n   \n<!-- more -->\n\n* * *\n\n<h2 id=\"Object_Operation\">오퍼레이션</h2>\n\n* * *\n\n### Object에 같은 key 사용\n\n(var obj= {key: value}) 형태에서 key 값이 같은 프로퍼티를 두 개 작성했을 때  \n자바스크립트 에디션(버젼)별로 차이가 있습니다.\n\n**ES3에서는 key 값이 같더라도 추가되고 ES5의 strict 모드에서는 에러가 발생합니다.**\n\n**ES6에서는 strict 모드에 관계없이 에러가 발생하지 않으며 나중에 작성한 프로퍼티 값으로 대체됩니다.**\n\n```js ES6 같은 key값 사용\n\"use strict\";  \ndebugger;  \n  \nlet sameKey = {one: 1, one: 2};  \nconsole.log(sameKey);  \n// Object {one:2}  \n```\n\n오브젝트 프로퍼티 키 값이 one인 프로퍼티 두 개를 작성 했습니다.  \n`ES6 버젼에서 첫 번째의 one 프로퍼티 값 1이 두 번째 프로퍼티 값 2로 대체됩니다.`  \n`나중에 작성된 프로퍼티는 값만 대체되고 추가되지 않습니다.`  \n`{one:2}가 두 개 작성되지 않습니다.`\n\n### 변수 이름으로 값 설정\n\n변수 이름을 사용하여 Object의 프로퍼티 값을 설정할 수 있습니다.\n\n```js\nlet one = 1, two = 2;  \nlet values = {one, two};  \nconsole.log(values);  \n// Object {one: 1, two:2}  \n```\n\n(let values = {one, two})에서 one이 프로퍼티 이름이 되면서 one 변수 값인 1이  \n프로퍼티 값으로 설정됩니다.  \ntwo 역시 프로퍼티 이름이 되면서 변수 값인 2가 프로퍼티 값으로 설정됩니다.\n\n{one, two} 의 형태가 변수의 이름을 사용하여 프로퍼티 이름이 되면서  \n변수의 값이 프로퍼티 키로 할당되어 {one:1, two:2}형태로 변환 됩니다.\n\n### Object에 function 작성\n\n*   ES5 에서는 Object에 함수를 아래와 같은 형태로 작성합니다.\n\n```js ES5\nlet obj = {  \n getTotal: function(param){  \n return param + 123;  \n }  \n};  \nconsole.log(obj.getTotal(400));  \n//523  \n```\n\n*   ES6 에서 Object에 함수(메서드)를 다른 방법으로 작성할 수 있습니다.\n\n```js ES6\nlet obj = {  \n getTotal(param){  \n return param + 123;  \n }  \n};  \nconsole.log(obj.getTotal(400));  \n//523  \n```\n\ngetTotal(param) {} 형태와 같이 클론(:)과 function 키워드를 작성 하지 않습니다.  \n이 형태의 설명은 다음에 다루고 여기서는 바뀐 형태와 그에 따른 코드 작성의 편리함 정도만 알고 넘어갑니다.\n\n* * *\n\n<h2 id=\"Object_Descriptor\">디스크립터</h2>\n\n디스크립터(Descriptor)는 ES5에서 제시되었으며 이를 바탕으로  \nES6에서 여러 기능들이 추가 되었습니다.\n\n내용의 연결을 위해 간단하게 요점만 다룹니다.\n\n```js\nObject.defineProperty({}, \"book\", {  \n value : 123  \n enumerable: true  \n});  \n```\n\n“book”은 프로퍼티 이름입니다. 프로퍼티 이름 이외에  \n{value: 123, enumerable: true}가 프로퍼티 디스크립터입니다.  \n프로퍼티 디스크립터는 속성 이름(enumerable)과 속성 값(true)으로 구성됩니다.\n\n프로퍼티 디스크립터는 데이터 프로퍼티 디스크립터 타입과 엑세스(access) 디스크립터 타입으로 분류됩니다.\n\n### 프로퍼티 디스크립터\n\n| 타입   | 속성 이름    | 속성 값 형태           | 디폴트 값 | 개요                        |\n|--------|--------------|------------------------|-----------|-----------------------------|\n| 데이터 | value        | Javascript 데이터 타입 | undefined | 프로퍼티 값으로 사용        |\n|        | writable     | true, false            | false     | false: 속성 값 변경 불가    |\n| 엑세스 | get          | function, undefined    | undefined | 프로퍼티 getter 함수        |\n|        | set          | function, undefined    | undefined | 프로퍼티 setter 함수        |\n| 공용   | enumerable   | true, false            | false     | false: for-in으로 열거 불가 |\n|        | configurable | true, false            | false     | false: 프로퍼티 삭제 불가   |\n\n\n데이터 타입 속성과 엑세스 타입 속성을 같이 작성할 수 없습니다.  \n“{value:1, get: function(){}}” 형태과 같이 value 속성과 get 속성을 같이 작성하면 에러가 발생합니다.\n\n스펙에서 {writable: true} 형태를 [[writable]]:true로 기술하고 있습니다.  \nenumerable,configurable도 같습니다.  \n위와 같이 대괄호 두 개 [[]] 사이에 속성 이름을 작성합니다.\n\n* * *\n\n<h2 id=\"Object_get_set\">get, set 속성</h2>\n\nget 속성은 getter 기능을 제공하고 set 속성은 setter 기능을 제공합니다.\n\n**아래는 ES5 에서의 사용 형태 입니다.**\n\n```js ES5 get\nvar obj = {};  \n2. Object.defineProperty(obj, \"book\", {  \n 3. get: function(){  \n 4. return \"책\";  \n }  \n});  \n  \n1. console.log(obj.book); // 책  \n```\n\n1.  엔진이 코드를 해석하면\n    \n\n2.  obj 오브젝트에서 book 프로퍼티 작성 여부를 체크합니다.  \n    book 프로퍼티가 작성되어 있으면 get 속성의 존재 여부를 체크합니다.\n    \n\n3.  존재한다면 get 속성 값인 함수를 실행합니다. `이것이 getter 입니다.`\n    \n\n4.  getter가 호출되어 호출된 값 “책”이 반환됩니다.\n    \n\n**getter는 obj.book()과 같이 함수를 호출하는 형태로 작성하지 않고**  \n**obj.book과 같이 함수 이름만 작성합니다.**\n\n```js ES5 set\nvar obj = {};  \nObject.defineProperty(obj, \"item\", {  \n set: function(param){  \n this.sports = param;  \n }  \n});  \n  \nobj.item = \"야구\";  \nconsole.log(obj.sports); // 야구  \n```\n\n1.  obj 오브젝트에서 item 프로퍼티 작성 여부를 체크합니다.\n    \n\n2.  작성되어 있으면 set 속성의 존재 여부를 체크합니다. 존재 하면 set 속성 값인 함수를 실행합니다.\n    \n\n3.  이때 “야구” 값 을 실행하는 함수의 파라미터 값으로 넘겨줍니다.  \n    `이것이 setter 입니다.`\n    \n\nsetter가 호출되면 this.sports에서 this가 obj 오브젝트를 참조합니다.  \n파라미터로 넘겨받은 “야구”를 obj 오브젝트의 sports 프로퍼티에 할당합니다.\n\n(obj.sports) 형태는 getter입니다. 하지만 obj 오브젝트에 get 속성을 작성하지 않았습니다. 디폴트로 getter가 호출되어 obj 오브젝트의 sports 프로퍼티 값을 반환 합니다.\n\n* * *\n\n**ES6에서는 보다 직관적으로 getter와 setter를 정의할 수 있습니다.**\n\n```js ES6 getter\nlet obj = {  \n value: 123,  \n get getValue(){  \n return this.value;  \n }  \n};  \nconsole.log(obj.getValue);  \n// 123  \n```\n\n**ES6에서 getter는 함수(메서드) 이름 앞에 명시적으로 “get”을 작성합니다.**\n\n1.  (obj.getValue)와 같이 함수 이름을 작성합니다.\n    \n\n2.  getter getValue가 함수로 호출 됩니다.\n    \n\n3.  this는 obj.getValue의 obj 오브젝트를 참조 합니다.\n    \n\n4.  obj 오브젝트에 value 프로퍼티가 있으므로 값을 반환 합니다.\n    \n\n```js ES6 setter\nlet obj = {  \n set setValue(value){  \n this.value = value;  \n }  \n};  \nobj.setValue = 123;  \nconsole.log(obj.value);  \n// 123  \n```\n\nsetter 또한 ES6에서 함수(메서드) 이름 앞에 명시적으로 “set”을 작성합니다.\n\n1.  (obj.setValue = 123)과 같이 obj 오브젝트의 setValue를 프로퍼티 키로 하여  \n    값을 할당하는 형태로 작성합니다.\n    \n\n2.  setValue가 setter이므로 함수로 호출되고 123을 파라미터 값으로 넘겨줍니다.\n    \n\n3.  this는 obj.setValue의 obj 오브젝트를 참조합니다.\n    \n\n* * *\n\n<h2 id=\"Object_is\">is(): 값과 값 타입 비교</h2>\n\nObject.is() 메서드는 두 개의 파라미터 값과 값 타입을 비교하여 같으면 true, 다르면 false를 반환 합니다.\n\n값과 값 타입을 비교하는 것이지 오브젝트를 비교하는 것이 아닙니다.\n\n배열[]과 배열[] 비교, 오브젝트{}와 오브젝트{} 비교는 false가 반환됩니다.  \n단, window 오브젝트를 비교하면 true를 반환합니다.\n\n값을 비교하는 방법마다 차이가 있습니다.\n\n> 1.  ===  \n>     값과 값 타입을 모두 비교합니다.\n> 2.  ==  \n>     타입은 비교하지 않고 값만 비교합니다.\n> 3.  Object.is()  \n>     값과 값 타입을 모두 비교합니다.\n\n### Object.is() 와 === 의 차이\n\nObject.is()와 ===는 값과 값 타입을 비교하는 점은 같습니다.\n\n차이점.\n\n> *   +0 과 -0을 비교하면\n>     *   Object.is()는 false\n>     *   ===는 true를 반환합니다.\n> *   NaN 과 NaN을 비교하면\n>     *   Object.is()는 true를 반환하고\n>     *   ===는 false를 반환합니다.\n\n```js 정리\nconsole.log(\"1:\", Object.is(1, \"1\"));  \n//false  \n  \nconsole.log(\"2:\", Object.is(NaN, NaN), NaN === NaN);  \n// true false  \n  \nconsole.log(\"3:\", Object.is(0, -0), 0 === -0);  \n// false true  \n  \nconsole.log(\"4:\", Object.is(-0, 0), -0 === 0);  \n// false true  \n  \nconsole.log(\"5:\", Object.is(-0, -0), -0 === -0);  \n// true true  \n  \nconsole.log(\"6:\", Object.is(NaN, 0/0), NaN === 0/0);  \n// true flase  \n  \nconsole.log(\"7:\", Object.is(null, null), null === null);  \n// true true  \n  \nconsole.log(\"8:\", Object.is(undefined, null), undefined === null);  \n// false false  \n```\n\n* * *\n\n<h2 id=\"Object_assign\">assign(): 오브젝트 프로퍼티 복사</h2>\n\nObject.assign() 메소드는 열거할 수 있는 하나 이상의 출처 객체로부터  \n대상 객체로 속성을 복사할 때 사용합니다. 대상 객체를 반환합니다.\n\n> Object.assign(target, …sources)\n\n*   형태 : Object.assign()\n    \n*   target : 열거 가능한 오브젝트 지정\n    \n*   sources : 열거 가능한 오브젝트, 다수 지정 가능, sources 지정안할 시 target 오브젝트 반환\n    \n\n두 번째 파라미터의 오브젝트에서 own 프로퍼티만 복사합니다.  \nprototype과 프로퍼티 디스크럽터는 복사하지 않습니다.\n\n`own 프로퍼티: 오브젝트 자체에서 작성한 프로퍼티를 나타내며 상속받은 프로퍼티는 포함되지 않습니다.`\n\n```js 첫 번째 파라미터 null값\ntry {  \n let obj = Object.assign(null, {x: 1});  \n} catch (e) {  \n 1. console.log(\"null 지정 불가\");  \n}  \n  \n2. console.log(Object.assign(123));  \n// Number {[[PrimitiveValue]]: 123}  \n3. console.log(Object.assign(456, 70));  \n// Number {[[PrimitiveValue]]: 456}  \n```\n\n1.  Object.assign()의 첫 번째 파라미터를 지정하지 않거나 null 또는 undefined로 지정하면 TypeError가 발생합니다.  \n    null로 지정했으므로 catch(e)가 실행되어 “null 지정 불가”가 출력됩니다.\n\n2.  **Object.assign()의 첫 번째 파라미터에 Number, Boolean,  \n    String, Symbol 값을 지정하면 값 타입의 오브젝트를 생성**하고  \n    파라미터 값을 생성한 오브젝트의 [[PrimitiveValue]]에 설정합니다.  \n    첫 번째 파라미터가 123 Number 오브젝트 이므로 Number 오브젝트를 생성하고  \n    [[PrimitiveValue]]에 123을 설정합니다. 마지막으로 생성한 오브젝트를 반환 합니다.\n\n3.  첫 번째, 두 번째 파라미터 모두 열거 가능한 오브젝트가 아닙니다.  \n    첫 번째 오브젝트는 Number 오브젝트 이므로 2번과 같은 방식으로 설정되고 반환됩니다.  \n    하지만 두 번째 오브젝트는 복사되지 않고 반환됩니다.\n\n```js\n1. console.log(Object.assign(\"ABC\", {one: 1}));  \n/*  \nString  \n0: \"A\"  \n1: \"B\"  \n2: \"C\"  \none: 1  \nlength: 3  \n&#95;&#95;proto&#95;&#95;: String  \n[[PrimitiveValue]]: \"ABC\"  \n*/  \n  \n2. console.log(Object.assign(Symbol(\"ABC\"), {one: 1}));  \n/*  \nSymbol  \ndescription: (...)  \none: 1  \n&#95;&#95;proto&#95;&#95;: Symbol  \n[[PrimitiveValue]]: Symbol(ABC)  \n*/  \n  \ntry {  \n let obj = Object.assign(\"ABC\", \"ONE\");  \n} catch (e) {  \n 3. console.log(\"파라미터 모두 문자열 사용 불가\")  \n};  \n```\n\n1.  Object.assign() 첫 번째 파라미터가 String 오브젝트 입니다.  \n    String 오브젝트를 생성하고 [[PrimitiveValue]]에 “ABC”가 설정되고  \n    String 오브젝트는 이터러블 오브젝트 이기 때문에 {one:1}을 복사하고 생성한 오브젝트를 반환합니다.\n\n2.  Object.assign() 첫 번째 파라미터가 Symbol 이므로 Symbol 오브젝트를 생성합니다.  \n    [[PrimitiveValue]]에 Symbol(“ABC”)를 설정합니다.  \n    생성된 Symbol 오브젝트에 {one:1}을 복사합니다.\n\n3.  Object.assign()의 파라미터가 모두 문자열이므로 TypeError가 발생합니다.\n\n\n```js 파라미터 값으로 undefined, null 작성시\nlet oneObj = {};  \n1. Object.assign(oneObj, \"ABC\", undefined, null);  \nconsole.log(oneObj);  \n/*  \nObject  \n0: \"A\"  \n1: \"B\"  \n2: \"C\"  \n&#95;&#95;proto&#95;&#95;: Object  \n*/  \nlet twoObj = {};  \n2. Object.assign(twoObj, {key1: undefined, key2: null});  \nconsole.log(twoObj);  \n/*  \nObject  \nkey1: undefined  \nkey2: null  \n&#95;&#95;proto&#95;&#95;: Object  \n*/  \n```\n\n1.  Object.assign() 파라미터에 undefined, null을 작성하면 복사되지 않습니다.\n\n\n2.  Object.assign() 파라미터에 오브젝트로 작성하고 오브젝트에 프로퍼티 값으로  \n    undefined 와 null을 작성하면 복사됩니다.\n\n`undefined, null를 오브젝트 프로퍼티 값으로 작성시 복사 가능하지만, 파라미터에 값으로 작성하면 복사되지 않습니다.`\n\n* * *\n\n<h2 id=\"Object_assign_necessity\">assign() 필요성</h2>\n\n일반적으로 Object 오브젝트를 변수에 할당하면 프로퍼티가 연동되어  \n한 쪽의 프로퍼티 값을 바꾸면 다른 한 쪽의 프로퍼티 값이 자동으로 바뀝니다.\n\n```js 일반적인 오브젝트 프로퍼티 연동 예시\nlet sports = {  \n event: \"축구\",  \n player: 11  \n}  \n1. let dup = sports;  \n  \n2. sports.player = 55;  \nconsole.log(dup.player);  \n// 55  \n  \n3. dup.event = \"농구\";  \nconsole.log(sports.event);  \n// \"농구\"  \n```\n\n1.  sports 오브젝트를 dup 변수에 할당하면 dup 변수의 오브젝트와 sports 오브젝트의 프로퍼티가 연동됩니다.\n\n> console.log(dup);  \n> {event: “농구”, player: 55}\n> \n> *   event: “농구”\n> *   player: 55\n> *   &#95;&#95;proto&#95;&#95;: Object\n\n즉, 한 쪽 오브젝트 프로퍼티 값을 바꾸면 다른 쪽의 프로퍼티 값이 자동으로 변경됩니다.\n\n2.  sports 오브젝트의 player 프로퍼티에 55를 할당 합니다.  \n    dup 오브젝트의 player 프로퍼티 값이 55로 변경됩니다.  \n    sports 오브젝트는 원본이고 dup 오브젝트가 복사본입니다.\n\n\n3.  복사본 dup 오브젝트의 event 프로퍼티에 값을 할당하면  \n    원본 sports 오브젝트의 event 프로퍼티 값이 자동으로 변경됩니다.\n\n### 값을 연동하여 사용하고 싶지 않은 경우\n\nObject.assign()으로 복사하여 사용하면 프로퍼티 값이 연동되지 않습니다.\n\n```js Object.assign() 사용 복사\nlet sports = {  \n event: \"축구\",  \n player: 11  \n};  \n1. let dup = Object.assign({}, sports);  \nconsole.log(dup.player);  \n// 11  \n  \n2. dup.player = 33;  \nconsole.log(dup.player,sports.player);  \n// 33 11  \n3. sports.event = \"수영\";  \nconsole.log(dup.event,sports.event);  \n// 축구 수영  \n```\n\n1.  Object.assign() 두 번째 프로퍼티에 지정한 sports 오브젝트의 프로퍼티를  \n    첫 번째 파라미터에 지정한 빈 오브젝트{}에 복사합니다.  \n    그리고 첫 번째 파라미터의 오브젝트를 반환하여 dup 변수에 할당합니다.\n\n\n2.  dup 오브젝트의 player 프로퍼티에 33을 할당합니다.  \n    sports 오브젝트의 player 프로퍼티 값은 연동되지 않습니다.\n\n\n3.  sports 오브젝트의 event 프로퍼티에 “수영”을 할당합니다.  \n    dup 오브젝트의 프로퍼티 값은 연동되지 않습니다.\n\n* * *\n\n<h2 id=\"Object_assign_consider\">assign() 고려사항</h2>\n\nObject.assign()은 복사한 값이 연동되지 않아 좋지만 고려할 점도 있습니다.\n\n```js \nlet oneObj = {one: 1};  \nlet twoObj = {two: 2};  \n  \n1. let mergeObj = Object.assign(oneObj, twoObj);  \nconsole.log(Object.is(oneObj, mergeObj));  \n//true  \n  \n2. mergeObj.one = 456;  \nconsole.log(Object.is(oneObj, mergeObj));  \n//true  \n```\n\n1.  twoObj의 프로퍼티를 oneObj에 복사하고 mergeObj에 할당합니다.  \n    oneObj 와 mergeObj의 프로퍼티가 같으므로 ture가 출력됩니다.\n\n\n2.  Object.assign()으로 복사한 첫 번째 파라미터(oneObj)와 두 번째 파라미터(twoObj)의 프로퍼티는 연동되지 않지만,\n\n**첫 번째 파라미터 오브젝트(oneObj)를 할당한 오브젝트(mergeObj)는 연동됩니다.**\n\n* * *\n\n<h2 id=\"Object_assign_getter\">assign() getter</h2>\n\n오브젝트의 프로퍼티를 복사할 때 프로퍼티가 getter이면  \n<u>함수를 복사하지 않고 함수를 호출하여 반환된 값을 복사합니다.</u> \nreturn문을 작성하지 않으면 undefined를 반환합니다.\n\n```js\nlet count = {  \n current: 1,  \n get getCount() {  \n return ++this.current;  \n }  \n};  \nlet mergeObj = {};  \n1. Object.assign(mergeObj, count);  \n2. console.log(mergeObj);  \n// Object {current: 1, getCount: 2}  \n```\n\n1.  두 번째 파라미터 count 오브젝트에 작성된 순서로 복사합니다.  \n    count 오브젝트의 current 프로퍼티를 복사 하고 그 값은 1입니다.  \n    다음 getCount()함수를 복사하는 대신 함수를 호출하고 반환된 값을 복사합니다.  \n    함수에서 this.current에 1을 더하므로 프로퍼티 값은 2가 되고 2를 반환합니다.\n\n2.  count 오브젝트의 current 프로퍼티를 복사하는 시점의 값은 1입니다.  \n    그 후에 getCount() 함수를 호출하면서 1을 더하지만  \n    원본 프로퍼티 값이 변경되더라도 복사된 mergeObj의 프로퍼티 값은 연동되지 않으므로 current 값은 1입니다.  \n    getCount는 함수가 호출되고 반환된 값인 2가 mergeObj의 복사되어 출력됩니다.\n\n* * *\n\n<h2 id=\"Object_setPrototypeOf\">setPrototypeOf(): &#95;&#95;proto&#95;&#95;에 첨부</h2>\n\nObject.setPrototypeOf() 메소드는 지정된 객체의 프로토타입 (즉, 내부 [[Prototype]] 프로퍼티)을 다른 객체 또는 null 로 설정합니다  \n첫 번째 파라미터의 &#95;&#95;proto&#95;&#95;에 두 번째 파라미터를 첨부합니다.\n\n> Object.setPrototypeOf(obj, prototype);\n\n*   obj  \n    오브젝트 또는 인스턴스 (프로토타입 설정을 가지는 오브젝트)  \n    오브젝트에 프로퍼티를 추가 할 수 없는 오브젝트이면 TypeError 발생\n    \n*   prototype  \n    객체의 새로운 프로토 타입 (오브젝트 or null).\n    \n\n<p style=\"color: red;\">경고</p>\n\n오브젝트의 [Prototype]을 변경하는 것은 모든 브라우저와 JavaScript 엔진에서  \n단순히 obj.&#95;&#95;proto&#95;&#95; = … 문에 소요 된 시간으로 제한되지 않고  \n변경된 [Prototype]에 접근할 수 있는 모든 코드로 확장될 수 있습니다.  \n성능에 신경을 쓰면 [[Prototype]] 설정을 피해야 합니다.  \n[[Prototype]]을 변경하는 대신 Object.create()를 사용하여 원하는 [[Prototype]]으로 새 오브젝트를 만듭니다.\n\n```js setPrototypeOf() 예제1\nlet Sports = function(){};  \nSports.prototype.getCount = function(){  \n return 123;  \n};  \n  \n1. let protoObj = Object.setPrototypeOf({}, Sports.prototype);  \n  \n2. console.log(protoObj.getCount());  \n// 123  \n```\n\n1.  setPrototypeOf()의 두 번째 파라미터인 Sports.prototype에 연결된 프로퍼티를 첫 번째 파라미터인 빈 오브젝트{}의 &#95;&#95;proto&#95;&#95;에 첨부합니다.\n\n> *   protoObj: Sports\n>     *   &#95;&#95;proto&#95;&#95;: Object ①\n>         *   getCount: ƒ ()\n>         *   constructor: ƒ ()\n>         *   &#95;&#95;proto&#95;&#95;: Object\n\n*   protoObj에 &#95;&#95;proto&#95;&#95;가 연결되어 있으며 여기에  \n    Sports.prototype의 constructor 와 getCount가 연결되어 있습니다.\n\n2.  protoObj의 &#95;&#95;proto&#95;&#95;에 getCount가 있으므로  \n    protoObj.getCount() 형태로 호출할 수 있습니다.\n\n```js setPrototypeOf() 예제2\nlet Sports = function(){};  \nSports.prototype.getCount = function(){  \n return 123;  \n};  \n  \n1. let fnObj = Object.setPrototypeOf({}, Sports);  \n  \n2. console.log(fnObj.getCount);  \n// undefined  \n3. console.log(fnObj.prototype.getCount.call(Sports));  \n// 123  \n```\n\n1.  예제1에서는 Object.setPrototypeOf()의 두 번째 파라미터를  \n    Sports.prototype를 지정 했습니다. 예제 2에서는 Sports 함수를 지정합니다.  \n    Sports 함수를 첫 번째 파라미터 오브젝트의 &#95;&#95;proto&#95;&#95;에 첨부하여 반환합니다.\n    \n2.  fnObj.getCount를 실행하면 Sports.prototype에 연결된 getCount가 반환되지 않고 undefined가 반환됩니다. 이는 fnObj 또는 fnObj.&#95;&#95;proto&#95;&#95;에 getCount가 없다는 의미입니다.  \n    setPrototypeOf() 두 번째 파라미터에 Sports.prototype이 아닌 Sports를 지정하면 Sports.prototype에 연결된 메서드를 직접 호출할 수 없습니다.\n    \n3.  이와 같이 경로를 지정해 호출해줘야 합니다.  \n    fnObj.&#95;&#95;proto&#95;&#95;.prototype.getCount()가 전체 경로이지만,  \n    &#95;&#95;proto&#95;&#95;는 작성하지 않아도 되므로  \n    fnObj.prototype.getCount.call(Sports)형태로 작성하면  \n    getCount()를 호출할 수 있습니다.    \n\n* * *\n\n<h2 id=\"Object_proto\">&#95;&#95;proto&#95;&#95;</h2>\n\n*   new 연산자로 생성된 인스턴스 또는  \n    다른 오브젝트의 prototype에 연결된 프로퍼티가  \n    &#95;&#95;proto&#95;&#95;에 첨부됩니다.\n\n*   &#95;&#95;proto&#95;&#95;는 엑세스 프로퍼티 입니다.  \n    즉, getter와 setter 기능이 있습니다.\n\n*   &#95;&#95;proto&#95;&#95;는 [[Enumerable]]: false이고  \n    [[Configurable]]: true 입니다.\n\n1.  인스턴스를 생성하면 오브젝트의 prototype에 연결된 프로퍼티가  \n    인스턴스의 &#95;&#95;proto&#95;&#95;에 첨부됩니다.\n\n2.  이 환경이 만들어지면 prototype에 연결된 메서드를 인스턴스 메서드로 호출할 수 있습니다.\n\n*   브라우저 개발자 도구에서 &#95;&#95;proto&#95;&#95;에 첨부되는 것처럼 표시되는 것은 개발자가 인식 하기 쉽도록 하기 위한 것으로 실제로는  \n    원본 오브젝트의 prototype에 연결된 프로퍼티를 참조합니다.  \n    이것을 prototype 공유(share)라고 합니다.  \n    <p style=\"color: yellow\">첨부라는 말은 기능의 표면적 이해를 돕기 위한 것일뿐 실제로 prototype에 프로퍼티를 복사하는 것은 아닙니다. 참조 혹은 prototype 공유가 맞습니다.<p>\n\n* * *\n\n<h2>prototype과 &#95;&#95;proto&#95;&#95; 차이<h2>\n\n&#95;&#95;proto&#95;&#95;에 있는 메서드는 object.name() 형태로 직접 호출할 수 있지만 prototype에 연결된 메서드는 object.prototype.name.call() 형태로 호출해야 합니다.\n\n```js \n1. let Sports = function(){};  \nSports.prototype.get = function(){};  \nlet sportsObj = new Sports();  \n  \n2. sportsObj.&#95;&#95;proto&#95;&#95;[\"set\"] = function(){};  \n3. sportsObj.set();  \n  \n4. let result = Sports.prototype.set;  \nconsole.log(result);  \n// function() {}  \n```\n\n1.  Sports.prototype에 get 메서드를 연결하고 new 연산자로 인스턴스를 생성하여  \n    sportsObj에 할당합니다. sportsObj.&#95;&#95;proto&#95;&#95;에 get()메서드가 첨부됩니다.\n\n\n2.  생성한 sportsObj 인스턴스의 &#95;&#95;proto&#95;&#95;에 set() 메서드를 추가합니다. 이때 &#95;&#95;proto&#95;&#95;에 추가하더라도 &#95;&#95;proto&#95;&#95;에 추가되지 않고 Sports.prototype에 추가됩니다.  \n    왜냐하면 set()메서드를 Sports로 생성한 다른 인스턴스에서 공유하기 때문입니다.\n\n\n3.  set() 메서드가 호출되면 인스턴스의 &#95;&#95;proto&#95;&#95;에 있지만,  \n    &#95;&#95;proto&#95;&#95;은 프로퍼티 검색과 경로 제공을 위한 것으로,  \n    실제로 호출되는 메서드는 인스턴스를 생성한 Sports.prototype에 연결된 메서드입니다.  \n    이것이 prototype의 프로퍼티 공유 개념이며 자바스크립트의 아키텍처입니다.\n\n\n4.  sportsObj의 &#95;&#95;proto&#95;&#95;에 set()메서드를 추가했는데,  \n    Sports.prototype.set으로 코드가 출력된 것은 실제로 Sports.prototype에 추가되기 때문입니다.","source":"_posts/Object 오브젝트 -ECMAScript.md","raw":"---\ntitle: Object 오브젝트 -ECMAScript\ndate: 2020-03-23 10:28:44\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n\nES6에서 Object 오브젝트에 작성하고 제어하는 방법이 추가 되었습니다.  \n어떤것은 ES5와 다르게 변경된 것도 있습니다.\n\n*   Object\n    \n    * [오퍼레이션](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_Operation)\n    * [디스크립터](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_Descriptor)\n    * [get, set 속성](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_get_set)\n    * [getter](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_getter)\n    * [setter](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_setter)\n    * [is(): 값과 값 타입 비교](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_is)\n    * [assign(): 오브젝트 프로퍼티 복사](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign)\n    * [assign() 필요성](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign_necessity)\n    * [assign() 고려사항](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign_consider)\n    * [assign() getter](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign_getter)\n    * [setPrototypeOf():&#95;&#95;proto&#95;&#95;에 첨부](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_setPrototypeOf)\n    * [&#95;&#95;proto&#95;&#95;](/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_proto)\n   \n<!-- more -->\n\n* * *\n\n<h2 id=\"Object_Operation\">오퍼레이션</h2>\n\n* * *\n\n### Object에 같은 key 사용\n\n(var obj= {key: value}) 형태에서 key 값이 같은 프로퍼티를 두 개 작성했을 때  \n자바스크립트 에디션(버젼)별로 차이가 있습니다.\n\n**ES3에서는 key 값이 같더라도 추가되고 ES5의 strict 모드에서는 에러가 발생합니다.**\n\n**ES6에서는 strict 모드에 관계없이 에러가 발생하지 않으며 나중에 작성한 프로퍼티 값으로 대체됩니다.**\n\n```js ES6 같은 key값 사용\n\"use strict\";  \ndebugger;  \n  \nlet sameKey = {one: 1, one: 2};  \nconsole.log(sameKey);  \n// Object {one:2}  \n```\n\n오브젝트 프로퍼티 키 값이 one인 프로퍼티 두 개를 작성 했습니다.  \n`ES6 버젼에서 첫 번째의 one 프로퍼티 값 1이 두 번째 프로퍼티 값 2로 대체됩니다.`  \n`나중에 작성된 프로퍼티는 값만 대체되고 추가되지 않습니다.`  \n`{one:2}가 두 개 작성되지 않습니다.`\n\n### 변수 이름으로 값 설정\n\n변수 이름을 사용하여 Object의 프로퍼티 값을 설정할 수 있습니다.\n\n```js\nlet one = 1, two = 2;  \nlet values = {one, two};  \nconsole.log(values);  \n// Object {one: 1, two:2}  \n```\n\n(let values = {one, two})에서 one이 프로퍼티 이름이 되면서 one 변수 값인 1이  \n프로퍼티 값으로 설정됩니다.  \ntwo 역시 프로퍼티 이름이 되면서 변수 값인 2가 프로퍼티 값으로 설정됩니다.\n\n{one, two} 의 형태가 변수의 이름을 사용하여 프로퍼티 이름이 되면서  \n변수의 값이 프로퍼티 키로 할당되어 {one:1, two:2}형태로 변환 됩니다.\n\n### Object에 function 작성\n\n*   ES5 에서는 Object에 함수를 아래와 같은 형태로 작성합니다.\n\n```js ES5\nlet obj = {  \n getTotal: function(param){  \n return param + 123;  \n }  \n};  \nconsole.log(obj.getTotal(400));  \n//523  \n```\n\n*   ES6 에서 Object에 함수(메서드)를 다른 방법으로 작성할 수 있습니다.\n\n```js ES6\nlet obj = {  \n getTotal(param){  \n return param + 123;  \n }  \n};  \nconsole.log(obj.getTotal(400));  \n//523  \n```\n\ngetTotal(param) {} 형태와 같이 클론(:)과 function 키워드를 작성 하지 않습니다.  \n이 형태의 설명은 다음에 다루고 여기서는 바뀐 형태와 그에 따른 코드 작성의 편리함 정도만 알고 넘어갑니다.\n\n* * *\n\n<h2 id=\"Object_Descriptor\">디스크립터</h2>\n\n디스크립터(Descriptor)는 ES5에서 제시되었으며 이를 바탕으로  \nES6에서 여러 기능들이 추가 되었습니다.\n\n내용의 연결을 위해 간단하게 요점만 다룹니다.\n\n```js\nObject.defineProperty({}, \"book\", {  \n value : 123  \n enumerable: true  \n});  \n```\n\n“book”은 프로퍼티 이름입니다. 프로퍼티 이름 이외에  \n{value: 123, enumerable: true}가 프로퍼티 디스크립터입니다.  \n프로퍼티 디스크립터는 속성 이름(enumerable)과 속성 값(true)으로 구성됩니다.\n\n프로퍼티 디스크립터는 데이터 프로퍼티 디스크립터 타입과 엑세스(access) 디스크립터 타입으로 분류됩니다.\n\n### 프로퍼티 디스크립터\n\n| 타입   | 속성 이름    | 속성 값 형태           | 디폴트 값 | 개요                        |\n|--------|--------------|------------------------|-----------|-----------------------------|\n| 데이터 | value        | Javascript 데이터 타입 | undefined | 프로퍼티 값으로 사용        |\n|        | writable     | true, false            | false     | false: 속성 값 변경 불가    |\n| 엑세스 | get          | function, undefined    | undefined | 프로퍼티 getter 함수        |\n|        | set          | function, undefined    | undefined | 프로퍼티 setter 함수        |\n| 공용   | enumerable   | true, false            | false     | false: for-in으로 열거 불가 |\n|        | configurable | true, false            | false     | false: 프로퍼티 삭제 불가   |\n\n\n데이터 타입 속성과 엑세스 타입 속성을 같이 작성할 수 없습니다.  \n“{value:1, get: function(){}}” 형태과 같이 value 속성과 get 속성을 같이 작성하면 에러가 발생합니다.\n\n스펙에서 {writable: true} 형태를 [[writable]]:true로 기술하고 있습니다.  \nenumerable,configurable도 같습니다.  \n위와 같이 대괄호 두 개 [[]] 사이에 속성 이름을 작성합니다.\n\n* * *\n\n<h2 id=\"Object_get_set\">get, set 속성</h2>\n\nget 속성은 getter 기능을 제공하고 set 속성은 setter 기능을 제공합니다.\n\n**아래는 ES5 에서의 사용 형태 입니다.**\n\n```js ES5 get\nvar obj = {};  \n2. Object.defineProperty(obj, \"book\", {  \n 3. get: function(){  \n 4. return \"책\";  \n }  \n});  \n  \n1. console.log(obj.book); // 책  \n```\n\n1.  엔진이 코드를 해석하면\n    \n\n2.  obj 오브젝트에서 book 프로퍼티 작성 여부를 체크합니다.  \n    book 프로퍼티가 작성되어 있으면 get 속성의 존재 여부를 체크합니다.\n    \n\n3.  존재한다면 get 속성 값인 함수를 실행합니다. `이것이 getter 입니다.`\n    \n\n4.  getter가 호출되어 호출된 값 “책”이 반환됩니다.\n    \n\n**getter는 obj.book()과 같이 함수를 호출하는 형태로 작성하지 않고**  \n**obj.book과 같이 함수 이름만 작성합니다.**\n\n```js ES5 set\nvar obj = {};  \nObject.defineProperty(obj, \"item\", {  \n set: function(param){  \n this.sports = param;  \n }  \n});  \n  \nobj.item = \"야구\";  \nconsole.log(obj.sports); // 야구  \n```\n\n1.  obj 오브젝트에서 item 프로퍼티 작성 여부를 체크합니다.\n    \n\n2.  작성되어 있으면 set 속성의 존재 여부를 체크합니다. 존재 하면 set 속성 값인 함수를 실행합니다.\n    \n\n3.  이때 “야구” 값 을 실행하는 함수의 파라미터 값으로 넘겨줍니다.  \n    `이것이 setter 입니다.`\n    \n\nsetter가 호출되면 this.sports에서 this가 obj 오브젝트를 참조합니다.  \n파라미터로 넘겨받은 “야구”를 obj 오브젝트의 sports 프로퍼티에 할당합니다.\n\n(obj.sports) 형태는 getter입니다. 하지만 obj 오브젝트에 get 속성을 작성하지 않았습니다. 디폴트로 getter가 호출되어 obj 오브젝트의 sports 프로퍼티 값을 반환 합니다.\n\n* * *\n\n**ES6에서는 보다 직관적으로 getter와 setter를 정의할 수 있습니다.**\n\n```js ES6 getter\nlet obj = {  \n value: 123,  \n get getValue(){  \n return this.value;  \n }  \n};  \nconsole.log(obj.getValue);  \n// 123  \n```\n\n**ES6에서 getter는 함수(메서드) 이름 앞에 명시적으로 “get”을 작성합니다.**\n\n1.  (obj.getValue)와 같이 함수 이름을 작성합니다.\n    \n\n2.  getter getValue가 함수로 호출 됩니다.\n    \n\n3.  this는 obj.getValue의 obj 오브젝트를 참조 합니다.\n    \n\n4.  obj 오브젝트에 value 프로퍼티가 있으므로 값을 반환 합니다.\n    \n\n```js ES6 setter\nlet obj = {  \n set setValue(value){  \n this.value = value;  \n }  \n};  \nobj.setValue = 123;  \nconsole.log(obj.value);  \n// 123  \n```\n\nsetter 또한 ES6에서 함수(메서드) 이름 앞에 명시적으로 “set”을 작성합니다.\n\n1.  (obj.setValue = 123)과 같이 obj 오브젝트의 setValue를 프로퍼티 키로 하여  \n    값을 할당하는 형태로 작성합니다.\n    \n\n2.  setValue가 setter이므로 함수로 호출되고 123을 파라미터 값으로 넘겨줍니다.\n    \n\n3.  this는 obj.setValue의 obj 오브젝트를 참조합니다.\n    \n\n* * *\n\n<h2 id=\"Object_is\">is(): 값과 값 타입 비교</h2>\n\nObject.is() 메서드는 두 개의 파라미터 값과 값 타입을 비교하여 같으면 true, 다르면 false를 반환 합니다.\n\n값과 값 타입을 비교하는 것이지 오브젝트를 비교하는 것이 아닙니다.\n\n배열[]과 배열[] 비교, 오브젝트{}와 오브젝트{} 비교는 false가 반환됩니다.  \n단, window 오브젝트를 비교하면 true를 반환합니다.\n\n값을 비교하는 방법마다 차이가 있습니다.\n\n> 1.  ===  \n>     값과 값 타입을 모두 비교합니다.\n> 2.  ==  \n>     타입은 비교하지 않고 값만 비교합니다.\n> 3.  Object.is()  \n>     값과 값 타입을 모두 비교합니다.\n\n### Object.is() 와 === 의 차이\n\nObject.is()와 ===는 값과 값 타입을 비교하는 점은 같습니다.\n\n차이점.\n\n> *   +0 과 -0을 비교하면\n>     *   Object.is()는 false\n>     *   ===는 true를 반환합니다.\n> *   NaN 과 NaN을 비교하면\n>     *   Object.is()는 true를 반환하고\n>     *   ===는 false를 반환합니다.\n\n```js 정리\nconsole.log(\"1:\", Object.is(1, \"1\"));  \n//false  \n  \nconsole.log(\"2:\", Object.is(NaN, NaN), NaN === NaN);  \n// true false  \n  \nconsole.log(\"3:\", Object.is(0, -0), 0 === -0);  \n// false true  \n  \nconsole.log(\"4:\", Object.is(-0, 0), -0 === 0);  \n// false true  \n  \nconsole.log(\"5:\", Object.is(-0, -0), -0 === -0);  \n// true true  \n  \nconsole.log(\"6:\", Object.is(NaN, 0/0), NaN === 0/0);  \n// true flase  \n  \nconsole.log(\"7:\", Object.is(null, null), null === null);  \n// true true  \n  \nconsole.log(\"8:\", Object.is(undefined, null), undefined === null);  \n// false false  \n```\n\n* * *\n\n<h2 id=\"Object_assign\">assign(): 오브젝트 프로퍼티 복사</h2>\n\nObject.assign() 메소드는 열거할 수 있는 하나 이상의 출처 객체로부터  \n대상 객체로 속성을 복사할 때 사용합니다. 대상 객체를 반환합니다.\n\n> Object.assign(target, …sources)\n\n*   형태 : Object.assign()\n    \n*   target : 열거 가능한 오브젝트 지정\n    \n*   sources : 열거 가능한 오브젝트, 다수 지정 가능, sources 지정안할 시 target 오브젝트 반환\n    \n\n두 번째 파라미터의 오브젝트에서 own 프로퍼티만 복사합니다.  \nprototype과 프로퍼티 디스크럽터는 복사하지 않습니다.\n\n`own 프로퍼티: 오브젝트 자체에서 작성한 프로퍼티를 나타내며 상속받은 프로퍼티는 포함되지 않습니다.`\n\n```js 첫 번째 파라미터 null값\ntry {  \n let obj = Object.assign(null, {x: 1});  \n} catch (e) {  \n 1. console.log(\"null 지정 불가\");  \n}  \n  \n2. console.log(Object.assign(123));  \n// Number {[[PrimitiveValue]]: 123}  \n3. console.log(Object.assign(456, 70));  \n// Number {[[PrimitiveValue]]: 456}  \n```\n\n1.  Object.assign()의 첫 번째 파라미터를 지정하지 않거나 null 또는 undefined로 지정하면 TypeError가 발생합니다.  \n    null로 지정했으므로 catch(e)가 실행되어 “null 지정 불가”가 출력됩니다.\n\n2.  **Object.assign()의 첫 번째 파라미터에 Number, Boolean,  \n    String, Symbol 값을 지정하면 값 타입의 오브젝트를 생성**하고  \n    파라미터 값을 생성한 오브젝트의 [[PrimitiveValue]]에 설정합니다.  \n    첫 번째 파라미터가 123 Number 오브젝트 이므로 Number 오브젝트를 생성하고  \n    [[PrimitiveValue]]에 123을 설정합니다. 마지막으로 생성한 오브젝트를 반환 합니다.\n\n3.  첫 번째, 두 번째 파라미터 모두 열거 가능한 오브젝트가 아닙니다.  \n    첫 번째 오브젝트는 Number 오브젝트 이므로 2번과 같은 방식으로 설정되고 반환됩니다.  \n    하지만 두 번째 오브젝트는 복사되지 않고 반환됩니다.\n\n```js\n1. console.log(Object.assign(\"ABC\", {one: 1}));  \n/*  \nString  \n0: \"A\"  \n1: \"B\"  \n2: \"C\"  \none: 1  \nlength: 3  \n&#95;&#95;proto&#95;&#95;: String  \n[[PrimitiveValue]]: \"ABC\"  \n*/  \n  \n2. console.log(Object.assign(Symbol(\"ABC\"), {one: 1}));  \n/*  \nSymbol  \ndescription: (...)  \none: 1  \n&#95;&#95;proto&#95;&#95;: Symbol  \n[[PrimitiveValue]]: Symbol(ABC)  \n*/  \n  \ntry {  \n let obj = Object.assign(\"ABC\", \"ONE\");  \n} catch (e) {  \n 3. console.log(\"파라미터 모두 문자열 사용 불가\")  \n};  \n```\n\n1.  Object.assign() 첫 번째 파라미터가 String 오브젝트 입니다.  \n    String 오브젝트를 생성하고 [[PrimitiveValue]]에 “ABC”가 설정되고  \n    String 오브젝트는 이터러블 오브젝트 이기 때문에 {one:1}을 복사하고 생성한 오브젝트를 반환합니다.\n\n2.  Object.assign() 첫 번째 파라미터가 Symbol 이므로 Symbol 오브젝트를 생성합니다.  \n    [[PrimitiveValue]]에 Symbol(“ABC”)를 설정합니다.  \n    생성된 Symbol 오브젝트에 {one:1}을 복사합니다.\n\n3.  Object.assign()의 파라미터가 모두 문자열이므로 TypeError가 발생합니다.\n\n\n```js 파라미터 값으로 undefined, null 작성시\nlet oneObj = {};  \n1. Object.assign(oneObj, \"ABC\", undefined, null);  \nconsole.log(oneObj);  \n/*  \nObject  \n0: \"A\"  \n1: \"B\"  \n2: \"C\"  \n&#95;&#95;proto&#95;&#95;: Object  \n*/  \nlet twoObj = {};  \n2. Object.assign(twoObj, {key1: undefined, key2: null});  \nconsole.log(twoObj);  \n/*  \nObject  \nkey1: undefined  \nkey2: null  \n&#95;&#95;proto&#95;&#95;: Object  \n*/  \n```\n\n1.  Object.assign() 파라미터에 undefined, null을 작성하면 복사되지 않습니다.\n\n\n2.  Object.assign() 파라미터에 오브젝트로 작성하고 오브젝트에 프로퍼티 값으로  \n    undefined 와 null을 작성하면 복사됩니다.\n\n`undefined, null를 오브젝트 프로퍼티 값으로 작성시 복사 가능하지만, 파라미터에 값으로 작성하면 복사되지 않습니다.`\n\n* * *\n\n<h2 id=\"Object_assign_necessity\">assign() 필요성</h2>\n\n일반적으로 Object 오브젝트를 변수에 할당하면 프로퍼티가 연동되어  \n한 쪽의 프로퍼티 값을 바꾸면 다른 한 쪽의 프로퍼티 값이 자동으로 바뀝니다.\n\n```js 일반적인 오브젝트 프로퍼티 연동 예시\nlet sports = {  \n event: \"축구\",  \n player: 11  \n}  \n1. let dup = sports;  \n  \n2. sports.player = 55;  \nconsole.log(dup.player);  \n// 55  \n  \n3. dup.event = \"농구\";  \nconsole.log(sports.event);  \n// \"농구\"  \n```\n\n1.  sports 오브젝트를 dup 변수에 할당하면 dup 변수의 오브젝트와 sports 오브젝트의 프로퍼티가 연동됩니다.\n\n> console.log(dup);  \n> {event: “농구”, player: 55}\n> \n> *   event: “농구”\n> *   player: 55\n> *   &#95;&#95;proto&#95;&#95;: Object\n\n즉, 한 쪽 오브젝트 프로퍼티 값을 바꾸면 다른 쪽의 프로퍼티 값이 자동으로 변경됩니다.\n\n2.  sports 오브젝트의 player 프로퍼티에 55를 할당 합니다.  \n    dup 오브젝트의 player 프로퍼티 값이 55로 변경됩니다.  \n    sports 오브젝트는 원본이고 dup 오브젝트가 복사본입니다.\n\n\n3.  복사본 dup 오브젝트의 event 프로퍼티에 값을 할당하면  \n    원본 sports 오브젝트의 event 프로퍼티 값이 자동으로 변경됩니다.\n\n### 값을 연동하여 사용하고 싶지 않은 경우\n\nObject.assign()으로 복사하여 사용하면 프로퍼티 값이 연동되지 않습니다.\n\n```js Object.assign() 사용 복사\nlet sports = {  \n event: \"축구\",  \n player: 11  \n};  \n1. let dup = Object.assign({}, sports);  \nconsole.log(dup.player);  \n// 11  \n  \n2. dup.player = 33;  \nconsole.log(dup.player,sports.player);  \n// 33 11  \n3. sports.event = \"수영\";  \nconsole.log(dup.event,sports.event);  \n// 축구 수영  \n```\n\n1.  Object.assign() 두 번째 프로퍼티에 지정한 sports 오브젝트의 프로퍼티를  \n    첫 번째 파라미터에 지정한 빈 오브젝트{}에 복사합니다.  \n    그리고 첫 번째 파라미터의 오브젝트를 반환하여 dup 변수에 할당합니다.\n\n\n2.  dup 오브젝트의 player 프로퍼티에 33을 할당합니다.  \n    sports 오브젝트의 player 프로퍼티 값은 연동되지 않습니다.\n\n\n3.  sports 오브젝트의 event 프로퍼티에 “수영”을 할당합니다.  \n    dup 오브젝트의 프로퍼티 값은 연동되지 않습니다.\n\n* * *\n\n<h2 id=\"Object_assign_consider\">assign() 고려사항</h2>\n\nObject.assign()은 복사한 값이 연동되지 않아 좋지만 고려할 점도 있습니다.\n\n```js \nlet oneObj = {one: 1};  \nlet twoObj = {two: 2};  \n  \n1. let mergeObj = Object.assign(oneObj, twoObj);  \nconsole.log(Object.is(oneObj, mergeObj));  \n//true  \n  \n2. mergeObj.one = 456;  \nconsole.log(Object.is(oneObj, mergeObj));  \n//true  \n```\n\n1.  twoObj의 프로퍼티를 oneObj에 복사하고 mergeObj에 할당합니다.  \n    oneObj 와 mergeObj의 프로퍼티가 같으므로 ture가 출력됩니다.\n\n\n2.  Object.assign()으로 복사한 첫 번째 파라미터(oneObj)와 두 번째 파라미터(twoObj)의 프로퍼티는 연동되지 않지만,\n\n**첫 번째 파라미터 오브젝트(oneObj)를 할당한 오브젝트(mergeObj)는 연동됩니다.**\n\n* * *\n\n<h2 id=\"Object_assign_getter\">assign() getter</h2>\n\n오브젝트의 프로퍼티를 복사할 때 프로퍼티가 getter이면  \n<u>함수를 복사하지 않고 함수를 호출하여 반환된 값을 복사합니다.</u> \nreturn문을 작성하지 않으면 undefined를 반환합니다.\n\n```js\nlet count = {  \n current: 1,  \n get getCount() {  \n return ++this.current;  \n }  \n};  \nlet mergeObj = {};  \n1. Object.assign(mergeObj, count);  \n2. console.log(mergeObj);  \n// Object {current: 1, getCount: 2}  \n```\n\n1.  두 번째 파라미터 count 오브젝트에 작성된 순서로 복사합니다.  \n    count 오브젝트의 current 프로퍼티를 복사 하고 그 값은 1입니다.  \n    다음 getCount()함수를 복사하는 대신 함수를 호출하고 반환된 값을 복사합니다.  \n    함수에서 this.current에 1을 더하므로 프로퍼티 값은 2가 되고 2를 반환합니다.\n\n2.  count 오브젝트의 current 프로퍼티를 복사하는 시점의 값은 1입니다.  \n    그 후에 getCount() 함수를 호출하면서 1을 더하지만  \n    원본 프로퍼티 값이 변경되더라도 복사된 mergeObj의 프로퍼티 값은 연동되지 않으므로 current 값은 1입니다.  \n    getCount는 함수가 호출되고 반환된 값인 2가 mergeObj의 복사되어 출력됩니다.\n\n* * *\n\n<h2 id=\"Object_setPrototypeOf\">setPrototypeOf(): &#95;&#95;proto&#95;&#95;에 첨부</h2>\n\nObject.setPrototypeOf() 메소드는 지정된 객체의 프로토타입 (즉, 내부 [[Prototype]] 프로퍼티)을 다른 객체 또는 null 로 설정합니다  \n첫 번째 파라미터의 &#95;&#95;proto&#95;&#95;에 두 번째 파라미터를 첨부합니다.\n\n> Object.setPrototypeOf(obj, prototype);\n\n*   obj  \n    오브젝트 또는 인스턴스 (프로토타입 설정을 가지는 오브젝트)  \n    오브젝트에 프로퍼티를 추가 할 수 없는 오브젝트이면 TypeError 발생\n    \n*   prototype  \n    객체의 새로운 프로토 타입 (오브젝트 or null).\n    \n\n<p style=\"color: red;\">경고</p>\n\n오브젝트의 [Prototype]을 변경하는 것은 모든 브라우저와 JavaScript 엔진에서  \n단순히 obj.&#95;&#95;proto&#95;&#95; = … 문에 소요 된 시간으로 제한되지 않고  \n변경된 [Prototype]에 접근할 수 있는 모든 코드로 확장될 수 있습니다.  \n성능에 신경을 쓰면 [[Prototype]] 설정을 피해야 합니다.  \n[[Prototype]]을 변경하는 대신 Object.create()를 사용하여 원하는 [[Prototype]]으로 새 오브젝트를 만듭니다.\n\n```js setPrototypeOf() 예제1\nlet Sports = function(){};  \nSports.prototype.getCount = function(){  \n return 123;  \n};  \n  \n1. let protoObj = Object.setPrototypeOf({}, Sports.prototype);  \n  \n2. console.log(protoObj.getCount());  \n// 123  \n```\n\n1.  setPrototypeOf()의 두 번째 파라미터인 Sports.prototype에 연결된 프로퍼티를 첫 번째 파라미터인 빈 오브젝트{}의 &#95;&#95;proto&#95;&#95;에 첨부합니다.\n\n> *   protoObj: Sports\n>     *   &#95;&#95;proto&#95;&#95;: Object ①\n>         *   getCount: ƒ ()\n>         *   constructor: ƒ ()\n>         *   &#95;&#95;proto&#95;&#95;: Object\n\n*   protoObj에 &#95;&#95;proto&#95;&#95;가 연결되어 있으며 여기에  \n    Sports.prototype의 constructor 와 getCount가 연결되어 있습니다.\n\n2.  protoObj의 &#95;&#95;proto&#95;&#95;에 getCount가 있으므로  \n    protoObj.getCount() 형태로 호출할 수 있습니다.\n\n```js setPrototypeOf() 예제2\nlet Sports = function(){};  \nSports.prototype.getCount = function(){  \n return 123;  \n};  \n  \n1. let fnObj = Object.setPrototypeOf({}, Sports);  \n  \n2. console.log(fnObj.getCount);  \n// undefined  \n3. console.log(fnObj.prototype.getCount.call(Sports));  \n// 123  \n```\n\n1.  예제1에서는 Object.setPrototypeOf()의 두 번째 파라미터를  \n    Sports.prototype를 지정 했습니다. 예제 2에서는 Sports 함수를 지정합니다.  \n    Sports 함수를 첫 번째 파라미터 오브젝트의 &#95;&#95;proto&#95;&#95;에 첨부하여 반환합니다.\n    \n2.  fnObj.getCount를 실행하면 Sports.prototype에 연결된 getCount가 반환되지 않고 undefined가 반환됩니다. 이는 fnObj 또는 fnObj.&#95;&#95;proto&#95;&#95;에 getCount가 없다는 의미입니다.  \n    setPrototypeOf() 두 번째 파라미터에 Sports.prototype이 아닌 Sports를 지정하면 Sports.prototype에 연결된 메서드를 직접 호출할 수 없습니다.\n    \n3.  이와 같이 경로를 지정해 호출해줘야 합니다.  \n    fnObj.&#95;&#95;proto&#95;&#95;.prototype.getCount()가 전체 경로이지만,  \n    &#95;&#95;proto&#95;&#95;는 작성하지 않아도 되므로  \n    fnObj.prototype.getCount.call(Sports)형태로 작성하면  \n    getCount()를 호출할 수 있습니다.    \n\n* * *\n\n<h2 id=\"Object_proto\">&#95;&#95;proto&#95;&#95;</h2>\n\n*   new 연산자로 생성된 인스턴스 또는  \n    다른 오브젝트의 prototype에 연결된 프로퍼티가  \n    &#95;&#95;proto&#95;&#95;에 첨부됩니다.\n\n*   &#95;&#95;proto&#95;&#95;는 엑세스 프로퍼티 입니다.  \n    즉, getter와 setter 기능이 있습니다.\n\n*   &#95;&#95;proto&#95;&#95;는 [[Enumerable]]: false이고  \n    [[Configurable]]: true 입니다.\n\n1.  인스턴스를 생성하면 오브젝트의 prototype에 연결된 프로퍼티가  \n    인스턴스의 &#95;&#95;proto&#95;&#95;에 첨부됩니다.\n\n2.  이 환경이 만들어지면 prototype에 연결된 메서드를 인스턴스 메서드로 호출할 수 있습니다.\n\n*   브라우저 개발자 도구에서 &#95;&#95;proto&#95;&#95;에 첨부되는 것처럼 표시되는 것은 개발자가 인식 하기 쉽도록 하기 위한 것으로 실제로는  \n    원본 오브젝트의 prototype에 연결된 프로퍼티를 참조합니다.  \n    이것을 prototype 공유(share)라고 합니다.  \n    <p style=\"color: yellow\">첨부라는 말은 기능의 표면적 이해를 돕기 위한 것일뿐 실제로 prototype에 프로퍼티를 복사하는 것은 아닙니다. 참조 혹은 prototype 공유가 맞습니다.<p>\n\n* * *\n\n<h2>prototype과 &#95;&#95;proto&#95;&#95; 차이<h2>\n\n&#95;&#95;proto&#95;&#95;에 있는 메서드는 object.name() 형태로 직접 호출할 수 있지만 prototype에 연결된 메서드는 object.prototype.name.call() 형태로 호출해야 합니다.\n\n```js \n1. let Sports = function(){};  \nSports.prototype.get = function(){};  \nlet sportsObj = new Sports();  \n  \n2. sportsObj.&#95;&#95;proto&#95;&#95;[\"set\"] = function(){};  \n3. sportsObj.set();  \n  \n4. let result = Sports.prototype.set;  \nconsole.log(result);  \n// function() {}  \n```\n\n1.  Sports.prototype에 get 메서드를 연결하고 new 연산자로 인스턴스를 생성하여  \n    sportsObj에 할당합니다. sportsObj.&#95;&#95;proto&#95;&#95;에 get()메서드가 첨부됩니다.\n\n\n2.  생성한 sportsObj 인스턴스의 &#95;&#95;proto&#95;&#95;에 set() 메서드를 추가합니다. 이때 &#95;&#95;proto&#95;&#95;에 추가하더라도 &#95;&#95;proto&#95;&#95;에 추가되지 않고 Sports.prototype에 추가됩니다.  \n    왜냐하면 set()메서드를 Sports로 생성한 다른 인스턴스에서 공유하기 때문입니다.\n\n\n3.  set() 메서드가 호출되면 인스턴스의 &#95;&#95;proto&#95;&#95;에 있지만,  \n    &#95;&#95;proto&#95;&#95;은 프로퍼티 검색과 경로 제공을 위한 것으로,  \n    실제로 호출되는 메서드는 인스턴스를 생성한 Sports.prototype에 연결된 메서드입니다.  \n    이것이 prototype의 프로퍼티 공유 개념이며 자바스크립트의 아키텍처입니다.\n\n\n4.  sportsObj의 &#95;&#95;proto&#95;&#95;에 set()메서드를 추가했는데,  \n    Sports.prototype.set으로 코드가 출력된 것은 실제로 Sports.prototype에 추가되기 때문입니다.","slug":"Object 오브젝트 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrsn0018qgvq8oenhqsx","content":"<p>ES6에서 Object 오브젝트에 작성하고 제어하는 방법이 추가 되었습니다.<br>어떤것은 ES5와 다르게 변경된 것도 있습니다.</p>\n<ul>\n<li><p>Object</p>\n<ul>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_Operation\">오퍼레이션</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_Descriptor\">디스크립터</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_get_set\">get, set 속성</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_getter\">getter</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_setter\">setter</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_is\">is(): 값과 값 타입 비교</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign\">assign(): 오브젝트 프로퍼티 복사</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign_necessity\">assign() 필요성</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign_consider\">assign() 고려사항</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign_getter\">assign() getter</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_setPrototypeOf\">setPrototypeOf():&#95;&#95;proto&#95;&#95;에 첨부</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_proto\">&#95;&#95;proto&#95;&#95;</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"Object_Operation\">오퍼레이션</h2>\n\n<hr>\n<h3 id=\"Object에-같은-key-사용\"><a href=\"#Object에-같은-key-사용\" class=\"headerlink\" title=\"Object에 같은 key 사용\"></a>Object에 같은 key 사용</h3><p>(var obj= {key: value}) 형태에서 key 값이 같은 프로퍼티를 두 개 작성했을 때<br>자바스크립트 에디션(버젼)별로 차이가 있습니다.</p>\n<p><strong>ES3에서는 key 값이 같더라도 추가되고 ES5의 strict 모드에서는 에러가 발생합니다.</strong></p>\n<p><strong>ES6에서는 strict 모드에 관계없이 에러가 발생하지 않으며 나중에 작성한 프로퍼티 값으로 대체됩니다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>ES6 같은 key값 사용</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">debugger</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> sameKey = &#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>, <span class=\"attr\">one</span>: <span class=\"number\">2</span>&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sameKey);  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;one:2&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>오브젝트 프로퍼티 키 값이 one인 프로퍼티 두 개를 작성 했습니다.<br><code>ES6 버젼에서 첫 번째의 one 프로퍼티 값 1이 두 번째 프로퍼티 값 2로 대체됩니다.</code><br><code>나중에 작성된 프로퍼티는 값만 대체되고 추가되지 않습니다.</code><br><code>{one:2}가 두 개 작성되지 않습니다.</code></p>\n<h3 id=\"변수-이름으로-값-설정\"><a href=\"#변수-이름으로-값-설정\" class=\"headerlink\" title=\"변수 이름으로 값 설정\"></a>변수 이름으로 값 설정</h3><p>변수 이름을 사용하여 Object의 프로퍼티 값을 설정할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"number\">1</span>, two = <span class=\"number\">2</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> values = &#123;one, two&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(values);  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;one: 1, two:2&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>(let values = {one, two})에서 one이 프로퍼티 이름이 되면서 one 변수 값인 1이<br>프로퍼티 값으로 설정됩니다.<br>two 역시 프로퍼티 이름이 되면서 변수 값인 2가 프로퍼티 값으로 설정됩니다.</p>\n<p>{one, two} 의 형태가 변수의 이름을 사용하여 프로퍼티 이름이 되면서<br>변수의 값이 프로퍼티 키로 할당되어 {one:1, two:2}형태로 변환 됩니다.</p>\n<h3 id=\"Object에-function-작성\"><a href=\"#Object에-function-작성\" class=\"headerlink\" title=\"Object에 function 작성\"></a>Object에 function 작성</h3><ul>\n<li>ES5 에서는 Object에 함수를 아래와 같은 형태로 작성합니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>ES5</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;  </span><br><span class=\"line\"> getTotal: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> param + <span class=\"number\">123</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getTotal(<span class=\"number\">400</span>));  </span><br><span class=\"line\"><span class=\"comment\">//523</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES6 에서 Object에 함수(메서드)를 다른 방법으로 작성할 수 있습니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>ES6</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;  </span><br><span class=\"line\"> getTotal(param)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> param + <span class=\"number\">123</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getTotal(<span class=\"number\">400</span>));  </span><br><span class=\"line\"><span class=\"comment\">//523</span></span><br></pre></td></tr></table></figure>\n\n<p>getTotal(param) {} 형태와 같이 클론(:)과 function 키워드를 작성 하지 않습니다.<br>이 형태의 설명은 다음에 다루고 여기서는 바뀐 형태와 그에 따른 코드 작성의 편리함 정도만 알고 넘어갑니다.</p>\n<hr>\n<h2 id=\"Object_Descriptor\">디스크립터</h2>\n\n<p>디스크립터(Descriptor)는 ES5에서 제시되었으며 이를 바탕으로<br>ES6에서 여러 기능들이 추가 되었습니다.</p>\n<p>내용의 연결을 위해 간단하게 요점만 다룹니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(&#123;&#125;, <span class=\"string\">\"book\"</span>, &#123;  </span><br><span class=\"line\"> value : <span class=\"number\">123</span>  </span><br><span class=\"line\"> enumerable: <span class=\"literal\">true</span>  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>“book”은 프로퍼티 이름입니다. 프로퍼티 이름 이외에<br>{value: 123, enumerable: true}가 프로퍼티 디스크립터입니다.<br>프로퍼티 디스크립터는 속성 이름(enumerable)과 속성 값(true)으로 구성됩니다.</p>\n<p>프로퍼티 디스크립터는 데이터 프로퍼티 디스크립터 타입과 엑세스(access) 디스크립터 타입으로 분류됩니다.</p>\n<h3 id=\"프로퍼티-디스크립터\"><a href=\"#프로퍼티-디스크립터\" class=\"headerlink\" title=\"프로퍼티 디스크립터\"></a>프로퍼티 디스크립터</h3><table>\n<thead>\n<tr>\n<th>타입</th>\n<th>속성 이름</th>\n<th>속성 값 형태</th>\n<th>디폴트 값</th>\n<th>개요</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>데이터</td>\n<td>value</td>\n<td>Javascript 데이터 타입</td>\n<td>undefined</td>\n<td>프로퍼티 값으로 사용</td>\n</tr>\n<tr>\n<td></td>\n<td>writable</td>\n<td>true, false</td>\n<td>false</td>\n<td>false: 속성 값 변경 불가</td>\n</tr>\n<tr>\n<td>엑세스</td>\n<td>get</td>\n<td>function, undefined</td>\n<td>undefined</td>\n<td>프로퍼티 getter 함수</td>\n</tr>\n<tr>\n<td></td>\n<td>set</td>\n<td>function, undefined</td>\n<td>undefined</td>\n<td>프로퍼티 setter 함수</td>\n</tr>\n<tr>\n<td>공용</td>\n<td>enumerable</td>\n<td>true, false</td>\n<td>false</td>\n<td>false: for-in으로 열거 불가</td>\n</tr>\n<tr>\n<td></td>\n<td>configurable</td>\n<td>true, false</td>\n<td>false</td>\n<td>false: 프로퍼티 삭제 불가</td>\n</tr>\n</tbody></table>\n<p>데이터 타입 속성과 엑세스 타입 속성을 같이 작성할 수 없습니다.<br>“{value:1, get: function(){}}” 형태과 같이 value 속성과 get 속성을 같이 작성하면 에러가 발생합니다.</p>\n<p>스펙에서 {writable: true} 형태를 [[writable]]:true로 기술하고 있습니다.<br>enumerable,configurable도 같습니다.<br>위와 같이 대괄호 두 개 [[]] 사이에 속성 이름을 작성합니다.</p>\n<hr>\n<h2 id=\"Object_get_set\">get, set 속성</h2>\n\n<p>get 속성은 getter 기능을 제공하고 set 속성은 setter 기능을 제공합니다.</p>\n<p><strong>아래는 ES5 에서의 사용 형태 입니다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>ES5 get</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">\"book\"</span>, &#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"keyword\">get</span>: function()&#123;  </span><br><span class=\"line\"> <span class=\"number\">4.</span> <span class=\"keyword\">return</span> <span class=\"string\">\"책\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(obj.book); <span class=\"comment\">// 책</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>엔진이 코드를 해석하면</li>\n</ol>\n<ol start=\"2\">\n<li>obj 오브젝트에서 book 프로퍼티 작성 여부를 체크합니다.<br>book 프로퍼티가 작성되어 있으면 get 속성의 존재 여부를 체크합니다.</li>\n</ol>\n<ol start=\"3\">\n<li>존재한다면 get 속성 값인 함수를 실행합니다. <code>이것이 getter 입니다.</code></li>\n</ol>\n<ol start=\"4\">\n<li>getter가 호출되어 호출된 값 “책”이 반환됩니다.</li>\n</ol>\n<p><strong>getter는 obj.book()과 같이 함수를 호출하는 형태로 작성하지 않고</strong><br><strong>obj.book과 같이 함수 이름만 작성합니다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>ES5 set</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">\"item\"</span>, &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">set</span>: function(param)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.sports = param;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">obj.item = <span class=\"string\">\"야구\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.sports); <span class=\"comment\">// 야구</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>obj 오브젝트에서 item 프로퍼티 작성 여부를 체크합니다.</li>\n</ol>\n<ol start=\"2\">\n<li>작성되어 있으면 set 속성의 존재 여부를 체크합니다. 존재 하면 set 속성 값인 함수를 실행합니다.</li>\n</ol>\n<ol start=\"3\">\n<li>이때 “야구” 값 을 실행하는 함수의 파라미터 값으로 넘겨줍니다.<br><code>이것이 setter 입니다.</code></li>\n</ol>\n<p>setter가 호출되면 this.sports에서 this가 obj 오브젝트를 참조합니다.<br>파라미터로 넘겨받은 “야구”를 obj 오브젝트의 sports 프로퍼티에 할당합니다.</p>\n<p>(obj.sports) 형태는 getter입니다. 하지만 obj 오브젝트에 get 속성을 작성하지 않았습니다. 디폴트로 getter가 호출되어 obj 오브젝트의 sports 프로퍼티 값을 반환 합니다.</p>\n<hr>\n<p><strong>ES6에서는 보다 직관적으로 getter와 setter를 정의할 수 있습니다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>ES6 getter</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;  </span><br><span class=\"line\"> value: <span class=\"number\">123</span>,  </span><br><span class=\"line\"> <span class=\"keyword\">get</span> getValue()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getValue);  </span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>ES6에서 getter는 함수(메서드) 이름 앞에 명시적으로 “get”을 작성합니다.</strong></p>\n<ol>\n<li>(obj.getValue)와 같이 함수 이름을 작성합니다.</li>\n</ol>\n<ol start=\"2\">\n<li>getter getValue가 함수로 호출 됩니다.</li>\n</ol>\n<ol start=\"3\">\n<li>this는 obj.getValue의 obj 오브젝트를 참조 합니다.</li>\n</ol>\n<ol start=\"4\">\n<li>obj 오브젝트에 value 프로퍼티가 있으므로 값을 반환 합니다.</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>ES6 setter</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">set</span> setValue(value)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.value = value;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">obj.setValue = <span class=\"number\">123</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.value);  </span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n\n<p>setter 또한 ES6에서 함수(메서드) 이름 앞에 명시적으로 “set”을 작성합니다.</p>\n<ol>\n<li>(obj.setValue = 123)과 같이 obj 오브젝트의 setValue를 프로퍼티 키로 하여<br>값을 할당하는 형태로 작성합니다.</li>\n</ol>\n<ol start=\"2\">\n<li>setValue가 setter이므로 함수로 호출되고 123을 파라미터 값으로 넘겨줍니다.</li>\n</ol>\n<ol start=\"3\">\n<li>this는 obj.setValue의 obj 오브젝트를 참조합니다.</li>\n</ol>\n<hr>\n<h2 id=\"Object_is\">is(): 값과 값 타입 비교</h2>\n\n<p>Object.is() 메서드는 두 개의 파라미터 값과 값 타입을 비교하여 같으면 true, 다르면 false를 반환 합니다.</p>\n<p>값과 값 타입을 비교하는 것이지 오브젝트를 비교하는 것이 아닙니다.</p>\n<p>배열[]과 배열[] 비교, 오브젝트{}와 오브젝트{} 비교는 false가 반환됩니다.<br>단, window 오브젝트를 비교하면 true를 반환합니다.</p>\n<p>값을 비교하는 방법마다 차이가 있습니다.</p>\n<blockquote>\n<ol>\n<li>===<br>값과 값 타입을 모두 비교합니다.</li>\n<li>==<br>타입은 비교하지 않고 값만 비교합니다.</li>\n<li>Object.is()<br>값과 값 타입을 모두 비교합니다.</li>\n</ol>\n</blockquote>\n<h3 id=\"Object-is-와-의-차이\"><a href=\"#Object-is-와-의-차이\" class=\"headerlink\" title=\"Object.is() 와 === 의 차이\"></a>Object.is() 와 === 의 차이</h3><p>Object.is()와 ===는 값과 값 타입을 비교하는 점은 같습니다.</p>\n<p>차이점.</p>\n<blockquote>\n<ul>\n<li>+0 과 -0을 비교하면<ul>\n<li>Object.is()는 false</li>\n<li>===는 true를 반환합니다.</li>\n</ul>\n</li>\n<li>NaN 과 NaN을 비교하면<ul>\n<li>Object.is()는 true를 반환하고</li>\n<li>===는 false를 반환합니다.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight js\"><figcaption><span>정리</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"number\">1</span>, <span class=\"string\">\"1\"</span>));  </span><br><span class=\"line\"><span class=\"comment\">//false  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>), <span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span>);  </span><br><span class=\"line\"><span class=\"comment\">// true false  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"number\">0</span>, <span class=\"number\">-0</span>), <span class=\"number\">0</span> === <span class=\"number\">-0</span>);  </span><br><span class=\"line\"><span class=\"comment\">// false true  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"number\">-0</span>, <span class=\"number\">0</span>), <span class=\"number\">-0</span> === <span class=\"number\">0</span>);  </span><br><span class=\"line\"><span class=\"comment\">// false true  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"number\">-0</span>, <span class=\"number\">-0</span>), <span class=\"number\">-0</span> === <span class=\"number\">-0</span>);  </span><br><span class=\"line\"><span class=\"comment\">// true true  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"6:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, <span class=\"number\">0</span>/<span class=\"number\">0</span>), <span class=\"literal\">NaN</span> === <span class=\"number\">0</span>/<span class=\"number\">0</span>);  </span><br><span class=\"line\"><span class=\"comment\">// true flase  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"7:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>), <span class=\"literal\">null</span> === <span class=\"literal\">null</span>);  </span><br><span class=\"line\"><span class=\"comment\">// true true  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"8:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"literal\">undefined</span>, <span class=\"literal\">null</span>), <span class=\"literal\">undefined</span> === <span class=\"literal\">null</span>);  </span><br><span class=\"line\"><span class=\"comment\">// false false</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Object_assign\">assign(): 오브젝트 프로퍼티 복사</h2>\n\n<p>Object.assign() 메소드는 열거할 수 있는 하나 이상의 출처 객체로부터<br>대상 객체로 속성을 복사할 때 사용합니다. 대상 객체를 반환합니다.</p>\n<blockquote>\n<p>Object.assign(target, …sources)</p>\n</blockquote>\n<ul>\n<li><p>형태 : Object.assign()</p>\n</li>\n<li><p>target : 열거 가능한 오브젝트 지정</p>\n</li>\n<li><p>sources : 열거 가능한 오브젝트, 다수 지정 가능, sources 지정안할 시 target 오브젝트 반환</p>\n</li>\n</ul>\n<p>두 번째 파라미터의 오브젝트에서 own 프로퍼티만 복사합니다.<br>prototype과 프로퍼티 디스크럽터는 복사하지 않습니다.</p>\n<p><code>own 프로퍼티: 오브젝트 자체에서 작성한 프로퍼티를 나타내며 상속받은 프로퍼티는 포함되지 않습니다.</code></p>\n<figure class=\"highlight js\"><figcaption><span>첫 번째 파라미터 null값</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> obj = <span class=\"built_in\">Object</span>.assign(<span class=\"literal\">null</span>, &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;);  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"null 지정 불가\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.assign(<span class=\"number\">123</span>));  </span><br><span class=\"line\"><span class=\"comment\">// Number &#123;[[PrimitiveValue]]: 123&#125;  </span></span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.assign(<span class=\"number\">456</span>, <span class=\"number\">70</span>));  </span><br><span class=\"line\"><span class=\"comment\">// Number &#123;[[PrimitiveValue]]: 456&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Object.assign()의 첫 번째 파라미터를 지정하지 않거나 null 또는 undefined로 지정하면 TypeError가 발생합니다.<br>null로 지정했으므로 catch(e)가 실행되어 “null 지정 불가”가 출력됩니다.</p>\n</li>\n<li><p><strong>Object.assign()의 첫 번째 파라미터에 Number, Boolean,<br>String, Symbol 값을 지정하면 값 타입의 오브젝트를 생성</strong>하고<br>파라미터 값을 생성한 오브젝트의 [[PrimitiveValue]]에 설정합니다.<br>첫 번째 파라미터가 123 Number 오브젝트 이므로 Number 오브젝트를 생성하고<br>[[PrimitiveValue]]에 123을 설정합니다. 마지막으로 생성한 오브젝트를 반환 합니다.</p>\n</li>\n<li><p>첫 번째, 두 번째 파라미터 모두 열거 가능한 오브젝트가 아닙니다.<br>첫 번째 오브젝트는 Number 오브젝트 이므로 2번과 같은 방식으로 설정되고 반환됩니다.<br>하지만 두 번째 오브젝트는 복사되지 않고 반환됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.assign(<span class=\"string\">\"ABC\"</span>, &#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>&#125;));  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">String  </span></span><br><span class=\"line\"><span class=\"comment\">0: \"A\"  </span></span><br><span class=\"line\"><span class=\"comment\">1: \"B\"  </span></span><br><span class=\"line\"><span class=\"comment\">2: \"C\"  </span></span><br><span class=\"line\"><span class=\"comment\">one: 1  </span></span><br><span class=\"line\"><span class=\"comment\">length: 3  </span></span><br><span class=\"line\"><span class=\"comment\">&amp;#95;&amp;#95;proto&amp;#95;&amp;#95;: String  </span></span><br><span class=\"line\"><span class=\"comment\">[[PrimitiveValue]]: \"ABC\"  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.assign(<span class=\"built_in\">Symbol</span>(<span class=\"string\">\"ABC\"</span>), &#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>&#125;));  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Symbol  </span></span><br><span class=\"line\"><span class=\"comment\">description: (...)  </span></span><br><span class=\"line\"><span class=\"comment\">one: 1  </span></span><br><span class=\"line\"><span class=\"comment\">&amp;#95;&amp;#95;proto&amp;#95;&amp;#95;: Symbol  </span></span><br><span class=\"line\"><span class=\"comment\">[[PrimitiveValue]]: Symbol(ABC)  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> obj = <span class=\"built_in\">Object</span>.assign(<span class=\"string\">\"ABC\"</span>, <span class=\"string\">\"ONE\"</span>);  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"파라미터 모두 문자열 사용 불가\"</span>)  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Object.assign() 첫 번째 파라미터가 String 오브젝트 입니다.<br>String 오브젝트를 생성하고 [[PrimitiveValue]]에 “ABC”가 설정되고<br>String 오브젝트는 이터러블 오브젝트 이기 때문에 {one:1}을 복사하고 생성한 오브젝트를 반환합니다.</p>\n</li>\n<li><p>Object.assign() 첫 번째 파라미터가 Symbol 이므로 Symbol 오브젝트를 생성합니다.<br>[[PrimitiveValue]]에 Symbol(“ABC”)를 설정합니다.<br>생성된 Symbol 오브젝트에 {one:1}을 복사합니다.</p>\n</li>\n<li><p>Object.assign()의 파라미터가 모두 문자열이므로 TypeError가 발생합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>파라미터 값으로 undefined, null 작성시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> oneObj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">Object</span>.assign(oneObj, <span class=\"string\">\"ABC\"</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">null</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(oneObj);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Object  </span></span><br><span class=\"line\"><span class=\"comment\">0: \"A\"  </span></span><br><span class=\"line\"><span class=\"comment\">1: \"B\"  </span></span><br><span class=\"line\"><span class=\"comment\">2: \"C\"  </span></span><br><span class=\"line\"><span class=\"comment\">&amp;#95;&amp;#95;proto&amp;#95;&amp;#95;: Object  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"><span class=\"keyword\">let</span> twoObj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">Object</span>.assign(twoObj, &#123;<span class=\"attr\">key1</span>: <span class=\"literal\">undefined</span>, <span class=\"attr\">key2</span>: <span class=\"literal\">null</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(twoObj);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Object  </span></span><br><span class=\"line\"><span class=\"comment\">key1: undefined  </span></span><br><span class=\"line\"><span class=\"comment\">key2: null  </span></span><br><span class=\"line\"><span class=\"comment\">&amp;#95;&amp;#95;proto&amp;#95;&amp;#95;: Object  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Object.assign() 파라미터에 undefined, null을 작성하면 복사되지 않습니다.</li>\n</ol>\n<ol start=\"2\">\n<li>Object.assign() 파라미터에 오브젝트로 작성하고 오브젝트에 프로퍼티 값으로<br>undefined 와 null을 작성하면 복사됩니다.</li>\n</ol>\n<p><code>undefined, null를 오브젝트 프로퍼티 값으로 작성시 복사 가능하지만, 파라미터에 값으로 작성하면 복사되지 않습니다.</code></p>\n<hr>\n<h2 id=\"Object_assign_necessity\">assign() 필요성</h2>\n\n<p>일반적으로 Object 오브젝트를 변수에 할당하면 프로퍼티가 연동되어<br>한 쪽의 프로퍼티 값을 바꾸면 다른 한 쪽의 프로퍼티 값이 자동으로 바뀝니다.</p>\n<figure class=\"highlight js\"><figcaption><span>일반적인 오브젝트 프로퍼티 연동 예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = &#123;  </span><br><span class=\"line\"> event: <span class=\"string\">\"축구\"</span>,  </span><br><span class=\"line\"> player: <span class=\"number\">11</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> dup = sports;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> sports.player = <span class=\"number\">55</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dup.player);  </span><br><span class=\"line\"><span class=\"comment\">// 55  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> dup.event = <span class=\"string\">\"농구\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sports.event);  </span><br><span class=\"line\"><span class=\"comment\">// \"농구\"</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>sports 오브젝트를 dup 변수에 할당하면 dup 변수의 오브젝트와 sports 오브젝트의 프로퍼티가 연동됩니다.</li>\n</ol>\n<blockquote>\n<p>console.log(dup);<br>{event: “농구”, player: 55}</p>\n<ul>\n<li>event: “농구”</li>\n<li>player: 55</li>\n<li>&#95;&#95;proto&#95;&#95;: Object</li>\n</ul>\n</blockquote>\n<p>즉, 한 쪽 오브젝트 프로퍼티 값을 바꾸면 다른 쪽의 프로퍼티 값이 자동으로 변경됩니다.</p>\n<ol start=\"2\">\n<li>sports 오브젝트의 player 프로퍼티에 55를 할당 합니다.<br>dup 오브젝트의 player 프로퍼티 값이 55로 변경됩니다.<br>sports 오브젝트는 원본이고 dup 오브젝트가 복사본입니다.</li>\n</ol>\n<ol start=\"3\">\n<li>복사본 dup 오브젝트의 event 프로퍼티에 값을 할당하면<br>원본 sports 오브젝트의 event 프로퍼티 값이 자동으로 변경됩니다.</li>\n</ol>\n<h3 id=\"값을-연동하여-사용하고-싶지-않은-경우\"><a href=\"#값을-연동하여-사용하고-싶지-않은-경우\" class=\"headerlink\" title=\"값을 연동하여 사용하고 싶지 않은 경우\"></a>값을 연동하여 사용하고 싶지 않은 경우</h3><p>Object.assign()으로 복사하여 사용하면 프로퍼티 값이 연동되지 않습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>Object.assign() 사용 복사</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = &#123;  </span><br><span class=\"line\"> event: <span class=\"string\">\"축구\"</span>,  </span><br><span class=\"line\"> player: <span class=\"number\">11</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> dup = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, sports);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dup.player);  </span><br><span class=\"line\"><span class=\"comment\">// 11  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> dup.player = <span class=\"number\">33</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dup.player,sports.player);  </span><br><span class=\"line\"><span class=\"comment\">// 33 11  </span></span><br><span class=\"line\"><span class=\"number\">3.</span> sports.event = <span class=\"string\">\"수영\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dup.event,sports.event);  </span><br><span class=\"line\"><span class=\"comment\">// 축구 수영</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Object.assign() 두 번째 프로퍼티에 지정한 sports 오브젝트의 프로퍼티를<br>첫 번째 파라미터에 지정한 빈 오브젝트{}에 복사합니다.<br>그리고 첫 번째 파라미터의 오브젝트를 반환하여 dup 변수에 할당합니다.</li>\n</ol>\n<ol start=\"2\">\n<li>dup 오브젝트의 player 프로퍼티에 33을 할당합니다.<br>sports 오브젝트의 player 프로퍼티 값은 연동되지 않습니다.</li>\n</ol>\n<ol start=\"3\">\n<li>sports 오브젝트의 event 프로퍼티에 “수영”을 할당합니다.<br>dup 오브젝트의 프로퍼티 값은 연동되지 않습니다.</li>\n</ol>\n<hr>\n<h2 id=\"Object_assign_consider\">assign() 고려사항</h2>\n\n<p>Object.assign()은 복사한 값이 연동되지 않아 좋지만 고려할 점도 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> oneObj = &#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> twoObj = &#123;<span class=\"attr\">two</span>: <span class=\"number\">2</span>&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> mergeObj = <span class=\"built_in\">Object</span>.assign(oneObj, twoObj);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(oneObj, mergeObj));  </span><br><span class=\"line\"><span class=\"comment\">//true  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> mergeObj.one = <span class=\"number\">456</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(oneObj, mergeObj));  </span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>twoObj의 프로퍼티를 oneObj에 복사하고 mergeObj에 할당합니다.<br>oneObj 와 mergeObj의 프로퍼티가 같으므로 ture가 출력됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li>Object.assign()으로 복사한 첫 번째 파라미터(oneObj)와 두 번째 파라미터(twoObj)의 프로퍼티는 연동되지 않지만,</li>\n</ol>\n<p><strong>첫 번째 파라미터 오브젝트(oneObj)를 할당한 오브젝트(mergeObj)는 연동됩니다.</strong></p>\n<hr>\n<h2 id=\"Object_assign_getter\">assign() getter</h2>\n\n<p>오브젝트의 프로퍼티를 복사할 때 프로퍼티가 getter이면<br><u>함수를 복사하지 않고 함수를 호출하여 반환된 값을 복사합니다.</u><br>return문을 작성하지 않으면 undefined를 반환합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> count = &#123;  </span><br><span class=\"line\"> current: <span class=\"number\">1</span>,  </span><br><span class=\"line\"> <span class=\"keyword\">get</span> getCount() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> ++<span class=\"keyword\">this</span>.current;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> mergeObj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">Object</span>.assign(mergeObj, count);  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(mergeObj);  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;current: 1, getCount: 2&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>두 번째 파라미터 count 오브젝트에 작성된 순서로 복사합니다.<br>count 오브젝트의 current 프로퍼티를 복사 하고 그 값은 1입니다.<br>다음 getCount()함수를 복사하는 대신 함수를 호출하고 반환된 값을 복사합니다.<br>함수에서 this.current에 1을 더하므로 프로퍼티 값은 2가 되고 2를 반환합니다.</p>\n</li>\n<li><p>count 오브젝트의 current 프로퍼티를 복사하는 시점의 값은 1입니다.<br>그 후에 getCount() 함수를 호출하면서 1을 더하지만<br>원본 프로퍼티 값이 변경되더라도 복사된 mergeObj의 프로퍼티 값은 연동되지 않으므로 current 값은 1입니다.<br>getCount는 함수가 호출되고 반환된 값인 2가 mergeObj의 복사되어 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Object_setPrototypeOf\">setPrototypeOf(): &#95;&#95;proto&#95;&#95;에 첨부</h2>\n\n<p>Object.setPrototypeOf() 메소드는 지정된 객체의 프로토타입 (즉, 내부 [[Prototype]] 프로퍼티)을 다른 객체 또는 null 로 설정합니다<br>첫 번째 파라미터의 &#95;&#95;proto&#95;&#95;에 두 번째 파라미터를 첨부합니다.</p>\n<blockquote>\n<p>Object.setPrototypeOf(obj, prototype);</p>\n</blockquote>\n<ul>\n<li><p>obj<br>오브젝트 또는 인스턴스 (프로토타입 설정을 가지는 오브젝트)<br>오브젝트에 프로퍼티를 추가 할 수 없는 오브젝트이면 TypeError 발생</p>\n</li>\n<li><p>prototype<br>객체의 새로운 프로토 타입 (오브젝트 or null).</p>\n</li>\n</ul>\n<p style=\"color: red;\">경고</p>\n\n<p>오브젝트의 [Prototype]을 변경하는 것은 모든 브라우저와 JavaScript 엔진에서<br>단순히 obj.&#95;&#95;proto&#95;&#95; = … 문에 소요 된 시간으로 제한되지 않고<br>변경된 [Prototype]에 접근할 수 있는 모든 코드로 확장될 수 있습니다.<br>성능에 신경을 쓰면 [[Prototype]] 설정을 피해야 합니다.<br>[[Prototype]]을 변경하는 대신 Object.create()를 사용하여 원하는 [[Prototype]]으로 새 오브젝트를 만듭니다.</p>\n<figure class=\"highlight js\"><figcaption><span>setPrototypeOf() 예제1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\">Sports.prototype.getCount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"number\">123</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> protoObj = <span class=\"built_in\">Object</span>.setPrototypeOf(&#123;&#125;, Sports.prototype);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(protoObj.getCount());  </span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>setPrototypeOf()의 두 번째 파라미터인 Sports.prototype에 연결된 프로퍼티를 첫 번째 파라미터인 빈 오브젝트{}의 &#95;&#95;proto&#95;&#95;에 첨부합니다.</li>\n</ol>\n<blockquote>\n<ul>\n<li>protoObj: Sports<ul>\n<li>&#95;&#95;proto&#95;&#95;: Object ①<ul>\n<li>getCount: ƒ ()</li>\n<li>constructor: ƒ ()</li>\n<li>&#95;&#95;proto&#95;&#95;: Object</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>protoObj에 &#95;&#95;proto&#95;&#95;가 연결되어 있으며 여기에<br>Sports.prototype의 constructor 와 getCount가 연결되어 있습니다.</li>\n</ul>\n<ol start=\"2\">\n<li>protoObj의 &#95;&#95;proto&#95;&#95;에 getCount가 있으므로<br>protoObj.getCount() 형태로 호출할 수 있습니다.</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>setPrototypeOf() 예제2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\">Sports.prototype.getCount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"number\">123</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> fnObj = <span class=\"built_in\">Object</span>.setPrototypeOf(&#123;&#125;, Sports);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(fnObj.getCount);  </span><br><span class=\"line\"><span class=\"comment\">// undefined  </span></span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(fnObj.prototype.getCount.call(Sports));  </span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>예제1에서는 Object.setPrototypeOf()의 두 번째 파라미터를<br>Sports.prototype를 지정 했습니다. 예제 2에서는 Sports 함수를 지정합니다.<br>Sports 함수를 첫 번째 파라미터 오브젝트의 &#95;&#95;proto&#95;&#95;에 첨부하여 반환합니다.</p>\n</li>\n<li><p>fnObj.getCount를 실행하면 Sports.prototype에 연결된 getCount가 반환되지 않고 undefined가 반환됩니다. 이는 fnObj 또는 fnObj.&#95;&#95;proto&#95;&#95;에 getCount가 없다는 의미입니다.<br>setPrototypeOf() 두 번째 파라미터에 Sports.prototype이 아닌 Sports를 지정하면 Sports.prototype에 연결된 메서드를 직접 호출할 수 없습니다.</p>\n</li>\n<li><p>이와 같이 경로를 지정해 호출해줘야 합니다.<br>fnObj.&#95;&#95;proto&#95;&#95;.prototype.getCount()가 전체 경로이지만,<br>&#95;&#95;proto&#95;&#95;는 작성하지 않아도 되므로<br>fnObj.prototype.getCount.call(Sports)형태로 작성하면<br>getCount()를 호출할 수 있습니다.    </p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Object_proto\">&#95;&#95;proto&#95;&#95;</h2>\n\n<ul>\n<li><p>new 연산자로 생성된 인스턴스 또는<br>다른 오브젝트의 prototype에 연결된 프로퍼티가<br>&#95;&#95;proto&#95;&#95;에 첨부됩니다.</p>\n</li>\n<li><p>&#95;&#95;proto&#95;&#95;는 엑세스 프로퍼티 입니다.<br>즉, getter와 setter 기능이 있습니다.</p>\n</li>\n<li><p>&#95;&#95;proto&#95;&#95;는 [[Enumerable]]: false이고<br>[[Configurable]]: true 입니다.</p>\n</li>\n</ul>\n<ol>\n<li><p>인스턴스를 생성하면 오브젝트의 prototype에 연결된 프로퍼티가<br>인스턴스의 &#95;&#95;proto&#95;&#95;에 첨부됩니다.</p>\n</li>\n<li><p>이 환경이 만들어지면 prototype에 연결된 메서드를 인스턴스 메서드로 호출할 수 있습니다.</p>\n</li>\n</ol>\n<ul>\n<li>브라우저 개발자 도구에서 &#95;&#95;proto&#95;&#95;에 첨부되는 것처럼 표시되는 것은 개발자가 인식 하기 쉽도록 하기 위한 것으로 실제로는<br>원본 오브젝트의 prototype에 연결된 프로퍼티를 참조합니다.<br>이것을 prototype 공유(share)라고 합니다.  <p style=\"color: yellow\">첨부라는 말은 기능의 표면적 이해를 돕기 위한 것일뿐 실제로 prototype에 프로퍼티를 복사하는 것은 아닙니다. 참조 혹은 prototype 공유가 맞습니다.<p>\n\n</li>\n</ul>\n<hr>\n<h2>prototype과 &#95;&#95;proto&#95;&#95; 차이<h2>\n\n<p>&#95;&#95;proto&#95;&#95;에 있는 메서드는 object.name() 형태로 직접 호출할 수 있지만 prototype에 연결된 메서드는 object.prototype.name.call() 형태로 호출해야 합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> Sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\">Sports.prototype.get = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> sportsObj = <span class=\"keyword\">new</span> Sports();  </span><br><span class=\"line\">  </span><br><span class=\"line\">2. sportsObj.&amp;#95;&amp;#95;proto&amp;#95;&amp;#95;[\"set\"] = function()&#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> sportsObj.set();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"keyword\">let</span> result = Sports.prototype.set;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\"><span class=\"comment\">// function() &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Sports.prototype에 get 메서드를 연결하고 new 연산자로 인스턴스를 생성하여<br>sportsObj에 할당합니다. sportsObj.&#95;&#95;proto&#95;&#95;에 get()메서드가 첨부됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li>생성한 sportsObj 인스턴스의 &#95;&#95;proto&#95;&#95;에 set() 메서드를 추가합니다. 이때 &#95;&#95;proto&#95;&#95;에 추가하더라도 &#95;&#95;proto&#95;&#95;에 추가되지 않고 Sports.prototype에 추가됩니다.<br>왜냐하면 set()메서드를 Sports로 생성한 다른 인스턴스에서 공유하기 때문입니다.</li>\n</ol>\n<ol start=\"3\">\n<li>set() 메서드가 호출되면 인스턴스의 &#95;&#95;proto&#95;&#95;에 있지만,<br>&#95;&#95;proto&#95;&#95;은 프로퍼티 검색과 경로 제공을 위한 것으로,<br>실제로 호출되는 메서드는 인스턴스를 생성한 Sports.prototype에 연결된 메서드입니다.<br>이것이 prototype의 프로퍼티 공유 개념이며 자바스크립트의 아키텍처입니다.</li>\n</ol>\n<ol start=\"4\">\n<li>sportsObj의 &#95;&#95;proto&#95;&#95;에 set()메서드를 추가했는데,<br>Sports.prototype.set으로 코드가 출력된 것은 실제로 Sports.prototype에 추가되기 때문입니다.</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>ES6에서 Object 오브젝트에 작성하고 제어하는 방법이 추가 되었습니다.<br>어떤것은 ES5와 다르게 변경된 것도 있습니다.</p>\n<ul>\n<li><p>Object</p>\n<ul>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_Operation\">오퍼레이션</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_Descriptor\">디스크립터</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_get_set\">get, set 속성</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_getter\">getter</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_setter\">setter</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_is\">is(): 값과 값 타입 비교</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign\">assign(): 오브젝트 프로퍼티 복사</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign_necessity\">assign() 필요성</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign_consider\">assign() 고려사항</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_assign_getter\">assign() getter</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_setPrototypeOf\">setPrototypeOf():&#95;&#95;proto&#95;&#95;에 첨부</a></li>\n<li><a href=\"/2020/03/23/Object%20오브젝트%20-ECMAScript/#Object_proto\">&#95;&#95;proto&#95;&#95;</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"Object_Operation\">오퍼레이션</h2>\n\n<hr>\n<h3 id=\"Object에-같은-key-사용\"><a href=\"#Object에-같은-key-사용\" class=\"headerlink\" title=\"Object에 같은 key 사용\"></a>Object에 같은 key 사용</h3><p>(var obj= {key: value}) 형태에서 key 값이 같은 프로퍼티를 두 개 작성했을 때<br>자바스크립트 에디션(버젼)별로 차이가 있습니다.</p>\n<p><strong>ES3에서는 key 값이 같더라도 추가되고 ES5의 strict 모드에서는 에러가 발생합니다.</strong></p>\n<p><strong>ES6에서는 strict 모드에 관계없이 에러가 발생하지 않으며 나중에 작성한 프로퍼티 값으로 대체됩니다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>ES6 같은 key값 사용</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">debugger</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> sameKey = &#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>, <span class=\"attr\">one</span>: <span class=\"number\">2</span>&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sameKey);  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;one:2&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>오브젝트 프로퍼티 키 값이 one인 프로퍼티 두 개를 작성 했습니다.<br><code>ES6 버젼에서 첫 번째의 one 프로퍼티 값 1이 두 번째 프로퍼티 값 2로 대체됩니다.</code><br><code>나중에 작성된 프로퍼티는 값만 대체되고 추가되지 않습니다.</code><br><code>{one:2}가 두 개 작성되지 않습니다.</code></p>\n<h3 id=\"변수-이름으로-값-설정\"><a href=\"#변수-이름으로-값-설정\" class=\"headerlink\" title=\"변수 이름으로 값 설정\"></a>변수 이름으로 값 설정</h3><p>변수 이름을 사용하여 Object의 프로퍼티 값을 설정할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"number\">1</span>, two = <span class=\"number\">2</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> values = &#123;one, two&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(values);  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;one: 1, two:2&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>(let values = {one, two})에서 one이 프로퍼티 이름이 되면서 one 변수 값인 1이<br>프로퍼티 값으로 설정됩니다.<br>two 역시 프로퍼티 이름이 되면서 변수 값인 2가 프로퍼티 값으로 설정됩니다.</p>\n<p>{one, two} 의 형태가 변수의 이름을 사용하여 프로퍼티 이름이 되면서<br>변수의 값이 프로퍼티 키로 할당되어 {one:1, two:2}형태로 변환 됩니다.</p>\n<h3 id=\"Object에-function-작성\"><a href=\"#Object에-function-작성\" class=\"headerlink\" title=\"Object에 function 작성\"></a>Object에 function 작성</h3><ul>\n<li>ES5 에서는 Object에 함수를 아래와 같은 형태로 작성합니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>ES5</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;  </span><br><span class=\"line\"> getTotal: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> param + <span class=\"number\">123</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getTotal(<span class=\"number\">400</span>));  </span><br><span class=\"line\"><span class=\"comment\">//523</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES6 에서 Object에 함수(메서드)를 다른 방법으로 작성할 수 있습니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>ES6</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;  </span><br><span class=\"line\"> getTotal(param)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> param + <span class=\"number\">123</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getTotal(<span class=\"number\">400</span>));  </span><br><span class=\"line\"><span class=\"comment\">//523</span></span><br></pre></td></tr></table></figure>\n\n<p>getTotal(param) {} 형태와 같이 클론(:)과 function 키워드를 작성 하지 않습니다.<br>이 형태의 설명은 다음에 다루고 여기서는 바뀐 형태와 그에 따른 코드 작성의 편리함 정도만 알고 넘어갑니다.</p>\n<hr>\n<h2 id=\"Object_Descriptor\">디스크립터</h2>\n\n<p>디스크립터(Descriptor)는 ES5에서 제시되었으며 이를 바탕으로<br>ES6에서 여러 기능들이 추가 되었습니다.</p>\n<p>내용의 연결을 위해 간단하게 요점만 다룹니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(&#123;&#125;, <span class=\"string\">\"book\"</span>, &#123;  </span><br><span class=\"line\"> value : <span class=\"number\">123</span>  </span><br><span class=\"line\"> enumerable: <span class=\"literal\">true</span>  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>“book”은 프로퍼티 이름입니다. 프로퍼티 이름 이외에<br>{value: 123, enumerable: true}가 프로퍼티 디스크립터입니다.<br>프로퍼티 디스크립터는 속성 이름(enumerable)과 속성 값(true)으로 구성됩니다.</p>\n<p>프로퍼티 디스크립터는 데이터 프로퍼티 디스크립터 타입과 엑세스(access) 디스크립터 타입으로 분류됩니다.</p>\n<h3 id=\"프로퍼티-디스크립터\"><a href=\"#프로퍼티-디스크립터\" class=\"headerlink\" title=\"프로퍼티 디스크립터\"></a>프로퍼티 디스크립터</h3><table>\n<thead>\n<tr>\n<th>타입</th>\n<th>속성 이름</th>\n<th>속성 값 형태</th>\n<th>디폴트 값</th>\n<th>개요</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>데이터</td>\n<td>value</td>\n<td>Javascript 데이터 타입</td>\n<td>undefined</td>\n<td>프로퍼티 값으로 사용</td>\n</tr>\n<tr>\n<td></td>\n<td>writable</td>\n<td>true, false</td>\n<td>false</td>\n<td>false: 속성 값 변경 불가</td>\n</tr>\n<tr>\n<td>엑세스</td>\n<td>get</td>\n<td>function, undefined</td>\n<td>undefined</td>\n<td>프로퍼티 getter 함수</td>\n</tr>\n<tr>\n<td></td>\n<td>set</td>\n<td>function, undefined</td>\n<td>undefined</td>\n<td>프로퍼티 setter 함수</td>\n</tr>\n<tr>\n<td>공용</td>\n<td>enumerable</td>\n<td>true, false</td>\n<td>false</td>\n<td>false: for-in으로 열거 불가</td>\n</tr>\n<tr>\n<td></td>\n<td>configurable</td>\n<td>true, false</td>\n<td>false</td>\n<td>false: 프로퍼티 삭제 불가</td>\n</tr>\n</tbody></table>\n<p>데이터 타입 속성과 엑세스 타입 속성을 같이 작성할 수 없습니다.<br>“{value:1, get: function(){}}” 형태과 같이 value 속성과 get 속성을 같이 작성하면 에러가 발생합니다.</p>\n<p>스펙에서 {writable: true} 형태를 [[writable]]:true로 기술하고 있습니다.<br>enumerable,configurable도 같습니다.<br>위와 같이 대괄호 두 개 [[]] 사이에 속성 이름을 작성합니다.</p>\n<hr>\n<h2 id=\"Object_get_set\">get, set 속성</h2>\n\n<p>get 속성은 getter 기능을 제공하고 set 속성은 setter 기능을 제공합니다.</p>\n<p><strong>아래는 ES5 에서의 사용 형태 입니다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>ES5 get</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">\"book\"</span>, &#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"keyword\">get</span>: function()&#123;  </span><br><span class=\"line\"> <span class=\"number\">4.</span> <span class=\"keyword\">return</span> <span class=\"string\">\"책\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(obj.book); <span class=\"comment\">// 책</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>엔진이 코드를 해석하면</li>\n</ol>\n<ol start=\"2\">\n<li>obj 오브젝트에서 book 프로퍼티 작성 여부를 체크합니다.<br>book 프로퍼티가 작성되어 있으면 get 속성의 존재 여부를 체크합니다.</li>\n</ol>\n<ol start=\"3\">\n<li>존재한다면 get 속성 값인 함수를 실행합니다. <code>이것이 getter 입니다.</code></li>\n</ol>\n<ol start=\"4\">\n<li>getter가 호출되어 호출된 값 “책”이 반환됩니다.</li>\n</ol>\n<p><strong>getter는 obj.book()과 같이 함수를 호출하는 형태로 작성하지 않고</strong><br><strong>obj.book과 같이 함수 이름만 작성합니다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>ES5 set</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">\"item\"</span>, &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">set</span>: function(param)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.sports = param;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">obj.item = <span class=\"string\">\"야구\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.sports); <span class=\"comment\">// 야구</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>obj 오브젝트에서 item 프로퍼티 작성 여부를 체크합니다.</li>\n</ol>\n<ol start=\"2\">\n<li>작성되어 있으면 set 속성의 존재 여부를 체크합니다. 존재 하면 set 속성 값인 함수를 실행합니다.</li>\n</ol>\n<ol start=\"3\">\n<li>이때 “야구” 값 을 실행하는 함수의 파라미터 값으로 넘겨줍니다.<br><code>이것이 setter 입니다.</code></li>\n</ol>\n<p>setter가 호출되면 this.sports에서 this가 obj 오브젝트를 참조합니다.<br>파라미터로 넘겨받은 “야구”를 obj 오브젝트의 sports 프로퍼티에 할당합니다.</p>\n<p>(obj.sports) 형태는 getter입니다. 하지만 obj 오브젝트에 get 속성을 작성하지 않았습니다. 디폴트로 getter가 호출되어 obj 오브젝트의 sports 프로퍼티 값을 반환 합니다.</p>\n<hr>\n<p><strong>ES6에서는 보다 직관적으로 getter와 setter를 정의할 수 있습니다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>ES6 getter</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;  </span><br><span class=\"line\"> value: <span class=\"number\">123</span>,  </span><br><span class=\"line\"> <span class=\"keyword\">get</span> getValue()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getValue);  </span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>ES6에서 getter는 함수(메서드) 이름 앞에 명시적으로 “get”을 작성합니다.</strong></p>\n<ol>\n<li>(obj.getValue)와 같이 함수 이름을 작성합니다.</li>\n</ol>\n<ol start=\"2\">\n<li>getter getValue가 함수로 호출 됩니다.</li>\n</ol>\n<ol start=\"3\">\n<li>this는 obj.getValue의 obj 오브젝트를 참조 합니다.</li>\n</ol>\n<ol start=\"4\">\n<li>obj 오브젝트에 value 프로퍼티가 있으므로 값을 반환 합니다.</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>ES6 setter</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">set</span> setValue(value)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.value = value;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">obj.setValue = <span class=\"number\">123</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.value);  </span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n\n<p>setter 또한 ES6에서 함수(메서드) 이름 앞에 명시적으로 “set”을 작성합니다.</p>\n<ol>\n<li>(obj.setValue = 123)과 같이 obj 오브젝트의 setValue를 프로퍼티 키로 하여<br>값을 할당하는 형태로 작성합니다.</li>\n</ol>\n<ol start=\"2\">\n<li>setValue가 setter이므로 함수로 호출되고 123을 파라미터 값으로 넘겨줍니다.</li>\n</ol>\n<ol start=\"3\">\n<li>this는 obj.setValue의 obj 오브젝트를 참조합니다.</li>\n</ol>\n<hr>\n<h2 id=\"Object_is\">is(): 값과 값 타입 비교</h2>\n\n<p>Object.is() 메서드는 두 개의 파라미터 값과 값 타입을 비교하여 같으면 true, 다르면 false를 반환 합니다.</p>\n<p>값과 값 타입을 비교하는 것이지 오브젝트를 비교하는 것이 아닙니다.</p>\n<p>배열[]과 배열[] 비교, 오브젝트{}와 오브젝트{} 비교는 false가 반환됩니다.<br>단, window 오브젝트를 비교하면 true를 반환합니다.</p>\n<p>값을 비교하는 방법마다 차이가 있습니다.</p>\n<blockquote>\n<ol>\n<li>===<br>값과 값 타입을 모두 비교합니다.</li>\n<li>==<br>타입은 비교하지 않고 값만 비교합니다.</li>\n<li>Object.is()<br>값과 값 타입을 모두 비교합니다.</li>\n</ol>\n</blockquote>\n<h3 id=\"Object-is-와-의-차이\"><a href=\"#Object-is-와-의-차이\" class=\"headerlink\" title=\"Object.is() 와 === 의 차이\"></a>Object.is() 와 === 의 차이</h3><p>Object.is()와 ===는 값과 값 타입을 비교하는 점은 같습니다.</p>\n<p>차이점.</p>\n<blockquote>\n<ul>\n<li>+0 과 -0을 비교하면<ul>\n<li>Object.is()는 false</li>\n<li>===는 true를 반환합니다.</li>\n</ul>\n</li>\n<li>NaN 과 NaN을 비교하면<ul>\n<li>Object.is()는 true를 반환하고</li>\n<li>===는 false를 반환합니다.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight js\"><figcaption><span>정리</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"number\">1</span>, <span class=\"string\">\"1\"</span>));  </span><br><span class=\"line\"><span class=\"comment\">//false  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>), <span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span>);  </span><br><span class=\"line\"><span class=\"comment\">// true false  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"number\">0</span>, <span class=\"number\">-0</span>), <span class=\"number\">0</span> === <span class=\"number\">-0</span>);  </span><br><span class=\"line\"><span class=\"comment\">// false true  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"number\">-0</span>, <span class=\"number\">0</span>), <span class=\"number\">-0</span> === <span class=\"number\">0</span>);  </span><br><span class=\"line\"><span class=\"comment\">// false true  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"number\">-0</span>, <span class=\"number\">-0</span>), <span class=\"number\">-0</span> === <span class=\"number\">-0</span>);  </span><br><span class=\"line\"><span class=\"comment\">// true true  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"6:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, <span class=\"number\">0</span>/<span class=\"number\">0</span>), <span class=\"literal\">NaN</span> === <span class=\"number\">0</span>/<span class=\"number\">0</span>);  </span><br><span class=\"line\"><span class=\"comment\">// true flase  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"7:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>), <span class=\"literal\">null</span> === <span class=\"literal\">null</span>);  </span><br><span class=\"line\"><span class=\"comment\">// true true  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"8:\"</span>, <span class=\"built_in\">Object</span>.is(<span class=\"literal\">undefined</span>, <span class=\"literal\">null</span>), <span class=\"literal\">undefined</span> === <span class=\"literal\">null</span>);  </span><br><span class=\"line\"><span class=\"comment\">// false false</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Object_assign\">assign(): 오브젝트 프로퍼티 복사</h2>\n\n<p>Object.assign() 메소드는 열거할 수 있는 하나 이상의 출처 객체로부터<br>대상 객체로 속성을 복사할 때 사용합니다. 대상 객체를 반환합니다.</p>\n<blockquote>\n<p>Object.assign(target, …sources)</p>\n</blockquote>\n<ul>\n<li><p>형태 : Object.assign()</p>\n</li>\n<li><p>target : 열거 가능한 오브젝트 지정</p>\n</li>\n<li><p>sources : 열거 가능한 오브젝트, 다수 지정 가능, sources 지정안할 시 target 오브젝트 반환</p>\n</li>\n</ul>\n<p>두 번째 파라미터의 오브젝트에서 own 프로퍼티만 복사합니다.<br>prototype과 프로퍼티 디스크럽터는 복사하지 않습니다.</p>\n<p><code>own 프로퍼티: 오브젝트 자체에서 작성한 프로퍼티를 나타내며 상속받은 프로퍼티는 포함되지 않습니다.</code></p>\n<figure class=\"highlight js\"><figcaption><span>첫 번째 파라미터 null값</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> obj = <span class=\"built_in\">Object</span>.assign(<span class=\"literal\">null</span>, &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;);  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"null 지정 불가\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.assign(<span class=\"number\">123</span>));  </span><br><span class=\"line\"><span class=\"comment\">// Number &#123;[[PrimitiveValue]]: 123&#125;  </span></span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.assign(<span class=\"number\">456</span>, <span class=\"number\">70</span>));  </span><br><span class=\"line\"><span class=\"comment\">// Number &#123;[[PrimitiveValue]]: 456&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Object.assign()의 첫 번째 파라미터를 지정하지 않거나 null 또는 undefined로 지정하면 TypeError가 발생합니다.<br>null로 지정했으므로 catch(e)가 실행되어 “null 지정 불가”가 출력됩니다.</p>\n</li>\n<li><p><strong>Object.assign()의 첫 번째 파라미터에 Number, Boolean,<br>String, Symbol 값을 지정하면 값 타입의 오브젝트를 생성</strong>하고<br>파라미터 값을 생성한 오브젝트의 [[PrimitiveValue]]에 설정합니다.<br>첫 번째 파라미터가 123 Number 오브젝트 이므로 Number 오브젝트를 생성하고<br>[[PrimitiveValue]]에 123을 설정합니다. 마지막으로 생성한 오브젝트를 반환 합니다.</p>\n</li>\n<li><p>첫 번째, 두 번째 파라미터 모두 열거 가능한 오브젝트가 아닙니다.<br>첫 번째 오브젝트는 Number 오브젝트 이므로 2번과 같은 방식으로 설정되고 반환됩니다.<br>하지만 두 번째 오브젝트는 복사되지 않고 반환됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.assign(<span class=\"string\">\"ABC\"</span>, &#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>&#125;));  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">String  </span></span><br><span class=\"line\"><span class=\"comment\">0: \"A\"  </span></span><br><span class=\"line\"><span class=\"comment\">1: \"B\"  </span></span><br><span class=\"line\"><span class=\"comment\">2: \"C\"  </span></span><br><span class=\"line\"><span class=\"comment\">one: 1  </span></span><br><span class=\"line\"><span class=\"comment\">length: 3  </span></span><br><span class=\"line\"><span class=\"comment\">&amp;#95;&amp;#95;proto&amp;#95;&amp;#95;: String  </span></span><br><span class=\"line\"><span class=\"comment\">[[PrimitiveValue]]: \"ABC\"  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.assign(<span class=\"built_in\">Symbol</span>(<span class=\"string\">\"ABC\"</span>), &#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>&#125;));  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Symbol  </span></span><br><span class=\"line\"><span class=\"comment\">description: (...)  </span></span><br><span class=\"line\"><span class=\"comment\">one: 1  </span></span><br><span class=\"line\"><span class=\"comment\">&amp;#95;&amp;#95;proto&amp;#95;&amp;#95;: Symbol  </span></span><br><span class=\"line\"><span class=\"comment\">[[PrimitiveValue]]: Symbol(ABC)  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> obj = <span class=\"built_in\">Object</span>.assign(<span class=\"string\">\"ABC\"</span>, <span class=\"string\">\"ONE\"</span>);  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"파라미터 모두 문자열 사용 불가\"</span>)  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Object.assign() 첫 번째 파라미터가 String 오브젝트 입니다.<br>String 오브젝트를 생성하고 [[PrimitiveValue]]에 “ABC”가 설정되고<br>String 오브젝트는 이터러블 오브젝트 이기 때문에 {one:1}을 복사하고 생성한 오브젝트를 반환합니다.</p>\n</li>\n<li><p>Object.assign() 첫 번째 파라미터가 Symbol 이므로 Symbol 오브젝트를 생성합니다.<br>[[PrimitiveValue]]에 Symbol(“ABC”)를 설정합니다.<br>생성된 Symbol 오브젝트에 {one:1}을 복사합니다.</p>\n</li>\n<li><p>Object.assign()의 파라미터가 모두 문자열이므로 TypeError가 발생합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>파라미터 값으로 undefined, null 작성시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> oneObj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">Object</span>.assign(oneObj, <span class=\"string\">\"ABC\"</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">null</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(oneObj);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Object  </span></span><br><span class=\"line\"><span class=\"comment\">0: \"A\"  </span></span><br><span class=\"line\"><span class=\"comment\">1: \"B\"  </span></span><br><span class=\"line\"><span class=\"comment\">2: \"C\"  </span></span><br><span class=\"line\"><span class=\"comment\">&amp;#95;&amp;#95;proto&amp;#95;&amp;#95;: Object  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"><span class=\"keyword\">let</span> twoObj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">Object</span>.assign(twoObj, &#123;<span class=\"attr\">key1</span>: <span class=\"literal\">undefined</span>, <span class=\"attr\">key2</span>: <span class=\"literal\">null</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(twoObj);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Object  </span></span><br><span class=\"line\"><span class=\"comment\">key1: undefined  </span></span><br><span class=\"line\"><span class=\"comment\">key2: null  </span></span><br><span class=\"line\"><span class=\"comment\">&amp;#95;&amp;#95;proto&amp;#95;&amp;#95;: Object  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Object.assign() 파라미터에 undefined, null을 작성하면 복사되지 않습니다.</li>\n</ol>\n<ol start=\"2\">\n<li>Object.assign() 파라미터에 오브젝트로 작성하고 오브젝트에 프로퍼티 값으로<br>undefined 와 null을 작성하면 복사됩니다.</li>\n</ol>\n<p><code>undefined, null를 오브젝트 프로퍼티 값으로 작성시 복사 가능하지만, 파라미터에 값으로 작성하면 복사되지 않습니다.</code></p>\n<hr>\n<h2 id=\"Object_assign_necessity\">assign() 필요성</h2>\n\n<p>일반적으로 Object 오브젝트를 변수에 할당하면 프로퍼티가 연동되어<br>한 쪽의 프로퍼티 값을 바꾸면 다른 한 쪽의 프로퍼티 값이 자동으로 바뀝니다.</p>\n<figure class=\"highlight js\"><figcaption><span>일반적인 오브젝트 프로퍼티 연동 예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = &#123;  </span><br><span class=\"line\"> event: <span class=\"string\">\"축구\"</span>,  </span><br><span class=\"line\"> player: <span class=\"number\">11</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> dup = sports;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> sports.player = <span class=\"number\">55</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dup.player);  </span><br><span class=\"line\"><span class=\"comment\">// 55  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> dup.event = <span class=\"string\">\"농구\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sports.event);  </span><br><span class=\"line\"><span class=\"comment\">// \"농구\"</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>sports 오브젝트를 dup 변수에 할당하면 dup 변수의 오브젝트와 sports 오브젝트의 프로퍼티가 연동됩니다.</li>\n</ol>\n<blockquote>\n<p>console.log(dup);<br>{event: “농구”, player: 55}</p>\n<ul>\n<li>event: “농구”</li>\n<li>player: 55</li>\n<li>&#95;&#95;proto&#95;&#95;: Object</li>\n</ul>\n</blockquote>\n<p>즉, 한 쪽 오브젝트 프로퍼티 값을 바꾸면 다른 쪽의 프로퍼티 값이 자동으로 변경됩니다.</p>\n<ol start=\"2\">\n<li>sports 오브젝트의 player 프로퍼티에 55를 할당 합니다.<br>dup 오브젝트의 player 프로퍼티 값이 55로 변경됩니다.<br>sports 오브젝트는 원본이고 dup 오브젝트가 복사본입니다.</li>\n</ol>\n<ol start=\"3\">\n<li>복사본 dup 오브젝트의 event 프로퍼티에 값을 할당하면<br>원본 sports 오브젝트의 event 프로퍼티 값이 자동으로 변경됩니다.</li>\n</ol>\n<h3 id=\"값을-연동하여-사용하고-싶지-않은-경우\"><a href=\"#값을-연동하여-사용하고-싶지-않은-경우\" class=\"headerlink\" title=\"값을 연동하여 사용하고 싶지 않은 경우\"></a>값을 연동하여 사용하고 싶지 않은 경우</h3><p>Object.assign()으로 복사하여 사용하면 프로퍼티 값이 연동되지 않습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>Object.assign() 사용 복사</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = &#123;  </span><br><span class=\"line\"> event: <span class=\"string\">\"축구\"</span>,  </span><br><span class=\"line\"> player: <span class=\"number\">11</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> dup = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, sports);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dup.player);  </span><br><span class=\"line\"><span class=\"comment\">// 11  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> dup.player = <span class=\"number\">33</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dup.player,sports.player);  </span><br><span class=\"line\"><span class=\"comment\">// 33 11  </span></span><br><span class=\"line\"><span class=\"number\">3.</span> sports.event = <span class=\"string\">\"수영\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dup.event,sports.event);  </span><br><span class=\"line\"><span class=\"comment\">// 축구 수영</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Object.assign() 두 번째 프로퍼티에 지정한 sports 오브젝트의 프로퍼티를<br>첫 번째 파라미터에 지정한 빈 오브젝트{}에 복사합니다.<br>그리고 첫 번째 파라미터의 오브젝트를 반환하여 dup 변수에 할당합니다.</li>\n</ol>\n<ol start=\"2\">\n<li>dup 오브젝트의 player 프로퍼티에 33을 할당합니다.<br>sports 오브젝트의 player 프로퍼티 값은 연동되지 않습니다.</li>\n</ol>\n<ol start=\"3\">\n<li>sports 오브젝트의 event 프로퍼티에 “수영”을 할당합니다.<br>dup 오브젝트의 프로퍼티 값은 연동되지 않습니다.</li>\n</ol>\n<hr>\n<h2 id=\"Object_assign_consider\">assign() 고려사항</h2>\n\n<p>Object.assign()은 복사한 값이 연동되지 않아 좋지만 고려할 점도 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> oneObj = &#123;<span class=\"attr\">one</span>: <span class=\"number\">1</span>&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> twoObj = &#123;<span class=\"attr\">two</span>: <span class=\"number\">2</span>&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> mergeObj = <span class=\"built_in\">Object</span>.assign(oneObj, twoObj);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(oneObj, mergeObj));  </span><br><span class=\"line\"><span class=\"comment\">//true  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> mergeObj.one = <span class=\"number\">456</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(oneObj, mergeObj));  </span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>twoObj의 프로퍼티를 oneObj에 복사하고 mergeObj에 할당합니다.<br>oneObj 와 mergeObj의 프로퍼티가 같으므로 ture가 출력됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li>Object.assign()으로 복사한 첫 번째 파라미터(oneObj)와 두 번째 파라미터(twoObj)의 프로퍼티는 연동되지 않지만,</li>\n</ol>\n<p><strong>첫 번째 파라미터 오브젝트(oneObj)를 할당한 오브젝트(mergeObj)는 연동됩니다.</strong></p>\n<hr>\n<h2 id=\"Object_assign_getter\">assign() getter</h2>\n\n<p>오브젝트의 프로퍼티를 복사할 때 프로퍼티가 getter이면<br><u>함수를 복사하지 않고 함수를 호출하여 반환된 값을 복사합니다.</u><br>return문을 작성하지 않으면 undefined를 반환합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> count = &#123;  </span><br><span class=\"line\"> current: <span class=\"number\">1</span>,  </span><br><span class=\"line\"> <span class=\"keyword\">get</span> getCount() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> ++<span class=\"keyword\">this</span>.current;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> mergeObj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">Object</span>.assign(mergeObj, count);  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(mergeObj);  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;current: 1, getCount: 2&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>두 번째 파라미터 count 오브젝트에 작성된 순서로 복사합니다.<br>count 오브젝트의 current 프로퍼티를 복사 하고 그 값은 1입니다.<br>다음 getCount()함수를 복사하는 대신 함수를 호출하고 반환된 값을 복사합니다.<br>함수에서 this.current에 1을 더하므로 프로퍼티 값은 2가 되고 2를 반환합니다.</p>\n</li>\n<li><p>count 오브젝트의 current 프로퍼티를 복사하는 시점의 값은 1입니다.<br>그 후에 getCount() 함수를 호출하면서 1을 더하지만<br>원본 프로퍼티 값이 변경되더라도 복사된 mergeObj의 프로퍼티 값은 연동되지 않으므로 current 값은 1입니다.<br>getCount는 함수가 호출되고 반환된 값인 2가 mergeObj의 복사되어 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Object_setPrototypeOf\">setPrototypeOf(): &#95;&#95;proto&#95;&#95;에 첨부</h2>\n\n<p>Object.setPrototypeOf() 메소드는 지정된 객체의 프로토타입 (즉, 내부 [[Prototype]] 프로퍼티)을 다른 객체 또는 null 로 설정합니다<br>첫 번째 파라미터의 &#95;&#95;proto&#95;&#95;에 두 번째 파라미터를 첨부합니다.</p>\n<blockquote>\n<p>Object.setPrototypeOf(obj, prototype);</p>\n</blockquote>\n<ul>\n<li><p>obj<br>오브젝트 또는 인스턴스 (프로토타입 설정을 가지는 오브젝트)<br>오브젝트에 프로퍼티를 추가 할 수 없는 오브젝트이면 TypeError 발생</p>\n</li>\n<li><p>prototype<br>객체의 새로운 프로토 타입 (오브젝트 or null).</p>\n</li>\n</ul>\n<p style=\"color: red;\">경고</p>\n\n<p>오브젝트의 [Prototype]을 변경하는 것은 모든 브라우저와 JavaScript 엔진에서<br>단순히 obj.&#95;&#95;proto&#95;&#95; = … 문에 소요 된 시간으로 제한되지 않고<br>변경된 [Prototype]에 접근할 수 있는 모든 코드로 확장될 수 있습니다.<br>성능에 신경을 쓰면 [[Prototype]] 설정을 피해야 합니다.<br>[[Prototype]]을 변경하는 대신 Object.create()를 사용하여 원하는 [[Prototype]]으로 새 오브젝트를 만듭니다.</p>\n<figure class=\"highlight js\"><figcaption><span>setPrototypeOf() 예제1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\">Sports.prototype.getCount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"number\">123</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> protoObj = <span class=\"built_in\">Object</span>.setPrototypeOf(&#123;&#125;, Sports.prototype);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(protoObj.getCount());  </span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>setPrototypeOf()의 두 번째 파라미터인 Sports.prototype에 연결된 프로퍼티를 첫 번째 파라미터인 빈 오브젝트{}의 &#95;&#95;proto&#95;&#95;에 첨부합니다.</li>\n</ol>\n<blockquote>\n<ul>\n<li>protoObj: Sports<ul>\n<li>&#95;&#95;proto&#95;&#95;: Object ①<ul>\n<li>getCount: ƒ ()</li>\n<li>constructor: ƒ ()</li>\n<li>&#95;&#95;proto&#95;&#95;: Object</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>protoObj에 &#95;&#95;proto&#95;&#95;가 연결되어 있으며 여기에<br>Sports.prototype의 constructor 와 getCount가 연결되어 있습니다.</li>\n</ul>\n<ol start=\"2\">\n<li>protoObj의 &#95;&#95;proto&#95;&#95;에 getCount가 있으므로<br>protoObj.getCount() 형태로 호출할 수 있습니다.</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>setPrototypeOf() 예제2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\">Sports.prototype.getCount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"number\">123</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> fnObj = <span class=\"built_in\">Object</span>.setPrototypeOf(&#123;&#125;, Sports);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(fnObj.getCount);  </span><br><span class=\"line\"><span class=\"comment\">// undefined  </span></span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(fnObj.prototype.getCount.call(Sports));  </span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>예제1에서는 Object.setPrototypeOf()의 두 번째 파라미터를<br>Sports.prototype를 지정 했습니다. 예제 2에서는 Sports 함수를 지정합니다.<br>Sports 함수를 첫 번째 파라미터 오브젝트의 &#95;&#95;proto&#95;&#95;에 첨부하여 반환합니다.</p>\n</li>\n<li><p>fnObj.getCount를 실행하면 Sports.prototype에 연결된 getCount가 반환되지 않고 undefined가 반환됩니다. 이는 fnObj 또는 fnObj.&#95;&#95;proto&#95;&#95;에 getCount가 없다는 의미입니다.<br>setPrototypeOf() 두 번째 파라미터에 Sports.prototype이 아닌 Sports를 지정하면 Sports.prototype에 연결된 메서드를 직접 호출할 수 없습니다.</p>\n</li>\n<li><p>이와 같이 경로를 지정해 호출해줘야 합니다.<br>fnObj.&#95;&#95;proto&#95;&#95;.prototype.getCount()가 전체 경로이지만,<br>&#95;&#95;proto&#95;&#95;는 작성하지 않아도 되므로<br>fnObj.prototype.getCount.call(Sports)형태로 작성하면<br>getCount()를 호출할 수 있습니다.    </p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Object_proto\">&#95;&#95;proto&#95;&#95;</h2>\n\n<ul>\n<li><p>new 연산자로 생성된 인스턴스 또는<br>다른 오브젝트의 prototype에 연결된 프로퍼티가<br>&#95;&#95;proto&#95;&#95;에 첨부됩니다.</p>\n</li>\n<li><p>&#95;&#95;proto&#95;&#95;는 엑세스 프로퍼티 입니다.<br>즉, getter와 setter 기능이 있습니다.</p>\n</li>\n<li><p>&#95;&#95;proto&#95;&#95;는 [[Enumerable]]: false이고<br>[[Configurable]]: true 입니다.</p>\n</li>\n</ul>\n<ol>\n<li><p>인스턴스를 생성하면 오브젝트의 prototype에 연결된 프로퍼티가<br>인스턴스의 &#95;&#95;proto&#95;&#95;에 첨부됩니다.</p>\n</li>\n<li><p>이 환경이 만들어지면 prototype에 연결된 메서드를 인스턴스 메서드로 호출할 수 있습니다.</p>\n</li>\n</ol>\n<ul>\n<li>브라우저 개발자 도구에서 &#95;&#95;proto&#95;&#95;에 첨부되는 것처럼 표시되는 것은 개발자가 인식 하기 쉽도록 하기 위한 것으로 실제로는<br>원본 오브젝트의 prototype에 연결된 프로퍼티를 참조합니다.<br>이것을 prototype 공유(share)라고 합니다.  <p style=\"color: yellow\">첨부라는 말은 기능의 표면적 이해를 돕기 위한 것일뿐 실제로 prototype에 프로퍼티를 복사하는 것은 아닙니다. 참조 혹은 prototype 공유가 맞습니다.<p>\n\n</li>\n</ul>\n<hr>\n<h2>prototype과 &#95;&#95;proto&#95;&#95; 차이<h2>\n\n<p>&#95;&#95;proto&#95;&#95;에 있는 메서드는 object.name() 형태로 직접 호출할 수 있지만 prototype에 연결된 메서드는 object.prototype.name.call() 형태로 호출해야 합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> Sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\">Sports.prototype.get = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> sportsObj = <span class=\"keyword\">new</span> Sports();  </span><br><span class=\"line\">  </span><br><span class=\"line\">2. sportsObj.&amp;#95;&amp;#95;proto&amp;#95;&amp;#95;[\"set\"] = function()&#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> sportsObj.set();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"keyword\">let</span> result = Sports.prototype.set;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\"><span class=\"comment\">// function() &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Sports.prototype에 get 메서드를 연결하고 new 연산자로 인스턴스를 생성하여<br>sportsObj에 할당합니다. sportsObj.&#95;&#95;proto&#95;&#95;에 get()메서드가 첨부됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li>생성한 sportsObj 인스턴스의 &#95;&#95;proto&#95;&#95;에 set() 메서드를 추가합니다. 이때 &#95;&#95;proto&#95;&#95;에 추가하더라도 &#95;&#95;proto&#95;&#95;에 추가되지 않고 Sports.prototype에 추가됩니다.<br>왜냐하면 set()메서드를 Sports로 생성한 다른 인스턴스에서 공유하기 때문입니다.</li>\n</ol>\n<ol start=\"3\">\n<li>set() 메서드가 호출되면 인스턴스의 &#95;&#95;proto&#95;&#95;에 있지만,<br>&#95;&#95;proto&#95;&#95;은 프로퍼티 검색과 경로 제공을 위한 것으로,<br>실제로 호출되는 메서드는 인스턴스를 생성한 Sports.prototype에 연결된 메서드입니다.<br>이것이 prototype의 프로퍼티 공유 개념이며 자바스크립트의 아키텍처입니다.</li>\n</ol>\n<ol start=\"4\">\n<li>sportsObj의 &#95;&#95;proto&#95;&#95;에 set()메서드를 추가했는데,<br>Sports.prototype.set으로 코드가 출력된 것은 실제로 Sports.prototype에 추가되기 때문입니다.</li>\n</ol>"},{"title":"RegExp (정규표현) 객체 -JavaScript","date":"2020-03-03T00:15:28.000Z","disqusId":"tunas-blog-1","_content":"\n정규표현 객체는 입력요소에 데이터를 규칙에 맞게 작성했는지 판단해서\n\n알려주는 객체 입니다.\n\n**지정한 규칙대로 단어가 입력됬는지,**\n\n**잘못된 단어를 포함하고 있는지 찾을때 사용합니다**\n\n    기본형 두가지\n    \n        var 변수 = new RegExp(패턴, 검색옵션)\n        생성자 함수를 사용하면 정규식이 실행 시점에 컴파일됩니다. \n        정규식의 패턴이 변경될 수 있는 경우, \n        혹은 사용자 입력과 같이 다른 출처로부터 패턴을 가져와야 하는\n        경우에는 생성자 함수를 사용합니다.\n    \n        var 변수 = /패턴/검색 옵션\n        정규식 리터럴(슬래쉬로 감싸는 패턴)은 \n        스크립트가 불러와질 때 컴파일됩니다. \n        만약 정규식이 상수라면, 이렇게 사용하는 것이 성능을 향상시킬 수 있습니다.   \n\n<!-- more -->\n\n* * *\n\n#### 정규 표현 검색 옵션\n\n\n| 종류                  | 설명                                                                                                                                                                                                                                                                        |\n|-----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| \\*                    | 앞의 표현식이 **0회 이상 연속으로 반복되는 부분과 대응됩니다.** {0,} 와 같은 의미입니다.                                                                                                                                                                                    |\n| +                     | 앞의 표현식이 **1회 이상 연속으로 반복되는 부분과 대응됩니다.** {1,} 와 같은 의미입니다.                                                                                                                                                                                    |\n| i                     | 찾는 문자가 영문일 경우 **대·소문자를 구분하지 않습니다**                                                                                                                                                                                                                   |\n| ?                     | 앞의 표현식이 **0 또는 1회 등장하는 부분과 대응됩니다.** {0,1} 와 같은 의미입니다.                                                                                                                                                                                          |\n| .                     | **개행 문자를 제외한 모든 단일 문자와 대응됩니다.**예를 들어, /.n/는 “nay, an apple is on the tree”에서 ‘an’과 ‘on’에 대응되지만, ‘nay’ 에는 대응되지 않습니다.                                                                                                             |\n| g                     | 옵션에 g가 없으면 데이터의 왼쪽부터 규칙에 일치하는 문자 한 개만 찾지만,**g를 넣으면 규칙에 맞는 모든 문자를 찾습니다**.                                                                                                                                                    |\n| m                     | **데이터의 행이 바뀌어도** 규칙에 맞는 문자를 찾습니다.(다중행 검색)                                                                                                                                                                                                        |\n| $                     | **문자열 끝부분에** 규칙에 맞는 문자를 찾습니다.                                                                                                                                                                                                                            |\n| ^                     | **문자열 앞에서부터 규칙에 일치하는 문제를 찾습니다.**                                                                                                                                                                                                                      |\n| \\[xyz\\]               | 문자셋(Character set) 입니다.**괄호 안의 어떤 문자(이스케이프 시퀀스까지 포함)와도 대응됩니다. 점(.) 이나 별표 (\\*) 같은 특수 문자는 문자셋 내부에서는 특수 문자가 아닙니다. 따라서 이스케이프시킬 필요가 없습니다.** 하이픈을 이용하여 문자의 범위를 지정해줄 수 있습니다. |\n| \\[^xyz\\]              | 부정 문자셋(negated character set)입니다. **괄호 내부에 등장하지 않는 어떤 문자와도 대응됩니다. 하이픈을 이용하여 문자의 범위를 지정할 수 있습니다.**                                                                                                                       |\n| \\\\d                   | **숫자 문자에 대응됩니다.** \\[0-9\\]와 동일합니다.                                                                                                                                                                                                                           |\n| \\\\D                   | **숫자 문자가 아닌 문자에 대응됩니다.** \\[^0-9\\]와 동일합니다.                                                                                                                                                                                                              |\n| \\\\s                   | **페이스, 탭, 폼피드, 줄 바꿈 문자등을 포함한 하나의 공백 문자**에 대응됩니다. \\[ \\\\f\\\\n\\\\r\\\\t\\\\v\\\\u00a0\\\\u1680\\\\u2000-\\\\u200a\\\\u2028\\\\u2029\\\\u202f\\\\u205f\\\\u3000\\\\ufeff\\].와 동일합니다. 예를 들어, /\\\\S\\\\w\\*/는 “foo bar.”의 ‘bar’ 에 대응됩니다.                         |\n| \\\\S                   | **공백 문자가 아닌 하나의 문자에 대응됩니다.** \\[^ \\\\f\\\\n\\\\r\\\\t\\\\v\\\\u00a0\\\\u1680\\\\u2000-\\\\u200a\\\\u2028\\\\u2029\\\\u202f\\\\u205f\\\\u3000\\\\ufeff\\]. 와 동일합니다. 예를 들어, /\\\\S\\\\w\\*/는 “foo bar.”의 ‘foo’ 에 대응됩니다.                                                       |\n| \\[0-9\\]\\[A-Z\\]\\[a-z\\] | **숫자, 대문자 영문, 소문자 영문을 찾습니다.**                                                                                                                                                                                                                              |\n| \\\\w                   | 문자의 앞 또는 뒤에 공백 문자열을 삭제합니다.                                                                                                                                                                                                                               |\n| \\\\W                   | **알파벳, 숫자, 밑줄(\\_) 기호를 제외한 문자를 찾습니다.** \\[^A-Za-z0-9\\_\\] 와 동일합니다.                                                                                                                                                                                   |\n| (x)                   | **‘x’에 대응되고, 그것을 기억합니다.** 괄호는 포획 괄호(capturing parentheses)라 불립니다.                                                                                                                                                                                  |\n| (?:x)                 | **‘x’에 대응되지만 대응된 것을 기억하지 않습니다.** 괄호는 비포획 괄호(non-capturing parentheses)라고 불립니다.                                                                                                                                                             |\n| x(?=y)                | **오직 ‘y’가 뒤따라오는 ‘x’에만 대응됩니다.** 이것은 lookahead 라고 불립니다.예를 들어, /Jack(?=Sprat)/ 는 ‘Sprat’가 뒤따라오는 ‘Jack’ 에만 대응됩니다. /Jack(?=Sprat                                                                                                       |\n| x(?!y)                | **‘x’뒤에 ‘y’가 없는경우에만 ‘x’에 일치합니다.** 이것은 negated lookahead 라고 불립니다.                                                                                                                                                                                    |\n| a|b                   | a 또는 b인지 검사할때 사용합니다.                                                                                                                                                                                                                                           |\n| {n}                   | **앞 표현식이 n번 나타나는 부분에 대응됩니다.** n은 반드시 양의 정수여야 합니다. /a{2}/는 ‘a’에는 대응되지 않지만, 첫 두”aa” 에는 대응됩니다.                                                                                                                               |\n| {n,m}                 | n과 m은 양의 정수이고, n <= m를 만족해야 합니다.**앞 문자가 최소 n개, 최대 m개가 나타나는 부분에 대응됩니다.** m이 생략된다면, m은 ∞로 취급됩니다.                                                                                                                          |\n| \\\\cX                  | 문자열 내부의 제어 문자에 대응됩니다. 여기서 X는 A에서 Z까지의 문자 중 하나입니다. 예를 들어, /\\\\cM/는 문자열에서 control-M (U+000D)에 대응됩니다.                                                                                                                          |\n| \\\\f                   | 폼피드 (U+000C) 문자에 대응됩니다.                                                                                                                                                                                                                                          |\n| \\\\n                   | 줄 바꿈 (U+000A) 문자에 대응됩니다.                                                                                                                                                                                                                                         |\n| \\\\r                   | 캐리지 리턴(U+000D) 문자에 대응됩니다.                                                                                                                                                                                                                                      |\n| \\\\t                   | 탭 (U+0009) 문자에 대응됩니다.                                                                                                                                                                                                                                              |\n| \\\\v                   | 수직 탭(U+000B) 문자에 대응됩니다.                                                                                                                                                                                                                                          |\n| \\\\n                   | **정규식 내부의 n번째 괄호에서 대응된 부분에 대한 역참조** 여기서, n은 양의 정수입니다. 예를 들어, /apple(,)\\\\sorange\\\\1/는 “apple, orange, cherry, peach.”의 ‘apple, orange,’ 에 일치합니다.                                                                               |\n| \\\\0                   | 널 (U+0000)문자에 대응합니다. 이 때 다른 숫자를 뒤에 쓰지 마세요. 왜냐하면 \\\\0는 8진 이스케이프 시퀀스이기 때문입니다.                                                                                                                                                      |\n| \\\\xhh                 | 코드가 hh(두 16진 숫자)인 문자에 일치합니다.                                                                                                                                                                                                                                |\n| \\\\uhhhh               | 코드가 hhhh(네개의 16진 숫자)인 문자에 일치합니다.                                                                                                                                                                                                                          |\n\n\n*   참고 링크 :  \n    [https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EC%A0%95%EA%B7%9C%EC%8B%9D](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EC%A0%95%EA%B7%9C%EC%8B%9D)\n\n* * *\n\n#### 정규 표현 메서드\n\n| 종류   | 설명                                                  |\n|--------|-------------------------------------------------------|\n| test() | 지정된 규칙에 맞는 단어가 있으면 **true 값을 반환**   |\n| exec() | 지정된 규칙에 맞는 단어가 있으면 **해당 단어를 반환** |\n\n사용예제\n\n```js\nvar str=\"Html Css jQuery \"; // 문자열 선언\n\n\nvar reg1=/css/;  // 검색 패턴\nvar result_1=reg1.test(str); \n//str데이터에 reg1 패턴 규칙에 맞는 단어가 있으면 true 아니면 false반환\n    document.write(result_1,\"<br />\"); //false\n  \n  \nvar reg2=/css/i; // 검색 패턴\n//옵션에 'i'를 입력하면 영문 대소문자를 구분하지 않습니다\nvar result_2=reg2.test(str);\n   document.write(result_2,\"<br />\"); //true\n```\n\n사용예제 2\n```js\n// 유저에게 이름을 입력받습니다.\nvar userName=prompt(\"당신의 이름은?\");\n// (가 부터 힣 까지, 2자 부터 5자까지)인 경우의 패턴 값을 생성했습니다.\nreg1=/^[가-힣]{2,5}$/;\n\nwhile(true){ // reg1 값이 true라면\n  if(reg1.test(userName)) break; // break(종료)\n\n  // reg1 값이 false 라면\n  alert(\"이름 입력 형식이 잘못되었습니다!\");\n  userName=prompt(\"당신의 이름은?\"); // 다시 입력받습니다.\n}\n\n// 유저에게 핸드폰 번호를 입력받습니다.\nvar userCell=prompt(\"당신의 핸드폰 번호는?\");\n// (010 or 016 or 011)로 시작, 숫자 3~4자리만 작성가능, 마지막엔 숫자4개가 작성된 경우의 패턴 값을 생성했습니다.\nreg2=/^(010|016|011)\\d{3,4}\\d{4}$/;\n\nwhile(true){ //reg2 값이 true 라면\n  if(reg2.test(userCell)) break; // break\n\n   // reg2 값이 false 라면\n   alert(\"핸드폰 입력 형식이 잘못되었습니다!\");\n   userCell=prompt(\"당신의 핸드폰 번호는?\"); // 다시 입력받습니다.\n}\n\n// 유저에게 이메일을 입력받습니다.\nvar userEmail=prompt(\"당신의 이메일은?\");\n/* 알파벳, 밑줄(_), 숫자를 포함한 5글자부터~12글자까지,\n   다음엔 '@',\n   a-z중 2글자부터 10글자까지 작성된,\n   \".\"이후에 a-z중 2~3글자 까지 작성된,\n   다음에 \".\"인 문자가 0이거나 1개가 작성된,\n   .이후에 a-z중 0개 부터 2개까지 작성된 패턴 값을 생성합니다.\n*/\nreg3=/^\\w{5,12}@[a-z]{2,10}[\\.][a-z]{2,3}[\\.]?[a-z]{0,2}$/;\n\nwhile(true){ //reg3 값이 true 라면\n  if(reg3.test(userEmail)) break; // break\n\n  //reg3 값이 false라면  \n  alert(\"이메일 입력 형식이 잘못되었습니다!\");\n  userEmail=prompt(\"당신의 이메일은?\"); //다시 입력받습니다.\n}\n// 출력\ndocument.write(userName,\"<br />\");\ndocument.write(userCell,\"<br />\");\ndocument.write(userEmail,\"<br />\"); \n```","source":"_posts/RegExp 정규표현 객체 -JavaScript.md","raw":"---\ntitle: RegExp (정규표현) 객체 -JavaScript\ndate: 2020-03-03 09:15:28\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\n정규표현 객체는 입력요소에 데이터를 규칙에 맞게 작성했는지 판단해서\n\n알려주는 객체 입니다.\n\n**지정한 규칙대로 단어가 입력됬는지,**\n\n**잘못된 단어를 포함하고 있는지 찾을때 사용합니다**\n\n    기본형 두가지\n    \n        var 변수 = new RegExp(패턴, 검색옵션)\n        생성자 함수를 사용하면 정규식이 실행 시점에 컴파일됩니다. \n        정규식의 패턴이 변경될 수 있는 경우, \n        혹은 사용자 입력과 같이 다른 출처로부터 패턴을 가져와야 하는\n        경우에는 생성자 함수를 사용합니다.\n    \n        var 변수 = /패턴/검색 옵션\n        정규식 리터럴(슬래쉬로 감싸는 패턴)은 \n        스크립트가 불러와질 때 컴파일됩니다. \n        만약 정규식이 상수라면, 이렇게 사용하는 것이 성능을 향상시킬 수 있습니다.   \n\n<!-- more -->\n\n* * *\n\n#### 정규 표현 검색 옵션\n\n\n| 종류                  | 설명                                                                                                                                                                                                                                                                        |\n|-----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| \\*                    | 앞의 표현식이 **0회 이상 연속으로 반복되는 부분과 대응됩니다.** {0,} 와 같은 의미입니다.                                                                                                                                                                                    |\n| +                     | 앞의 표현식이 **1회 이상 연속으로 반복되는 부분과 대응됩니다.** {1,} 와 같은 의미입니다.                                                                                                                                                                                    |\n| i                     | 찾는 문자가 영문일 경우 **대·소문자를 구분하지 않습니다**                                                                                                                                                                                                                   |\n| ?                     | 앞의 표현식이 **0 또는 1회 등장하는 부분과 대응됩니다.** {0,1} 와 같은 의미입니다.                                                                                                                                                                                          |\n| .                     | **개행 문자를 제외한 모든 단일 문자와 대응됩니다.**예를 들어, /.n/는 “nay, an apple is on the tree”에서 ‘an’과 ‘on’에 대응되지만, ‘nay’ 에는 대응되지 않습니다.                                                                                                             |\n| g                     | 옵션에 g가 없으면 데이터의 왼쪽부터 규칙에 일치하는 문자 한 개만 찾지만,**g를 넣으면 규칙에 맞는 모든 문자를 찾습니다**.                                                                                                                                                    |\n| m                     | **데이터의 행이 바뀌어도** 규칙에 맞는 문자를 찾습니다.(다중행 검색)                                                                                                                                                                                                        |\n| $                     | **문자열 끝부분에** 규칙에 맞는 문자를 찾습니다.                                                                                                                                                                                                                            |\n| ^                     | **문자열 앞에서부터 규칙에 일치하는 문제를 찾습니다.**                                                                                                                                                                                                                      |\n| \\[xyz\\]               | 문자셋(Character set) 입니다.**괄호 안의 어떤 문자(이스케이프 시퀀스까지 포함)와도 대응됩니다. 점(.) 이나 별표 (\\*) 같은 특수 문자는 문자셋 내부에서는 특수 문자가 아닙니다. 따라서 이스케이프시킬 필요가 없습니다.** 하이픈을 이용하여 문자의 범위를 지정해줄 수 있습니다. |\n| \\[^xyz\\]              | 부정 문자셋(negated character set)입니다. **괄호 내부에 등장하지 않는 어떤 문자와도 대응됩니다. 하이픈을 이용하여 문자의 범위를 지정할 수 있습니다.**                                                                                                                       |\n| \\\\d                   | **숫자 문자에 대응됩니다.** \\[0-9\\]와 동일합니다.                                                                                                                                                                                                                           |\n| \\\\D                   | **숫자 문자가 아닌 문자에 대응됩니다.** \\[^0-9\\]와 동일합니다.                                                                                                                                                                                                              |\n| \\\\s                   | **페이스, 탭, 폼피드, 줄 바꿈 문자등을 포함한 하나의 공백 문자**에 대응됩니다. \\[ \\\\f\\\\n\\\\r\\\\t\\\\v\\\\u00a0\\\\u1680\\\\u2000-\\\\u200a\\\\u2028\\\\u2029\\\\u202f\\\\u205f\\\\u3000\\\\ufeff\\].와 동일합니다. 예를 들어, /\\\\S\\\\w\\*/는 “foo bar.”의 ‘bar’ 에 대응됩니다.                         |\n| \\\\S                   | **공백 문자가 아닌 하나의 문자에 대응됩니다.** \\[^ \\\\f\\\\n\\\\r\\\\t\\\\v\\\\u00a0\\\\u1680\\\\u2000-\\\\u200a\\\\u2028\\\\u2029\\\\u202f\\\\u205f\\\\u3000\\\\ufeff\\]. 와 동일합니다. 예를 들어, /\\\\S\\\\w\\*/는 “foo bar.”의 ‘foo’ 에 대응됩니다.                                                       |\n| \\[0-9\\]\\[A-Z\\]\\[a-z\\] | **숫자, 대문자 영문, 소문자 영문을 찾습니다.**                                                                                                                                                                                                                              |\n| \\\\w                   | 문자의 앞 또는 뒤에 공백 문자열을 삭제합니다.                                                                                                                                                                                                                               |\n| \\\\W                   | **알파벳, 숫자, 밑줄(\\_) 기호를 제외한 문자를 찾습니다.** \\[^A-Za-z0-9\\_\\] 와 동일합니다.                                                                                                                                                                                   |\n| (x)                   | **‘x’에 대응되고, 그것을 기억합니다.** 괄호는 포획 괄호(capturing parentheses)라 불립니다.                                                                                                                                                                                  |\n| (?:x)                 | **‘x’에 대응되지만 대응된 것을 기억하지 않습니다.** 괄호는 비포획 괄호(non-capturing parentheses)라고 불립니다.                                                                                                                                                             |\n| x(?=y)                | **오직 ‘y’가 뒤따라오는 ‘x’에만 대응됩니다.** 이것은 lookahead 라고 불립니다.예를 들어, /Jack(?=Sprat)/ 는 ‘Sprat’가 뒤따라오는 ‘Jack’ 에만 대응됩니다. /Jack(?=Sprat                                                                                                       |\n| x(?!y)                | **‘x’뒤에 ‘y’가 없는경우에만 ‘x’에 일치합니다.** 이것은 negated lookahead 라고 불립니다.                                                                                                                                                                                    |\n| a|b                   | a 또는 b인지 검사할때 사용합니다.                                                                                                                                                                                                                                           |\n| {n}                   | **앞 표현식이 n번 나타나는 부분에 대응됩니다.** n은 반드시 양의 정수여야 합니다. /a{2}/는 ‘a’에는 대응되지 않지만, 첫 두”aa” 에는 대응됩니다.                                                                                                                               |\n| {n,m}                 | n과 m은 양의 정수이고, n <= m를 만족해야 합니다.**앞 문자가 최소 n개, 최대 m개가 나타나는 부분에 대응됩니다.** m이 생략된다면, m은 ∞로 취급됩니다.                                                                                                                          |\n| \\\\cX                  | 문자열 내부의 제어 문자에 대응됩니다. 여기서 X는 A에서 Z까지의 문자 중 하나입니다. 예를 들어, /\\\\cM/는 문자열에서 control-M (U+000D)에 대응됩니다.                                                                                                                          |\n| \\\\f                   | 폼피드 (U+000C) 문자에 대응됩니다.                                                                                                                                                                                                                                          |\n| \\\\n                   | 줄 바꿈 (U+000A) 문자에 대응됩니다.                                                                                                                                                                                                                                         |\n| \\\\r                   | 캐리지 리턴(U+000D) 문자에 대응됩니다.                                                                                                                                                                                                                                      |\n| \\\\t                   | 탭 (U+0009) 문자에 대응됩니다.                                                                                                                                                                                                                                              |\n| \\\\v                   | 수직 탭(U+000B) 문자에 대응됩니다.                                                                                                                                                                                                                                          |\n| \\\\n                   | **정규식 내부의 n번째 괄호에서 대응된 부분에 대한 역참조** 여기서, n은 양의 정수입니다. 예를 들어, /apple(,)\\\\sorange\\\\1/는 “apple, orange, cherry, peach.”의 ‘apple, orange,’ 에 일치합니다.                                                                               |\n| \\\\0                   | 널 (U+0000)문자에 대응합니다. 이 때 다른 숫자를 뒤에 쓰지 마세요. 왜냐하면 \\\\0는 8진 이스케이프 시퀀스이기 때문입니다.                                                                                                                                                      |\n| \\\\xhh                 | 코드가 hh(두 16진 숫자)인 문자에 일치합니다.                                                                                                                                                                                                                                |\n| \\\\uhhhh               | 코드가 hhhh(네개의 16진 숫자)인 문자에 일치합니다.                                                                                                                                                                                                                          |\n\n\n*   참고 링크 :  \n    [https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EC%A0%95%EA%B7%9C%EC%8B%9D](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EC%A0%95%EA%B7%9C%EC%8B%9D)\n\n* * *\n\n#### 정규 표현 메서드\n\n| 종류   | 설명                                                  |\n|--------|-------------------------------------------------------|\n| test() | 지정된 규칙에 맞는 단어가 있으면 **true 값을 반환**   |\n| exec() | 지정된 규칙에 맞는 단어가 있으면 **해당 단어를 반환** |\n\n사용예제\n\n```js\nvar str=\"Html Css jQuery \"; // 문자열 선언\n\n\nvar reg1=/css/;  // 검색 패턴\nvar result_1=reg1.test(str); \n//str데이터에 reg1 패턴 규칙에 맞는 단어가 있으면 true 아니면 false반환\n    document.write(result_1,\"<br />\"); //false\n  \n  \nvar reg2=/css/i; // 검색 패턴\n//옵션에 'i'를 입력하면 영문 대소문자를 구분하지 않습니다\nvar result_2=reg2.test(str);\n   document.write(result_2,\"<br />\"); //true\n```\n\n사용예제 2\n```js\n// 유저에게 이름을 입력받습니다.\nvar userName=prompt(\"당신의 이름은?\");\n// (가 부터 힣 까지, 2자 부터 5자까지)인 경우의 패턴 값을 생성했습니다.\nreg1=/^[가-힣]{2,5}$/;\n\nwhile(true){ // reg1 값이 true라면\n  if(reg1.test(userName)) break; // break(종료)\n\n  // reg1 값이 false 라면\n  alert(\"이름 입력 형식이 잘못되었습니다!\");\n  userName=prompt(\"당신의 이름은?\"); // 다시 입력받습니다.\n}\n\n// 유저에게 핸드폰 번호를 입력받습니다.\nvar userCell=prompt(\"당신의 핸드폰 번호는?\");\n// (010 or 016 or 011)로 시작, 숫자 3~4자리만 작성가능, 마지막엔 숫자4개가 작성된 경우의 패턴 값을 생성했습니다.\nreg2=/^(010|016|011)\\d{3,4}\\d{4}$/;\n\nwhile(true){ //reg2 값이 true 라면\n  if(reg2.test(userCell)) break; // break\n\n   // reg2 값이 false 라면\n   alert(\"핸드폰 입력 형식이 잘못되었습니다!\");\n   userCell=prompt(\"당신의 핸드폰 번호는?\"); // 다시 입력받습니다.\n}\n\n// 유저에게 이메일을 입력받습니다.\nvar userEmail=prompt(\"당신의 이메일은?\");\n/* 알파벳, 밑줄(_), 숫자를 포함한 5글자부터~12글자까지,\n   다음엔 '@',\n   a-z중 2글자부터 10글자까지 작성된,\n   \".\"이후에 a-z중 2~3글자 까지 작성된,\n   다음에 \".\"인 문자가 0이거나 1개가 작성된,\n   .이후에 a-z중 0개 부터 2개까지 작성된 패턴 값을 생성합니다.\n*/\nreg3=/^\\w{5,12}@[a-z]{2,10}[\\.][a-z]{2,3}[\\.]?[a-z]{0,2}$/;\n\nwhile(true){ //reg3 값이 true 라면\n  if(reg3.test(userEmail)) break; // break\n\n  //reg3 값이 false라면  \n  alert(\"이메일 입력 형식이 잘못되었습니다!\");\n  userEmail=prompt(\"당신의 이메일은?\"); //다시 입력받습니다.\n}\n// 출력\ndocument.write(userName,\"<br />\");\ndocument.write(userCell,\"<br />\");\ndocument.write(userEmail,\"<br />\"); \n```","slug":"RegExp 정규표현 객체 -JavaScript","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrso001bqgvqaxh8brra","content":"<p>정규표현 객체는 입력요소에 데이터를 규칙에 맞게 작성했는지 판단해서</p>\n<p>알려주는 객체 입니다.</p>\n<p><strong>지정한 규칙대로 단어가 입력됬는지,</strong></p>\n<p><strong>잘못된 단어를 포함하고 있는지 찾을때 사용합니다</strong></p>\n<pre><code>기본형 두가지\n\n    var 변수 = new RegExp(패턴, 검색옵션)\n    생성자 함수를 사용하면 정규식이 실행 시점에 컴파일됩니다. \n    정규식의 패턴이 변경될 수 있는 경우, \n    혹은 사용자 입력과 같이 다른 출처로부터 패턴을 가져와야 하는\n    경우에는 생성자 함수를 사용합니다.\n\n    var 변수 = /패턴/검색 옵션\n    정규식 리터럴(슬래쉬로 감싸는 패턴)은 \n    스크립트가 불러와질 때 컴파일됩니다. \n    만약 정규식이 상수라면, 이렇게 사용하는 것이 성능을 향상시킬 수 있습니다.   </code></pre><a id=\"more\"></a>\n\n<hr>\n<h4 id=\"정규-표현-검색-옵션\"><a href=\"#정규-표현-검색-옵션\" class=\"headerlink\" title=\"정규 표현 검색 옵션\"></a>정규 표현 검색 옵션</h4><table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>앞의 표현식이 <strong>0회 이상 연속으로 반복되는 부분과 대응됩니다.</strong> {0,} 와 같은 의미입니다.</td>\n</tr>\n<tr>\n<td>+</td>\n<td>앞의 표현식이 <strong>1회 이상 연속으로 반복되는 부분과 대응됩니다.</strong> {1,} 와 같은 의미입니다.</td>\n</tr>\n<tr>\n<td>i</td>\n<td>찾는 문자가 영문일 경우 <strong>대·소문자를 구분하지 않습니다</strong></td>\n</tr>\n<tr>\n<td>?</td>\n<td>앞의 표현식이 <strong>0 또는 1회 등장하는 부분과 대응됩니다.</strong> {0,1} 와 같은 의미입니다.</td>\n</tr>\n<tr>\n<td>.</td>\n<td><strong>개행 문자를 제외한 모든 단일 문자와 대응됩니다.</strong>예를 들어, /.n/는 “nay, an apple is on the tree”에서 ‘an’과 ‘on’에 대응되지만, ‘nay’ 에는 대응되지 않습니다.</td>\n</tr>\n<tr>\n<td>g</td>\n<td>옵션에 g가 없으면 데이터의 왼쪽부터 규칙에 일치하는 문자 한 개만 찾지만,<strong>g를 넣으면 규칙에 맞는 모든 문자를 찾습니다</strong>.</td>\n</tr>\n<tr>\n<td>m</td>\n<td><strong>데이터의 행이 바뀌어도</strong> 규칙에 맞는 문자를 찾습니다.(다중행 검색)</td>\n</tr>\n<tr>\n<td>$</td>\n<td><strong>문자열 끝부분에</strong> 규칙에 맞는 문자를 찾습니다.</td>\n</tr>\n<tr>\n<td>^</td>\n<td><strong>문자열 앞에서부터 규칙에 일치하는 문제를 찾습니다.</strong></td>\n</tr>\n<tr>\n<td>[xyz]</td>\n<td>문자셋(Character set) 입니다.<strong>괄호 안의 어떤 문자(이스케이프 시퀀스까지 포함)와도 대응됩니다. 점(.) 이나 별표 (*) 같은 특수 문자는 문자셋 내부에서는 특수 문자가 아닙니다. 따라서 이스케이프시킬 필요가 없습니다.</strong> 하이픈을 이용하여 문자의 범위를 지정해줄 수 있습니다.</td>\n</tr>\n<tr>\n<td>[^xyz]</td>\n<td>부정 문자셋(negated character set)입니다. <strong>괄호 내부에 등장하지 않는 어떤 문자와도 대응됩니다. 하이픈을 이용하여 문자의 범위를 지정할 수 있습니다.</strong></td>\n</tr>\n<tr>\n<td>\\d</td>\n<td><strong>숫자 문자에 대응됩니다.</strong> [0-9]와 동일합니다.</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td><strong>숫자 문자가 아닌 문자에 대응됩니다.</strong> [^0-9]와 동일합니다.</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td><strong>페이스, 탭, 폼피드, 줄 바꿈 문자등을 포함한 하나의 공백 문자</strong>에 대응됩니다. [ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff].와 동일합니다. 예를 들어, /\\S\\w*/는 “foo bar.”의 ‘bar’ 에 대응됩니다.</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td><strong>공백 문자가 아닌 하나의 문자에 대응됩니다.</strong> [^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]. 와 동일합니다. 예를 들어, /\\S\\w*/는 “foo bar.”의 ‘foo’ 에 대응됩니다.</td>\n</tr>\n<tr>\n<td>[0-9][A-Z][a-z]</td>\n<td><strong>숫자, 대문자 영문, 소문자 영문을 찾습니다.</strong></td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>문자의 앞 또는 뒤에 공백 문자열을 삭제합니다.</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td><strong>알파벳, 숫자, 밑줄(_) 기호를 제외한 문자를 찾습니다.</strong> [^A-Za-z0-9_] 와 동일합니다.</td>\n</tr>\n<tr>\n<td>(x)</td>\n<td><strong>‘x’에 대응되고, 그것을 기억합니다.</strong> 괄호는 포획 괄호(capturing parentheses)라 불립니다.</td>\n</tr>\n<tr>\n<td>(?:x)</td>\n<td><strong>‘x’에 대응되지만 대응된 것을 기억하지 않습니다.</strong> 괄호는 비포획 괄호(non-capturing parentheses)라고 불립니다.</td>\n</tr>\n<tr>\n<td>x(?=y)</td>\n<td><strong>오직 ‘y’가 뒤따라오는 ‘x’에만 대응됩니다.</strong> 이것은 lookahead 라고 불립니다.예를 들어, /Jack(?=Sprat)/ 는 ‘Sprat’가 뒤따라오는 ‘Jack’ 에만 대응됩니다. /Jack(?=Sprat</td>\n</tr>\n<tr>\n<td>x(?!y)</td>\n<td><strong>‘x’뒤에 ‘y’가 없는경우에만 ‘x’에 일치합니다.</strong> 이것은 negated lookahead 라고 불립니다.</td>\n</tr>\n<tr>\n<td>a</td>\n<td>b</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td><strong>앞 표현식이 n번 나타나는 부분에 대응됩니다.</strong> n은 반드시 양의 정수여야 합니다. /a{2}/는 ‘a’에는 대응되지 않지만, 첫 두”aa” 에는 대응됩니다.</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>n과 m은 양의 정수이고, n &lt;= m를 만족해야 합니다.<strong>앞 문자가 최소 n개, 최대 m개가 나타나는 부분에 대응됩니다.</strong> m이 생략된다면, m은 ∞로 취급됩니다.</td>\n</tr>\n<tr>\n<td>\\cX</td>\n<td>문자열 내부의 제어 문자에 대응됩니다. 여기서 X는 A에서 Z까지의 문자 중 하나입니다. 예를 들어, /\\cM/는 문자열에서 control-M (U+000D)에 대응됩니다.</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>폼피드 (U+000C) 문자에 대응됩니다.</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>줄 바꿈 (U+000A) 문자에 대응됩니다.</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>캐리지 리턴(U+000D) 문자에 대응됩니다.</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>탭 (U+0009) 문자에 대응됩니다.</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>수직 탭(U+000B) 문자에 대응됩니다.</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td><strong>정규식 내부의 n번째 괄호에서 대응된 부분에 대한 역참조</strong> 여기서, n은 양의 정수입니다. 예를 들어, /apple(,)\\sorange\\1/는 “apple, orange, cherry, peach.”의 ‘apple, orange,’ 에 일치합니다.</td>\n</tr>\n<tr>\n<td>\\0</td>\n<td>널 (U+0000)문자에 대응합니다. 이 때 다른 숫자를 뒤에 쓰지 마세요. 왜냐하면 \\0는 8진 이스케이프 시퀀스이기 때문입니다.</td>\n</tr>\n<tr>\n<td>\\xhh</td>\n<td>코드가 hh(두 16진 숫자)인 문자에 일치합니다.</td>\n</tr>\n<tr>\n<td>\\uhhhh</td>\n<td>코드가 hhhh(네개의 16진 숫자)인 문자에 일치합니다.</td>\n</tr>\n</tbody></table>\n<ul>\n<li>참고 링크 :<br><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EC%A0%95%EA%B7%9C%EC%8B%9D\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EC%A0%95%EA%B7%9C%EC%8B%9D</a></li>\n</ul>\n<hr>\n<h4 id=\"정규-표현-메서드\"><a href=\"#정규-표현-메서드\" class=\"headerlink\" title=\"정규 표현 메서드\"></a>정규 표현 메서드</h4><table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>test()</td>\n<td>지정된 규칙에 맞는 단어가 있으면 <strong>true 값을 반환</strong></td>\n</tr>\n<tr>\n<td>exec()</td>\n<td>지정된 규칙에 맞는 단어가 있으면 <strong>해당 단어를 반환</strong></td>\n</tr>\n</tbody></table>\n<p>사용예제</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str=<span class=\"string\">\"Html Css jQuery \"</span>; <span class=\"comment\">// 문자열 선언</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> reg1=<span class=\"regexp\">/css/</span>;  <span class=\"comment\">// 검색 패턴</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result_1=reg1.test(str); </span><br><span class=\"line\"><span class=\"comment\">//str데이터에 reg1 패턴 규칙에 맞는 단어가 있으면 true 아니면 false반환</span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(result_1,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">//false</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> reg2=<span class=\"regexp\">/css/i</span>; <span class=\"comment\">// 검색 패턴</span></span><br><span class=\"line\"><span class=\"comment\">//옵션에 'i'를 입력하면 영문 대소문자를 구분하지 않습니다</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result_2=reg2.test(str);</span><br><span class=\"line\">   <span class=\"built_in\">document</span>.write(result_2,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>사용예제 2</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 유저에게 이름을 입력받습니다.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> userName=prompt(<span class=\"string\">\"당신의 이름은?\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// (가 부터 힣 까지, 2자 부터 5자까지)인 경우의 패턴 값을 생성했습니다.</span></span><br><span class=\"line\">reg1=<span class=\"regexp\">/^[가-힣]&#123;2,5&#125;$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123; <span class=\"comment\">// reg1 값이 true라면</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(reg1.test(userName)) <span class=\"keyword\">break</span>; <span class=\"comment\">// break(종료)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// reg1 값이 false 라면</span></span><br><span class=\"line\">  alert(<span class=\"string\">\"이름 입력 형식이 잘못되었습니다!\"</span>);</span><br><span class=\"line\">  userName=prompt(<span class=\"string\">\"당신의 이름은?\"</span>); <span class=\"comment\">// 다시 입력받습니다.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 유저에게 핸드폰 번호를 입력받습니다.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> userCell=prompt(<span class=\"string\">\"당신의 핸드폰 번호는?\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// (010 or 016 or 011)로 시작, 숫자 3~4자리만 작성가능, 마지막엔 숫자4개가 작성된 경우의 패턴 값을 생성했습니다.</span></span><br><span class=\"line\">reg2=<span class=\"regexp\">/^(010|016|011)\\d&#123;3,4&#125;\\d&#123;4&#125;$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123; <span class=\"comment\">//reg2 값이 true 라면</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(reg2.test(userCell)) <span class=\"keyword\">break</span>; <span class=\"comment\">// break</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// reg2 값이 false 라면</span></span><br><span class=\"line\">   alert(<span class=\"string\">\"핸드폰 입력 형식이 잘못되었습니다!\"</span>);</span><br><span class=\"line\">   userCell=prompt(<span class=\"string\">\"당신의 핸드폰 번호는?\"</span>); <span class=\"comment\">// 다시 입력받습니다.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 유저에게 이메일을 입력받습니다.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> userEmail=prompt(<span class=\"string\">\"당신의 이메일은?\"</span>);</span><br><span class=\"line\"><span class=\"comment\">/* 알파벳, 밑줄(_), 숫자를 포함한 5글자부터~12글자까지,</span></span><br><span class=\"line\"><span class=\"comment\">   다음엔 '@',</span></span><br><span class=\"line\"><span class=\"comment\">   a-z중 2글자부터 10글자까지 작성된,</span></span><br><span class=\"line\"><span class=\"comment\">   \".\"이후에 a-z중 2~3글자 까지 작성된,</span></span><br><span class=\"line\"><span class=\"comment\">   다음에 \".\"인 문자가 0이거나 1개가 작성된,</span></span><br><span class=\"line\"><span class=\"comment\">   .이후에 a-z중 0개 부터 2개까지 작성된 패턴 값을 생성합니다.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">reg3=<span class=\"regexp\">/^\\w&#123;5,12&#125;@[a-z]&#123;2,10&#125;[\\.][a-z]&#123;2,3&#125;[\\.]?[a-z]&#123;0,2&#125;$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123; <span class=\"comment\">//reg3 값이 true 라면</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(reg3.test(userEmail)) <span class=\"keyword\">break</span>; <span class=\"comment\">// break</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//reg3 값이 false라면  </span></span><br><span class=\"line\">  alert(<span class=\"string\">\"이메일 입력 형식이 잘못되었습니다!\"</span>);</span><br><span class=\"line\">  userEmail=prompt(<span class=\"string\">\"당신의 이메일은?\"</span>); <span class=\"comment\">//다시 입력받습니다.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 출력</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(userName,<span class=\"string\">\"&lt;br /&gt;\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(userCell,<span class=\"string\">\"&lt;br /&gt;\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(userEmail,<span class=\"string\">\"&lt;br /&gt;\"</span>);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>정규표현 객체는 입력요소에 데이터를 규칙에 맞게 작성했는지 판단해서</p>\n<p>알려주는 객체 입니다.</p>\n<p><strong>지정한 규칙대로 단어가 입력됬는지,</strong></p>\n<p><strong>잘못된 단어를 포함하고 있는지 찾을때 사용합니다</strong></p>\n<pre><code>기본형 두가지\n\n    var 변수 = new RegExp(패턴, 검색옵션)\n    생성자 함수를 사용하면 정규식이 실행 시점에 컴파일됩니다. \n    정규식의 패턴이 변경될 수 있는 경우, \n    혹은 사용자 입력과 같이 다른 출처로부터 패턴을 가져와야 하는\n    경우에는 생성자 함수를 사용합니다.\n\n    var 변수 = /패턴/검색 옵션\n    정규식 리터럴(슬래쉬로 감싸는 패턴)은 \n    스크립트가 불러와질 때 컴파일됩니다. \n    만약 정규식이 상수라면, 이렇게 사용하는 것이 성능을 향상시킬 수 있습니다.   </code></pre>","more":"<hr>\n<h4 id=\"정규-표현-검색-옵션\"><a href=\"#정규-표현-검색-옵션\" class=\"headerlink\" title=\"정규 표현 검색 옵션\"></a>정규 표현 검색 옵션</h4><table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>앞의 표현식이 <strong>0회 이상 연속으로 반복되는 부분과 대응됩니다.</strong> {0,} 와 같은 의미입니다.</td>\n</tr>\n<tr>\n<td>+</td>\n<td>앞의 표현식이 <strong>1회 이상 연속으로 반복되는 부분과 대응됩니다.</strong> {1,} 와 같은 의미입니다.</td>\n</tr>\n<tr>\n<td>i</td>\n<td>찾는 문자가 영문일 경우 <strong>대·소문자를 구분하지 않습니다</strong></td>\n</tr>\n<tr>\n<td>?</td>\n<td>앞의 표현식이 <strong>0 또는 1회 등장하는 부분과 대응됩니다.</strong> {0,1} 와 같은 의미입니다.</td>\n</tr>\n<tr>\n<td>.</td>\n<td><strong>개행 문자를 제외한 모든 단일 문자와 대응됩니다.</strong>예를 들어, /.n/는 “nay, an apple is on the tree”에서 ‘an’과 ‘on’에 대응되지만, ‘nay’ 에는 대응되지 않습니다.</td>\n</tr>\n<tr>\n<td>g</td>\n<td>옵션에 g가 없으면 데이터의 왼쪽부터 규칙에 일치하는 문자 한 개만 찾지만,<strong>g를 넣으면 규칙에 맞는 모든 문자를 찾습니다</strong>.</td>\n</tr>\n<tr>\n<td>m</td>\n<td><strong>데이터의 행이 바뀌어도</strong> 규칙에 맞는 문자를 찾습니다.(다중행 검색)</td>\n</tr>\n<tr>\n<td>$</td>\n<td><strong>문자열 끝부분에</strong> 규칙에 맞는 문자를 찾습니다.</td>\n</tr>\n<tr>\n<td>^</td>\n<td><strong>문자열 앞에서부터 규칙에 일치하는 문제를 찾습니다.</strong></td>\n</tr>\n<tr>\n<td>[xyz]</td>\n<td>문자셋(Character set) 입니다.<strong>괄호 안의 어떤 문자(이스케이프 시퀀스까지 포함)와도 대응됩니다. 점(.) 이나 별표 (*) 같은 특수 문자는 문자셋 내부에서는 특수 문자가 아닙니다. 따라서 이스케이프시킬 필요가 없습니다.</strong> 하이픈을 이용하여 문자의 범위를 지정해줄 수 있습니다.</td>\n</tr>\n<tr>\n<td>[^xyz]</td>\n<td>부정 문자셋(negated character set)입니다. <strong>괄호 내부에 등장하지 않는 어떤 문자와도 대응됩니다. 하이픈을 이용하여 문자의 범위를 지정할 수 있습니다.</strong></td>\n</tr>\n<tr>\n<td>\\d</td>\n<td><strong>숫자 문자에 대응됩니다.</strong> [0-9]와 동일합니다.</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td><strong>숫자 문자가 아닌 문자에 대응됩니다.</strong> [^0-9]와 동일합니다.</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td><strong>페이스, 탭, 폼피드, 줄 바꿈 문자등을 포함한 하나의 공백 문자</strong>에 대응됩니다. [ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff].와 동일합니다. 예를 들어, /\\S\\w*/는 “foo bar.”의 ‘bar’ 에 대응됩니다.</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td><strong>공백 문자가 아닌 하나의 문자에 대응됩니다.</strong> [^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]. 와 동일합니다. 예를 들어, /\\S\\w*/는 “foo bar.”의 ‘foo’ 에 대응됩니다.</td>\n</tr>\n<tr>\n<td>[0-9][A-Z][a-z]</td>\n<td><strong>숫자, 대문자 영문, 소문자 영문을 찾습니다.</strong></td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>문자의 앞 또는 뒤에 공백 문자열을 삭제합니다.</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td><strong>알파벳, 숫자, 밑줄(_) 기호를 제외한 문자를 찾습니다.</strong> [^A-Za-z0-9_] 와 동일합니다.</td>\n</tr>\n<tr>\n<td>(x)</td>\n<td><strong>‘x’에 대응되고, 그것을 기억합니다.</strong> 괄호는 포획 괄호(capturing parentheses)라 불립니다.</td>\n</tr>\n<tr>\n<td>(?:x)</td>\n<td><strong>‘x’에 대응되지만 대응된 것을 기억하지 않습니다.</strong> 괄호는 비포획 괄호(non-capturing parentheses)라고 불립니다.</td>\n</tr>\n<tr>\n<td>x(?=y)</td>\n<td><strong>오직 ‘y’가 뒤따라오는 ‘x’에만 대응됩니다.</strong> 이것은 lookahead 라고 불립니다.예를 들어, /Jack(?=Sprat)/ 는 ‘Sprat’가 뒤따라오는 ‘Jack’ 에만 대응됩니다. /Jack(?=Sprat</td>\n</tr>\n<tr>\n<td>x(?!y)</td>\n<td><strong>‘x’뒤에 ‘y’가 없는경우에만 ‘x’에 일치합니다.</strong> 이것은 negated lookahead 라고 불립니다.</td>\n</tr>\n<tr>\n<td>a</td>\n<td>b</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td><strong>앞 표현식이 n번 나타나는 부분에 대응됩니다.</strong> n은 반드시 양의 정수여야 합니다. /a{2}/는 ‘a’에는 대응되지 않지만, 첫 두”aa” 에는 대응됩니다.</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>n과 m은 양의 정수이고, n &lt;= m를 만족해야 합니다.<strong>앞 문자가 최소 n개, 최대 m개가 나타나는 부분에 대응됩니다.</strong> m이 생략된다면, m은 ∞로 취급됩니다.</td>\n</tr>\n<tr>\n<td>\\cX</td>\n<td>문자열 내부의 제어 문자에 대응됩니다. 여기서 X는 A에서 Z까지의 문자 중 하나입니다. 예를 들어, /\\cM/는 문자열에서 control-M (U+000D)에 대응됩니다.</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>폼피드 (U+000C) 문자에 대응됩니다.</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>줄 바꿈 (U+000A) 문자에 대응됩니다.</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>캐리지 리턴(U+000D) 문자에 대응됩니다.</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>탭 (U+0009) 문자에 대응됩니다.</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>수직 탭(U+000B) 문자에 대응됩니다.</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td><strong>정규식 내부의 n번째 괄호에서 대응된 부분에 대한 역참조</strong> 여기서, n은 양의 정수입니다. 예를 들어, /apple(,)\\sorange\\1/는 “apple, orange, cherry, peach.”의 ‘apple, orange,’ 에 일치합니다.</td>\n</tr>\n<tr>\n<td>\\0</td>\n<td>널 (U+0000)문자에 대응합니다. 이 때 다른 숫자를 뒤에 쓰지 마세요. 왜냐하면 \\0는 8진 이스케이프 시퀀스이기 때문입니다.</td>\n</tr>\n<tr>\n<td>\\xhh</td>\n<td>코드가 hh(두 16진 숫자)인 문자에 일치합니다.</td>\n</tr>\n<tr>\n<td>\\uhhhh</td>\n<td>코드가 hhhh(네개의 16진 숫자)인 문자에 일치합니다.</td>\n</tr>\n</tbody></table>\n<ul>\n<li>참고 링크 :<br><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EC%A0%95%EA%B7%9C%EC%8B%9D\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EC%A0%95%EA%B7%9C%EC%8B%9D</a></li>\n</ul>\n<hr>\n<h4 id=\"정규-표현-메서드\"><a href=\"#정규-표현-메서드\" class=\"headerlink\" title=\"정규 표현 메서드\"></a>정규 표현 메서드</h4><table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>test()</td>\n<td>지정된 규칙에 맞는 단어가 있으면 <strong>true 값을 반환</strong></td>\n</tr>\n<tr>\n<td>exec()</td>\n<td>지정된 규칙에 맞는 단어가 있으면 <strong>해당 단어를 반환</strong></td>\n</tr>\n</tbody></table>\n<p>사용예제</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str=<span class=\"string\">\"Html Css jQuery \"</span>; <span class=\"comment\">// 문자열 선언</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> reg1=<span class=\"regexp\">/css/</span>;  <span class=\"comment\">// 검색 패턴</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result_1=reg1.test(str); </span><br><span class=\"line\"><span class=\"comment\">//str데이터에 reg1 패턴 규칙에 맞는 단어가 있으면 true 아니면 false반환</span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(result_1,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">//false</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> reg2=<span class=\"regexp\">/css/i</span>; <span class=\"comment\">// 검색 패턴</span></span><br><span class=\"line\"><span class=\"comment\">//옵션에 'i'를 입력하면 영문 대소문자를 구분하지 않습니다</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result_2=reg2.test(str);</span><br><span class=\"line\">   <span class=\"built_in\">document</span>.write(result_2,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>사용예제 2</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 유저에게 이름을 입력받습니다.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> userName=prompt(<span class=\"string\">\"당신의 이름은?\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// (가 부터 힣 까지, 2자 부터 5자까지)인 경우의 패턴 값을 생성했습니다.</span></span><br><span class=\"line\">reg1=<span class=\"regexp\">/^[가-힣]&#123;2,5&#125;$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123; <span class=\"comment\">// reg1 값이 true라면</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(reg1.test(userName)) <span class=\"keyword\">break</span>; <span class=\"comment\">// break(종료)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// reg1 값이 false 라면</span></span><br><span class=\"line\">  alert(<span class=\"string\">\"이름 입력 형식이 잘못되었습니다!\"</span>);</span><br><span class=\"line\">  userName=prompt(<span class=\"string\">\"당신의 이름은?\"</span>); <span class=\"comment\">// 다시 입력받습니다.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 유저에게 핸드폰 번호를 입력받습니다.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> userCell=prompt(<span class=\"string\">\"당신의 핸드폰 번호는?\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// (010 or 016 or 011)로 시작, 숫자 3~4자리만 작성가능, 마지막엔 숫자4개가 작성된 경우의 패턴 값을 생성했습니다.</span></span><br><span class=\"line\">reg2=<span class=\"regexp\">/^(010|016|011)\\d&#123;3,4&#125;\\d&#123;4&#125;$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123; <span class=\"comment\">//reg2 값이 true 라면</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(reg2.test(userCell)) <span class=\"keyword\">break</span>; <span class=\"comment\">// break</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// reg2 값이 false 라면</span></span><br><span class=\"line\">   alert(<span class=\"string\">\"핸드폰 입력 형식이 잘못되었습니다!\"</span>);</span><br><span class=\"line\">   userCell=prompt(<span class=\"string\">\"당신의 핸드폰 번호는?\"</span>); <span class=\"comment\">// 다시 입력받습니다.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 유저에게 이메일을 입력받습니다.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> userEmail=prompt(<span class=\"string\">\"당신의 이메일은?\"</span>);</span><br><span class=\"line\"><span class=\"comment\">/* 알파벳, 밑줄(_), 숫자를 포함한 5글자부터~12글자까지,</span></span><br><span class=\"line\"><span class=\"comment\">   다음엔 '@',</span></span><br><span class=\"line\"><span class=\"comment\">   a-z중 2글자부터 10글자까지 작성된,</span></span><br><span class=\"line\"><span class=\"comment\">   \".\"이후에 a-z중 2~3글자 까지 작성된,</span></span><br><span class=\"line\"><span class=\"comment\">   다음에 \".\"인 문자가 0이거나 1개가 작성된,</span></span><br><span class=\"line\"><span class=\"comment\">   .이후에 a-z중 0개 부터 2개까지 작성된 패턴 값을 생성합니다.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">reg3=<span class=\"regexp\">/^\\w&#123;5,12&#125;@[a-z]&#123;2,10&#125;[\\.][a-z]&#123;2,3&#125;[\\.]?[a-z]&#123;0,2&#125;$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123; <span class=\"comment\">//reg3 값이 true 라면</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(reg3.test(userEmail)) <span class=\"keyword\">break</span>; <span class=\"comment\">// break</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//reg3 값이 false라면  </span></span><br><span class=\"line\">  alert(<span class=\"string\">\"이메일 입력 형식이 잘못되었습니다!\"</span>);</span><br><span class=\"line\">  userEmail=prompt(<span class=\"string\">\"당신의 이메일은?\"</span>); <span class=\"comment\">//다시 입력받습니다.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 출력</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(userName,<span class=\"string\">\"&lt;br /&gt;\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(userCell,<span class=\"string\">\"&lt;br /&gt;\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(userEmail,<span class=\"string\">\"&lt;br /&gt;\"</span>);</span><br></pre></td></tr></table></figure>"},{"title":"Spread 연산자 -ECMAScript","date":"2020-03-19T23:49:05.000Z","disqusId":"tunas-blog-1","_content":"\n\n* * *\n\n## 개요\n\n스프레드(Spread) 연산자는 이터러블 오브젝트의 엘리먼트를 하나씩 분리하여 전개합니다.\n\n전개한 결과를 변수에 할당하거나 호출하는 함수의 파라미터 값으로 사용할 수 있습니다.\n\n* 기본형\n\n> […iterableObject]\n\n* function에서\n\n> function(…iterableObject);\n\n* array에서\n\n> […iterableObj, ‘4’, ‘five’, 6];\n\n* object 에서\n\n> let objClone = { …obj };  \n> //ECMAScript 2018에서 추가되었습니다.\n\nspread 연산자는 “…”을 작성하고 뒤에 이터러블 오브젝트를 작성합니다.\n\n<!-- more -->\n\n* * *\n\n### 1. 배열\n\n[] 대괄호 안에 spread 연산자로 배열을 작성한 형태.\n\n```js\nlet one = [11, 12];  \nlet two = [21, 22];  \nlet spreadObj = [51, ...one, 52, ...two];  \n  \n1. console.log(spreadObj);   \n/*   \n0: 51  \n1: 11  \n2: 12  \n3: 52  \n4: 21  \n5: 22  \n= [51, 11, 12, 52, 21, 22]  \n*/  \n2. console.log(spreadObj.length); // 6  \n```\n\n1.  one 배열의 엘리멘트 [11, 12]에서 11과 12가 분리된 후,  \n    spreadObj = [51, …one, 52, …two];에 …one위치에 설정됩니다.  \n    two 배열역시 같은방식으로 spreadObj에 설정되고  \n    [51, 11, 12, 52, 21, 22] 형태로 spreadObj에 할당됩니다.\n\n\n2.  spreadObj의 length 값은 6이 됩니다.  \n    (one 과 two 배열의 엘리멘트가 분리되어 할당되었기 때문)  \n    엘리멘트가 분리되지 않고 할당되었다면 length 값은 4가 돼야 합니다.\n\n* * *\n\n### 2. 문자열\n\n[] 대괄호 안에 spread 연산자로 문자열을 작성한 형태.\n\n```js\nlet spreadObj = [...\"music\"];  \nconsole.log(spreadObj);  \n/*  \n0: \"m\"  \n1: \"u\"  \n2: \"s\"  \n3: \"i\"  \n4: \"c\"  \n= [\"m\", \"u\", \"s\", \"i\", \"c\"]  \n*/  \nconsole.log(spreadObj.length); // 5  \n```\n\n* * *\n\n### 3. 함수 파라미터\n\n호출하는 함수의 파라미터 값을 spread 연산자로 작성하면,  \n**함수를 호출하기 전에 파라미터 값을 분리, 전개합니다.**  \n호출받는 함수의 파라미터에 이름을 작성하면 각 엘리먼트 값이 파라미터 이름에 설정됩니다.\n\n```js\nconst values = [10, 20, 30];  \nget(...values); // 10, 20, 30 으로 각각 분리됩니다.  \n  \nfunction get(one, two, three){  \n /* 호출받은 함수 파라미터에  \n one: 10  \n two: 20  \n three: 30 이 설정됩니다.  \n */  \n console.log( one + two + three); // 60  \n};  \n```\n\n함수의 파라미터 값이 분리된 형태를 spread 파라미터 라고 합니다.\n\n* * *\n\n## rest 파라미터\n\nfunction(…rest)와 같이 함수 파라미터에 spread연산자로 파라미터를 작성한 형태를 rest파라미터 라고 합니다.\n\n> function(param, paramN, …rest);\n\n* * *\n\n호출하는 함수의 파라미터에 3개의 파라미터 값을 작성하고  \n호출받는 함수의 파라미터에 파라미터 이름을 하나만 작성하면  \n나머지 2개의 파라미터 값이 설정되지 않습니다.\n\n```js ...rest 미사용\nlet get = (one) => {  \n console.log(one);  \n}  \nget(...[1, 2, 3]); // 1  \n```\n\nget(…[1, 2, 3])이 get(1, 2, 3)형태로 전개되고  \n파라미터 one에 1 값이 설정됨.\n호출받는 get()함수가 화살표 함수이므로  \n호출한 get(…[1, 2, 3]) 함수에서 보낸 파라미터가 arguments에 설정되지 않음.  \n따라서 [1, 2, 3]에서 2,3을 받지 못하게 됩니다.\n\n* * *\n\n```js ...rest 사용시\nlet get = (...numRest) => {  \n console.log(numRest); // [1, 2, 3]  \n console.log(Array.isArray(numRest));// 배열 인지 확인해주는 메서드 true  \n}  \nget(...[1, 2, 3]);  \n```\n\n**rest 파라미터는 get(1, 2, 3) 형태로 호출된 파라미터 값을 배열의 엘리멘트로 설정합니다.(함수 안에서 numRest에 설정된 값을 배열로 사용할 수 있습니다.)**\n\n* * *\n\n```js 한개의 값만 설정 하고 rest 사용시\nlet get = (one, ...rest) => {  \n console.log(one); // 1  \n console.log(rest); // [2, 3]  \n}  \nget(...[1, 2, 3]);  \n```\n\nget(1, 2, 3) 형태로 호출되어 파라미터 one에 1값 설정됨.  \n나머지 2,3은 rest파라미터에 [2, 3]형태로 설정됩니다.\n\n* * *\n\n## spread와 rest 파라미터 구분\n\n`(...)형태는 같지만 기능이 다르므로 구분해야 합니다.`\n\n*   spread 파라미터는  \n    <u>호출하는 함수의 파라미터</u>에 사용하며 Array( 배열[] )를 엘리먼트 단위로 전개합니다.\n    \n*   rest 파라미터는  \n    <u>호출받는 함수의 파라미터</u>에 사용합니다.  \n    **호출하는 함수의 파라미터 순서에 맞춰 호출받는 파라미터에 값을 설정합니다.**  \n    설정되지 못하고 남은 파라미터 값은 배열의 엘리먼트로 설정합니다.\n    \n\n`spread는 배열을 엘리먼트로 분리,전개. rest는 전개된 엘리먼트를 다시 배열에 설정.`\n\n* * *\n\n## Array-like (유사배열)\n\n배열은 아니지만 배열처럼 사용할 수 있는 Object를 Array-like(혹은 유사배열 객체)라고 합니다.\n\n배열은 인덱스(index)를 갖고 있어 인덱스 순서대로 읽을 수 있으며,  \n인덱스 번호를 이용해 엘리먼트 값을 수정, 삭제할 수 있습니다.\n\n*   Object의 {key:values}형태를 배열도 object라는 점을 이용한  \n    Array(배열) 처럼 사용 하는 트릭입니다.\n    \n*   Object의 프로퍼티 “key” 를 Array의 index 처럼 사용하고  \n    value[key] 형태로 프로퍼티를 읽어올 수 있습니다.\n    \n*   Object의 value(프로퍼티 값)은 Array의 엘리먼트 처럼 사용합니다.\n    \n```js\nlet values = {  \n// {key:value}  \n 0: \"zero\",  \n 1: \"one\",   \n 2: \"two\",  \n  \n// {key:value} 형태에 맞추어 object전체 수 length 값을 작성합니다.  \n// 이 형태가 Array-like (유사 배열)입니다.   \n length: 3};  \n  \nfor (var key in values){ //  for-in  \n console.log(key, ':', values[key]);  \n};  \n  \nfor (var k = 0; k < values.length; k++){ // for()  \n console.log(values[k]);  \n};  \n/*실행결과  \n--------------  \nfor-in  \n0 : zero  \n1 : one  \n2 : two  \nlength : 3  \n--------------  \nfor()  \nzero  \none  \ntwo  \n*/  \n```\n\n*   for-in 문은 Object 오브젝트를 전개할 때 사용합니다.  \n    for-in 문으로 valuse 오브젝트를 전개하면 length 프로퍼티도 같이 전개됩니다.  \n    즉, for-in문으로 Array-like를 전개한다면 length 프로퍼티를 제외시키는 처리가 필요합니다.\n    \n*   **배열을 전개할 때는 주로 for()문을 사용합니다.**  \n    for()문으로 values 오브젝트를 전개해도 length프로퍼티가 전개되지 않습니다.\n    \n\n* * *\n\n### 유사배열은 배열 메서드를 사용할 수 없습니다.\n\n일반적으로 유사배열은 배열이 아니므로 배열 메서드를 사용할 수 없습니다.  \n이럴 때 메서드를 빌려와 유사배열에도 배열 메서드를 사용할 수 있는 방법은\n\n<mark>apply, call, form등 을 이용해 Array 메소드를 가져와 쓰는 경우가 있습니다.</mark>\n","source":"_posts/Spread 연산자 -ECMAScript.md","raw":"---\ntitle: Spread 연산자 -ECMAScript\ndate: 2020-03-20 08:49:05\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n\n* * *\n\n## 개요\n\n스프레드(Spread) 연산자는 이터러블 오브젝트의 엘리먼트를 하나씩 분리하여 전개합니다.\n\n전개한 결과를 변수에 할당하거나 호출하는 함수의 파라미터 값으로 사용할 수 있습니다.\n\n* 기본형\n\n> […iterableObject]\n\n* function에서\n\n> function(…iterableObject);\n\n* array에서\n\n> […iterableObj, ‘4’, ‘five’, 6];\n\n* object 에서\n\n> let objClone = { …obj };  \n> //ECMAScript 2018에서 추가되었습니다.\n\nspread 연산자는 “…”을 작성하고 뒤에 이터러블 오브젝트를 작성합니다.\n\n<!-- more -->\n\n* * *\n\n### 1. 배열\n\n[] 대괄호 안에 spread 연산자로 배열을 작성한 형태.\n\n```js\nlet one = [11, 12];  \nlet two = [21, 22];  \nlet spreadObj = [51, ...one, 52, ...two];  \n  \n1. console.log(spreadObj);   \n/*   \n0: 51  \n1: 11  \n2: 12  \n3: 52  \n4: 21  \n5: 22  \n= [51, 11, 12, 52, 21, 22]  \n*/  \n2. console.log(spreadObj.length); // 6  \n```\n\n1.  one 배열의 엘리멘트 [11, 12]에서 11과 12가 분리된 후,  \n    spreadObj = [51, …one, 52, …two];에 …one위치에 설정됩니다.  \n    two 배열역시 같은방식으로 spreadObj에 설정되고  \n    [51, 11, 12, 52, 21, 22] 형태로 spreadObj에 할당됩니다.\n\n\n2.  spreadObj의 length 값은 6이 됩니다.  \n    (one 과 two 배열의 엘리멘트가 분리되어 할당되었기 때문)  \n    엘리멘트가 분리되지 않고 할당되었다면 length 값은 4가 돼야 합니다.\n\n* * *\n\n### 2. 문자열\n\n[] 대괄호 안에 spread 연산자로 문자열을 작성한 형태.\n\n```js\nlet spreadObj = [...\"music\"];  \nconsole.log(spreadObj);  \n/*  \n0: \"m\"  \n1: \"u\"  \n2: \"s\"  \n3: \"i\"  \n4: \"c\"  \n= [\"m\", \"u\", \"s\", \"i\", \"c\"]  \n*/  \nconsole.log(spreadObj.length); // 5  \n```\n\n* * *\n\n### 3. 함수 파라미터\n\n호출하는 함수의 파라미터 값을 spread 연산자로 작성하면,  \n**함수를 호출하기 전에 파라미터 값을 분리, 전개합니다.**  \n호출받는 함수의 파라미터에 이름을 작성하면 각 엘리먼트 값이 파라미터 이름에 설정됩니다.\n\n```js\nconst values = [10, 20, 30];  \nget(...values); // 10, 20, 30 으로 각각 분리됩니다.  \n  \nfunction get(one, two, three){  \n /* 호출받은 함수 파라미터에  \n one: 10  \n two: 20  \n three: 30 이 설정됩니다.  \n */  \n console.log( one + two + three); // 60  \n};  \n```\n\n함수의 파라미터 값이 분리된 형태를 spread 파라미터 라고 합니다.\n\n* * *\n\n## rest 파라미터\n\nfunction(…rest)와 같이 함수 파라미터에 spread연산자로 파라미터를 작성한 형태를 rest파라미터 라고 합니다.\n\n> function(param, paramN, …rest);\n\n* * *\n\n호출하는 함수의 파라미터에 3개의 파라미터 값을 작성하고  \n호출받는 함수의 파라미터에 파라미터 이름을 하나만 작성하면  \n나머지 2개의 파라미터 값이 설정되지 않습니다.\n\n```js ...rest 미사용\nlet get = (one) => {  \n console.log(one);  \n}  \nget(...[1, 2, 3]); // 1  \n```\n\nget(…[1, 2, 3])이 get(1, 2, 3)형태로 전개되고  \n파라미터 one에 1 값이 설정됨.\n호출받는 get()함수가 화살표 함수이므로  \n호출한 get(…[1, 2, 3]) 함수에서 보낸 파라미터가 arguments에 설정되지 않음.  \n따라서 [1, 2, 3]에서 2,3을 받지 못하게 됩니다.\n\n* * *\n\n```js ...rest 사용시\nlet get = (...numRest) => {  \n console.log(numRest); // [1, 2, 3]  \n console.log(Array.isArray(numRest));// 배열 인지 확인해주는 메서드 true  \n}  \nget(...[1, 2, 3]);  \n```\n\n**rest 파라미터는 get(1, 2, 3) 형태로 호출된 파라미터 값을 배열의 엘리멘트로 설정합니다.(함수 안에서 numRest에 설정된 값을 배열로 사용할 수 있습니다.)**\n\n* * *\n\n```js 한개의 값만 설정 하고 rest 사용시\nlet get = (one, ...rest) => {  \n console.log(one); // 1  \n console.log(rest); // [2, 3]  \n}  \nget(...[1, 2, 3]);  \n```\n\nget(1, 2, 3) 형태로 호출되어 파라미터 one에 1값 설정됨.  \n나머지 2,3은 rest파라미터에 [2, 3]형태로 설정됩니다.\n\n* * *\n\n## spread와 rest 파라미터 구분\n\n`(...)형태는 같지만 기능이 다르므로 구분해야 합니다.`\n\n*   spread 파라미터는  \n    <u>호출하는 함수의 파라미터</u>에 사용하며 Array( 배열[] )를 엘리먼트 단위로 전개합니다.\n    \n*   rest 파라미터는  \n    <u>호출받는 함수의 파라미터</u>에 사용합니다.  \n    **호출하는 함수의 파라미터 순서에 맞춰 호출받는 파라미터에 값을 설정합니다.**  \n    설정되지 못하고 남은 파라미터 값은 배열의 엘리먼트로 설정합니다.\n    \n\n`spread는 배열을 엘리먼트로 분리,전개. rest는 전개된 엘리먼트를 다시 배열에 설정.`\n\n* * *\n\n## Array-like (유사배열)\n\n배열은 아니지만 배열처럼 사용할 수 있는 Object를 Array-like(혹은 유사배열 객체)라고 합니다.\n\n배열은 인덱스(index)를 갖고 있어 인덱스 순서대로 읽을 수 있으며,  \n인덱스 번호를 이용해 엘리먼트 값을 수정, 삭제할 수 있습니다.\n\n*   Object의 {key:values}형태를 배열도 object라는 점을 이용한  \n    Array(배열) 처럼 사용 하는 트릭입니다.\n    \n*   Object의 프로퍼티 “key” 를 Array의 index 처럼 사용하고  \n    value[key] 형태로 프로퍼티를 읽어올 수 있습니다.\n    \n*   Object의 value(프로퍼티 값)은 Array의 엘리먼트 처럼 사용합니다.\n    \n```js\nlet values = {  \n// {key:value}  \n 0: \"zero\",  \n 1: \"one\",   \n 2: \"two\",  \n  \n// {key:value} 형태에 맞추어 object전체 수 length 값을 작성합니다.  \n// 이 형태가 Array-like (유사 배열)입니다.   \n length: 3};  \n  \nfor (var key in values){ //  for-in  \n console.log(key, ':', values[key]);  \n};  \n  \nfor (var k = 0; k < values.length; k++){ // for()  \n console.log(values[k]);  \n};  \n/*실행결과  \n--------------  \nfor-in  \n0 : zero  \n1 : one  \n2 : two  \nlength : 3  \n--------------  \nfor()  \nzero  \none  \ntwo  \n*/  \n```\n\n*   for-in 문은 Object 오브젝트를 전개할 때 사용합니다.  \n    for-in 문으로 valuse 오브젝트를 전개하면 length 프로퍼티도 같이 전개됩니다.  \n    즉, for-in문으로 Array-like를 전개한다면 length 프로퍼티를 제외시키는 처리가 필요합니다.\n    \n*   **배열을 전개할 때는 주로 for()문을 사용합니다.**  \n    for()문으로 values 오브젝트를 전개해도 length프로퍼티가 전개되지 않습니다.\n    \n\n* * *\n\n### 유사배열은 배열 메서드를 사용할 수 없습니다.\n\n일반적으로 유사배열은 배열이 아니므로 배열 메서드를 사용할 수 없습니다.  \n이럴 때 메서드를 빌려와 유사배열에도 배열 메서드를 사용할 수 있는 방법은\n\n<mark>apply, call, form등 을 이용해 Array 메소드를 가져와 쓰는 경우가 있습니다.</mark>\n","slug":"Spread 연산자 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrsp001eqgvqhy7gb432","content":"<hr>\n<h2 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h2><p>스프레드(Spread) 연산자는 이터러블 오브젝트의 엘리먼트를 하나씩 분리하여 전개합니다.</p>\n<p>전개한 결과를 변수에 할당하거나 호출하는 함수의 파라미터 값으로 사용할 수 있습니다.</p>\n<ul>\n<li>기본형</li>\n</ul>\n<blockquote>\n<p>[…iterableObject]</p>\n</blockquote>\n<ul>\n<li>function에서</li>\n</ul>\n<blockquote>\n<p>function(…iterableObject);</p>\n</blockquote>\n<ul>\n<li>array에서</li>\n</ul>\n<blockquote>\n<p>[…iterableObj, ‘4’, ‘five’, 6];</p>\n</blockquote>\n<ul>\n<li>object 에서</li>\n</ul>\n<blockquote>\n<p>let objClone = { …obj };<br>//ECMAScript 2018에서 추가되었습니다.</p>\n</blockquote>\n<p>spread 연산자는 “…”을 작성하고 뒤에 이터러블 오브젝트를 작성합니다.</p>\n<a id=\"more\"></a>\n\n<hr>\n<h3 id=\"1-배열\"><a href=\"#1-배열\" class=\"headerlink\" title=\"1. 배열\"></a>1. 배열</h3><p>[] 대괄호 안에 spread 연산자로 배열을 작성한 형태.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = [<span class=\"number\">11</span>, <span class=\"number\">12</span>];  </span><br><span class=\"line\"><span class=\"keyword\">let</span> two = [<span class=\"number\">21</span>, <span class=\"number\">22</span>];  </span><br><span class=\"line\"><span class=\"keyword\">let</span> spreadObj = [<span class=\"number\">51</span>, ...one, <span class=\"number\">52</span>, ...two];  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(spreadObj);   </span><br><span class=\"line\"><span class=\"comment\">/*   </span></span><br><span class=\"line\"><span class=\"comment\">0: 51  </span></span><br><span class=\"line\"><span class=\"comment\">1: 11  </span></span><br><span class=\"line\"><span class=\"comment\">2: 12  </span></span><br><span class=\"line\"><span class=\"comment\">3: 52  </span></span><br><span class=\"line\"><span class=\"comment\">4: 21  </span></span><br><span class=\"line\"><span class=\"comment\">5: 22  </span></span><br><span class=\"line\"><span class=\"comment\">= [51, 11, 12, 52, 21, 22]  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(spreadObj.length); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>one 배열의 엘리멘트 [11, 12]에서 11과 12가 분리된 후,<br>spreadObj = [51, …one, 52, …two];에 …one위치에 설정됩니다.<br>two 배열역시 같은방식으로 spreadObj에 설정되고<br>[51, 11, 12, 52, 21, 22] 형태로 spreadObj에 할당됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li>spreadObj의 length 값은 6이 됩니다.<br>(one 과 two 배열의 엘리멘트가 분리되어 할당되었기 때문)<br>엘리멘트가 분리되지 않고 할당되었다면 length 값은 4가 돼야 합니다.</li>\n</ol>\n<hr>\n<h3 id=\"2-문자열\"><a href=\"#2-문자열\" class=\"headerlink\" title=\"2. 문자열\"></a>2. 문자열</h3><p>[] 대괄호 안에 spread 연산자로 문자열을 작성한 형태.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> spreadObj = [...<span class=\"string\">\"music\"</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(spreadObj);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">0: \"m\"  </span></span><br><span class=\"line\"><span class=\"comment\">1: \"u\"  </span></span><br><span class=\"line\"><span class=\"comment\">2: \"s\"  </span></span><br><span class=\"line\"><span class=\"comment\">3: \"i\"  </span></span><br><span class=\"line\"><span class=\"comment\">4: \"c\"  </span></span><br><span class=\"line\"><span class=\"comment\">= [\"m\", \"u\", \"s\", \"i\", \"c\"]  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(spreadObj.length); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"3-함수-파라미터\"><a href=\"#3-함수-파라미터\" class=\"headerlink\" title=\"3. 함수 파라미터\"></a>3. 함수 파라미터</h3><p>호출하는 함수의 파라미터 값을 spread 연산자로 작성하면,<br><strong>함수를 호출하기 전에 파라미터 값을 분리, 전개합니다.</strong><br>호출받는 함수의 파라미터에 이름을 작성하면 각 엘리먼트 값이 파라미터 이름에 설정됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> values = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>];  </span><br><span class=\"line\"><span class=\"keyword\">get</span>(...values); // 10, 20, 30 으로 각각 분리됩니다.  </span><br><span class=\"line\">  </span><br><span class=\"line\">function <span class=\"keyword\">get</span>(one, two, three)&#123;  </span><br><span class=\"line\"> <span class=\"comment\">/* 호출받은 함수 파라미터에  </span></span><br><span class=\"line\"><span class=\"comment\"> one: 10  </span></span><br><span class=\"line\"><span class=\"comment\"> two: 20  </span></span><br><span class=\"line\"><span class=\"comment\"> three: 30 이 설정됩니다.  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log( one + two + three); <span class=\"comment\">// 60  </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>함수의 파라미터 값이 분리된 형태를 spread 파라미터 라고 합니다.</p>\n<hr>\n<h2 id=\"rest-파라미터\"><a href=\"#rest-파라미터\" class=\"headerlink\" title=\"rest 파라미터\"></a>rest 파라미터</h2><p>function(…rest)와 같이 함수 파라미터에 spread연산자로 파라미터를 작성한 형태를 rest파라미터 라고 합니다.</p>\n<blockquote>\n<p>function(param, paramN, …rest);</p>\n</blockquote>\n<hr>\n<p>호출하는 함수의 파라미터에 3개의 파라미터 값을 작성하고<br>호출받는 함수의 파라미터에 파라미터 이름을 하나만 작성하면<br>나머지 2개의 파라미터 값이 설정되지 않습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>...rest 미사용</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">get</span> = (one) =&gt; &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(one);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">get</span>(...[1, 2, 3]); // 1</span><br></pre></td></tr></table></figure>\n\n<p>get(…[1, 2, 3])이 get(1, 2, 3)형태로 전개되고<br>파라미터 one에 1 값이 설정됨.<br>호출받는 get()함수가 화살표 함수이므로<br>호출한 get(…[1, 2, 3]) 함수에서 보낸 파라미터가 arguments에 설정되지 않음.<br>따라서 [1, 2, 3]에서 2,3을 받지 못하게 됩니다.</p>\n<hr>\n<figure class=\"highlight js\"><figcaption><span>...rest 사용시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">get</span> = (...numRest) =&gt; &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(numRest); <span class=\"comment\">// [1, 2, 3]  </span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.isArray(numRest));<span class=\"comment\">// 배열 인지 확인해주는 메서드 true  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">get</span>(...[1, 2, 3]);</span><br></pre></td></tr></table></figure>\n\n<p><strong>rest 파라미터는 get(1, 2, 3) 형태로 호출된 파라미터 값을 배열의 엘리멘트로 설정합니다.(함수 안에서 numRest에 설정된 값을 배열로 사용할 수 있습니다.)</strong></p>\n<hr>\n<figure class=\"highlight js\"><figcaption><span>한개의 값만 설정 하고 rest 사용시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">get</span> = (one, ...rest) =&gt; &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(one); <span class=\"comment\">// 1  </span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(rest); <span class=\"comment\">// [2, 3]  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">get</span>(...[1, 2, 3]);</span><br></pre></td></tr></table></figure>\n\n<p>get(1, 2, 3) 형태로 호출되어 파라미터 one에 1값 설정됨.<br>나머지 2,3은 rest파라미터에 [2, 3]형태로 설정됩니다.</p>\n<hr>\n<h2 id=\"spread와-rest-파라미터-구분\"><a href=\"#spread와-rest-파라미터-구분\" class=\"headerlink\" title=\"spread와 rest 파라미터 구분\"></a>spread와 rest 파라미터 구분</h2><p><code>(...)형태는 같지만 기능이 다르므로 구분해야 합니다.</code></p>\n<ul>\n<li><p>spread 파라미터는<br><u>호출하는 함수의 파라미터</u>에 사용하며 Array( 배열[] )를 엘리먼트 단위로 전개합니다.</p>\n</li>\n<li><p>rest 파라미터는<br><u>호출받는 함수의 파라미터</u>에 사용합니다.<br><strong>호출하는 함수의 파라미터 순서에 맞춰 호출받는 파라미터에 값을 설정합니다.</strong><br>설정되지 못하고 남은 파라미터 값은 배열의 엘리먼트로 설정합니다.</p>\n</li>\n</ul>\n<p><code>spread는 배열을 엘리먼트로 분리,전개. rest는 전개된 엘리먼트를 다시 배열에 설정.</code></p>\n<hr>\n<h2 id=\"Array-like-유사배열\"><a href=\"#Array-like-유사배열\" class=\"headerlink\" title=\"Array-like (유사배열)\"></a>Array-like (유사배열)</h2><p>배열은 아니지만 배열처럼 사용할 수 있는 Object를 Array-like(혹은 유사배열 객체)라고 합니다.</p>\n<p>배열은 인덱스(index)를 갖고 있어 인덱스 순서대로 읽을 수 있으며,<br>인덱스 번호를 이용해 엘리먼트 값을 수정, 삭제할 수 있습니다.</p>\n<ul>\n<li><p>Object의 {key:values}형태를 배열도 object라는 점을 이용한<br>Array(배열) 처럼 사용 하는 트릭입니다.</p>\n</li>\n<li><p>Object의 프로퍼티 “key” 를 Array의 index 처럼 사용하고<br>value[key] 형태로 프로퍼티를 읽어올 수 있습니다.</p>\n</li>\n<li><p>Object의 value(프로퍼티 값)은 Array의 엘리먼트 처럼 사용합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> values = &#123;  </span><br><span class=\"line\"><span class=\"comment\">// &#123;key:value&#125;  </span></span><br><span class=\"line\"> <span class=\"number\">0</span>: <span class=\"string\">\"zero\"</span>,  </span><br><span class=\"line\"> <span class=\"number\">1</span>: <span class=\"string\">\"one\"</span>,   </span><br><span class=\"line\"> <span class=\"number\">2</span>: <span class=\"string\">\"two\"</span>,  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// &#123;key:value&#125; 형태에 맞추어 object전체 수 length 값을 작성합니다.  </span></span><br><span class=\"line\"><span class=\"comment\">// 이 형태가 Array-like (유사 배열)입니다.   </span></span><br><span class=\"line\"> length: <span class=\"number\">3</span>&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> values)&#123; <span class=\"comment\">//  for-in  </span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, <span class=\"string\">':'</span>, values[key]);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k = <span class=\"number\">0</span>; k &lt; values.length; k++)&#123; <span class=\"comment\">// for()  </span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(values[k]);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">/*실행결과  </span></span><br><span class=\"line\"><span class=\"comment\">--------------  </span></span><br><span class=\"line\"><span class=\"comment\">for-in  </span></span><br><span class=\"line\"><span class=\"comment\">0 : zero  </span></span><br><span class=\"line\"><span class=\"comment\">1 : one  </span></span><br><span class=\"line\"><span class=\"comment\">2 : two  </span></span><br><span class=\"line\"><span class=\"comment\">length : 3  </span></span><br><span class=\"line\"><span class=\"comment\">--------------  </span></span><br><span class=\"line\"><span class=\"comment\">for()  </span></span><br><span class=\"line\"><span class=\"comment\">zero  </span></span><br><span class=\"line\"><span class=\"comment\">one  </span></span><br><span class=\"line\"><span class=\"comment\">two  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>for-in 문은 Object 오브젝트를 전개할 때 사용합니다.<br>for-in 문으로 valuse 오브젝트를 전개하면 length 프로퍼티도 같이 전개됩니다.<br>즉, for-in문으로 Array-like를 전개한다면 length 프로퍼티를 제외시키는 처리가 필요합니다.</p>\n</li>\n<li><p><strong>배열을 전개할 때는 주로 for()문을 사용합니다.</strong><br>for()문으로 values 오브젝트를 전개해도 length프로퍼티가 전개되지 않습니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"유사배열은-배열-메서드를-사용할-수-없습니다\"><a href=\"#유사배열은-배열-메서드를-사용할-수-없습니다\" class=\"headerlink\" title=\"유사배열은 배열 메서드를 사용할 수 없습니다.\"></a>유사배열은 배열 메서드를 사용할 수 없습니다.</h3><p>일반적으로 유사배열은 배열이 아니므로 배열 메서드를 사용할 수 없습니다.<br>이럴 때 메서드를 빌려와 유사배열에도 배열 메서드를 사용할 수 있는 방법은</p>\n<p><mark>apply, call, form등 을 이용해 Array 메소드를 가져와 쓰는 경우가 있습니다.</mark></p>\n","site":{"data":{}},"excerpt":"<hr>\n<h2 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h2><p>스프레드(Spread) 연산자는 이터러블 오브젝트의 엘리먼트를 하나씩 분리하여 전개합니다.</p>\n<p>전개한 결과를 변수에 할당하거나 호출하는 함수의 파라미터 값으로 사용할 수 있습니다.</p>\n<ul>\n<li>기본형</li>\n</ul>\n<blockquote>\n<p>[…iterableObject]</p>\n</blockquote>\n<ul>\n<li>function에서</li>\n</ul>\n<blockquote>\n<p>function(…iterableObject);</p>\n</blockquote>\n<ul>\n<li>array에서</li>\n</ul>\n<blockquote>\n<p>[…iterableObj, ‘4’, ‘five’, 6];</p>\n</blockquote>\n<ul>\n<li>object 에서</li>\n</ul>\n<blockquote>\n<p>let objClone = { …obj };<br>//ECMAScript 2018에서 추가되었습니다.</p>\n</blockquote>\n<p>spread 연산자는 “…”을 작성하고 뒤에 이터러블 오브젝트를 작성합니다.</p>","more":"<hr>\n<h3 id=\"1-배열\"><a href=\"#1-배열\" class=\"headerlink\" title=\"1. 배열\"></a>1. 배열</h3><p>[] 대괄호 안에 spread 연산자로 배열을 작성한 형태.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = [<span class=\"number\">11</span>, <span class=\"number\">12</span>];  </span><br><span class=\"line\"><span class=\"keyword\">let</span> two = [<span class=\"number\">21</span>, <span class=\"number\">22</span>];  </span><br><span class=\"line\"><span class=\"keyword\">let</span> spreadObj = [<span class=\"number\">51</span>, ...one, <span class=\"number\">52</span>, ...two];  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(spreadObj);   </span><br><span class=\"line\"><span class=\"comment\">/*   </span></span><br><span class=\"line\"><span class=\"comment\">0: 51  </span></span><br><span class=\"line\"><span class=\"comment\">1: 11  </span></span><br><span class=\"line\"><span class=\"comment\">2: 12  </span></span><br><span class=\"line\"><span class=\"comment\">3: 52  </span></span><br><span class=\"line\"><span class=\"comment\">4: 21  </span></span><br><span class=\"line\"><span class=\"comment\">5: 22  </span></span><br><span class=\"line\"><span class=\"comment\">= [51, 11, 12, 52, 21, 22]  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(spreadObj.length); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>one 배열의 엘리멘트 [11, 12]에서 11과 12가 분리된 후,<br>spreadObj = [51, …one, 52, …two];에 …one위치에 설정됩니다.<br>two 배열역시 같은방식으로 spreadObj에 설정되고<br>[51, 11, 12, 52, 21, 22] 형태로 spreadObj에 할당됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li>spreadObj의 length 값은 6이 됩니다.<br>(one 과 two 배열의 엘리멘트가 분리되어 할당되었기 때문)<br>엘리멘트가 분리되지 않고 할당되었다면 length 값은 4가 돼야 합니다.</li>\n</ol>\n<hr>\n<h3 id=\"2-문자열\"><a href=\"#2-문자열\" class=\"headerlink\" title=\"2. 문자열\"></a>2. 문자열</h3><p>[] 대괄호 안에 spread 연산자로 문자열을 작성한 형태.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> spreadObj = [...<span class=\"string\">\"music\"</span>];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(spreadObj);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">0: \"m\"  </span></span><br><span class=\"line\"><span class=\"comment\">1: \"u\"  </span></span><br><span class=\"line\"><span class=\"comment\">2: \"s\"  </span></span><br><span class=\"line\"><span class=\"comment\">3: \"i\"  </span></span><br><span class=\"line\"><span class=\"comment\">4: \"c\"  </span></span><br><span class=\"line\"><span class=\"comment\">= [\"m\", \"u\", \"s\", \"i\", \"c\"]  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(spreadObj.length); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"3-함수-파라미터\"><a href=\"#3-함수-파라미터\" class=\"headerlink\" title=\"3. 함수 파라미터\"></a>3. 함수 파라미터</h3><p>호출하는 함수의 파라미터 값을 spread 연산자로 작성하면,<br><strong>함수를 호출하기 전에 파라미터 값을 분리, 전개합니다.</strong><br>호출받는 함수의 파라미터에 이름을 작성하면 각 엘리먼트 값이 파라미터 이름에 설정됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> values = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>];  </span><br><span class=\"line\"><span class=\"keyword\">get</span>(...values); // 10, 20, 30 으로 각각 분리됩니다.  </span><br><span class=\"line\">  </span><br><span class=\"line\">function <span class=\"keyword\">get</span>(one, two, three)&#123;  </span><br><span class=\"line\"> <span class=\"comment\">/* 호출받은 함수 파라미터에  </span></span><br><span class=\"line\"><span class=\"comment\"> one: 10  </span></span><br><span class=\"line\"><span class=\"comment\"> two: 20  </span></span><br><span class=\"line\"><span class=\"comment\"> three: 30 이 설정됩니다.  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log( one + two + three); <span class=\"comment\">// 60  </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>함수의 파라미터 값이 분리된 형태를 spread 파라미터 라고 합니다.</p>\n<hr>\n<h2 id=\"rest-파라미터\"><a href=\"#rest-파라미터\" class=\"headerlink\" title=\"rest 파라미터\"></a>rest 파라미터</h2><p>function(…rest)와 같이 함수 파라미터에 spread연산자로 파라미터를 작성한 형태를 rest파라미터 라고 합니다.</p>\n<blockquote>\n<p>function(param, paramN, …rest);</p>\n</blockquote>\n<hr>\n<p>호출하는 함수의 파라미터에 3개의 파라미터 값을 작성하고<br>호출받는 함수의 파라미터에 파라미터 이름을 하나만 작성하면<br>나머지 2개의 파라미터 값이 설정되지 않습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>...rest 미사용</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">get</span> = (one) =&gt; &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(one);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">get</span>(...[1, 2, 3]); // 1</span><br></pre></td></tr></table></figure>\n\n<p>get(…[1, 2, 3])이 get(1, 2, 3)형태로 전개되고<br>파라미터 one에 1 값이 설정됨.<br>호출받는 get()함수가 화살표 함수이므로<br>호출한 get(…[1, 2, 3]) 함수에서 보낸 파라미터가 arguments에 설정되지 않음.<br>따라서 [1, 2, 3]에서 2,3을 받지 못하게 됩니다.</p>\n<hr>\n<figure class=\"highlight js\"><figcaption><span>...rest 사용시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">get</span> = (...numRest) =&gt; &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(numRest); <span class=\"comment\">// [1, 2, 3]  </span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.isArray(numRest));<span class=\"comment\">// 배열 인지 확인해주는 메서드 true  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">get</span>(...[1, 2, 3]);</span><br></pre></td></tr></table></figure>\n\n<p><strong>rest 파라미터는 get(1, 2, 3) 형태로 호출된 파라미터 값을 배열의 엘리멘트로 설정합니다.(함수 안에서 numRest에 설정된 값을 배열로 사용할 수 있습니다.)</strong></p>\n<hr>\n<figure class=\"highlight js\"><figcaption><span>한개의 값만 설정 하고 rest 사용시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">get</span> = (one, ...rest) =&gt; &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(one); <span class=\"comment\">// 1  </span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(rest); <span class=\"comment\">// [2, 3]  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">get</span>(...[1, 2, 3]);</span><br></pre></td></tr></table></figure>\n\n<p>get(1, 2, 3) 형태로 호출되어 파라미터 one에 1값 설정됨.<br>나머지 2,3은 rest파라미터에 [2, 3]형태로 설정됩니다.</p>\n<hr>\n<h2 id=\"spread와-rest-파라미터-구분\"><a href=\"#spread와-rest-파라미터-구분\" class=\"headerlink\" title=\"spread와 rest 파라미터 구분\"></a>spread와 rest 파라미터 구분</h2><p><code>(...)형태는 같지만 기능이 다르므로 구분해야 합니다.</code></p>\n<ul>\n<li><p>spread 파라미터는<br><u>호출하는 함수의 파라미터</u>에 사용하며 Array( 배열[] )를 엘리먼트 단위로 전개합니다.</p>\n</li>\n<li><p>rest 파라미터는<br><u>호출받는 함수의 파라미터</u>에 사용합니다.<br><strong>호출하는 함수의 파라미터 순서에 맞춰 호출받는 파라미터에 값을 설정합니다.</strong><br>설정되지 못하고 남은 파라미터 값은 배열의 엘리먼트로 설정합니다.</p>\n</li>\n</ul>\n<p><code>spread는 배열을 엘리먼트로 분리,전개. rest는 전개된 엘리먼트를 다시 배열에 설정.</code></p>\n<hr>\n<h2 id=\"Array-like-유사배열\"><a href=\"#Array-like-유사배열\" class=\"headerlink\" title=\"Array-like (유사배열)\"></a>Array-like (유사배열)</h2><p>배열은 아니지만 배열처럼 사용할 수 있는 Object를 Array-like(혹은 유사배열 객체)라고 합니다.</p>\n<p>배열은 인덱스(index)를 갖고 있어 인덱스 순서대로 읽을 수 있으며,<br>인덱스 번호를 이용해 엘리먼트 값을 수정, 삭제할 수 있습니다.</p>\n<ul>\n<li><p>Object의 {key:values}형태를 배열도 object라는 점을 이용한<br>Array(배열) 처럼 사용 하는 트릭입니다.</p>\n</li>\n<li><p>Object의 프로퍼티 “key” 를 Array의 index 처럼 사용하고<br>value[key] 형태로 프로퍼티를 읽어올 수 있습니다.</p>\n</li>\n<li><p>Object의 value(프로퍼티 값)은 Array의 엘리먼트 처럼 사용합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> values = &#123;  </span><br><span class=\"line\"><span class=\"comment\">// &#123;key:value&#125;  </span></span><br><span class=\"line\"> <span class=\"number\">0</span>: <span class=\"string\">\"zero\"</span>,  </span><br><span class=\"line\"> <span class=\"number\">1</span>: <span class=\"string\">\"one\"</span>,   </span><br><span class=\"line\"> <span class=\"number\">2</span>: <span class=\"string\">\"two\"</span>,  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// &#123;key:value&#125; 형태에 맞추어 object전체 수 length 값을 작성합니다.  </span></span><br><span class=\"line\"><span class=\"comment\">// 이 형태가 Array-like (유사 배열)입니다.   </span></span><br><span class=\"line\"> length: <span class=\"number\">3</span>&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> values)&#123; <span class=\"comment\">//  for-in  </span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key, <span class=\"string\">':'</span>, values[key]);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k = <span class=\"number\">0</span>; k &lt; values.length; k++)&#123; <span class=\"comment\">// for()  </span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(values[k]);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">/*실행결과  </span></span><br><span class=\"line\"><span class=\"comment\">--------------  </span></span><br><span class=\"line\"><span class=\"comment\">for-in  </span></span><br><span class=\"line\"><span class=\"comment\">0 : zero  </span></span><br><span class=\"line\"><span class=\"comment\">1 : one  </span></span><br><span class=\"line\"><span class=\"comment\">2 : two  </span></span><br><span class=\"line\"><span class=\"comment\">length : 3  </span></span><br><span class=\"line\"><span class=\"comment\">--------------  </span></span><br><span class=\"line\"><span class=\"comment\">for()  </span></span><br><span class=\"line\"><span class=\"comment\">zero  </span></span><br><span class=\"line\"><span class=\"comment\">one  </span></span><br><span class=\"line\"><span class=\"comment\">two  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>for-in 문은 Object 오브젝트를 전개할 때 사용합니다.<br>for-in 문으로 valuse 오브젝트를 전개하면 length 프로퍼티도 같이 전개됩니다.<br>즉, for-in문으로 Array-like를 전개한다면 length 프로퍼티를 제외시키는 처리가 필요합니다.</p>\n</li>\n<li><p><strong>배열을 전개할 때는 주로 for()문을 사용합니다.</strong><br>for()문으로 values 오브젝트를 전개해도 length프로퍼티가 전개되지 않습니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"유사배열은-배열-메서드를-사용할-수-없습니다\"><a href=\"#유사배열은-배열-메서드를-사용할-수-없습니다\" class=\"headerlink\" title=\"유사배열은 배열 메서드를 사용할 수 없습니다.\"></a>유사배열은 배열 메서드를 사용할 수 없습니다.</h3><p>일반적으로 유사배열은 배열이 아니므로 배열 메서드를 사용할 수 없습니다.<br>이럴 때 메서드를 빌려와 유사배열에도 배열 메서드를 사용할 수 있는 방법은</p>\n<p><mark>apply, call, form등 을 이용해 Array 메소드를 가져와 쓰는 경우가 있습니다.</mark></p>"},{"title":"Strict mode -ECMAScript","date":"2020-03-16T01:04:46.000Z","disqusId":"tunas-blog-1","_content":"\n* * *\n\n### Strict mode\n\n`strict mode`는  \nJavaScript 코드가 “엄격 모드”에서 실행되도록 정의합니다.\n\n“strict mode”지시문은 ECMAScript 버전 5에서 새로 추가되었습니다.\n\nIE9 이하를 제외한 모든 최신 브라우저는 `strict mode`를 지원합니다.\n\n가끔 엄격하지 않은 기본값을  \n“느슨한 모드(sloppy mode)”라고 부르기도 합니다.  \n공식적인 용어는 아니지만 혹시 모르니 알아두세요.\n\n`\"strict mode\"지시문은 script 나 function의 시작 부분에서만 인식됩니다.`\n\n<!-- more -->\n\n*   전체 스크립트 적용 구문\n\n```js\n//스크립트 파일 첫번째 줄  \n\"use strict\";  \n```\n\n*   function에 적용하는 구문\n\n```js\nfunction strict() {  \n // 함수-레벨 strict mode 문법  \n \"use strict\";  \n```\n\n* * *\n\n#### 1.  strict mode를 사용하면 선언되지 않은 변수를 사용할 수 없습니다.\n\n```js\n\"use strict\";  \nmyFunction();  \n  \nfunction myFunction() {  \n x = 3.14; // x를 선언해 주지 않았기 때문에 오류가 발생합니다.  \n}  \ny= 3; // y역시 선언되지 않았기에 오류가 발생합니다.  \n```\n\nstrict mode는 이전에 허용 된 “잘못된 구문”을 실제 오류로 변경합니다.\n\n또한 선언되지 않은 변수를 사용하지 못하게하는 것과 같이  \n더 깨끗한 코드를 작성하는 데 도움이됩니다.  \n“strict mode”는 문자열이므로 IE 9는 이해하지 않아도 오류를 발생시키지 않습니다.\n\n예를 들어,  \n일반적인 JavaScript에서 변수 이름을 잘못 입력하면 새로운 전역 변수가 만들어집니다.  \n`strict mode에서는 실수로 전역 변수를 만들 수 없습니다.`\n\n* * *\n\n#### 2.  NaN 은 쓸 수 없는 전역 변수입니다.  \n\nNaN 에 할당하는 일반적인 코드는 아무 것도 하지 않습니다.  \n개발자도 아무런 실패 피드백을 받지 않습니다.\n\n엄격 모드에서 NaN 에 할당하는 것은 예외를 발생시킵니다.  \n일반 코드에서 조용히 넘어가는 모든 실패에 대해 (쓸 수 없는 전역 또는 프로퍼티에 할당, getter-only 프로퍼티에 할당, 확장 불가 객체에 새 프로퍼티 할당) 엄격 모드에서는 예외를 발생시킵니다.\n\n```js\n\"use strict\";  \n  \n// 쓸 수 없는 프로퍼티에 할당  \nvar undefined = 5; // TypeError 발생  \nvar Infinity = 5; // TypeError 발생  \n  \n// 쓸 수 없는 프로퍼티에 할당  \nvar obj1 = {};  \nObject.defineProperty(obj1, \"x\", { value: 42, writable: false });  \nobj1.x = 9; // TypeError 발생  \n  \n// getter-only 프로퍼티에 할당  \nvar obj2 = { get x() { return 17; } };  \nobj2.x = 5; // TypeError 발생  \n  \n// 확장 불가 객체에 새 프로퍼티 할당  \nvar fixed = {};  \nObject.preventExtensions(fixed);  \nfixed.newProp = \"ohai\"; // TypeError 발생  \n```\n\n* * *\n\n#### 3. 엄격 모드는 삭제할 수 없는 프로퍼티를 삭제하려할 때 예외를 발생시킵니다.  \n\n(시도가 어떤 효과도 없을 때).\n\n```js\n\"use strict\";  \ndelete Object.prototype; // TypeError 발생  \n```\n\n* * *\n\n#### 4. 또한 function 삭제도 허용하지 않습니다.\n\n```js\n\"use strict\";  \nfunction x(p1, p2) {};  \ndelete x;        // error  \n```\n\n* * *\n\n#### 5.  엄격모드는 유니크한 함수 파라미터 이름을 요구합니다. \n\n일반 코드에서는 마지막으로 중복된 인수가 이전에 지정된 인수를 숨깁니다. \n\n이러한 이전의 인수들은 `arguments[i]` 를 통해 여전히 남아 있을 수 있으므로, \n완전히 접근 불가한 것이 아닙니다. 여전히, 이런 숨김 처리는 이치에 맞지 않으며 원했던 것이 아닐 수 있습니다(예를 들면 오타를 숨길 수도 있습니다). \n\n따라서 엄격 모드에서는 중복 인수명은 구문 에러입니다.\n\n```js 예시1\n\"use strict\";  \nfunction x(p1, p1) {};   // !!! 구문 에러  \n```\n\n```js 예시2\nfunction sum(a, a, c){ // !!! 구문 에러  \n \"use strict\";  \n return a + b + c; // 코드가 실행되면 잘못된 것임  \n}  \n```\n\n* * *\n\n#### 6.  ECMAScript5 에서의 엄격 모드는 8진수 구문을 금지합니다.\n\n8진수 구문은 ES5의 문법이 아니지만,  \n모든 브라우저에서 앞에 0을 붙여 지원됩니다(0644 === 420 와 “045” === “%”).\n\n`ECMAScript 2015 에서는 접두사 \"0o\"를 붙여 8진수를 지원합니다.`\n\n```js\nvar a = 0o10; // ES6: 8진수  \n```\n\n초보 개발자들은 가끔 앞에 붙은 0 이 무의미하다고 생각하여, 이를 정렬용으로 사용합니다 — 하지만 이는 숫자의 의미를 바꿔버립니다.  \n이 8진수 문법은 거의 무용하며 잘못 사용될 수 있으므로 엄격모드에서 이 구문은 에러입니다.\n\n```js\n\"use strict\";  \nvar sum = 015 + // !!! 구문 에러  \n 197 +  \n 142;  \n```\n  \n------------------  \n#### 7. ECMAScript6 의 엄격모드는 primitive 값에 프로퍼티를 설정하는 것을 금지합니다. \n\n엄격모드가 아닐 때에는 프로퍼티 설정이 간단하게 무시되지만(no-op), \n엄격모드에서는 `TypeError` 를 발생시킵니다.  \n  \n```javascript  \n(function() {  \n\"use strict\";  \n  \nfalse.true = \"\";         // TypeError  \n(14).sailing = \"home\";   // TypeError  \n\"with\".you = \"far away\"; // TypeError  \n})();  \n```\n\n`primitive`: 원시값 또는 원시 자료형  \n객체도 아니고 메서드도 아닌 데이터입니다.  \n`string`, `number`, `bigint`, `boolean`, `null`, `undefined`, `symbol`  \n7가지 원시 자료형이 존재 합니다.\n\n<mark>모든 원시 값은 불변합니다. 즉, 변형할 수 없습니다. 원시값 자체와, 원시값을 할당한 변수를 혼동하지 않는 것이 중요합니다. 변수는 새로운 값을 다시 할당할 수 있지만, 이미 생성한 원시값은 객체, 배열, 함수와는 달리 변형할 수 없습니다.</mark>\n\n```js 원시값 예시\n// 문자열 메서드는 문자열을 변형하지 않음  \nvar bar = \"baz\";  \nconsole.log(bar);        // baz  \nbar.toUpperCase();  \nconsole.log(bar);        // baz  \n  \n// 배열 메소드는 배열을 변형함  \nvar foo = [];  \nconsole.log(foo);        // []  \nfoo.push(\"plugh\");  \nconsole.log(foo);        // [\"plugh\"]  \n  \n// 할당은 원시 값에 새로운 값을 부여 (변형이 아님)  \nbar = bar.toUpperCase(); // BAZ  \n```\n\n`원시 값을 교체할 수는 있지만, 직접 변형할 수는 없습니다.`\n\n``` js 원시형 코드 실행 과정\n// 원시값  \nlet foo = 5;  \n  \n// 원시값을 변경해야 하는 함수 정의  \nfunction addTwo(num) {  \n num += 2;  \n}  \n// 같은 작업을 시도하는 다른 함수  \nfunction addTwo_v2(foo) {  \n foo += 2;  \n}  \n  \n// 원시값을 인수로 전달해 첫 번째 함수를 호출  \naddTwo(foo);  \n// 현재 원시값 반환  \nconsole.log(foo);   // 5  \n  \n// 두 번째 함수로 다시 시도  \naddTwo_v2(foo);  \nconsole.log(foo);   // 5  \n```\n\n5 대신 7 일 것이라고 예상하였나요?  \n그렇다면, 이 코드의 실행 과정을 살펴보세요.\n\n1.  `addTwo` 와 `addTwo_v2` 함수 호출을 위해, JavaScript는 `식별자 foo` 의 값을 찾습니다. 이는 인스턴스화된 첫 번째 구문의 변수를 올바르게 찾습니다.\n    \n2.  찾은 다음, JavaScript는 `인수를 함수의 매개변수`로서 전달합니다.\n    \n3.  함수의 본문 내 구문들을 실행하기 전에, JavaScript는 원래 전달된 `인수(원시 값)를 복사해 로컬 복사본`을 생성합니다. 이러한 `복사본은 함수의 스코프 내에서만 존재하며`, 함수 정의 내에 `지정한 식별자`를 통해 접근가능합니다(`addTwo 의 num`, `addTwo_v2 의 foo`).\n    \n4.  그 후, 함수의 구문들이 실행됩니다.  \n    4-1. 첫 번째 함수내에서, 로컬 `num` 인수가 생성되었습니다. 이 값을 2 증가시키는 것이며, 원래 `foo` 의 값이 아닙니다!\n    \n    4-2. 두 번째 함수내에서, `로컬 foo` 인수가 생성되었습니다. 이 값을 2 증가시키는 것이며, 원래(외부) `foo` 의 값이 아닙니다! 또한, 이 경우에서, `외부 foo` 변수에는 어떤 방법으로든 접근할 수 없습니다. 이는 자바스크립트의 어휘적 유효 범위(`lexical scoping`)와 결과 변수 섀도잉 때문입니다. `로컬 foo` 는 `외부 foo` 를 숨깁니다.\n    \n\n<mark>결과적으로, 우리 함수들 내부의 모든 변경은 그 복사본으로 작업하였기 때문에, 원본 foo 에 전혀 영향을 주지 않았습니다.</mark>\n\n이것이 `원시값이 변하지 않는 이유`입니다. 원시값에 직접 작업하지 않으므로, 원본을 건드리지 않고 복사본 가져와 계속 작업을 합니다.\n\n* * *\n\n#### 8. function의 this키워드는 엄격모드에서 다르게 작동합니다.\n\n`this` 키워드는 함수를 호출 한 객체를 나타냅니다.  \n객체를 지정하지 않으면 엄격 모드의 `function`은 `undefined`로 반환됩니다.\n\n```js\n\"use strict\";  \nfunction myFunction() {  \n alert(this); // will alert \"undefined\"  \n}  \nmyFunction();  \n```","source":"_posts/Strict mode -ECMAScript.md","raw":"---\ntitle: Strict mode -ECMAScript\ndate: 2020-03-16 10:04:46\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n* * *\n\n### Strict mode\n\n`strict mode`는  \nJavaScript 코드가 “엄격 모드”에서 실행되도록 정의합니다.\n\n“strict mode”지시문은 ECMAScript 버전 5에서 새로 추가되었습니다.\n\nIE9 이하를 제외한 모든 최신 브라우저는 `strict mode`를 지원합니다.\n\n가끔 엄격하지 않은 기본값을  \n“느슨한 모드(sloppy mode)”라고 부르기도 합니다.  \n공식적인 용어는 아니지만 혹시 모르니 알아두세요.\n\n`\"strict mode\"지시문은 script 나 function의 시작 부분에서만 인식됩니다.`\n\n<!-- more -->\n\n*   전체 스크립트 적용 구문\n\n```js\n//스크립트 파일 첫번째 줄  \n\"use strict\";  \n```\n\n*   function에 적용하는 구문\n\n```js\nfunction strict() {  \n // 함수-레벨 strict mode 문법  \n \"use strict\";  \n```\n\n* * *\n\n#### 1.  strict mode를 사용하면 선언되지 않은 변수를 사용할 수 없습니다.\n\n```js\n\"use strict\";  \nmyFunction();  \n  \nfunction myFunction() {  \n x = 3.14; // x를 선언해 주지 않았기 때문에 오류가 발생합니다.  \n}  \ny= 3; // y역시 선언되지 않았기에 오류가 발생합니다.  \n```\n\nstrict mode는 이전에 허용 된 “잘못된 구문”을 실제 오류로 변경합니다.\n\n또한 선언되지 않은 변수를 사용하지 못하게하는 것과 같이  \n더 깨끗한 코드를 작성하는 데 도움이됩니다.  \n“strict mode”는 문자열이므로 IE 9는 이해하지 않아도 오류를 발생시키지 않습니다.\n\n예를 들어,  \n일반적인 JavaScript에서 변수 이름을 잘못 입력하면 새로운 전역 변수가 만들어집니다.  \n`strict mode에서는 실수로 전역 변수를 만들 수 없습니다.`\n\n* * *\n\n#### 2.  NaN 은 쓸 수 없는 전역 변수입니다.  \n\nNaN 에 할당하는 일반적인 코드는 아무 것도 하지 않습니다.  \n개발자도 아무런 실패 피드백을 받지 않습니다.\n\n엄격 모드에서 NaN 에 할당하는 것은 예외를 발생시킵니다.  \n일반 코드에서 조용히 넘어가는 모든 실패에 대해 (쓸 수 없는 전역 또는 프로퍼티에 할당, getter-only 프로퍼티에 할당, 확장 불가 객체에 새 프로퍼티 할당) 엄격 모드에서는 예외를 발생시킵니다.\n\n```js\n\"use strict\";  \n  \n// 쓸 수 없는 프로퍼티에 할당  \nvar undefined = 5; // TypeError 발생  \nvar Infinity = 5; // TypeError 발생  \n  \n// 쓸 수 없는 프로퍼티에 할당  \nvar obj1 = {};  \nObject.defineProperty(obj1, \"x\", { value: 42, writable: false });  \nobj1.x = 9; // TypeError 발생  \n  \n// getter-only 프로퍼티에 할당  \nvar obj2 = { get x() { return 17; } };  \nobj2.x = 5; // TypeError 발생  \n  \n// 확장 불가 객체에 새 프로퍼티 할당  \nvar fixed = {};  \nObject.preventExtensions(fixed);  \nfixed.newProp = \"ohai\"; // TypeError 발생  \n```\n\n* * *\n\n#### 3. 엄격 모드는 삭제할 수 없는 프로퍼티를 삭제하려할 때 예외를 발생시킵니다.  \n\n(시도가 어떤 효과도 없을 때).\n\n```js\n\"use strict\";  \ndelete Object.prototype; // TypeError 발생  \n```\n\n* * *\n\n#### 4. 또한 function 삭제도 허용하지 않습니다.\n\n```js\n\"use strict\";  \nfunction x(p1, p2) {};  \ndelete x;        // error  \n```\n\n* * *\n\n#### 5.  엄격모드는 유니크한 함수 파라미터 이름을 요구합니다. \n\n일반 코드에서는 마지막으로 중복된 인수가 이전에 지정된 인수를 숨깁니다. \n\n이러한 이전의 인수들은 `arguments[i]` 를 통해 여전히 남아 있을 수 있으므로, \n완전히 접근 불가한 것이 아닙니다. 여전히, 이런 숨김 처리는 이치에 맞지 않으며 원했던 것이 아닐 수 있습니다(예를 들면 오타를 숨길 수도 있습니다). \n\n따라서 엄격 모드에서는 중복 인수명은 구문 에러입니다.\n\n```js 예시1\n\"use strict\";  \nfunction x(p1, p1) {};   // !!! 구문 에러  \n```\n\n```js 예시2\nfunction sum(a, a, c){ // !!! 구문 에러  \n \"use strict\";  \n return a + b + c; // 코드가 실행되면 잘못된 것임  \n}  \n```\n\n* * *\n\n#### 6.  ECMAScript5 에서의 엄격 모드는 8진수 구문을 금지합니다.\n\n8진수 구문은 ES5의 문법이 아니지만,  \n모든 브라우저에서 앞에 0을 붙여 지원됩니다(0644 === 420 와 “045” === “%”).\n\n`ECMAScript 2015 에서는 접두사 \"0o\"를 붙여 8진수를 지원합니다.`\n\n```js\nvar a = 0o10; // ES6: 8진수  \n```\n\n초보 개발자들은 가끔 앞에 붙은 0 이 무의미하다고 생각하여, 이를 정렬용으로 사용합니다 — 하지만 이는 숫자의 의미를 바꿔버립니다.  \n이 8진수 문법은 거의 무용하며 잘못 사용될 수 있으므로 엄격모드에서 이 구문은 에러입니다.\n\n```js\n\"use strict\";  \nvar sum = 015 + // !!! 구문 에러  \n 197 +  \n 142;  \n```\n  \n------------------  \n#### 7. ECMAScript6 의 엄격모드는 primitive 값에 프로퍼티를 설정하는 것을 금지합니다. \n\n엄격모드가 아닐 때에는 프로퍼티 설정이 간단하게 무시되지만(no-op), \n엄격모드에서는 `TypeError` 를 발생시킵니다.  \n  \n```javascript  \n(function() {  \n\"use strict\";  \n  \nfalse.true = \"\";         // TypeError  \n(14).sailing = \"home\";   // TypeError  \n\"with\".you = \"far away\"; // TypeError  \n})();  \n```\n\n`primitive`: 원시값 또는 원시 자료형  \n객체도 아니고 메서드도 아닌 데이터입니다.  \n`string`, `number`, `bigint`, `boolean`, `null`, `undefined`, `symbol`  \n7가지 원시 자료형이 존재 합니다.\n\n<mark>모든 원시 값은 불변합니다. 즉, 변형할 수 없습니다. 원시값 자체와, 원시값을 할당한 변수를 혼동하지 않는 것이 중요합니다. 변수는 새로운 값을 다시 할당할 수 있지만, 이미 생성한 원시값은 객체, 배열, 함수와는 달리 변형할 수 없습니다.</mark>\n\n```js 원시값 예시\n// 문자열 메서드는 문자열을 변형하지 않음  \nvar bar = \"baz\";  \nconsole.log(bar);        // baz  \nbar.toUpperCase();  \nconsole.log(bar);        // baz  \n  \n// 배열 메소드는 배열을 변형함  \nvar foo = [];  \nconsole.log(foo);        // []  \nfoo.push(\"plugh\");  \nconsole.log(foo);        // [\"plugh\"]  \n  \n// 할당은 원시 값에 새로운 값을 부여 (변형이 아님)  \nbar = bar.toUpperCase(); // BAZ  \n```\n\n`원시 값을 교체할 수는 있지만, 직접 변형할 수는 없습니다.`\n\n``` js 원시형 코드 실행 과정\n// 원시값  \nlet foo = 5;  \n  \n// 원시값을 변경해야 하는 함수 정의  \nfunction addTwo(num) {  \n num += 2;  \n}  \n// 같은 작업을 시도하는 다른 함수  \nfunction addTwo_v2(foo) {  \n foo += 2;  \n}  \n  \n// 원시값을 인수로 전달해 첫 번째 함수를 호출  \naddTwo(foo);  \n// 현재 원시값 반환  \nconsole.log(foo);   // 5  \n  \n// 두 번째 함수로 다시 시도  \naddTwo_v2(foo);  \nconsole.log(foo);   // 5  \n```\n\n5 대신 7 일 것이라고 예상하였나요?  \n그렇다면, 이 코드의 실행 과정을 살펴보세요.\n\n1.  `addTwo` 와 `addTwo_v2` 함수 호출을 위해, JavaScript는 `식별자 foo` 의 값을 찾습니다. 이는 인스턴스화된 첫 번째 구문의 변수를 올바르게 찾습니다.\n    \n2.  찾은 다음, JavaScript는 `인수를 함수의 매개변수`로서 전달합니다.\n    \n3.  함수의 본문 내 구문들을 실행하기 전에, JavaScript는 원래 전달된 `인수(원시 값)를 복사해 로컬 복사본`을 생성합니다. 이러한 `복사본은 함수의 스코프 내에서만 존재하며`, 함수 정의 내에 `지정한 식별자`를 통해 접근가능합니다(`addTwo 의 num`, `addTwo_v2 의 foo`).\n    \n4.  그 후, 함수의 구문들이 실행됩니다.  \n    4-1. 첫 번째 함수내에서, 로컬 `num` 인수가 생성되었습니다. 이 값을 2 증가시키는 것이며, 원래 `foo` 의 값이 아닙니다!\n    \n    4-2. 두 번째 함수내에서, `로컬 foo` 인수가 생성되었습니다. 이 값을 2 증가시키는 것이며, 원래(외부) `foo` 의 값이 아닙니다! 또한, 이 경우에서, `외부 foo` 변수에는 어떤 방법으로든 접근할 수 없습니다. 이는 자바스크립트의 어휘적 유효 범위(`lexical scoping`)와 결과 변수 섀도잉 때문입니다. `로컬 foo` 는 `외부 foo` 를 숨깁니다.\n    \n\n<mark>결과적으로, 우리 함수들 내부의 모든 변경은 그 복사본으로 작업하였기 때문에, 원본 foo 에 전혀 영향을 주지 않았습니다.</mark>\n\n이것이 `원시값이 변하지 않는 이유`입니다. 원시값에 직접 작업하지 않으므로, 원본을 건드리지 않고 복사본 가져와 계속 작업을 합니다.\n\n* * *\n\n#### 8. function의 this키워드는 엄격모드에서 다르게 작동합니다.\n\n`this` 키워드는 함수를 호출 한 객체를 나타냅니다.  \n객체를 지정하지 않으면 엄격 모드의 `function`은 `undefined`로 반환됩니다.\n\n```js\n\"use strict\";  \nfunction myFunction() {  \n alert(this); // will alert \"undefined\"  \n}  \nmyFunction();  \n```","slug":"Strict mode -ECMAScript","published":1,"updated":"2020-05-06T13:11:57.133Z","_id":"ck9iqcrsq001hqgvqegyw736o","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<h3 id=\"Strict-mode\"><a href=\"#Strict-mode\" class=\"headerlink\" title=\"Strict mode\"></a>Strict mode</h3><p><code>strict mode</code>는<br>JavaScript 코드가 “엄격 모드”에서 실행되도록 정의합니다.</p>\n<p>“strict mode”지시문은 ECMAScript 버전 5에서 새로 추가되었습니다.</p>\n<p>IE9 이하를 제외한 모든 최신 브라우저는 <code>strict mode</code>를 지원합니다.</p>\n<p>가끔 엄격하지 않은 기본값을<br>“느슨한 모드(sloppy mode)”라고 부르기도 합니다.<br>공식적인 용어는 아니지만 혹시 모르니 알아두세요.</p>\n<p><code>&quot;strict mode&quot;지시문은 script 나 function의 시작 부분에서만 인식됩니다.</code></p>\n<a id=\"more\"></a>\n\n<ul>\n<li>전체 스크립트 적용 구문</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//스크립트 파일 첫번째 줄  </span></span><br><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>function에 적용하는 구문</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">strict</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"comment\">// 함수-레벨 strict mode 문법  </span></span><br><span class=\"line\"><span class=\"meta\"> \"use strict\"</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"1-strict-mode를-사용하면-선언되지-않은-변수를-사용할-수-없습니다\"><a href=\"#1-strict-mode를-사용하면-선언되지-않은-변수를-사용할-수-없습니다\" class=\"headerlink\" title=\"1.  strict mode를 사용하면 선언되지 않은 변수를 사용할 수 없습니다.\"></a>1.  strict mode를 사용하면 선언되지 않은 변수를 사용할 수 없습니다.</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\">myFunction();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> x = <span class=\"number\">3.14</span>; <span class=\"comment\">// x를 선언해 주지 않았기 때문에 오류가 발생합니다.  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">y= <span class=\"number\">3</span>; <span class=\"comment\">// y역시 선언되지 않았기에 오류가 발생합니다.</span></span><br></pre></td></tr></table></figure>\n\n<p>strict mode는 이전에 허용 된 “잘못된 구문”을 실제 오류로 변경합니다.</p>\n<p>또한 선언되지 않은 변수를 사용하지 못하게하는 것과 같이<br>더 깨끗한 코드를 작성하는 데 도움이됩니다.<br>“strict mode”는 문자열이므로 IE 9는 이해하지 않아도 오류를 발생시키지 않습니다.</p>\n<p>예를 들어,<br>일반적인 JavaScript에서 변수 이름을 잘못 입력하면 새로운 전역 변수가 만들어집니다.<br><code>strict mode에서는 실수로 전역 변수를 만들 수 없습니다.</code></p>\n<hr>\n<h4 id=\"2-NaN-은-쓸-수-없는-전역-변수입니다\"><a href=\"#2-NaN-은-쓸-수-없는-전역-변수입니다\" class=\"headerlink\" title=\"2.  NaN 은 쓸 수 없는 전역 변수입니다.\"></a>2.  NaN 은 쓸 수 없는 전역 변수입니다.</h4><p>NaN 에 할당하는 일반적인 코드는 아무 것도 하지 않습니다.<br>개발자도 아무런 실패 피드백을 받지 않습니다.</p>\n<p>엄격 모드에서 NaN 에 할당하는 것은 예외를 발생시킵니다.<br>일반 코드에서 조용히 넘어가는 모든 실패에 대해 (쓸 수 없는 전역 또는 프로퍼티에 할당, getter-only 프로퍼티에 할당, 확장 불가 객체에 새 프로퍼티 할당) 엄격 모드에서는 예외를 발생시킵니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 쓸 수 없는 프로퍼티에 할당  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"literal\">undefined</span> = <span class=\"number\">5</span>; <span class=\"comment\">// TypeError 발생  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"literal\">Infinity</span> = <span class=\"number\">5</span>; <span class=\"comment\">// TypeError 발생  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 쓸 수 없는 프로퍼티에 할당  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj1, <span class=\"string\">\"x\"</span>, &#123; <span class=\"attr\">value</span>: <span class=\"number\">42</span>, <span class=\"attr\">writable</span>: <span class=\"literal\">false</span> &#125;);  </span><br><span class=\"line\">obj1.x = <span class=\"number\">9</span>; <span class=\"comment\">// TypeError 발생  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// getter-only 프로퍼티에 할당  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; <span class=\"keyword\">get</span> x() &#123; <span class=\"keyword\">return</span> <span class=\"number\">17</span>; &#125; &#125;;  </span><br><span class=\"line\">obj2.x = <span class=\"number\">5</span>; <span class=\"comment\">// TypeError 발생  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 확장 불가 객체에 새 프로퍼티 할당  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fixed = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">Object</span>.preventExtensions(fixed);  </span><br><span class=\"line\">fixed.newProp = <span class=\"string\">\"ohai\"</span>; <span class=\"comment\">// TypeError 발생</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"3-엄격-모드는-삭제할-수-없는-프로퍼티를-삭제하려할-때-예외를-발생시킵니다\"><a href=\"#3-엄격-모드는-삭제할-수-없는-프로퍼티를-삭제하려할-때-예외를-발생시킵니다\" class=\"headerlink\" title=\"3. 엄격 모드는 삭제할 수 없는 프로퍼티를 삭제하려할 때 예외를 발생시킵니다.\"></a>3. 엄격 모드는 삭제할 수 없는 프로퍼티를 삭제하려할 때 예외를 발생시킵니다.</h4><p>(시도가 어떤 효과도 없을 때).</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// TypeError 발생</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"4-또한-function-삭제도-허용하지-않습니다\"><a href=\"#4-또한-function-삭제도-허용하지-않습니다\" class=\"headerlink\" title=\"4. 또한 function 삭제도 허용하지 않습니다.\"></a>4. 또한 function 삭제도 허용하지 않습니다.</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">x</span>(<span class=\"params\">p1, p2</span>) </span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">delete</span> x;        <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"5-엄격모드는-유니크한-함수-파라미터-이름을-요구합니다\"><a href=\"#5-엄격모드는-유니크한-함수-파라미터-이름을-요구합니다\" class=\"headerlink\" title=\"5.  엄격모드는 유니크한 함수 파라미터 이름을 요구합니다.\"></a>5.  엄격모드는 유니크한 함수 파라미터 이름을 요구합니다.</h4><p>일반 코드에서는 마지막으로 중복된 인수가 이전에 지정된 인수를 숨깁니다. </p>\n<p>이러한 이전의 인수들은 <code>arguments[i]</code> 를 통해 여전히 남아 있을 수 있으므로,<br>완전히 접근 불가한 것이 아닙니다. 여전히, 이런 숨김 처리는 이치에 맞지 않으며 원했던 것이 아닐 수 있습니다(예를 들면 오타를 숨길 수도 있습니다). </p>\n<p>따라서 엄격 모드에서는 중복 인수명은 구문 에러입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>예시1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">x</span>(<span class=\"params\">p1, p1</span>) </span>&#123;&#125;;   <span class=\"comment\">// !!! 구문 에러</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>예시2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, a, c</span>)</span>&#123; <span class=\"comment\">// !!! 구문 에러  </span></span><br><span class=\"line\"><span class=\"meta\"> \"use strict\"</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> a + b + c; <span class=\"comment\">// 코드가 실행되면 잘못된 것임  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"6-ECMAScript5-에서의-엄격-모드는-8진수-구문을-금지합니다\"><a href=\"#6-ECMAScript5-에서의-엄격-모드는-8진수-구문을-금지합니다\" class=\"headerlink\" title=\"6.  ECMAScript5 에서의 엄격 모드는 8진수 구문을 금지합니다.\"></a>6.  ECMAScript5 에서의 엄격 모드는 8진수 구문을 금지합니다.</h4><p>8진수 구문은 ES5의 문법이 아니지만,<br>모든 브라우저에서 앞에 0을 붙여 지원됩니다(0644 === 420 와 “045” === “%”).</p>\n<p><code>ECMAScript 2015 에서는 접두사 &quot;0o&quot;를 붙여 8진수를 지원합니다.</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">0o10</span>; <span class=\"comment\">// ES6: 8진수</span></span><br></pre></td></tr></table></figure>\n\n<p>초보 개발자들은 가끔 앞에 붙은 0 이 무의미하다고 생각하여, 이를 정렬용으로 사용합니다 — 하지만 이는 숫자의 의미를 바꿔버립니다.<br>이 8진수 문법은 거의 무용하며 잘못 사용될 수 있으므로 엄격모드에서 이 구문은 에러입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"number\">015</span> + <span class=\"comment\">// !!! 구문 에러  </span></span><br><span class=\"line\"> <span class=\"number\">197</span> +  </span><br><span class=\"line\"> <span class=\"number\">142</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"7-ECMAScript6-의-엄격모드는-primitive-값에-프로퍼티를-설정하는-것을-금지합니다\"><a href=\"#7-ECMAScript6-의-엄격모드는-primitive-값에-프로퍼티를-설정하는-것을-금지합니다\" class=\"headerlink\" title=\"7. ECMAScript6 의 엄격모드는 primitive 값에 프로퍼티를 설정하는 것을 금지합니다.\"></a>7. ECMAScript6 의 엄격모드는 primitive 값에 프로퍼티를 설정하는 것을 금지합니다.</h4><p>엄격모드가 아닐 때에는 프로퍼티 설정이 간단하게 무시되지만(no-op),<br>엄격모드에서는 <code>TypeError</code> 를 발생시킵니다.  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"literal\">false</span>.true = <span class=\"string\">\"\"</span>;         <span class=\"comment\">// TypeError  </span></span><br><span class=\"line\">(<span class=\"number\">14</span>).sailing = <span class=\"string\">\"home\"</span>;   <span class=\"comment\">// TypeError  </span></span><br><span class=\"line\"><span class=\"string\">\"with\"</span>.you = <span class=\"string\">\"far away\"</span>; <span class=\"comment\">// TypeError  </span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p><code>primitive</code>: 원시값 또는 원시 자료형<br>객체도 아니고 메서드도 아닌 데이터입니다.<br><code>string</code>, <code>number</code>, <code>bigint</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>symbol</code><br>7가지 원시 자료형이 존재 합니다.</p>\n<p><mark>모든 원시 값은 불변합니다. 즉, 변형할 수 없습니다. 원시값 자체와, 원시값을 할당한 변수를 혼동하지 않는 것이 중요합니다. 변수는 새로운 값을 다시 할당할 수 있지만, 이미 생성한 원시값은 객체, 배열, 함수와는 달리 변형할 수 없습니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>원시값 예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 문자열 메서드는 문자열을 변형하지 않음  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"string\">\"baz\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar);        <span class=\"comment\">// baz  </span></span><br><span class=\"line\">bar.toUpperCase();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar);        <span class=\"comment\">// baz  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 배열 메소드는 배열을 변형함  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = [];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo);        <span class=\"comment\">// []  </span></span><br><span class=\"line\">foo.push(<span class=\"string\">\"plugh\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo);        <span class=\"comment\">// [\"plugh\"]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 할당은 원시 값에 새로운 값을 부여 (변형이 아님)  </span></span><br><span class=\"line\">bar = bar.toUpperCase(); <span class=\"comment\">// BAZ</span></span><br></pre></td></tr></table></figure>\n\n<p><code>원시 값을 교체할 수는 있지만, 직접 변형할 수는 없습니다.</code></p>\n<figure class=\"highlight js\"><figcaption><span>원시형 코드 실행 과정</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 원시값  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"number\">5</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 원시값을 변경해야 하는 함수 정의  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTwo</span>(<span class=\"params\">num</span>) </span>&#123;  </span><br><span class=\"line\"> num += <span class=\"number\">2</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// 같은 작업을 시도하는 다른 함수  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTwo_v2</span>(<span class=\"params\">foo</span>) </span>&#123;  </span><br><span class=\"line\"> foo += <span class=\"number\">2</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 원시값을 인수로 전달해 첫 번째 함수를 호출  </span></span><br><span class=\"line\">addTwo(foo);  </span><br><span class=\"line\"><span class=\"comment\">// 현재 원시값 반환  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo);   <span class=\"comment\">// 5  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 두 번째 함수로 다시 시도  </span></span><br><span class=\"line\">addTwo_v2(foo);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo);   <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p>5 대신 7 일 것이라고 예상하였나요?<br>그렇다면, 이 코드의 실행 과정을 살펴보세요.</p>\n<ol>\n<li><p><code>addTwo</code> 와 <code>addTwo_v2</code> 함수 호출을 위해, JavaScript는 <code>식별자 foo</code> 의 값을 찾습니다. 이는 인스턴스화된 첫 번째 구문의 변수를 올바르게 찾습니다.</p>\n</li>\n<li><p>찾은 다음, JavaScript는 <code>인수를 함수의 매개변수</code>로서 전달합니다.</p>\n</li>\n<li><p>함수의 본문 내 구문들을 실행하기 전에, JavaScript는 원래 전달된 <code>인수(원시 값)를 복사해 로컬 복사본</code>을 생성합니다. 이러한 <code>복사본은 함수의 스코프 내에서만 존재하며</code>, 함수 정의 내에 <code>지정한 식별자</code>를 통해 접근가능합니다(<code>addTwo 의 num</code>, <code>addTwo_v2 의 foo</code>).</p>\n</li>\n<li><p>그 후, 함수의 구문들이 실행됩니다.<br>4-1. 첫 번째 함수내에서, 로컬 <code>num</code> 인수가 생성되었습니다. 이 값을 2 증가시키는 것이며, 원래 <code>foo</code> 의 값이 아닙니다!</p>\n<p>4-2. 두 번째 함수내에서, <code>로컬 foo</code> 인수가 생성되었습니다. 이 값을 2 증가시키는 것이며, 원래(외부) <code>foo</code> 의 값이 아닙니다! 또한, 이 경우에서, <code>외부 foo</code> 변수에는 어떤 방법으로든 접근할 수 없습니다. 이는 자바스크립트의 어휘적 유효 범위(<code>lexical scoping</code>)와 결과 변수 섀도잉 때문입니다. <code>로컬 foo</code> 는 <code>외부 foo</code> 를 숨깁니다.</p>\n</li>\n</ol>\n<p><mark>결과적으로, 우리 함수들 내부의 모든 변경은 그 복사본으로 작업하였기 때문에, 원본 foo 에 전혀 영향을 주지 않았습니다.</mark></p>\n<p>이것이 <code>원시값이 변하지 않는 이유</code>입니다. 원시값에 직접 작업하지 않으므로, 원본을 건드리지 않고 복사본 가져와 계속 작업을 합니다.</p>\n<hr>\n<h4 id=\"8-function의-this키워드는-엄격모드에서-다르게-작동합니다\"><a href=\"#8-function의-this키워드는-엄격모드에서-다르게-작동합니다\" class=\"headerlink\" title=\"8. function의 this키워드는 엄격모드에서 다르게 작동합니다.\"></a>8. function의 this키워드는 엄격모드에서 다르게 작동합니다.</h4><p><code>this</code> 키워드는 함수를 호출 한 객체를 나타냅니다.<br>객체를 지정하지 않으면 엄격 모드의 <code>function</code>은 <code>undefined</code>로 반환됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> alert(<span class=\"keyword\">this</span>); <span class=\"comment\">// will alert \"undefined\"  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">myFunction();</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<hr>\n<h3 id=\"Strict-mode\"><a href=\"#Strict-mode\" class=\"headerlink\" title=\"Strict mode\"></a>Strict mode</h3><p><code>strict mode</code>는<br>JavaScript 코드가 “엄격 모드”에서 실행되도록 정의합니다.</p>\n<p>“strict mode”지시문은 ECMAScript 버전 5에서 새로 추가되었습니다.</p>\n<p>IE9 이하를 제외한 모든 최신 브라우저는 <code>strict mode</code>를 지원합니다.</p>\n<p>가끔 엄격하지 않은 기본값을<br>“느슨한 모드(sloppy mode)”라고 부르기도 합니다.<br>공식적인 용어는 아니지만 혹시 모르니 알아두세요.</p>\n<p><code>&quot;strict mode&quot;지시문은 script 나 function의 시작 부분에서만 인식됩니다.</code></p>","more":"<ul>\n<li>전체 스크립트 적용 구문</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//스크립트 파일 첫번째 줄  </span></span><br><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>function에 적용하는 구문</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">strict</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"comment\">// 함수-레벨 strict mode 문법  </span></span><br><span class=\"line\"><span class=\"meta\"> \"use strict\"</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"1-strict-mode를-사용하면-선언되지-않은-변수를-사용할-수-없습니다\"><a href=\"#1-strict-mode를-사용하면-선언되지-않은-변수를-사용할-수-없습니다\" class=\"headerlink\" title=\"1.  strict mode를 사용하면 선언되지 않은 변수를 사용할 수 없습니다.\"></a>1.  strict mode를 사용하면 선언되지 않은 변수를 사용할 수 없습니다.</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\">myFunction();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> x = <span class=\"number\">3.14</span>; <span class=\"comment\">// x를 선언해 주지 않았기 때문에 오류가 발생합니다.  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">y= <span class=\"number\">3</span>; <span class=\"comment\">// y역시 선언되지 않았기에 오류가 발생합니다.</span></span><br></pre></td></tr></table></figure>\n\n<p>strict mode는 이전에 허용 된 “잘못된 구문”을 실제 오류로 변경합니다.</p>\n<p>또한 선언되지 않은 변수를 사용하지 못하게하는 것과 같이<br>더 깨끗한 코드를 작성하는 데 도움이됩니다.<br>“strict mode”는 문자열이므로 IE 9는 이해하지 않아도 오류를 발생시키지 않습니다.</p>\n<p>예를 들어,<br>일반적인 JavaScript에서 변수 이름을 잘못 입력하면 새로운 전역 변수가 만들어집니다.<br><code>strict mode에서는 실수로 전역 변수를 만들 수 없습니다.</code></p>\n<hr>\n<h4 id=\"2-NaN-은-쓸-수-없는-전역-변수입니다\"><a href=\"#2-NaN-은-쓸-수-없는-전역-변수입니다\" class=\"headerlink\" title=\"2.  NaN 은 쓸 수 없는 전역 변수입니다.\"></a>2.  NaN 은 쓸 수 없는 전역 변수입니다.</h4><p>NaN 에 할당하는 일반적인 코드는 아무 것도 하지 않습니다.<br>개발자도 아무런 실패 피드백을 받지 않습니다.</p>\n<p>엄격 모드에서 NaN 에 할당하는 것은 예외를 발생시킵니다.<br>일반 코드에서 조용히 넘어가는 모든 실패에 대해 (쓸 수 없는 전역 또는 프로퍼티에 할당, getter-only 프로퍼티에 할당, 확장 불가 객체에 새 프로퍼티 할당) 엄격 모드에서는 예외를 발생시킵니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 쓸 수 없는 프로퍼티에 할당  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"literal\">undefined</span> = <span class=\"number\">5</span>; <span class=\"comment\">// TypeError 발생  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"literal\">Infinity</span> = <span class=\"number\">5</span>; <span class=\"comment\">// TypeError 발생  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 쓸 수 없는 프로퍼티에 할당  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj1, <span class=\"string\">\"x\"</span>, &#123; <span class=\"attr\">value</span>: <span class=\"number\">42</span>, <span class=\"attr\">writable</span>: <span class=\"literal\">false</span> &#125;);  </span><br><span class=\"line\">obj1.x = <span class=\"number\">9</span>; <span class=\"comment\">// TypeError 발생  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// getter-only 프로퍼티에 할당  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; <span class=\"keyword\">get</span> x() &#123; <span class=\"keyword\">return</span> <span class=\"number\">17</span>; &#125; &#125;;  </span><br><span class=\"line\">obj2.x = <span class=\"number\">5</span>; <span class=\"comment\">// TypeError 발생  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 확장 불가 객체에 새 프로퍼티 할당  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fixed = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">Object</span>.preventExtensions(fixed);  </span><br><span class=\"line\">fixed.newProp = <span class=\"string\">\"ohai\"</span>; <span class=\"comment\">// TypeError 발생</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"3-엄격-모드는-삭제할-수-없는-프로퍼티를-삭제하려할-때-예외를-발생시킵니다\"><a href=\"#3-엄격-모드는-삭제할-수-없는-프로퍼티를-삭제하려할-때-예외를-발생시킵니다\" class=\"headerlink\" title=\"3. 엄격 모드는 삭제할 수 없는 프로퍼티를 삭제하려할 때 예외를 발생시킵니다.\"></a>3. 엄격 모드는 삭제할 수 없는 프로퍼티를 삭제하려할 때 예외를 발생시킵니다.</h4><p>(시도가 어떤 효과도 없을 때).</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// TypeError 발생</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"4-또한-function-삭제도-허용하지-않습니다\"><a href=\"#4-또한-function-삭제도-허용하지-않습니다\" class=\"headerlink\" title=\"4. 또한 function 삭제도 허용하지 않습니다.\"></a>4. 또한 function 삭제도 허용하지 않습니다.</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">x</span>(<span class=\"params\">p1, p2</span>) </span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">delete</span> x;        <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"5-엄격모드는-유니크한-함수-파라미터-이름을-요구합니다\"><a href=\"#5-엄격모드는-유니크한-함수-파라미터-이름을-요구합니다\" class=\"headerlink\" title=\"5.  엄격모드는 유니크한 함수 파라미터 이름을 요구합니다.\"></a>5.  엄격모드는 유니크한 함수 파라미터 이름을 요구합니다.</h4><p>일반 코드에서는 마지막으로 중복된 인수가 이전에 지정된 인수를 숨깁니다. </p>\n<p>이러한 이전의 인수들은 <code>arguments[i]</code> 를 통해 여전히 남아 있을 수 있으므로,<br>완전히 접근 불가한 것이 아닙니다. 여전히, 이런 숨김 처리는 이치에 맞지 않으며 원했던 것이 아닐 수 있습니다(예를 들면 오타를 숨길 수도 있습니다). </p>\n<p>따라서 엄격 모드에서는 중복 인수명은 구문 에러입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>예시1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">x</span>(<span class=\"params\">p1, p1</span>) </span>&#123;&#125;;   <span class=\"comment\">// !!! 구문 에러</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>예시2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, a, c</span>)</span>&#123; <span class=\"comment\">// !!! 구문 에러  </span></span><br><span class=\"line\"><span class=\"meta\"> \"use strict\"</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> a + b + c; <span class=\"comment\">// 코드가 실행되면 잘못된 것임  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"6-ECMAScript5-에서의-엄격-모드는-8진수-구문을-금지합니다\"><a href=\"#6-ECMAScript5-에서의-엄격-모드는-8진수-구문을-금지합니다\" class=\"headerlink\" title=\"6.  ECMAScript5 에서의 엄격 모드는 8진수 구문을 금지합니다.\"></a>6.  ECMAScript5 에서의 엄격 모드는 8진수 구문을 금지합니다.</h4><p>8진수 구문은 ES5의 문법이 아니지만,<br>모든 브라우저에서 앞에 0을 붙여 지원됩니다(0644 === 420 와 “045” === “%”).</p>\n<p><code>ECMAScript 2015 에서는 접두사 &quot;0o&quot;를 붙여 8진수를 지원합니다.</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">0o10</span>; <span class=\"comment\">// ES6: 8진수</span></span><br></pre></td></tr></table></figure>\n\n<p>초보 개발자들은 가끔 앞에 붙은 0 이 무의미하다고 생각하여, 이를 정렬용으로 사용합니다 — 하지만 이는 숫자의 의미를 바꿔버립니다.<br>이 8진수 문법은 거의 무용하며 잘못 사용될 수 있으므로 엄격모드에서 이 구문은 에러입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"number\">015</span> + <span class=\"comment\">// !!! 구문 에러  </span></span><br><span class=\"line\"> <span class=\"number\">197</span> +  </span><br><span class=\"line\"> <span class=\"number\">142</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"7-ECMAScript6-의-엄격모드는-primitive-값에-프로퍼티를-설정하는-것을-금지합니다\"><a href=\"#7-ECMAScript6-의-엄격모드는-primitive-값에-프로퍼티를-설정하는-것을-금지합니다\" class=\"headerlink\" title=\"7. ECMAScript6 의 엄격모드는 primitive 값에 프로퍼티를 설정하는 것을 금지합니다.\"></a>7. ECMAScript6 의 엄격모드는 primitive 값에 프로퍼티를 설정하는 것을 금지합니다.</h4><p>엄격모드가 아닐 때에는 프로퍼티 설정이 간단하게 무시되지만(no-op),<br>엄격모드에서는 <code>TypeError</code> 를 발생시킵니다.  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"literal\">false</span>.true = <span class=\"string\">\"\"</span>;         <span class=\"comment\">// TypeError  </span></span><br><span class=\"line\">(<span class=\"number\">14</span>).sailing = <span class=\"string\">\"home\"</span>;   <span class=\"comment\">// TypeError  </span></span><br><span class=\"line\"><span class=\"string\">\"with\"</span>.you = <span class=\"string\">\"far away\"</span>; <span class=\"comment\">// TypeError  </span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p><code>primitive</code>: 원시값 또는 원시 자료형<br>객체도 아니고 메서드도 아닌 데이터입니다.<br><code>string</code>, <code>number</code>, <code>bigint</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>symbol</code><br>7가지 원시 자료형이 존재 합니다.</p>\n<p><mark>모든 원시 값은 불변합니다. 즉, 변형할 수 없습니다. 원시값 자체와, 원시값을 할당한 변수를 혼동하지 않는 것이 중요합니다. 변수는 새로운 값을 다시 할당할 수 있지만, 이미 생성한 원시값은 객체, 배열, 함수와는 달리 변형할 수 없습니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>원시값 예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 문자열 메서드는 문자열을 변형하지 않음  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"string\">\"baz\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar);        <span class=\"comment\">// baz  </span></span><br><span class=\"line\">bar.toUpperCase();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar);        <span class=\"comment\">// baz  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 배열 메소드는 배열을 변형함  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = [];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo);        <span class=\"comment\">// []  </span></span><br><span class=\"line\">foo.push(<span class=\"string\">\"plugh\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo);        <span class=\"comment\">// [\"plugh\"]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 할당은 원시 값에 새로운 값을 부여 (변형이 아님)  </span></span><br><span class=\"line\">bar = bar.toUpperCase(); <span class=\"comment\">// BAZ</span></span><br></pre></td></tr></table></figure>\n\n<p><code>원시 값을 교체할 수는 있지만, 직접 변형할 수는 없습니다.</code></p>\n<figure class=\"highlight js\"><figcaption><span>원시형 코드 실행 과정</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 원시값  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"number\">5</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 원시값을 변경해야 하는 함수 정의  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTwo</span>(<span class=\"params\">num</span>) </span>&#123;  </span><br><span class=\"line\"> num += <span class=\"number\">2</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// 같은 작업을 시도하는 다른 함수  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTwo_v2</span>(<span class=\"params\">foo</span>) </span>&#123;  </span><br><span class=\"line\"> foo += <span class=\"number\">2</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 원시값을 인수로 전달해 첫 번째 함수를 호출  </span></span><br><span class=\"line\">addTwo(foo);  </span><br><span class=\"line\"><span class=\"comment\">// 현재 원시값 반환  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo);   <span class=\"comment\">// 5  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 두 번째 함수로 다시 시도  </span></span><br><span class=\"line\">addTwo_v2(foo);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo);   <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p>5 대신 7 일 것이라고 예상하였나요?<br>그렇다면, 이 코드의 실행 과정을 살펴보세요.</p>\n<ol>\n<li><p><code>addTwo</code> 와 <code>addTwo_v2</code> 함수 호출을 위해, JavaScript는 <code>식별자 foo</code> 의 값을 찾습니다. 이는 인스턴스화된 첫 번째 구문의 변수를 올바르게 찾습니다.</p>\n</li>\n<li><p>찾은 다음, JavaScript는 <code>인수를 함수의 매개변수</code>로서 전달합니다.</p>\n</li>\n<li><p>함수의 본문 내 구문들을 실행하기 전에, JavaScript는 원래 전달된 <code>인수(원시 값)를 복사해 로컬 복사본</code>을 생성합니다. 이러한 <code>복사본은 함수의 스코프 내에서만 존재하며</code>, 함수 정의 내에 <code>지정한 식별자</code>를 통해 접근가능합니다(<code>addTwo 의 num</code>, <code>addTwo_v2 의 foo</code>).</p>\n</li>\n<li><p>그 후, 함수의 구문들이 실행됩니다.<br>4-1. 첫 번째 함수내에서, 로컬 <code>num</code> 인수가 생성되었습니다. 이 값을 2 증가시키는 것이며, 원래 <code>foo</code> 의 값이 아닙니다!</p>\n<p>4-2. 두 번째 함수내에서, <code>로컬 foo</code> 인수가 생성되었습니다. 이 값을 2 증가시키는 것이며, 원래(외부) <code>foo</code> 의 값이 아닙니다! 또한, 이 경우에서, <code>외부 foo</code> 변수에는 어떤 방법으로든 접근할 수 없습니다. 이는 자바스크립트의 어휘적 유효 범위(<code>lexical scoping</code>)와 결과 변수 섀도잉 때문입니다. <code>로컬 foo</code> 는 <code>외부 foo</code> 를 숨깁니다.</p>\n</li>\n</ol>\n<p><mark>결과적으로, 우리 함수들 내부의 모든 변경은 그 복사본으로 작업하였기 때문에, 원본 foo 에 전혀 영향을 주지 않았습니다.</mark></p>\n<p>이것이 <code>원시값이 변하지 않는 이유</code>입니다. 원시값에 직접 작업하지 않으므로, 원본을 건드리지 않고 복사본 가져와 계속 작업을 합니다.</p>\n<hr>\n<h4 id=\"8-function의-this키워드는-엄격모드에서-다르게-작동합니다\"><a href=\"#8-function의-this키워드는-엄격모드에서-다르게-작동합니다\" class=\"headerlink\" title=\"8. function의 this키워드는 엄격모드에서 다르게 작동합니다.\"></a>8. function의 this키워드는 엄격모드에서 다르게 작동합니다.</h4><p><code>this</code> 키워드는 함수를 호출 한 객체를 나타냅니다.<br>객체를 지정하지 않으면 엄격 모드의 <code>function</code>은 <code>undefined</code>로 반환됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> alert(<span class=\"keyword\">this</span>); <span class=\"comment\">// will alert \"undefined\"  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">myFunction();</span><br></pre></td></tr></table></figure>"},{"title":"String(문자) 객체 -JavaScript","date":"2020-03-02T03:33:36.000Z","disqusId":"tunas-blog-1","_content":"\n\n* * *\n\n#### 문자 객체 메서드 및 속성\n\n| 종류                           | 설명                                                                                                                             |\n|--------------------------------|----------------------------------------------------------------------------------------------------------------------------------|\n| charAt(index)                  | 문자열에서 인덱스 번호에 해당하는 문자를 반환                                                                                    |\n| indexOf(“찾을 문자”)           | 문자열 왼쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 일치하는 문자의 **인덱스 번호**를 반환                                   |\n| lastindexOf(“찾을 문자”)       | 문자열 오른쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 일치하는 문자의 인덱스 번호를 반환 (만일 찾을 문자가 없으면 -1을 반환) |\n| match(“찾을 문자”)             | 문자열 왼쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 찾은 **문자**를 반환 (찾는 문자가 없으면 null 반환)                      |\n| replace(“바꿀 문자”,”새 문자”) | 문자열 왼쪽부터 바꿀 문자와 일치하는 문자를 찾아 최초로 찾은 문자를 **치환**                                                     |\n| search(“찾을 문자”)            | 문자열 왼쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 일치하는 인덱스 번호 반환                                                |\n| slice(a,b)                     | **a번째 까지 문자를 자르고 b번째 이후에 문자를 자른후** 남은 문자를 반환                                                         |\n| substring(a,b)                 | **a 인덱스부터 b 인덱스 이전 구간**의 문자를 반환                                                                                |\n| substr(a,문자 갯수)            | 문자열에 **a인덱스 부터 지정된 문자 개수**만큼 문자열을 반환                                                                     |\n| split(“문자”)                  | **지정한 문자를 기준으로 문자 데이터를 나누어 배열에 저장**하여 반환                                                             |\n| toLowerCase()                  | 문자열에서 **영문 대문자를 모두 소문자**로 바꿉니다.                                                                             |\n| toUpperCase()                  | 문자열에서 **영문 소문자를 모두 대문자**로 바꿉니다.                                                                             |\n| length                         | 문자열에서 **문자의 총 개수**를 반환합니다.                                                                                      |\n| concat(“새로운 문자”)          | 문자열에 새로운 **문자열을 결합**합니다.                                                                                         |\n| charCodeAt(“찾을 문자”)        | 찾을 문자의 아스키 코드 값을 반환                                                                                                |\n| fromCartCode(아스키 코드 값)   | 아스키 코드 값에 해당하는 문자를 반환                                                                                            |\n| trim()                         | 문자의 앞 또는 뒤에 공백 문자열을 삭제합니다.                                                                                    |\n\n<!-- more -->\n\n사용 예제\n\n```js\nvar t=\"Hello Thank you good luck to you\";  \n  \ndocument.write(t.charAt(16),\"<br />\");   \n// 인덱스 16에 저장된 문자를 불러옵니다 (g)  \n  \ndocument.write(t.indexOf(\"you\"),\"<br />\");   \n// 문자열 왼쪽부터 최초로 발견된 \"you\"의 인덱스 값을 반환 (12)  \n  \ndocument.write(t.indexOf(\"you\",16),\"<br />\");  \n// 문자열 인덱스 16 위치부터 최초로 발견된 \"you\"의 인덱스 값 반환 (29)  \n  \ndocument.write(t.lastIndexOf(\"you\"),\"<br />\");  \n// 문자열 오른쪽 부터 왼쪽 방향으로 최초로 발견된 \"you\"의 인덱스 값 반환 (29)  \n  \ndocument.write(t.lastIndexOf(\"you\",25),\"<br />\");  \n// 문자열 인덱스 25부터 왼쪽 방향으로 최초로 발견된 \"you\"의 인덱스 값 반환 (12)  \n  \ndocument.write(t.match(\"luck\"),\"<br />\");  \n// 문자열 왼쪽부터 최초로 발견된 \"luck\"과 일치하는 문자를 찾아 반환 (luck)  \n  \ndocument.write(t.search(\"you\"),\"<br />\");  \n// 문자열 왼쪽부터 최초로 발견된 \"you\"의 인덱스 값 반환 (luck)  \n  \ndocument.write(t.substr(21,4),\"<br />\");  \n// 문자열 인덱스 21부터 네 글자를 가져옵니다 (luck)  \n  \ndocument.write(t.substring(6,12),\"<br />\");  \n// 문자열 인덱스 6부터 12 이전까지 문자를 가져옵니다. (Thank_)  \n  \ndocument.write(t.replace(\"you\",\"me\"),\"<br />\");  \n// 문자열 왼쪽부터 최초에 발견된 \"you\"를 \"me\"로 치환 (Hello Thank me good luck to you)  \n  \ndocument.write(t.toLowerCase(),\"<br />\");  \n// 문자열의 영문자를 모두 소문자로 바꿉니다. (hello thank you good luck to you)  \n  \ndocument.write(t.toUpperCase(),\"<br />\");  \n// 문자열의 영문자를 모두 대문자로 바꿉니다. (HELLO THANK YOU GOOD LUCK TO YOU)  \n  \ndocument.write(t.length,\"<br />\");  \n// 문자열의 총 문자 개수를 반환합니다. (공백포함 32)  \n  \nvar s=t.split(\" \");  \n//  \" \"(공백) 문자를 기준으로 문자를 분리하여 s에 저장합니다.  \n  \ndocument.write(s[0],\"<br />\");  \n// s 인덱스 0에 저장된 문자열을 출력합니다. (Hello)  \n  \ndocument.write(s[4],\"<br />\");  \n// s 인덱스 4에 저장된 문자열을 출력합니다. (luck)  \n```\n\n* * *\n\n#### 사용자에게 입력받은 이메일 유효성 검사 예제\n\n```js\nvar userEmail=prompt(\"당신의 이메일 주소는?\",\"\");  \n    \nvar check1=false; //초기 값 저장  \nvar check2=false; //초기 값 저장  \n    \n//이메일 주소에 뒷부분 형식을 배열로 저장  \nvar arrUrl=[\".co.kr\",\".com\",\".net\",\".or.kr\",\".go.kr\"];  \n  \n/*방문자가 입력한 이메일 주소에 \"@\"포함되어 있으면 변수  \ncheck1에 true가 저장*/  \nif(userEmail.indexOf(\"@\")>0) check1=true; //indexOf는 찾는 문자가 없는경우만 -1을 반환 합니다.  \n    \n //이메일에 배열 데이터 포함여부 검사  \nfor(var i=0; i<arrUrl.length; i++){  \n if(userEmail.indexOf(arrUrl[i])>0) check2=true;  \n}  \n  \n    \n//AND(&&)연산자는 모두 피연산자가 모두 true여야 true를 반환합니다.  \nif(check1&&check2){  \n document.write(userEmail);  \n}else{  \n alert(\"이메일 형식이 잘못되었습니다.\");  \n}  \n```","source":"_posts/String 문자 객체 -JavaScript.md","raw":"---\ntitle: String(문자) 객체 -JavaScript\ndate: 2020-03-02 12:33:36\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\n\n* * *\n\n#### 문자 객체 메서드 및 속성\n\n| 종류                           | 설명                                                                                                                             |\n|--------------------------------|----------------------------------------------------------------------------------------------------------------------------------|\n| charAt(index)                  | 문자열에서 인덱스 번호에 해당하는 문자를 반환                                                                                    |\n| indexOf(“찾을 문자”)           | 문자열 왼쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 일치하는 문자의 **인덱스 번호**를 반환                                   |\n| lastindexOf(“찾을 문자”)       | 문자열 오른쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 일치하는 문자의 인덱스 번호를 반환 (만일 찾을 문자가 없으면 -1을 반환) |\n| match(“찾을 문자”)             | 문자열 왼쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 찾은 **문자**를 반환 (찾는 문자가 없으면 null 반환)                      |\n| replace(“바꿀 문자”,”새 문자”) | 문자열 왼쪽부터 바꿀 문자와 일치하는 문자를 찾아 최초로 찾은 문자를 **치환**                                                     |\n| search(“찾을 문자”)            | 문자열 왼쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 일치하는 인덱스 번호 반환                                                |\n| slice(a,b)                     | **a번째 까지 문자를 자르고 b번째 이후에 문자를 자른후** 남은 문자를 반환                                                         |\n| substring(a,b)                 | **a 인덱스부터 b 인덱스 이전 구간**의 문자를 반환                                                                                |\n| substr(a,문자 갯수)            | 문자열에 **a인덱스 부터 지정된 문자 개수**만큼 문자열을 반환                                                                     |\n| split(“문자”)                  | **지정한 문자를 기준으로 문자 데이터를 나누어 배열에 저장**하여 반환                                                             |\n| toLowerCase()                  | 문자열에서 **영문 대문자를 모두 소문자**로 바꿉니다.                                                                             |\n| toUpperCase()                  | 문자열에서 **영문 소문자를 모두 대문자**로 바꿉니다.                                                                             |\n| length                         | 문자열에서 **문자의 총 개수**를 반환합니다.                                                                                      |\n| concat(“새로운 문자”)          | 문자열에 새로운 **문자열을 결합**합니다.                                                                                         |\n| charCodeAt(“찾을 문자”)        | 찾을 문자의 아스키 코드 값을 반환                                                                                                |\n| fromCartCode(아스키 코드 값)   | 아스키 코드 값에 해당하는 문자를 반환                                                                                            |\n| trim()                         | 문자의 앞 또는 뒤에 공백 문자열을 삭제합니다.                                                                                    |\n\n<!-- more -->\n\n사용 예제\n\n```js\nvar t=\"Hello Thank you good luck to you\";  \n  \ndocument.write(t.charAt(16),\"<br />\");   \n// 인덱스 16에 저장된 문자를 불러옵니다 (g)  \n  \ndocument.write(t.indexOf(\"you\"),\"<br />\");   \n// 문자열 왼쪽부터 최초로 발견된 \"you\"의 인덱스 값을 반환 (12)  \n  \ndocument.write(t.indexOf(\"you\",16),\"<br />\");  \n// 문자열 인덱스 16 위치부터 최초로 발견된 \"you\"의 인덱스 값 반환 (29)  \n  \ndocument.write(t.lastIndexOf(\"you\"),\"<br />\");  \n// 문자열 오른쪽 부터 왼쪽 방향으로 최초로 발견된 \"you\"의 인덱스 값 반환 (29)  \n  \ndocument.write(t.lastIndexOf(\"you\",25),\"<br />\");  \n// 문자열 인덱스 25부터 왼쪽 방향으로 최초로 발견된 \"you\"의 인덱스 값 반환 (12)  \n  \ndocument.write(t.match(\"luck\"),\"<br />\");  \n// 문자열 왼쪽부터 최초로 발견된 \"luck\"과 일치하는 문자를 찾아 반환 (luck)  \n  \ndocument.write(t.search(\"you\"),\"<br />\");  \n// 문자열 왼쪽부터 최초로 발견된 \"you\"의 인덱스 값 반환 (luck)  \n  \ndocument.write(t.substr(21,4),\"<br />\");  \n// 문자열 인덱스 21부터 네 글자를 가져옵니다 (luck)  \n  \ndocument.write(t.substring(6,12),\"<br />\");  \n// 문자열 인덱스 6부터 12 이전까지 문자를 가져옵니다. (Thank_)  \n  \ndocument.write(t.replace(\"you\",\"me\"),\"<br />\");  \n// 문자열 왼쪽부터 최초에 발견된 \"you\"를 \"me\"로 치환 (Hello Thank me good luck to you)  \n  \ndocument.write(t.toLowerCase(),\"<br />\");  \n// 문자열의 영문자를 모두 소문자로 바꿉니다. (hello thank you good luck to you)  \n  \ndocument.write(t.toUpperCase(),\"<br />\");  \n// 문자열의 영문자를 모두 대문자로 바꿉니다. (HELLO THANK YOU GOOD LUCK TO YOU)  \n  \ndocument.write(t.length,\"<br />\");  \n// 문자열의 총 문자 개수를 반환합니다. (공백포함 32)  \n  \nvar s=t.split(\" \");  \n//  \" \"(공백) 문자를 기준으로 문자를 분리하여 s에 저장합니다.  \n  \ndocument.write(s[0],\"<br />\");  \n// s 인덱스 0에 저장된 문자열을 출력합니다. (Hello)  \n  \ndocument.write(s[4],\"<br />\");  \n// s 인덱스 4에 저장된 문자열을 출력합니다. (luck)  \n```\n\n* * *\n\n#### 사용자에게 입력받은 이메일 유효성 검사 예제\n\n```js\nvar userEmail=prompt(\"당신의 이메일 주소는?\",\"\");  \n    \nvar check1=false; //초기 값 저장  \nvar check2=false; //초기 값 저장  \n    \n//이메일 주소에 뒷부분 형식을 배열로 저장  \nvar arrUrl=[\".co.kr\",\".com\",\".net\",\".or.kr\",\".go.kr\"];  \n  \n/*방문자가 입력한 이메일 주소에 \"@\"포함되어 있으면 변수  \ncheck1에 true가 저장*/  \nif(userEmail.indexOf(\"@\")>0) check1=true; //indexOf는 찾는 문자가 없는경우만 -1을 반환 합니다.  \n    \n //이메일에 배열 데이터 포함여부 검사  \nfor(var i=0; i<arrUrl.length; i++){  \n if(userEmail.indexOf(arrUrl[i])>0) check2=true;  \n}  \n  \n    \n//AND(&&)연산자는 모두 피연산자가 모두 true여야 true를 반환합니다.  \nif(check1&&check2){  \n document.write(userEmail);  \n}else{  \n alert(\"이메일 형식이 잘못되었습니다.\");  \n}  \n```","slug":"String 문자 객체 -JavaScript","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrsr001kqgvqas27bmwy","content":"<hr>\n<h4 id=\"문자-객체-메서드-및-속성\"><a href=\"#문자-객체-메서드-및-속성\" class=\"headerlink\" title=\"문자 객체 메서드 및 속성\"></a>문자 객체 메서드 및 속성</h4><table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>charAt(index)</td>\n<td>문자열에서 인덱스 번호에 해당하는 문자를 반환</td>\n</tr>\n<tr>\n<td>indexOf(“찾을 문자”)</td>\n<td>문자열 왼쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 일치하는 문자의 <strong>인덱스 번호</strong>를 반환</td>\n</tr>\n<tr>\n<td>lastindexOf(“찾을 문자”)</td>\n<td>문자열 오른쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 일치하는 문자의 인덱스 번호를 반환 (만일 찾을 문자가 없으면 -1을 반환)</td>\n</tr>\n<tr>\n<td>match(“찾을 문자”)</td>\n<td>문자열 왼쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 찾은 <strong>문자</strong>를 반환 (찾는 문자가 없으면 null 반환)</td>\n</tr>\n<tr>\n<td>replace(“바꿀 문자”,”새 문자”)</td>\n<td>문자열 왼쪽부터 바꿀 문자와 일치하는 문자를 찾아 최초로 찾은 문자를 <strong>치환</strong></td>\n</tr>\n<tr>\n<td>search(“찾을 문자”)</td>\n<td>문자열 왼쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 일치하는 인덱스 번호 반환</td>\n</tr>\n<tr>\n<td>slice(a,b)</td>\n<td><strong>a번째 까지 문자를 자르고 b번째 이후에 문자를 자른후</strong> 남은 문자를 반환</td>\n</tr>\n<tr>\n<td>substring(a,b)</td>\n<td><strong>a 인덱스부터 b 인덱스 이전 구간</strong>의 문자를 반환</td>\n</tr>\n<tr>\n<td>substr(a,문자 갯수)</td>\n<td>문자열에 <strong>a인덱스 부터 지정된 문자 개수</strong>만큼 문자열을 반환</td>\n</tr>\n<tr>\n<td>split(“문자”)</td>\n<td><strong>지정한 문자를 기준으로 문자 데이터를 나누어 배열에 저장</strong>하여 반환</td>\n</tr>\n<tr>\n<td>toLowerCase()</td>\n<td>문자열에서 <strong>영문 대문자를 모두 소문자</strong>로 바꿉니다.</td>\n</tr>\n<tr>\n<td>toUpperCase()</td>\n<td>문자열에서 <strong>영문 소문자를 모두 대문자</strong>로 바꿉니다.</td>\n</tr>\n<tr>\n<td>length</td>\n<td>문자열에서 <strong>문자의 총 개수</strong>를 반환합니다.</td>\n</tr>\n<tr>\n<td>concat(“새로운 문자”)</td>\n<td>문자열에 새로운 <strong>문자열을 결합</strong>합니다.</td>\n</tr>\n<tr>\n<td>charCodeAt(“찾을 문자”)</td>\n<td>찾을 문자의 아스키 코드 값을 반환</td>\n</tr>\n<tr>\n<td>fromCartCode(아스키 코드 값)</td>\n<td>아스키 코드 값에 해당하는 문자를 반환</td>\n</tr>\n<tr>\n<td>trim()</td>\n<td>문자의 앞 또는 뒤에 공백 문자열을 삭제합니다.</td>\n</tr>\n</tbody></table>\n<a id=\"more\"></a>\n\n<p>사용 예제</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> t=<span class=\"string\">\"Hello Thank you good luck to you\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.charAt(<span class=\"number\">16</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);   </span><br><span class=\"line\"><span class=\"comment\">// 인덱스 16에 저장된 문자를 불러옵니다 (g)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.indexOf(<span class=\"string\">\"you\"</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);   </span><br><span class=\"line\"><span class=\"comment\">// 문자열 왼쪽부터 최초로 발견된 \"you\"의 인덱스 값을 반환 (12)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.indexOf(<span class=\"string\">\"you\"</span>,<span class=\"number\">16</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 인덱스 16 위치부터 최초로 발견된 \"you\"의 인덱스 값 반환 (29)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.lastIndexOf(<span class=\"string\">\"you\"</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 오른쪽 부터 왼쪽 방향으로 최초로 발견된 \"you\"의 인덱스 값 반환 (29)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.lastIndexOf(<span class=\"string\">\"you\"</span>,<span class=\"number\">25</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 인덱스 25부터 왼쪽 방향으로 최초로 발견된 \"you\"의 인덱스 값 반환 (12)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.match(<span class=\"string\">\"luck\"</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 왼쪽부터 최초로 발견된 \"luck\"과 일치하는 문자를 찾아 반환 (luck)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.search(<span class=\"string\">\"you\"</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 왼쪽부터 최초로 발견된 \"you\"의 인덱스 값 반환 (luck)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.substr(<span class=\"number\">21</span>,<span class=\"number\">4</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 인덱스 21부터 네 글자를 가져옵니다 (luck)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.substring(<span class=\"number\">6</span>,<span class=\"number\">12</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 인덱스 6부터 12 이전까지 문자를 가져옵니다. (Thank_)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.replace(<span class=\"string\">\"you\"</span>,<span class=\"string\">\"me\"</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 왼쪽부터 최초에 발견된 \"you\"를 \"me\"로 치환 (Hello Thank me good luck to you)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.toLowerCase(),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열의 영문자를 모두 소문자로 바꿉니다. (hello thank you good luck to you)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.toUpperCase(),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열의 영문자를 모두 대문자로 바꿉니다. (HELLO THANK YOU GOOD LUCK TO YOU)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.length,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열의 총 문자 개수를 반환합니다. (공백포함 32)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> s=t.split(<span class=\"string\">\" \"</span>);  </span><br><span class=\"line\"><span class=\"comment\">//  \" \"(공백) 문자를 기준으로 문자를 분리하여 s에 저장합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(s[<span class=\"number\">0</span>],<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// s 인덱스 0에 저장된 문자열을 출력합니다. (Hello)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(s[<span class=\"number\">4</span>],<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// s 인덱스 4에 저장된 문자열을 출력합니다. (luck)</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"사용자에게-입력받은-이메일-유효성-검사-예제\"><a href=\"#사용자에게-입력받은-이메일-유효성-검사-예제\" class=\"headerlink\" title=\"사용자에게 입력받은 이메일 유효성 검사 예제\"></a>사용자에게 입력받은 이메일 유효성 검사 예제</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userEmail=prompt(<span class=\"string\">\"당신의 이메일 주소는?\"</span>,<span class=\"string\">\"\"</span>);  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">var</span> check1=<span class=\"literal\">false</span>; <span class=\"comment\">//초기 값 저장  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> check2=<span class=\"literal\">false</span>; <span class=\"comment\">//초기 값 저장  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//이메일 주소에 뒷부분 형식을 배열로 저장  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrUrl=[<span class=\"string\">\".co.kr\"</span>,<span class=\"string\">\".com\"</span>,<span class=\"string\">\".net\"</span>,<span class=\"string\">\".or.kr\"</span>,<span class=\"string\">\".go.kr\"</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/*방문자가 입력한 이메일 주소에 \"@\"포함되어 있으면 변수  </span></span><br><span class=\"line\"><span class=\"comment\">check1에 true가 저장*/</span>  </span><br><span class=\"line\"><span class=\"keyword\">if</span>(userEmail.indexOf(<span class=\"string\">\"@\"</span>)&gt;<span class=\"number\">0</span>) check1=<span class=\"literal\">true</span>; <span class=\"comment\">//indexOf는 찾는 문자가 없는경우만 -1을 반환 합니다.  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">//이메일에 배열 데이터 포함여부 검사  </span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;arrUrl.length; i++)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">if</span>(userEmail.indexOf(arrUrl[i])&gt;<span class=\"number\">0</span>) check2=<span class=\"literal\">true</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//AND(&amp;&amp;)연산자는 모두 피연산자가 모두 true여야 true를 반환합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(check1&amp;&amp;check2)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(userEmail);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\"> alert(<span class=\"string\">\"이메일 형식이 잘못되었습니다.\"</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<hr>\n<h4 id=\"문자-객체-메서드-및-속성\"><a href=\"#문자-객체-메서드-및-속성\" class=\"headerlink\" title=\"문자 객체 메서드 및 속성\"></a>문자 객체 메서드 및 속성</h4><table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>charAt(index)</td>\n<td>문자열에서 인덱스 번호에 해당하는 문자를 반환</td>\n</tr>\n<tr>\n<td>indexOf(“찾을 문자”)</td>\n<td>문자열 왼쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 일치하는 문자의 <strong>인덱스 번호</strong>를 반환</td>\n</tr>\n<tr>\n<td>lastindexOf(“찾을 문자”)</td>\n<td>문자열 오른쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 일치하는 문자의 인덱스 번호를 반환 (만일 찾을 문자가 없으면 -1을 반환)</td>\n</tr>\n<tr>\n<td>match(“찾을 문자”)</td>\n<td>문자열 왼쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 찾은 <strong>문자</strong>를 반환 (찾는 문자가 없으면 null 반환)</td>\n</tr>\n<tr>\n<td>replace(“바꿀 문자”,”새 문자”)</td>\n<td>문자열 왼쪽부터 바꿀 문자와 일치하는 문자를 찾아 최초로 찾은 문자를 <strong>치환</strong></td>\n</tr>\n<tr>\n<td>search(“찾을 문자”)</td>\n<td>문자열 왼쪽부터 찾을 문자와 일치하는 문자를 찾아 최초로 일치하는 인덱스 번호 반환</td>\n</tr>\n<tr>\n<td>slice(a,b)</td>\n<td><strong>a번째 까지 문자를 자르고 b번째 이후에 문자를 자른후</strong> 남은 문자를 반환</td>\n</tr>\n<tr>\n<td>substring(a,b)</td>\n<td><strong>a 인덱스부터 b 인덱스 이전 구간</strong>의 문자를 반환</td>\n</tr>\n<tr>\n<td>substr(a,문자 갯수)</td>\n<td>문자열에 <strong>a인덱스 부터 지정된 문자 개수</strong>만큼 문자열을 반환</td>\n</tr>\n<tr>\n<td>split(“문자”)</td>\n<td><strong>지정한 문자를 기준으로 문자 데이터를 나누어 배열에 저장</strong>하여 반환</td>\n</tr>\n<tr>\n<td>toLowerCase()</td>\n<td>문자열에서 <strong>영문 대문자를 모두 소문자</strong>로 바꿉니다.</td>\n</tr>\n<tr>\n<td>toUpperCase()</td>\n<td>문자열에서 <strong>영문 소문자를 모두 대문자</strong>로 바꿉니다.</td>\n</tr>\n<tr>\n<td>length</td>\n<td>문자열에서 <strong>문자의 총 개수</strong>를 반환합니다.</td>\n</tr>\n<tr>\n<td>concat(“새로운 문자”)</td>\n<td>문자열에 새로운 <strong>문자열을 결합</strong>합니다.</td>\n</tr>\n<tr>\n<td>charCodeAt(“찾을 문자”)</td>\n<td>찾을 문자의 아스키 코드 값을 반환</td>\n</tr>\n<tr>\n<td>fromCartCode(아스키 코드 값)</td>\n<td>아스키 코드 값에 해당하는 문자를 반환</td>\n</tr>\n<tr>\n<td>trim()</td>\n<td>문자의 앞 또는 뒤에 공백 문자열을 삭제합니다.</td>\n</tr>\n</tbody></table>","more":"<p>사용 예제</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> t=<span class=\"string\">\"Hello Thank you good luck to you\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.charAt(<span class=\"number\">16</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);   </span><br><span class=\"line\"><span class=\"comment\">// 인덱스 16에 저장된 문자를 불러옵니다 (g)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.indexOf(<span class=\"string\">\"you\"</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);   </span><br><span class=\"line\"><span class=\"comment\">// 문자열 왼쪽부터 최초로 발견된 \"you\"의 인덱스 값을 반환 (12)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.indexOf(<span class=\"string\">\"you\"</span>,<span class=\"number\">16</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 인덱스 16 위치부터 최초로 발견된 \"you\"의 인덱스 값 반환 (29)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.lastIndexOf(<span class=\"string\">\"you\"</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 오른쪽 부터 왼쪽 방향으로 최초로 발견된 \"you\"의 인덱스 값 반환 (29)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.lastIndexOf(<span class=\"string\">\"you\"</span>,<span class=\"number\">25</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 인덱스 25부터 왼쪽 방향으로 최초로 발견된 \"you\"의 인덱스 값 반환 (12)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.match(<span class=\"string\">\"luck\"</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 왼쪽부터 최초로 발견된 \"luck\"과 일치하는 문자를 찾아 반환 (luck)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.search(<span class=\"string\">\"you\"</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 왼쪽부터 최초로 발견된 \"you\"의 인덱스 값 반환 (luck)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.substr(<span class=\"number\">21</span>,<span class=\"number\">4</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 인덱스 21부터 네 글자를 가져옵니다 (luck)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.substring(<span class=\"number\">6</span>,<span class=\"number\">12</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 인덱스 6부터 12 이전까지 문자를 가져옵니다. (Thank_)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.replace(<span class=\"string\">\"you\"</span>,<span class=\"string\">\"me\"</span>),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 왼쪽부터 최초에 발견된 \"you\"를 \"me\"로 치환 (Hello Thank me good luck to you)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.toLowerCase(),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열의 영문자를 모두 소문자로 바꿉니다. (hello thank you good luck to you)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.toUpperCase(),<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열의 영문자를 모두 대문자로 바꿉니다. (HELLO THANK YOU GOOD LUCK TO YOU)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(t.length,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열의 총 문자 개수를 반환합니다. (공백포함 32)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> s=t.split(<span class=\"string\">\" \"</span>);  </span><br><span class=\"line\"><span class=\"comment\">//  \" \"(공백) 문자를 기준으로 문자를 분리하여 s에 저장합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(s[<span class=\"number\">0</span>],<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// s 인덱스 0에 저장된 문자열을 출력합니다. (Hello)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(s[<span class=\"number\">4</span>],<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// s 인덱스 4에 저장된 문자열을 출력합니다. (luck)</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"사용자에게-입력받은-이메일-유효성-검사-예제\"><a href=\"#사용자에게-입력받은-이메일-유효성-검사-예제\" class=\"headerlink\" title=\"사용자에게 입력받은 이메일 유효성 검사 예제\"></a>사용자에게 입력받은 이메일 유효성 검사 예제</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userEmail=prompt(<span class=\"string\">\"당신의 이메일 주소는?\"</span>,<span class=\"string\">\"\"</span>);  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">var</span> check1=<span class=\"literal\">false</span>; <span class=\"comment\">//초기 값 저장  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> check2=<span class=\"literal\">false</span>; <span class=\"comment\">//초기 값 저장  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//이메일 주소에 뒷부분 형식을 배열로 저장  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrUrl=[<span class=\"string\">\".co.kr\"</span>,<span class=\"string\">\".com\"</span>,<span class=\"string\">\".net\"</span>,<span class=\"string\">\".or.kr\"</span>,<span class=\"string\">\".go.kr\"</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/*방문자가 입력한 이메일 주소에 \"@\"포함되어 있으면 변수  </span></span><br><span class=\"line\"><span class=\"comment\">check1에 true가 저장*/</span>  </span><br><span class=\"line\"><span class=\"keyword\">if</span>(userEmail.indexOf(<span class=\"string\">\"@\"</span>)&gt;<span class=\"number\">0</span>) check1=<span class=\"literal\">true</span>; <span class=\"comment\">//indexOf는 찾는 문자가 없는경우만 -1을 반환 합니다.  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">//이메일에 배열 데이터 포함여부 검사  </span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;arrUrl.length; i++)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">if</span>(userEmail.indexOf(arrUrl[i])&gt;<span class=\"number\">0</span>) check2=<span class=\"literal\">true</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//AND(&amp;&amp;)연산자는 모두 피연산자가 모두 true여야 true를 반환합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(check1&amp;&amp;check2)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(userEmail);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\"> alert(<span class=\"string\">\"이메일 형식이 잘못되었습니다.\"</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Set 오브젝트 -ECMAScript","date":"2020-04-13T01:32:44.000Z","disqusId":"tunas-blog-1","_content":"\n\nSet 오브젝트는 Map 오브젝트와 비슷하지만 [key, value]가 아닌 [value]만 작성하는 점이 다릅니다. Map 오브젝트에 Array 기능을 추가한 오브젝트 입니다.\n\n*   Set 오브젝트\n    *   [개요](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set)\n    *   [new Set(): Set 인스턴스 생성](/2020/04/13/Set%20오브젝트%20-ECMAScript/#newSet)\n    *   [add(): value 추가](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_add)\n    *   [has(): value 존재 여부](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_has)\n    *   [entries(): 이터레이터 오브젝트 생성](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_entries)\n    *   [values(): value 반환 이터레이터 오브젝트 생성](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_values)\n    *   [keys(): key 반환 이터레이터 오브젝트 생성](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_keys)\n    *   [forEach(): 엘리먼트마다 콜백 함수 호출](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_forEach)\n    *   [delete(): 엘리먼트 삭제](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_delete)\n    *   [clear(): 모든 value 지움](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_clear)\n    *   [Symbol.iterator: 이터레이터 오브젝트 생성](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_Symbol_iterator)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Set\">개요</h2>\n\nSet 오브젝트는 Array 오브젝트와 비슷하지만, Array 오브젝트에 없는 특성이 있습니다.  \nSet 오브젝트는 [value1, value2, ···]와 같이 값을 배열로 작성합니다.  \nSet 오브젝트에 추가한 순서로 인덱스를 부여하여 저장합니다. 따라서 추가한 순서대로 읽히는 것을 보장해 줍니다.\n\nSet 오브젝트는 key 개념을 갖고 있으며 value1, value2가 값이면서 키 역활도 합니다.  \n역활을 하는 것이지 key가 별도로 존재하는 것은 아닙니다.  \n이런 특징으로 인해 value 값이 같으면 나중에 추가한 값이 추가되지 않습니다.  \n이 점이 Array 오브젝트와 다르며 Map 오브젝트와 같습니다.\n\n[value1, value2]에 string, number, symbol 등의 원시값(프리미티브) 데이터 타입을 작성할 수 있으며, Object, Function과 같은 오브젝트도 작성할 수 있습니다. null 값은 undefined로 취급됩니다.\n\nArray 오브젝트에서 엘리먼트를 삭제하려면 배열을 반복하면서 값의 일치 여부를 비교해야 합니다.  \n같은 값이 여러 개 있을 수 있으므로 모두 삭제하려면 계속해서 비교하며 삭제가 진행됩니다.  \n반면 Set 오브젝트는 value 값이 같은 것이 없으므로 삭제를 한 번만 실행하면 됩니다.\n\n* * *\n\n<h2 id=\"newSet\">new Set(): Set 인스턴스 생성</h2>\n\nSet 인스턴스를 생성하여 반환합니다.\n\n> new Set()\n\n*   선택적 파라미터  \n    파라미터는 선택으로 이터러블 오브젝트를 작성하고, 그 안에 value를 0개 이상 작성합니다.\n\n```js Set()\nconst setObj = new Set();  \n  \n1. const newSet = new Set([1, 2, 1, 2, \"스포츠\"]);  \n2. console.log(newSet.size);  \n  \n3. for (let element of newSet){  \n console.log(element);  \n};  \n// 3  \n// 1  \n// 2  \n// 스포츠  \n```\n\n*   Set( ) 파라미터에 value를 지정하지 않고 인스턴스를 생성할 수 있습니다. 추후에 Set 오브젝트의 메서드를 이용해서 value를 추가해줄 수 있습니다.\n\n1.  Set( ) 파라미터에 이터러블 오브젝트를 작성하고, 그 안에 value를 작성한 형태입니다.  \n    Set 인스턴스에 저장할 때 파라미터 값이 key 역활을 하면서 value로 저장됩니다.  \n    Set 인스턴스에서 value의 존재 여부를 체크하고 존재하지 않으면 추가, 존재하면 추가하지 않습니다.\n\n2.  size 프로퍼티는 Set 인스턴스의 value 수를 반환합니다. Set() 파라미터에 5개의 값을 작성했는데, 실행 결과 3이 출력됩니다. 이는 같은 파라미터값은 뒤에 작성한 값이 추가되지 않기 때문입니다.\n\n3.  for-of 문으로 newSet 인스턴스를 반복할 수 있습니다. newSet 인스턴스의 value가 for-of 문의 element에 설정됩니다.\n\n* * *\n\n<h2 id=\"Set_add\">add(): value 추가</h2>\n\nSet 인스턴스 끝에 value 값을 추가합니다.\n\n> Set.prototype.add()\n\n파라미터에 Set 인스턴스에 추가할 String, 오브젝트 등의 value를 지정합니다. 값을 추가 한 후 Set 인스턴스를 반환합니다. 따라서 메서드 체인 방법으로 Set 인스턴스의 메서드를 호출할 수 있습니다.\n\n```js add()\n1. const newSet = new Set();  \nnewSet.add(\"축구\").add(\"농구\");  \n  \n2. newSet.add(\"축구\");  \n  \n3. for (let element of newSet) {  \n console.log(element);  \n};  \n// 축구  \n// 농구  \n```\n\n1.  Set 인스턴스를 생성하여 newSet에 할당합니다. add() 파라미터에 “축구”를 지정하여 실행하면, Set 인스턴스에 “축구”가 추가되며 인덱스 값은 0 입니다. add()를 실행한 후 newSet 인스턴스를 반환하므로 add()를 연결하여 호출할 수 있습니다. “농구”가 추가되고 인덱스 값은 1 입니다.\n\n2.  add() 파라미터에 지정한 “축구”가 Set 인스턴스에 존재하므로 “축구”가 추가되지 않습니다.\n\n3.  for-of 문으로 newSet 인스턴스를 반복하면, newSet 인스턴스의 value가 for-of 문의 element에 설정됩니다.  \n    newSet 인스턴스에 추가된 순서대로 전개됩니다.\n\n* * *\n\n<h2 id=\"Set_has\">has(): value 존재 여부</h2>\n\nSet 인스턴스에서 value의 존재 여부를 반환합니다.\n\n> Set.prototype.has()\n\n파라미터에 존재 여부를 체크할 값을 지정합니다. Set 인스턴스에 값이 존재하면 true, 아니면 false를 반환합니다.\n\n```js has()\nconst newSet = new Set();  \nnewSet.add(\"sports\");  \n  \nconsole.log(newSet.has(\"sports\"));  \n// true  \n```\n\n*   Set 인스턴스를 생성하여 newSet 변수에 할당했습니다. add()를 실행하면 파라미터에 지정한 “sports”가 newSet 인스턴스에 추가됩니다. newSet 인스턴스에 has() 파라미터에 지정한 “sports”가 존재합니다. true를 반환합니다.\n\n* * *\n\n<h2 id=\"Set_entries\">entries(): 이터레이터 오브젝트 생성</h2>\n\n이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Set.prototype.entries()\n\n생성한 이터레이터 오브젝트의 next()를 호출하면 Set 인스턴스에 작성된 순서로 [key, value]를 반환합니다.  \nSet 인스턴스에 key를 저장하지 않지만 value를 key에 설정하여 반환합니다.\n\n```js entries()\n1. const newSet = new Set([\"one\", () => {}]);  \nlet iteratorObj = newSet.entries();  \n  \n2. console.log(iteratorObj.next());  \n3. console.log(iteratorObj.next());  \n// Object {value: Array[2], done: false}  \n// Object {value: Array[2], done: false}  \n```\n\n1.  두 개의 value를 가진 Set 인스턴스를 생성합니다. 하나는 “one”이고 또 하나는 function(){}입니다. entries()를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.\n\n2.  첫 번째 value인 “one”을 반환하며 실행 결과에 {value: Array[2], done: false}가 출력됩니다.  \n    value를 반환하므로 {value: “one”, done: false} 형태로 반환되어야 하지만, value를 key에 설정하여 반환하므로 {value: Array[2]} 형태가 됩니다. Array[2]를 펼치면 0:”one”, 1:”one”이 표시됩니다.\n\n3.  마찬가지로 value인 function(){}을 반환하며 {value: Array[2], done: false} 형태입니다.  \n    Array[2]를 펼치면 0: function(){}, 1: function(){}이 표시됩니다.\n\n* * *\n\n<h2 id=\"Set_values\">values(): value 반환 이터레이터 오브젝트 생성</h2>\n\nvalue 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Set.prototype.value\n\n생성한 이터레이터 오브젝트의 next()를 호출하면 Set 인스턴스에 작성된 순서로 value를 반환합니다.\n\n```js values()\n1. const newSet = new Set([\"one\", () => {}]);  \nlet iteratorObj = newSet.values();  \n  \n2. console.log(iteratorObj.next());  \n3. console.log(iteratorObj.next());  \n// Object {value: \"one\", done: false}  \n// Object {value: function, done: false}  \n```\n\n1.  두 개의 value를 가진 Set 인스턴스를 생성합니다. 하나는 “one” 또 하나는 function(){}입니다.  \n    인스턴스의 values()를 호출하면 value를 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n2.  첫 번째 value인 “one”이 대상이며 {value: “one”, done: false}를 반환합니다.  \n    etntries() 메서드가 {value: Array[2]}를 반환하는 것과 차이점 입니다.\n\n3.  두 번째 value인 function(){}이 대상이며 {value: function(){}, done: false}를 반환합니다.\n\n* * *\n\n<h2 id=\"Set_keys\">keys(): key 반환 이터레이터 오브젝트 생성</h2>\n\nkey 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Set.prototype.keys()\n\n생성한 이터레이터 오브젝트의 next()를 호출하면 Set 인스턴스에 작성된 순서로 key 값을 반환합니다.  \nSet 인스턴스에 value만 설정되므로 value를 key로 하여 반환합니다.  \n그다지 의미가 없지만 같은 이름의 Map 인스턴스 메서드와 반환 구조를 맞추기 위한 것으로 생각됩니다.\n\n```js keys()\nconst newSet = new Set([\"one\", () => {}]);  \nlet iteratorObj = newSet.keys();  \n  \nconsole.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \n// Object {value: \"one\", done: false}  \n// Object {value: function(){}, done: false}  \n```\n\n*   앞의 예제들과 주어진 값은 같습니다.  \n    keys()를 호출하면 value를 key로 하여 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.  \n    <mark>반환되는 프로퍼티 이름이 key가 아닌 value입니다.</mark>\n\n* * *\n\n<h2 id=\"Set_forEach\">forEach(): 엘리먼트마다 콜백 함수 호출</h2>\n\nSet 인스턴스에 작성된 순서로 반복하면서 콜백 함수를 호출합니다.\n\n> Set.prototype.forEach()\n\n*   파라미터  \n    Function (반복할 때 마다 호출할 callback 함수)  \n    Object (선택) callback 함수에서 this로 참조할 오브젝트\n\nforEach()를 호출할 때마다 세 개의 파라미터를 넘겨줍니다.  \n첫 번째 파라미터가 value이고 두 번째 파라미터가 key입니다. 세 번째 파라미터는 실행 중인 Set 인스턴스 입니다.  \n<mark>value 값과 key 값이 같습니다.</mark>\n\n```js forEach()\nconst newSet = new Set([\"one\", \"two\"]);  \n  \nnewSet.forEach(function(value, key, obj) {  \n console.log(value, this.member);  \n}, {member: 10});  \n// one : 10  \n// two : 10  \n```\n\n*   forEach()를 처음 호출하면 콜백 함수의 value 와 key 파라미터에 “one”이 설정되고 obj 파라미터에 newSet 인스턴스가 설정됩니다. 콜백 함수에서 this로 forEach() 두 번째 파라미터에 지정한 Object 오브젝트를 참조합니다.\n\n<mark>화살표 함수로 콜백 함수를 작성하면 콜백 함수 블록에서 this가 window 오브젝트를 참조하므로 이 코드와 같이 function 키워드로 작성해야 합니다.</mark>\n\n* * *\n\n<h2 id=\"Set_delete\">delete(): 엘리먼트 삭제</h2>\n\nSet 인스턴스에서 value 값이 같은 엘리먼트를 삭제합니다.\n\n> Set.prototype.delete()\n\n*   파라미터  \n    삭제할 value\n    \n*   반환 값  \n    삭제 성공시 true, 아니면 false 반환\n    \n\n```js delete()\nconst newSet = new Set([\"one\"]);  \n  \nconsole.log(newSet.delete(\"one\"));  \n// true  \n```\n\n*   newSet 인스턴스에서 delete() 파라미터에 지정한 “one” 과 같은 value가 있으면 엘리먼트를 삭제합니다.  \n    삭제되므로 true를 반환합니다.\n\n* * *\n\n<h2 id=\"Set_clear\">clear(): 모든 value 지움</h2>\n\nSet 인스턴스의 모든 value()를 지웁니다.\n\n> Set.prototype.clear()\n\n```js clear()\nconst newSet = new Set([\"one\", \"two\"]);  \nnewSet.clear();  \nconsole.log(newSet.size);  \n// 0  \n```\n\n*   clear()를 실행하면 newSet 인스턴스에서 엘리먼트를 모두 지우므로 size 프로퍼티 값이 0으로 출력됩니다. 인스턴스 자체를 지우는 것이 아니라 엘리먼트를 모두 지우는 것 이므로 다시 value를 추가해줄 수 있습니다.\n\n* * *\n\n<h2 id=\"Set_Symbol_iterator\">Symbol.iterator: 이터레이터 오브젝트 생성</h2>\n\n이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Set.prototype[Symbol.iterator]\n\n생성한 이터레이터 오브젝트의 next()를 호출하면, Set 인스턴스에 작성된 순서로 value를 반환합니다.\n\n```js Symbol.iterator\n1. const newSet = new Set([1, \"스포츠\"]);  \nlet iteratorObj = newSet[Symbol.iterator]();  \n  \n2. console.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \n// Object {value: 1, done: false}  \n// Object {value: \"스포츠\", done: false}  \n```\n\n1.  newSet 인스턴스를 생성하고 [1, “스포츠”]를 할당합니다.  \n    newSet 인스턴스의 [Symbol.iterator] ()를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.\n\n2.  next()를 호출할 때마다 newSet 인스턴스의 value값을 {value: 1, done: false} 형태의 value에 설정하여 반환합니다.\n","source":"_posts/Set 오브젝트 -ECMAScript.md","raw":"---\ntitle: Set 오브젝트 -ECMAScript\ndate: 2020-04-13 10:32:44\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n\nSet 오브젝트는 Map 오브젝트와 비슷하지만 [key, value]가 아닌 [value]만 작성하는 점이 다릅니다. Map 오브젝트에 Array 기능을 추가한 오브젝트 입니다.\n\n*   Set 오브젝트\n    *   [개요](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set)\n    *   [new Set(): Set 인스턴스 생성](/2020/04/13/Set%20오브젝트%20-ECMAScript/#newSet)\n    *   [add(): value 추가](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_add)\n    *   [has(): value 존재 여부](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_has)\n    *   [entries(): 이터레이터 오브젝트 생성](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_entries)\n    *   [values(): value 반환 이터레이터 오브젝트 생성](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_values)\n    *   [keys(): key 반환 이터레이터 오브젝트 생성](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_keys)\n    *   [forEach(): 엘리먼트마다 콜백 함수 호출](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_forEach)\n    *   [delete(): 엘리먼트 삭제](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_delete)\n    *   [clear(): 모든 value 지움](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_clear)\n    *   [Symbol.iterator: 이터레이터 오브젝트 생성](/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_Symbol_iterator)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Set\">개요</h2>\n\nSet 오브젝트는 Array 오브젝트와 비슷하지만, Array 오브젝트에 없는 특성이 있습니다.  \nSet 오브젝트는 [value1, value2, ···]와 같이 값을 배열로 작성합니다.  \nSet 오브젝트에 추가한 순서로 인덱스를 부여하여 저장합니다. 따라서 추가한 순서대로 읽히는 것을 보장해 줍니다.\n\nSet 오브젝트는 key 개념을 갖고 있으며 value1, value2가 값이면서 키 역활도 합니다.  \n역활을 하는 것이지 key가 별도로 존재하는 것은 아닙니다.  \n이런 특징으로 인해 value 값이 같으면 나중에 추가한 값이 추가되지 않습니다.  \n이 점이 Array 오브젝트와 다르며 Map 오브젝트와 같습니다.\n\n[value1, value2]에 string, number, symbol 등의 원시값(프리미티브) 데이터 타입을 작성할 수 있으며, Object, Function과 같은 오브젝트도 작성할 수 있습니다. null 값은 undefined로 취급됩니다.\n\nArray 오브젝트에서 엘리먼트를 삭제하려면 배열을 반복하면서 값의 일치 여부를 비교해야 합니다.  \n같은 값이 여러 개 있을 수 있으므로 모두 삭제하려면 계속해서 비교하며 삭제가 진행됩니다.  \n반면 Set 오브젝트는 value 값이 같은 것이 없으므로 삭제를 한 번만 실행하면 됩니다.\n\n* * *\n\n<h2 id=\"newSet\">new Set(): Set 인스턴스 생성</h2>\n\nSet 인스턴스를 생성하여 반환합니다.\n\n> new Set()\n\n*   선택적 파라미터  \n    파라미터는 선택으로 이터러블 오브젝트를 작성하고, 그 안에 value를 0개 이상 작성합니다.\n\n```js Set()\nconst setObj = new Set();  \n  \n1. const newSet = new Set([1, 2, 1, 2, \"스포츠\"]);  \n2. console.log(newSet.size);  \n  \n3. for (let element of newSet){  \n console.log(element);  \n};  \n// 3  \n// 1  \n// 2  \n// 스포츠  \n```\n\n*   Set( ) 파라미터에 value를 지정하지 않고 인스턴스를 생성할 수 있습니다. 추후에 Set 오브젝트의 메서드를 이용해서 value를 추가해줄 수 있습니다.\n\n1.  Set( ) 파라미터에 이터러블 오브젝트를 작성하고, 그 안에 value를 작성한 형태입니다.  \n    Set 인스턴스에 저장할 때 파라미터 값이 key 역활을 하면서 value로 저장됩니다.  \n    Set 인스턴스에서 value의 존재 여부를 체크하고 존재하지 않으면 추가, 존재하면 추가하지 않습니다.\n\n2.  size 프로퍼티는 Set 인스턴스의 value 수를 반환합니다. Set() 파라미터에 5개의 값을 작성했는데, 실행 결과 3이 출력됩니다. 이는 같은 파라미터값은 뒤에 작성한 값이 추가되지 않기 때문입니다.\n\n3.  for-of 문으로 newSet 인스턴스를 반복할 수 있습니다. newSet 인스턴스의 value가 for-of 문의 element에 설정됩니다.\n\n* * *\n\n<h2 id=\"Set_add\">add(): value 추가</h2>\n\nSet 인스턴스 끝에 value 값을 추가합니다.\n\n> Set.prototype.add()\n\n파라미터에 Set 인스턴스에 추가할 String, 오브젝트 등의 value를 지정합니다. 값을 추가 한 후 Set 인스턴스를 반환합니다. 따라서 메서드 체인 방법으로 Set 인스턴스의 메서드를 호출할 수 있습니다.\n\n```js add()\n1. const newSet = new Set();  \nnewSet.add(\"축구\").add(\"농구\");  \n  \n2. newSet.add(\"축구\");  \n  \n3. for (let element of newSet) {  \n console.log(element);  \n};  \n// 축구  \n// 농구  \n```\n\n1.  Set 인스턴스를 생성하여 newSet에 할당합니다. add() 파라미터에 “축구”를 지정하여 실행하면, Set 인스턴스에 “축구”가 추가되며 인덱스 값은 0 입니다. add()를 실행한 후 newSet 인스턴스를 반환하므로 add()를 연결하여 호출할 수 있습니다. “농구”가 추가되고 인덱스 값은 1 입니다.\n\n2.  add() 파라미터에 지정한 “축구”가 Set 인스턴스에 존재하므로 “축구”가 추가되지 않습니다.\n\n3.  for-of 문으로 newSet 인스턴스를 반복하면, newSet 인스턴스의 value가 for-of 문의 element에 설정됩니다.  \n    newSet 인스턴스에 추가된 순서대로 전개됩니다.\n\n* * *\n\n<h2 id=\"Set_has\">has(): value 존재 여부</h2>\n\nSet 인스턴스에서 value의 존재 여부를 반환합니다.\n\n> Set.prototype.has()\n\n파라미터에 존재 여부를 체크할 값을 지정합니다. Set 인스턴스에 값이 존재하면 true, 아니면 false를 반환합니다.\n\n```js has()\nconst newSet = new Set();  \nnewSet.add(\"sports\");  \n  \nconsole.log(newSet.has(\"sports\"));  \n// true  \n```\n\n*   Set 인스턴스를 생성하여 newSet 변수에 할당했습니다. add()를 실행하면 파라미터에 지정한 “sports”가 newSet 인스턴스에 추가됩니다. newSet 인스턴스에 has() 파라미터에 지정한 “sports”가 존재합니다. true를 반환합니다.\n\n* * *\n\n<h2 id=\"Set_entries\">entries(): 이터레이터 오브젝트 생성</h2>\n\n이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Set.prototype.entries()\n\n생성한 이터레이터 오브젝트의 next()를 호출하면 Set 인스턴스에 작성된 순서로 [key, value]를 반환합니다.  \nSet 인스턴스에 key를 저장하지 않지만 value를 key에 설정하여 반환합니다.\n\n```js entries()\n1. const newSet = new Set([\"one\", () => {}]);  \nlet iteratorObj = newSet.entries();  \n  \n2. console.log(iteratorObj.next());  \n3. console.log(iteratorObj.next());  \n// Object {value: Array[2], done: false}  \n// Object {value: Array[2], done: false}  \n```\n\n1.  두 개의 value를 가진 Set 인스턴스를 생성합니다. 하나는 “one”이고 또 하나는 function(){}입니다. entries()를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.\n\n2.  첫 번째 value인 “one”을 반환하며 실행 결과에 {value: Array[2], done: false}가 출력됩니다.  \n    value를 반환하므로 {value: “one”, done: false} 형태로 반환되어야 하지만, value를 key에 설정하여 반환하므로 {value: Array[2]} 형태가 됩니다. Array[2]를 펼치면 0:”one”, 1:”one”이 표시됩니다.\n\n3.  마찬가지로 value인 function(){}을 반환하며 {value: Array[2], done: false} 형태입니다.  \n    Array[2]를 펼치면 0: function(){}, 1: function(){}이 표시됩니다.\n\n* * *\n\n<h2 id=\"Set_values\">values(): value 반환 이터레이터 오브젝트 생성</h2>\n\nvalue 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Set.prototype.value\n\n생성한 이터레이터 오브젝트의 next()를 호출하면 Set 인스턴스에 작성된 순서로 value를 반환합니다.\n\n```js values()\n1. const newSet = new Set([\"one\", () => {}]);  \nlet iteratorObj = newSet.values();  \n  \n2. console.log(iteratorObj.next());  \n3. console.log(iteratorObj.next());  \n// Object {value: \"one\", done: false}  \n// Object {value: function, done: false}  \n```\n\n1.  두 개의 value를 가진 Set 인스턴스를 생성합니다. 하나는 “one” 또 하나는 function(){}입니다.  \n    인스턴스의 values()를 호출하면 value를 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n2.  첫 번째 value인 “one”이 대상이며 {value: “one”, done: false}를 반환합니다.  \n    etntries() 메서드가 {value: Array[2]}를 반환하는 것과 차이점 입니다.\n\n3.  두 번째 value인 function(){}이 대상이며 {value: function(){}, done: false}를 반환합니다.\n\n* * *\n\n<h2 id=\"Set_keys\">keys(): key 반환 이터레이터 오브젝트 생성</h2>\n\nkey 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Set.prototype.keys()\n\n생성한 이터레이터 오브젝트의 next()를 호출하면 Set 인스턴스에 작성된 순서로 key 값을 반환합니다.  \nSet 인스턴스에 value만 설정되므로 value를 key로 하여 반환합니다.  \n그다지 의미가 없지만 같은 이름의 Map 인스턴스 메서드와 반환 구조를 맞추기 위한 것으로 생각됩니다.\n\n```js keys()\nconst newSet = new Set([\"one\", () => {}]);  \nlet iteratorObj = newSet.keys();  \n  \nconsole.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \n// Object {value: \"one\", done: false}  \n// Object {value: function(){}, done: false}  \n```\n\n*   앞의 예제들과 주어진 값은 같습니다.  \n    keys()를 호출하면 value를 key로 하여 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.  \n    <mark>반환되는 프로퍼티 이름이 key가 아닌 value입니다.</mark>\n\n* * *\n\n<h2 id=\"Set_forEach\">forEach(): 엘리먼트마다 콜백 함수 호출</h2>\n\nSet 인스턴스에 작성된 순서로 반복하면서 콜백 함수를 호출합니다.\n\n> Set.prototype.forEach()\n\n*   파라미터  \n    Function (반복할 때 마다 호출할 callback 함수)  \n    Object (선택) callback 함수에서 this로 참조할 오브젝트\n\nforEach()를 호출할 때마다 세 개의 파라미터를 넘겨줍니다.  \n첫 번째 파라미터가 value이고 두 번째 파라미터가 key입니다. 세 번째 파라미터는 실행 중인 Set 인스턴스 입니다.  \n<mark>value 값과 key 값이 같습니다.</mark>\n\n```js forEach()\nconst newSet = new Set([\"one\", \"two\"]);  \n  \nnewSet.forEach(function(value, key, obj) {  \n console.log(value, this.member);  \n}, {member: 10});  \n// one : 10  \n// two : 10  \n```\n\n*   forEach()를 처음 호출하면 콜백 함수의 value 와 key 파라미터에 “one”이 설정되고 obj 파라미터에 newSet 인스턴스가 설정됩니다. 콜백 함수에서 this로 forEach() 두 번째 파라미터에 지정한 Object 오브젝트를 참조합니다.\n\n<mark>화살표 함수로 콜백 함수를 작성하면 콜백 함수 블록에서 this가 window 오브젝트를 참조하므로 이 코드와 같이 function 키워드로 작성해야 합니다.</mark>\n\n* * *\n\n<h2 id=\"Set_delete\">delete(): 엘리먼트 삭제</h2>\n\nSet 인스턴스에서 value 값이 같은 엘리먼트를 삭제합니다.\n\n> Set.prototype.delete()\n\n*   파라미터  \n    삭제할 value\n    \n*   반환 값  \n    삭제 성공시 true, 아니면 false 반환\n    \n\n```js delete()\nconst newSet = new Set([\"one\"]);  \n  \nconsole.log(newSet.delete(\"one\"));  \n// true  \n```\n\n*   newSet 인스턴스에서 delete() 파라미터에 지정한 “one” 과 같은 value가 있으면 엘리먼트를 삭제합니다.  \n    삭제되므로 true를 반환합니다.\n\n* * *\n\n<h2 id=\"Set_clear\">clear(): 모든 value 지움</h2>\n\nSet 인스턴스의 모든 value()를 지웁니다.\n\n> Set.prototype.clear()\n\n```js clear()\nconst newSet = new Set([\"one\", \"two\"]);  \nnewSet.clear();  \nconsole.log(newSet.size);  \n// 0  \n```\n\n*   clear()를 실행하면 newSet 인스턴스에서 엘리먼트를 모두 지우므로 size 프로퍼티 값이 0으로 출력됩니다. 인스턴스 자체를 지우는 것이 아니라 엘리먼트를 모두 지우는 것 이므로 다시 value를 추가해줄 수 있습니다.\n\n* * *\n\n<h2 id=\"Set_Symbol_iterator\">Symbol.iterator: 이터레이터 오브젝트 생성</h2>\n\n이터레이터 오브젝트를 생성하여 반환합니다.\n\n> Set.prototype[Symbol.iterator]\n\n생성한 이터레이터 오브젝트의 next()를 호출하면, Set 인스턴스에 작성된 순서로 value를 반환합니다.\n\n```js Symbol.iterator\n1. const newSet = new Set([1, \"스포츠\"]);  \nlet iteratorObj = newSet[Symbol.iterator]();  \n  \n2. console.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \n// Object {value: 1, done: false}  \n// Object {value: \"스포츠\", done: false}  \n```\n\n1.  newSet 인스턴스를 생성하고 [1, “스포츠”]를 할당합니다.  \n    newSet 인스턴스의 [Symbol.iterator] ()를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.\n\n2.  next()를 호출할 때마다 newSet 인스턴스의 value값을 {value: 1, done: false} 형태의 value에 설정하여 반환합니다.\n","slug":"Set 오브젝트 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrss001nqgvqbhxu90nl","content":"<p>Set 오브젝트는 Map 오브젝트와 비슷하지만 [key, value]가 아닌 [value]만 작성하는 점이 다릅니다. Map 오브젝트에 Array 기능을 추가한 오브젝트 입니다.</p>\n<ul>\n<li>Set 오브젝트<ul>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set\">개요</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#newSet\">new Set(): Set 인스턴스 생성</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_add\">add(): value 추가</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_has\">has(): value 존재 여부</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_entries\">entries(): 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_values\">values(): value 반환 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_keys\">keys(): key 반환 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_forEach\">forEach(): 엘리먼트마다 콜백 함수 호출</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_delete\">delete(): 엘리먼트 삭제</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_clear\">clear(): 모든 value 지움</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_Symbol_iterator\">Symbol.iterator: 이터레이터 오브젝트 생성</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"Set\">개요</h2>\n\n<p>Set 오브젝트는 Array 오브젝트와 비슷하지만, Array 오브젝트에 없는 특성이 있습니다.<br>Set 오브젝트는 [value1, value2, ···]와 같이 값을 배열로 작성합니다.<br>Set 오브젝트에 추가한 순서로 인덱스를 부여하여 저장합니다. 따라서 추가한 순서대로 읽히는 것을 보장해 줍니다.</p>\n<p>Set 오브젝트는 key 개념을 갖고 있으며 value1, value2가 값이면서 키 역활도 합니다.<br>역활을 하는 것이지 key가 별도로 존재하는 것은 아닙니다.<br>이런 특징으로 인해 value 값이 같으면 나중에 추가한 값이 추가되지 않습니다.<br>이 점이 Array 오브젝트와 다르며 Map 오브젝트와 같습니다.</p>\n<p>[value1, value2]에 string, number, symbol 등의 원시값(프리미티브) 데이터 타입을 작성할 수 있으며, Object, Function과 같은 오브젝트도 작성할 수 있습니다. null 값은 undefined로 취급됩니다.</p>\n<p>Array 오브젝트에서 엘리먼트를 삭제하려면 배열을 반복하면서 값의 일치 여부를 비교해야 합니다.<br>같은 값이 여러 개 있을 수 있으므로 모두 삭제하려면 계속해서 비교하며 삭제가 진행됩니다.<br>반면 Set 오브젝트는 value 값이 같은 것이 없으므로 삭제를 한 번만 실행하면 됩니다.</p>\n<hr>\n<h2 id=\"newSet\">new Set(): Set 인스턴스 생성</h2>\n\n<p>Set 인스턴스를 생성하여 반환합니다.</p>\n<blockquote>\n<p>new Set()</p>\n</blockquote>\n<ul>\n<li>선택적 파라미터<br>파라미터는 선택으로 이터러블 오브젝트를 작성하고, 그 안에 value를 0개 이상 작성합니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>Set()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> setObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">\"스포츠\"</span>]);  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(newSet.size);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> element <span class=\"keyword\">of</span> newSet)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(element);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// 3  </span></span><br><span class=\"line\"><span class=\"comment\">// 1  </span></span><br><span class=\"line\"><span class=\"comment\">// 2  </span></span><br><span class=\"line\"><span class=\"comment\">// 스포츠</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Set( ) 파라미터에 value를 지정하지 않고 인스턴스를 생성할 수 있습니다. 추후에 Set 오브젝트의 메서드를 이용해서 value를 추가해줄 수 있습니다.</li>\n</ul>\n<ol>\n<li><p>Set( ) 파라미터에 이터러블 오브젝트를 작성하고, 그 안에 value를 작성한 형태입니다.<br>Set 인스턴스에 저장할 때 파라미터 값이 key 역활을 하면서 value로 저장됩니다.<br>Set 인스턴스에서 value의 존재 여부를 체크하고 존재하지 않으면 추가, 존재하면 추가하지 않습니다.</p>\n</li>\n<li><p>size 프로퍼티는 Set 인스턴스의 value 수를 반환합니다. Set() 파라미터에 5개의 값을 작성했는데, 실행 결과 3이 출력됩니다. 이는 같은 파라미터값은 뒤에 작성한 값이 추가되지 않기 때문입니다.</p>\n</li>\n<li><p>for-of 문으로 newSet 인스턴스를 반복할 수 있습니다. newSet 인스턴스의 value가 for-of 문의 element에 설정됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Set_add\">add(): value 추가</h2>\n\n<p>Set 인스턴스 끝에 value 값을 추가합니다.</p>\n<blockquote>\n<p>Set.prototype.add()</p>\n</blockquote>\n<p>파라미터에 Set 인스턴스에 추가할 String, 오브젝트 등의 value를 지정합니다. 값을 추가 한 후 Set 인스턴스를 반환합니다. 따라서 메서드 체인 방법으로 Set 인스턴스의 메서드를 호출할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>add()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();  </span><br><span class=\"line\">newSet.add(<span class=\"string\">\"축구\"</span>).add(<span class=\"string\">\"농구\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> newSet.add(<span class=\"string\">\"축구\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> element <span class=\"keyword\">of</span> newSet) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(element);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// 축구  </span></span><br><span class=\"line\"><span class=\"comment\">// 농구</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Set 인스턴스를 생성하여 newSet에 할당합니다. add() 파라미터에 “축구”를 지정하여 실행하면, Set 인스턴스에 “축구”가 추가되며 인덱스 값은 0 입니다. add()를 실행한 후 newSet 인스턴스를 반환하므로 add()를 연결하여 호출할 수 있습니다. “농구”가 추가되고 인덱스 값은 1 입니다.</p>\n</li>\n<li><p>add() 파라미터에 지정한 “축구”가 Set 인스턴스에 존재하므로 “축구”가 추가되지 않습니다.</p>\n</li>\n<li><p>for-of 문으로 newSet 인스턴스를 반복하면, newSet 인스턴스의 value가 for-of 문의 element에 설정됩니다.<br>newSet 인스턴스에 추가된 순서대로 전개됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Set_has\">has(): value 존재 여부</h2>\n\n<p>Set 인스턴스에서 value의 존재 여부를 반환합니다.</p>\n<blockquote>\n<p>Set.prototype.has()</p>\n</blockquote>\n<p>파라미터에 존재 여부를 체크할 값을 지정합니다. Set 인스턴스에 값이 존재하면 true, 아니면 false를 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>has()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();  </span><br><span class=\"line\">newSet.add(<span class=\"string\">\"sports\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newSet.has(<span class=\"string\">\"sports\"</span>));  </span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Set 인스턴스를 생성하여 newSet 변수에 할당했습니다. add()를 실행하면 파라미터에 지정한 “sports”가 newSet 인스턴스에 추가됩니다. newSet 인스턴스에 has() 파라미터에 지정한 “sports”가 존재합니다. true를 반환합니다.</li>\n</ul>\n<hr>\n<h2 id=\"Set_entries\">entries(): 이터레이터 오브젝트 생성</h2>\n\n<p>이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Set.prototype.entries()</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트의 next()를 호출하면 Set 인스턴스에 작성된 순서로 [key, value]를 반환합니다.<br>Set 인스턴스에 key를 저장하지 않지만 value를 key에 설정하여 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>entries()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"one\"</span>, () =&gt; &#123;&#125;]);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iteratorObj = newSet.entries();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Array[2], done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Array[2], done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>두 개의 value를 가진 Set 인스턴스를 생성합니다. 하나는 “one”이고 또 하나는 function(){}입니다. entries()를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>첫 번째 value인 “one”을 반환하며 실행 결과에 {value: Array[2], done: false}가 출력됩니다.<br>value를 반환하므로 {value: “one”, done: false} 형태로 반환되어야 하지만, value를 key에 설정하여 반환하므로 {value: Array[2]} 형태가 됩니다. Array[2]를 펼치면 0:”one”, 1:”one”이 표시됩니다.</p>\n</li>\n<li><p>마찬가지로 value인 function(){}을 반환하며 {value: Array[2], done: false} 형태입니다.<br>Array[2]를 펼치면 0: function(){}, 1: function(){}이 표시됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Set_values\">values(): value 반환 이터레이터 오브젝트 생성</h2>\n\n<p>value 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Set.prototype.value</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트의 next()를 호출하면 Set 인스턴스에 작성된 순서로 value를 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>values()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"one\"</span>, () =&gt; &#123;&#125;]);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iteratorObj = newSet.values();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"one\", done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: function, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>두 개의 value를 가진 Set 인스턴스를 생성합니다. 하나는 “one” 또 하나는 function(){}입니다.<br>인스턴스의 values()를 호출하면 value를 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>첫 번째 value인 “one”이 대상이며 {value: “one”, done: false}를 반환합니다.<br>etntries() 메서드가 {value: Array[2]}를 반환하는 것과 차이점 입니다.</p>\n</li>\n<li><p>두 번째 value인 function(){}이 대상이며 {value: function(){}, done: false}를 반환합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Set_keys\">keys(): key 반환 이터레이터 오브젝트 생성</h2>\n\n<p>key 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Set.prototype.keys()</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트의 next()를 호출하면 Set 인스턴스에 작성된 순서로 key 값을 반환합니다.<br>Set 인스턴스에 value만 설정되므로 value를 key로 하여 반환합니다.<br>그다지 의미가 없지만 같은 이름의 Map 인스턴스 메서드와 반환 구조를 맞추기 위한 것으로 생각됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>keys()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"one\"</span>, () =&gt; &#123;&#125;]);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iteratorObj = newSet.keys();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"one\", done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: function()&#123;&#125;, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>앞의 예제들과 주어진 값은 같습니다.<br>keys()를 호출하면 value를 key로 하여 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.<br><mark>반환되는 프로퍼티 이름이 key가 아닌 value입니다.</mark></li>\n</ul>\n<hr>\n<h2 id=\"Set_forEach\">forEach(): 엘리먼트마다 콜백 함수 호출</h2>\n\n<p>Set 인스턴스에 작성된 순서로 반복하면서 콜백 함수를 호출합니다.</p>\n<blockquote>\n<p>Set.prototype.forEach()</p>\n</blockquote>\n<ul>\n<li>파라미터<br>Function (반복할 때 마다 호출할 callback 함수)<br>Object (선택) callback 함수에서 this로 참조할 오브젝트</li>\n</ul>\n<p>forEach()를 호출할 때마다 세 개의 파라미터를 넘겨줍니다.<br>첫 번째 파라미터가 value이고 두 번째 파라미터가 key입니다. 세 번째 파라미터는 실행 중인 Set 인스턴스 입니다.<br><mark>value 값과 key 값이 같습니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>forEach()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"one\"</span>, <span class=\"string\">\"two\"</span>]);  </span><br><span class=\"line\">  </span><br><span class=\"line\">newSet.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, key, obj</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value, <span class=\"keyword\">this</span>.member);  </span><br><span class=\"line\">&#125;, &#123;<span class=\"attr\">member</span>: <span class=\"number\">10</span>&#125;);  </span><br><span class=\"line\"><span class=\"comment\">// one : 10  </span></span><br><span class=\"line\"><span class=\"comment\">// two : 10</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>forEach()를 처음 호출하면 콜백 함수의 value 와 key 파라미터에 “one”이 설정되고 obj 파라미터에 newSet 인스턴스가 설정됩니다. 콜백 함수에서 this로 forEach() 두 번째 파라미터에 지정한 Object 오브젝트를 참조합니다.</li>\n</ul>\n<p><mark>화살표 함수로 콜백 함수를 작성하면 콜백 함수 블록에서 this가 window 오브젝트를 참조하므로 이 코드와 같이 function 키워드로 작성해야 합니다.</mark></p>\n<hr>\n<h2 id=\"Set_delete\">delete(): 엘리먼트 삭제</h2>\n\n<p>Set 인스턴스에서 value 값이 같은 엘리먼트를 삭제합니다.</p>\n<blockquote>\n<p>Set.prototype.delete()</p>\n</blockquote>\n<ul>\n<li><p>파라미터<br>삭제할 value</p>\n</li>\n<li><p>반환 값<br>삭제 성공시 true, 아니면 false 반환</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>delete()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"one\"</span>]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newSet.delete(<span class=\"string\">\"one\"</span>));  </span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>newSet 인스턴스에서 delete() 파라미터에 지정한 “one” 과 같은 value가 있으면 엘리먼트를 삭제합니다.<br>삭제되므로 true를 반환합니다.</li>\n</ul>\n<hr>\n<h2 id=\"Set_clear\">clear(): 모든 value 지움</h2>\n\n<p>Set 인스턴스의 모든 value()를 지웁니다.</p>\n<blockquote>\n<p>Set.prototype.clear()</p>\n</blockquote>\n<figure class=\"highlight js\"><figcaption><span>clear()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"one\"</span>, <span class=\"string\">\"two\"</span>]);  </span><br><span class=\"line\">newSet.clear();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newSet.size);  </span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>clear()를 실행하면 newSet 인스턴스에서 엘리먼트를 모두 지우므로 size 프로퍼티 값이 0으로 출력됩니다. 인스턴스 자체를 지우는 것이 아니라 엘리먼트를 모두 지우는 것 이므로 다시 value를 추가해줄 수 있습니다.</li>\n</ul>\n<hr>\n<h2 id=\"Set_Symbol_iterator\">Symbol.iterator: 이터레이터 오브젝트 생성</h2>\n\n<p>이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Set.prototype[Symbol.iterator]</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트의 next()를 호출하면, Set 인스턴스에 작성된 순서로 value를 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>Symbol.iterator</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"string\">\"스포츠\"</span>]);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iteratorObj = newSet[<span class=\"built_in\">Symbol</span>.iterator]();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 1, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"스포츠\", done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>newSet 인스턴스를 생성하고 [1, “스포츠”]를 할당합니다.<br>newSet 인스턴스의 [Symbol.iterator] ()를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>next()를 호출할 때마다 newSet 인스턴스의 value값을 {value: 1, done: false} 형태의 value에 설정하여 반환합니다.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Set 오브젝트는 Map 오브젝트와 비슷하지만 [key, value]가 아닌 [value]만 작성하는 점이 다릅니다. Map 오브젝트에 Array 기능을 추가한 오브젝트 입니다.</p>\n<ul>\n<li>Set 오브젝트<ul>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set\">개요</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#newSet\">new Set(): Set 인스턴스 생성</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_add\">add(): value 추가</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_has\">has(): value 존재 여부</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_entries\">entries(): 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_values\">values(): value 반환 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_keys\">keys(): key 반환 이터레이터 오브젝트 생성</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_forEach\">forEach(): 엘리먼트마다 콜백 함수 호출</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_delete\">delete(): 엘리먼트 삭제</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_clear\">clear(): 모든 value 지움</a></li>\n<li><a href=\"/2020/04/13/Set%20오브젝트%20-ECMAScript/#Set_Symbol_iterator\">Symbol.iterator: 이터레이터 오브젝트 생성</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"Set\">개요</h2>\n\n<p>Set 오브젝트는 Array 오브젝트와 비슷하지만, Array 오브젝트에 없는 특성이 있습니다.<br>Set 오브젝트는 [value1, value2, ···]와 같이 값을 배열로 작성합니다.<br>Set 오브젝트에 추가한 순서로 인덱스를 부여하여 저장합니다. 따라서 추가한 순서대로 읽히는 것을 보장해 줍니다.</p>\n<p>Set 오브젝트는 key 개념을 갖고 있으며 value1, value2가 값이면서 키 역활도 합니다.<br>역활을 하는 것이지 key가 별도로 존재하는 것은 아닙니다.<br>이런 특징으로 인해 value 값이 같으면 나중에 추가한 값이 추가되지 않습니다.<br>이 점이 Array 오브젝트와 다르며 Map 오브젝트와 같습니다.</p>\n<p>[value1, value2]에 string, number, symbol 등의 원시값(프리미티브) 데이터 타입을 작성할 수 있으며, Object, Function과 같은 오브젝트도 작성할 수 있습니다. null 값은 undefined로 취급됩니다.</p>\n<p>Array 오브젝트에서 엘리먼트를 삭제하려면 배열을 반복하면서 값의 일치 여부를 비교해야 합니다.<br>같은 값이 여러 개 있을 수 있으므로 모두 삭제하려면 계속해서 비교하며 삭제가 진행됩니다.<br>반면 Set 오브젝트는 value 값이 같은 것이 없으므로 삭제를 한 번만 실행하면 됩니다.</p>\n<hr>\n<h2 id=\"newSet\">new Set(): Set 인스턴스 생성</h2>\n\n<p>Set 인스턴스를 생성하여 반환합니다.</p>\n<blockquote>\n<p>new Set()</p>\n</blockquote>\n<ul>\n<li>선택적 파라미터<br>파라미터는 선택으로 이터러블 오브젝트를 작성하고, 그 안에 value를 0개 이상 작성합니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>Set()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> setObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">\"스포츠\"</span>]);  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(newSet.size);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> element <span class=\"keyword\">of</span> newSet)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(element);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// 3  </span></span><br><span class=\"line\"><span class=\"comment\">// 1  </span></span><br><span class=\"line\"><span class=\"comment\">// 2  </span></span><br><span class=\"line\"><span class=\"comment\">// 스포츠</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Set( ) 파라미터에 value를 지정하지 않고 인스턴스를 생성할 수 있습니다. 추후에 Set 오브젝트의 메서드를 이용해서 value를 추가해줄 수 있습니다.</li>\n</ul>\n<ol>\n<li><p>Set( ) 파라미터에 이터러블 오브젝트를 작성하고, 그 안에 value를 작성한 형태입니다.<br>Set 인스턴스에 저장할 때 파라미터 값이 key 역활을 하면서 value로 저장됩니다.<br>Set 인스턴스에서 value의 존재 여부를 체크하고 존재하지 않으면 추가, 존재하면 추가하지 않습니다.</p>\n</li>\n<li><p>size 프로퍼티는 Set 인스턴스의 value 수를 반환합니다. Set() 파라미터에 5개의 값을 작성했는데, 실행 결과 3이 출력됩니다. 이는 같은 파라미터값은 뒤에 작성한 값이 추가되지 않기 때문입니다.</p>\n</li>\n<li><p>for-of 문으로 newSet 인스턴스를 반복할 수 있습니다. newSet 인스턴스의 value가 for-of 문의 element에 설정됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Set_add\">add(): value 추가</h2>\n\n<p>Set 인스턴스 끝에 value 값을 추가합니다.</p>\n<blockquote>\n<p>Set.prototype.add()</p>\n</blockquote>\n<p>파라미터에 Set 인스턴스에 추가할 String, 오브젝트 등의 value를 지정합니다. 값을 추가 한 후 Set 인스턴스를 반환합니다. 따라서 메서드 체인 방법으로 Set 인스턴스의 메서드를 호출할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>add()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();  </span><br><span class=\"line\">newSet.add(<span class=\"string\">\"축구\"</span>).add(<span class=\"string\">\"농구\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> newSet.add(<span class=\"string\">\"축구\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> element <span class=\"keyword\">of</span> newSet) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(element);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// 축구  </span></span><br><span class=\"line\"><span class=\"comment\">// 농구</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Set 인스턴스를 생성하여 newSet에 할당합니다. add() 파라미터에 “축구”를 지정하여 실행하면, Set 인스턴스에 “축구”가 추가되며 인덱스 값은 0 입니다. add()를 실행한 후 newSet 인스턴스를 반환하므로 add()를 연결하여 호출할 수 있습니다. “농구”가 추가되고 인덱스 값은 1 입니다.</p>\n</li>\n<li><p>add() 파라미터에 지정한 “축구”가 Set 인스턴스에 존재하므로 “축구”가 추가되지 않습니다.</p>\n</li>\n<li><p>for-of 문으로 newSet 인스턴스를 반복하면, newSet 인스턴스의 value가 for-of 문의 element에 설정됩니다.<br>newSet 인스턴스에 추가된 순서대로 전개됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Set_has\">has(): value 존재 여부</h2>\n\n<p>Set 인스턴스에서 value의 존재 여부를 반환합니다.</p>\n<blockquote>\n<p>Set.prototype.has()</p>\n</blockquote>\n<p>파라미터에 존재 여부를 체크할 값을 지정합니다. Set 인스턴스에 값이 존재하면 true, 아니면 false를 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>has()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();  </span><br><span class=\"line\">newSet.add(<span class=\"string\">\"sports\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newSet.has(<span class=\"string\">\"sports\"</span>));  </span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Set 인스턴스를 생성하여 newSet 변수에 할당했습니다. add()를 실행하면 파라미터에 지정한 “sports”가 newSet 인스턴스에 추가됩니다. newSet 인스턴스에 has() 파라미터에 지정한 “sports”가 존재합니다. true를 반환합니다.</li>\n</ul>\n<hr>\n<h2 id=\"Set_entries\">entries(): 이터레이터 오브젝트 생성</h2>\n\n<p>이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Set.prototype.entries()</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트의 next()를 호출하면 Set 인스턴스에 작성된 순서로 [key, value]를 반환합니다.<br>Set 인스턴스에 key를 저장하지 않지만 value를 key에 설정하여 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>entries()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"one\"</span>, () =&gt; &#123;&#125;]);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iteratorObj = newSet.entries();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Array[2], done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: Array[2], done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>두 개의 value를 가진 Set 인스턴스를 생성합니다. 하나는 “one”이고 또 하나는 function(){}입니다. entries()를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>첫 번째 value인 “one”을 반환하며 실행 결과에 {value: Array[2], done: false}가 출력됩니다.<br>value를 반환하므로 {value: “one”, done: false} 형태로 반환되어야 하지만, value를 key에 설정하여 반환하므로 {value: Array[2]} 형태가 됩니다. Array[2]를 펼치면 0:”one”, 1:”one”이 표시됩니다.</p>\n</li>\n<li><p>마찬가지로 value인 function(){}을 반환하며 {value: Array[2], done: false} 형태입니다.<br>Array[2]를 펼치면 0: function(){}, 1: function(){}이 표시됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Set_values\">values(): value 반환 이터레이터 오브젝트 생성</h2>\n\n<p>value 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Set.prototype.value</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트의 next()를 호출하면 Set 인스턴스에 작성된 순서로 value를 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>values()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"one\"</span>, () =&gt; &#123;&#125;]);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iteratorObj = newSet.values();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"one\", done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: function, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>두 개의 value를 가진 Set 인스턴스를 생성합니다. 하나는 “one” 또 하나는 function(){}입니다.<br>인스턴스의 values()를 호출하면 value를 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>첫 번째 value인 “one”이 대상이며 {value: “one”, done: false}를 반환합니다.<br>etntries() 메서드가 {value: Array[2]}를 반환하는 것과 차이점 입니다.</p>\n</li>\n<li><p>두 번째 value인 function(){}이 대상이며 {value: function(){}, done: false}를 반환합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Set_keys\">keys(): key 반환 이터레이터 오브젝트 생성</h2>\n\n<p>key 값을 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Set.prototype.keys()</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트의 next()를 호출하면 Set 인스턴스에 작성된 순서로 key 값을 반환합니다.<br>Set 인스턴스에 value만 설정되므로 value를 key로 하여 반환합니다.<br>그다지 의미가 없지만 같은 이름의 Map 인스턴스 메서드와 반환 구조를 맞추기 위한 것으로 생각됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>keys()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"one\"</span>, () =&gt; &#123;&#125;]);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iteratorObj = newSet.keys();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"one\", done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: function()&#123;&#125;, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>앞의 예제들과 주어진 값은 같습니다.<br>keys()를 호출하면 value를 key로 하여 반환하는 이터레이터 오브젝트를 생성하여 반환합니다.<br><mark>반환되는 프로퍼티 이름이 key가 아닌 value입니다.</mark></li>\n</ul>\n<hr>\n<h2 id=\"Set_forEach\">forEach(): 엘리먼트마다 콜백 함수 호출</h2>\n\n<p>Set 인스턴스에 작성된 순서로 반복하면서 콜백 함수를 호출합니다.</p>\n<blockquote>\n<p>Set.prototype.forEach()</p>\n</blockquote>\n<ul>\n<li>파라미터<br>Function (반복할 때 마다 호출할 callback 함수)<br>Object (선택) callback 함수에서 this로 참조할 오브젝트</li>\n</ul>\n<p>forEach()를 호출할 때마다 세 개의 파라미터를 넘겨줍니다.<br>첫 번째 파라미터가 value이고 두 번째 파라미터가 key입니다. 세 번째 파라미터는 실행 중인 Set 인스턴스 입니다.<br><mark>value 값과 key 값이 같습니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>forEach()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"one\"</span>, <span class=\"string\">\"two\"</span>]);  </span><br><span class=\"line\">  </span><br><span class=\"line\">newSet.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, key, obj</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value, <span class=\"keyword\">this</span>.member);  </span><br><span class=\"line\">&#125;, &#123;<span class=\"attr\">member</span>: <span class=\"number\">10</span>&#125;);  </span><br><span class=\"line\"><span class=\"comment\">// one : 10  </span></span><br><span class=\"line\"><span class=\"comment\">// two : 10</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>forEach()를 처음 호출하면 콜백 함수의 value 와 key 파라미터에 “one”이 설정되고 obj 파라미터에 newSet 인스턴스가 설정됩니다. 콜백 함수에서 this로 forEach() 두 번째 파라미터에 지정한 Object 오브젝트를 참조합니다.</li>\n</ul>\n<p><mark>화살표 함수로 콜백 함수를 작성하면 콜백 함수 블록에서 this가 window 오브젝트를 참조하므로 이 코드와 같이 function 키워드로 작성해야 합니다.</mark></p>\n<hr>\n<h2 id=\"Set_delete\">delete(): 엘리먼트 삭제</h2>\n\n<p>Set 인스턴스에서 value 값이 같은 엘리먼트를 삭제합니다.</p>\n<blockquote>\n<p>Set.prototype.delete()</p>\n</blockquote>\n<ul>\n<li><p>파라미터<br>삭제할 value</p>\n</li>\n<li><p>반환 값<br>삭제 성공시 true, 아니면 false 반환</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>delete()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"one\"</span>]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newSet.delete(<span class=\"string\">\"one\"</span>));  </span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>newSet 인스턴스에서 delete() 파라미터에 지정한 “one” 과 같은 value가 있으면 엘리먼트를 삭제합니다.<br>삭제되므로 true를 반환합니다.</li>\n</ul>\n<hr>\n<h2 id=\"Set_clear\">clear(): 모든 value 지움</h2>\n\n<p>Set 인스턴스의 모든 value()를 지웁니다.</p>\n<blockquote>\n<p>Set.prototype.clear()</p>\n</blockquote>\n<figure class=\"highlight js\"><figcaption><span>clear()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"one\"</span>, <span class=\"string\">\"two\"</span>]);  </span><br><span class=\"line\">newSet.clear();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newSet.size);  </span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>clear()를 실행하면 newSet 인스턴스에서 엘리먼트를 모두 지우므로 size 프로퍼티 값이 0으로 출력됩니다. 인스턴스 자체를 지우는 것이 아니라 엘리먼트를 모두 지우는 것 이므로 다시 value를 추가해줄 수 있습니다.</li>\n</ul>\n<hr>\n<h2 id=\"Set_Symbol_iterator\">Symbol.iterator: 이터레이터 오브젝트 생성</h2>\n\n<p>이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<blockquote>\n<p>Set.prototype[Symbol.iterator]</p>\n</blockquote>\n<p>생성한 이터레이터 오브젝트의 next()를 호출하면, Set 인스턴스에 작성된 순서로 value를 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>Symbol.iterator</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">const</span> newSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"string\">\"스포츠\"</span>]);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iteratorObj = newSet[<span class=\"built_in\">Symbol</span>.iterator]();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: 1, done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"스포츠\", done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>newSet 인스턴스를 생성하고 [1, “스포츠”]를 할당합니다.<br>newSet 인스턴스의 [Symbol.iterator] ()를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n</li>\n<li><p>next()를 호출할 때마다 newSet 인스턴스의 value값을 {value: 1, done: false} 형태의 value에 설정하여 반환합니다.</p>\n</li>\n</ol>"},{"title":"String 오브젝트 -ECMAScript","date":"2020-03-28T20:33:24.000Z","disqusId":"tunas-blog-1","_content":"\n*   String 오브젝트\n    *   [Unicode](/2020/03/29/String%20오브젝트%20-ECMAScript/#Unicode)\n        *   fromCodePoint(): 코드 포인트 문자 반환\n        *   codePointAt(): 코드 포인트 값 반환\n    *   [includes(): 문자열 포함 여부](/2020/03/29/String%20오브젝트%20-ECMAScript/#includes)\n    *   [startsWith(): 문자열 시작 여부](/2020/03/29/String%20오브젝트%20-ECMAScript/#starsWith)\n    *   [endsWith(): 문자열 종료 여부](/2020/03/29/String%20오브젝트%20-ECMAScript/#endsWith)\n    *   [repeat(): 문자열 복제](/2020/03/29/String%20오브젝트%20-ECMAScript/#repeat)\n    *   [normalize(): 유니코드 정규화 형식 변환](/2020/03/29/String%20오브젝트%20-ECMAScript/#normalize)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Unicode\">Unicode</h2> \n\n유니코드는 “U+”를 작성하고 이어서 코드 포인트(codepoint)를 작성합니다.\n\n코드 포인트는 4자리 이상의 UTF-16 진수 형태로 U+0000 에서 U+10FFFF까지 약 110만 개 정도를 사용할 수 있습니다.\n\n코드 포인트 전체는 17개 평면(plane)으로 나누어져 있으며, 하나의 평면은  \n65535(U+FFFF)개 입니다. 첫 번째 평면을 BMP(Basic Multilingual Plane)라고 부르며 일반적인 문자가 이 평면에 속합니다. (ex 한글)\n\nBPM를 제외한 코드 포인트가 속한 평면을 Supplementary plane 또는 Astral plane이라고 부릅니다. 5자리 이상의 코드 포인트가 여기에 속합니다.\n\n```js Unicode\n// 16진수 이스케이프 시퀀스  \n1. console.log(\"1:\", \"\\x31\\x32\\x33\");  \n  \n// 유니코드 이스케이프 시퀀스  \n2. console.log(\"2:\", \"\\u0031\\u0032\\u0033\");  \n  \n// 유니코드 코드포인트 이스케이프  \n3. console.log(\"3:\", \"\\u{34}\\u{35}\\u{36}\");  \n  \n// U+FFFF보다 큰 코드 포인트: 코끼리  \n//http://unicode-table.com/en/1F418/  \n4. console.log(\"4:\", \"\\u{1f418}\");  \n  \n//서로게이트 페어(Surrogate pair)  \n5. console.log(\"5:\", \"\\uD83D\\uDC18\");  \n```\n\n1.  “\\x31\\x32\\x33”를 변환하면 123이 반환됩니다. \\에 이어서 16진수로 값을 작성합니다. 이 형태를 16진수 이스케이프 시퀀스(Escape Sequence)라고 합니다.\n\n2.  “\\x31\\x32\\x33” 를 유니코드로 작성하면 “\\u0031\\u0032\\u0033” 형태가 됩니다.  \n    이를 유니코드 이스케이프 시퀀스라고 합니다. UTF-16 진수 형태로 U+0000에서 U+FFFF까지 사용할 수 있습니다.\n    \n3.  U+FFFF 보다 큰 코드 포인트 (유니코드 이스케이프 시퀀스 범위를 넘어가는)는  \n    ES6에서 “\\u{34}”와 같이 중괄호 안에 코드 포인트를 작성합니다.  \n    이를 유니코드 코드 포인트 이스케이프라고 합니다.  \n    \\u{1f418}과 같이 5자리로도 작성할 수 있습니다.\n    \n4.  코끼리 이모지를 출력하는 유니코드 코드 포인트 이스케이프 값 입니다.  \n    브라우저 마다 이모지 모습이 조금씩 차이가 있을 수 있습니다.\n    \n5.  \\u{1F418} 형태는 ES5에서 사용할 수 없습니다.  \n    ES5에서 사용할 수 있는 형태를 Surrogate pair 라고 하며 “\\uD83D\\uDC18”와 같이 두 개의 유니코드 이스케이프 시퀀스를 사용 합니다.\n    \n\n* * *\n\n### fromCodePoint(): 코드 포인트 문자 반환\n\n유니코드의 코드 포인트에 해당하는 문자를 반환합니다.\n\n> String.fromCodePoint(param);\n\n```js\n// #$%&  \nconsole.log(\"1:\", String.fromCodePoint(35, 36, 37));  \n  \n// 16진수로 지정, 49, 50, 51로 지정한 것과 같음  \nconsole.log(\"2:\", String.fromCodePoint(0x31, 0x32, 0x33));  \n  \n// 44032 = 가, 44033 = 각 = 가각  \nconsole.log(\"3:\", String.fromCodePoint(44032, 44033));  \n  \n// 코끼리 이모지  \n//http://unicode-table.com/en/1F418/  \nconsole.log(\"4:\", String.fromCodePoint(0x1F418));  \n  \n/* fromCharCode는 ES5 함수이며,   \n4자리 까지만 작성할 수 있으므로 코끼리 이모지가 표시되지 않음 */  \nconsole.log(\"5:\", String.fromCharCode(0x1f418));  \n  \n/* fromCharCode를 사용하려면   \nSurrogate pair 형태로 값을 두 개 작성해야됨. */  \nconsole.log(\"6:\", String.fromCharCode(0xD83D, 0xDC18));  \n```\n\n* * *\n\n## codePointAt(): 코드 포인트 값 반환\n\n문자열에서 파라미터에 지정한 인덱스 번째 문자의 코드 포인트 값을 반환합니다.  \n파라미터의 디폴트 값은 0 입니다.  \n해당 인덱스에 문자가 없으면 undefined를 반환합니다.\n\n```js\nconsole.log(\"가\".codePointAt(0));  \n// \"가\"의 코드 포인트 값 44032 반환  \n  \nlet values = \"ABC\";  \nfor (var value of values){  \n console.log(value, value.codePointAt(0));  \n// A 65   \n// B 66   \n// C 67  \n};  \n```\n\n* * *\n\n<h2 id=\"includes\">includes(): 문자열 포함 여부</h2>\n\n> str.includes(searchString[, position])\n\n**매개변수**\n\n*   searchString:  \n    이 문자열에서 찾을 다른 문자열.\n    \n*   position (선택적 파라미터)  \n    searchString을 찾기 시작할 위치. 기본값 0.\n    \n\n**반환값**  \n문자열을 찾아내면 true. 실패하면 false.\n\n```js\nlet target = \"123가나다라456\";  \n1. console.log(\"1: \", target.includes(2));  \n  \n2. console.log(\"2: \", target.includes(\"가나\"));  \n  \n3. console.log(\"3: \", target.includes(\"12\", 5));  \n```\n\n1.  target.includes(2)가 숫자 값이지만 문자열로 변환하여 비교합니다. true\n    \n2.  유니코드의 코드 포인트 값으로 체크하기 때문에 한글을 체크할 수 있습니다. true\n    \n3.  target 안에 12가 있지만 6번째 이후 부터 체크 하므로 false\n    \n\n* * *\n\n<h2 id=\"starsWith\">starsWith(): 문자열 시작 여부</h2>\n\nstartsWith() 메소드는 어떤 문자열이 특정 문자로 시작하는지 확인하여 결과를 true 혹은 false로 반환합니다. 대소문자를 구분합니다.\n\n> str.starsWith(searchString[, position])\n\n**매개변수**\n\n*   searchString:  \n    이 문자열에서 찾을 다른 문자열.\n    \n*   position (선택적 파라미터)  \n    searchString을 찾기 시작할 위치. 기본값 0.\n    \n\n**반환값**  \n문자열이 검색 문자열로 시작하면 true. 아니면 false.\n\n```js\nlet target = \"123가나다\";  \n1. console.log(\"1:\", target.startsWith(123));  \n  \n2. console.log(\"2:\", target.startsWith(\"23\"));  \n  \n3. console.log(\"3:\", target.startsWith(\"가나\", 3));  \n```\n\n1.  123으로 대상 문자열이 시작하므로 true 반환.  \n    두 번째 파라미터를 작성하지 않았으므로 비교 시작 인덱스는 0\n    \n2.  23으로 시작하지 않으므로 false\n    \n3.  두 번째 파라미터에 인덱스 값 3을 작성하여 4 번째 부터 비교합니다.  \n    대상 문자열 4번째에 “가나”로 시작하므로 true\n    \n\n* * *\n\n<h2 id=\"endsWith\">endsWith(): 문자열 종료 여부</h2>\n\nndsWith() 메서드를 사용하여 어떤 문자열에서 특정 문자열로 끝나는지를 확인할 수 있으며, 그 결과를 true 혹은 false로 반환합니다.\n\n> str.endsWith(searchString[, position])\n\n*   searchString  \n    대상 문자열의 끝이 특정 문자열로 끝나는지를 찾기 원하는 문자열입니다.\n    \n*   position (선택적 파라미터)  \n    찾고자 하는 문자열의 길이값이며, 기본값은 문자열 전체 길이입니다.  \n    문자열의 길이값은 문자열 전체 길이 보다 길 수 없습니다.\n    \n```js\nlet target = \"123가나다\";  \n1. console.log(target.endsWith(\"가나다\"));  \n  \n2. console.log(target.endsWith(\"가나\"));  \n  \n3. console.log(target.endsWith(\"가나\", 5));  \n```\n\n1.  대상 문자열이 “가나다”로 끝나므로 true\n    \n\n2.  “가나”로 끝나지 않으므로 false\n    \n\n3.  두 번째 파라미터에 길이 값 5를 지정했으므로 대상 문자열의 5번째 까지만 비교합니다. “가나”로 끝나게 되므로 true 반환\n    \n\n* * *\n\n<h2 id=\"repeat\">repeat(): 문자열 복제</h2>\n\nrepeat() 메서드는 문자열을 주어진 횟수만큼 반복해 붙인 새로운 문자열을 반환합니다.\n\n> str.repeat(count);\n\n*   count  \n    문자열을 반복할 횟수. 0과 양의 무한대 사이의 정수([0, +∞)).\n    \n*   반환값  \n    현재 문자열을 주어진 횟수만큼 반복해 붙인 새로운 문자열.\n    \n*   예외  \n    RangeError: 반복 횟수는 양의 정수여야 함.  \n    RangeError: 반복 횟수는 무한대보다 작아야 하며, 최대 문자열 크기를 넘어선 안됨.\n    \n```js\nlet target = \"123\";  \n1. console.log(\"1:\", target.repeat(3));  \n  \n2. console.log(\"2:\", target.repeat(0));  \n  \n3. console.log(\"3:\", target.repeat(2.7));  \n```\n\n1.  “123” 문자열을 3번 반복하여 123123123 반환\n    \n2.  파라미터에 0을 작성하면 빈 문자열을 반환합니다. “”\n    \n3.  2.7과 같이 소수를 작성하면 소수를 버리고 정수만 사용하여 복제합니다.  \n    123123 이 반환됩니다.\n    \n\n* * *\n\n<h2 id=\"normalize\">normalize(): 유니코드 정규화 형식 변환</h2>\n\n대상 문자열을 파라미터에 작성한 유니코드 정규화 형식으로 변환하여 반환합니다.  \n만약 주어진 값이 문자열이 아닐 경우에는 우선 문자열로 변환 후 정규화합니다.\n\n> str.normalize([form])\n\n*   form  \n    유니코드 정규화 방식을 지정합니다. “NFC”, “NFD”, “NFKC”, “NFKD” 중 하나이며, 생략되거나 undefined 일 경우 “NFC”가 디폴트 값 입니다.\n    \n    *   NFC — 정규형 정준 결합(Normalization Form Canonical Composition).\n    *   NFD — 정규형 정준 분해(Normalization Form Canonical Decomposition).\n    *   NFKC — 정규형 호환성 결합(Normalization Form Compatibility Composition).\n    *   NFKD — 정규형 호환성 분해(Normalization Form Compatibility Decomposition).\n\n*   반환 값  \n    주어진 문자열을 유니코드 정규화 방식에 따라 정규화된 문자열로 반환합니다.\n\nform이 위에서 명시된 값 중 하나가 아닐 경우 RangeError 에러가 발생합니다.\n\nnormalize() 메서드는 문자열을 유니코드 정규화 방식에 따라 정규화된 형태로 반환합니다. 문자열의 값 자체에는 영향을 주지 않습니다.\n\n```js\nconsole.log(\"1:\", \"ㄱ\".charCodeAt(0));  \n// 12593 = (0x3131)  \nconsole.log(\"2:\", \"ㅏ\".charCodeAt(0));  \n// 12623 = (0x314F)  \n  \n// \"ㄱ\" 과 \"ㅏ\"의 코드 포인트값을 연결 하여 작성  \nlet jamo = \"\\u3131\\u314F\";  \n1. console.log(\"3:\", jamo.normalize(\"NFC\"));  \n console.log(\"4:\", jamo.normalize());  \n  \n2. console.log(\"5:\", jamo.normalize(\"NFD\"));  \n3. console.log(\"6:\", jamo.normalize(\"NFKD\"));  \n console.log(\"7:\", jamo.normalize(\"NFKC\"));  \n```\n\n1.  “ㄱ” 과 “ㅏ” 가 연결된 “가” 모습이 아닌 “ㄱㅏ” 형태가 됩니다.  \n    파라미터에 형식 값을 작성하지 않아도 디폴트 값 NFC 변환 형식이 적용됩니다.\n    \n\n2.  NFC와 같이 NFD도 “ㄱㅏ” 형태로 출력됩니다.\n    \n    \n3.  NFKD 와 NFKC는 “가” 와 같이 글자 하나로 출력됩니다.\n    ","source":"_posts/String 오브젝트 -ECMAScript.md","raw":"---\ntitle: String 오브젝트 -ECMAScript\ndate: 2020-03-29 05:33:24\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n*   String 오브젝트\n    *   [Unicode](/2020/03/29/String%20오브젝트%20-ECMAScript/#Unicode)\n        *   fromCodePoint(): 코드 포인트 문자 반환\n        *   codePointAt(): 코드 포인트 값 반환\n    *   [includes(): 문자열 포함 여부](/2020/03/29/String%20오브젝트%20-ECMAScript/#includes)\n    *   [startsWith(): 문자열 시작 여부](/2020/03/29/String%20오브젝트%20-ECMAScript/#starsWith)\n    *   [endsWith(): 문자열 종료 여부](/2020/03/29/String%20오브젝트%20-ECMAScript/#endsWith)\n    *   [repeat(): 문자열 복제](/2020/03/29/String%20오브젝트%20-ECMAScript/#repeat)\n    *   [normalize(): 유니코드 정규화 형식 변환](/2020/03/29/String%20오브젝트%20-ECMAScript/#normalize)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Unicode\">Unicode</h2> \n\n유니코드는 “U+”를 작성하고 이어서 코드 포인트(codepoint)를 작성합니다.\n\n코드 포인트는 4자리 이상의 UTF-16 진수 형태로 U+0000 에서 U+10FFFF까지 약 110만 개 정도를 사용할 수 있습니다.\n\n코드 포인트 전체는 17개 평면(plane)으로 나누어져 있으며, 하나의 평면은  \n65535(U+FFFF)개 입니다. 첫 번째 평면을 BMP(Basic Multilingual Plane)라고 부르며 일반적인 문자가 이 평면에 속합니다. (ex 한글)\n\nBPM를 제외한 코드 포인트가 속한 평면을 Supplementary plane 또는 Astral plane이라고 부릅니다. 5자리 이상의 코드 포인트가 여기에 속합니다.\n\n```js Unicode\n// 16진수 이스케이프 시퀀스  \n1. console.log(\"1:\", \"\\x31\\x32\\x33\");  \n  \n// 유니코드 이스케이프 시퀀스  \n2. console.log(\"2:\", \"\\u0031\\u0032\\u0033\");  \n  \n// 유니코드 코드포인트 이스케이프  \n3. console.log(\"3:\", \"\\u{34}\\u{35}\\u{36}\");  \n  \n// U+FFFF보다 큰 코드 포인트: 코끼리  \n//http://unicode-table.com/en/1F418/  \n4. console.log(\"4:\", \"\\u{1f418}\");  \n  \n//서로게이트 페어(Surrogate pair)  \n5. console.log(\"5:\", \"\\uD83D\\uDC18\");  \n```\n\n1.  “\\x31\\x32\\x33”를 변환하면 123이 반환됩니다. \\에 이어서 16진수로 값을 작성합니다. 이 형태를 16진수 이스케이프 시퀀스(Escape Sequence)라고 합니다.\n\n2.  “\\x31\\x32\\x33” 를 유니코드로 작성하면 “\\u0031\\u0032\\u0033” 형태가 됩니다.  \n    이를 유니코드 이스케이프 시퀀스라고 합니다. UTF-16 진수 형태로 U+0000에서 U+FFFF까지 사용할 수 있습니다.\n    \n3.  U+FFFF 보다 큰 코드 포인트 (유니코드 이스케이프 시퀀스 범위를 넘어가는)는  \n    ES6에서 “\\u{34}”와 같이 중괄호 안에 코드 포인트를 작성합니다.  \n    이를 유니코드 코드 포인트 이스케이프라고 합니다.  \n    \\u{1f418}과 같이 5자리로도 작성할 수 있습니다.\n    \n4.  코끼리 이모지를 출력하는 유니코드 코드 포인트 이스케이프 값 입니다.  \n    브라우저 마다 이모지 모습이 조금씩 차이가 있을 수 있습니다.\n    \n5.  \\u{1F418} 형태는 ES5에서 사용할 수 없습니다.  \n    ES5에서 사용할 수 있는 형태를 Surrogate pair 라고 하며 “\\uD83D\\uDC18”와 같이 두 개의 유니코드 이스케이프 시퀀스를 사용 합니다.\n    \n\n* * *\n\n### fromCodePoint(): 코드 포인트 문자 반환\n\n유니코드의 코드 포인트에 해당하는 문자를 반환합니다.\n\n> String.fromCodePoint(param);\n\n```js\n// #$%&  \nconsole.log(\"1:\", String.fromCodePoint(35, 36, 37));  \n  \n// 16진수로 지정, 49, 50, 51로 지정한 것과 같음  \nconsole.log(\"2:\", String.fromCodePoint(0x31, 0x32, 0x33));  \n  \n// 44032 = 가, 44033 = 각 = 가각  \nconsole.log(\"3:\", String.fromCodePoint(44032, 44033));  \n  \n// 코끼리 이모지  \n//http://unicode-table.com/en/1F418/  \nconsole.log(\"4:\", String.fromCodePoint(0x1F418));  \n  \n/* fromCharCode는 ES5 함수이며,   \n4자리 까지만 작성할 수 있으므로 코끼리 이모지가 표시되지 않음 */  \nconsole.log(\"5:\", String.fromCharCode(0x1f418));  \n  \n/* fromCharCode를 사용하려면   \nSurrogate pair 형태로 값을 두 개 작성해야됨. */  \nconsole.log(\"6:\", String.fromCharCode(0xD83D, 0xDC18));  \n```\n\n* * *\n\n## codePointAt(): 코드 포인트 값 반환\n\n문자열에서 파라미터에 지정한 인덱스 번째 문자의 코드 포인트 값을 반환합니다.  \n파라미터의 디폴트 값은 0 입니다.  \n해당 인덱스에 문자가 없으면 undefined를 반환합니다.\n\n```js\nconsole.log(\"가\".codePointAt(0));  \n// \"가\"의 코드 포인트 값 44032 반환  \n  \nlet values = \"ABC\";  \nfor (var value of values){  \n console.log(value, value.codePointAt(0));  \n// A 65   \n// B 66   \n// C 67  \n};  \n```\n\n* * *\n\n<h2 id=\"includes\">includes(): 문자열 포함 여부</h2>\n\n> str.includes(searchString[, position])\n\n**매개변수**\n\n*   searchString:  \n    이 문자열에서 찾을 다른 문자열.\n    \n*   position (선택적 파라미터)  \n    searchString을 찾기 시작할 위치. 기본값 0.\n    \n\n**반환값**  \n문자열을 찾아내면 true. 실패하면 false.\n\n```js\nlet target = \"123가나다라456\";  \n1. console.log(\"1: \", target.includes(2));  \n  \n2. console.log(\"2: \", target.includes(\"가나\"));  \n  \n3. console.log(\"3: \", target.includes(\"12\", 5));  \n```\n\n1.  target.includes(2)가 숫자 값이지만 문자열로 변환하여 비교합니다. true\n    \n2.  유니코드의 코드 포인트 값으로 체크하기 때문에 한글을 체크할 수 있습니다. true\n    \n3.  target 안에 12가 있지만 6번째 이후 부터 체크 하므로 false\n    \n\n* * *\n\n<h2 id=\"starsWith\">starsWith(): 문자열 시작 여부</h2>\n\nstartsWith() 메소드는 어떤 문자열이 특정 문자로 시작하는지 확인하여 결과를 true 혹은 false로 반환합니다. 대소문자를 구분합니다.\n\n> str.starsWith(searchString[, position])\n\n**매개변수**\n\n*   searchString:  \n    이 문자열에서 찾을 다른 문자열.\n    \n*   position (선택적 파라미터)  \n    searchString을 찾기 시작할 위치. 기본값 0.\n    \n\n**반환값**  \n문자열이 검색 문자열로 시작하면 true. 아니면 false.\n\n```js\nlet target = \"123가나다\";  \n1. console.log(\"1:\", target.startsWith(123));  \n  \n2. console.log(\"2:\", target.startsWith(\"23\"));  \n  \n3. console.log(\"3:\", target.startsWith(\"가나\", 3));  \n```\n\n1.  123으로 대상 문자열이 시작하므로 true 반환.  \n    두 번째 파라미터를 작성하지 않았으므로 비교 시작 인덱스는 0\n    \n2.  23으로 시작하지 않으므로 false\n    \n3.  두 번째 파라미터에 인덱스 값 3을 작성하여 4 번째 부터 비교합니다.  \n    대상 문자열 4번째에 “가나”로 시작하므로 true\n    \n\n* * *\n\n<h2 id=\"endsWith\">endsWith(): 문자열 종료 여부</h2>\n\nndsWith() 메서드를 사용하여 어떤 문자열에서 특정 문자열로 끝나는지를 확인할 수 있으며, 그 결과를 true 혹은 false로 반환합니다.\n\n> str.endsWith(searchString[, position])\n\n*   searchString  \n    대상 문자열의 끝이 특정 문자열로 끝나는지를 찾기 원하는 문자열입니다.\n    \n*   position (선택적 파라미터)  \n    찾고자 하는 문자열의 길이값이며, 기본값은 문자열 전체 길이입니다.  \n    문자열의 길이값은 문자열 전체 길이 보다 길 수 없습니다.\n    \n```js\nlet target = \"123가나다\";  \n1. console.log(target.endsWith(\"가나다\"));  \n  \n2. console.log(target.endsWith(\"가나\"));  \n  \n3. console.log(target.endsWith(\"가나\", 5));  \n```\n\n1.  대상 문자열이 “가나다”로 끝나므로 true\n    \n\n2.  “가나”로 끝나지 않으므로 false\n    \n\n3.  두 번째 파라미터에 길이 값 5를 지정했으므로 대상 문자열의 5번째 까지만 비교합니다. “가나”로 끝나게 되므로 true 반환\n    \n\n* * *\n\n<h2 id=\"repeat\">repeat(): 문자열 복제</h2>\n\nrepeat() 메서드는 문자열을 주어진 횟수만큼 반복해 붙인 새로운 문자열을 반환합니다.\n\n> str.repeat(count);\n\n*   count  \n    문자열을 반복할 횟수. 0과 양의 무한대 사이의 정수([0, +∞)).\n    \n*   반환값  \n    현재 문자열을 주어진 횟수만큼 반복해 붙인 새로운 문자열.\n    \n*   예외  \n    RangeError: 반복 횟수는 양의 정수여야 함.  \n    RangeError: 반복 횟수는 무한대보다 작아야 하며, 최대 문자열 크기를 넘어선 안됨.\n    \n```js\nlet target = \"123\";  \n1. console.log(\"1:\", target.repeat(3));  \n  \n2. console.log(\"2:\", target.repeat(0));  \n  \n3. console.log(\"3:\", target.repeat(2.7));  \n```\n\n1.  “123” 문자열을 3번 반복하여 123123123 반환\n    \n2.  파라미터에 0을 작성하면 빈 문자열을 반환합니다. “”\n    \n3.  2.7과 같이 소수를 작성하면 소수를 버리고 정수만 사용하여 복제합니다.  \n    123123 이 반환됩니다.\n    \n\n* * *\n\n<h2 id=\"normalize\">normalize(): 유니코드 정규화 형식 변환</h2>\n\n대상 문자열을 파라미터에 작성한 유니코드 정규화 형식으로 변환하여 반환합니다.  \n만약 주어진 값이 문자열이 아닐 경우에는 우선 문자열로 변환 후 정규화합니다.\n\n> str.normalize([form])\n\n*   form  \n    유니코드 정규화 방식을 지정합니다. “NFC”, “NFD”, “NFKC”, “NFKD” 중 하나이며, 생략되거나 undefined 일 경우 “NFC”가 디폴트 값 입니다.\n    \n    *   NFC — 정규형 정준 결합(Normalization Form Canonical Composition).\n    *   NFD — 정규형 정준 분해(Normalization Form Canonical Decomposition).\n    *   NFKC — 정규형 호환성 결합(Normalization Form Compatibility Composition).\n    *   NFKD — 정규형 호환성 분해(Normalization Form Compatibility Decomposition).\n\n*   반환 값  \n    주어진 문자열을 유니코드 정규화 방식에 따라 정규화된 문자열로 반환합니다.\n\nform이 위에서 명시된 값 중 하나가 아닐 경우 RangeError 에러가 발생합니다.\n\nnormalize() 메서드는 문자열을 유니코드 정규화 방식에 따라 정규화된 형태로 반환합니다. 문자열의 값 자체에는 영향을 주지 않습니다.\n\n```js\nconsole.log(\"1:\", \"ㄱ\".charCodeAt(0));  \n// 12593 = (0x3131)  \nconsole.log(\"2:\", \"ㅏ\".charCodeAt(0));  \n// 12623 = (0x314F)  \n  \n// \"ㄱ\" 과 \"ㅏ\"의 코드 포인트값을 연결 하여 작성  \nlet jamo = \"\\u3131\\u314F\";  \n1. console.log(\"3:\", jamo.normalize(\"NFC\"));  \n console.log(\"4:\", jamo.normalize());  \n  \n2. console.log(\"5:\", jamo.normalize(\"NFD\"));  \n3. console.log(\"6:\", jamo.normalize(\"NFKD\"));  \n console.log(\"7:\", jamo.normalize(\"NFKC\"));  \n```\n\n1.  “ㄱ” 과 “ㅏ” 가 연결된 “가” 모습이 아닌 “ㄱㅏ” 형태가 됩니다.  \n    파라미터에 형식 값을 작성하지 않아도 디폴트 값 NFC 변환 형식이 적용됩니다.\n    \n\n2.  NFC와 같이 NFD도 “ㄱㅏ” 형태로 출력됩니다.\n    \n    \n3.  NFKD 와 NFKC는 “가” 와 같이 글자 하나로 출력됩니다.\n    ","slug":"String 오브젝트 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrst001qqgvqevta0okr","content":"<ul>\n<li>String 오브젝트<ul>\n<li><a href=\"/2020/03/29/String%20오브젝트%20-ECMAScript/#Unicode\">Unicode</a><ul>\n<li>fromCodePoint(): 코드 포인트 문자 반환</li>\n<li>codePointAt(): 코드 포인트 값 반환</li>\n</ul>\n</li>\n<li><a href=\"/2020/03/29/String%20오브젝트%20-ECMAScript/#includes\">includes(): 문자열 포함 여부</a></li>\n<li><a href=\"/2020/03/29/String%20오브젝트%20-ECMAScript/#starsWith\">startsWith(): 문자열 시작 여부</a></li>\n<li><a href=\"/2020/03/29/String%20오브젝트%20-ECMAScript/#endsWith\">endsWith(): 문자열 종료 여부</a></li>\n<li><a href=\"/2020/03/29/String%20오브젝트%20-ECMAScript/#repeat\">repeat(): 문자열 복제</a></li>\n<li><a href=\"/2020/03/29/String%20오브젝트%20-ECMAScript/#normalize\">normalize(): 유니코드 정규화 형식 변환</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"Unicode\">Unicode</h2> \n\n<p>유니코드는 “U+”를 작성하고 이어서 코드 포인트(codepoint)를 작성합니다.</p>\n<p>코드 포인트는 4자리 이상의 UTF-16 진수 형태로 U+0000 에서 U+10FFFF까지 약 110만 개 정도를 사용할 수 있습니다.</p>\n<p>코드 포인트 전체는 17개 평면(plane)으로 나누어져 있으며, 하나의 평면은<br>65535(U+FFFF)개 입니다. 첫 번째 평면을 BMP(Basic Multilingual Plane)라고 부르며 일반적인 문자가 이 평면에 속합니다. (ex 한글)</p>\n<p>BPM를 제외한 코드 포인트가 속한 평면을 Supplementary plane 또는 Astral plane이라고 부릅니다. 5자리 이상의 코드 포인트가 여기에 속합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>Unicode</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 16진수 이스케이프 시퀀스  </span></span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"string\">\"\\x31\\x32\\x33\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 유니코드 이스케이프 시퀀스  </span></span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"string\">\"\\u0031\\u0032\\u0033\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 유니코드 코드포인트 이스케이프  </span></span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"string\">\"\\u&#123;34&#125;\\u&#123;35&#125;\\u&#123;36&#125;\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// U+FFFF보다 큰 코드 포인트: 코끼리  </span></span><br><span class=\"line\"><span class=\"comment\">//http://unicode-table.com/en/1F418/  </span></span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"string\">\"\\u&#123;1f418&#125;\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//서로게이트 페어(Surrogate pair)  </span></span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, <span class=\"string\">\"\\uD83D\\uDC18\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>“\\x31\\x32\\x33”를 변환하면 123이 반환됩니다. \\에 이어서 16진수로 값을 작성합니다. 이 형태를 16진수 이스케이프 시퀀스(Escape Sequence)라고 합니다.</p>\n</li>\n<li><p>“\\x31\\x32\\x33” 를 유니코드로 작성하면 “\\u0031\\u0032\\u0033” 형태가 됩니다.<br>이를 유니코드 이스케이프 시퀀스라고 합니다. UTF-16 진수 형태로 U+0000에서 U+FFFF까지 사용할 수 있습니다.</p>\n</li>\n<li><p>U+FFFF 보다 큰 코드 포인트 (유니코드 이스케이프 시퀀스 범위를 넘어가는)는<br>ES6에서 “\\u{34}”와 같이 중괄호 안에 코드 포인트를 작성합니다.<br>이를 유니코드 코드 포인트 이스케이프라고 합니다.<br>\\u{1f418}과 같이 5자리로도 작성할 수 있습니다.</p>\n</li>\n<li><p>코끼리 이모지를 출력하는 유니코드 코드 포인트 이스케이프 값 입니다.<br>브라우저 마다 이모지 모습이 조금씩 차이가 있을 수 있습니다.</p>\n</li>\n<li><p>\\u{1F418} 형태는 ES5에서 사용할 수 없습니다.<br>ES5에서 사용할 수 있는 형태를 Surrogate pair 라고 하며 “\\uD83D\\uDC18”와 같이 두 개의 유니코드 이스케이프 시퀀스를 사용 합니다.</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"fromCodePoint-코드-포인트-문자-반환\"><a href=\"#fromCodePoint-코드-포인트-문자-반환\" class=\"headerlink\" title=\"fromCodePoint(): 코드 포인트 문자 반환\"></a>fromCodePoint(): 코드 포인트 문자 반환</h3><p>유니코드의 코드 포인트에 해당하는 문자를 반환합니다.</p>\n<blockquote>\n<p>String.fromCodePoint(param);</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// #$%&amp;  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"built_in\">String</span>.fromCodePoint(<span class=\"number\">35</span>, <span class=\"number\">36</span>, <span class=\"number\">37</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 16진수로 지정, 49, 50, 51로 지정한 것과 같음  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"built_in\">String</span>.fromCodePoint(<span class=\"number\">0x31</span>, <span class=\"number\">0x32</span>, <span class=\"number\">0x33</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 44032 = 가, 44033 = 각 = 가각  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">String</span>.fromCodePoint(<span class=\"number\">44032</span>, <span class=\"number\">44033</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 코끼리 이모지  </span></span><br><span class=\"line\"><span class=\"comment\">//http://unicode-table.com/en/1F418/  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"built_in\">String</span>.fromCodePoint(<span class=\"number\">0x1F418</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/* fromCharCode는 ES5 함수이며,   </span></span><br><span class=\"line\"><span class=\"comment\">4자리 까지만 작성할 수 있으므로 코끼리 이모지가 표시되지 않음 */</span>  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0x1f418</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/* fromCharCode를 사용하려면   </span></span><br><span class=\"line\"><span class=\"comment\">Surrogate pair 형태로 값을 두 개 작성해야됨. */</span>  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"6:\"</span>, <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0xD83D</span>, <span class=\"number\">0xDC18</span>));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"codePointAt-코드-포인트-값-반환\"><a href=\"#codePointAt-코드-포인트-값-반환\" class=\"headerlink\" title=\"codePointAt(): 코드 포인트 값 반환\"></a>codePointAt(): 코드 포인트 값 반환</h2><p>문자열에서 파라미터에 지정한 인덱스 번째 문자의 코드 포인트 값을 반환합니다.<br>파라미터의 디폴트 값은 0 입니다.<br>해당 인덱스에 문자가 없으면 undefined를 반환합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"가\"</span>.codePointAt(<span class=\"number\">0</span>));  </span><br><span class=\"line\"><span class=\"comment\">// \"가\"의 코드 포인트 값 44032 반환  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> values = <span class=\"string\">\"ABC\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> value <span class=\"keyword\">of</span> values)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value, value.codePointAt(<span class=\"number\">0</span>));  </span><br><span class=\"line\"><span class=\"comment\">// A 65   </span></span><br><span class=\"line\"><span class=\"comment\">// B 66   </span></span><br><span class=\"line\"><span class=\"comment\">// C 67  </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"includes\">includes(): 문자열 포함 여부</h2>\n\n<blockquote>\n<p>str.includes(searchString[, position])</p>\n</blockquote>\n<p><strong>매개변수</strong></p>\n<ul>\n<li><p>searchString:<br>이 문자열에서 찾을 다른 문자열.</p>\n</li>\n<li><p>position (선택적 파라미터)<br>searchString을 찾기 시작할 위치. 기본값 0.</p>\n</li>\n</ul>\n<p><strong>반환값</strong><br>문자열을 찾아내면 true. 실패하면 false.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> target = <span class=\"string\">\"123가나다라456\"</span>;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1: \"</span>, target.includes(<span class=\"number\">2</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2: \"</span>, target.includes(<span class=\"string\">\"가나\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: \"</span>, target.includes(<span class=\"string\">\"12\"</span>, <span class=\"number\">5</span>));</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>target.includes(2)가 숫자 값이지만 문자열로 변환하여 비교합니다. true</p>\n</li>\n<li><p>유니코드의 코드 포인트 값으로 체크하기 때문에 한글을 체크할 수 있습니다. true</p>\n</li>\n<li><p>target 안에 12가 있지만 6번째 이후 부터 체크 하므로 false</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"starsWith\">starsWith(): 문자열 시작 여부</h2>\n\n<p>startsWith() 메소드는 어떤 문자열이 특정 문자로 시작하는지 확인하여 결과를 true 혹은 false로 반환합니다. 대소문자를 구분합니다.</p>\n<blockquote>\n<p>str.starsWith(searchString[, position])</p>\n</blockquote>\n<p><strong>매개변수</strong></p>\n<ul>\n<li><p>searchString:<br>이 문자열에서 찾을 다른 문자열.</p>\n</li>\n<li><p>position (선택적 파라미터)<br>searchString을 찾기 시작할 위치. 기본값 0.</p>\n</li>\n</ul>\n<p><strong>반환값</strong><br>문자열이 검색 문자열로 시작하면 true. 아니면 false.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> target = <span class=\"string\">\"123가나다\"</span>;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, target.startsWith(<span class=\"number\">123</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, target.startsWith(<span class=\"string\">\"23\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, target.startsWith(<span class=\"string\">\"가나\"</span>, <span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>123으로 대상 문자열이 시작하므로 true 반환.<br>두 번째 파라미터를 작성하지 않았으므로 비교 시작 인덱스는 0</p>\n</li>\n<li><p>23으로 시작하지 않으므로 false</p>\n</li>\n<li><p>두 번째 파라미터에 인덱스 값 3을 작성하여 4 번째 부터 비교합니다.<br>대상 문자열 4번째에 “가나”로 시작하므로 true</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"endsWith\">endsWith(): 문자열 종료 여부</h2>\n\n<p>ndsWith() 메서드를 사용하여 어떤 문자열에서 특정 문자열로 끝나는지를 확인할 수 있으며, 그 결과를 true 혹은 false로 반환합니다.</p>\n<blockquote>\n<p>str.endsWith(searchString[, position])</p>\n</blockquote>\n<ul>\n<li><p>searchString<br>대상 문자열의 끝이 특정 문자열로 끝나는지를 찾기 원하는 문자열입니다.</p>\n</li>\n<li><p>position (선택적 파라미터)<br>찾고자 하는 문자열의 길이값이며, 기본값은 문자열 전체 길이입니다.<br>문자열의 길이값은 문자열 전체 길이 보다 길 수 없습니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> target = <span class=\"string\">\"123가나다\"</span>;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(target.endsWith(<span class=\"string\">\"가나다\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(target.endsWith(<span class=\"string\">\"가나\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(target.endsWith(<span class=\"string\">\"가나\"</span>, <span class=\"number\">5</span>));</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>대상 문자열이 “가나다”로 끝나므로 true</li>\n</ol>\n<ol start=\"2\">\n<li>“가나”로 끝나지 않으므로 false</li>\n</ol>\n<ol start=\"3\">\n<li>두 번째 파라미터에 길이 값 5를 지정했으므로 대상 문자열의 5번째 까지만 비교합니다. “가나”로 끝나게 되므로 true 반환</li>\n</ol>\n<hr>\n<h2 id=\"repeat\">repeat(): 문자열 복제</h2>\n\n<p>repeat() 메서드는 문자열을 주어진 횟수만큼 반복해 붙인 새로운 문자열을 반환합니다.</p>\n<blockquote>\n<p>str.repeat(count);</p>\n</blockquote>\n<ul>\n<li><p>count<br>문자열을 반복할 횟수. 0과 양의 무한대 사이의 정수([0, +∞)).</p>\n</li>\n<li><p>반환값<br>현재 문자열을 주어진 횟수만큼 반복해 붙인 새로운 문자열.</p>\n</li>\n<li><p>예외<br>RangeError: 반복 횟수는 양의 정수여야 함.<br>RangeError: 반복 횟수는 무한대보다 작아야 하며, 최대 문자열 크기를 넘어선 안됨.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> target = <span class=\"string\">\"123\"</span>;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, target.repeat(<span class=\"number\">3</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, target.repeat(<span class=\"number\">0</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, target.repeat(<span class=\"number\">2.7</span>));</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>“123” 문자열을 3번 반복하여 123123123 반환</p>\n</li>\n<li><p>파라미터에 0을 작성하면 빈 문자열을 반환합니다. “”</p>\n</li>\n<li><p>2.7과 같이 소수를 작성하면 소수를 버리고 정수만 사용하여 복제합니다.<br>123123 이 반환됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"normalize\">normalize(): 유니코드 정규화 형식 변환</h2>\n\n<p>대상 문자열을 파라미터에 작성한 유니코드 정규화 형식으로 변환하여 반환합니다.<br>만약 주어진 값이 문자열이 아닐 경우에는 우선 문자열로 변환 후 정규화합니다.</p>\n<blockquote>\n<p>str.normalize([form])</p>\n</blockquote>\n<ul>\n<li><p>form<br>유니코드 정규화 방식을 지정합니다. “NFC”, “NFD”, “NFKC”, “NFKD” 중 하나이며, 생략되거나 undefined 일 경우 “NFC”가 디폴트 값 입니다.</p>\n<ul>\n<li>NFC — 정규형 정준 결합(Normalization Form Canonical Composition).</li>\n<li>NFD — 정규형 정준 분해(Normalization Form Canonical Decomposition).</li>\n<li>NFKC — 정규형 호환성 결합(Normalization Form Compatibility Composition).</li>\n<li>NFKD — 정규형 호환성 분해(Normalization Form Compatibility Decomposition).</li>\n</ul>\n</li>\n<li><p>반환 값<br>주어진 문자열을 유니코드 정규화 방식에 따라 정규화된 문자열로 반환합니다.</p>\n</li>\n</ul>\n<p>form이 위에서 명시된 값 중 하나가 아닐 경우 RangeError 에러가 발생합니다.</p>\n<p>normalize() 메서드는 문자열을 유니코드 정규화 방식에 따라 정규화된 형태로 반환합니다. 문자열의 값 자체에는 영향을 주지 않습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"string\">\"ㄱ\"</span>.charCodeAt(<span class=\"number\">0</span>));  </span><br><span class=\"line\"><span class=\"comment\">// 12593 = (0x3131)  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"string\">\"ㅏ\"</span>.charCodeAt(<span class=\"number\">0</span>));  </span><br><span class=\"line\"><span class=\"comment\">// 12623 = (0x314F)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// \"ㄱ\" 과 \"ㅏ\"의 코드 포인트값을 연결 하여 작성  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> jamo = <span class=\"string\">\"\\u3131\\u314F\"</span>;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, jamo.normalize(<span class=\"string\">\"NFC\"</span>));  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, jamo.normalize());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, jamo.normalize(<span class=\"string\">\"NFD\"</span>));  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"6:\"</span>, jamo.normalize(<span class=\"string\">\"NFKD\"</span>));  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"7:\"</span>, jamo.normalize(<span class=\"string\">\"NFKC\"</span>));</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>“ㄱ” 과 “ㅏ” 가 연결된 “가” 모습이 아닌 “ㄱㅏ” 형태가 됩니다.<br>파라미터에 형식 값을 작성하지 않아도 디폴트 값 NFC 변환 형식이 적용됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li>NFC와 같이 NFD도 “ㄱㅏ” 형태로 출력됩니다.</li>\n</ol>\n<ol start=\"3\">\n<li>NFKD 와 NFKC는 “가” 와 같이 글자 하나로 출력됩니다.</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ul>\n<li>String 오브젝트<ul>\n<li><a href=\"/2020/03/29/String%20오브젝트%20-ECMAScript/#Unicode\">Unicode</a><ul>\n<li>fromCodePoint(): 코드 포인트 문자 반환</li>\n<li>codePointAt(): 코드 포인트 값 반환</li>\n</ul>\n</li>\n<li><a href=\"/2020/03/29/String%20오브젝트%20-ECMAScript/#includes\">includes(): 문자열 포함 여부</a></li>\n<li><a href=\"/2020/03/29/String%20오브젝트%20-ECMAScript/#starsWith\">startsWith(): 문자열 시작 여부</a></li>\n<li><a href=\"/2020/03/29/String%20오브젝트%20-ECMAScript/#endsWith\">endsWith(): 문자열 종료 여부</a></li>\n<li><a href=\"/2020/03/29/String%20오브젝트%20-ECMAScript/#repeat\">repeat(): 문자열 복제</a></li>\n<li><a href=\"/2020/03/29/String%20오브젝트%20-ECMAScript/#normalize\">normalize(): 유니코드 정규화 형식 변환</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"Unicode\">Unicode</h2> \n\n<p>유니코드는 “U+”를 작성하고 이어서 코드 포인트(codepoint)를 작성합니다.</p>\n<p>코드 포인트는 4자리 이상의 UTF-16 진수 형태로 U+0000 에서 U+10FFFF까지 약 110만 개 정도를 사용할 수 있습니다.</p>\n<p>코드 포인트 전체는 17개 평면(plane)으로 나누어져 있으며, 하나의 평면은<br>65535(U+FFFF)개 입니다. 첫 번째 평면을 BMP(Basic Multilingual Plane)라고 부르며 일반적인 문자가 이 평면에 속합니다. (ex 한글)</p>\n<p>BPM를 제외한 코드 포인트가 속한 평면을 Supplementary plane 또는 Astral plane이라고 부릅니다. 5자리 이상의 코드 포인트가 여기에 속합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>Unicode</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 16진수 이스케이프 시퀀스  </span></span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"string\">\"\\x31\\x32\\x33\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 유니코드 이스케이프 시퀀스  </span></span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"string\">\"\\u0031\\u0032\\u0033\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 유니코드 코드포인트 이스케이프  </span></span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"string\">\"\\u&#123;34&#125;\\u&#123;35&#125;\\u&#123;36&#125;\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// U+FFFF보다 큰 코드 포인트: 코끼리  </span></span><br><span class=\"line\"><span class=\"comment\">//http://unicode-table.com/en/1F418/  </span></span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"string\">\"\\u&#123;1f418&#125;\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//서로게이트 페어(Surrogate pair)  </span></span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, <span class=\"string\">\"\\uD83D\\uDC18\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>“\\x31\\x32\\x33”를 변환하면 123이 반환됩니다. \\에 이어서 16진수로 값을 작성합니다. 이 형태를 16진수 이스케이프 시퀀스(Escape Sequence)라고 합니다.</p>\n</li>\n<li><p>“\\x31\\x32\\x33” 를 유니코드로 작성하면 “\\u0031\\u0032\\u0033” 형태가 됩니다.<br>이를 유니코드 이스케이프 시퀀스라고 합니다. UTF-16 진수 형태로 U+0000에서 U+FFFF까지 사용할 수 있습니다.</p>\n</li>\n<li><p>U+FFFF 보다 큰 코드 포인트 (유니코드 이스케이프 시퀀스 범위를 넘어가는)는<br>ES6에서 “\\u{34}”와 같이 중괄호 안에 코드 포인트를 작성합니다.<br>이를 유니코드 코드 포인트 이스케이프라고 합니다.<br>\\u{1f418}과 같이 5자리로도 작성할 수 있습니다.</p>\n</li>\n<li><p>코끼리 이모지를 출력하는 유니코드 코드 포인트 이스케이프 값 입니다.<br>브라우저 마다 이모지 모습이 조금씩 차이가 있을 수 있습니다.</p>\n</li>\n<li><p>\\u{1F418} 형태는 ES5에서 사용할 수 없습니다.<br>ES5에서 사용할 수 있는 형태를 Surrogate pair 라고 하며 “\\uD83D\\uDC18”와 같이 두 개의 유니코드 이스케이프 시퀀스를 사용 합니다.</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"fromCodePoint-코드-포인트-문자-반환\"><a href=\"#fromCodePoint-코드-포인트-문자-반환\" class=\"headerlink\" title=\"fromCodePoint(): 코드 포인트 문자 반환\"></a>fromCodePoint(): 코드 포인트 문자 반환</h3><p>유니코드의 코드 포인트에 해당하는 문자를 반환합니다.</p>\n<blockquote>\n<p>String.fromCodePoint(param);</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// #$%&amp;  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"built_in\">String</span>.fromCodePoint(<span class=\"number\">35</span>, <span class=\"number\">36</span>, <span class=\"number\">37</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 16진수로 지정, 49, 50, 51로 지정한 것과 같음  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"built_in\">String</span>.fromCodePoint(<span class=\"number\">0x31</span>, <span class=\"number\">0x32</span>, <span class=\"number\">0x33</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 44032 = 가, 44033 = 각 = 가각  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">String</span>.fromCodePoint(<span class=\"number\">44032</span>, <span class=\"number\">44033</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 코끼리 이모지  </span></span><br><span class=\"line\"><span class=\"comment\">//http://unicode-table.com/en/1F418/  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"built_in\">String</span>.fromCodePoint(<span class=\"number\">0x1F418</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/* fromCharCode는 ES5 함수이며,   </span></span><br><span class=\"line\"><span class=\"comment\">4자리 까지만 작성할 수 있으므로 코끼리 이모지가 표시되지 않음 */</span>  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0x1f418</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/* fromCharCode를 사용하려면   </span></span><br><span class=\"line\"><span class=\"comment\">Surrogate pair 형태로 값을 두 개 작성해야됨. */</span>  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"6:\"</span>, <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0xD83D</span>, <span class=\"number\">0xDC18</span>));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"codePointAt-코드-포인트-값-반환\"><a href=\"#codePointAt-코드-포인트-값-반환\" class=\"headerlink\" title=\"codePointAt(): 코드 포인트 값 반환\"></a>codePointAt(): 코드 포인트 값 반환</h2><p>문자열에서 파라미터에 지정한 인덱스 번째 문자의 코드 포인트 값을 반환합니다.<br>파라미터의 디폴트 값은 0 입니다.<br>해당 인덱스에 문자가 없으면 undefined를 반환합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"가\"</span>.codePointAt(<span class=\"number\">0</span>));  </span><br><span class=\"line\"><span class=\"comment\">// \"가\"의 코드 포인트 값 44032 반환  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> values = <span class=\"string\">\"ABC\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> value <span class=\"keyword\">of</span> values)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value, value.codePointAt(<span class=\"number\">0</span>));  </span><br><span class=\"line\"><span class=\"comment\">// A 65   </span></span><br><span class=\"line\"><span class=\"comment\">// B 66   </span></span><br><span class=\"line\"><span class=\"comment\">// C 67  </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"includes\">includes(): 문자열 포함 여부</h2>\n\n<blockquote>\n<p>str.includes(searchString[, position])</p>\n</blockquote>\n<p><strong>매개변수</strong></p>\n<ul>\n<li><p>searchString:<br>이 문자열에서 찾을 다른 문자열.</p>\n</li>\n<li><p>position (선택적 파라미터)<br>searchString을 찾기 시작할 위치. 기본값 0.</p>\n</li>\n</ul>\n<p><strong>반환값</strong><br>문자열을 찾아내면 true. 실패하면 false.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> target = <span class=\"string\">\"123가나다라456\"</span>;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1: \"</span>, target.includes(<span class=\"number\">2</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2: \"</span>, target.includes(<span class=\"string\">\"가나\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3: \"</span>, target.includes(<span class=\"string\">\"12\"</span>, <span class=\"number\">5</span>));</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>target.includes(2)가 숫자 값이지만 문자열로 변환하여 비교합니다. true</p>\n</li>\n<li><p>유니코드의 코드 포인트 값으로 체크하기 때문에 한글을 체크할 수 있습니다. true</p>\n</li>\n<li><p>target 안에 12가 있지만 6번째 이후 부터 체크 하므로 false</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"starsWith\">starsWith(): 문자열 시작 여부</h2>\n\n<p>startsWith() 메소드는 어떤 문자열이 특정 문자로 시작하는지 확인하여 결과를 true 혹은 false로 반환합니다. 대소문자를 구분합니다.</p>\n<blockquote>\n<p>str.starsWith(searchString[, position])</p>\n</blockquote>\n<p><strong>매개변수</strong></p>\n<ul>\n<li><p>searchString:<br>이 문자열에서 찾을 다른 문자열.</p>\n</li>\n<li><p>position (선택적 파라미터)<br>searchString을 찾기 시작할 위치. 기본값 0.</p>\n</li>\n</ul>\n<p><strong>반환값</strong><br>문자열이 검색 문자열로 시작하면 true. 아니면 false.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> target = <span class=\"string\">\"123가나다\"</span>;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, target.startsWith(<span class=\"number\">123</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, target.startsWith(<span class=\"string\">\"23\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, target.startsWith(<span class=\"string\">\"가나\"</span>, <span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>123으로 대상 문자열이 시작하므로 true 반환.<br>두 번째 파라미터를 작성하지 않았으므로 비교 시작 인덱스는 0</p>\n</li>\n<li><p>23으로 시작하지 않으므로 false</p>\n</li>\n<li><p>두 번째 파라미터에 인덱스 값 3을 작성하여 4 번째 부터 비교합니다.<br>대상 문자열 4번째에 “가나”로 시작하므로 true</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"endsWith\">endsWith(): 문자열 종료 여부</h2>\n\n<p>ndsWith() 메서드를 사용하여 어떤 문자열에서 특정 문자열로 끝나는지를 확인할 수 있으며, 그 결과를 true 혹은 false로 반환합니다.</p>\n<blockquote>\n<p>str.endsWith(searchString[, position])</p>\n</blockquote>\n<ul>\n<li><p>searchString<br>대상 문자열의 끝이 특정 문자열로 끝나는지를 찾기 원하는 문자열입니다.</p>\n</li>\n<li><p>position (선택적 파라미터)<br>찾고자 하는 문자열의 길이값이며, 기본값은 문자열 전체 길이입니다.<br>문자열의 길이값은 문자열 전체 길이 보다 길 수 없습니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> target = <span class=\"string\">\"123가나다\"</span>;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(target.endsWith(<span class=\"string\">\"가나다\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(target.endsWith(<span class=\"string\">\"가나\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(target.endsWith(<span class=\"string\">\"가나\"</span>, <span class=\"number\">5</span>));</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>대상 문자열이 “가나다”로 끝나므로 true</li>\n</ol>\n<ol start=\"2\">\n<li>“가나”로 끝나지 않으므로 false</li>\n</ol>\n<ol start=\"3\">\n<li>두 번째 파라미터에 길이 값 5를 지정했으므로 대상 문자열의 5번째 까지만 비교합니다. “가나”로 끝나게 되므로 true 반환</li>\n</ol>\n<hr>\n<h2 id=\"repeat\">repeat(): 문자열 복제</h2>\n\n<p>repeat() 메서드는 문자열을 주어진 횟수만큼 반복해 붙인 새로운 문자열을 반환합니다.</p>\n<blockquote>\n<p>str.repeat(count);</p>\n</blockquote>\n<ul>\n<li><p>count<br>문자열을 반복할 횟수. 0과 양의 무한대 사이의 정수([0, +∞)).</p>\n</li>\n<li><p>반환값<br>현재 문자열을 주어진 횟수만큼 반복해 붙인 새로운 문자열.</p>\n</li>\n<li><p>예외<br>RangeError: 반복 횟수는 양의 정수여야 함.<br>RangeError: 반복 횟수는 무한대보다 작아야 하며, 최대 문자열 크기를 넘어선 안됨.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> target = <span class=\"string\">\"123\"</span>;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, target.repeat(<span class=\"number\">3</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, target.repeat(<span class=\"number\">0</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, target.repeat(<span class=\"number\">2.7</span>));</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>“123” 문자열을 3번 반복하여 123123123 반환</p>\n</li>\n<li><p>파라미터에 0을 작성하면 빈 문자열을 반환합니다. “”</p>\n</li>\n<li><p>2.7과 같이 소수를 작성하면 소수를 버리고 정수만 사용하여 복제합니다.<br>123123 이 반환됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"normalize\">normalize(): 유니코드 정규화 형식 변환</h2>\n\n<p>대상 문자열을 파라미터에 작성한 유니코드 정규화 형식으로 변환하여 반환합니다.<br>만약 주어진 값이 문자열이 아닐 경우에는 우선 문자열로 변환 후 정규화합니다.</p>\n<blockquote>\n<p>str.normalize([form])</p>\n</blockquote>\n<ul>\n<li><p>form<br>유니코드 정규화 방식을 지정합니다. “NFC”, “NFD”, “NFKC”, “NFKD” 중 하나이며, 생략되거나 undefined 일 경우 “NFC”가 디폴트 값 입니다.</p>\n<ul>\n<li>NFC — 정규형 정준 결합(Normalization Form Canonical Composition).</li>\n<li>NFD — 정규형 정준 분해(Normalization Form Canonical Decomposition).</li>\n<li>NFKC — 정규형 호환성 결합(Normalization Form Compatibility Composition).</li>\n<li>NFKD — 정규형 호환성 분해(Normalization Form Compatibility Decomposition).</li>\n</ul>\n</li>\n<li><p>반환 값<br>주어진 문자열을 유니코드 정규화 방식에 따라 정규화된 문자열로 반환합니다.</p>\n</li>\n</ul>\n<p>form이 위에서 명시된 값 중 하나가 아닐 경우 RangeError 에러가 발생합니다.</p>\n<p>normalize() 메서드는 문자열을 유니코드 정규화 방식에 따라 정규화된 형태로 반환합니다. 문자열의 값 자체에는 영향을 주지 않습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"string\">\"ㄱ\"</span>.charCodeAt(<span class=\"number\">0</span>));  </span><br><span class=\"line\"><span class=\"comment\">// 12593 = (0x3131)  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"string\">\"ㅏ\"</span>.charCodeAt(<span class=\"number\">0</span>));  </span><br><span class=\"line\"><span class=\"comment\">// 12623 = (0x314F)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// \"ㄱ\" 과 \"ㅏ\"의 코드 포인트값을 연결 하여 작성  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> jamo = <span class=\"string\">\"\\u3131\\u314F\"</span>;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, jamo.normalize(<span class=\"string\">\"NFC\"</span>));  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, jamo.normalize());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, jamo.normalize(<span class=\"string\">\"NFD\"</span>));  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"6:\"</span>, jamo.normalize(<span class=\"string\">\"NFKD\"</span>));  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"7:\"</span>, jamo.normalize(<span class=\"string\">\"NFKC\"</span>));</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>“ㄱ” 과 “ㅏ” 가 연결된 “가” 모습이 아닌 “ㄱㅏ” 형태가 됩니다.<br>파라미터에 형식 값을 작성하지 않아도 디폴트 값 NFC 변환 형식이 적용됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li>NFC와 같이 NFD도 “ㄱㅏ” 형태로 출력됩니다.</li>\n</ol>\n<ol start=\"3\">\n<li>NFKD 와 NFKC는 “가” 와 같이 글자 하나로 출력됩니다.</li>\n</ol>"},{"title":"Symbol 메서드 -ECMAScript","date":"2020-04-09T01:34:23.000Z","disqusId":"tunas-blog-1","_content":"\n\n*   Symbol 메서드\n    *   [for(): Symbol 값 저장](/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_for)\n        *   글로벌(전역) Symbol 레지스트리\n        *   Symbol의 대표적 사용 형태 세 가지\n    *   [keyFor(): key 값 변환](/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_keyFor)\n    *   [toString(): 문자열로 변환](/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_toString)\n    *   [valueOf(): Symbol 프리미티브 값](/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_valueOf)\n    *   [getOwnPropertySymbols(): Symbol 프로퍼티 반환](/2020/04/09/Symbol%20메서드%20-ECMAScript/#getOwnPropertySymbols)\n    *   [JSON.stringify(): JSON 형태로 변환](/2020/04/09/Symbol%20메서드%20-ECMAScript/#JSON_stringify)\n        *   주석을 프로퍼티 key 값으로 활용\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Symbol_for\">for(): Symbol 값 저장</h2>\n\n글로벌 Symbol 레지스트리(registry)에 Symbol 값을 저장합니다.\n\n> Symbol.for(key);\n\n*   key  \n    String, 필수. 심볼의 키 (심볼의 설명을 위해서도 쓰입니다).\n    \n*   반환 값  \n    해당 키에 해당하는 심볼이 있다면 반환, 없으면 새로운 심볼을 만들고 반환합니다.\n    \n\n<mark>Symbol은 두 개의 스코프에 저장될 수 있습니다.  \n앞에서 다루었던 Symbol()은 Symbol을 생성한 스코프에 Symbol 값이 설정됩니다.</mark>\n\n반면, Symbol.for()은 글로벌 Symbol 레지스트리에 {key: value} 형태로 저장됩니다.  \n파라미터에 지정한 문자열이 key가 되고 생성한 Symbol 값이 value가 됩니다.\n\n**Symbol.for()는 매 호출마다 새로운 심볼을 만들지 않고 현재 레지스트리에 해당 키를 가진 심볼이 있는지 먼저 검사를 합니다. 레지스트리에 key가 있다면 그 심볼(value)을 반환합니다. 만약 key에 해당하는 심볼이 없다면 Symbol.for()는 새로운 전역 심볼을 만들어 반환합니다.**\n\n글로벌 Symbol 레지스트리는 Symbol 값을 공유하기 위한 영역입니다.  \n다른 자바스크립트 프레임워크에서도 공유할 수 있습니다.\n\n### 글로벌(전역) Symbol 레지스트리\n\n글로벌(전역) Symbol 레지스트리는 다음과 같은 가진 기록 구조를 가진 리스트입니다.  \n초기 값은 비어 있습니다.\n\n*   [[[key]] 심볼을 구분하기 위해 사용되는 문자열 키\n*   [[[symbol]] 전역으로 저장되는 심볼\n\n### Symbol의 대표적 사용 형태 세 가지\n\n1.  Symbol() : Symbol 값을 생성하여 스코프 안에서 사용합니다.\n\n2.  Symbol.for() : 글로벌 Symbol 레지스트리에 저장되며 전체 프로그램에서 사용합니다.\n\n3.  Well-Known Symbol : 빌트인 Symbol 프로퍼티로 오버라이드하여 기능을 추가 및 변경 합니다.\n\n```js Symbol.for()\n1. console.log(Symbol.for(\"sports\")); //새로운 전역심볼 생성  \n2. console.log(Symbol.for(\"sports\"));// 이미 만들어진 심볼을 검색  \n  \n3. console.log(Symbol.for(\"ABC\") === Symbol.for(\"ABC\")); //전역심볼  \n4. console.log(Symbol.for(\"DEF\") === Symbol(\"DEF\")); //지역 심볼  \n5. console.log(Symbol.for(true)); // 문자열이 아님  \n// Symbol(sports)  \n// Symbol(sports)  \n  \n// true  \n// false  \n// Symbol(true)  \n```\n\n1.  Symbol 값을 생성하여 글로벌 Symbol 레지스트리에 {key: value} 형태로 저장됩니다.  \n    key: 파라미터로 넘겨준값 (“sports”)  \n    value: 생성한 Symbol 값 ( Symbol.for(“sports”) )  \n    생성한 Symbol을 출력하면 for을 제외하고 Symbol(“sports”)로 출력됩니다.\n\n2.  바로 위에서 sports를 글로벌 Symbol 레지스트리에 저장했으므로  \n    저장된 sports 키의 value를 검색하여 반환합니다.  \n    마찬가지로 for을 제외한 Symbol(“sports”) 형태로 출력됩니다.\n\n3.  Symbol 값을 생성하여 “ABC”를 프로퍼티 키로 글로벌 Symbol 레지스트리에 저장합니다.  \n    오른쪽 Symbol.for(“ABC”)에서 글로벌 Symbol 레지스트리에 프로퍼티 키 “ABC”를 검색하여  \n    생성되있는 Symbol 값을 반환합니다. 왼쪽과 오른쪽 Symbol 값이 같으므로 true가 반환됩니다.\n\n4.  Symbol.for()은 글로벌 Symbol 레지스트리에 저장되고  \n    Symbol()은 스코프에 저장되면서 둘은 공유되지 않습니다. false가 반환됩니다.\n\n5.  파라미터에 true 와 같이 문자열이 아닌 값을 던져주면 문자열로 변환하여 프로퍼티 키로 사용합니다.  \n    key: “true”  \n    value: Symbol.for(“true”)  \n    출력시 Symbol(true)로 출력됩니다.\n\n* * *\n\n<h2 id=\"Symbol_keyFor\">keyFor(): key 값 변환</h2>\n\n글로벌 Symbol 레지스트리에서 프로퍼티 키 값을 반환합니다.\n\n> Symbol.keyFor(Symbol)\n\n파라미터에 글로벌 Symbol 레지스트리에 저장한 Symbol을 지정합니다.  \nSymbol이 아니면 TypeError가 발생합니다.  \n글로벌 Symbol 레지스트리에 Symbol이 존재하면 프로퍼티 키를 반환합니다.  \nSymbol이 존재하지 않으면 undefinded를 반환합니다.\n\n```js keyFor()\nlet globalSym = Symbol.for('foo'); // 글로벌 Symbol 레지스트리에 Symbol 값을 생성합니다.  \nconsole.log(Symbol.keyFor(globalSym)); // \"foo\"  \n  \nlet localSym = Symbol();  \nconsole.log(Symbol.keyFor(localSym)); // undefined  \n```\n\n*   Symbol()은 글로벌 스코프에서 생성하더라도 글로벌 Symbol 레지스트리에는 등록되지 않습니다.  \n    undefined가 반환됩니다.\n\n* * *\n\n<h2 id=\"Symbol_toString\">toString(): 문자열로 변환</h2>\n\nSymbol을 문자열로 변환하여 반환합니다.  \nSymbol 값이 아닌 Symbol 값을 생성한 Symbol() 형태를 문자열로 반환합니다.  \nWell-Known Symbol, 글로벌 Symbol 레지스트리도 변환됩니다.\n\n> Symbol.prototype.toString()\n\n생성한 Symbol 값을 문자열에 연결하면 TypeError가 발생하지만, toString으로 변환하여 연결하면 에러가 나지 않고 문자열로 연결됩니다. toString() 메서드가 Symbol.prototype에 연결되어 있으므로 Symbol() 또는 Symbol.for()로 생성한 Symbol을 사용합니다.\n\n```js toString()\nconsole.log(\"1:\", Symbol(\"123\").toString());  \n// 1: Symbol(123)  \n  \nconsole.log(\"2:\", Symbol.for(\"ABC\").toString());  \n// 2: Symbol(ABC)  \n  \nconsole.log(\"3:\", Symbol.iterator.toString());  \n// 3: Symbol(Symbol.iterator)  \n```\n\n1.  2.  Symbol 값이 아닌 Symbol 값을 생성할 때의 형태를 문자열로 반환합니다.  \n        Symbol.for()도 Symbol()과 같지만 출력할 때 for을 제외시킵니다.\n\n3.  Well-Known Symbol을 문자열로 반환합니다. Symbol 값을 생성할 때의 형태  \n    Symbol.iterator가 Symbol()의 파라미터에 표시됩니다.\n\n* * *\n\n<h2 id=\"Symbol_valueOf\">valueOf(): Symbol 프리미티브 값</h2>\n\nvalueOf () 메서드는 Symbol 오브젝트의 프리미티브 값을 반환합니다.\n\n> Symbol.prototype.valueOf()\n\n모든 빌트인 오브젝트에 valueOf() 메소드가 있으며 프리미티브 값을 반환합니다.  \n예시로 New Number(123)으로 생성한 인스턴스를 valueOf()로 실행하면 123이 반환됩니다.\n\nSymbol도 빌트인 오브젝트이지만 반환 값 형태가 다릅니다.  \nSymbol(123)으로 생성한 Symbol로 valueOf()를 실행하면 Symbol 값이 반환되지 않고,  \nSymbol 값을 생성할 때의 “Symbol(123)”이 반환됩니다.\n\n* * *\n\n<h2 id=\"getOwnPropertySymbols\">getOwnPropertySymbols(): Symbol 프로퍼티 반환</h2>\n\ngetOwnPropertySymbols()는 반환 대상이 Symbol인 Object 오브젝트 메서드 입니다.  \n배열로 반환합니다.\n\n> Object.getOwnPropertySymbols()\n\n*   파라미터  \n    추출 대상 Object\n    \n*   반환  \n    지정한 Object 에서 Symbol 이외의 프로퍼티는 반환하지 않고 오직 Symbol만 배열로 반환합니다.\n    \n\n```js getOwnPropertySymbols\nlet bookObj = {book: 123};  \nbookObj[Symbol(\"one\")] = 10;  \nbookObj[Symbol.for(\"two\")] = 20;  \n  \nlet names = Object.getOwnPropertyNames(bookObj);  \nconsole.log(\"1:\", names);  \n// 1: [\"book\"]  \n  \nlet symbolList = Object.getOwnPropertySymbols(bookObj);  \nconsole.log(\"2:\", symbolList);  \n// 2: [Symbol(one), Symbol(two)]  \n  \nfor (let sym of symbolList){  \n console.log(sym.toString(), bookObj[sym]);  \n// Symbol(one) 10  \n// Symbol(two) 20  \n}  \n  \nlet emptyList = Object.getOwnPropertySymbols({});  \nconsole.log(\"5:\", emptyList.length);  \n// 5: 0  \n```\n\n*   {book:123}으로 Object 오브젝트를 생성하여 bookObj에 할당합니다.  \n    Symbol(“one”)으로 Symbol을 생성하고, bookObj 오브젝트의 symbol-keyed 프로퍼티로 사용하여 10을 할당합니다.  \n    이때 bookObj 오브젝트는 {book: 123, Symbol(“one”): 10} 형태가 됩니다.  \n    글로벌 Symbol 레지스트리에 “two”를 프로퍼티 키로 Symbol 값을 등록하고, bookObj 오브젝트에 symbol-keyed 프로퍼티로 사용하여 20을 할당합니다.  \n    이때 bookObj 오브젝트는 {book: 123, Symbol(“one”): 10, Symbol(“two”): 20} 형태가 됩니다.\n\n1.  getOwnPropertyNames() 파라미터에 지정한 bookObj 오브젝트에서 프로퍼티 이름을 배열로 반환합니다.  \n    이때 Symbol은 반환되지 않습니다. 즉 [“book”]만 출력됩니다.  \n    for-in문으로 전개해도 Symbol은 열거되지 않습니다.\n\n2.  getOwnPropertySymbols() 파라미터에 지정한 bookObj 오브젝트에서  \n    Symbol-keyed 프로퍼티를 배열로 반환합니다. Symbol이 아닌 프로퍼티는 반환하지 않습니다.  \n    [Symbol(one), Symbol(two)]가 반환됩니다.\n\n3.  4.  getOwnPropertySymbols()에서 배열로 반환해 줌으로 for-of문으로 전개할 수 있습니다.  \n        Symbol이 sym 변수에 설정되어 String으로 변환되어 출력됩니다.\n\n5.  getOwnPropertySymbols() 파라미터에 빈 Object 를 지정하면 빈 배열로 반환합니다.  \n    length 값이 0 이 됩니다.\n\n* * *\n\n<h2 id=\"JSON_stringify\">JSON.stringify(): JSON 형태로 변환</h2>\n\n자바스크립트 형태를 JSON 형태의 문자열로 변환합니다.\n\n> JSON.stringify(value[, replacer[, space]])\n\n*   value  \n    JSON 문자열로 변환할 값.\n    \n*   replacer 선택적 파라미터  \n    문자열화 동작 방식을 변경하는 함수, 혹은 JSON 문자열에 포함될 값 객체의 속성들을 선택하기 위한 화이트리스트(whitelist)로 쓰이는 String 과 Number 객체들의 배열. 이 값이 null 이거나 제공되지 않으면, 객체의 모든 속성들이 JSON 문자열 결과에 포함된다.\n    \n*   space 선택적 파라미터  \n    가독성을 목적으로 JSON 문자열 출력에 공백을 삽입하는데 사용되는 String 또는 Number 객체.\n    \n    *   Number 라면, 공백으로 사용되는 스페이스(space)의 수를 나타낸다; 이 수가 10 보다 크면 10 으로 제한된다. 1 보다 작은 값은 스페이스가 사용되지 않는 것을 나타낸다.\n    *   String 이라면, 그 문자열(만약 길이가 10 보다 길다면, 첫번째 10 개의 문자)이 공백으로 사용된다. 이 매개 변수가 제공되지 않는다면(또는 null 이면), 공백이 사용되지 않는다.\n*   반환 값  \n    주어진 값과 대응하는 JSON 문자열.\n    \n\nJSON.stringify()로 자바스크립트 형태의 {key: value}를 JSON 형태의 문자열로 변환하면,  \nSymbol-keyed 프로퍼티로 작성한 Symbol은 변환에서 제외됩니다.  \nSymbol 값을 외부에 노출시키지 않으려는 의도이지만, 에러 역시 나지 않으므로 주의해야 합니다.\n\n```js JSON.stringify\nlet result = JSON.stringify({[Symbol(\"one\")]: \"1\"});  \nconsole.log(result);  \nconsole.log(typeof result);  \n  \nconsole.log(JSON.stringify({[Symbol.for(\"two\")]: \"2\"}));  \n// \"{ }\"  \n// string  \n// \"{ }\"  \n```\n\n*   위와 같이 Symbol(“one”)으로 생성한 Symbol을 Object 오브젝트의 symbol-keyed 프로퍼티로 사용한 것을  \n    JSON.stringify()로 변환하면, Symbol이 변환에서 제외되어 중괄호 {}만 문자열로 반환됩니다.\n\n### 주석을 프로퍼티 key 값으로 활용\n\nSymbol 주석을 프로퍼티 키로 활용하여 JSON.stringify()에서 Symbol이 제외되는 것을 방지하기 위한  \n하나의 코드작성 법입니다.\n\n```js JSON.stringify() Symbol 제외 방지\nlet bookObj = {};  \nbookObj[Symbol(\"one\")] = 10;  \nbookObj[Symbol.for(\"two\")] = 20;  \n  \n1. let symbolList = Object.getOwnPropertySymbols(bookObj);  \nconsole.log(symbolList);  \n  \nlet first, second, key, keyValue = {};  \n2. for (let sym of symbolList){  \n 3. key = Symbol.keyFor(sym);  \n 4. if (key){  \n keyValue[key] = bookObj[sym];  \n } 5. else {  \n //Symbol(one)  \n first = /^Symbol[(]/[Symbol.replace](sym.toString(), \"\");  \n second = /[)]$/[Symbol.replace](first, \"\");  \n 6. keyValue[second] = bookObj[sym];  \n }  \n};  \n7. console.log(JSON.stringify(keyValue));  \n// [Symbol(one), Symbol(two)]  \n// {\"one\": 10, \"two\": 20}  \n```\n\n*   빈 오브젝트 bookObj에 Symbol(one) 과 Symbol.for(two)로 생성한 Symbol을  \n    Symbol-keyed 프로퍼티로 사용하여 프로퍼티 값을 설정해 줬습니다.  \n    {Symbol(“one”): 10, Symbol(“two”): 20} 형태가 됩니다.\n\n1.  getOwnPropertySymbols() 파라미터의 bookObj 오브젝트에서 반환받으면  \n    [Symbol(one), Symbol(two)]가 출력됩니다. symbolList 변수에 할당합니다.\n\n2.  for-of 문으로 symbolList를 반복하면 배열의 순서대로 sym 변수에 할당됩니다.\n\n3.  Symbol.keyFor(sym)을 실행하면 글로벌 Symbol 레지스트리에 등록한 Symbol 키를 반환받습니다.  \n    따라서 Symbol(one)은 undefined를 Symbol.for(two)는 “two”를 반환합니다.\n\n4.  Symbol.for(“two”)가 for-of 문의 sym에 설정될때 실행됩니다.  \n    bookObj 오브젝트의 sym으로 값을 구하면 20이 반환되며, 글로벌 Symbol 레지스트리에 “two”가 프로퍼티 키로 등록되어 있으므로 {two: 20}형태가 됩니다.  \n    ~~Symbol.for()로 생성한 Symbol은 프로퍼티 키와 값을 갖고 있으므로 {key: value}형태를 만들수 있습니다.~~\n\n5.  Symbol(“one”)이 for-of 문의 sym에 설정될 때 실행됩니다.  \n    “one”을 프로퍼티 키로 사용하기 위해 정규 표현식으로 “one”이외의 문자를 빈 문자열로 대체합니다.\n\n6.  bookObj 오브젝트에서 Symbol(“one”)으로 생성한 값으로 프로퍼티 값을 구하면 10이 반환되며,  \n    second 변수 값이 “one”이므로 {one: 10}형태가 됩니다. for-of문 반복을 완료하면  \n    {one: 10, two: 20} 형태가 됩니다.\n\n7.  파라미터에 keyValue를 지정하여 JSON.stringify()를 실행하면 {“one”: 10, “two”: 20}으로 변환됩니다.  \n    Symbol() 주석을 유일하게 지정하면 {key: value} 형태로 Symbol을 변환할 수 있습니다.  \n    Symbol()로 생성한 값을 오브젝트의 프로퍼티 키로 사용하고 이를 서버로 전송하려면 계획적인 접근이 필요합니다.\n","source":"_posts/Symbol 메서드 -ECMAScript.md","raw":"---\ntitle: Symbol 메서드 -ECMAScript\ndate: 2020-04-09 10:34:23\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n\n*   Symbol 메서드\n    *   [for(): Symbol 값 저장](/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_for)\n        *   글로벌(전역) Symbol 레지스트리\n        *   Symbol의 대표적 사용 형태 세 가지\n    *   [keyFor(): key 값 변환](/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_keyFor)\n    *   [toString(): 문자열로 변환](/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_toString)\n    *   [valueOf(): Symbol 프리미티브 값](/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_valueOf)\n    *   [getOwnPropertySymbols(): Symbol 프로퍼티 반환](/2020/04/09/Symbol%20메서드%20-ECMAScript/#getOwnPropertySymbols)\n    *   [JSON.stringify(): JSON 형태로 변환](/2020/04/09/Symbol%20메서드%20-ECMAScript/#JSON_stringify)\n        *   주석을 프로퍼티 key 값으로 활용\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Symbol_for\">for(): Symbol 값 저장</h2>\n\n글로벌 Symbol 레지스트리(registry)에 Symbol 값을 저장합니다.\n\n> Symbol.for(key);\n\n*   key  \n    String, 필수. 심볼의 키 (심볼의 설명을 위해서도 쓰입니다).\n    \n*   반환 값  \n    해당 키에 해당하는 심볼이 있다면 반환, 없으면 새로운 심볼을 만들고 반환합니다.\n    \n\n<mark>Symbol은 두 개의 스코프에 저장될 수 있습니다.  \n앞에서 다루었던 Symbol()은 Symbol을 생성한 스코프에 Symbol 값이 설정됩니다.</mark>\n\n반면, Symbol.for()은 글로벌 Symbol 레지스트리에 {key: value} 형태로 저장됩니다.  \n파라미터에 지정한 문자열이 key가 되고 생성한 Symbol 값이 value가 됩니다.\n\n**Symbol.for()는 매 호출마다 새로운 심볼을 만들지 않고 현재 레지스트리에 해당 키를 가진 심볼이 있는지 먼저 검사를 합니다. 레지스트리에 key가 있다면 그 심볼(value)을 반환합니다. 만약 key에 해당하는 심볼이 없다면 Symbol.for()는 새로운 전역 심볼을 만들어 반환합니다.**\n\n글로벌 Symbol 레지스트리는 Symbol 값을 공유하기 위한 영역입니다.  \n다른 자바스크립트 프레임워크에서도 공유할 수 있습니다.\n\n### 글로벌(전역) Symbol 레지스트리\n\n글로벌(전역) Symbol 레지스트리는 다음과 같은 가진 기록 구조를 가진 리스트입니다.  \n초기 값은 비어 있습니다.\n\n*   [[[key]] 심볼을 구분하기 위해 사용되는 문자열 키\n*   [[[symbol]] 전역으로 저장되는 심볼\n\n### Symbol의 대표적 사용 형태 세 가지\n\n1.  Symbol() : Symbol 값을 생성하여 스코프 안에서 사용합니다.\n\n2.  Symbol.for() : 글로벌 Symbol 레지스트리에 저장되며 전체 프로그램에서 사용합니다.\n\n3.  Well-Known Symbol : 빌트인 Symbol 프로퍼티로 오버라이드하여 기능을 추가 및 변경 합니다.\n\n```js Symbol.for()\n1. console.log(Symbol.for(\"sports\")); //새로운 전역심볼 생성  \n2. console.log(Symbol.for(\"sports\"));// 이미 만들어진 심볼을 검색  \n  \n3. console.log(Symbol.for(\"ABC\") === Symbol.for(\"ABC\")); //전역심볼  \n4. console.log(Symbol.for(\"DEF\") === Symbol(\"DEF\")); //지역 심볼  \n5. console.log(Symbol.for(true)); // 문자열이 아님  \n// Symbol(sports)  \n// Symbol(sports)  \n  \n// true  \n// false  \n// Symbol(true)  \n```\n\n1.  Symbol 값을 생성하여 글로벌 Symbol 레지스트리에 {key: value} 형태로 저장됩니다.  \n    key: 파라미터로 넘겨준값 (“sports”)  \n    value: 생성한 Symbol 값 ( Symbol.for(“sports”) )  \n    생성한 Symbol을 출력하면 for을 제외하고 Symbol(“sports”)로 출력됩니다.\n\n2.  바로 위에서 sports를 글로벌 Symbol 레지스트리에 저장했으므로  \n    저장된 sports 키의 value를 검색하여 반환합니다.  \n    마찬가지로 for을 제외한 Symbol(“sports”) 형태로 출력됩니다.\n\n3.  Symbol 값을 생성하여 “ABC”를 프로퍼티 키로 글로벌 Symbol 레지스트리에 저장합니다.  \n    오른쪽 Symbol.for(“ABC”)에서 글로벌 Symbol 레지스트리에 프로퍼티 키 “ABC”를 검색하여  \n    생성되있는 Symbol 값을 반환합니다. 왼쪽과 오른쪽 Symbol 값이 같으므로 true가 반환됩니다.\n\n4.  Symbol.for()은 글로벌 Symbol 레지스트리에 저장되고  \n    Symbol()은 스코프에 저장되면서 둘은 공유되지 않습니다. false가 반환됩니다.\n\n5.  파라미터에 true 와 같이 문자열이 아닌 값을 던져주면 문자열로 변환하여 프로퍼티 키로 사용합니다.  \n    key: “true”  \n    value: Symbol.for(“true”)  \n    출력시 Symbol(true)로 출력됩니다.\n\n* * *\n\n<h2 id=\"Symbol_keyFor\">keyFor(): key 값 변환</h2>\n\n글로벌 Symbol 레지스트리에서 프로퍼티 키 값을 반환합니다.\n\n> Symbol.keyFor(Symbol)\n\n파라미터에 글로벌 Symbol 레지스트리에 저장한 Symbol을 지정합니다.  \nSymbol이 아니면 TypeError가 발생합니다.  \n글로벌 Symbol 레지스트리에 Symbol이 존재하면 프로퍼티 키를 반환합니다.  \nSymbol이 존재하지 않으면 undefinded를 반환합니다.\n\n```js keyFor()\nlet globalSym = Symbol.for('foo'); // 글로벌 Symbol 레지스트리에 Symbol 값을 생성합니다.  \nconsole.log(Symbol.keyFor(globalSym)); // \"foo\"  \n  \nlet localSym = Symbol();  \nconsole.log(Symbol.keyFor(localSym)); // undefined  \n```\n\n*   Symbol()은 글로벌 스코프에서 생성하더라도 글로벌 Symbol 레지스트리에는 등록되지 않습니다.  \n    undefined가 반환됩니다.\n\n* * *\n\n<h2 id=\"Symbol_toString\">toString(): 문자열로 변환</h2>\n\nSymbol을 문자열로 변환하여 반환합니다.  \nSymbol 값이 아닌 Symbol 값을 생성한 Symbol() 형태를 문자열로 반환합니다.  \nWell-Known Symbol, 글로벌 Symbol 레지스트리도 변환됩니다.\n\n> Symbol.prototype.toString()\n\n생성한 Symbol 값을 문자열에 연결하면 TypeError가 발생하지만, toString으로 변환하여 연결하면 에러가 나지 않고 문자열로 연결됩니다. toString() 메서드가 Symbol.prototype에 연결되어 있으므로 Symbol() 또는 Symbol.for()로 생성한 Symbol을 사용합니다.\n\n```js toString()\nconsole.log(\"1:\", Symbol(\"123\").toString());  \n// 1: Symbol(123)  \n  \nconsole.log(\"2:\", Symbol.for(\"ABC\").toString());  \n// 2: Symbol(ABC)  \n  \nconsole.log(\"3:\", Symbol.iterator.toString());  \n// 3: Symbol(Symbol.iterator)  \n```\n\n1.  2.  Symbol 값이 아닌 Symbol 값을 생성할 때의 형태를 문자열로 반환합니다.  \n        Symbol.for()도 Symbol()과 같지만 출력할 때 for을 제외시킵니다.\n\n3.  Well-Known Symbol을 문자열로 반환합니다. Symbol 값을 생성할 때의 형태  \n    Symbol.iterator가 Symbol()의 파라미터에 표시됩니다.\n\n* * *\n\n<h2 id=\"Symbol_valueOf\">valueOf(): Symbol 프리미티브 값</h2>\n\nvalueOf () 메서드는 Symbol 오브젝트의 프리미티브 값을 반환합니다.\n\n> Symbol.prototype.valueOf()\n\n모든 빌트인 오브젝트에 valueOf() 메소드가 있으며 프리미티브 값을 반환합니다.  \n예시로 New Number(123)으로 생성한 인스턴스를 valueOf()로 실행하면 123이 반환됩니다.\n\nSymbol도 빌트인 오브젝트이지만 반환 값 형태가 다릅니다.  \nSymbol(123)으로 생성한 Symbol로 valueOf()를 실행하면 Symbol 값이 반환되지 않고,  \nSymbol 값을 생성할 때의 “Symbol(123)”이 반환됩니다.\n\n* * *\n\n<h2 id=\"getOwnPropertySymbols\">getOwnPropertySymbols(): Symbol 프로퍼티 반환</h2>\n\ngetOwnPropertySymbols()는 반환 대상이 Symbol인 Object 오브젝트 메서드 입니다.  \n배열로 반환합니다.\n\n> Object.getOwnPropertySymbols()\n\n*   파라미터  \n    추출 대상 Object\n    \n*   반환  \n    지정한 Object 에서 Symbol 이외의 프로퍼티는 반환하지 않고 오직 Symbol만 배열로 반환합니다.\n    \n\n```js getOwnPropertySymbols\nlet bookObj = {book: 123};  \nbookObj[Symbol(\"one\")] = 10;  \nbookObj[Symbol.for(\"two\")] = 20;  \n  \nlet names = Object.getOwnPropertyNames(bookObj);  \nconsole.log(\"1:\", names);  \n// 1: [\"book\"]  \n  \nlet symbolList = Object.getOwnPropertySymbols(bookObj);  \nconsole.log(\"2:\", symbolList);  \n// 2: [Symbol(one), Symbol(two)]  \n  \nfor (let sym of symbolList){  \n console.log(sym.toString(), bookObj[sym]);  \n// Symbol(one) 10  \n// Symbol(two) 20  \n}  \n  \nlet emptyList = Object.getOwnPropertySymbols({});  \nconsole.log(\"5:\", emptyList.length);  \n// 5: 0  \n```\n\n*   {book:123}으로 Object 오브젝트를 생성하여 bookObj에 할당합니다.  \n    Symbol(“one”)으로 Symbol을 생성하고, bookObj 오브젝트의 symbol-keyed 프로퍼티로 사용하여 10을 할당합니다.  \n    이때 bookObj 오브젝트는 {book: 123, Symbol(“one”): 10} 형태가 됩니다.  \n    글로벌 Symbol 레지스트리에 “two”를 프로퍼티 키로 Symbol 값을 등록하고, bookObj 오브젝트에 symbol-keyed 프로퍼티로 사용하여 20을 할당합니다.  \n    이때 bookObj 오브젝트는 {book: 123, Symbol(“one”): 10, Symbol(“two”): 20} 형태가 됩니다.\n\n1.  getOwnPropertyNames() 파라미터에 지정한 bookObj 오브젝트에서 프로퍼티 이름을 배열로 반환합니다.  \n    이때 Symbol은 반환되지 않습니다. 즉 [“book”]만 출력됩니다.  \n    for-in문으로 전개해도 Symbol은 열거되지 않습니다.\n\n2.  getOwnPropertySymbols() 파라미터에 지정한 bookObj 오브젝트에서  \n    Symbol-keyed 프로퍼티를 배열로 반환합니다. Symbol이 아닌 프로퍼티는 반환하지 않습니다.  \n    [Symbol(one), Symbol(two)]가 반환됩니다.\n\n3.  4.  getOwnPropertySymbols()에서 배열로 반환해 줌으로 for-of문으로 전개할 수 있습니다.  \n        Symbol이 sym 변수에 설정되어 String으로 변환되어 출력됩니다.\n\n5.  getOwnPropertySymbols() 파라미터에 빈 Object 를 지정하면 빈 배열로 반환합니다.  \n    length 값이 0 이 됩니다.\n\n* * *\n\n<h2 id=\"JSON_stringify\">JSON.stringify(): JSON 형태로 변환</h2>\n\n자바스크립트 형태를 JSON 형태의 문자열로 변환합니다.\n\n> JSON.stringify(value[, replacer[, space]])\n\n*   value  \n    JSON 문자열로 변환할 값.\n    \n*   replacer 선택적 파라미터  \n    문자열화 동작 방식을 변경하는 함수, 혹은 JSON 문자열에 포함될 값 객체의 속성들을 선택하기 위한 화이트리스트(whitelist)로 쓰이는 String 과 Number 객체들의 배열. 이 값이 null 이거나 제공되지 않으면, 객체의 모든 속성들이 JSON 문자열 결과에 포함된다.\n    \n*   space 선택적 파라미터  \n    가독성을 목적으로 JSON 문자열 출력에 공백을 삽입하는데 사용되는 String 또는 Number 객체.\n    \n    *   Number 라면, 공백으로 사용되는 스페이스(space)의 수를 나타낸다; 이 수가 10 보다 크면 10 으로 제한된다. 1 보다 작은 값은 스페이스가 사용되지 않는 것을 나타낸다.\n    *   String 이라면, 그 문자열(만약 길이가 10 보다 길다면, 첫번째 10 개의 문자)이 공백으로 사용된다. 이 매개 변수가 제공되지 않는다면(또는 null 이면), 공백이 사용되지 않는다.\n*   반환 값  \n    주어진 값과 대응하는 JSON 문자열.\n    \n\nJSON.stringify()로 자바스크립트 형태의 {key: value}를 JSON 형태의 문자열로 변환하면,  \nSymbol-keyed 프로퍼티로 작성한 Symbol은 변환에서 제외됩니다.  \nSymbol 값을 외부에 노출시키지 않으려는 의도이지만, 에러 역시 나지 않으므로 주의해야 합니다.\n\n```js JSON.stringify\nlet result = JSON.stringify({[Symbol(\"one\")]: \"1\"});  \nconsole.log(result);  \nconsole.log(typeof result);  \n  \nconsole.log(JSON.stringify({[Symbol.for(\"two\")]: \"2\"}));  \n// \"{ }\"  \n// string  \n// \"{ }\"  \n```\n\n*   위와 같이 Symbol(“one”)으로 생성한 Symbol을 Object 오브젝트의 symbol-keyed 프로퍼티로 사용한 것을  \n    JSON.stringify()로 변환하면, Symbol이 변환에서 제외되어 중괄호 {}만 문자열로 반환됩니다.\n\n### 주석을 프로퍼티 key 값으로 활용\n\nSymbol 주석을 프로퍼티 키로 활용하여 JSON.stringify()에서 Symbol이 제외되는 것을 방지하기 위한  \n하나의 코드작성 법입니다.\n\n```js JSON.stringify() Symbol 제외 방지\nlet bookObj = {};  \nbookObj[Symbol(\"one\")] = 10;  \nbookObj[Symbol.for(\"two\")] = 20;  \n  \n1. let symbolList = Object.getOwnPropertySymbols(bookObj);  \nconsole.log(symbolList);  \n  \nlet first, second, key, keyValue = {};  \n2. for (let sym of symbolList){  \n 3. key = Symbol.keyFor(sym);  \n 4. if (key){  \n keyValue[key] = bookObj[sym];  \n } 5. else {  \n //Symbol(one)  \n first = /^Symbol[(]/[Symbol.replace](sym.toString(), \"\");  \n second = /[)]$/[Symbol.replace](first, \"\");  \n 6. keyValue[second] = bookObj[sym];  \n }  \n};  \n7. console.log(JSON.stringify(keyValue));  \n// [Symbol(one), Symbol(two)]  \n// {\"one\": 10, \"two\": 20}  \n```\n\n*   빈 오브젝트 bookObj에 Symbol(one) 과 Symbol.for(two)로 생성한 Symbol을  \n    Symbol-keyed 프로퍼티로 사용하여 프로퍼티 값을 설정해 줬습니다.  \n    {Symbol(“one”): 10, Symbol(“two”): 20} 형태가 됩니다.\n\n1.  getOwnPropertySymbols() 파라미터의 bookObj 오브젝트에서 반환받으면  \n    [Symbol(one), Symbol(two)]가 출력됩니다. symbolList 변수에 할당합니다.\n\n2.  for-of 문으로 symbolList를 반복하면 배열의 순서대로 sym 변수에 할당됩니다.\n\n3.  Symbol.keyFor(sym)을 실행하면 글로벌 Symbol 레지스트리에 등록한 Symbol 키를 반환받습니다.  \n    따라서 Symbol(one)은 undefined를 Symbol.for(two)는 “two”를 반환합니다.\n\n4.  Symbol.for(“two”)가 for-of 문의 sym에 설정될때 실행됩니다.  \n    bookObj 오브젝트의 sym으로 값을 구하면 20이 반환되며, 글로벌 Symbol 레지스트리에 “two”가 프로퍼티 키로 등록되어 있으므로 {two: 20}형태가 됩니다.  \n    ~~Symbol.for()로 생성한 Symbol은 프로퍼티 키와 값을 갖고 있으므로 {key: value}형태를 만들수 있습니다.~~\n\n5.  Symbol(“one”)이 for-of 문의 sym에 설정될 때 실행됩니다.  \n    “one”을 프로퍼티 키로 사용하기 위해 정규 표현식으로 “one”이외의 문자를 빈 문자열로 대체합니다.\n\n6.  bookObj 오브젝트에서 Symbol(“one”)으로 생성한 값으로 프로퍼티 값을 구하면 10이 반환되며,  \n    second 변수 값이 “one”이므로 {one: 10}형태가 됩니다. for-of문 반복을 완료하면  \n    {one: 10, two: 20} 형태가 됩니다.\n\n7.  파라미터에 keyValue를 지정하여 JSON.stringify()를 실행하면 {“one”: 10, “two”: 20}으로 변환됩니다.  \n    Symbol() 주석을 유일하게 지정하면 {key: value} 형태로 Symbol을 변환할 수 있습니다.  \n    Symbol()로 생성한 값을 오브젝트의 프로퍼티 키로 사용하고 이를 서버로 전송하려면 계획적인 접근이 필요합니다.\n","slug":"Symbol 메서드 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrsw001tqgvqdev3c6gw","content":"<ul>\n<li>Symbol 메서드<ul>\n<li><a href=\"/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_for\">for(): Symbol 값 저장</a><ul>\n<li>글로벌(전역) Symbol 레지스트리</li>\n<li>Symbol의 대표적 사용 형태 세 가지</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_keyFor\">keyFor(): key 값 변환</a></li>\n<li><a href=\"/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_toString\">toString(): 문자열로 변환</a></li>\n<li><a href=\"/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_valueOf\">valueOf(): Symbol 프리미티브 값</a></li>\n<li><a href=\"/2020/04/09/Symbol%20메서드%20-ECMAScript/#getOwnPropertySymbols\">getOwnPropertySymbols(): Symbol 프로퍼티 반환</a></li>\n<li><a href=\"/2020/04/09/Symbol%20메서드%20-ECMAScript/#JSON_stringify\">JSON.stringify(): JSON 형태로 변환</a><ul>\n<li>주석을 프로퍼티 key 값으로 활용</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"Symbol_for\">for(): Symbol 값 저장</h2>\n\n<p>글로벌 Symbol 레지스트리(registry)에 Symbol 값을 저장합니다.</p>\n<blockquote>\n<p>Symbol.for(key);</p>\n</blockquote>\n<ul>\n<li><p>key<br>String, 필수. 심볼의 키 (심볼의 설명을 위해서도 쓰입니다).</p>\n</li>\n<li><p>반환 값<br>해당 키에 해당하는 심볼이 있다면 반환, 없으면 새로운 심볼을 만들고 반환합니다.</p>\n</li>\n</ul>\n<p><mark>Symbol은 두 개의 스코프에 저장될 수 있습니다.<br>앞에서 다루었던 Symbol()은 Symbol을 생성한 스코프에 Symbol 값이 설정됩니다.</mark></p>\n<p>반면, Symbol.for()은 글로벌 Symbol 레지스트리에 {key: value} 형태로 저장됩니다.<br>파라미터에 지정한 문자열이 key가 되고 생성한 Symbol 값이 value가 됩니다.</p>\n<p><strong>Symbol.for()는 매 호출마다 새로운 심볼을 만들지 않고 현재 레지스트리에 해당 키를 가진 심볼이 있는지 먼저 검사를 합니다. 레지스트리에 key가 있다면 그 심볼(value)을 반환합니다. 만약 key에 해당하는 심볼이 없다면 Symbol.for()는 새로운 전역 심볼을 만들어 반환합니다.</strong></p>\n<p>글로벌 Symbol 레지스트리는 Symbol 값을 공유하기 위한 영역입니다.<br>다른 자바스크립트 프레임워크에서도 공유할 수 있습니다.</p>\n<h3 id=\"글로벌-전역-Symbol-레지스트리\"><a href=\"#글로벌-전역-Symbol-레지스트리\" class=\"headerlink\" title=\"글로벌(전역) Symbol 레지스트리\"></a>글로벌(전역) Symbol 레지스트리</h3><p>글로벌(전역) Symbol 레지스트리는 다음과 같은 가진 기록 구조를 가진 리스트입니다.<br>초기 값은 비어 있습니다.</p>\n<ul>\n<li>[[[key]] 심볼을 구분하기 위해 사용되는 문자열 키</li>\n<li>[[[symbol]] 전역으로 저장되는 심볼</li>\n</ul>\n<h3 id=\"Symbol의-대표적-사용-형태-세-가지\"><a href=\"#Symbol의-대표적-사용-형태-세-가지\" class=\"headerlink\" title=\"Symbol의 대표적 사용 형태 세 가지\"></a>Symbol의 대표적 사용 형태 세 가지</h3><ol>\n<li><p>Symbol() : Symbol 값을 생성하여 스코프 안에서 사용합니다.</p>\n</li>\n<li><p>Symbol.for() : 글로벌 Symbol 레지스트리에 저장되며 전체 프로그램에서 사용합니다.</p>\n</li>\n<li><p>Well-Known Symbol : 빌트인 Symbol 프로퍼티로 오버라이드하여 기능을 추가 및 변경 합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>Symbol.for()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"sports\"</span>)); <span class=\"comment\">//새로운 전역심볼 생성  </span></span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"sports\"</span>));<span class=\"comment\">// 이미 만들어진 심볼을 검색  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"ABC\"</span>) === <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"ABC\"</span>)); <span class=\"comment\">//전역심볼  </span></span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"DEF\"</span>) === <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"DEF\"</span>)); <span class=\"comment\">//지역 심볼  </span></span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Symbol</span>.for(<span class=\"literal\">true</span>)); <span class=\"comment\">// 문자열이 아님  </span></span><br><span class=\"line\"><span class=\"comment\">// Symbol(sports)  </span></span><br><span class=\"line\"><span class=\"comment\">// Symbol(sports)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// true  </span></span><br><span class=\"line\"><span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"comment\">// Symbol(true)</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Symbol 값을 생성하여 글로벌 Symbol 레지스트리에 {key: value} 형태로 저장됩니다.<br>key: 파라미터로 넘겨준값 (“sports”)<br>value: 생성한 Symbol 값 ( Symbol.for(“sports”) )<br>생성한 Symbol을 출력하면 for을 제외하고 Symbol(“sports”)로 출력됩니다.</p>\n</li>\n<li><p>바로 위에서 sports를 글로벌 Symbol 레지스트리에 저장했으므로<br>저장된 sports 키의 value를 검색하여 반환합니다.<br>마찬가지로 for을 제외한 Symbol(“sports”) 형태로 출력됩니다.</p>\n</li>\n<li><p>Symbol 값을 생성하여 “ABC”를 프로퍼티 키로 글로벌 Symbol 레지스트리에 저장합니다.<br>오른쪽 Symbol.for(“ABC”)에서 글로벌 Symbol 레지스트리에 프로퍼티 키 “ABC”를 검색하여<br>생성되있는 Symbol 값을 반환합니다. 왼쪽과 오른쪽 Symbol 값이 같으므로 true가 반환됩니다.</p>\n</li>\n<li><p>Symbol.for()은 글로벌 Symbol 레지스트리에 저장되고<br>Symbol()은 스코프에 저장되면서 둘은 공유되지 않습니다. false가 반환됩니다.</p>\n</li>\n<li><p>파라미터에 true 와 같이 문자열이 아닌 값을 던져주면 문자열로 변환하여 프로퍼티 키로 사용합니다.<br>key: “true”<br>value: Symbol.for(“true”)<br>출력시 Symbol(true)로 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Symbol_keyFor\">keyFor(): key 값 변환</h2>\n\n<p>글로벌 Symbol 레지스트리에서 프로퍼티 키 값을 반환합니다.</p>\n<blockquote>\n<p>Symbol.keyFor(Symbol)</p>\n</blockquote>\n<p>파라미터에 글로벌 Symbol 레지스트리에 저장한 Symbol을 지정합니다.<br>Symbol이 아니면 TypeError가 발생합니다.<br>글로벌 Symbol 레지스트리에 Symbol이 존재하면 프로퍼티 키를 반환합니다.<br>Symbol이 존재하지 않으면 undefinded를 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>keyFor()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> globalSym = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">'foo'</span>); <span class=\"comment\">// 글로벌 Symbol 레지스트리에 Symbol 값을 생성합니다.  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Symbol</span>.keyFor(globalSym)); <span class=\"comment\">// \"foo\"  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> localSym = <span class=\"built_in\">Symbol</span>();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Symbol</span>.keyFor(localSym)); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Symbol()은 글로벌 스코프에서 생성하더라도 글로벌 Symbol 레지스트리에는 등록되지 않습니다.<br>undefined가 반환됩니다.</li>\n</ul>\n<hr>\n<h2 id=\"Symbol_toString\">toString(): 문자열로 변환</h2>\n\n<p>Symbol을 문자열로 변환하여 반환합니다.<br>Symbol 값이 아닌 Symbol 값을 생성한 Symbol() 형태를 문자열로 반환합니다.<br>Well-Known Symbol, 글로벌 Symbol 레지스트리도 변환됩니다.</p>\n<blockquote>\n<p>Symbol.prototype.toString()</p>\n</blockquote>\n<p>생성한 Symbol 값을 문자열에 연결하면 TypeError가 발생하지만, toString으로 변환하여 연결하면 에러가 나지 않고 문자열로 연결됩니다. toString() 메서드가 Symbol.prototype에 연결되어 있으므로 Symbol() 또는 Symbol.for()로 생성한 Symbol을 사용합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>toString()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"123\"</span>).toString());  </span><br><span class=\"line\"><span class=\"comment\">// 1: Symbol(123)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"ABC\"</span>).toString());  </span><br><span class=\"line\"><span class=\"comment\">// 2: Symbol(ABC)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">Symbol</span>.iterator.toString());  </span><br><span class=\"line\"><span class=\"comment\">// 3: Symbol(Symbol.iterator)</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><ol start=\"2\">\n<li>Symbol 값이 아닌 Symbol 값을 생성할 때의 형태를 문자열로 반환합니다.<br>Symbol.for()도 Symbol()과 같지만 출력할 때 for을 제외시킵니다.</li>\n</ol>\n</li>\n<li><p>Well-Known Symbol을 문자열로 반환합니다. Symbol 값을 생성할 때의 형태<br>Symbol.iterator가 Symbol()의 파라미터에 표시됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Symbol_valueOf\">valueOf(): Symbol 프리미티브 값</h2>\n\n<p>valueOf () 메서드는 Symbol 오브젝트의 프리미티브 값을 반환합니다.</p>\n<blockquote>\n<p>Symbol.prototype.valueOf()</p>\n</blockquote>\n<p>모든 빌트인 오브젝트에 valueOf() 메소드가 있으며 프리미티브 값을 반환합니다.<br>예시로 New Number(123)으로 생성한 인스턴스를 valueOf()로 실행하면 123이 반환됩니다.</p>\n<p>Symbol도 빌트인 오브젝트이지만 반환 값 형태가 다릅니다.<br>Symbol(123)으로 생성한 Symbol로 valueOf()를 실행하면 Symbol 값이 반환되지 않고,<br>Symbol 값을 생성할 때의 “Symbol(123)”이 반환됩니다.</p>\n<hr>\n<h2 id=\"getOwnPropertySymbols\">getOwnPropertySymbols(): Symbol 프로퍼티 반환</h2>\n\n<p>getOwnPropertySymbols()는 반환 대상이 Symbol인 Object 오브젝트 메서드 입니다.<br>배열로 반환합니다.</p>\n<blockquote>\n<p>Object.getOwnPropertySymbols()</p>\n</blockquote>\n<ul>\n<li><p>파라미터<br>추출 대상 Object</p>\n</li>\n<li><p>반환<br>지정한 Object 에서 Symbol 이외의 프로퍼티는 반환하지 않고 오직 Symbol만 배열로 반환합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>getOwnPropertySymbols</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bookObj = &#123;<span class=\"attr\">book</span>: <span class=\"number\">123</span>&#125;;  </span><br><span class=\"line\">bookObj[<span class=\"built_in\">Symbol</span>(<span class=\"string\">\"one\"</span>)] = <span class=\"number\">10</span>;  </span><br><span class=\"line\">bookObj[<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"two\"</span>)] = <span class=\"number\">20</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> names = <span class=\"built_in\">Object</span>.getOwnPropertyNames(bookObj);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, names);  </span><br><span class=\"line\"><span class=\"comment\">// 1: [\"book\"]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> symbolList = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(bookObj);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, symbolList);  </span><br><span class=\"line\"><span class=\"comment\">// 2: [Symbol(one), Symbol(two)]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> sym <span class=\"keyword\">of</span> symbolList)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(sym.toString(), bookObj[sym]);  </span><br><span class=\"line\"><span class=\"comment\">// Symbol(one) 10  </span></span><br><span class=\"line\"><span class=\"comment\">// Symbol(two) 20  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> emptyList = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(&#123;&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, emptyList.length);  </span><br><span class=\"line\"><span class=\"comment\">// 5: 0</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>{book:123}으로 Object 오브젝트를 생성하여 bookObj에 할당합니다.<br>Symbol(“one”)으로 Symbol을 생성하고, bookObj 오브젝트의 symbol-keyed 프로퍼티로 사용하여 10을 할당합니다.<br>이때 bookObj 오브젝트는 {book: 123, Symbol(“one”): 10} 형태가 됩니다.<br>글로벌 Symbol 레지스트리에 “two”를 프로퍼티 키로 Symbol 값을 등록하고, bookObj 오브젝트에 symbol-keyed 프로퍼티로 사용하여 20을 할당합니다.<br>이때 bookObj 오브젝트는 {book: 123, Symbol(“one”): 10, Symbol(“two”): 20} 형태가 됩니다.</li>\n</ul>\n<ol>\n<li><p>getOwnPropertyNames() 파라미터에 지정한 bookObj 오브젝트에서 프로퍼티 이름을 배열로 반환합니다.<br>이때 Symbol은 반환되지 않습니다. 즉 [“book”]만 출력됩니다.<br>for-in문으로 전개해도 Symbol은 열거되지 않습니다.</p>\n</li>\n<li><p>getOwnPropertySymbols() 파라미터에 지정한 bookObj 오브젝트에서<br>Symbol-keyed 프로퍼티를 배열로 반환합니다. Symbol이 아닌 프로퍼티는 반환하지 않습니다.<br>[Symbol(one), Symbol(two)]가 반환됩니다.</p>\n</li>\n<li><ol start=\"4\">\n<li>getOwnPropertySymbols()에서 배열로 반환해 줌으로 for-of문으로 전개할 수 있습니다.<br>Symbol이 sym 변수에 설정되어 String으로 변환되어 출력됩니다.</li>\n</ol>\n</li>\n<li><p>getOwnPropertySymbols() 파라미터에 빈 Object 를 지정하면 빈 배열로 반환합니다.<br>length 값이 0 이 됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"JSON_stringify\">JSON.stringify(): JSON 형태로 변환</h2>\n\n<p>자바스크립트 형태를 JSON 형태의 문자열로 변환합니다.</p>\n<blockquote>\n<p>JSON.stringify(value[, replacer[, space]])</p>\n</blockquote>\n<ul>\n<li><p>value<br>JSON 문자열로 변환할 값.</p>\n</li>\n<li><p>replacer 선택적 파라미터<br>문자열화 동작 방식을 변경하는 함수, 혹은 JSON 문자열에 포함될 값 객체의 속성들을 선택하기 위한 화이트리스트(whitelist)로 쓰이는 String 과 Number 객체들의 배열. 이 값이 null 이거나 제공되지 않으면, 객체의 모든 속성들이 JSON 문자열 결과에 포함된다.</p>\n</li>\n<li><p>space 선택적 파라미터<br>가독성을 목적으로 JSON 문자열 출력에 공백을 삽입하는데 사용되는 String 또는 Number 객체.</p>\n<ul>\n<li>Number 라면, 공백으로 사용되는 스페이스(space)의 수를 나타낸다; 이 수가 10 보다 크면 10 으로 제한된다. 1 보다 작은 값은 스페이스가 사용되지 않는 것을 나타낸다.</li>\n<li>String 이라면, 그 문자열(만약 길이가 10 보다 길다면, 첫번째 10 개의 문자)이 공백으로 사용된다. 이 매개 변수가 제공되지 않는다면(또는 null 이면), 공백이 사용되지 않는다.</li>\n</ul>\n</li>\n<li><p>반환 값<br>주어진 값과 대응하는 JSON 문자열.</p>\n</li>\n</ul>\n<p>JSON.stringify()로 자바스크립트 형태의 {key: value}를 JSON 형태의 문자열로 변환하면,<br>Symbol-keyed 프로퍼티로 작성한 Symbol은 변환에서 제외됩니다.<br>Symbol 값을 외부에 노출시키지 않으려는 의도이지만, 에러 역시 나지 않으므로 주의해야 합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>JSON.stringify</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">JSON</span>.stringify(&#123;[<span class=\"built_in\">Symbol</span>(<span class=\"string\">\"one\"</span>)]: <span class=\"string\">\"1\"</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> result);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(&#123;[<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"two\"</span>)]: <span class=\"string\">\"2\"</span>&#125;));  </span><br><span class=\"line\"><span class=\"comment\">// \"&#123; &#125;\"  </span></span><br><span class=\"line\"><span class=\"comment\">// string  </span></span><br><span class=\"line\"><span class=\"comment\">// \"&#123; &#125;\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>위와 같이 Symbol(“one”)으로 생성한 Symbol을 Object 오브젝트의 symbol-keyed 프로퍼티로 사용한 것을<br>JSON.stringify()로 변환하면, Symbol이 변환에서 제외되어 중괄호 {}만 문자열로 반환됩니다.</li>\n</ul>\n<h3 id=\"주석을-프로퍼티-key-값으로-활용\"><a href=\"#주석을-프로퍼티-key-값으로-활용\" class=\"headerlink\" title=\"주석을 프로퍼티 key 값으로 활용\"></a>주석을 프로퍼티 key 값으로 활용</h3><p>Symbol 주석을 프로퍼티 키로 활용하여 JSON.stringify()에서 Symbol이 제외되는 것을 방지하기 위한<br>하나의 코드작성 법입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>JSON.stringify() Symbol 제외 방지</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bookObj = &#123;&#125;;  </span><br><span class=\"line\">bookObj[<span class=\"built_in\">Symbol</span>(<span class=\"string\">\"one\"</span>)] = <span class=\"number\">10</span>;  </span><br><span class=\"line\">bookObj[<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"two\"</span>)] = <span class=\"number\">20</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> symbolList = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(bookObj);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(symbolList);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> first, second, key, keyValue = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> sym <span class=\"keyword\">of</span> symbolList)&#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> key = <span class=\"built_in\">Symbol</span>.keyFor(sym);  </span><br><span class=\"line\"> <span class=\"number\">4.</span> <span class=\"keyword\">if</span> (key)&#123;  </span><br><span class=\"line\"> keyValue[key] = bookObj[sym];  </span><br><span class=\"line\"> &#125; <span class=\"number\">5.</span> <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\"> <span class=\"comment\">//Symbol(one)  </span></span><br><span class=\"line\"> first = <span class=\"regexp\">/^Symbol[(]/</span>[<span class=\"built_in\">Symbol</span>.replace](sym.toString(), <span class=\"string\">\"\"</span>);  </span><br><span class=\"line\"> second = <span class=\"regexp\">/[)]$/</span>[<span class=\"built_in\">Symbol</span>.replace](first, <span class=\"string\">\"\"</span>);  </span><br><span class=\"line\"> <span class=\"number\">6.</span> keyValue[second] = bookObj[sym];  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">7.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(keyValue));  </span><br><span class=\"line\"><span class=\"comment\">// [Symbol(one), Symbol(two)]  </span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"one\": 10, \"two\": 20&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>빈 오브젝트 bookObj에 Symbol(one) 과 Symbol.for(two)로 생성한 Symbol을<br>Symbol-keyed 프로퍼티로 사용하여 프로퍼티 값을 설정해 줬습니다.<br>{Symbol(“one”): 10, Symbol(“two”): 20} 형태가 됩니다.</li>\n</ul>\n<ol>\n<li><p>getOwnPropertySymbols() 파라미터의 bookObj 오브젝트에서 반환받으면<br>[Symbol(one), Symbol(two)]가 출력됩니다. symbolList 변수에 할당합니다.</p>\n</li>\n<li><p>for-of 문으로 symbolList를 반복하면 배열의 순서대로 sym 변수에 할당됩니다.</p>\n</li>\n<li><p>Symbol.keyFor(sym)을 실행하면 글로벌 Symbol 레지스트리에 등록한 Symbol 키를 반환받습니다.<br>따라서 Symbol(one)은 undefined를 Symbol.for(two)는 “two”를 반환합니다.</p>\n</li>\n<li><p>Symbol.for(“two”)가 for-of 문의 sym에 설정될때 실행됩니다.<br>bookObj 오브젝트의 sym으로 값을 구하면 20이 반환되며, 글로벌 Symbol 레지스트리에 “two”가 프로퍼티 키로 등록되어 있으므로 {two: 20}형태가 됩니다.<br><del>Symbol.for()로 생성한 Symbol은 프로퍼티 키와 값을 갖고 있으므로 {key: value}형태를 만들수 있습니다.</del></p>\n</li>\n<li><p>Symbol(“one”)이 for-of 문의 sym에 설정될 때 실행됩니다.<br>“one”을 프로퍼티 키로 사용하기 위해 정규 표현식으로 “one”이외의 문자를 빈 문자열로 대체합니다.</p>\n</li>\n<li><p>bookObj 오브젝트에서 Symbol(“one”)으로 생성한 값으로 프로퍼티 값을 구하면 10이 반환되며,<br>second 변수 값이 “one”이므로 {one: 10}형태가 됩니다. for-of문 반복을 완료하면<br>{one: 10, two: 20} 형태가 됩니다.</p>\n</li>\n<li><p>파라미터에 keyValue를 지정하여 JSON.stringify()를 실행하면 {“one”: 10, “two”: 20}으로 변환됩니다.<br>Symbol() 주석을 유일하게 지정하면 {key: value} 형태로 Symbol을 변환할 수 있습니다.<br>Symbol()로 생성한 값을 오브젝트의 프로퍼티 키로 사용하고 이를 서버로 전송하려면 계획적인 접근이 필요합니다.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ul>\n<li>Symbol 메서드<ul>\n<li><a href=\"/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_for\">for(): Symbol 값 저장</a><ul>\n<li>글로벌(전역) Symbol 레지스트리</li>\n<li>Symbol의 대표적 사용 형태 세 가지</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_keyFor\">keyFor(): key 값 변환</a></li>\n<li><a href=\"/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_toString\">toString(): 문자열로 변환</a></li>\n<li><a href=\"/2020/04/09/Symbol%20메서드%20-ECMAScript/#Symbol_valueOf\">valueOf(): Symbol 프리미티브 값</a></li>\n<li><a href=\"/2020/04/09/Symbol%20메서드%20-ECMAScript/#getOwnPropertySymbols\">getOwnPropertySymbols(): Symbol 프로퍼티 반환</a></li>\n<li><a href=\"/2020/04/09/Symbol%20메서드%20-ECMAScript/#JSON_stringify\">JSON.stringify(): JSON 형태로 변환</a><ul>\n<li>주석을 프로퍼티 key 값으로 활용</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"Symbol_for\">for(): Symbol 값 저장</h2>\n\n<p>글로벌 Symbol 레지스트리(registry)에 Symbol 값을 저장합니다.</p>\n<blockquote>\n<p>Symbol.for(key);</p>\n</blockquote>\n<ul>\n<li><p>key<br>String, 필수. 심볼의 키 (심볼의 설명을 위해서도 쓰입니다).</p>\n</li>\n<li><p>반환 값<br>해당 키에 해당하는 심볼이 있다면 반환, 없으면 새로운 심볼을 만들고 반환합니다.</p>\n</li>\n</ul>\n<p><mark>Symbol은 두 개의 스코프에 저장될 수 있습니다.<br>앞에서 다루었던 Symbol()은 Symbol을 생성한 스코프에 Symbol 값이 설정됩니다.</mark></p>\n<p>반면, Symbol.for()은 글로벌 Symbol 레지스트리에 {key: value} 형태로 저장됩니다.<br>파라미터에 지정한 문자열이 key가 되고 생성한 Symbol 값이 value가 됩니다.</p>\n<p><strong>Symbol.for()는 매 호출마다 새로운 심볼을 만들지 않고 현재 레지스트리에 해당 키를 가진 심볼이 있는지 먼저 검사를 합니다. 레지스트리에 key가 있다면 그 심볼(value)을 반환합니다. 만약 key에 해당하는 심볼이 없다면 Symbol.for()는 새로운 전역 심볼을 만들어 반환합니다.</strong></p>\n<p>글로벌 Symbol 레지스트리는 Symbol 값을 공유하기 위한 영역입니다.<br>다른 자바스크립트 프레임워크에서도 공유할 수 있습니다.</p>\n<h3 id=\"글로벌-전역-Symbol-레지스트리\"><a href=\"#글로벌-전역-Symbol-레지스트리\" class=\"headerlink\" title=\"글로벌(전역) Symbol 레지스트리\"></a>글로벌(전역) Symbol 레지스트리</h3><p>글로벌(전역) Symbol 레지스트리는 다음과 같은 가진 기록 구조를 가진 리스트입니다.<br>초기 값은 비어 있습니다.</p>\n<ul>\n<li>[[[key]] 심볼을 구분하기 위해 사용되는 문자열 키</li>\n<li>[[[symbol]] 전역으로 저장되는 심볼</li>\n</ul>\n<h3 id=\"Symbol의-대표적-사용-형태-세-가지\"><a href=\"#Symbol의-대표적-사용-형태-세-가지\" class=\"headerlink\" title=\"Symbol의 대표적 사용 형태 세 가지\"></a>Symbol의 대표적 사용 형태 세 가지</h3><ol>\n<li><p>Symbol() : Symbol 값을 생성하여 스코프 안에서 사용합니다.</p>\n</li>\n<li><p>Symbol.for() : 글로벌 Symbol 레지스트리에 저장되며 전체 프로그램에서 사용합니다.</p>\n</li>\n<li><p>Well-Known Symbol : 빌트인 Symbol 프로퍼티로 오버라이드하여 기능을 추가 및 변경 합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>Symbol.for()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"sports\"</span>)); <span class=\"comment\">//새로운 전역심볼 생성  </span></span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"sports\"</span>));<span class=\"comment\">// 이미 만들어진 심볼을 검색  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"ABC\"</span>) === <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"ABC\"</span>)); <span class=\"comment\">//전역심볼  </span></span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"DEF\"</span>) === <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"DEF\"</span>)); <span class=\"comment\">//지역 심볼  </span></span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Symbol</span>.for(<span class=\"literal\">true</span>)); <span class=\"comment\">// 문자열이 아님  </span></span><br><span class=\"line\"><span class=\"comment\">// Symbol(sports)  </span></span><br><span class=\"line\"><span class=\"comment\">// Symbol(sports)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// true  </span></span><br><span class=\"line\"><span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"comment\">// Symbol(true)</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Symbol 값을 생성하여 글로벌 Symbol 레지스트리에 {key: value} 형태로 저장됩니다.<br>key: 파라미터로 넘겨준값 (“sports”)<br>value: 생성한 Symbol 값 ( Symbol.for(“sports”) )<br>생성한 Symbol을 출력하면 for을 제외하고 Symbol(“sports”)로 출력됩니다.</p>\n</li>\n<li><p>바로 위에서 sports를 글로벌 Symbol 레지스트리에 저장했으므로<br>저장된 sports 키의 value를 검색하여 반환합니다.<br>마찬가지로 for을 제외한 Symbol(“sports”) 형태로 출력됩니다.</p>\n</li>\n<li><p>Symbol 값을 생성하여 “ABC”를 프로퍼티 키로 글로벌 Symbol 레지스트리에 저장합니다.<br>오른쪽 Symbol.for(“ABC”)에서 글로벌 Symbol 레지스트리에 프로퍼티 키 “ABC”를 검색하여<br>생성되있는 Symbol 값을 반환합니다. 왼쪽과 오른쪽 Symbol 값이 같으므로 true가 반환됩니다.</p>\n</li>\n<li><p>Symbol.for()은 글로벌 Symbol 레지스트리에 저장되고<br>Symbol()은 스코프에 저장되면서 둘은 공유되지 않습니다. false가 반환됩니다.</p>\n</li>\n<li><p>파라미터에 true 와 같이 문자열이 아닌 값을 던져주면 문자열로 변환하여 프로퍼티 키로 사용합니다.<br>key: “true”<br>value: Symbol.for(“true”)<br>출력시 Symbol(true)로 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Symbol_keyFor\">keyFor(): key 값 변환</h2>\n\n<p>글로벌 Symbol 레지스트리에서 프로퍼티 키 값을 반환합니다.</p>\n<blockquote>\n<p>Symbol.keyFor(Symbol)</p>\n</blockquote>\n<p>파라미터에 글로벌 Symbol 레지스트리에 저장한 Symbol을 지정합니다.<br>Symbol이 아니면 TypeError가 발생합니다.<br>글로벌 Symbol 레지스트리에 Symbol이 존재하면 프로퍼티 키를 반환합니다.<br>Symbol이 존재하지 않으면 undefinded를 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>keyFor()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> globalSym = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">'foo'</span>); <span class=\"comment\">// 글로벌 Symbol 레지스트리에 Symbol 값을 생성합니다.  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Symbol</span>.keyFor(globalSym)); <span class=\"comment\">// \"foo\"  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> localSym = <span class=\"built_in\">Symbol</span>();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Symbol</span>.keyFor(localSym)); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Symbol()은 글로벌 스코프에서 생성하더라도 글로벌 Symbol 레지스트리에는 등록되지 않습니다.<br>undefined가 반환됩니다.</li>\n</ul>\n<hr>\n<h2 id=\"Symbol_toString\">toString(): 문자열로 변환</h2>\n\n<p>Symbol을 문자열로 변환하여 반환합니다.<br>Symbol 값이 아닌 Symbol 값을 생성한 Symbol() 형태를 문자열로 반환합니다.<br>Well-Known Symbol, 글로벌 Symbol 레지스트리도 변환됩니다.</p>\n<blockquote>\n<p>Symbol.prototype.toString()</p>\n</blockquote>\n<p>생성한 Symbol 값을 문자열에 연결하면 TypeError가 발생하지만, toString으로 변환하여 연결하면 에러가 나지 않고 문자열로 연결됩니다. toString() 메서드가 Symbol.prototype에 연결되어 있으므로 Symbol() 또는 Symbol.for()로 생성한 Symbol을 사용합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>toString()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"123\"</span>).toString());  </span><br><span class=\"line\"><span class=\"comment\">// 1: Symbol(123)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"ABC\"</span>).toString());  </span><br><span class=\"line\"><span class=\"comment\">// 2: Symbol(ABC)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">Symbol</span>.iterator.toString());  </span><br><span class=\"line\"><span class=\"comment\">// 3: Symbol(Symbol.iterator)</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><ol start=\"2\">\n<li>Symbol 값이 아닌 Symbol 값을 생성할 때의 형태를 문자열로 반환합니다.<br>Symbol.for()도 Symbol()과 같지만 출력할 때 for을 제외시킵니다.</li>\n</ol>\n</li>\n<li><p>Well-Known Symbol을 문자열로 반환합니다. Symbol 값을 생성할 때의 형태<br>Symbol.iterator가 Symbol()의 파라미터에 표시됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Symbol_valueOf\">valueOf(): Symbol 프리미티브 값</h2>\n\n<p>valueOf () 메서드는 Symbol 오브젝트의 프리미티브 값을 반환합니다.</p>\n<blockquote>\n<p>Symbol.prototype.valueOf()</p>\n</blockquote>\n<p>모든 빌트인 오브젝트에 valueOf() 메소드가 있으며 프리미티브 값을 반환합니다.<br>예시로 New Number(123)으로 생성한 인스턴스를 valueOf()로 실행하면 123이 반환됩니다.</p>\n<p>Symbol도 빌트인 오브젝트이지만 반환 값 형태가 다릅니다.<br>Symbol(123)으로 생성한 Symbol로 valueOf()를 실행하면 Symbol 값이 반환되지 않고,<br>Symbol 값을 생성할 때의 “Symbol(123)”이 반환됩니다.</p>\n<hr>\n<h2 id=\"getOwnPropertySymbols\">getOwnPropertySymbols(): Symbol 프로퍼티 반환</h2>\n\n<p>getOwnPropertySymbols()는 반환 대상이 Symbol인 Object 오브젝트 메서드 입니다.<br>배열로 반환합니다.</p>\n<blockquote>\n<p>Object.getOwnPropertySymbols()</p>\n</blockquote>\n<ul>\n<li><p>파라미터<br>추출 대상 Object</p>\n</li>\n<li><p>반환<br>지정한 Object 에서 Symbol 이외의 프로퍼티는 반환하지 않고 오직 Symbol만 배열로 반환합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>getOwnPropertySymbols</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bookObj = &#123;<span class=\"attr\">book</span>: <span class=\"number\">123</span>&#125;;  </span><br><span class=\"line\">bookObj[<span class=\"built_in\">Symbol</span>(<span class=\"string\">\"one\"</span>)] = <span class=\"number\">10</span>;  </span><br><span class=\"line\">bookObj[<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"two\"</span>)] = <span class=\"number\">20</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> names = <span class=\"built_in\">Object</span>.getOwnPropertyNames(bookObj);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, names);  </span><br><span class=\"line\"><span class=\"comment\">// 1: [\"book\"]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> symbolList = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(bookObj);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, symbolList);  </span><br><span class=\"line\"><span class=\"comment\">// 2: [Symbol(one), Symbol(two)]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> sym <span class=\"keyword\">of</span> symbolList)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(sym.toString(), bookObj[sym]);  </span><br><span class=\"line\"><span class=\"comment\">// Symbol(one) 10  </span></span><br><span class=\"line\"><span class=\"comment\">// Symbol(two) 20  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> emptyList = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(&#123;&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, emptyList.length);  </span><br><span class=\"line\"><span class=\"comment\">// 5: 0</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>{book:123}으로 Object 오브젝트를 생성하여 bookObj에 할당합니다.<br>Symbol(“one”)으로 Symbol을 생성하고, bookObj 오브젝트의 symbol-keyed 프로퍼티로 사용하여 10을 할당합니다.<br>이때 bookObj 오브젝트는 {book: 123, Symbol(“one”): 10} 형태가 됩니다.<br>글로벌 Symbol 레지스트리에 “two”를 프로퍼티 키로 Symbol 값을 등록하고, bookObj 오브젝트에 symbol-keyed 프로퍼티로 사용하여 20을 할당합니다.<br>이때 bookObj 오브젝트는 {book: 123, Symbol(“one”): 10, Symbol(“two”): 20} 형태가 됩니다.</li>\n</ul>\n<ol>\n<li><p>getOwnPropertyNames() 파라미터에 지정한 bookObj 오브젝트에서 프로퍼티 이름을 배열로 반환합니다.<br>이때 Symbol은 반환되지 않습니다. 즉 [“book”]만 출력됩니다.<br>for-in문으로 전개해도 Symbol은 열거되지 않습니다.</p>\n</li>\n<li><p>getOwnPropertySymbols() 파라미터에 지정한 bookObj 오브젝트에서<br>Symbol-keyed 프로퍼티를 배열로 반환합니다. Symbol이 아닌 프로퍼티는 반환하지 않습니다.<br>[Symbol(one), Symbol(two)]가 반환됩니다.</p>\n</li>\n<li><ol start=\"4\">\n<li>getOwnPropertySymbols()에서 배열로 반환해 줌으로 for-of문으로 전개할 수 있습니다.<br>Symbol이 sym 변수에 설정되어 String으로 변환되어 출력됩니다.</li>\n</ol>\n</li>\n<li><p>getOwnPropertySymbols() 파라미터에 빈 Object 를 지정하면 빈 배열로 반환합니다.<br>length 값이 0 이 됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"JSON_stringify\">JSON.stringify(): JSON 형태로 변환</h2>\n\n<p>자바스크립트 형태를 JSON 형태의 문자열로 변환합니다.</p>\n<blockquote>\n<p>JSON.stringify(value[, replacer[, space]])</p>\n</blockquote>\n<ul>\n<li><p>value<br>JSON 문자열로 변환할 값.</p>\n</li>\n<li><p>replacer 선택적 파라미터<br>문자열화 동작 방식을 변경하는 함수, 혹은 JSON 문자열에 포함될 값 객체의 속성들을 선택하기 위한 화이트리스트(whitelist)로 쓰이는 String 과 Number 객체들의 배열. 이 값이 null 이거나 제공되지 않으면, 객체의 모든 속성들이 JSON 문자열 결과에 포함된다.</p>\n</li>\n<li><p>space 선택적 파라미터<br>가독성을 목적으로 JSON 문자열 출력에 공백을 삽입하는데 사용되는 String 또는 Number 객체.</p>\n<ul>\n<li>Number 라면, 공백으로 사용되는 스페이스(space)의 수를 나타낸다; 이 수가 10 보다 크면 10 으로 제한된다. 1 보다 작은 값은 스페이스가 사용되지 않는 것을 나타낸다.</li>\n<li>String 이라면, 그 문자열(만약 길이가 10 보다 길다면, 첫번째 10 개의 문자)이 공백으로 사용된다. 이 매개 변수가 제공되지 않는다면(또는 null 이면), 공백이 사용되지 않는다.</li>\n</ul>\n</li>\n<li><p>반환 값<br>주어진 값과 대응하는 JSON 문자열.</p>\n</li>\n</ul>\n<p>JSON.stringify()로 자바스크립트 형태의 {key: value}를 JSON 형태의 문자열로 변환하면,<br>Symbol-keyed 프로퍼티로 작성한 Symbol은 변환에서 제외됩니다.<br>Symbol 값을 외부에 노출시키지 않으려는 의도이지만, 에러 역시 나지 않으므로 주의해야 합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>JSON.stringify</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">JSON</span>.stringify(&#123;[<span class=\"built_in\">Symbol</span>(<span class=\"string\">\"one\"</span>)]: <span class=\"string\">\"1\"</span>&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> result);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(&#123;[<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"two\"</span>)]: <span class=\"string\">\"2\"</span>&#125;));  </span><br><span class=\"line\"><span class=\"comment\">// \"&#123; &#125;\"  </span></span><br><span class=\"line\"><span class=\"comment\">// string  </span></span><br><span class=\"line\"><span class=\"comment\">// \"&#123; &#125;\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>위와 같이 Symbol(“one”)으로 생성한 Symbol을 Object 오브젝트의 symbol-keyed 프로퍼티로 사용한 것을<br>JSON.stringify()로 변환하면, Symbol이 변환에서 제외되어 중괄호 {}만 문자열로 반환됩니다.</li>\n</ul>\n<h3 id=\"주석을-프로퍼티-key-값으로-활용\"><a href=\"#주석을-프로퍼티-key-값으로-활용\" class=\"headerlink\" title=\"주석을 프로퍼티 key 값으로 활용\"></a>주석을 프로퍼티 key 값으로 활용</h3><p>Symbol 주석을 프로퍼티 키로 활용하여 JSON.stringify()에서 Symbol이 제외되는 것을 방지하기 위한<br>하나의 코드작성 법입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>JSON.stringify() Symbol 제외 방지</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bookObj = &#123;&#125;;  </span><br><span class=\"line\">bookObj[<span class=\"built_in\">Symbol</span>(<span class=\"string\">\"one\"</span>)] = <span class=\"number\">10</span>;  </span><br><span class=\"line\">bookObj[<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"two\"</span>)] = <span class=\"number\">20</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> symbolList = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(bookObj);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(symbolList);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> first, second, key, keyValue = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> sym <span class=\"keyword\">of</span> symbolList)&#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> key = <span class=\"built_in\">Symbol</span>.keyFor(sym);  </span><br><span class=\"line\"> <span class=\"number\">4.</span> <span class=\"keyword\">if</span> (key)&#123;  </span><br><span class=\"line\"> keyValue[key] = bookObj[sym];  </span><br><span class=\"line\"> &#125; <span class=\"number\">5.</span> <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\"> <span class=\"comment\">//Symbol(one)  </span></span><br><span class=\"line\"> first = <span class=\"regexp\">/^Symbol[(]/</span>[<span class=\"built_in\">Symbol</span>.replace](sym.toString(), <span class=\"string\">\"\"</span>);  </span><br><span class=\"line\"> second = <span class=\"regexp\">/[)]$/</span>[<span class=\"built_in\">Symbol</span>.replace](first, <span class=\"string\">\"\"</span>);  </span><br><span class=\"line\"> <span class=\"number\">6.</span> keyValue[second] = bookObj[sym];  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">7.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(keyValue));  </span><br><span class=\"line\"><span class=\"comment\">// [Symbol(one), Symbol(two)]  </span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"one\": 10, \"two\": 20&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>빈 오브젝트 bookObj에 Symbol(one) 과 Symbol.for(two)로 생성한 Symbol을<br>Symbol-keyed 프로퍼티로 사용하여 프로퍼티 값을 설정해 줬습니다.<br>{Symbol(“one”): 10, Symbol(“two”): 20} 형태가 됩니다.</li>\n</ul>\n<ol>\n<li><p>getOwnPropertySymbols() 파라미터의 bookObj 오브젝트에서 반환받으면<br>[Symbol(one), Symbol(two)]가 출력됩니다. symbolList 변수에 할당합니다.</p>\n</li>\n<li><p>for-of 문으로 symbolList를 반복하면 배열의 순서대로 sym 변수에 할당됩니다.</p>\n</li>\n<li><p>Symbol.keyFor(sym)을 실행하면 글로벌 Symbol 레지스트리에 등록한 Symbol 키를 반환받습니다.<br>따라서 Symbol(one)은 undefined를 Symbol.for(two)는 “two”를 반환합니다.</p>\n</li>\n<li><p>Symbol.for(“two”)가 for-of 문의 sym에 설정될때 실행됩니다.<br>bookObj 오브젝트의 sym으로 값을 구하면 20이 반환되며, 글로벌 Symbol 레지스트리에 “two”가 프로퍼티 키로 등록되어 있으므로 {two: 20}형태가 됩니다.<br><del>Symbol.for()로 생성한 Symbol은 프로퍼티 키와 값을 갖고 있으므로 {key: value}형태를 만들수 있습니다.</del></p>\n</li>\n<li><p>Symbol(“one”)이 for-of 문의 sym에 설정될 때 실행됩니다.<br>“one”을 프로퍼티 키로 사용하기 위해 정규 표현식으로 “one”이외의 문자를 빈 문자열로 대체합니다.</p>\n</li>\n<li><p>bookObj 오브젝트에서 Symbol(“one”)으로 생성한 값으로 프로퍼티 값을 구하면 10이 반환되며,<br>second 변수 값이 “one”이므로 {one: 10}형태가 됩니다. for-of문 반복을 완료하면<br>{one: 10, two: 20} 형태가 됩니다.</p>\n</li>\n<li><p>파라미터에 keyValue를 지정하여 JSON.stringify()를 실행하면 {“one”: 10, “two”: 20}으로 변환됩니다.<br>Symbol() 주석을 유일하게 지정하면 {key: value} 형태로 Symbol을 변환할 수 있습니다.<br>Symbol()로 생성한 값을 오브젝트의 프로퍼티 키로 사용하고 이를 서버로 전송하려면 계획적인 접근이 필요합니다.</p>\n</li>\n</ol>"},{"title":"Template 리터널 -ECMAScript","date":"2020-03-28T22:27:24.000Z","disqusId":"tunas-blog-1","_content":"\n템플릿 리터럴(Template Literal)은 문자열 처리를 위한 템플릿을 제공합니다.\n\n```js 구문\n`string`  \n`string text line 1  \n string text line 2`  \n`string ${expression} string`  \ntag `string ${expression} text`  \n```\n\n<!-- more -->\n\n역따옴표(``) 안에 `AB${표현식}`과 같이 문자열과 표현식을 작성할 수있습니다. \nAB는 문자열 그대로 출력되고 ${표현식}은 표현식을 평가하고 결과를 문자열로출력합니다.\n\n문자열과 표현식의 결과를 연결하여 문자열로 표현하는 것이 템플릿 리터널입니다.\n\n```js \nconsole.log(\"1:\", `123ABC가나다`);  \n  \nconsole.log(\"2:\", '라인 1\\n라인 2');  \nconsole.log(\"3:\", `첫 번째 줄  \n두 번째 줄`);  \n  \nlet one = 1, two = 2;  \nconsole.log(\"4:\", `1 + 2는 ${one + two}이다`);  \n/*  \n1: 123ABC가나다  \n2: 라인 1  \n라인 2  \n3: 첫 번째 줄  \n두 번째 줄  \n4: 1 + 2는 3이다  \n*/ \n```\n\n2.  \\n이 작성된 위치에서 줄을 바꿉니다.\n    \n3.  \\n을 사용하지 않고 에디터에서 줄을 바꾸면 됩니다.  \n    줄 바꿈을 한 다음 앞에 공백을 작성하면 공백이 삽입됩니다.\n    \n4.  “1 + 2는” 그대로 출력되고 ${one + two} 표현식을 평가합니다.  \n    one 변수 값 1이 one 에 할당되고 변수 값 2가 two에 할당되고  \n    one + two 의 값을 계산합니다.  \n    {1 + 2 는 3이다} 가 반환됩니다.\n    \n\n* * *\n\n## tagged Template\n\n템플릿 앞에 tag를 작성한 형태를 태그드(tagged)템플릿 이라고 합니다.\n\n> tag `string ${expression} text`\n\ntag 위치에 호출할 함수 이름을 작성합니다.\n\n함수를 호출하기 전에 템플릿에서 문자열과 표현식을 분리하고 이를 파라미터 값으로 넘겨줍니다. 함수 이름이 작성된 템플릿을 테그드 템플릿이라고 하고 호출되는 함수를 태그 함수라고 합니다.\n\n```js\nlet one = 1, two = 2;  \n2. function tagFunction(text, value) {  \n 3. console.log(\"1:\", text[0]);  \n 4. console.log(\"2:\", value);  \n 5. console.log(\"3:\", text[1]);  \n 6. console.log(\"4:\", typeof text[1]);  \n}  \n1. tagFunction `1+2=${one + two}`;  \n```\n\n1.  템플릿에서 문자열과 표현식을 분리합니다. 1+2는 문자열이고 ${one + two}는 표현식입니다. tagFunction()을 호출하면서 분리된 문자열을 배열로 넘겨줍니다.  \n    표현식은 평가 결과인 3을 넘겨줍니다. 표현식 다음에 문자열이 없으면 빈 문자열을 배열에 추가합니다.\n    \n2.  호출받는 함수 파라미터에 문자열과 표현식 값을 분리하여 작성합니다.  \n    배열로 넘겨 받은 문자열 [“1+2=”,””]가 text에 설정되고 표현식 값인 3이 value에 설정됩니다.\n    \n3.  text의 첫 번째 엘리먼트 값 1+2= 이 출력됩니다.\n    \n4.  value는 표현식 값 3이 출력됩니다.\n    \n5.  text[1]은 빈 문자열(“”)이며 표현식 다음에 문자열이 없을때 엔진이 빈 문자열을 추가 시킨 값입니다.\n    \n6.  text[1]의 type인 string이 출력됩니다.\n    \n\n* * *\n\n호출하는 함수에서 문자열을 배열로 넘겨주므로 태그 함수의 파라미터 이름은 하나만 작성하면 됩니다.  \n표현식 평과 결과 값은 배열이 아닌 개별로 넘겨주므로 이에 맞춰 파라미터 이름을 작성해야 합니다.\n\n```js 다수의 파라미터 형태\nlet one = 1, two = 2;  \nfunction tagFunction(text, plus, minus) {  \n 1. console.log(text[0], plus, text[1]);  \n 2. console.log(minus, text[2], text[3]);  \n}  \ntagFunction `1+2=${one + two}이고 1-2=${one - two}이다`;  \n```\n\n표현식을 분리하여 평가하면 `${one + two}`는 3이고,`${one - two}`는 -1 입니다.  \n따라서 호출 받는 함수의 파라미터 형태가 ([“1+2=”,”이고 1-2=”,이다],3,-1)  \n형태가 됩니다.\n\n*   text에 호출한 함수에서 문자열을 배열로 넘겨준 값이 설정됩니다.\n*   plus에 표현식 값 3이 설정됩니다.\n*   minus에 표현식 값 -1이 설정됩니다.\n\n1.  text에 배열로 넘겨준 값 인덱스0번과 plus에 넘겨준 표현식 값 3  \n    그리고 text에 배열로 넘겨준 값 인덱스1 번이 연결되어 출력됩니다.  \n    1+2= 3 이고 1-2=\n    \n2.  minus에 넘겨준 표현식값 -1 과 text에 배열로 넘겨준 인덱스 2 번과 3번이 연결되어 출력됩니다. text[3]인덱스는 없으므로. undefined값이 출력됩니다.//-1 “이다” undefined\n    \n\n* * *\n\n## String.raw\n\n템플릿의 표현식은 변환하지만 특수 문자와 유니코드는 문자열로 인식합니다.\n\nString.raw를 작성하고 이어서 템플릿 리터럴을 작성합니다.  \n가급적 템플릿을 적용하지 않고 문자열로 표현하려는 경향이 강합니다.\n\n```js\nlet one = 1, two = 2;  \nconsole.log(\"1:\", String.raw`1+2=${one + two}`);  \n  \nconsole.log(\"2:\", `줄 바꿈-1\\n줄 바꿈-2`);  \nconsole.log(\"3:\", String.raw`줄 바꿈-1\\n줄 바꿈-2`);  \n  \nconsole.log(\"4:\", `Unicode \\u0031\\u0032`);  \nconsole.log(\"5:\", String.raw`Unicode \\u0031\\u0032`);  \n/*  \n1: 1+2=3  \n2: 줄 바꿈-1  \n줄 바꿈-2  \n3: 줄 바꿈-1\\n줄 바꿈-2  \n4: Unicode 12  \n5: Unicode u0031\\u0032  \n*/  \n```\n\n1.  템플릿 앞에 String.raw를 작성하면 문자열과 표현식 평가 결과를 연결하여 반환합니다.\n    \n2.  템플릿에 \\n을 작성하면 줄 바꿈을 하는 것과 달리  \n    String.raw 템플릿에 \\n을 작성하면 \\n을 문자열로 출력합니다.\n    \n3.  \\u0031과 같이 템플릿에 유니코드를 작성하면 코드 포인트 값으로 변환하여 사용합니다. 변환값인 12가 출력됩니다.\n    \n4.  String.raw 템플릿에 유니코드를 작성하면 코드 포인트로 변환하지 않고 문자열로 사용합니다. \\u0031\\u0032 가 출력됩니다.\n    \n\n* * *\n\n## String.raw(): 문자열 전개, 조합\n\n첫 번째 파라미터의 raw 프로퍼티 값인 문자열을 문자 하나씩 전개하면서 두 번째 이후의 파라미터를 조합하며 반환합니다.\n\n첫 번째 파라미터에 {raw: “문자열”}형태로 작성합니다.  \nraw가 아닌 다른 이름을 사용할 수 없습니다.  \n두 번째 파라미터에 {raw: “문자열”}에 “문자열”과 조합할 값을 작성합니다.  \nString.raw()를 템플릿의 태그 함수로 사용합니다.\n\n```js\nlet one = 1, two = 2;  \nlet result = String.raw({raw: \"ABCDE\"}, one, two, 3);  \nconsole.log(result);  \n// A1B2C3DE  \n```\n\n1.  String.raw() 의 두 번째 파라미터인 one 변수에 1이 할당됩니다.\n2.  String.raw() 의 세 번째 파라미터인 two 변수에 2가 할당됩니다.\n\n3.  {raw: “ABCDE”}에서 A를 반환할 버퍼에 추가합니다. //A\n4.  String.raw() 의 두 번째 파라미터 one 변수 값 1을 반환 버퍼 끝에 추가합니다. //A1\n\n5.  {raw: “ABCDE”}에서 B를 반환 버퍼 끝에 추가합니다. //A1B\n6.  String.raw() 의 세 번째 파라미터 two 변수 값 2을 반환 버퍼 끝에 추가합니다. // A1B2\n\n7.  {raw: “ABCDE”}에서 C를 반환 버퍼 끝에 추가합니다. //A1B2C\n8.  String.raw() 의 네 번째 파라미터 값 3을 반환 버퍼 끝에 추가합니다. //A1B2C3\n\n9.  {raw: “ABCDE”}에서 D를 반환 버퍼 끝에 추가합니다. //A1B2C3D\n10.  String.raw() 의 다섯 번째 파라미터가 없으므로 추가하지 않습니다.\n\n11.  {raw: “ABCDE”}에서 E를 반환 버퍼 끝에 추가합니다. // A1B2C3DE\n12.  String.raw() 의 여섯 번째 파라미터가 없으므로 추가하지 않습니다.\n\n13.  반환 버퍼를 반환합니다. // A1B2C3DE\n","source":"_posts/Template 리터널 -ECMAScript.md","raw":"---\ntitle: Template 리터널 -ECMAScript\ndate: 2020-03-29 07:27:24\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n템플릿 리터럴(Template Literal)은 문자열 처리를 위한 템플릿을 제공합니다.\n\n```js 구문\n`string`  \n`string text line 1  \n string text line 2`  \n`string ${expression} string`  \ntag `string ${expression} text`  \n```\n\n<!-- more -->\n\n역따옴표(``) 안에 `AB${표현식}`과 같이 문자열과 표현식을 작성할 수있습니다. \nAB는 문자열 그대로 출력되고 ${표현식}은 표현식을 평가하고 결과를 문자열로출력합니다.\n\n문자열과 표현식의 결과를 연결하여 문자열로 표현하는 것이 템플릿 리터널입니다.\n\n```js \nconsole.log(\"1:\", `123ABC가나다`);  \n  \nconsole.log(\"2:\", '라인 1\\n라인 2');  \nconsole.log(\"3:\", `첫 번째 줄  \n두 번째 줄`);  \n  \nlet one = 1, two = 2;  \nconsole.log(\"4:\", `1 + 2는 ${one + two}이다`);  \n/*  \n1: 123ABC가나다  \n2: 라인 1  \n라인 2  \n3: 첫 번째 줄  \n두 번째 줄  \n4: 1 + 2는 3이다  \n*/ \n```\n\n2.  \\n이 작성된 위치에서 줄을 바꿉니다.\n    \n3.  \\n을 사용하지 않고 에디터에서 줄을 바꾸면 됩니다.  \n    줄 바꿈을 한 다음 앞에 공백을 작성하면 공백이 삽입됩니다.\n    \n4.  “1 + 2는” 그대로 출력되고 ${one + two} 표현식을 평가합니다.  \n    one 변수 값 1이 one 에 할당되고 변수 값 2가 two에 할당되고  \n    one + two 의 값을 계산합니다.  \n    {1 + 2 는 3이다} 가 반환됩니다.\n    \n\n* * *\n\n## tagged Template\n\n템플릿 앞에 tag를 작성한 형태를 태그드(tagged)템플릿 이라고 합니다.\n\n> tag `string ${expression} text`\n\ntag 위치에 호출할 함수 이름을 작성합니다.\n\n함수를 호출하기 전에 템플릿에서 문자열과 표현식을 분리하고 이를 파라미터 값으로 넘겨줍니다. 함수 이름이 작성된 템플릿을 테그드 템플릿이라고 하고 호출되는 함수를 태그 함수라고 합니다.\n\n```js\nlet one = 1, two = 2;  \n2. function tagFunction(text, value) {  \n 3. console.log(\"1:\", text[0]);  \n 4. console.log(\"2:\", value);  \n 5. console.log(\"3:\", text[1]);  \n 6. console.log(\"4:\", typeof text[1]);  \n}  \n1. tagFunction `1+2=${one + two}`;  \n```\n\n1.  템플릿에서 문자열과 표현식을 분리합니다. 1+2는 문자열이고 ${one + two}는 표현식입니다. tagFunction()을 호출하면서 분리된 문자열을 배열로 넘겨줍니다.  \n    표현식은 평가 결과인 3을 넘겨줍니다. 표현식 다음에 문자열이 없으면 빈 문자열을 배열에 추가합니다.\n    \n2.  호출받는 함수 파라미터에 문자열과 표현식 값을 분리하여 작성합니다.  \n    배열로 넘겨 받은 문자열 [“1+2=”,””]가 text에 설정되고 표현식 값인 3이 value에 설정됩니다.\n    \n3.  text의 첫 번째 엘리먼트 값 1+2= 이 출력됩니다.\n    \n4.  value는 표현식 값 3이 출력됩니다.\n    \n5.  text[1]은 빈 문자열(“”)이며 표현식 다음에 문자열이 없을때 엔진이 빈 문자열을 추가 시킨 값입니다.\n    \n6.  text[1]의 type인 string이 출력됩니다.\n    \n\n* * *\n\n호출하는 함수에서 문자열을 배열로 넘겨주므로 태그 함수의 파라미터 이름은 하나만 작성하면 됩니다.  \n표현식 평과 결과 값은 배열이 아닌 개별로 넘겨주므로 이에 맞춰 파라미터 이름을 작성해야 합니다.\n\n```js 다수의 파라미터 형태\nlet one = 1, two = 2;  \nfunction tagFunction(text, plus, minus) {  \n 1. console.log(text[0], plus, text[1]);  \n 2. console.log(minus, text[2], text[3]);  \n}  \ntagFunction `1+2=${one + two}이고 1-2=${one - two}이다`;  \n```\n\n표현식을 분리하여 평가하면 `${one + two}`는 3이고,`${one - two}`는 -1 입니다.  \n따라서 호출 받는 함수의 파라미터 형태가 ([“1+2=”,”이고 1-2=”,이다],3,-1)  \n형태가 됩니다.\n\n*   text에 호출한 함수에서 문자열을 배열로 넘겨준 값이 설정됩니다.\n*   plus에 표현식 값 3이 설정됩니다.\n*   minus에 표현식 값 -1이 설정됩니다.\n\n1.  text에 배열로 넘겨준 값 인덱스0번과 plus에 넘겨준 표현식 값 3  \n    그리고 text에 배열로 넘겨준 값 인덱스1 번이 연결되어 출력됩니다.  \n    1+2= 3 이고 1-2=\n    \n2.  minus에 넘겨준 표현식값 -1 과 text에 배열로 넘겨준 인덱스 2 번과 3번이 연결되어 출력됩니다. text[3]인덱스는 없으므로. undefined값이 출력됩니다.//-1 “이다” undefined\n    \n\n* * *\n\n## String.raw\n\n템플릿의 표현식은 변환하지만 특수 문자와 유니코드는 문자열로 인식합니다.\n\nString.raw를 작성하고 이어서 템플릿 리터럴을 작성합니다.  \n가급적 템플릿을 적용하지 않고 문자열로 표현하려는 경향이 강합니다.\n\n```js\nlet one = 1, two = 2;  \nconsole.log(\"1:\", String.raw`1+2=${one + two}`);  \n  \nconsole.log(\"2:\", `줄 바꿈-1\\n줄 바꿈-2`);  \nconsole.log(\"3:\", String.raw`줄 바꿈-1\\n줄 바꿈-2`);  \n  \nconsole.log(\"4:\", `Unicode \\u0031\\u0032`);  \nconsole.log(\"5:\", String.raw`Unicode \\u0031\\u0032`);  \n/*  \n1: 1+2=3  \n2: 줄 바꿈-1  \n줄 바꿈-2  \n3: 줄 바꿈-1\\n줄 바꿈-2  \n4: Unicode 12  \n5: Unicode u0031\\u0032  \n*/  \n```\n\n1.  템플릿 앞에 String.raw를 작성하면 문자열과 표현식 평가 결과를 연결하여 반환합니다.\n    \n2.  템플릿에 \\n을 작성하면 줄 바꿈을 하는 것과 달리  \n    String.raw 템플릿에 \\n을 작성하면 \\n을 문자열로 출력합니다.\n    \n3.  \\u0031과 같이 템플릿에 유니코드를 작성하면 코드 포인트 값으로 변환하여 사용합니다. 변환값인 12가 출력됩니다.\n    \n4.  String.raw 템플릿에 유니코드를 작성하면 코드 포인트로 변환하지 않고 문자열로 사용합니다. \\u0031\\u0032 가 출력됩니다.\n    \n\n* * *\n\n## String.raw(): 문자열 전개, 조합\n\n첫 번째 파라미터의 raw 프로퍼티 값인 문자열을 문자 하나씩 전개하면서 두 번째 이후의 파라미터를 조합하며 반환합니다.\n\n첫 번째 파라미터에 {raw: “문자열”}형태로 작성합니다.  \nraw가 아닌 다른 이름을 사용할 수 없습니다.  \n두 번째 파라미터에 {raw: “문자열”}에 “문자열”과 조합할 값을 작성합니다.  \nString.raw()를 템플릿의 태그 함수로 사용합니다.\n\n```js\nlet one = 1, two = 2;  \nlet result = String.raw({raw: \"ABCDE\"}, one, two, 3);  \nconsole.log(result);  \n// A1B2C3DE  \n```\n\n1.  String.raw() 의 두 번째 파라미터인 one 변수에 1이 할당됩니다.\n2.  String.raw() 의 세 번째 파라미터인 two 변수에 2가 할당됩니다.\n\n3.  {raw: “ABCDE”}에서 A를 반환할 버퍼에 추가합니다. //A\n4.  String.raw() 의 두 번째 파라미터 one 변수 값 1을 반환 버퍼 끝에 추가합니다. //A1\n\n5.  {raw: “ABCDE”}에서 B를 반환 버퍼 끝에 추가합니다. //A1B\n6.  String.raw() 의 세 번째 파라미터 two 변수 값 2을 반환 버퍼 끝에 추가합니다. // A1B2\n\n7.  {raw: “ABCDE”}에서 C를 반환 버퍼 끝에 추가합니다. //A1B2C\n8.  String.raw() 의 네 번째 파라미터 값 3을 반환 버퍼 끝에 추가합니다. //A1B2C3\n\n9.  {raw: “ABCDE”}에서 D를 반환 버퍼 끝에 추가합니다. //A1B2C3D\n10.  String.raw() 의 다섯 번째 파라미터가 없으므로 추가하지 않습니다.\n\n11.  {raw: “ABCDE”}에서 E를 반환 버퍼 끝에 추가합니다. // A1B2C3DE\n12.  String.raw() 의 여섯 번째 파라미터가 없으므로 추가하지 않습니다.\n\n13.  반환 버퍼를 반환합니다. // A1B2C3DE\n","slug":"Template 리터널 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrsx001wqgvq8gighnno","content":"<p>템플릿 리터럴(Template Literal)은 문자열 처리를 위한 템플릿을 제공합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>구문</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`string`</span>  </span><br><span class=\"line\"><span class=\"string\">`string text line 1  </span></span><br><span class=\"line\"><span class=\"string\"> string text line 2`</span>  </span><br><span class=\"line\"><span class=\"string\">`string <span class=\"subst\">$&#123;expression&#125;</span> string`</span>  </span><br><span class=\"line\">tag <span class=\"string\">`string <span class=\"subst\">$&#123;expression&#125;</span> text`</span></span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<p>역따옴표(``) 안에 <code>AB${표현식}</code>과 같이 문자열과 표현식을 작성할 수있습니다.<br>AB는 문자열 그대로 출력되고 ${표현식}은 표현식을 평가하고 결과를 문자열로출력합니다.</p>\n<p>문자열과 표현식의 결과를 연결하여 문자열로 표현하는 것이 템플릿 리터널입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"string\">`123ABC가나다`</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"string\">'라인 1\\n라인 2'</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"string\">`첫 번째 줄  </span></span><br><span class=\"line\"><span class=\"string\">두 번째 줄`</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"number\">1</span>, two = <span class=\"number\">2</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"string\">`1 + 2는 <span class=\"subst\">$&#123;one + two&#125;</span>이다`</span>);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">1: 123ABC가나다  </span></span><br><span class=\"line\"><span class=\"comment\">2: 라인 1  </span></span><br><span class=\"line\"><span class=\"comment\">라인 2  </span></span><br><span class=\"line\"><span class=\"comment\">3: 첫 번째 줄  </span></span><br><span class=\"line\"><span class=\"comment\">두 번째 줄  </span></span><br><span class=\"line\"><span class=\"comment\">4: 1 + 2는 3이다  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>\\n이 작성된 위치에서 줄을 바꿉니다.</p>\n</li>\n<li><p>\\n을 사용하지 않고 에디터에서 줄을 바꾸면 됩니다.<br>줄 바꿈을 한 다음 앞에 공백을 작성하면 공백이 삽입됩니다.</p>\n</li>\n<li><p>“1 + 2는” 그대로 출력되고 ${one + two} 표현식을 평가합니다.<br>one 변수 값 1이 one 에 할당되고 변수 값 2가 two에 할당되고<br>one + two 의 값을 계산합니다.<br>{1 + 2 는 3이다} 가 반환됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"tagged-Template\"><a href=\"#tagged-Template\" class=\"headerlink\" title=\"tagged Template\"></a>tagged Template</h2><p>템플릿 앞에 tag를 작성한 형태를 태그드(tagged)템플릿 이라고 합니다.</p>\n<blockquote>\n<p>tag <code>string ${expression} text</code></p>\n</blockquote>\n<p>tag 위치에 호출할 함수 이름을 작성합니다.</p>\n<p>함수를 호출하기 전에 템플릿에서 문자열과 표현식을 분리하고 이를 파라미터 값으로 넘겨줍니다. 함수 이름이 작성된 템플릿을 테그드 템플릿이라고 하고 호출되는 함수를 태그 함수라고 합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"number\">1</span>, two = <span class=\"number\">2</span>;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tagFunction</span>(<span class=\"params\">text, value</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, text[<span class=\"number\">0</span>]);  </span><br><span class=\"line\"> <span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, value);  </span><br><span class=\"line\"> <span class=\"number\">5.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, text[<span class=\"number\">1</span>]);  </span><br><span class=\"line\"> <span class=\"number\">6.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"keyword\">typeof</span> text[<span class=\"number\">1</span>]);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">1.</span> tagFunction <span class=\"string\">`1+2=<span class=\"subst\">$&#123;one + two&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>템플릿에서 문자열과 표현식을 분리합니다. 1+2는 문자열이고 ${one + two}는 표현식입니다. tagFunction()을 호출하면서 분리된 문자열을 배열로 넘겨줍니다.<br>표현식은 평가 결과인 3을 넘겨줍니다. 표현식 다음에 문자열이 없으면 빈 문자열을 배열에 추가합니다.</p>\n</li>\n<li><p>호출받는 함수 파라미터에 문자열과 표현식 값을 분리하여 작성합니다.<br>배열로 넘겨 받은 문자열 [“1+2=”,””]가 text에 설정되고 표현식 값인 3이 value에 설정됩니다.</p>\n</li>\n<li><p>text의 첫 번째 엘리먼트 값 1+2= 이 출력됩니다.</p>\n</li>\n<li><p>value는 표현식 값 3이 출력됩니다.</p>\n</li>\n<li><p>text[1]은 빈 문자열(“”)이며 표현식 다음에 문자열이 없을때 엔진이 빈 문자열을 추가 시킨 값입니다.</p>\n</li>\n<li><p>text[1]의 type인 string이 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<p>호출하는 함수에서 문자열을 배열로 넘겨주므로 태그 함수의 파라미터 이름은 하나만 작성하면 됩니다.<br>표현식 평과 결과 값은 배열이 아닌 개별로 넘겨주므로 이에 맞춰 파라미터 이름을 작성해야 합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>다수의 파라미터 형태</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"number\">1</span>, two = <span class=\"number\">2</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tagFunction</span>(<span class=\"params\">text, plus, minus</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(text[<span class=\"number\">0</span>], plus, text[<span class=\"number\">1</span>]);  </span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(minus, text[<span class=\"number\">2</span>], text[<span class=\"number\">3</span>]);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">tagFunction <span class=\"string\">`1+2=<span class=\"subst\">$&#123;one + two&#125;</span>이고 1-2=<span class=\"subst\">$&#123;one - two&#125;</span>이다`</span>;</span><br></pre></td></tr></table></figure>\n\n<p>표현식을 분리하여 평가하면 <code>${one + two}</code>는 3이고,<code>${one - two}</code>는 -1 입니다.<br>따라서 호출 받는 함수의 파라미터 형태가 ([“1+2=”,”이고 1-2=”,이다],3,-1)<br>형태가 됩니다.</p>\n<ul>\n<li>text에 호출한 함수에서 문자열을 배열로 넘겨준 값이 설정됩니다.</li>\n<li>plus에 표현식 값 3이 설정됩니다.</li>\n<li>minus에 표현식 값 -1이 설정됩니다.</li>\n</ul>\n<ol>\n<li><p>text에 배열로 넘겨준 값 인덱스0번과 plus에 넘겨준 표현식 값 3<br>그리고 text에 배열로 넘겨준 값 인덱스1 번이 연결되어 출력됩니다.<br>1+2= 3 이고 1-2=</p>\n</li>\n<li><p>minus에 넘겨준 표현식값 -1 과 text에 배열로 넘겨준 인덱스 2 번과 3번이 연결되어 출력됩니다. text[3]인덱스는 없으므로. undefined값이 출력됩니다.//-1 “이다” undefined</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"String-raw\"><a href=\"#String-raw\" class=\"headerlink\" title=\"String.raw\"></a>String.raw</h2><p>템플릿의 표현식은 변환하지만 특수 문자와 유니코드는 문자열로 인식합니다.</p>\n<p>String.raw를 작성하고 이어서 템플릿 리터럴을 작성합니다.<br>가급적 템플릿을 적용하지 않고 문자열로 표현하려는 경향이 강합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"number\">1</span>, two = <span class=\"number\">2</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"built_in\">String</span>.raw<span class=\"string\">`1+2=<span class=\"subst\">$&#123;one + two&#125;</span>`</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"string\">`줄 바꿈-1\\n줄 바꿈-2`</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">String</span>.raw<span class=\"string\">`줄 바꿈-1\\n줄 바꿈-2`</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"string\">`Unicode \\u0031\\u0032`</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, <span class=\"built_in\">String</span>.raw<span class=\"string\">`Unicode \\u0031\\u0032`</span>);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">1: 1+2=3  </span></span><br><span class=\"line\"><span class=\"comment\">2: 줄 바꿈-1  </span></span><br><span class=\"line\"><span class=\"comment\">줄 바꿈-2  </span></span><br><span class=\"line\"><span class=\"comment\">3: 줄 바꿈-1\\n줄 바꿈-2  </span></span><br><span class=\"line\"><span class=\"comment\">4: Unicode 12  </span></span><br><span class=\"line\"><span class=\"comment\">5: Unicode u0031\\u0032  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>템플릿 앞에 String.raw를 작성하면 문자열과 표현식 평가 결과를 연결하여 반환합니다.</p>\n</li>\n<li><p>템플릿에 \\n을 작성하면 줄 바꿈을 하는 것과 달리<br>String.raw 템플릿에 \\n을 작성하면 \\n을 문자열로 출력합니다.</p>\n</li>\n<li><p>\\u0031과 같이 템플릿에 유니코드를 작성하면 코드 포인트 값으로 변환하여 사용합니다. 변환값인 12가 출력됩니다.</p>\n</li>\n<li><p>String.raw 템플릿에 유니코드를 작성하면 코드 포인트로 변환하지 않고 문자열로 사용합니다. \\u0031\\u0032 가 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"String-raw-문자열-전개-조합\"><a href=\"#String-raw-문자열-전개-조합\" class=\"headerlink\" title=\"String.raw(): 문자열 전개, 조합\"></a>String.raw(): 문자열 전개, 조합</h2><p>첫 번째 파라미터의 raw 프로퍼티 값인 문자열을 문자 하나씩 전개하면서 두 번째 이후의 파라미터를 조합하며 반환합니다.</p>\n<p>첫 번째 파라미터에 {raw: “문자열”}형태로 작성합니다.<br>raw가 아닌 다른 이름을 사용할 수 없습니다.<br>두 번째 파라미터에 {raw: “문자열”}에 “문자열”과 조합할 값을 작성합니다.<br>String.raw()를 템플릿의 태그 함수로 사용합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"number\">1</span>, two = <span class=\"number\">2</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">String</span>.raw(&#123;<span class=\"attr\">raw</span>: <span class=\"string\">\"ABCDE\"</span>&#125;, one, two, <span class=\"number\">3</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\"><span class=\"comment\">// A1B2C3DE</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>String.raw() 의 두 번째 파라미터인 one 변수에 1이 할당됩니다.</p>\n</li>\n<li><p>String.raw() 의 세 번째 파라미터인 two 변수에 2가 할당됩니다.</p>\n</li>\n<li><p>{raw: “ABCDE”}에서 A를 반환할 버퍼에 추가합니다. //A</p>\n</li>\n<li><p>String.raw() 의 두 번째 파라미터 one 변수 값 1을 반환 버퍼 끝에 추가합니다. //A1</p>\n</li>\n<li><p>{raw: “ABCDE”}에서 B를 반환 버퍼 끝에 추가합니다. //A1B</p>\n</li>\n<li><p>String.raw() 의 세 번째 파라미터 two 변수 값 2을 반환 버퍼 끝에 추가합니다. // A1B2</p>\n</li>\n<li><p>{raw: “ABCDE”}에서 C를 반환 버퍼 끝에 추가합니다. //A1B2C</p>\n</li>\n<li><p>String.raw() 의 네 번째 파라미터 값 3을 반환 버퍼 끝에 추가합니다. //A1B2C3</p>\n</li>\n<li><p>{raw: “ABCDE”}에서 D를 반환 버퍼 끝에 추가합니다. //A1B2C3D</p>\n</li>\n<li><p>String.raw() 의 다섯 번째 파라미터가 없으므로 추가하지 않습니다.</p>\n</li>\n<li><p>{raw: “ABCDE”}에서 E를 반환 버퍼 끝에 추가합니다. // A1B2C3DE</p>\n</li>\n<li><p>String.raw() 의 여섯 번째 파라미터가 없으므로 추가하지 않습니다.</p>\n</li>\n<li><p>반환 버퍼를 반환합니다. // A1B2C3DE</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>템플릿 리터럴(Template Literal)은 문자열 처리를 위한 템플릿을 제공합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>구문</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`string`</span>  </span><br><span class=\"line\"><span class=\"string\">`string text line 1  </span></span><br><span class=\"line\"><span class=\"string\"> string text line 2`</span>  </span><br><span class=\"line\"><span class=\"string\">`string <span class=\"subst\">$&#123;expression&#125;</span> string`</span>  </span><br><span class=\"line\">tag <span class=\"string\">`string <span class=\"subst\">$&#123;expression&#125;</span> text`</span></span><br></pre></td></tr></table></figure>","more":"<p>역따옴표(``) 안에 <code>AB${표현식}</code>과 같이 문자열과 표현식을 작성할 수있습니다.<br>AB는 문자열 그대로 출력되고 ${표현식}은 표현식을 평가하고 결과를 문자열로출력합니다.</p>\n<p>문자열과 표현식의 결과를 연결하여 문자열로 표현하는 것이 템플릿 리터널입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"string\">`123ABC가나다`</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"string\">'라인 1\\n라인 2'</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"string\">`첫 번째 줄  </span></span><br><span class=\"line\"><span class=\"string\">두 번째 줄`</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"number\">1</span>, two = <span class=\"number\">2</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"string\">`1 + 2는 <span class=\"subst\">$&#123;one + two&#125;</span>이다`</span>);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">1: 123ABC가나다  </span></span><br><span class=\"line\"><span class=\"comment\">2: 라인 1  </span></span><br><span class=\"line\"><span class=\"comment\">라인 2  </span></span><br><span class=\"line\"><span class=\"comment\">3: 첫 번째 줄  </span></span><br><span class=\"line\"><span class=\"comment\">두 번째 줄  </span></span><br><span class=\"line\"><span class=\"comment\">4: 1 + 2는 3이다  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>\\n이 작성된 위치에서 줄을 바꿉니다.</p>\n</li>\n<li><p>\\n을 사용하지 않고 에디터에서 줄을 바꾸면 됩니다.<br>줄 바꿈을 한 다음 앞에 공백을 작성하면 공백이 삽입됩니다.</p>\n</li>\n<li><p>“1 + 2는” 그대로 출력되고 ${one + two} 표현식을 평가합니다.<br>one 변수 값 1이 one 에 할당되고 변수 값 2가 two에 할당되고<br>one + two 의 값을 계산합니다.<br>{1 + 2 는 3이다} 가 반환됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"tagged-Template\"><a href=\"#tagged-Template\" class=\"headerlink\" title=\"tagged Template\"></a>tagged Template</h2><p>템플릿 앞에 tag를 작성한 형태를 태그드(tagged)템플릿 이라고 합니다.</p>\n<blockquote>\n<p>tag <code>string ${expression} text</code></p>\n</blockquote>\n<p>tag 위치에 호출할 함수 이름을 작성합니다.</p>\n<p>함수를 호출하기 전에 템플릿에서 문자열과 표현식을 분리하고 이를 파라미터 값으로 넘겨줍니다. 함수 이름이 작성된 템플릿을 테그드 템플릿이라고 하고 호출되는 함수를 태그 함수라고 합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"number\">1</span>, two = <span class=\"number\">2</span>;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tagFunction</span>(<span class=\"params\">text, value</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, text[<span class=\"number\">0</span>]);  </span><br><span class=\"line\"> <span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, value);  </span><br><span class=\"line\"> <span class=\"number\">5.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, text[<span class=\"number\">1</span>]);  </span><br><span class=\"line\"> <span class=\"number\">6.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"keyword\">typeof</span> text[<span class=\"number\">1</span>]);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">1.</span> tagFunction <span class=\"string\">`1+2=<span class=\"subst\">$&#123;one + two&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>템플릿에서 문자열과 표현식을 분리합니다. 1+2는 문자열이고 ${one + two}는 표현식입니다. tagFunction()을 호출하면서 분리된 문자열을 배열로 넘겨줍니다.<br>표현식은 평가 결과인 3을 넘겨줍니다. 표현식 다음에 문자열이 없으면 빈 문자열을 배열에 추가합니다.</p>\n</li>\n<li><p>호출받는 함수 파라미터에 문자열과 표현식 값을 분리하여 작성합니다.<br>배열로 넘겨 받은 문자열 [“1+2=”,””]가 text에 설정되고 표현식 값인 3이 value에 설정됩니다.</p>\n</li>\n<li><p>text의 첫 번째 엘리먼트 값 1+2= 이 출력됩니다.</p>\n</li>\n<li><p>value는 표현식 값 3이 출력됩니다.</p>\n</li>\n<li><p>text[1]은 빈 문자열(“”)이며 표현식 다음에 문자열이 없을때 엔진이 빈 문자열을 추가 시킨 값입니다.</p>\n</li>\n<li><p>text[1]의 type인 string이 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<p>호출하는 함수에서 문자열을 배열로 넘겨주므로 태그 함수의 파라미터 이름은 하나만 작성하면 됩니다.<br>표현식 평과 결과 값은 배열이 아닌 개별로 넘겨주므로 이에 맞춰 파라미터 이름을 작성해야 합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>다수의 파라미터 형태</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"number\">1</span>, two = <span class=\"number\">2</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tagFunction</span>(<span class=\"params\">text, plus, minus</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(text[<span class=\"number\">0</span>], plus, text[<span class=\"number\">1</span>]);  </span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(minus, text[<span class=\"number\">2</span>], text[<span class=\"number\">3</span>]);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">tagFunction <span class=\"string\">`1+2=<span class=\"subst\">$&#123;one + two&#125;</span>이고 1-2=<span class=\"subst\">$&#123;one - two&#125;</span>이다`</span>;</span><br></pre></td></tr></table></figure>\n\n<p>표현식을 분리하여 평가하면 <code>${one + two}</code>는 3이고,<code>${one - two}</code>는 -1 입니다.<br>따라서 호출 받는 함수의 파라미터 형태가 ([“1+2=”,”이고 1-2=”,이다],3,-1)<br>형태가 됩니다.</p>\n<ul>\n<li>text에 호출한 함수에서 문자열을 배열로 넘겨준 값이 설정됩니다.</li>\n<li>plus에 표현식 값 3이 설정됩니다.</li>\n<li>minus에 표현식 값 -1이 설정됩니다.</li>\n</ul>\n<ol>\n<li><p>text에 배열로 넘겨준 값 인덱스0번과 plus에 넘겨준 표현식 값 3<br>그리고 text에 배열로 넘겨준 값 인덱스1 번이 연결되어 출력됩니다.<br>1+2= 3 이고 1-2=</p>\n</li>\n<li><p>minus에 넘겨준 표현식값 -1 과 text에 배열로 넘겨준 인덱스 2 번과 3번이 연결되어 출력됩니다. text[3]인덱스는 없으므로. undefined값이 출력됩니다.//-1 “이다” undefined</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"String-raw\"><a href=\"#String-raw\" class=\"headerlink\" title=\"String.raw\"></a>String.raw</h2><p>템플릿의 표현식은 변환하지만 특수 문자와 유니코드는 문자열로 인식합니다.</p>\n<p>String.raw를 작성하고 이어서 템플릿 리터럴을 작성합니다.<br>가급적 템플릿을 적용하지 않고 문자열로 표현하려는 경향이 강합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"number\">1</span>, two = <span class=\"number\">2</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"built_in\">String</span>.raw<span class=\"string\">`1+2=<span class=\"subst\">$&#123;one + two&#125;</span>`</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"string\">`줄 바꿈-1\\n줄 바꿈-2`</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">String</span>.raw<span class=\"string\">`줄 바꿈-1\\n줄 바꿈-2`</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, <span class=\"string\">`Unicode \\u0031\\u0032`</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, <span class=\"built_in\">String</span>.raw<span class=\"string\">`Unicode \\u0031\\u0032`</span>);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">1: 1+2=3  </span></span><br><span class=\"line\"><span class=\"comment\">2: 줄 바꿈-1  </span></span><br><span class=\"line\"><span class=\"comment\">줄 바꿈-2  </span></span><br><span class=\"line\"><span class=\"comment\">3: 줄 바꿈-1\\n줄 바꿈-2  </span></span><br><span class=\"line\"><span class=\"comment\">4: Unicode 12  </span></span><br><span class=\"line\"><span class=\"comment\">5: Unicode u0031\\u0032  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>템플릿 앞에 String.raw를 작성하면 문자열과 표현식 평가 결과를 연결하여 반환합니다.</p>\n</li>\n<li><p>템플릿에 \\n을 작성하면 줄 바꿈을 하는 것과 달리<br>String.raw 템플릿에 \\n을 작성하면 \\n을 문자열로 출력합니다.</p>\n</li>\n<li><p>\\u0031과 같이 템플릿에 유니코드를 작성하면 코드 포인트 값으로 변환하여 사용합니다. 변환값인 12가 출력됩니다.</p>\n</li>\n<li><p>String.raw 템플릿에 유니코드를 작성하면 코드 포인트로 변환하지 않고 문자열로 사용합니다. \\u0031\\u0032 가 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"String-raw-문자열-전개-조합\"><a href=\"#String-raw-문자열-전개-조합\" class=\"headerlink\" title=\"String.raw(): 문자열 전개, 조합\"></a>String.raw(): 문자열 전개, 조합</h2><p>첫 번째 파라미터의 raw 프로퍼티 값인 문자열을 문자 하나씩 전개하면서 두 번째 이후의 파라미터를 조합하며 반환합니다.</p>\n<p>첫 번째 파라미터에 {raw: “문자열”}형태로 작성합니다.<br>raw가 아닌 다른 이름을 사용할 수 없습니다.<br>두 번째 파라미터에 {raw: “문자열”}에 “문자열”과 조합할 값을 작성합니다.<br>String.raw()를 템플릿의 태그 함수로 사용합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"number\">1</span>, two = <span class=\"number\">2</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">String</span>.raw(&#123;<span class=\"attr\">raw</span>: <span class=\"string\">\"ABCDE\"</span>&#125;, one, two, <span class=\"number\">3</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\"><span class=\"comment\">// A1B2C3DE</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>String.raw() 의 두 번째 파라미터인 one 변수에 1이 할당됩니다.</p>\n</li>\n<li><p>String.raw() 의 세 번째 파라미터인 two 변수에 2가 할당됩니다.</p>\n</li>\n<li><p>{raw: “ABCDE”}에서 A를 반환할 버퍼에 추가합니다. //A</p>\n</li>\n<li><p>String.raw() 의 두 번째 파라미터 one 변수 값 1을 반환 버퍼 끝에 추가합니다. //A1</p>\n</li>\n<li><p>{raw: “ABCDE”}에서 B를 반환 버퍼 끝에 추가합니다. //A1B</p>\n</li>\n<li><p>String.raw() 의 세 번째 파라미터 two 변수 값 2을 반환 버퍼 끝에 추가합니다. // A1B2</p>\n</li>\n<li><p>{raw: “ABCDE”}에서 C를 반환 버퍼 끝에 추가합니다. //A1B2C</p>\n</li>\n<li><p>String.raw() 의 네 번째 파라미터 값 3을 반환 버퍼 끝에 추가합니다. //A1B2C3</p>\n</li>\n<li><p>{raw: “ABCDE”}에서 D를 반환 버퍼 끝에 추가합니다. //A1B2C3D</p>\n</li>\n<li><p>String.raw() 의 다섯 번째 파라미터가 없으므로 추가하지 않습니다.</p>\n</li>\n<li><p>{raw: “ABCDE”}에서 E를 반환 버퍼 끝에 추가합니다. // A1B2C3DE</p>\n</li>\n<li><p>String.raw() 의 여섯 번째 파라미터가 없으므로 추가하지 않습니다.</p>\n</li>\n<li><p>반환 버퍼를 반환합니다. // A1B2C3DE</p>\n</li>\n</ol>"},{"title":"Symbol 오브젝트 -ECMAScript","date":"2020-04-06T01:35:07.000Z","disqusId":"tunas-blog-1","_content":"\n*   Symbol Object\n    *   [primitive](/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#primitive)\n    *   [Symbol()](/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_값_생성)\n    *   [Symbol 값 변경](/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_값_변경)\n    *   [Symbol 오브젝트 생성](/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_Object)\n    *   [오브젝트에서 Symbol 사용](/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Object_Symbol)\n    *   [Symbol 사용 형태](/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_ex)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"primitive\">primitive</h2>\n\n자바스크립트에 프리미티브(primitive) 개념이 있습니다. 이는 오브젝트가 아닌 값 입니다.  \nES5에 string, number, boolean, null, undefined가 있으며  \nES6에 Symbol이 추가되었습니다.\n\n(var num = 123;)을 실행하면 num에 123이 할당됩니다.  \n123은 number 타입의 프리미티브 값입니다.\n\nstring, number, boolean 은 래퍼(Wrapper) 오브젝트가 있습니다.  \n각각 String, Number, Boolean 오브젝트가 래퍼 오브젝트 입니다.  \nES6에서 symbol의 Symbol 오브젝트가 추가되었습니다.  \nundefined, null은 래퍼 오브젝트가 없습니다.\n\n**valueOf()로 래퍼 오브젝트의 프리미티브 값을 구할 수 있습니다.**  \n**단, Symbol은 값을 반환하지 않습니다.**\n\n* * *\n\n<h2 id=\"Symbol_값_생성\">Symbol()</h2>\n\n> let sym = Symbol();\n\n형태로 작성하며 Symbol 값을 생성하여 sym에 할당합니다.\n\nnew 연산자는 사용할 수 없습니다.\n\n**Symbol()로 생성된 값은 프로그램 전체를 통해 유일하며 값을 변경할 수 없습니다.**\n\n생성한 Symbol에 프로퍼티를 설정할 수 없으며 strict mode에서 TypeError가 발생합니다.\n\nSymbol()로 반환된 값이 오브젝트가 아니므로 오브젝트를 생성한다고 할 수 없습니다.  \nSymbol을 생성한다는 것은 뉘앙스에 차이가 있습니다. Symbol 값을 생성한다는 표현이 적절합니다.\n\nSymbol은 String””, Array[], Object{}, Boolean(true/false)와 같이 오브젝트를  \n생성하는 리터럴이 없습니다. undefined, null과 같이 그 자체가 값이 되는 것도 아닙니다.\n\nSymbol()과 같이 함수로 호출해야 값을 생성하며 반환합니다.\n\n```js\nconst sym = Symbol();  \nconsole.log(\"1:\", sym);  \nconsole.log(\"2:\", typeof sym);  \nconsole.log(\"3:\", Symbol(\"주석\"));  \n  \nconsole.log(\"4:\", sym == Symbol());  \n// 1: Symbol()  \n// 2: symbol  \n// 3: Symbol(주석)  \n// 4: false  \n```\n\n*   Symbol()을 호출하면 Symbol 값을 생성하여 반환합니다.  \n    생성한 값은 변경할 수 없으므로 const 변수에 할당해도 됩니다.\n\n1.  Symbol()로 값을 생성했는데 값이 출력되지 않고 실행 결과 Symbol()이 출력됩니다.  \n    Symbol 값을 구하면 Symbol()로 생성한 값을 반환하지 않고,  \n    **Symbol값을 생성했던 형태를 반환합니다. 브라우저 개발자 도구에서도 값을 볼 수 없습니다.**  \n    **이것이 Symbol의 특징입니다.**\n\n2.  Symbol()로 생성한 값의 typeof는 symbol 입니다.\n\n3.  Symbol()의 파라미터는 선택사항으로 Symbol()로 생성한 값의 설명이나 주석을 문자열로 작성합니다. Symbol 값을 생성하는데 영향을 미치지 않습니다. Symbol 값을 외부에 제공하지 않으므로 디버깅할 때 유용합니다.  \n    파라미터를 작성하지 않으면 undefined로 인식합니다. Symbol(“주석”)형태로 반환됩니다.\n\n4.  <mark>앞에서 Symbol()로 생성한 값(sym)과 다시 Symbol()로 생성한 값을 비교하면  \n    false가 반환됩니다.Symbol()을 실행할 때마다 프로그램 전체를 통해 유일한 값을  \n    생성하므로 값이 같을 수 없습니다. 이것이 Symbol의 특징입니다.</mark>\n\n* * *\n\n<h2 id=\"Symbol_값_변경\">Symbol 값 변경</h2>\n\nSymbol()로 생성한 Symbol 값을 변경할 수 없습니다. Symbol 값에 문자열을 연결할 수 있으나  \nString() 또는 toString()을 사용해야 합니다. 이 형태는 Symbol 값이 연결되는 것은 아니며  \nSymbol 값을 생성할 때의 형태를 연결합니다.\n\nSymbol 값을 템플릿에 사용할 수 없고, + 연산자로 문자열을 연결하면 에러가 발생합니다.\n\n```js Symbol +연산자, or연산자 사용불가\nlet sym = Symbol();  \ntry {  \n +sym;  \n} catch (e) {  \n console.log(\"+sym 사용 불가\");  \n};  \n  \ntry {  \n sym | 0;  \n} catch (e) {  \n console.log(\"sym | 0 사용 불가\");  \n};  \n// +sym 사용 불가  \n// sym | 사용 불가  \n```\n\n*   단항 + 연산자를 사용하여 Number 타입으로 변환하면 에러가 발생합니다.  \n    Symbol과 비트 or 연산자를 함께 사용하면 에러가 발생합니다.\n\n```js Symbol 문자열 연결\nlet sym = Symbol();  \ntry {  \n sym + \"문자열\";  \n} catch (e) {  \n 1. console.log(\"문자열 연결 불가\");  \n};  \n  \n2. console.log(String(sym) + \"연결\");  \n3. console.log(sym.toString() + \"연결\");  \n// 문자열 연결 불가  \n// Symbol() 연결  \n// Symbol() 연결  \n```\n\n1.  Symbol()로 생성한 값에 + 연산자로 문자열을 연결하면 에러가 발생합니다.\n\n2.  String(sym) 으로 Symbol을 문자열로 변환하면 문자열을 연결할 수 있습니다.  \n    Symbol 값이 문자열로 연결되지는 않고 Symbol 값을 생성한 형태인  \n    “Symbol()”이 연결됩니다. “Symbol() 연결”이 출력됩니다.\n\n3.  toString()으로 Symbol()을 문자열로 변환하면 문자열을 연결할 수 있습니다.  \n    String()과 마찬가지로 Symbol()을 생성한 형태가 문자열에 연결됩니다.\n\n```js Symbol 템블릿\nlet sym =Symbol(\"123\");  \ntry {  \n `${sym}`;  \n} catch (e) {  \n console.log(\"`${sym} 불가`\");  \n}  \n// `${sym} 불가`  \n```\n\n**템블릿에서 Symbol 값을 사용하면 에러가 발생합니다.**  \nSymbol 값이 템플릿에 반영되면 문자열 값으로 변환되어 외부에 노출되기 때문입니다.  \n(Symbol 값을 생성한 형태도 반영되지 않습니다. Symbol 값을 외부에 노출시키지 않는 것이 Symbol의 특징입니다.)\n\n* * *\n\n<h2 id=\"Symbol_Object\">Symbol 오브젝트 생성</h2>\n\nObject()에 Object(123)처럼 파라미터 값 123을 작성하면 Number 오브젝트를 반환합니다.  \n마찬가지로 Object()의 파라미터에 Symbol 값일 작성하면 Symbol 오브젝트를 반환합니다.\n\n*   Symbol 오브젝트에\n    *   Symbol 메서드,\n    *   Symbol.prototype,\n    *   prototype에 연결된 프로퍼티가 설정됩니다.\n\n```js Symbol Object\n1. let sym = Symbol(\"123\");  \nconst obj = Object(sym);  \nconsole.log(obj);  \n  \n2. console.log(obj == sym);  \nconsole.log(obj === sym);  \n  \n/* Symbol  \ndescription: (...)  \n>__proto__: Symbol  \n[[PrimitiveValue]]: Symbol(123)  \n*/  \n  \n// true  \n// false  \n```\n\n1.  Symbol(“123”)으로 Symbol 값을 생성하고 이를 Object(sym) 파라미터에 지정합니다.  \n    Symbol 오브젝트를 생성하여 반환하게 됩니다. 다음은 생성한 Symbol 오브젝트 구성 입니다.\n    <img src=\"/images/SymbolObj.JPG\">\n    \n    1.  Symbol.prototype에 연결된 프로퍼티가 &#95;&#95;proto&#95;&#95;에 첨부됩니다.  \n        이를 통해 Symbol.prototype의 메서드와 프로퍼티를 확인할 수 있습니다.\n        \n    2.  [[PrimitiveValue]]에 Symbol 값을 생성한 형태인 Symbol(“123”)이 설정됩니다.  \n        ~~Symbol 값이 설정되지 않고 값을 생성한 형태가 설정됩니다.~~ \n        &#95;&#95;proto&#95;&#95;에 있는 valueOf()로 [[PrimitiveValue]]에 설정된 값을 반환받을 수 있습니다.\n        \n\n2.  Symbol(“123”)으로 생성한 값 sym 과 Object()의 파라미터에 지정하여 생성한 obj를 비교하면 true를 반환합니다. === 연산자로 타입까지 비교하면 false를 반환합니다. 값은 [[PrimitiveValue]] 값으로 비교하여 true를 반환하지만 타입은 Symbol 과 Object 의 타입이 비교되기 때문입니다.\n\n* * *\n\n<h2 id=\"Object_Symbol\">오브젝트에서 Symbol 사용</h2>\n\n프로그램에서 유일한 값을 갖은 Symbol의 특징을 이용하여  \nSymbol 값을 오브젝트의 프로퍼티 키로 사용하면 프로퍼티 키가 중복되지 않습니다.\n\n*   [Symbol()]  \n    형태와 같이 대괄호[] 안에 Symbol()을 작성합니다.\n    \n*   { [Symbol()]: 123}  \n    프로퍼티 키에 작성한 Symbol()을 symbol-keyed property라고 합니다.  \n    Symbol 값은 문자열이 아니며 값이기 때문에 []안에 {“Symbol”} 형태로 작성하지 않고  \n    {Symbol} 형태로 작성합니다. 이 형태를 symbol-keyed property 라고 하는 것입니다.\n\n```js\nlet sym = Symbol(\"123\");  \nlet obj = {[sym]: \"456\"};  \n// Symbol(\"123\")을 변수에 할당하고 []안에 변수 이름을 작성하여  \n// Object 의 프로퍼티 키로 사용  \nconsole.log(obj);  \n  \n// 프로퍼티 키에 해당하는 값 출력  \nconsole.log(obj[sym]);  \nconsole.log(obj.sym);  \n// 대괄호[]를 사용하지 않고 작성하면 에러가 발생하지 않고  \n// undefined가 반환됨.  \n  \n/* Object  \nSymbol(123): \"456\"  \n>__proto__: Object  \n*/  \n  \n// 456  \n// undefined  \n```\n\n* * *\n\n<h2 id=\"Symbol_ex\">Symbol 사용 형태</h2>\n\nfon-in 문에서 symbol-keyed 프로퍼티가 열거되지 않습니다.  \n**Symbol 이 [[ Enumberable]]: false 이기 때문입니다.**\n\nSymbol-keyed 프로퍼티를 열거 하려면 Object.getOwnPropertySymbols()를 사용해야 합니다.\n\n### 클래스 메서드 이름으로 Symbol 사용\n\n```js method-name\nconst symbolOne = Symbol(\"symbol one\");  \nconst symbolTwo = Symbol(\"symbol two\");  \n  \nclass Sports {  \n 1. static [symbolOne]() {  \n return \"Symbol-1\";  \n }  \n 2. [symbolTwo](){  \n return \"Symbol-2\";  \n }  \n}  \n3. console.log(Sports[symbolOne]());  \n  \n4. let obj = new Sports();  \nconsole.log(obj[symbolTwo]());  \n// Symbol-1  \n// Symbol-2  \n```\n\n1.  Symbol(“symbol one”)으로 생성한 값을 static 메서드 이름으로 사용한 형태입니다.  \n    대괄호 []안에 Symbol 값을 할당한 변수 이름을 작성하고 이어서 소괄호()를 작성합니다.\n\n2.  Symbol(“symbol two”)로 생성한 값을 메서드 이름으로 사용한 형태입니다.  \n    static 키워드를 작성하지 않았으므로 Sports.prototype에 symbolTwo{}가 연결됩니다.\n\n3.  symbolOne은 static 메서드 입니다. 클래스 이름에 이어 대괄호[]안에 메서드 이름을 작성하고 소괄호()를 작성하면 메서드가 호출됩니다.\n\n4.  symbolTwo{}가 Sports.prototype에 연결되어 있으므로 호출하기 위해 인스턴스를 생성합니다. 인스턴스에 이어 대괄호[]안에 메서드 이름을 작성하고 소괄호()를 작성하면 메서드로 호출됩니다.\n\n### JSON.stringify()에서 Symbol 사용\n\nJSON.stringify()는 Object 오브젝트의 프로퍼티를 {“key”: “value”}형태로 변환합니다.  \nkey는 문자열로 변환되고 value는 타입에 따라 문자열로 변환되지 않을 수도 있습니다.  \n클라이언트에서 서버로 데이터를 JSON형태로 전송할 때 사용합니다.\n\nSymbol 값은 외부에 노출되지 않도록 조치 되어 있기 때문에 {[sym]: “값”}과 같이  \nSymbol 값을 프로퍼티로 작성하여 JSON.stringify()를 실행하면 프로퍼티 키와 프로퍼티 값이  \n문자열로 변환되지 않고 빈 Object {}가 반환됩니다.\n\n<mark>이를 위한 대처방법으로 Object.getOwnPropertySymbols()를 사용하는 방법이 있습니다.</mark>\n","source":"_posts/Symbol 오브젝트 -ECMAScript.md","raw":"---\ntitle: Symbol 오브젝트 -ECMAScript\ndate: 2020-04-06 10:35:07\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n*   Symbol Object\n    *   [primitive](/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#primitive)\n    *   [Symbol()](/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_값_생성)\n    *   [Symbol 값 변경](/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_값_변경)\n    *   [Symbol 오브젝트 생성](/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_Object)\n    *   [오브젝트에서 Symbol 사용](/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Object_Symbol)\n    *   [Symbol 사용 형태](/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_ex)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"primitive\">primitive</h2>\n\n자바스크립트에 프리미티브(primitive) 개념이 있습니다. 이는 오브젝트가 아닌 값 입니다.  \nES5에 string, number, boolean, null, undefined가 있으며  \nES6에 Symbol이 추가되었습니다.\n\n(var num = 123;)을 실행하면 num에 123이 할당됩니다.  \n123은 number 타입의 프리미티브 값입니다.\n\nstring, number, boolean 은 래퍼(Wrapper) 오브젝트가 있습니다.  \n각각 String, Number, Boolean 오브젝트가 래퍼 오브젝트 입니다.  \nES6에서 symbol의 Symbol 오브젝트가 추가되었습니다.  \nundefined, null은 래퍼 오브젝트가 없습니다.\n\n**valueOf()로 래퍼 오브젝트의 프리미티브 값을 구할 수 있습니다.**  \n**단, Symbol은 값을 반환하지 않습니다.**\n\n* * *\n\n<h2 id=\"Symbol_값_생성\">Symbol()</h2>\n\n> let sym = Symbol();\n\n형태로 작성하며 Symbol 값을 생성하여 sym에 할당합니다.\n\nnew 연산자는 사용할 수 없습니다.\n\n**Symbol()로 생성된 값은 프로그램 전체를 통해 유일하며 값을 변경할 수 없습니다.**\n\n생성한 Symbol에 프로퍼티를 설정할 수 없으며 strict mode에서 TypeError가 발생합니다.\n\nSymbol()로 반환된 값이 오브젝트가 아니므로 오브젝트를 생성한다고 할 수 없습니다.  \nSymbol을 생성한다는 것은 뉘앙스에 차이가 있습니다. Symbol 값을 생성한다는 표현이 적절합니다.\n\nSymbol은 String””, Array[], Object{}, Boolean(true/false)와 같이 오브젝트를  \n생성하는 리터럴이 없습니다. undefined, null과 같이 그 자체가 값이 되는 것도 아닙니다.\n\nSymbol()과 같이 함수로 호출해야 값을 생성하며 반환합니다.\n\n```js\nconst sym = Symbol();  \nconsole.log(\"1:\", sym);  \nconsole.log(\"2:\", typeof sym);  \nconsole.log(\"3:\", Symbol(\"주석\"));  \n  \nconsole.log(\"4:\", sym == Symbol());  \n// 1: Symbol()  \n// 2: symbol  \n// 3: Symbol(주석)  \n// 4: false  \n```\n\n*   Symbol()을 호출하면 Symbol 값을 생성하여 반환합니다.  \n    생성한 값은 변경할 수 없으므로 const 변수에 할당해도 됩니다.\n\n1.  Symbol()로 값을 생성했는데 값이 출력되지 않고 실행 결과 Symbol()이 출력됩니다.  \n    Symbol 값을 구하면 Symbol()로 생성한 값을 반환하지 않고,  \n    **Symbol값을 생성했던 형태를 반환합니다. 브라우저 개발자 도구에서도 값을 볼 수 없습니다.**  \n    **이것이 Symbol의 특징입니다.**\n\n2.  Symbol()로 생성한 값의 typeof는 symbol 입니다.\n\n3.  Symbol()의 파라미터는 선택사항으로 Symbol()로 생성한 값의 설명이나 주석을 문자열로 작성합니다. Symbol 값을 생성하는데 영향을 미치지 않습니다. Symbol 값을 외부에 제공하지 않으므로 디버깅할 때 유용합니다.  \n    파라미터를 작성하지 않으면 undefined로 인식합니다. Symbol(“주석”)형태로 반환됩니다.\n\n4.  <mark>앞에서 Symbol()로 생성한 값(sym)과 다시 Symbol()로 생성한 값을 비교하면  \n    false가 반환됩니다.Symbol()을 실행할 때마다 프로그램 전체를 통해 유일한 값을  \n    생성하므로 값이 같을 수 없습니다. 이것이 Symbol의 특징입니다.</mark>\n\n* * *\n\n<h2 id=\"Symbol_값_변경\">Symbol 값 변경</h2>\n\nSymbol()로 생성한 Symbol 값을 변경할 수 없습니다. Symbol 값에 문자열을 연결할 수 있으나  \nString() 또는 toString()을 사용해야 합니다. 이 형태는 Symbol 값이 연결되는 것은 아니며  \nSymbol 값을 생성할 때의 형태를 연결합니다.\n\nSymbol 값을 템플릿에 사용할 수 없고, + 연산자로 문자열을 연결하면 에러가 발생합니다.\n\n```js Symbol +연산자, or연산자 사용불가\nlet sym = Symbol();  \ntry {  \n +sym;  \n} catch (e) {  \n console.log(\"+sym 사용 불가\");  \n};  \n  \ntry {  \n sym | 0;  \n} catch (e) {  \n console.log(\"sym | 0 사용 불가\");  \n};  \n// +sym 사용 불가  \n// sym | 사용 불가  \n```\n\n*   단항 + 연산자를 사용하여 Number 타입으로 변환하면 에러가 발생합니다.  \n    Symbol과 비트 or 연산자를 함께 사용하면 에러가 발생합니다.\n\n```js Symbol 문자열 연결\nlet sym = Symbol();  \ntry {  \n sym + \"문자열\";  \n} catch (e) {  \n 1. console.log(\"문자열 연결 불가\");  \n};  \n  \n2. console.log(String(sym) + \"연결\");  \n3. console.log(sym.toString() + \"연결\");  \n// 문자열 연결 불가  \n// Symbol() 연결  \n// Symbol() 연결  \n```\n\n1.  Symbol()로 생성한 값에 + 연산자로 문자열을 연결하면 에러가 발생합니다.\n\n2.  String(sym) 으로 Symbol을 문자열로 변환하면 문자열을 연결할 수 있습니다.  \n    Symbol 값이 문자열로 연결되지는 않고 Symbol 값을 생성한 형태인  \n    “Symbol()”이 연결됩니다. “Symbol() 연결”이 출력됩니다.\n\n3.  toString()으로 Symbol()을 문자열로 변환하면 문자열을 연결할 수 있습니다.  \n    String()과 마찬가지로 Symbol()을 생성한 형태가 문자열에 연결됩니다.\n\n```js Symbol 템블릿\nlet sym =Symbol(\"123\");  \ntry {  \n `${sym}`;  \n} catch (e) {  \n console.log(\"`${sym} 불가`\");  \n}  \n// `${sym} 불가`  \n```\n\n**템블릿에서 Symbol 값을 사용하면 에러가 발생합니다.**  \nSymbol 값이 템플릿에 반영되면 문자열 값으로 변환되어 외부에 노출되기 때문입니다.  \n(Symbol 값을 생성한 형태도 반영되지 않습니다. Symbol 값을 외부에 노출시키지 않는 것이 Symbol의 특징입니다.)\n\n* * *\n\n<h2 id=\"Symbol_Object\">Symbol 오브젝트 생성</h2>\n\nObject()에 Object(123)처럼 파라미터 값 123을 작성하면 Number 오브젝트를 반환합니다.  \n마찬가지로 Object()의 파라미터에 Symbol 값일 작성하면 Symbol 오브젝트를 반환합니다.\n\n*   Symbol 오브젝트에\n    *   Symbol 메서드,\n    *   Symbol.prototype,\n    *   prototype에 연결된 프로퍼티가 설정됩니다.\n\n```js Symbol Object\n1. let sym = Symbol(\"123\");  \nconst obj = Object(sym);  \nconsole.log(obj);  \n  \n2. console.log(obj == sym);  \nconsole.log(obj === sym);  \n  \n/* Symbol  \ndescription: (...)  \n>__proto__: Symbol  \n[[PrimitiveValue]]: Symbol(123)  \n*/  \n  \n// true  \n// false  \n```\n\n1.  Symbol(“123”)으로 Symbol 값을 생성하고 이를 Object(sym) 파라미터에 지정합니다.  \n    Symbol 오브젝트를 생성하여 반환하게 됩니다. 다음은 생성한 Symbol 오브젝트 구성 입니다.\n    <img src=\"/images/SymbolObj.JPG\">\n    \n    1.  Symbol.prototype에 연결된 프로퍼티가 &#95;&#95;proto&#95;&#95;에 첨부됩니다.  \n        이를 통해 Symbol.prototype의 메서드와 프로퍼티를 확인할 수 있습니다.\n        \n    2.  [[PrimitiveValue]]에 Symbol 값을 생성한 형태인 Symbol(“123”)이 설정됩니다.  \n        ~~Symbol 값이 설정되지 않고 값을 생성한 형태가 설정됩니다.~~ \n        &#95;&#95;proto&#95;&#95;에 있는 valueOf()로 [[PrimitiveValue]]에 설정된 값을 반환받을 수 있습니다.\n        \n\n2.  Symbol(“123”)으로 생성한 값 sym 과 Object()의 파라미터에 지정하여 생성한 obj를 비교하면 true를 반환합니다. === 연산자로 타입까지 비교하면 false를 반환합니다. 값은 [[PrimitiveValue]] 값으로 비교하여 true를 반환하지만 타입은 Symbol 과 Object 의 타입이 비교되기 때문입니다.\n\n* * *\n\n<h2 id=\"Object_Symbol\">오브젝트에서 Symbol 사용</h2>\n\n프로그램에서 유일한 값을 갖은 Symbol의 특징을 이용하여  \nSymbol 값을 오브젝트의 프로퍼티 키로 사용하면 프로퍼티 키가 중복되지 않습니다.\n\n*   [Symbol()]  \n    형태와 같이 대괄호[] 안에 Symbol()을 작성합니다.\n    \n*   { [Symbol()]: 123}  \n    프로퍼티 키에 작성한 Symbol()을 symbol-keyed property라고 합니다.  \n    Symbol 값은 문자열이 아니며 값이기 때문에 []안에 {“Symbol”} 형태로 작성하지 않고  \n    {Symbol} 형태로 작성합니다. 이 형태를 symbol-keyed property 라고 하는 것입니다.\n\n```js\nlet sym = Symbol(\"123\");  \nlet obj = {[sym]: \"456\"};  \n// Symbol(\"123\")을 변수에 할당하고 []안에 변수 이름을 작성하여  \n// Object 의 프로퍼티 키로 사용  \nconsole.log(obj);  \n  \n// 프로퍼티 키에 해당하는 값 출력  \nconsole.log(obj[sym]);  \nconsole.log(obj.sym);  \n// 대괄호[]를 사용하지 않고 작성하면 에러가 발생하지 않고  \n// undefined가 반환됨.  \n  \n/* Object  \nSymbol(123): \"456\"  \n>__proto__: Object  \n*/  \n  \n// 456  \n// undefined  \n```\n\n* * *\n\n<h2 id=\"Symbol_ex\">Symbol 사용 형태</h2>\n\nfon-in 문에서 symbol-keyed 프로퍼티가 열거되지 않습니다.  \n**Symbol 이 [[ Enumberable]]: false 이기 때문입니다.**\n\nSymbol-keyed 프로퍼티를 열거 하려면 Object.getOwnPropertySymbols()를 사용해야 합니다.\n\n### 클래스 메서드 이름으로 Symbol 사용\n\n```js method-name\nconst symbolOne = Symbol(\"symbol one\");  \nconst symbolTwo = Symbol(\"symbol two\");  \n  \nclass Sports {  \n 1. static [symbolOne]() {  \n return \"Symbol-1\";  \n }  \n 2. [symbolTwo](){  \n return \"Symbol-2\";  \n }  \n}  \n3. console.log(Sports[symbolOne]());  \n  \n4. let obj = new Sports();  \nconsole.log(obj[symbolTwo]());  \n// Symbol-1  \n// Symbol-2  \n```\n\n1.  Symbol(“symbol one”)으로 생성한 값을 static 메서드 이름으로 사용한 형태입니다.  \n    대괄호 []안에 Symbol 값을 할당한 변수 이름을 작성하고 이어서 소괄호()를 작성합니다.\n\n2.  Symbol(“symbol two”)로 생성한 값을 메서드 이름으로 사용한 형태입니다.  \n    static 키워드를 작성하지 않았으므로 Sports.prototype에 symbolTwo{}가 연결됩니다.\n\n3.  symbolOne은 static 메서드 입니다. 클래스 이름에 이어 대괄호[]안에 메서드 이름을 작성하고 소괄호()를 작성하면 메서드가 호출됩니다.\n\n4.  symbolTwo{}가 Sports.prototype에 연결되어 있으므로 호출하기 위해 인스턴스를 생성합니다. 인스턴스에 이어 대괄호[]안에 메서드 이름을 작성하고 소괄호()를 작성하면 메서드로 호출됩니다.\n\n### JSON.stringify()에서 Symbol 사용\n\nJSON.stringify()는 Object 오브젝트의 프로퍼티를 {“key”: “value”}형태로 변환합니다.  \nkey는 문자열로 변환되고 value는 타입에 따라 문자열로 변환되지 않을 수도 있습니다.  \n클라이언트에서 서버로 데이터를 JSON형태로 전송할 때 사용합니다.\n\nSymbol 값은 외부에 노출되지 않도록 조치 되어 있기 때문에 {[sym]: “값”}과 같이  \nSymbol 값을 프로퍼티로 작성하여 JSON.stringify()를 실행하면 프로퍼티 키와 프로퍼티 값이  \n문자열로 변환되지 않고 빈 Object {}가 반환됩니다.\n\n<mark>이를 위한 대처방법으로 Object.getOwnPropertySymbols()를 사용하는 방법이 있습니다.</mark>\n","slug":"Symbol 오브젝트 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrsx001zqgvq7w4rbhvy","content":"<ul>\n<li>Symbol Object<ul>\n<li><a href=\"/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#primitive\">primitive</a></li>\n<li><a href=\"/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_값_생성\">Symbol()</a></li>\n<li><a href=\"/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_값_변경\">Symbol 값 변경</a></li>\n<li><a href=\"/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_Object\">Symbol 오브젝트 생성</a></li>\n<li><a href=\"/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Object_Symbol\">오브젝트에서 Symbol 사용</a></li>\n<li><a href=\"/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_ex\">Symbol 사용 형태</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"primitive\">primitive</h2>\n\n<p>자바스크립트에 프리미티브(primitive) 개념이 있습니다. 이는 오브젝트가 아닌 값 입니다.<br>ES5에 string, number, boolean, null, undefined가 있으며<br>ES6에 Symbol이 추가되었습니다.</p>\n<p>(var num = 123;)을 실행하면 num에 123이 할당됩니다.<br>123은 number 타입의 프리미티브 값입니다.</p>\n<p>string, number, boolean 은 래퍼(Wrapper) 오브젝트가 있습니다.<br>각각 String, Number, Boolean 오브젝트가 래퍼 오브젝트 입니다.<br>ES6에서 symbol의 Symbol 오브젝트가 추가되었습니다.<br>undefined, null은 래퍼 오브젝트가 없습니다.</p>\n<p><strong>valueOf()로 래퍼 오브젝트의 프리미티브 값을 구할 수 있습니다.</strong><br><strong>단, Symbol은 값을 반환하지 않습니다.</strong></p>\n<hr>\n<h2 id=\"Symbol_값_생성\">Symbol()</h2>\n\n<blockquote>\n<p>let sym = Symbol();</p>\n</blockquote>\n<p>형태로 작성하며 Symbol 값을 생성하여 sym에 할당합니다.</p>\n<p>new 연산자는 사용할 수 없습니다.</p>\n<p><strong>Symbol()로 생성된 값은 프로그램 전체를 통해 유일하며 값을 변경할 수 없습니다.</strong></p>\n<p>생성한 Symbol에 프로퍼티를 설정할 수 없으며 strict mode에서 TypeError가 발생합니다.</p>\n<p>Symbol()로 반환된 값이 오브젝트가 아니므로 오브젝트를 생성한다고 할 수 없습니다.<br>Symbol을 생성한다는 것은 뉘앙스에 차이가 있습니다. Symbol 값을 생성한다는 표현이 적절합니다.</p>\n<p>Symbol은 String””, Array[], Object{}, Boolean(true/false)와 같이 오브젝트를<br>생성하는 리터럴이 없습니다. undefined, null과 같이 그 자체가 값이 되는 것도 아닙니다.</p>\n<p>Symbol()과 같이 함수로 호출해야 값을 생성하며 반환합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sym = <span class=\"built_in\">Symbol</span>();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, sym);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"keyword\">typeof</span> sym);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"주석\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, sym == <span class=\"built_in\">Symbol</span>());  </span><br><span class=\"line\"><span class=\"comment\">// 1: Symbol()  </span></span><br><span class=\"line\"><span class=\"comment\">// 2: symbol  </span></span><br><span class=\"line\"><span class=\"comment\">// 3: Symbol(주석)  </span></span><br><span class=\"line\"><span class=\"comment\">// 4: false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Symbol()을 호출하면 Symbol 값을 생성하여 반환합니다.<br>생성한 값은 변경할 수 없으므로 const 변수에 할당해도 됩니다.</li>\n</ul>\n<ol>\n<li><p>Symbol()로 값을 생성했는데 값이 출력되지 않고 실행 결과 Symbol()이 출력됩니다.<br>Symbol 값을 구하면 Symbol()로 생성한 값을 반환하지 않고,<br><strong>Symbol값을 생성했던 형태를 반환합니다. 브라우저 개발자 도구에서도 값을 볼 수 없습니다.</strong><br><strong>이것이 Symbol의 특징입니다.</strong></p>\n</li>\n<li><p>Symbol()로 생성한 값의 typeof는 symbol 입니다.</p>\n</li>\n<li><p>Symbol()의 파라미터는 선택사항으로 Symbol()로 생성한 값의 설명이나 주석을 문자열로 작성합니다. Symbol 값을 생성하는데 영향을 미치지 않습니다. Symbol 값을 외부에 제공하지 않으므로 디버깅할 때 유용합니다.<br>파라미터를 작성하지 않으면 undefined로 인식합니다. Symbol(“주석”)형태로 반환됩니다.</p>\n</li>\n<li><p><mark>앞에서 Symbol()로 생성한 값(sym)과 다시 Symbol()로 생성한 값을 비교하면<br>false가 반환됩니다.Symbol()을 실행할 때마다 프로그램 전체를 통해 유일한 값을<br>생성하므로 값이 같을 수 없습니다. 이것이 Symbol의 특징입니다.</mark></p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Symbol_값_변경\">Symbol 값 변경</h2>\n\n<p>Symbol()로 생성한 Symbol 값을 변경할 수 없습니다. Symbol 값에 문자열을 연결할 수 있으나<br>String() 또는 toString()을 사용해야 합니다. 이 형태는 Symbol 값이 연결되는 것은 아니며<br>Symbol 값을 생성할 때의 형태를 연결합니다.</p>\n<p>Symbol 값을 템플릿에 사용할 수 없고, + 연산자로 문자열을 연결하면 에러가 발생합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>Symbol +연산자, or연산자 사용불가</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>();  </span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> +sym;  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"+sym 사용 불가\"</span>);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> sym | <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"sym | 0 사용 불가\"</span>);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// +sym 사용 불가  </span></span><br><span class=\"line\"><span class=\"comment\">// sym | 사용 불가</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>단항 + 연산자를 사용하여 Number 타입으로 변환하면 에러가 발생합니다.<br>Symbol과 비트 or 연산자를 함께 사용하면 에러가 발생합니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>Symbol 문자열 연결</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>();  </span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> sym + <span class=\"string\">\"문자열\"</span>;  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"문자열 연결 불가\"</span>);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(sym) + <span class=\"string\">\"연결\"</span>);  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(sym.toString() + <span class=\"string\">\"연결\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 연결 불가  </span></span><br><span class=\"line\"><span class=\"comment\">// Symbol() 연결  </span></span><br><span class=\"line\"><span class=\"comment\">// Symbol() 연결</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Symbol()로 생성한 값에 + 연산자로 문자열을 연결하면 에러가 발생합니다.</p>\n</li>\n<li><p>String(sym) 으로 Symbol을 문자열로 변환하면 문자열을 연결할 수 있습니다.<br>Symbol 값이 문자열로 연결되지는 않고 Symbol 값을 생성한 형태인<br>“Symbol()”이 연결됩니다. “Symbol() 연결”이 출력됩니다.</p>\n</li>\n<li><p>toString()으로 Symbol()을 문자열로 변환하면 문자열을 연결할 수 있습니다.<br>String()과 마찬가지로 Symbol()을 생성한 형태가 문자열에 연결됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>Symbol 템블릿</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym =<span class=\"built_in\">Symbol</span>(<span class=\"string\">\"123\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"string\">`<span class=\"subst\">$&#123;sym&#125;</span>`</span>;  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"`$&#123;sym&#125; 불가`\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// `$&#123;sym&#125; 불가`</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>템블릿에서 Symbol 값을 사용하면 에러가 발생합니다.</strong><br>Symbol 값이 템플릿에 반영되면 문자열 값으로 변환되어 외부에 노출되기 때문입니다.<br>(Symbol 값을 생성한 형태도 반영되지 않습니다. Symbol 값을 외부에 노출시키지 않는 것이 Symbol의 특징입니다.)</p>\n<hr>\n<h2 id=\"Symbol_Object\">Symbol 오브젝트 생성</h2>\n\n<p>Object()에 Object(123)처럼 파라미터 값 123을 작성하면 Number 오브젝트를 반환합니다.<br>마찬가지로 Object()의 파라미터에 Symbol 값일 작성하면 Symbol 오브젝트를 반환합니다.</p>\n<ul>\n<li>Symbol 오브젝트에<ul>\n<li>Symbol 메서드,</li>\n<li>Symbol.prototype,</li>\n<li>prototype에 연결된 프로퍼티가 설정됩니다.</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>Symbol Object</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"123\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>(sym);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(obj == sym);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj === sym);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/* Symbol  </span></span><br><span class=\"line\"><span class=\"comment\">description: (...)  </span></span><br><span class=\"line\"><span class=\"comment\">&gt;__proto__: Symbol  </span></span><br><span class=\"line\"><span class=\"comment\">[[PrimitiveValue]]: Symbol(123)  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// true  </span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Symbol(“123”)으로 Symbol 값을 생성하고 이를 Object(sym) 파라미터에 지정합니다.<br>Symbol 오브젝트를 생성하여 반환하게 됩니다. 다음은 생성한 Symbol 오브젝트 구성 입니다.</p>\n<img src=\"/images/SymbolObj.JPG\">\n\n<ol>\n<li><p>Symbol.prototype에 연결된 프로퍼티가 &#95;&#95;proto&#95;&#95;에 첨부됩니다.<br>이를 통해 Symbol.prototype의 메서드와 프로퍼티를 확인할 수 있습니다.</p>\n</li>\n<li><p>[[PrimitiveValue]]에 Symbol 값을 생성한 형태인 Symbol(“123”)이 설정됩니다.<br><del>Symbol 값이 설정되지 않고 값을 생성한 형태가 설정됩니다.</del><br>&#95;&#95;proto&#95;&#95;에 있는 valueOf()로 [[PrimitiveValue]]에 설정된 값을 반환받을 수 있습니다.</p>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"2\">\n<li>Symbol(“123”)으로 생성한 값 sym 과 Object()의 파라미터에 지정하여 생성한 obj를 비교하면 true를 반환합니다. === 연산자로 타입까지 비교하면 false를 반환합니다. 값은 [[PrimitiveValue]] 값으로 비교하여 true를 반환하지만 타입은 Symbol 과 Object 의 타입이 비교되기 때문입니다.</li>\n</ol>\n<hr>\n<h2 id=\"Object_Symbol\">오브젝트에서 Symbol 사용</h2>\n\n<p>프로그램에서 유일한 값을 갖은 Symbol의 특징을 이용하여<br>Symbol 값을 오브젝트의 프로퍼티 키로 사용하면 프로퍼티 키가 중복되지 않습니다.</p>\n<ul>\n<li><p>[Symbol()]<br>형태와 같이 대괄호[] 안에 Symbol()을 작성합니다.</p>\n</li>\n<li><p>{ [Symbol()]: 123}<br>프로퍼티 키에 작성한 Symbol()을 symbol-keyed property라고 합니다.<br>Symbol 값은 문자열이 아니며 값이기 때문에 []안에 {“Symbol”} 형태로 작성하지 않고<br>{Symbol} 형태로 작성합니다. 이 형태를 symbol-keyed property 라고 하는 것입니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"123\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;[sym]: <span class=\"string\">\"456\"</span>&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// Symbol(\"123\")을 변수에 할당하고 []안에 변수 이름을 작성하여  </span></span><br><span class=\"line\"><span class=\"comment\">// Object 의 프로퍼티 키로 사용  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 프로퍼티 키에 해당하는 값 출력  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj[sym]);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.sym);  </span><br><span class=\"line\"><span class=\"comment\">// 대괄호[]를 사용하지 않고 작성하면 에러가 발생하지 않고  </span></span><br><span class=\"line\"><span class=\"comment\">// undefined가 반환됨.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/* Object  </span></span><br><span class=\"line\"><span class=\"comment\">Symbol(123): \"456\"  </span></span><br><span class=\"line\"><span class=\"comment\">&gt;__proto__: Object  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 456  </span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Symbol_ex\">Symbol 사용 형태</h2>\n\n<p>fon-in 문에서 symbol-keyed 프로퍼티가 열거되지 않습니다.<br><strong>Symbol 이 [[ Enumberable]]: false 이기 때문입니다.</strong></p>\n<p>Symbol-keyed 프로퍼티를 열거 하려면 Object.getOwnPropertySymbols()를 사용해야 합니다.</p>\n<h3 id=\"클래스-메서드-이름으로-Symbol-사용\"><a href=\"#클래스-메서드-이름으로-Symbol-사용\" class=\"headerlink\" title=\"클래스 메서드 이름으로 Symbol 사용\"></a>클래스 메서드 이름으로 Symbol 사용</h3><figure class=\"highlight js\"><figcaption><span>method-name</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> symbolOne = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"symbol one\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> symbolTwo = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"symbol two\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"keyword\">static</span> [symbolOne]() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"Symbol-1\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"number\">2.</span> [symbolTwo]()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"Symbol-2\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(Sports[symbolOne]());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Sports();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj[symbolTwo]());  </span><br><span class=\"line\"><span class=\"comment\">// Symbol-1  </span></span><br><span class=\"line\"><span class=\"comment\">// Symbol-2</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Symbol(“symbol one”)으로 생성한 값을 static 메서드 이름으로 사용한 형태입니다.<br>대괄호 []안에 Symbol 값을 할당한 변수 이름을 작성하고 이어서 소괄호()를 작성합니다.</p>\n</li>\n<li><p>Symbol(“symbol two”)로 생성한 값을 메서드 이름으로 사용한 형태입니다.<br>static 키워드를 작성하지 않았으므로 Sports.prototype에 symbolTwo{}가 연결됩니다.</p>\n</li>\n<li><p>symbolOne은 static 메서드 입니다. 클래스 이름에 이어 대괄호[]안에 메서드 이름을 작성하고 소괄호()를 작성하면 메서드가 호출됩니다.</p>\n</li>\n<li><p>symbolTwo{}가 Sports.prototype에 연결되어 있으므로 호출하기 위해 인스턴스를 생성합니다. 인스턴스에 이어 대괄호[]안에 메서드 이름을 작성하고 소괄호()를 작성하면 메서드로 호출됩니다.</p>\n</li>\n</ol>\n<h3 id=\"JSON-stringify-에서-Symbol-사용\"><a href=\"#JSON-stringify-에서-Symbol-사용\" class=\"headerlink\" title=\"JSON.stringify()에서 Symbol 사용\"></a>JSON.stringify()에서 Symbol 사용</h3><p>JSON.stringify()는 Object 오브젝트의 프로퍼티를 {“key”: “value”}형태로 변환합니다.<br>key는 문자열로 변환되고 value는 타입에 따라 문자열로 변환되지 않을 수도 있습니다.<br>클라이언트에서 서버로 데이터를 JSON형태로 전송할 때 사용합니다.</p>\n<p>Symbol 값은 외부에 노출되지 않도록 조치 되어 있기 때문에 {[sym]: “값”}과 같이<br>Symbol 값을 프로퍼티로 작성하여 JSON.stringify()를 실행하면 프로퍼티 키와 프로퍼티 값이<br>문자열로 변환되지 않고 빈 Object {}가 반환됩니다.</p>\n<p><mark>이를 위한 대처방법으로 Object.getOwnPropertySymbols()를 사용하는 방법이 있습니다.</mark></p>\n","site":{"data":{}},"excerpt":"<ul>\n<li>Symbol Object<ul>\n<li><a href=\"/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#primitive\">primitive</a></li>\n<li><a href=\"/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_값_생성\">Symbol()</a></li>\n<li><a href=\"/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_값_변경\">Symbol 값 변경</a></li>\n<li><a href=\"/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_Object\">Symbol 오브젝트 생성</a></li>\n<li><a href=\"/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Object_Symbol\">오브젝트에서 Symbol 사용</a></li>\n<li><a href=\"/2020/04/06/Symbol%20오브젝트%20-ECMAScript/#Symbol_ex\">Symbol 사용 형태</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"primitive\">primitive</h2>\n\n<p>자바스크립트에 프리미티브(primitive) 개념이 있습니다. 이는 오브젝트가 아닌 값 입니다.<br>ES5에 string, number, boolean, null, undefined가 있으며<br>ES6에 Symbol이 추가되었습니다.</p>\n<p>(var num = 123;)을 실행하면 num에 123이 할당됩니다.<br>123은 number 타입의 프리미티브 값입니다.</p>\n<p>string, number, boolean 은 래퍼(Wrapper) 오브젝트가 있습니다.<br>각각 String, Number, Boolean 오브젝트가 래퍼 오브젝트 입니다.<br>ES6에서 symbol의 Symbol 오브젝트가 추가되었습니다.<br>undefined, null은 래퍼 오브젝트가 없습니다.</p>\n<p><strong>valueOf()로 래퍼 오브젝트의 프리미티브 값을 구할 수 있습니다.</strong><br><strong>단, Symbol은 값을 반환하지 않습니다.</strong></p>\n<hr>\n<h2 id=\"Symbol_값_생성\">Symbol()</h2>\n\n<blockquote>\n<p>let sym = Symbol();</p>\n</blockquote>\n<p>형태로 작성하며 Symbol 값을 생성하여 sym에 할당합니다.</p>\n<p>new 연산자는 사용할 수 없습니다.</p>\n<p><strong>Symbol()로 생성된 값은 프로그램 전체를 통해 유일하며 값을 변경할 수 없습니다.</strong></p>\n<p>생성한 Symbol에 프로퍼티를 설정할 수 없으며 strict mode에서 TypeError가 발생합니다.</p>\n<p>Symbol()로 반환된 값이 오브젝트가 아니므로 오브젝트를 생성한다고 할 수 없습니다.<br>Symbol을 생성한다는 것은 뉘앙스에 차이가 있습니다. Symbol 값을 생성한다는 표현이 적절합니다.</p>\n<p>Symbol은 String””, Array[], Object{}, Boolean(true/false)와 같이 오브젝트를<br>생성하는 리터럴이 없습니다. undefined, null과 같이 그 자체가 값이 되는 것도 아닙니다.</p>\n<p>Symbol()과 같이 함수로 호출해야 값을 생성하며 반환합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sym = <span class=\"built_in\">Symbol</span>();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, sym);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"keyword\">typeof</span> sym);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"주석\"</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, sym == <span class=\"built_in\">Symbol</span>());  </span><br><span class=\"line\"><span class=\"comment\">// 1: Symbol()  </span></span><br><span class=\"line\"><span class=\"comment\">// 2: symbol  </span></span><br><span class=\"line\"><span class=\"comment\">// 3: Symbol(주석)  </span></span><br><span class=\"line\"><span class=\"comment\">// 4: false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Symbol()을 호출하면 Symbol 값을 생성하여 반환합니다.<br>생성한 값은 변경할 수 없으므로 const 변수에 할당해도 됩니다.</li>\n</ul>\n<ol>\n<li><p>Symbol()로 값을 생성했는데 값이 출력되지 않고 실행 결과 Symbol()이 출력됩니다.<br>Symbol 값을 구하면 Symbol()로 생성한 값을 반환하지 않고,<br><strong>Symbol값을 생성했던 형태를 반환합니다. 브라우저 개발자 도구에서도 값을 볼 수 없습니다.</strong><br><strong>이것이 Symbol의 특징입니다.</strong></p>\n</li>\n<li><p>Symbol()로 생성한 값의 typeof는 symbol 입니다.</p>\n</li>\n<li><p>Symbol()의 파라미터는 선택사항으로 Symbol()로 생성한 값의 설명이나 주석을 문자열로 작성합니다. Symbol 값을 생성하는데 영향을 미치지 않습니다. Symbol 값을 외부에 제공하지 않으므로 디버깅할 때 유용합니다.<br>파라미터를 작성하지 않으면 undefined로 인식합니다. Symbol(“주석”)형태로 반환됩니다.</p>\n</li>\n<li><p><mark>앞에서 Symbol()로 생성한 값(sym)과 다시 Symbol()로 생성한 값을 비교하면<br>false가 반환됩니다.Symbol()을 실행할 때마다 프로그램 전체를 통해 유일한 값을<br>생성하므로 값이 같을 수 없습니다. 이것이 Symbol의 특징입니다.</mark></p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Symbol_값_변경\">Symbol 값 변경</h2>\n\n<p>Symbol()로 생성한 Symbol 값을 변경할 수 없습니다. Symbol 값에 문자열을 연결할 수 있으나<br>String() 또는 toString()을 사용해야 합니다. 이 형태는 Symbol 값이 연결되는 것은 아니며<br>Symbol 값을 생성할 때의 형태를 연결합니다.</p>\n<p>Symbol 값을 템플릿에 사용할 수 없고, + 연산자로 문자열을 연결하면 에러가 발생합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>Symbol +연산자, or연산자 사용불가</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>();  </span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> +sym;  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"+sym 사용 불가\"</span>);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> sym | <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"sym | 0 사용 불가\"</span>);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// +sym 사용 불가  </span></span><br><span class=\"line\"><span class=\"comment\">// sym | 사용 불가</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>단항 + 연산자를 사용하여 Number 타입으로 변환하면 에러가 발생합니다.<br>Symbol과 비트 or 연산자를 함께 사용하면 에러가 발생합니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>Symbol 문자열 연결</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>();  </span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> sym + <span class=\"string\">\"문자열\"</span>;  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"문자열 연결 불가\"</span>);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>(sym) + <span class=\"string\">\"연결\"</span>);  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(sym.toString() + <span class=\"string\">\"연결\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 문자열 연결 불가  </span></span><br><span class=\"line\"><span class=\"comment\">// Symbol() 연결  </span></span><br><span class=\"line\"><span class=\"comment\">// Symbol() 연결</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Symbol()로 생성한 값에 + 연산자로 문자열을 연결하면 에러가 발생합니다.</p>\n</li>\n<li><p>String(sym) 으로 Symbol을 문자열로 변환하면 문자열을 연결할 수 있습니다.<br>Symbol 값이 문자열로 연결되지는 않고 Symbol 값을 생성한 형태인<br>“Symbol()”이 연결됩니다. “Symbol() 연결”이 출력됩니다.</p>\n</li>\n<li><p>toString()으로 Symbol()을 문자열로 변환하면 문자열을 연결할 수 있습니다.<br>String()과 마찬가지로 Symbol()을 생성한 형태가 문자열에 연결됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>Symbol 템블릿</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym =<span class=\"built_in\">Symbol</span>(<span class=\"string\">\"123\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"string\">`<span class=\"subst\">$&#123;sym&#125;</span>`</span>;  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"`$&#123;sym&#125; 불가`\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// `$&#123;sym&#125; 불가`</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>템블릿에서 Symbol 값을 사용하면 에러가 발생합니다.</strong><br>Symbol 값이 템플릿에 반영되면 문자열 값으로 변환되어 외부에 노출되기 때문입니다.<br>(Symbol 값을 생성한 형태도 반영되지 않습니다. Symbol 값을 외부에 노출시키지 않는 것이 Symbol의 특징입니다.)</p>\n<hr>\n<h2 id=\"Symbol_Object\">Symbol 오브젝트 생성</h2>\n\n<p>Object()에 Object(123)처럼 파라미터 값 123을 작성하면 Number 오브젝트를 반환합니다.<br>마찬가지로 Object()의 파라미터에 Symbol 값일 작성하면 Symbol 오브젝트를 반환합니다.</p>\n<ul>\n<li>Symbol 오브젝트에<ul>\n<li>Symbol 메서드,</li>\n<li>Symbol.prototype,</li>\n<li>prototype에 연결된 프로퍼티가 설정됩니다.</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>Symbol Object</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"123\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>(sym);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(obj == sym);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj === sym);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/* Symbol  </span></span><br><span class=\"line\"><span class=\"comment\">description: (...)  </span></span><br><span class=\"line\"><span class=\"comment\">&gt;__proto__: Symbol  </span></span><br><span class=\"line\"><span class=\"comment\">[[PrimitiveValue]]: Symbol(123)  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// true  </span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Symbol(“123”)으로 Symbol 값을 생성하고 이를 Object(sym) 파라미터에 지정합니다.<br>Symbol 오브젝트를 생성하여 반환하게 됩니다. 다음은 생성한 Symbol 오브젝트 구성 입니다.</p>\n<img src=\"/images/SymbolObj.JPG\">\n\n<ol>\n<li><p>Symbol.prototype에 연결된 프로퍼티가 &#95;&#95;proto&#95;&#95;에 첨부됩니다.<br>이를 통해 Symbol.prototype의 메서드와 프로퍼티를 확인할 수 있습니다.</p>\n</li>\n<li><p>[[PrimitiveValue]]에 Symbol 값을 생성한 형태인 Symbol(“123”)이 설정됩니다.<br><del>Symbol 값이 설정되지 않고 값을 생성한 형태가 설정됩니다.</del><br>&#95;&#95;proto&#95;&#95;에 있는 valueOf()로 [[PrimitiveValue]]에 설정된 값을 반환받을 수 있습니다.</p>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"2\">\n<li>Symbol(“123”)으로 생성한 값 sym 과 Object()의 파라미터에 지정하여 생성한 obj를 비교하면 true를 반환합니다. === 연산자로 타입까지 비교하면 false를 반환합니다. 값은 [[PrimitiveValue]] 값으로 비교하여 true를 반환하지만 타입은 Symbol 과 Object 의 타입이 비교되기 때문입니다.</li>\n</ol>\n<hr>\n<h2 id=\"Object_Symbol\">오브젝트에서 Symbol 사용</h2>\n\n<p>프로그램에서 유일한 값을 갖은 Symbol의 특징을 이용하여<br>Symbol 값을 오브젝트의 프로퍼티 키로 사용하면 프로퍼티 키가 중복되지 않습니다.</p>\n<ul>\n<li><p>[Symbol()]<br>형태와 같이 대괄호[] 안에 Symbol()을 작성합니다.</p>\n</li>\n<li><p>{ [Symbol()]: 123}<br>프로퍼티 키에 작성한 Symbol()을 symbol-keyed property라고 합니다.<br>Symbol 값은 문자열이 아니며 값이기 때문에 []안에 {“Symbol”} 형태로 작성하지 않고<br>{Symbol} 형태로 작성합니다. 이 형태를 symbol-keyed property 라고 하는 것입니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"123\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;[sym]: <span class=\"string\">\"456\"</span>&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// Symbol(\"123\")을 변수에 할당하고 []안에 변수 이름을 작성하여  </span></span><br><span class=\"line\"><span class=\"comment\">// Object 의 프로퍼티 키로 사용  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 프로퍼티 키에 해당하는 값 출력  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj[sym]);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.sym);  </span><br><span class=\"line\"><span class=\"comment\">// 대괄호[]를 사용하지 않고 작성하면 에러가 발생하지 않고  </span></span><br><span class=\"line\"><span class=\"comment\">// undefined가 반환됨.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/* Object  </span></span><br><span class=\"line\"><span class=\"comment\">Symbol(123): \"456\"  </span></span><br><span class=\"line\"><span class=\"comment\">&gt;__proto__: Object  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 456  </span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Symbol_ex\">Symbol 사용 형태</h2>\n\n<p>fon-in 문에서 symbol-keyed 프로퍼티가 열거되지 않습니다.<br><strong>Symbol 이 [[ Enumberable]]: false 이기 때문입니다.</strong></p>\n<p>Symbol-keyed 프로퍼티를 열거 하려면 Object.getOwnPropertySymbols()를 사용해야 합니다.</p>\n<h3 id=\"클래스-메서드-이름으로-Symbol-사용\"><a href=\"#클래스-메서드-이름으로-Symbol-사용\" class=\"headerlink\" title=\"클래스 메서드 이름으로 Symbol 사용\"></a>클래스 메서드 이름으로 Symbol 사용</h3><figure class=\"highlight js\"><figcaption><span>method-name</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> symbolOne = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"symbol one\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> symbolTwo = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"symbol two\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"keyword\">static</span> [symbolOne]() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"Symbol-1\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"number\">2.</span> [symbolTwo]()&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"Symbol-2\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(Sports[symbolOne]());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> Sports();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj[symbolTwo]());  </span><br><span class=\"line\"><span class=\"comment\">// Symbol-1  </span></span><br><span class=\"line\"><span class=\"comment\">// Symbol-2</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Symbol(“symbol one”)으로 생성한 값을 static 메서드 이름으로 사용한 형태입니다.<br>대괄호 []안에 Symbol 값을 할당한 변수 이름을 작성하고 이어서 소괄호()를 작성합니다.</p>\n</li>\n<li><p>Symbol(“symbol two”)로 생성한 값을 메서드 이름으로 사용한 형태입니다.<br>static 키워드를 작성하지 않았으므로 Sports.prototype에 symbolTwo{}가 연결됩니다.</p>\n</li>\n<li><p>symbolOne은 static 메서드 입니다. 클래스 이름에 이어 대괄호[]안에 메서드 이름을 작성하고 소괄호()를 작성하면 메서드가 호출됩니다.</p>\n</li>\n<li><p>symbolTwo{}가 Sports.prototype에 연결되어 있으므로 호출하기 위해 인스턴스를 생성합니다. 인스턴스에 이어 대괄호[]안에 메서드 이름을 작성하고 소괄호()를 작성하면 메서드로 호출됩니다.</p>\n</li>\n</ol>\n<h3 id=\"JSON-stringify-에서-Symbol-사용\"><a href=\"#JSON-stringify-에서-Symbol-사용\" class=\"headerlink\" title=\"JSON.stringify()에서 Symbol 사용\"></a>JSON.stringify()에서 Symbol 사용</h3><p>JSON.stringify()는 Object 오브젝트의 프로퍼티를 {“key”: “value”}형태로 변환합니다.<br>key는 문자열로 변환되고 value는 타입에 따라 문자열로 변환되지 않을 수도 있습니다.<br>클라이언트에서 서버로 데이터를 JSON형태로 전송할 때 사용합니다.</p>\n<p>Symbol 값은 외부에 노출되지 않도록 조치 되어 있기 때문에 {[sym]: “값”}과 같이<br>Symbol 값을 프로퍼티로 작성하여 JSON.stringify()를 실행하면 프로퍼티 키와 프로퍼티 값이<br>문자열로 변환되지 않고 빈 Object {}가 반환됩니다.</p>\n<p><mark>이를 위한 대처방법으로 Object.getOwnPropertySymbols()를 사용하는 방법이 있습니다.</mark></p>"},{"title":"WeakMap 오브젝트 -ECMAScript","date":"2020-04-12T23:22:25.000Z","disqusId":"tunas-blog-1","_content":"\n*   WeakMap 오브젝트\n    \n    *   [개요](/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap)\n        *   GC(Garbage Collection)\n    *   [new WeakMap 인스턴스 생성](/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#newWeakMap)\n    *   [set(): key, value 설정](/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_set)\n    *   [get(): key가 같은 value 반환](/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_get)\n    *   [has(): key 존재 여부](/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_has)\n    *   [delete(): 엘리먼트 삭제](/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_delete)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"WeakMap\">개요</h2>\n\n`WeakMap`는 약한(weak) Map 오브젝트 입니다.  \n`Map` 오브젝트와 작성 방법과 형태는 같지만, 약한 점이 있습니다.\n\n*   `WeakMap` 오브젝트는 `key`에 `Object`만 작성할 수 있으며 `string`, `numbers`, `symbol` 등의 (원시 데이터형)은 허용되지 않습니다.\n\n*   `value`는 타입에 제한이 없습니다.\n\n*   `key`에 오브젝트만 지정할 수 있는 것이 중요하며, 그 이유를 이해하는 것이 `WeakMap` 오브젝트의 사용 핵심입니다.\n    \n    *   ex) let music = {title: “음악”} 코드를 실행하면 music 변수에 Object 오브젝트를 생성하여 할당합니다.  \n        다시 music 변수에 {singer: “가수”}를 할당하면 {title: “음악”}을 사용할 수 없게 됩니다.  \n        당연한 예시지만, 이로 인해 발생하는 문제를 해결하기 위한 것이 WeakMap 오브젝트의 목적입니다.\n\n### GC(Garbage Collection)\n\n```js GC\n1. let music = {title: \"음악\"};  \n2. let music = {singer: \"가수\"};  \n```\n\n1.  생성된 `Object 오브젝트`가 메모리에 설정되며, 메모리 주소가 `music 변수`에 할당됩니다.  \n    `music`을 전개하면 `{title: “음악”}`이 전개됩니다.  \n    `music`을 전개하다는 것은 `music` 변수에 `설정된 메모리 주소의 오브젝트`를 전개하는 것입니다.\n\n2.  `music = {singer: “가수”}`도 `Object 오브젝트`를 생성하여 메모리에 설정합니다. 생성한 Object 오브젝트를 `music 변수`에 할당하므로 `music 변수의 메모리 주소`가 바뀌게 됩니다.  \n    즉, `{title: “음악”}`을 사용할 수 없게 됩니다.\n\n**이때 엔진은 사용하지 않는 {title: “음악”}을 메모리에서 지웁니다.**  \n<mark>이를 GC(Garbage Collection)라고 하고, GC를 수행하는 것을 Garbage Collector라고 합니다.  \nGC를 하지 않으면 사용하지 않는 메모리가 쌓이게 됩니다. 즉 메모리 릭(Memory Leak)이 발생합니다.</mark>\n\n`GC`가 사용하지 않게 된 오브젝트를 메모리에서 지우면, `WeakMap` 인스턴스의 `key`에서 오브젝트를 참조할 수 없게됩니다. 메모리에 존재하지 않는 오브젝트를 참조하는 것은 문제가 됩니다. 이때, 엔진이 `WeakMap` 인스턴스의 `key` 와 `value`를 삭제합니다. 개발자 코드로 삭제하지 않아도 됩니다. 이런 점을 반영한 것이 `WeakMap` 오브젝트입니다.\n\n`WeakMap` 오브젝트에서 제공하는 메서드는 간단합니다.  \n`set()`, `get()`, `has()`, `delete()`만 있습니다. `WeakMap` 인스턴스에 `[key, value]`를 `CRUD`(Create, Read, Update, Delete)하기 위한 기본적인 메서드만 있습니다.  \n`WeakMap` 인스턴스는 열거할 수 없습니다. 그러므로 `forEach(), entries()` 메서드가 없습니다.\n\n`Map` 오브젝트는 `size` 프로퍼티가 있어 현재의 `[key, value]` 수를 알 수 있으나, `WeakMap` 오브젝트는 `size` 프로퍼티가 없어서 현재의 `[key, value]` 수를 알 수 없습니다. `length` 프로퍼티도 ~~개발자 도구에서는 표시되나~~ 실제로 사용하면 `undefined`를 반환합니다.\n\n* * *\n\n<h2 id=\"newWeakMap\">new WeakMap 인스턴스 생성</h2>\n\n**`WeakMap` 인스턴스를 생성하여 반환합니다.**\n\n> new WeakMap()\n\n*   선택적 파라미터  \n    Object, 이터러블 오브젝트안에 작성 [key, value] 형태\n    \n*   반환  \n    생성한 WeakMap 인스턴스\n    \n```js\nconst emptyWeakMap = new WeakMap();  \n  \nlet obj = {};  \nconst newWeakMap = new WeakMap([  \n [obj, \"오브젝트\"]  \n]);  \n```\n\n*   `WeakMap()`에 파라미터를 작성하지 않아도 `WeakMap` 인스턴스를 생성할 수 있습니다.  \n    이는 상황에 따라 엘리먼트를 추가하려는 의도입니다.\n\n*   `WeakMap()` 파라미터에 이터러블 오브젝트를 작성하고 그 안에 `[key, value]` 형태로 작성합니다.  \n    `key`에 오브젝트 이름을 지정하고 `value`에 값을 작성합니다. `key`인 오브젝트 자체에 프로퍼티가 있으므로 `value`는 오브젝트에 대한 `주석(설명)`이라고 볼 수 있습니다.\n\n* * *\n\n<h2 id=\"WeakMap_set\">set(): key, value 설정</h2>\n\n**`WeakMap` 인스턴스에 `key` 와 `value`를 설정합니다.**\n\n> WeakMap.prototype.set()\n\n*   파라미터\n    \n    *   Object (key, Object/Function 등의 오브젝트)\n    *   any (value)\n*   반환  \n    key, value가 추가된 WeakMap 인스턴스\n    \n\n첫 번째 파라미터에 `key`로 설정될 `Object, Function`과 같은 오브젝트를 지정합니다.  \n`string`, `numbers`, `boolean`, `null`, `undefined`, `symbol`을 지정하면 에러가 발생합니다.  \n두 번째 파라미터에 임의의 값을 작성합니다.\n\n```js set-1\n\"use strict\";  \ndebugger;  \n  \nconst newWeakMap = new WeakMap();  \n1. (function(){  \n var obj = {item: \"weakmap\"};  \n newWeakMap.set(obj, \"GC\");  \n}());  \n  \nconst newMap = new Map();  \n2. (function(){  \n var obj = {item: \"map\"};  \n newMap.set(obj, \"Keep\");  \n}());  \n  \n  \n3. setTimeout(function() {  \n 4. console.log(\"1:\", newWeakMap);  \n 5 .console.log(\"2:\", newMap);  \n}, 1000);  \n// 1: WeakMap {Object {item: \"weakmap\"} => \"GC\"}  \n// 2: Map {Object {item: \"map\"} => \"keep\"}  \n```\n\n*   위 코드는 상황에 따라 실행 결과가 다르게 출력될 수 있습니다.  \n    개발자 도구에서 `Sources`로 들어가 `.js파일`을 선택해 소스 코드를 화면에 표시하고  \n    F5를 눌러 새로고침 합니다. 소스 코드 두 번째 줄에 `debugger`를 작성했으므로 이 앞에서 멈추게 됩니다.  \n    `debugger`로 멈춘 시점에서 한 줄씩 소스 코드를 이동하면, 실행 결과의 1번 형태로 출력되지 않고, `“WeakMap {}”` 형태가 출력될 수 있습니다. 이는 소스 코드를 한 줄씩 따라 가는 동안 `GC`가 실행되어 `WeakMap` 인스턴스의 `[key, value]`를 삭제하기 때문입니다.\n\n1.  `(function(){코드});` 형태는 자동으로 함수가 실행됩니다. 함수를 저장하지 않고 한 번만 사용하려는 것이 목적입니다. 함수 실행이 끝나 함수를 빠져나오면 함수에서 선언한 변수가 저장되지 않으므로 다시 사용할 수 없습니다. 이렇게 사용하지 않게 된 것을 `Garbage Collector`가 메모리에서 삭제합니다.  \n    `newWeakMap.set(obj, “GC”)`을 실행하면, `obj` 오브젝트를 참조하는 메모리 주소가 `newWeakMap` 인스턴스의 `key`에 설정됩니다. 함수 실행이 끝나 함수를 빠져나오면 함수블록의 `obj` 변수가 메모리에서 삭제됩니다. 따라서 `newWeakMap` 인스턴스의 `key`에서 `obj` 오브젝트를 참조할 수 없게 됩니다.  \n    이때, `obj` 변수에서 참조하는 `{item: “weakmap”}`이 메모리에서 지워지면 `newWeakMap` 인스턴스의 `[key, value]`를 삭제합니다. 이것이 `WeakMap` 오브젝트의 목적입니다.\n\n2.  위의 1번 코드와 같은 형식이며 `WeakMap`이 아닌 `Map`을 사용한 것이 다릅니다.  \n    함수를 빠져나오면 `obj` 오브젝트를 참조하는 `Map` 인스턴스 `[key, value]`를 삭제하지 않고 유지합니다.  \n    이점이 `WeakMap` 과 `Map`의 차이입니다.\n\n3.  1초 후에 `setTimeout` 콜백 함수를 실행하게 됩니다. 1초 간격을 둔 것은 `GC`의 실행 여부에 따른 상태를 출력하기 위해서 입니다.\n\n4.  `console.log()`로 `newWeakMap`을 찍으면 두 가지 형태로 출력될 수 있습니다.  \n    `newWeakMap` 인스턴스의 `key`로 등록한 오브젝트가 메모리에서 삭제되면 `newWeakMap` 인스턴스의 `[key, value]`가 삭제되므로 빈 Object 오브젝트 {}가 출력됩니다. 메모리에서 삭제되지 않은 상태라면, `newWeakMap` 인스턴스에 `[key, value]`가 남아 있으므로 `1: WeakMap {Object {item: “weakmap”} => “GC”}` 형태로 출력됩니다.\n\n5.  `newMap` 인스턴스는 `GC`의 영향을 받지 않으므로 항상 `Map {Object {item: “map”} => “keep”}` 형태로 출력됩니다.\n\n```js set-2\nconst newWeakMap = new WeakMap();  \n  \n1. let sportsObj = {};  \nnewWeakMap.set(sportsObj, \"Object-1\");  \n  \n2. sportsObj = {};  \n3. newWeakMap.set(sportsObj, \"Object-2\");  \n  \n4. setTimeout(function() {  \n console.log(newWeakMap);  \n}, 1000);  \n// WeakMap {Object { } => \"Object-2\"} 또는  \n// WeakMap {Object { } => \"Object-2\"}, WeakMap {Object { } => \"Object-1\"}  \n```\n\n1.  `sportsObj` 변수에 `Object` 오브젝트를 생성하여 할당하고, `set( )`의 첫 번째 파라미터에 `sportsObj`를 지정하여 추가합니다.\n\n2.  새로운 `Object` 오브젝트를 생성하여 `sportsObj` 변수에 할당하므로 `sportsObj`가 참조하는 `메모리 주소`가 변경됩니다. `newWeakMap` 인스턴스에 `key`로 설정된 `sportsObj`가 참조하는 `Object` 오브젝트는 `GC` 대상이 됩니다.\n\n3.  `set( )`의 첫 번째 파라미터에 `sportsObj`를 지정하여 설정합니다. `newWeakMap` 인스턴스에 `sportsObj`가 있지만, `sportsObj`가 참조하는 메모리 주소가 다르므로 추가됩니다. 따라서 `newWeakMap` 인스턴스에는 `sportsObj`가 참조하는 `Object` 오브젝트가 두 개 존재하게 됩니다. 개발자 도구에서 소스 코드에 중단점(`Break Point`)를 걸어 `newWeakMap` 인스턴스를 펼치면 두 개의 `Object` 오브젝트가 표시됩니다.\n\n```js set-3\nconst newWeakMap = new WeakMap();  \n  \nlet fn = function(){};  \nnewWeakMap.set(fn, \"함수\");  \n  \nnewWeakMap.set(fn, \"value 변경\");  \nconsole.log(newWeakMap);  \n// WeakMap {function => \"value 변경\"}  \n```\n\n*   `function` 오브젝트를 생성하여 `변수 fn`에 할당한 후, `set()`에서 `key`로 지정하여 `newWeakMap`에 추가합니다.  \n    `function` 오브젝트도 오브젝트이므로 `WeakMap` 인스턴스에 설정할 수 있습니다.\n    \n*   `set( )`의 첫 번째 파라미터에 `fn`을 지정하여 `newWeakMap` 인스턴스에 설정합니다. `fn`이 참조하는 `메모리 주소`가 같으므로 추가하지 않고 두 번째 파라미터 값으로 `value`를 변경합니다. `newWeakMap` 인스턴스에 `[key, value]`가 하나만 존재합니다.\n    \n\n* * *\n\n<h2 id=\"WeakMap_get\">get(): key가 같은 value 반환</h2>\n\n**`WeakMap` 인스턴스에서 지정한 `key`의 `value`를 반환합니다.**\n\n> WeakMap.prototype.get()\n\n*   파라미터  \n    WeakMap 인스턴스의 key와 비교할 오브젝트를 지정합니다.\n    \n*   반환 값  \n    key가 존재하면 value를 반환하고, 존재하지 않으면 undefined를 반환합니다.\n    \n\n```js get()\nconst newWeakMap = new WeakMap();  \n  \nlet obj = {};  \nnewWeakMap.set(obj, \"오브젝트\");  \n  \nconsole.log(newWeakMap.get(obj));  \n// 오브젝트  \n```\n\n*   `obj` 변수에 Object 오브젝트를 생성하여 할당하고, 이를 `key`로 하여 `newWeakMap` 인스턴스에 추가합니다. `value` 값은 “오브젝트”입니다.  \n    `get()` 파라미터에 오브젝트를 지정합니다. `newWeakMap` 인스턴스에 파라미터로 지정한 `obj` 오브젝트가 존재하므로 `[key, value]`에서 `value`를 반환합니다.\n\n* * *\n\n<h2 id=\"WeakMap_has\">has(): key 존재 여부</h2>\n\n**`WeakMap` 인스턴스에서 `key` 존재 여부를 반환합니다. `true/false`**\n\n> WeakMap.prototype.has()\n\n파라미터에 WeakMap 인스턴스의 key와 비교할 오브젝트를 지정합니다. 오브젝트가 존재하면 `true`, 아니면 `false`를 반환합니다.\n\n```js has()\nconst newWeakMap = new WeakMap();  \n  \nlet obj = {};  \nnewWeakMap.set(obj, \"오브젝트\");  \n  \nconsole.log(newWeakMap.has(obj));  \n// true  \n```\n\n*   Object 오브젝트를 생성하여 obj 변수에 할당하고, 이를 key로 하여 newWeakMap 인스턴스에 설정합니다. value값은 “오브젝트”입니다.  \n    newWeakMap 인스턴스에 has()파라미터에 지정한 obj 오브젝트가 존재하므로 true가 출력됩니다.\n\n* * *\n\n<h2 id=\"WeakMap_delete\">delete(): 엘리먼트 삭제</h2>\n\n**`WeakMap` 인스턴스에서 `key`가 같은 엘리먼트를 삭제합니다.**\n\n> WeakMap.prototype.delete()\n\n파라미터의 WeakMap 인스턴스의 key와 비교할 오브젝트를 지정합니다. `key`가 존재하면 `[key, value]`를 삭제하고 `true`를 반환합니다. 존재하지 않으면 `false`를 반환합니다.\n\n```js delete()\nconst newWeakMap = new WeakMap();  \n  \nlet obj = {};  \nnewWeakMap.set(obj, \"오브젝트\");  \n  \nconsole.log(newWeakMap.delete(obj));  \n// true  \n```\n\n`Object` 오브젝트를 생성하여 `obj` 변수에 할당하고, 이를 `key`로 하여 `newWeakMap`에 추가한 상태에서 위 코드를 실행합니다. `delete()` 파라미터에 `key`로 등록된 `obj` 오브젝트를 지정했으므로 `[key, value]`가 삭제됩니다. 또한, 삭제에 성공했으므로 true를 반환합니다. `newWeakMap` 인스턴스에서 삭제하는 것이지 `obj`에서 참조하는 메모리의 `Object 오브젝트{}`가 삭제되는 것은 아닙니다.\n","source":"_posts/WeakMap 오브젝트 -ECMAScript.md","raw":"---\ntitle: WeakMap 오브젝트 -ECMAScript\ndate: 2020-04-13 08:22:25\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n*   WeakMap 오브젝트\n    \n    *   [개요](/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap)\n        *   GC(Garbage Collection)\n    *   [new WeakMap 인스턴스 생성](/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#newWeakMap)\n    *   [set(): key, value 설정](/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_set)\n    *   [get(): key가 같은 value 반환](/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_get)\n    *   [has(): key 존재 여부](/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_has)\n    *   [delete(): 엘리먼트 삭제](/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_delete)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"WeakMap\">개요</h2>\n\n`WeakMap`는 약한(weak) Map 오브젝트 입니다.  \n`Map` 오브젝트와 작성 방법과 형태는 같지만, 약한 점이 있습니다.\n\n*   `WeakMap` 오브젝트는 `key`에 `Object`만 작성할 수 있으며 `string`, `numbers`, `symbol` 등의 (원시 데이터형)은 허용되지 않습니다.\n\n*   `value`는 타입에 제한이 없습니다.\n\n*   `key`에 오브젝트만 지정할 수 있는 것이 중요하며, 그 이유를 이해하는 것이 `WeakMap` 오브젝트의 사용 핵심입니다.\n    \n    *   ex) let music = {title: “음악”} 코드를 실행하면 music 변수에 Object 오브젝트를 생성하여 할당합니다.  \n        다시 music 변수에 {singer: “가수”}를 할당하면 {title: “음악”}을 사용할 수 없게 됩니다.  \n        당연한 예시지만, 이로 인해 발생하는 문제를 해결하기 위한 것이 WeakMap 오브젝트의 목적입니다.\n\n### GC(Garbage Collection)\n\n```js GC\n1. let music = {title: \"음악\"};  \n2. let music = {singer: \"가수\"};  \n```\n\n1.  생성된 `Object 오브젝트`가 메모리에 설정되며, 메모리 주소가 `music 변수`에 할당됩니다.  \n    `music`을 전개하면 `{title: “음악”}`이 전개됩니다.  \n    `music`을 전개하다는 것은 `music` 변수에 `설정된 메모리 주소의 오브젝트`를 전개하는 것입니다.\n\n2.  `music = {singer: “가수”}`도 `Object 오브젝트`를 생성하여 메모리에 설정합니다. 생성한 Object 오브젝트를 `music 변수`에 할당하므로 `music 변수의 메모리 주소`가 바뀌게 됩니다.  \n    즉, `{title: “음악”}`을 사용할 수 없게 됩니다.\n\n**이때 엔진은 사용하지 않는 {title: “음악”}을 메모리에서 지웁니다.**  \n<mark>이를 GC(Garbage Collection)라고 하고, GC를 수행하는 것을 Garbage Collector라고 합니다.  \nGC를 하지 않으면 사용하지 않는 메모리가 쌓이게 됩니다. 즉 메모리 릭(Memory Leak)이 발생합니다.</mark>\n\n`GC`가 사용하지 않게 된 오브젝트를 메모리에서 지우면, `WeakMap` 인스턴스의 `key`에서 오브젝트를 참조할 수 없게됩니다. 메모리에 존재하지 않는 오브젝트를 참조하는 것은 문제가 됩니다. 이때, 엔진이 `WeakMap` 인스턴스의 `key` 와 `value`를 삭제합니다. 개발자 코드로 삭제하지 않아도 됩니다. 이런 점을 반영한 것이 `WeakMap` 오브젝트입니다.\n\n`WeakMap` 오브젝트에서 제공하는 메서드는 간단합니다.  \n`set()`, `get()`, `has()`, `delete()`만 있습니다. `WeakMap` 인스턴스에 `[key, value]`를 `CRUD`(Create, Read, Update, Delete)하기 위한 기본적인 메서드만 있습니다.  \n`WeakMap` 인스턴스는 열거할 수 없습니다. 그러므로 `forEach(), entries()` 메서드가 없습니다.\n\n`Map` 오브젝트는 `size` 프로퍼티가 있어 현재의 `[key, value]` 수를 알 수 있으나, `WeakMap` 오브젝트는 `size` 프로퍼티가 없어서 현재의 `[key, value]` 수를 알 수 없습니다. `length` 프로퍼티도 ~~개발자 도구에서는 표시되나~~ 실제로 사용하면 `undefined`를 반환합니다.\n\n* * *\n\n<h2 id=\"newWeakMap\">new WeakMap 인스턴스 생성</h2>\n\n**`WeakMap` 인스턴스를 생성하여 반환합니다.**\n\n> new WeakMap()\n\n*   선택적 파라미터  \n    Object, 이터러블 오브젝트안에 작성 [key, value] 형태\n    \n*   반환  \n    생성한 WeakMap 인스턴스\n    \n```js\nconst emptyWeakMap = new WeakMap();  \n  \nlet obj = {};  \nconst newWeakMap = new WeakMap([  \n [obj, \"오브젝트\"]  \n]);  \n```\n\n*   `WeakMap()`에 파라미터를 작성하지 않아도 `WeakMap` 인스턴스를 생성할 수 있습니다.  \n    이는 상황에 따라 엘리먼트를 추가하려는 의도입니다.\n\n*   `WeakMap()` 파라미터에 이터러블 오브젝트를 작성하고 그 안에 `[key, value]` 형태로 작성합니다.  \n    `key`에 오브젝트 이름을 지정하고 `value`에 값을 작성합니다. `key`인 오브젝트 자체에 프로퍼티가 있으므로 `value`는 오브젝트에 대한 `주석(설명)`이라고 볼 수 있습니다.\n\n* * *\n\n<h2 id=\"WeakMap_set\">set(): key, value 설정</h2>\n\n**`WeakMap` 인스턴스에 `key` 와 `value`를 설정합니다.**\n\n> WeakMap.prototype.set()\n\n*   파라미터\n    \n    *   Object (key, Object/Function 등의 오브젝트)\n    *   any (value)\n*   반환  \n    key, value가 추가된 WeakMap 인스턴스\n    \n\n첫 번째 파라미터에 `key`로 설정될 `Object, Function`과 같은 오브젝트를 지정합니다.  \n`string`, `numbers`, `boolean`, `null`, `undefined`, `symbol`을 지정하면 에러가 발생합니다.  \n두 번째 파라미터에 임의의 값을 작성합니다.\n\n```js set-1\n\"use strict\";  \ndebugger;  \n  \nconst newWeakMap = new WeakMap();  \n1. (function(){  \n var obj = {item: \"weakmap\"};  \n newWeakMap.set(obj, \"GC\");  \n}());  \n  \nconst newMap = new Map();  \n2. (function(){  \n var obj = {item: \"map\"};  \n newMap.set(obj, \"Keep\");  \n}());  \n  \n  \n3. setTimeout(function() {  \n 4. console.log(\"1:\", newWeakMap);  \n 5 .console.log(\"2:\", newMap);  \n}, 1000);  \n// 1: WeakMap {Object {item: \"weakmap\"} => \"GC\"}  \n// 2: Map {Object {item: \"map\"} => \"keep\"}  \n```\n\n*   위 코드는 상황에 따라 실행 결과가 다르게 출력될 수 있습니다.  \n    개발자 도구에서 `Sources`로 들어가 `.js파일`을 선택해 소스 코드를 화면에 표시하고  \n    F5를 눌러 새로고침 합니다. 소스 코드 두 번째 줄에 `debugger`를 작성했으므로 이 앞에서 멈추게 됩니다.  \n    `debugger`로 멈춘 시점에서 한 줄씩 소스 코드를 이동하면, 실행 결과의 1번 형태로 출력되지 않고, `“WeakMap {}”` 형태가 출력될 수 있습니다. 이는 소스 코드를 한 줄씩 따라 가는 동안 `GC`가 실행되어 `WeakMap` 인스턴스의 `[key, value]`를 삭제하기 때문입니다.\n\n1.  `(function(){코드});` 형태는 자동으로 함수가 실행됩니다. 함수를 저장하지 않고 한 번만 사용하려는 것이 목적입니다. 함수 실행이 끝나 함수를 빠져나오면 함수에서 선언한 변수가 저장되지 않으므로 다시 사용할 수 없습니다. 이렇게 사용하지 않게 된 것을 `Garbage Collector`가 메모리에서 삭제합니다.  \n    `newWeakMap.set(obj, “GC”)`을 실행하면, `obj` 오브젝트를 참조하는 메모리 주소가 `newWeakMap` 인스턴스의 `key`에 설정됩니다. 함수 실행이 끝나 함수를 빠져나오면 함수블록의 `obj` 변수가 메모리에서 삭제됩니다. 따라서 `newWeakMap` 인스턴스의 `key`에서 `obj` 오브젝트를 참조할 수 없게 됩니다.  \n    이때, `obj` 변수에서 참조하는 `{item: “weakmap”}`이 메모리에서 지워지면 `newWeakMap` 인스턴스의 `[key, value]`를 삭제합니다. 이것이 `WeakMap` 오브젝트의 목적입니다.\n\n2.  위의 1번 코드와 같은 형식이며 `WeakMap`이 아닌 `Map`을 사용한 것이 다릅니다.  \n    함수를 빠져나오면 `obj` 오브젝트를 참조하는 `Map` 인스턴스 `[key, value]`를 삭제하지 않고 유지합니다.  \n    이점이 `WeakMap` 과 `Map`의 차이입니다.\n\n3.  1초 후에 `setTimeout` 콜백 함수를 실행하게 됩니다. 1초 간격을 둔 것은 `GC`의 실행 여부에 따른 상태를 출력하기 위해서 입니다.\n\n4.  `console.log()`로 `newWeakMap`을 찍으면 두 가지 형태로 출력될 수 있습니다.  \n    `newWeakMap` 인스턴스의 `key`로 등록한 오브젝트가 메모리에서 삭제되면 `newWeakMap` 인스턴스의 `[key, value]`가 삭제되므로 빈 Object 오브젝트 {}가 출력됩니다. 메모리에서 삭제되지 않은 상태라면, `newWeakMap` 인스턴스에 `[key, value]`가 남아 있으므로 `1: WeakMap {Object {item: “weakmap”} => “GC”}` 형태로 출력됩니다.\n\n5.  `newMap` 인스턴스는 `GC`의 영향을 받지 않으므로 항상 `Map {Object {item: “map”} => “keep”}` 형태로 출력됩니다.\n\n```js set-2\nconst newWeakMap = new WeakMap();  \n  \n1. let sportsObj = {};  \nnewWeakMap.set(sportsObj, \"Object-1\");  \n  \n2. sportsObj = {};  \n3. newWeakMap.set(sportsObj, \"Object-2\");  \n  \n4. setTimeout(function() {  \n console.log(newWeakMap);  \n}, 1000);  \n// WeakMap {Object { } => \"Object-2\"} 또는  \n// WeakMap {Object { } => \"Object-2\"}, WeakMap {Object { } => \"Object-1\"}  \n```\n\n1.  `sportsObj` 변수에 `Object` 오브젝트를 생성하여 할당하고, `set( )`의 첫 번째 파라미터에 `sportsObj`를 지정하여 추가합니다.\n\n2.  새로운 `Object` 오브젝트를 생성하여 `sportsObj` 변수에 할당하므로 `sportsObj`가 참조하는 `메모리 주소`가 변경됩니다. `newWeakMap` 인스턴스에 `key`로 설정된 `sportsObj`가 참조하는 `Object` 오브젝트는 `GC` 대상이 됩니다.\n\n3.  `set( )`의 첫 번째 파라미터에 `sportsObj`를 지정하여 설정합니다. `newWeakMap` 인스턴스에 `sportsObj`가 있지만, `sportsObj`가 참조하는 메모리 주소가 다르므로 추가됩니다. 따라서 `newWeakMap` 인스턴스에는 `sportsObj`가 참조하는 `Object` 오브젝트가 두 개 존재하게 됩니다. 개발자 도구에서 소스 코드에 중단점(`Break Point`)를 걸어 `newWeakMap` 인스턴스를 펼치면 두 개의 `Object` 오브젝트가 표시됩니다.\n\n```js set-3\nconst newWeakMap = new WeakMap();  \n  \nlet fn = function(){};  \nnewWeakMap.set(fn, \"함수\");  \n  \nnewWeakMap.set(fn, \"value 변경\");  \nconsole.log(newWeakMap);  \n// WeakMap {function => \"value 변경\"}  \n```\n\n*   `function` 오브젝트를 생성하여 `변수 fn`에 할당한 후, `set()`에서 `key`로 지정하여 `newWeakMap`에 추가합니다.  \n    `function` 오브젝트도 오브젝트이므로 `WeakMap` 인스턴스에 설정할 수 있습니다.\n    \n*   `set( )`의 첫 번째 파라미터에 `fn`을 지정하여 `newWeakMap` 인스턴스에 설정합니다. `fn`이 참조하는 `메모리 주소`가 같으므로 추가하지 않고 두 번째 파라미터 값으로 `value`를 변경합니다. `newWeakMap` 인스턴스에 `[key, value]`가 하나만 존재합니다.\n    \n\n* * *\n\n<h2 id=\"WeakMap_get\">get(): key가 같은 value 반환</h2>\n\n**`WeakMap` 인스턴스에서 지정한 `key`의 `value`를 반환합니다.**\n\n> WeakMap.prototype.get()\n\n*   파라미터  \n    WeakMap 인스턴스의 key와 비교할 오브젝트를 지정합니다.\n    \n*   반환 값  \n    key가 존재하면 value를 반환하고, 존재하지 않으면 undefined를 반환합니다.\n    \n\n```js get()\nconst newWeakMap = new WeakMap();  \n  \nlet obj = {};  \nnewWeakMap.set(obj, \"오브젝트\");  \n  \nconsole.log(newWeakMap.get(obj));  \n// 오브젝트  \n```\n\n*   `obj` 변수에 Object 오브젝트를 생성하여 할당하고, 이를 `key`로 하여 `newWeakMap` 인스턴스에 추가합니다. `value` 값은 “오브젝트”입니다.  \n    `get()` 파라미터에 오브젝트를 지정합니다. `newWeakMap` 인스턴스에 파라미터로 지정한 `obj` 오브젝트가 존재하므로 `[key, value]`에서 `value`를 반환합니다.\n\n* * *\n\n<h2 id=\"WeakMap_has\">has(): key 존재 여부</h2>\n\n**`WeakMap` 인스턴스에서 `key` 존재 여부를 반환합니다. `true/false`**\n\n> WeakMap.prototype.has()\n\n파라미터에 WeakMap 인스턴스의 key와 비교할 오브젝트를 지정합니다. 오브젝트가 존재하면 `true`, 아니면 `false`를 반환합니다.\n\n```js has()\nconst newWeakMap = new WeakMap();  \n  \nlet obj = {};  \nnewWeakMap.set(obj, \"오브젝트\");  \n  \nconsole.log(newWeakMap.has(obj));  \n// true  \n```\n\n*   Object 오브젝트를 생성하여 obj 변수에 할당하고, 이를 key로 하여 newWeakMap 인스턴스에 설정합니다. value값은 “오브젝트”입니다.  \n    newWeakMap 인스턴스에 has()파라미터에 지정한 obj 오브젝트가 존재하므로 true가 출력됩니다.\n\n* * *\n\n<h2 id=\"WeakMap_delete\">delete(): 엘리먼트 삭제</h2>\n\n**`WeakMap` 인스턴스에서 `key`가 같은 엘리먼트를 삭제합니다.**\n\n> WeakMap.prototype.delete()\n\n파라미터의 WeakMap 인스턴스의 key와 비교할 오브젝트를 지정합니다. `key`가 존재하면 `[key, value]`를 삭제하고 `true`를 반환합니다. 존재하지 않으면 `false`를 반환합니다.\n\n```js delete()\nconst newWeakMap = new WeakMap();  \n  \nlet obj = {};  \nnewWeakMap.set(obj, \"오브젝트\");  \n  \nconsole.log(newWeakMap.delete(obj));  \n// true  \n```\n\n`Object` 오브젝트를 생성하여 `obj` 변수에 할당하고, 이를 `key`로 하여 `newWeakMap`에 추가한 상태에서 위 코드를 실행합니다. `delete()` 파라미터에 `key`로 등록된 `obj` 오브젝트를 지정했으므로 `[key, value]`가 삭제됩니다. 또한, 삭제에 성공했으므로 true를 반환합니다. `newWeakMap` 인스턴스에서 삭제하는 것이지 `obj`에서 참조하는 메모리의 `Object 오브젝트{}`가 삭제되는 것은 아닙니다.\n","slug":"WeakMap 오브젝트 -ECMAScript","published":1,"updated":"2020-05-06T13:30:55.904Z","_id":"ck9iqcrsz0022qgvq0iq440fl","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li><p>WeakMap 오브젝트</p>\n<ul>\n<li><a href=\"/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap\">개요</a><ul>\n<li>GC(Garbage Collection)</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#newWeakMap\">new WeakMap 인스턴스 생성</a></li>\n<li><a href=\"/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_set\">set(): key, value 설정</a></li>\n<li><a href=\"/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_get\">get(): key가 같은 value 반환</a></li>\n<li><a href=\"/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_has\">has(): key 존재 여부</a></li>\n<li><a href=\"/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_delete\">delete(): 엘리먼트 삭제</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"WeakMap\">개요</h2>\n\n<p><code>WeakMap</code>는 약한(weak) Map 오브젝트 입니다.<br><code>Map</code> 오브젝트와 작성 방법과 형태는 같지만, 약한 점이 있습니다.</p>\n<ul>\n<li><p><code>WeakMap</code> 오브젝트는 <code>key</code>에 <code>Object</code>만 작성할 수 있으며 <code>string</code>, <code>numbers</code>, <code>symbol</code> 등의 (원시 데이터형)은 허용되지 않습니다.</p>\n</li>\n<li><p><code>value</code>는 타입에 제한이 없습니다.</p>\n</li>\n<li><p><code>key</code>에 오브젝트만 지정할 수 있는 것이 중요하며, 그 이유를 이해하는 것이 <code>WeakMap</code> 오브젝트의 사용 핵심입니다.</p>\n<ul>\n<li>ex) let music = {title: “음악”} 코드를 실행하면 music 변수에 Object 오브젝트를 생성하여 할당합니다.<br>다시 music 변수에 {singer: “가수”}를 할당하면 {title: “음악”}을 사용할 수 없게 됩니다.<br>당연한 예시지만, 이로 인해 발생하는 문제를 해결하기 위한 것이 WeakMap 오브젝트의 목적입니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GC-Garbage-Collection\"><a href=\"#GC-Garbage-Collection\" class=\"headerlink\" title=\"GC(Garbage Collection)\"></a>GC(Garbage Collection)</h3><figure class=\"highlight js\"><figcaption><span>GC</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> music = &#123;<span class=\"attr\">title</span>: <span class=\"string\">\"음악\"</span>&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> music = &#123;<span class=\"attr\">singer</span>: <span class=\"string\">\"가수\"</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>생성된 <code>Object 오브젝트</code>가 메모리에 설정되며, 메모리 주소가 <code>music 변수</code>에 할당됩니다.<br><code>music</code>을 전개하면 <code>{title: “음악”}</code>이 전개됩니다.<br><code>music</code>을 전개하다는 것은 <code>music</code> 변수에 <code>설정된 메모리 주소의 오브젝트</code>를 전개하는 것입니다.</p>\n</li>\n<li><p><code>music = {singer: “가수”}</code>도 <code>Object 오브젝트</code>를 생성하여 메모리에 설정합니다. 생성한 Object 오브젝트를 <code>music 변수</code>에 할당하므로 <code>music 변수의 메모리 주소</code>가 바뀌게 됩니다.<br>즉, <code>{title: “음악”}</code>을 사용할 수 없게 됩니다.</p>\n</li>\n</ol>\n<p><strong>이때 엔진은 사용하지 않는 {title: “음악”}을 메모리에서 지웁니다.</strong><br><mark>이를 GC(Garbage Collection)라고 하고, GC를 수행하는 것을 Garbage Collector라고 합니다.<br>GC를 하지 않으면 사용하지 않는 메모리가 쌓이게 됩니다. 즉 메모리 릭(Memory Leak)이 발생합니다.</mark></p>\n<p><code>GC</code>가 사용하지 않게 된 오브젝트를 메모리에서 지우면, <code>WeakMap</code> 인스턴스의 <code>key</code>에서 오브젝트를 참조할 수 없게됩니다. 메모리에 존재하지 않는 오브젝트를 참조하는 것은 문제가 됩니다. 이때, 엔진이 <code>WeakMap</code> 인스턴스의 <code>key</code> 와 <code>value</code>를 삭제합니다. 개발자 코드로 삭제하지 않아도 됩니다. 이런 점을 반영한 것이 <code>WeakMap</code> 오브젝트입니다.</p>\n<p><code>WeakMap</code> 오브젝트에서 제공하는 메서드는 간단합니다.<br><code>set()</code>, <code>get()</code>, <code>has()</code>, <code>delete()</code>만 있습니다. <code>WeakMap</code> 인스턴스에 <code>[key, value]</code>를 <code>CRUD</code>(Create, Read, Update, Delete)하기 위한 기본적인 메서드만 있습니다.<br><code>WeakMap</code> 인스턴스는 열거할 수 없습니다. 그러므로 <code>forEach(), entries()</code> 메서드가 없습니다.</p>\n<p><code>Map</code> 오브젝트는 <code>size</code> 프로퍼티가 있어 현재의 <code>[key, value]</code> 수를 알 수 있으나, <code>WeakMap</code> 오브젝트는 <code>size</code> 프로퍼티가 없어서 현재의 <code>[key, value]</code> 수를 알 수 없습니다. <code>length</code> 프로퍼티도 <del>개발자 도구에서는 표시되나</del> 실제로 사용하면 <code>undefined</code>를 반환합니다.</p>\n<hr>\n<h2 id=\"newWeakMap\">new WeakMap 인스턴스 생성</h2>\n\n<p><strong><code>WeakMap</code> 인스턴스를 생성하여 반환합니다.</strong></p>\n<blockquote>\n<p>new WeakMap()</p>\n</blockquote>\n<ul>\n<li><p>선택적 파라미터<br>Object, 이터러블 오브젝트안에 작성 [key, value] 형태</p>\n</li>\n<li><p>반환<br>생성한 WeakMap 인스턴스</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> emptyWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> newWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>([  </span><br><span class=\"line\"> [obj, <span class=\"string\">\"오브젝트\"</span>]  </span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>WeakMap()</code>에 파라미터를 작성하지 않아도 <code>WeakMap</code> 인스턴스를 생성할 수 있습니다.<br>이는 상황에 따라 엘리먼트를 추가하려는 의도입니다.</p>\n</li>\n<li><p><code>WeakMap()</code> 파라미터에 이터러블 오브젝트를 작성하고 그 안에 <code>[key, value]</code> 형태로 작성합니다.<br><code>key</code>에 오브젝트 이름을 지정하고 <code>value</code>에 값을 작성합니다. <code>key</code>인 오브젝트 자체에 프로퍼티가 있으므로 <code>value</code>는 오브젝트에 대한 <code>주석(설명)</code>이라고 볼 수 있습니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"WeakMap_set\">set(): key, value 설정</h2>\n\n<p><strong><code>WeakMap</code> 인스턴스에 <code>key</code> 와 <code>value</code>를 설정합니다.</strong></p>\n<blockquote>\n<p>WeakMap.prototype.set()</p>\n</blockquote>\n<ul>\n<li><p>파라미터</p>\n<ul>\n<li>Object (key, Object/Function 등의 오브젝트)</li>\n<li>any (value)</li>\n</ul>\n</li>\n<li><p>반환<br>key, value가 추가된 WeakMap 인스턴스</p>\n</li>\n</ul>\n<p>첫 번째 파라미터에 <code>key</code>로 설정될 <code>Object, Function</code>과 같은 오브젝트를 지정합니다.<br><code>string</code>, <code>numbers</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>symbol</code>을 지정하면 에러가 발생합니다.<br>두 번째 파라미터에 임의의 값을 작성합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>set-1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">debugger</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> newWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();  </span><br><span class=\"line\"><span class=\"number\">1.</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"weakmap\"</span>&#125;;  </span><br><span class=\"line\"> newWeakMap.set(obj, <span class=\"string\">\"GC\"</span>);  </span><br><span class=\"line\">&#125;());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();  </span><br><span class=\"line\"><span class=\"number\">2.</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"map\"</span>&#125;;  </span><br><span class=\"line\"> newMap.set(obj, <span class=\"string\">\"Keep\"</span>);  </span><br><span class=\"line\">&#125;());  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, newWeakMap);  </span><br><span class=\"line\"> <span class=\"number\">5</span> .console.log(<span class=\"string\">\"2:\"</span>, newMap);  </span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 1: WeakMap &#123;Object &#123;item: \"weakmap\"&#125; =&gt; \"GC\"&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// 2: Map &#123;Object &#123;item: \"map\"&#125; =&gt; \"keep\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>위 코드는 상황에 따라 실행 결과가 다르게 출력될 수 있습니다.<br>개발자 도구에서 <code>Sources</code>로 들어가 <code>.js파일</code>을 선택해 소스 코드를 화면에 표시하고<br>F5를 눌러 새로고침 합니다. 소스 코드 두 번째 줄에 <code>debugger</code>를 작성했으므로 이 앞에서 멈추게 됩니다.<br><code>debugger</code>로 멈춘 시점에서 한 줄씩 소스 코드를 이동하면, 실행 결과의 1번 형태로 출력되지 않고, <code>“WeakMap {}”</code> 형태가 출력될 수 있습니다. 이는 소스 코드를 한 줄씩 따라 가는 동안 <code>GC</code>가 실행되어 <code>WeakMap</code> 인스턴스의 <code>[key, value]</code>를 삭제하기 때문입니다.</li>\n</ul>\n<ol>\n<li><p><code>(function(){코드});</code> 형태는 자동으로 함수가 실행됩니다. 함수를 저장하지 않고 한 번만 사용하려는 것이 목적입니다. 함수 실행이 끝나 함수를 빠져나오면 함수에서 선언한 변수가 저장되지 않으므로 다시 사용할 수 없습니다. 이렇게 사용하지 않게 된 것을 <code>Garbage Collector</code>가 메모리에서 삭제합니다.<br><code>newWeakMap.set(obj, “GC”)</code>을 실행하면, <code>obj</code> 오브젝트를 참조하는 메모리 주소가 <code>newWeakMap</code> 인스턴스의 <code>key</code>에 설정됩니다. 함수 실행이 끝나 함수를 빠져나오면 함수블록의 <code>obj</code> 변수가 메모리에서 삭제됩니다. 따라서 <code>newWeakMap</code> 인스턴스의 <code>key</code>에서 <code>obj</code> 오브젝트를 참조할 수 없게 됩니다.<br>이때, <code>obj</code> 변수에서 참조하는 <code>{item: “weakmap”}</code>이 메모리에서 지워지면 <code>newWeakMap</code> 인스턴스의 <code>[key, value]</code>를 삭제합니다. 이것이 <code>WeakMap</code> 오브젝트의 목적입니다.</p>\n</li>\n<li><p>위의 1번 코드와 같은 형식이며 <code>WeakMap</code>이 아닌 <code>Map</code>을 사용한 것이 다릅니다.<br>함수를 빠져나오면 <code>obj</code> 오브젝트를 참조하는 <code>Map</code> 인스턴스 <code>[key, value]</code>를 삭제하지 않고 유지합니다.<br>이점이 <code>WeakMap</code> 과 <code>Map</code>의 차이입니다.</p>\n</li>\n<li><p>1초 후에 <code>setTimeout</code> 콜백 함수를 실행하게 됩니다. 1초 간격을 둔 것은 <code>GC</code>의 실행 여부에 따른 상태를 출력하기 위해서 입니다.</p>\n</li>\n<li><p><code>console.log()</code>로 <code>newWeakMap</code>을 찍으면 두 가지 형태로 출력될 수 있습니다.<br><code>newWeakMap</code> 인스턴스의 <code>key</code>로 등록한 오브젝트가 메모리에서 삭제되면 <code>newWeakMap</code> 인스턴스의 <code>[key, value]</code>가 삭제되므로 빈 Object 오브젝트 {}가 출력됩니다. 메모리에서 삭제되지 않은 상태라면, <code>newWeakMap</code> 인스턴스에 <code>[key, value]</code>가 남아 있으므로 <code>1: WeakMap {Object {item: “weakmap”} =&gt; “GC”}</code> 형태로 출력됩니다.</p>\n</li>\n<li><p><code>newMap</code> 인스턴스는 <code>GC</code>의 영향을 받지 않으므로 항상 <code>Map {Object {item: “map”} =&gt; “keep”}</code> 형태로 출력됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>set-2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> sportsObj = &#123;&#125;;  </span><br><span class=\"line\">newWeakMap.set(sportsObj, <span class=\"string\">\"Object-1\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> sportsObj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> newWeakMap.set(sportsObj, <span class=\"string\">\"Object-2\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(newWeakMap);  </span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);  </span><br><span class=\"line\"><span class=\"comment\">// WeakMap &#123;Object &#123; &#125; =&gt; \"Object-2\"&#125; 또는  </span></span><br><span class=\"line\"><span class=\"comment\">// WeakMap &#123;Object &#123; &#125; =&gt; \"Object-2\"&#125;, WeakMap &#123;Object &#123; &#125; =&gt; \"Object-1\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><code>sportsObj</code> 변수에 <code>Object</code> 오브젝트를 생성하여 할당하고, <code>set( )</code>의 첫 번째 파라미터에 <code>sportsObj</code>를 지정하여 추가합니다.</p>\n</li>\n<li><p>새로운 <code>Object</code> 오브젝트를 생성하여 <code>sportsObj</code> 변수에 할당하므로 <code>sportsObj</code>가 참조하는 <code>메모리 주소</code>가 변경됩니다. <code>newWeakMap</code> 인스턴스에 <code>key</code>로 설정된 <code>sportsObj</code>가 참조하는 <code>Object</code> 오브젝트는 <code>GC</code> 대상이 됩니다.</p>\n</li>\n<li><p><code>set( )</code>의 첫 번째 파라미터에 <code>sportsObj</code>를 지정하여 설정합니다. <code>newWeakMap</code> 인스턴스에 <code>sportsObj</code>가 있지만, <code>sportsObj</code>가 참조하는 메모리 주소가 다르므로 추가됩니다. 따라서 <code>newWeakMap</code> 인스턴스에는 <code>sportsObj</code>가 참조하는 <code>Object</code> 오브젝트가 두 개 존재하게 됩니다. 개발자 도구에서 소스 코드에 중단점(<code>Break Point</code>)를 걸어 <code>newWeakMap</code> 인스턴스를 펼치면 두 개의 <code>Object</code> 오브젝트가 표시됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>set-3</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\">newWeakMap.set(fn, <span class=\"string\">\"함수\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">newWeakMap.set(fn, <span class=\"string\">\"value 변경\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newWeakMap);  </span><br><span class=\"line\"><span class=\"comment\">// WeakMap &#123;function =&gt; \"value 변경\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>function</code> 오브젝트를 생성하여 <code>변수 fn</code>에 할당한 후, <code>set()</code>에서 <code>key</code>로 지정하여 <code>newWeakMap</code>에 추가합니다.<br><code>function</code> 오브젝트도 오브젝트이므로 <code>WeakMap</code> 인스턴스에 설정할 수 있습니다.</p>\n</li>\n<li><p><code>set( )</code>의 첫 번째 파라미터에 <code>fn</code>을 지정하여 <code>newWeakMap</code> 인스턴스에 설정합니다. <code>fn</code>이 참조하는 <code>메모리 주소</code>가 같으므로 추가하지 않고 두 번째 파라미터 값으로 <code>value</code>를 변경합니다. <code>newWeakMap</code> 인스턴스에 <code>[key, value]</code>가 하나만 존재합니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"WeakMap_get\">get(): key가 같은 value 반환</h2>\n\n<p><strong><code>WeakMap</code> 인스턴스에서 지정한 <code>key</code>의 <code>value</code>를 반환합니다.</strong></p>\n<blockquote>\n<p>WeakMap.prototype.get()</p>\n</blockquote>\n<ul>\n<li><p>파라미터<br>WeakMap 인스턴스의 key와 비교할 오브젝트를 지정합니다.</p>\n</li>\n<li><p>반환 값<br>key가 존재하면 value를 반환하고, 존재하지 않으면 undefined를 반환합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>get()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;  </span><br><span class=\"line\">newWeakMap.set(obj, <span class=\"string\">\"오브젝트\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newWeakMap.get(obj));  </span><br><span class=\"line\"><span class=\"comment\">// 오브젝트</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>obj</code> 변수에 Object 오브젝트를 생성하여 할당하고, 이를 <code>key</code>로 하여 <code>newWeakMap</code> 인스턴스에 추가합니다. <code>value</code> 값은 “오브젝트”입니다.<br><code>get()</code> 파라미터에 오브젝트를 지정합니다. <code>newWeakMap</code> 인스턴스에 파라미터로 지정한 <code>obj</code> 오브젝트가 존재하므로 <code>[key, value]</code>에서 <code>value</code>를 반환합니다.</li>\n</ul>\n<hr>\n<h2 id=\"WeakMap_has\">has(): key 존재 여부</h2>\n\n<p><strong><code>WeakMap</code> 인스턴스에서 <code>key</code> 존재 여부를 반환합니다. <code>true/false</code></strong></p>\n<blockquote>\n<p>WeakMap.prototype.has()</p>\n</blockquote>\n<p>파라미터에 WeakMap 인스턴스의 key와 비교할 오브젝트를 지정합니다. 오브젝트가 존재하면 <code>true</code>, 아니면 <code>false</code>를 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>has()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;  </span><br><span class=\"line\">newWeakMap.set(obj, <span class=\"string\">\"오브젝트\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newWeakMap.has(obj));  </span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Object 오브젝트를 생성하여 obj 변수에 할당하고, 이를 key로 하여 newWeakMap 인스턴스에 설정합니다. value값은 “오브젝트”입니다.<br>newWeakMap 인스턴스에 has()파라미터에 지정한 obj 오브젝트가 존재하므로 true가 출력됩니다.</li>\n</ul>\n<hr>\n<h2 id=\"WeakMap_delete\">delete(): 엘리먼트 삭제</h2>\n\n<p><strong><code>WeakMap</code> 인스턴스에서 <code>key</code>가 같은 엘리먼트를 삭제합니다.</strong></p>\n<blockquote>\n<p>WeakMap.prototype.delete()</p>\n</blockquote>\n<p>파라미터의 WeakMap 인스턴스의 key와 비교할 오브젝트를 지정합니다. <code>key</code>가 존재하면 <code>[key, value]</code>를 삭제하고 <code>true</code>를 반환합니다. 존재하지 않으면 <code>false</code>를 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>delete()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;  </span><br><span class=\"line\">newWeakMap.set(obj, <span class=\"string\">\"오브젝트\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newWeakMap.delete(obj));  </span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Object</code> 오브젝트를 생성하여 <code>obj</code> 변수에 할당하고, 이를 <code>key</code>로 하여 <code>newWeakMap</code>에 추가한 상태에서 위 코드를 실행합니다. <code>delete()</code> 파라미터에 <code>key</code>로 등록된 <code>obj</code> 오브젝트를 지정했으므로 <code>[key, value]</code>가 삭제됩니다. 또한, 삭제에 성공했으므로 true를 반환합니다. <code>newWeakMap</code> 인스턴스에서 삭제하는 것이지 <code>obj</code>에서 참조하는 메모리의 <code>Object 오브젝트{}</code>가 삭제되는 것은 아닙니다.</p>\n","site":{"data":{}},"excerpt":"<ul>\n<li><p>WeakMap 오브젝트</p>\n<ul>\n<li><a href=\"/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap\">개요</a><ul>\n<li>GC(Garbage Collection)</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#newWeakMap\">new WeakMap 인스턴스 생성</a></li>\n<li><a href=\"/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_set\">set(): key, value 설정</a></li>\n<li><a href=\"/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_get\">get(): key가 같은 value 반환</a></li>\n<li><a href=\"/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_has\">has(): key 존재 여부</a></li>\n<li><a href=\"/2020/04/13/WeakMap%20오브젝트%20-ECMAScript/#WeakMap_delete\">delete(): 엘리먼트 삭제</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"WeakMap\">개요</h2>\n\n<p><code>WeakMap</code>는 약한(weak) Map 오브젝트 입니다.<br><code>Map</code> 오브젝트와 작성 방법과 형태는 같지만, 약한 점이 있습니다.</p>\n<ul>\n<li><p><code>WeakMap</code> 오브젝트는 <code>key</code>에 <code>Object</code>만 작성할 수 있으며 <code>string</code>, <code>numbers</code>, <code>symbol</code> 등의 (원시 데이터형)은 허용되지 않습니다.</p>\n</li>\n<li><p><code>value</code>는 타입에 제한이 없습니다.</p>\n</li>\n<li><p><code>key</code>에 오브젝트만 지정할 수 있는 것이 중요하며, 그 이유를 이해하는 것이 <code>WeakMap</code> 오브젝트의 사용 핵심입니다.</p>\n<ul>\n<li>ex) let music = {title: “음악”} 코드를 실행하면 music 변수에 Object 오브젝트를 생성하여 할당합니다.<br>다시 music 변수에 {singer: “가수”}를 할당하면 {title: “음악”}을 사용할 수 없게 됩니다.<br>당연한 예시지만, 이로 인해 발생하는 문제를 해결하기 위한 것이 WeakMap 오브젝트의 목적입니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GC-Garbage-Collection\"><a href=\"#GC-Garbage-Collection\" class=\"headerlink\" title=\"GC(Garbage Collection)\"></a>GC(Garbage Collection)</h3><figure class=\"highlight js\"><figcaption><span>GC</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> music = &#123;<span class=\"attr\">title</span>: <span class=\"string\">\"음악\"</span>&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> music = &#123;<span class=\"attr\">singer</span>: <span class=\"string\">\"가수\"</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>생성된 <code>Object 오브젝트</code>가 메모리에 설정되며, 메모리 주소가 <code>music 변수</code>에 할당됩니다.<br><code>music</code>을 전개하면 <code>{title: “음악”}</code>이 전개됩니다.<br><code>music</code>을 전개하다는 것은 <code>music</code> 변수에 <code>설정된 메모리 주소의 오브젝트</code>를 전개하는 것입니다.</p>\n</li>\n<li><p><code>music = {singer: “가수”}</code>도 <code>Object 오브젝트</code>를 생성하여 메모리에 설정합니다. 생성한 Object 오브젝트를 <code>music 변수</code>에 할당하므로 <code>music 변수의 메모리 주소</code>가 바뀌게 됩니다.<br>즉, <code>{title: “음악”}</code>을 사용할 수 없게 됩니다.</p>\n</li>\n</ol>\n<p><strong>이때 엔진은 사용하지 않는 {title: “음악”}을 메모리에서 지웁니다.</strong><br><mark>이를 GC(Garbage Collection)라고 하고, GC를 수행하는 것을 Garbage Collector라고 합니다.<br>GC를 하지 않으면 사용하지 않는 메모리가 쌓이게 됩니다. 즉 메모리 릭(Memory Leak)이 발생합니다.</mark></p>\n<p><code>GC</code>가 사용하지 않게 된 오브젝트를 메모리에서 지우면, <code>WeakMap</code> 인스턴스의 <code>key</code>에서 오브젝트를 참조할 수 없게됩니다. 메모리에 존재하지 않는 오브젝트를 참조하는 것은 문제가 됩니다. 이때, 엔진이 <code>WeakMap</code> 인스턴스의 <code>key</code> 와 <code>value</code>를 삭제합니다. 개발자 코드로 삭제하지 않아도 됩니다. 이런 점을 반영한 것이 <code>WeakMap</code> 오브젝트입니다.</p>\n<p><code>WeakMap</code> 오브젝트에서 제공하는 메서드는 간단합니다.<br><code>set()</code>, <code>get()</code>, <code>has()</code>, <code>delete()</code>만 있습니다. <code>WeakMap</code> 인스턴스에 <code>[key, value]</code>를 <code>CRUD</code>(Create, Read, Update, Delete)하기 위한 기본적인 메서드만 있습니다.<br><code>WeakMap</code> 인스턴스는 열거할 수 없습니다. 그러므로 <code>forEach(), entries()</code> 메서드가 없습니다.</p>\n<p><code>Map</code> 오브젝트는 <code>size</code> 프로퍼티가 있어 현재의 <code>[key, value]</code> 수를 알 수 있으나, <code>WeakMap</code> 오브젝트는 <code>size</code> 프로퍼티가 없어서 현재의 <code>[key, value]</code> 수를 알 수 없습니다. <code>length</code> 프로퍼티도 <del>개발자 도구에서는 표시되나</del> 실제로 사용하면 <code>undefined</code>를 반환합니다.</p>\n<hr>\n<h2 id=\"newWeakMap\">new WeakMap 인스턴스 생성</h2>\n\n<p><strong><code>WeakMap</code> 인스턴스를 생성하여 반환합니다.</strong></p>\n<blockquote>\n<p>new WeakMap()</p>\n</blockquote>\n<ul>\n<li><p>선택적 파라미터<br>Object, 이터러블 오브젝트안에 작성 [key, value] 형태</p>\n</li>\n<li><p>반환<br>생성한 WeakMap 인스턴스</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> emptyWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> newWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>([  </span><br><span class=\"line\"> [obj, <span class=\"string\">\"오브젝트\"</span>]  </span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>WeakMap()</code>에 파라미터를 작성하지 않아도 <code>WeakMap</code> 인스턴스를 생성할 수 있습니다.<br>이는 상황에 따라 엘리먼트를 추가하려는 의도입니다.</p>\n</li>\n<li><p><code>WeakMap()</code> 파라미터에 이터러블 오브젝트를 작성하고 그 안에 <code>[key, value]</code> 형태로 작성합니다.<br><code>key</code>에 오브젝트 이름을 지정하고 <code>value</code>에 값을 작성합니다. <code>key</code>인 오브젝트 자체에 프로퍼티가 있으므로 <code>value</code>는 오브젝트에 대한 <code>주석(설명)</code>이라고 볼 수 있습니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"WeakMap_set\">set(): key, value 설정</h2>\n\n<p><strong><code>WeakMap</code> 인스턴스에 <code>key</code> 와 <code>value</code>를 설정합니다.</strong></p>\n<blockquote>\n<p>WeakMap.prototype.set()</p>\n</blockquote>\n<ul>\n<li><p>파라미터</p>\n<ul>\n<li>Object (key, Object/Function 등의 오브젝트)</li>\n<li>any (value)</li>\n</ul>\n</li>\n<li><p>반환<br>key, value가 추가된 WeakMap 인스턴스</p>\n</li>\n</ul>\n<p>첫 번째 파라미터에 <code>key</code>로 설정될 <code>Object, Function</code>과 같은 오브젝트를 지정합니다.<br><code>string</code>, <code>numbers</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>symbol</code>을 지정하면 에러가 발생합니다.<br>두 번째 파라미터에 임의의 값을 작성합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>set-1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">debugger</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> newWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();  </span><br><span class=\"line\"><span class=\"number\">1.</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"weakmap\"</span>&#125;;  </span><br><span class=\"line\"> newWeakMap.set(obj, <span class=\"string\">\"GC\"</span>);  </span><br><span class=\"line\">&#125;());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> newMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();  </span><br><span class=\"line\"><span class=\"number\">2.</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"map\"</span>&#125;;  </span><br><span class=\"line\"> newMap.set(obj, <span class=\"string\">\"Keep\"</span>);  </span><br><span class=\"line\">&#125;());  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, newWeakMap);  </span><br><span class=\"line\"> <span class=\"number\">5</span> .console.log(<span class=\"string\">\"2:\"</span>, newMap);  </span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);  </span><br><span class=\"line\"><span class=\"comment\">// 1: WeakMap &#123;Object &#123;item: \"weakmap\"&#125; =&gt; \"GC\"&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// 2: Map &#123;Object &#123;item: \"map\"&#125; =&gt; \"keep\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>위 코드는 상황에 따라 실행 결과가 다르게 출력될 수 있습니다.<br>개발자 도구에서 <code>Sources</code>로 들어가 <code>.js파일</code>을 선택해 소스 코드를 화면에 표시하고<br>F5를 눌러 새로고침 합니다. 소스 코드 두 번째 줄에 <code>debugger</code>를 작성했으므로 이 앞에서 멈추게 됩니다.<br><code>debugger</code>로 멈춘 시점에서 한 줄씩 소스 코드를 이동하면, 실행 결과의 1번 형태로 출력되지 않고, <code>“WeakMap {}”</code> 형태가 출력될 수 있습니다. 이는 소스 코드를 한 줄씩 따라 가는 동안 <code>GC</code>가 실행되어 <code>WeakMap</code> 인스턴스의 <code>[key, value]</code>를 삭제하기 때문입니다.</li>\n</ul>\n<ol>\n<li><p><code>(function(){코드});</code> 형태는 자동으로 함수가 실행됩니다. 함수를 저장하지 않고 한 번만 사용하려는 것이 목적입니다. 함수 실행이 끝나 함수를 빠져나오면 함수에서 선언한 변수가 저장되지 않으므로 다시 사용할 수 없습니다. 이렇게 사용하지 않게 된 것을 <code>Garbage Collector</code>가 메모리에서 삭제합니다.<br><code>newWeakMap.set(obj, “GC”)</code>을 실행하면, <code>obj</code> 오브젝트를 참조하는 메모리 주소가 <code>newWeakMap</code> 인스턴스의 <code>key</code>에 설정됩니다. 함수 실행이 끝나 함수를 빠져나오면 함수블록의 <code>obj</code> 변수가 메모리에서 삭제됩니다. 따라서 <code>newWeakMap</code> 인스턴스의 <code>key</code>에서 <code>obj</code> 오브젝트를 참조할 수 없게 됩니다.<br>이때, <code>obj</code> 변수에서 참조하는 <code>{item: “weakmap”}</code>이 메모리에서 지워지면 <code>newWeakMap</code> 인스턴스의 <code>[key, value]</code>를 삭제합니다. 이것이 <code>WeakMap</code> 오브젝트의 목적입니다.</p>\n</li>\n<li><p>위의 1번 코드와 같은 형식이며 <code>WeakMap</code>이 아닌 <code>Map</code>을 사용한 것이 다릅니다.<br>함수를 빠져나오면 <code>obj</code> 오브젝트를 참조하는 <code>Map</code> 인스턴스 <code>[key, value]</code>를 삭제하지 않고 유지합니다.<br>이점이 <code>WeakMap</code> 과 <code>Map</code>의 차이입니다.</p>\n</li>\n<li><p>1초 후에 <code>setTimeout</code> 콜백 함수를 실행하게 됩니다. 1초 간격을 둔 것은 <code>GC</code>의 실행 여부에 따른 상태를 출력하기 위해서 입니다.</p>\n</li>\n<li><p><code>console.log()</code>로 <code>newWeakMap</code>을 찍으면 두 가지 형태로 출력될 수 있습니다.<br><code>newWeakMap</code> 인스턴스의 <code>key</code>로 등록한 오브젝트가 메모리에서 삭제되면 <code>newWeakMap</code> 인스턴스의 <code>[key, value]</code>가 삭제되므로 빈 Object 오브젝트 {}가 출력됩니다. 메모리에서 삭제되지 않은 상태라면, <code>newWeakMap</code> 인스턴스에 <code>[key, value]</code>가 남아 있으므로 <code>1: WeakMap {Object {item: “weakmap”} =&gt; “GC”}</code> 형태로 출력됩니다.</p>\n</li>\n<li><p><code>newMap</code> 인스턴스는 <code>GC</code>의 영향을 받지 않으므로 항상 <code>Map {Object {item: “map”} =&gt; “keep”}</code> 형태로 출력됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>set-2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> sportsObj = &#123;&#125;;  </span><br><span class=\"line\">newWeakMap.set(sportsObj, <span class=\"string\">\"Object-1\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> sportsObj = &#123;&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> newWeakMap.set(sportsObj, <span class=\"string\">\"Object-2\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(newWeakMap);  </span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);  </span><br><span class=\"line\"><span class=\"comment\">// WeakMap &#123;Object &#123; &#125; =&gt; \"Object-2\"&#125; 또는  </span></span><br><span class=\"line\"><span class=\"comment\">// WeakMap &#123;Object &#123; &#125; =&gt; \"Object-2\"&#125;, WeakMap &#123;Object &#123; &#125; =&gt; \"Object-1\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><code>sportsObj</code> 변수에 <code>Object</code> 오브젝트를 생성하여 할당하고, <code>set( )</code>의 첫 번째 파라미터에 <code>sportsObj</code>를 지정하여 추가합니다.</p>\n</li>\n<li><p>새로운 <code>Object</code> 오브젝트를 생성하여 <code>sportsObj</code> 변수에 할당하므로 <code>sportsObj</code>가 참조하는 <code>메모리 주소</code>가 변경됩니다. <code>newWeakMap</code> 인스턴스에 <code>key</code>로 설정된 <code>sportsObj</code>가 참조하는 <code>Object</code> 오브젝트는 <code>GC</code> 대상이 됩니다.</p>\n</li>\n<li><p><code>set( )</code>의 첫 번째 파라미터에 <code>sportsObj</code>를 지정하여 설정합니다. <code>newWeakMap</code> 인스턴스에 <code>sportsObj</code>가 있지만, <code>sportsObj</code>가 참조하는 메모리 주소가 다르므로 추가됩니다. 따라서 <code>newWeakMap</code> 인스턴스에는 <code>sportsObj</code>가 참조하는 <code>Object</code> 오브젝트가 두 개 존재하게 됩니다. 개발자 도구에서 소스 코드에 중단점(<code>Break Point</code>)를 걸어 <code>newWeakMap</code> 인스턴스를 펼치면 두 개의 <code>Object</code> 오브젝트가 표시됩니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>set-3</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\">newWeakMap.set(fn, <span class=\"string\">\"함수\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">newWeakMap.set(fn, <span class=\"string\">\"value 변경\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newWeakMap);  </span><br><span class=\"line\"><span class=\"comment\">// WeakMap &#123;function =&gt; \"value 변경\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>function</code> 오브젝트를 생성하여 <code>변수 fn</code>에 할당한 후, <code>set()</code>에서 <code>key</code>로 지정하여 <code>newWeakMap</code>에 추가합니다.<br><code>function</code> 오브젝트도 오브젝트이므로 <code>WeakMap</code> 인스턴스에 설정할 수 있습니다.</p>\n</li>\n<li><p><code>set( )</code>의 첫 번째 파라미터에 <code>fn</code>을 지정하여 <code>newWeakMap</code> 인스턴스에 설정합니다. <code>fn</code>이 참조하는 <code>메모리 주소</code>가 같으므로 추가하지 않고 두 번째 파라미터 값으로 <code>value</code>를 변경합니다. <code>newWeakMap</code> 인스턴스에 <code>[key, value]</code>가 하나만 존재합니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"WeakMap_get\">get(): key가 같은 value 반환</h2>\n\n<p><strong><code>WeakMap</code> 인스턴스에서 지정한 <code>key</code>의 <code>value</code>를 반환합니다.</strong></p>\n<blockquote>\n<p>WeakMap.prototype.get()</p>\n</blockquote>\n<ul>\n<li><p>파라미터<br>WeakMap 인스턴스의 key와 비교할 오브젝트를 지정합니다.</p>\n</li>\n<li><p>반환 값<br>key가 존재하면 value를 반환하고, 존재하지 않으면 undefined를 반환합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>get()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;  </span><br><span class=\"line\">newWeakMap.set(obj, <span class=\"string\">\"오브젝트\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newWeakMap.get(obj));  </span><br><span class=\"line\"><span class=\"comment\">// 오브젝트</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>obj</code> 변수에 Object 오브젝트를 생성하여 할당하고, 이를 <code>key</code>로 하여 <code>newWeakMap</code> 인스턴스에 추가합니다. <code>value</code> 값은 “오브젝트”입니다.<br><code>get()</code> 파라미터에 오브젝트를 지정합니다. <code>newWeakMap</code> 인스턴스에 파라미터로 지정한 <code>obj</code> 오브젝트가 존재하므로 <code>[key, value]</code>에서 <code>value</code>를 반환합니다.</li>\n</ul>\n<hr>\n<h2 id=\"WeakMap_has\">has(): key 존재 여부</h2>\n\n<p><strong><code>WeakMap</code> 인스턴스에서 <code>key</code> 존재 여부를 반환합니다. <code>true/false</code></strong></p>\n<blockquote>\n<p>WeakMap.prototype.has()</p>\n</blockquote>\n<p>파라미터에 WeakMap 인스턴스의 key와 비교할 오브젝트를 지정합니다. 오브젝트가 존재하면 <code>true</code>, 아니면 <code>false</code>를 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>has()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;  </span><br><span class=\"line\">newWeakMap.set(obj, <span class=\"string\">\"오브젝트\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newWeakMap.has(obj));  </span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Object 오브젝트를 생성하여 obj 변수에 할당하고, 이를 key로 하여 newWeakMap 인스턴스에 설정합니다. value값은 “오브젝트”입니다.<br>newWeakMap 인스턴스에 has()파라미터에 지정한 obj 오브젝트가 존재하므로 true가 출력됩니다.</li>\n</ul>\n<hr>\n<h2 id=\"WeakMap_delete\">delete(): 엘리먼트 삭제</h2>\n\n<p><strong><code>WeakMap</code> 인스턴스에서 <code>key</code>가 같은 엘리먼트를 삭제합니다.</strong></p>\n<blockquote>\n<p>WeakMap.prototype.delete()</p>\n</blockquote>\n<p>파라미터의 WeakMap 인스턴스의 key와 비교할 오브젝트를 지정합니다. <code>key</code>가 존재하면 <code>[key, value]</code>를 삭제하고 <code>true</code>를 반환합니다. 존재하지 않으면 <code>false</code>를 반환합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>delete()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newWeakMap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;  </span><br><span class=\"line\">newWeakMap.set(obj, <span class=\"string\">\"오브젝트\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newWeakMap.delete(obj));  </span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Object</code> 오브젝트를 생성하여 <code>obj</code> 변수에 할당하고, 이를 <code>key</code>로 하여 <code>newWeakMap</code>에 추가한 상태에서 위 코드를 실행합니다. <code>delete()</code> 파라미터에 <code>key</code>로 등록된 <code>obj</code> 오브젝트를 지정했으므로 <code>[key, value]</code>가 삭제됩니다. 또한, 삭제에 성공했으므로 true를 반환합니다. <code>newWeakMap</code> 인스턴스에서 삭제하는 것이지 <code>obj</code>에서 참조하는 메모리의 <code>Object 오브젝트{}</code>가 삭제되는 것은 아닙니다.</p>"},{"title":"WeakSet 오브젝트 -ECMAScript","date":"2020-04-13T23:55:14.000Z","disqusId":"tunas-blog-1","_content":"\nvalue로 오브젝트만 사용하는 WeakSet\n\n*   WeakSet\n    \n    *   [개요](/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet)\n    *   [new WeakSet(): WeakSet 인스턴스 생성](/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#newWeakSet)\n    *   [add(): value 추가](/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet_add)\n    *   [has(): value 존재 여부](/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet_has)\n    *   [delete(): 엘리먼트 삭제](/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet_delete)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"WeakSet\">개요</h2>\n\nWeakSet 오브젝트는 value로 오브젝트만 사용할 수 있으며, string, number, symbol과 같은 값을 사용할 수 없습니다. key는 사용하지 않습니다.\n\nWeakMap 인스턴스와 마찬가지로 GC(Garbage Collection)가 발생하면 WeakSet 인스턴스의 value가 삭제됩니다.  \n<mark>WeakMap 오브젝트는 key가 기준이고 WeakSet 오브젝트는 value가 기준입니다.</mark>\n\n* * *\n\n<h2 id=\"newWeakSet\">new WeakSet(): WeakSet 인스턴스 생성</h2>\n\nWeakSet 인스턴스를 생성하여 반환합니다.\n\n> new WeakSet()\n\n*   파라미터는 선택으로 이터러블 오브젝트를 작성하고, 그 안에 오브젝트를 지정합니다.  \n    지정한 오브젝트가 value에 설정됩니다.\n\n```js new WeakSet\n1. let newString = new String(\"문자열\");  \nlet newNumber = new Number(12345);  \nconst newWeakSet = new WeakSet([newString, newNumber]);  \n  \n2. try {  \n new WeakSet([\"ABC\", 345]);  \n} catch (e) {  \n console.log(\"object 이외 지정 불가\");  \n};  \n// object 이외 지정 불가  \n```\n\n1.  String 인스턴스와 Number 인스턴스를 생성합니다. WeakSet 인스턴스를 생성하면서 파라미터에 이터러블 오브젝트를 작성하고, 그 안에 String 인스턴스와 Number 인스턴스를 지정합니다. 각 인스턴스의 메모리 주소가 WeakSet 인스턴스의 value로 설정됩니다.\n\n2.  newWeakSet() 파라미터에 문자열(“ABC”) 또는 숫자(345)를 작성하면 에러가 발생합니다.  \n    Object, Function과 같은 오브젝트만 지정할 수 있습니다.\n\n* * *\n\n<h2 id=\"WeakSet_add\">add(): value 추가</h2>\n\nWeakSet 인스턴스에 value 를 추가합니다.\n\n> WeakSet.prototype.add()\n\n파라미터에 value로 설정될 오브젝트를 지정합니다. Object, Function과 같은 오브젝트를 지정할 수 있습니다.  \n~~string, number, boolean, null, undefined, symbol을 작성하면 에러가 발생합니다.~~\n\n```js add()\nconst newWeakSet = new WeakSet();  \n  \n1. let newString = new String(\"문자열\");  \nnewWeakSet.add(newString);  \n  \n2. let obj = {sports: \"스포츠\"};  \nnewWeakSet.add(obj); \n``` \n\n1.  <mark>new String()으로 인스턴스를 생성하여 변수에 할당한 후, add() 파라미터에 지정하면 newWeakSet 인스턴스에 value로 추가됩니다.</mark> 문자열을 String 인스턴스로 생성하여 지정하였습니다.\n\n2.  Object 오브젝트를 생성하여 변수에 할당하고 add() 파라미터에 지정하면 newWeakSet 인스턴스에 value로 추가됩니다.\n\n* * *\n\n<h2 id=\"WeakSet_has\">has(): value 존재 여부</h2>\n\nWeakSet 인스턴스x에서 value 존재 여부를 체크하여 반환합니다.\n\n> WeakSet.prototype.has()\n\n*   파라미터에 WeakSet 인스턴스의 value와 비교할 오브젝트를 지정합니다. 오브젝트가 존재하면 true를 반환하고,  \n    존재하지 않으면 false를 반환합니다.\n\n```js has()\nlet newString = new String(\"문자열\");  \nconst newWeakSet = new WeakSet([newString]);  \n  \nconsole.log(newWeakSet.has(newString));  \n//true  \n```\n\n*   has() 파라미터에 지정한 newString 인스턴스가 newWeakSet 인스턴스의 value에 있으므로 true를 반환합니다.\n\n* * *\n\n<h2 id=\"WeakSet_delete\">delete(): 엘리먼트 삭제</h2>\n\nWeakSet 인스턴스에서 value가 같은 엘리먼트를 삭제합니다.\n\n> WeakSet.prototype.delete()\n\n*   파라미터에 WeakSet 인스턴스에서 삭제할 오브젝트를 지정합니다. 오브젝트가 존재하면 value를 삭제하고 true를 반환합니다. 존재하지 않으면 false를 반환합니다.\n\n```js delete()\nlet newString = new String(\"문자열\");  \nconst newWeakSet = new WeakSet([newString]);  \n  \nconsole.log(newWeakSet.delete(newString));  \nconsole.log(newWeakSet.has(newString));  \n// true  \n// false  \n```\n\n*   new String()으로 인스턴스를 생성하여 newWeakSet 인스턴스에 추가한 상태입니다.  \n    delete() 파라미터에 newWeakSet 인스턴스에 존재하는 newString 인스턴스를 지정해 줬으므로 삭제하고 true를 반환합니다. 삭제가 완료되었으므로 has()로 존재 여부를 체크해보면 당연히 false를 반환하게 됩니다.\n","source":"_posts/WeakSet 오브젝트 -ECMAScript.md","raw":"---\ntitle: WeakSet 오브젝트 -ECMAScript\ndate: 2020-04-14 08:55:14\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\nvalue로 오브젝트만 사용하는 WeakSet\n\n*   WeakSet\n    \n    *   [개요](/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet)\n    *   [new WeakSet(): WeakSet 인스턴스 생성](/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#newWeakSet)\n    *   [add(): value 추가](/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet_add)\n    *   [has(): value 존재 여부](/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet_has)\n    *   [delete(): 엘리먼트 삭제](/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet_delete)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"WeakSet\">개요</h2>\n\nWeakSet 오브젝트는 value로 오브젝트만 사용할 수 있으며, string, number, symbol과 같은 값을 사용할 수 없습니다. key는 사용하지 않습니다.\n\nWeakMap 인스턴스와 마찬가지로 GC(Garbage Collection)가 발생하면 WeakSet 인스턴스의 value가 삭제됩니다.  \n<mark>WeakMap 오브젝트는 key가 기준이고 WeakSet 오브젝트는 value가 기준입니다.</mark>\n\n* * *\n\n<h2 id=\"newWeakSet\">new WeakSet(): WeakSet 인스턴스 생성</h2>\n\nWeakSet 인스턴스를 생성하여 반환합니다.\n\n> new WeakSet()\n\n*   파라미터는 선택으로 이터러블 오브젝트를 작성하고, 그 안에 오브젝트를 지정합니다.  \n    지정한 오브젝트가 value에 설정됩니다.\n\n```js new WeakSet\n1. let newString = new String(\"문자열\");  \nlet newNumber = new Number(12345);  \nconst newWeakSet = new WeakSet([newString, newNumber]);  \n  \n2. try {  \n new WeakSet([\"ABC\", 345]);  \n} catch (e) {  \n console.log(\"object 이외 지정 불가\");  \n};  \n// object 이외 지정 불가  \n```\n\n1.  String 인스턴스와 Number 인스턴스를 생성합니다. WeakSet 인스턴스를 생성하면서 파라미터에 이터러블 오브젝트를 작성하고, 그 안에 String 인스턴스와 Number 인스턴스를 지정합니다. 각 인스턴스의 메모리 주소가 WeakSet 인스턴스의 value로 설정됩니다.\n\n2.  newWeakSet() 파라미터에 문자열(“ABC”) 또는 숫자(345)를 작성하면 에러가 발생합니다.  \n    Object, Function과 같은 오브젝트만 지정할 수 있습니다.\n\n* * *\n\n<h2 id=\"WeakSet_add\">add(): value 추가</h2>\n\nWeakSet 인스턴스에 value 를 추가합니다.\n\n> WeakSet.prototype.add()\n\n파라미터에 value로 설정될 오브젝트를 지정합니다. Object, Function과 같은 오브젝트를 지정할 수 있습니다.  \n~~string, number, boolean, null, undefined, symbol을 작성하면 에러가 발생합니다.~~\n\n```js add()\nconst newWeakSet = new WeakSet();  \n  \n1. let newString = new String(\"문자열\");  \nnewWeakSet.add(newString);  \n  \n2. let obj = {sports: \"스포츠\"};  \nnewWeakSet.add(obj); \n``` \n\n1.  <mark>new String()으로 인스턴스를 생성하여 변수에 할당한 후, add() 파라미터에 지정하면 newWeakSet 인스턴스에 value로 추가됩니다.</mark> 문자열을 String 인스턴스로 생성하여 지정하였습니다.\n\n2.  Object 오브젝트를 생성하여 변수에 할당하고 add() 파라미터에 지정하면 newWeakSet 인스턴스에 value로 추가됩니다.\n\n* * *\n\n<h2 id=\"WeakSet_has\">has(): value 존재 여부</h2>\n\nWeakSet 인스턴스x에서 value 존재 여부를 체크하여 반환합니다.\n\n> WeakSet.prototype.has()\n\n*   파라미터에 WeakSet 인스턴스의 value와 비교할 오브젝트를 지정합니다. 오브젝트가 존재하면 true를 반환하고,  \n    존재하지 않으면 false를 반환합니다.\n\n```js has()\nlet newString = new String(\"문자열\");  \nconst newWeakSet = new WeakSet([newString]);  \n  \nconsole.log(newWeakSet.has(newString));  \n//true  \n```\n\n*   has() 파라미터에 지정한 newString 인스턴스가 newWeakSet 인스턴스의 value에 있으므로 true를 반환합니다.\n\n* * *\n\n<h2 id=\"WeakSet_delete\">delete(): 엘리먼트 삭제</h2>\n\nWeakSet 인스턴스에서 value가 같은 엘리먼트를 삭제합니다.\n\n> WeakSet.prototype.delete()\n\n*   파라미터에 WeakSet 인스턴스에서 삭제할 오브젝트를 지정합니다. 오브젝트가 존재하면 value를 삭제하고 true를 반환합니다. 존재하지 않으면 false를 반환합니다.\n\n```js delete()\nlet newString = new String(\"문자열\");  \nconst newWeakSet = new WeakSet([newString]);  \n  \nconsole.log(newWeakSet.delete(newString));  \nconsole.log(newWeakSet.has(newString));  \n// true  \n// false  \n```\n\n*   new String()으로 인스턴스를 생성하여 newWeakSet 인스턴스에 추가한 상태입니다.  \n    delete() 파라미터에 newWeakSet 인스턴스에 존재하는 newString 인스턴스를 지정해 줬으므로 삭제하고 true를 반환합니다. 삭제가 완료되었으므로 has()로 존재 여부를 체크해보면 당연히 false를 반환하게 됩니다.\n","slug":"WeakSet 오브젝트 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrt20025qgvqe70m7uyv","content":"<p>value로 오브젝트만 사용하는 WeakSet</p>\n<ul>\n<li><p>WeakSet</p>\n<ul>\n<li><a href=\"/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet\">개요</a></li>\n<li><a href=\"/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#newWeakSet\">new WeakSet(): WeakSet 인스턴스 생성</a></li>\n<li><a href=\"/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet_add\">add(): value 추가</a></li>\n<li><a href=\"/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet_has\">has(): value 존재 여부</a></li>\n<li><a href=\"/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet_delete\">delete(): 엘리먼트 삭제</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"WeakSet\">개요</h2>\n\n<p>WeakSet 오브젝트는 value로 오브젝트만 사용할 수 있으며, string, number, symbol과 같은 값을 사용할 수 없습니다. key는 사용하지 않습니다.</p>\n<p>WeakMap 인스턴스와 마찬가지로 GC(Garbage Collection)가 발생하면 WeakSet 인스턴스의 value가 삭제됩니다.<br><mark>WeakMap 오브젝트는 key가 기준이고 WeakSet 오브젝트는 value가 기준입니다.</mark></p>\n<hr>\n<h2 id=\"newWeakSet\">new WeakSet(): WeakSet 인스턴스 생성</h2>\n\n<p>WeakSet 인스턴스를 생성하여 반환합니다.</p>\n<blockquote>\n<p>new WeakSet()</p>\n</blockquote>\n<ul>\n<li>파라미터는 선택으로 이터러블 오브젝트를 작성하고, 그 안에 오브젝트를 지정합니다.<br>지정한 오브젝트가 value에 설정됩니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>new WeakSet</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> newString = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">\"문자열\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> newNumber = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">12345</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> newWeakSet = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>([newString, newNumber]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>([<span class=\"string\">\"ABC\"</span>, <span class=\"number\">345</span>]);  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"object 이외 지정 불가\"</span>);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// object 이외 지정 불가</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>String 인스턴스와 Number 인스턴스를 생성합니다. WeakSet 인스턴스를 생성하면서 파라미터에 이터러블 오브젝트를 작성하고, 그 안에 String 인스턴스와 Number 인스턴스를 지정합니다. 각 인스턴스의 메모리 주소가 WeakSet 인스턴스의 value로 설정됩니다.</p>\n</li>\n<li><p>newWeakSet() 파라미터에 문자열(“ABC”) 또는 숫자(345)를 작성하면 에러가 발생합니다.<br>Object, Function과 같은 오브젝트만 지정할 수 있습니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"WeakSet_add\">add(): value 추가</h2>\n\n<p>WeakSet 인스턴스에 value 를 추가합니다.</p>\n<blockquote>\n<p>WeakSet.prototype.add()</p>\n</blockquote>\n<p>파라미터에 value로 설정될 오브젝트를 지정합니다. Object, Function과 같은 오브젝트를 지정할 수 있습니다.<br><del>string, number, boolean, null, undefined, symbol을 작성하면 에러가 발생합니다.</del></p>\n<figure class=\"highlight js\"><figcaption><span>add()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newWeakSet = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> newString = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">\"문자열\"</span>);  </span><br><span class=\"line\">newWeakSet.add(newString);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">sports</span>: <span class=\"string\">\"스포츠\"</span>&#125;;  </span><br><span class=\"line\">newWeakSet.add(obj); </span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1.  &lt;mark&gt;new String()으로 인스턴스를 생성하여 변수에 할당한 후, add() 파라미터에 지정하면 newWeakSet 인스턴스에 value로 추가됩니다.&lt;/mark&gt; 문자열을 String 인스턴스로 생성하여 지정하였습니다.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">2.  Object 오브젝트를 생성하여 변수에 할당하고 add() 파라미터에 지정하면 newWeakSet 인스턴스에 value로 추가됩니다.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* * *</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&lt;h2 id=\"WeakSet_has\"&gt;has(): value 존재 여부&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">WeakSet 인스턴스x에서 value 존재 여부를 체크하여 반환합니다.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&gt; WeakSet.prototype.has()</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">*   파라미터에 WeakSet 인스턴스의 value와 비교할 오브젝트를 지정합니다. 오브젝트가 존재하면 true를 반환하고,  </span></span><br><span class=\"line\"><span class=\"string\">    존재하지 않으면 false를 반환합니다.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js has()</span><br><span class=\"line\"><span class=\"keyword\">let</span> newString = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">\"문자열\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> newWeakSet = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>([newString]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newWeakSet.has(newString));  </span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>has() 파라미터에 지정한 newString 인스턴스가 newWeakSet 인스턴스의 value에 있으므로 true를 반환합니다.</li>\n</ul>\n<hr>\n<h2 id=\"WeakSet_delete\">delete(): 엘리먼트 삭제</h2>\n\n<p>WeakSet 인스턴스에서 value가 같은 엘리먼트를 삭제합니다.</p>\n<blockquote>\n<p>WeakSet.prototype.delete()</p>\n</blockquote>\n<ul>\n<li>파라미터에 WeakSet 인스턴스에서 삭제할 오브젝트를 지정합니다. 오브젝트가 존재하면 value를 삭제하고 true를 반환합니다. 존재하지 않으면 false를 반환합니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>delete()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newString = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">\"문자열\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> newWeakSet = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>([newString]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newWeakSet.delete(newString));  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newWeakSet.has(newString));  </span><br><span class=\"line\"><span class=\"comment\">// true  </span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>new String()으로 인스턴스를 생성하여 newWeakSet 인스턴스에 추가한 상태입니다.<br>delete() 파라미터에 newWeakSet 인스턴스에 존재하는 newString 인스턴스를 지정해 줬으므로 삭제하고 true를 반환합니다. 삭제가 완료되었으므로 has()로 존재 여부를 체크해보면 당연히 false를 반환하게 됩니다.</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>value로 오브젝트만 사용하는 WeakSet</p>\n<ul>\n<li><p>WeakSet</p>\n<ul>\n<li><a href=\"/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet\">개요</a></li>\n<li><a href=\"/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#newWeakSet\">new WeakSet(): WeakSet 인스턴스 생성</a></li>\n<li><a href=\"/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet_add\">add(): value 추가</a></li>\n<li><a href=\"/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet_has\">has(): value 존재 여부</a></li>\n<li><a href=\"/2020/04/14/WeakSet%20오브젝트%20-ECMAScript/#WeakSet_delete\">delete(): 엘리먼트 삭제</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"WeakSet\">개요</h2>\n\n<p>WeakSet 오브젝트는 value로 오브젝트만 사용할 수 있으며, string, number, symbol과 같은 값을 사용할 수 없습니다. key는 사용하지 않습니다.</p>\n<p>WeakMap 인스턴스와 마찬가지로 GC(Garbage Collection)가 발생하면 WeakSet 인스턴스의 value가 삭제됩니다.<br><mark>WeakMap 오브젝트는 key가 기준이고 WeakSet 오브젝트는 value가 기준입니다.</mark></p>\n<hr>\n<h2 id=\"newWeakSet\">new WeakSet(): WeakSet 인스턴스 생성</h2>\n\n<p>WeakSet 인스턴스를 생성하여 반환합니다.</p>\n<blockquote>\n<p>new WeakSet()</p>\n</blockquote>\n<ul>\n<li>파라미터는 선택으로 이터러블 오브젝트를 작성하고, 그 안에 오브젝트를 지정합니다.<br>지정한 오브젝트가 value에 설정됩니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>new WeakSet</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> newString = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">\"문자열\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> newNumber = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">12345</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> newWeakSet = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>([newString, newNumber]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>([<span class=\"string\">\"ABC\"</span>, <span class=\"number\">345</span>]);  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"object 이외 지정 불가\"</span>);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// object 이외 지정 불가</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>String 인스턴스와 Number 인스턴스를 생성합니다. WeakSet 인스턴스를 생성하면서 파라미터에 이터러블 오브젝트를 작성하고, 그 안에 String 인스턴스와 Number 인스턴스를 지정합니다. 각 인스턴스의 메모리 주소가 WeakSet 인스턴스의 value로 설정됩니다.</p>\n</li>\n<li><p>newWeakSet() 파라미터에 문자열(“ABC”) 또는 숫자(345)를 작성하면 에러가 발생합니다.<br>Object, Function과 같은 오브젝트만 지정할 수 있습니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"WeakSet_add\">add(): value 추가</h2>\n\n<p>WeakSet 인스턴스에 value 를 추가합니다.</p>\n<blockquote>\n<p>WeakSet.prototype.add()</p>\n</blockquote>\n<p>파라미터에 value로 설정될 오브젝트를 지정합니다. Object, Function과 같은 오브젝트를 지정할 수 있습니다.<br><del>string, number, boolean, null, undefined, symbol을 작성하면 에러가 발생합니다.</del></p>\n<figure class=\"highlight js\"><figcaption><span>add()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newWeakSet = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> newString = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">\"문자열\"</span>);  </span><br><span class=\"line\">newWeakSet.add(newString);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">sports</span>: <span class=\"string\">\"스포츠\"</span>&#125;;  </span><br><span class=\"line\">newWeakSet.add(obj); </span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1.  &lt;mark&gt;new String()으로 인스턴스를 생성하여 변수에 할당한 후, add() 파라미터에 지정하면 newWeakSet 인스턴스에 value로 추가됩니다.&lt;/mark&gt; 문자열을 String 인스턴스로 생성하여 지정하였습니다.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">2.  Object 오브젝트를 생성하여 변수에 할당하고 add() 파라미터에 지정하면 newWeakSet 인스턴스에 value로 추가됩니다.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* * *</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&lt;h2 id=\"WeakSet_has\"&gt;has(): value 존재 여부&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">WeakSet 인스턴스x에서 value 존재 여부를 체크하여 반환합니다.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&gt; WeakSet.prototype.has()</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">*   파라미터에 WeakSet 인스턴스의 value와 비교할 오브젝트를 지정합니다. 오브젝트가 존재하면 true를 반환하고,  </span></span><br><span class=\"line\"><span class=\"string\">    존재하지 않으면 false를 반환합니다.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js has()</span><br><span class=\"line\"><span class=\"keyword\">let</span> newString = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">\"문자열\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> newWeakSet = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>([newString]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newWeakSet.has(newString));  </span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>has() 파라미터에 지정한 newString 인스턴스가 newWeakSet 인스턴스의 value에 있으므로 true를 반환합니다.</li>\n</ul>\n<hr>\n<h2 id=\"WeakSet_delete\">delete(): 엘리먼트 삭제</h2>\n\n<p>WeakSet 인스턴스에서 value가 같은 엘리먼트를 삭제합니다.</p>\n<blockquote>\n<p>WeakSet.prototype.delete()</p>\n</blockquote>\n<ul>\n<li>파라미터에 WeakSet 인스턴스에서 삭제할 오브젝트를 지정합니다. 오브젝트가 존재하면 value를 삭제하고 true를 반환합니다. 존재하지 않으면 false를 반환합니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>delete()</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newString = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">\"문자열\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">const</span> newWeakSet = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>([newString]);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newWeakSet.delete(newString));  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newWeakSet.has(newString));  </span><br><span class=\"line\"><span class=\"comment\">// true  </span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>new String()으로 인스턴스를 생성하여 newWeakSet 인스턴스에 추가한 상태입니다.<br>delete() 파라미터에 newWeakSet 인스턴스에 존재하는 newString 인스턴스를 지정해 줬으므로 삭제하고 true를 반환합니다. 삭제가 완료되었으므로 has()로 존재 여부를 체크해보면 당연히 false를 반환하게 됩니다.</li>\n</ul>"},{"title":"return 문,재귀 함수 호출 -JavaScript","date":"2020-03-09T01:25:56.000Z","disqusId":"tunas-blog-1","_content":"\nreturn 문 이란 함수에서 결과값을 되돌려 줄 때 사용합니다.  \n함수에서 return 문이 실행되면  \n반복문에 break문과 비슷하게 실행문이 강제 종료됩니다.\n\n    기본형\n    function 함수명(){\n        실행문;\n        return 데이터(값);\n    }\n\n```js 예시1\nfunction calc(){  \n var result=100+200  \n return result; // calc값에 300을 반환합니다.  \n}  \nvar num = calc();  \ndocument.write(num);  \n```\n\n```js 예시2\nfunction test(){  \n document.write(\"html\");  \n return;  \n // 다음 실행문은 실행되지 않습니다.  \n document.write(\"javascript\");  \n}  \nmyFnc();  \n```\n<!-- more -->\n\n* * *\n\n### 재귀 함수 호출\n\n함수 정의문 내에서 실행문으로 함수를 다시 호출하는 것을  \n재귀 함수 호출 이라고 합니다.  \n**함수를 반복문 처럼 여러번 호출하기 위해 사용합니다.**\n\n    기본형\n        function myFnc(){\n        실행문;\n        myFnc();\n    }\n    myFnc();\n\n```js 예제\nvar num=0;  \nfunction testFnc(){  \n num++; //num의 데이터가 1씩 증가됩니다.  \n document.write(num, \"<br />\"); //출력  \n if(num==10) return; // num값이 10이라면 종료됩니다.  \n    \n testFnc(); // 아니라면 다시 testFnc함수를 호출합니다.   \n}   \ntestFnc(); //testFnc 함수를 호출합니다.  \n```\n\n","source":"_posts/return 문, 재귀함수 호출 -JavaScript.md","raw":"---\ntitle: return 문,재귀 함수 호출 -JavaScript\ndate: 2020-03-09 10:25:56\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\nreturn 문 이란 함수에서 결과값을 되돌려 줄 때 사용합니다.  \n함수에서 return 문이 실행되면  \n반복문에 break문과 비슷하게 실행문이 강제 종료됩니다.\n\n    기본형\n    function 함수명(){\n        실행문;\n        return 데이터(값);\n    }\n\n```js 예시1\nfunction calc(){  \n var result=100+200  \n return result; // calc값에 300을 반환합니다.  \n}  \nvar num = calc();  \ndocument.write(num);  \n```\n\n```js 예시2\nfunction test(){  \n document.write(\"html\");  \n return;  \n // 다음 실행문은 실행되지 않습니다.  \n document.write(\"javascript\");  \n}  \nmyFnc();  \n```\n<!-- more -->\n\n* * *\n\n### 재귀 함수 호출\n\n함수 정의문 내에서 실행문으로 함수를 다시 호출하는 것을  \n재귀 함수 호출 이라고 합니다.  \n**함수를 반복문 처럼 여러번 호출하기 위해 사용합니다.**\n\n    기본형\n        function myFnc(){\n        실행문;\n        myFnc();\n    }\n    myFnc();\n\n```js 예제\nvar num=0;  \nfunction testFnc(){  \n num++; //num의 데이터가 1씩 증가됩니다.  \n document.write(num, \"<br />\"); //출력  \n if(num==10) return; // num값이 10이라면 종료됩니다.  \n    \n testFnc(); // 아니라면 다시 testFnc함수를 호출합니다.   \n}   \ntestFnc(); //testFnc 함수를 호출합니다.  \n```\n\n","slug":"return 문, 재귀함수 호출 -JavaScript","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrt30028qgvqhqecfxum","content":"<p>return 문 이란 함수에서 결과값을 되돌려 줄 때 사용합니다.<br>함수에서 return 문이 실행되면<br>반복문에 break문과 비슷하게 실행문이 강제 종료됩니다.</p>\n<pre><code>기본형\nfunction 함수명(){\n    실행문;\n    return 데이터(값);\n}</code></pre><figure class=\"highlight js\"><figcaption><span>예시1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calc</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> result=<span class=\"number\">100</span>+<span class=\"number\">200</span>  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> result; <span class=\"comment\">// calc값에 300을 반환합니다.  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> num = calc();  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(num);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>예시2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"string\">\"html\"</span>);  </span><br><span class=\"line\"> <span class=\"keyword\">return</span>;  </span><br><span class=\"line\"> <span class=\"comment\">// 다음 실행문은 실행되지 않습니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"string\">\"javascript\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">myFnc();</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n\n<hr>\n<h3 id=\"재귀-함수-호출\"><a href=\"#재귀-함수-호출\" class=\"headerlink\" title=\"재귀 함수 호출\"></a>재귀 함수 호출</h3><p>함수 정의문 내에서 실행문으로 함수를 다시 호출하는 것을<br>재귀 함수 호출 이라고 합니다.<br><strong>함수를 반복문 처럼 여러번 호출하기 위해 사용합니다.</strong></p>\n<pre><code>기본형\n    function myFnc(){\n    실행문;\n    myFnc();\n}\nmyFnc();</code></pre><figure class=\"highlight js\"><figcaption><span>예제</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num=<span class=\"number\">0</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testFnc</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> num++; <span class=\"comment\">//num의 데이터가 1씩 증가됩니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(num, <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">//출력  </span></span><br><span class=\"line\"> <span class=\"keyword\">if</span>(num==<span class=\"number\">10</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">// num값이 10이라면 종료됩니다.  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"> testFnc(); <span class=\"comment\">// 아니라면 다시 testFnc함수를 호출합니다.   </span></span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">testFnc(); <span class=\"comment\">//testFnc 함수를 호출합니다.</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>return 문 이란 함수에서 결과값을 되돌려 줄 때 사용합니다.<br>함수에서 return 문이 실행되면<br>반복문에 break문과 비슷하게 실행문이 강제 종료됩니다.</p>\n<pre><code>기본형\nfunction 함수명(){\n    실행문;\n    return 데이터(값);\n}</code></pre><figure class=\"highlight js\"><figcaption><span>예시1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calc</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> result=<span class=\"number\">100</span>+<span class=\"number\">200</span>  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> result; <span class=\"comment\">// calc값에 300을 반환합니다.  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> num = calc();  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(num);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>예시2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"string\">\"html\"</span>);  </span><br><span class=\"line\"> <span class=\"keyword\">return</span>;  </span><br><span class=\"line\"> <span class=\"comment\">// 다음 실행문은 실행되지 않습니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"string\">\"javascript\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">myFnc();</span><br></pre></td></tr></table></figure>","more":"<hr>\n<h3 id=\"재귀-함수-호출\"><a href=\"#재귀-함수-호출\" class=\"headerlink\" title=\"재귀 함수 호출\"></a>재귀 함수 호출</h3><p>함수 정의문 내에서 실행문으로 함수를 다시 호출하는 것을<br>재귀 함수 호출 이라고 합니다.<br><strong>함수를 반복문 처럼 여러번 호출하기 위해 사용합니다.</strong></p>\n<pre><code>기본형\n    function myFnc(){\n    실행문;\n    myFnc();\n}\nmyFnc();</code></pre><figure class=\"highlight js\"><figcaption><span>예제</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num=<span class=\"number\">0</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testFnc</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> num++; <span class=\"comment\">//num의 데이터가 1씩 증가됩니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(num, <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">//출력  </span></span><br><span class=\"line\"> <span class=\"keyword\">if</span>(num==<span class=\"number\">10</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">// num값이 10이라면 종료됩니다.  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"> testFnc(); <span class=\"comment\">// 아니라면 다시 testFnc함수를 호출합니다.   </span></span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">testFnc(); <span class=\"comment\">//testFnc 함수를 호출합니다.</span></span><br></pre></td></tr></table></figure>"},{"title":"function (함수) -JavaScript","date":"2020-03-08T23:53:26.000Z","disqusId":"tunas-blog-1","_content":"\n데이터를 저장할 때는 변수를 선언하여 저장했습니다.  \n하지만 변수에는 데이터만 저장할 수 있고,  \n실행문을 저장할 수 없습니다.  \n함수를 사용하면 실행문을 메모리에 저장했다가  \n필요할 때 마다 호출하여 사용할 수 있습니다.\n\n<!-- more -->\n\n* * *\n\n### 함수 정의문\n\n함수를 사용하여 실행문을 저장한 것을 함수 정의문이라고 합니다.\n\n함수를 정의하는 여러 방법이 있습니다:\n\n* * *\n\n#### 1.1 함수 선언 (function 문)\n\n> function name([param[, param[, … param]]]) {  \n> statements  \n> }\n\n*   name  \n    함수 이름.\n    \n*   param  \n    함수에 전달되는 인수의 이름. 함수는 255개까지 인수를 가질 수 있습니다.\n    \n*   statements  \n    함수의 몸통을 구성하는 문.\n    \n*   세미콜론은 실행 가능한 JavaScript 문을 분리하는 데 사용됩니다. 함수 선언은 실행 문이 아니므로 세미콜론으로 끝나는 것은 일반적이지 않습니다.\n    \n\n* * *\n\n#### 1.2 표현식\n\n표현식을 사용하여 정의 할 수도 있습니다.  \n함수 표현식은 변수에 저장 될 수 있습니다\n\n> var x = function (a, b) {return a * b};  \n> var z = x(4, 3); // 12\n\n함수 표현식이 변수에 저장된 후에는 변수를 함수로 사용할 수 있습니다.\n\n위의 함수는 실제로 익명 함수 (이름이없는 함수)입니다.  \n변수에 저장된 함수는 함수 이름이 필요하지 않습니다.  \n변수 이름을 사용하여 항상 호출됩니다.\n\n*   위의 함수는 실행 가능한 명령문의 일부이므로 세미콜론으로 끝납니다.\n\n* * *\n\n#### Self-invoking functions\n\n함수 표현식은 자기 호출을 할수 있습니다.  \n자체 호출 표현식은 호출되지 않고 자동으로 호출 (시작)됩니다.  \n표현식 뒤에 ()가 있으면 함수 표현식이 자동으로 실행됩니다.\n\n*   함수 선언을 자체 호출 할 수 없습니다. 함수 주위에 ()괄호를 추가하여 함수 표현식임을 표시해야합니다.\n\n> (function () {  \n> var x = “Hello!!”; // 자체 호출되어 실행됩니다.  \n> })();\n\n* * *\n\n#### Function Hoisting\n\n`Hoisting`은 변수 선언 및 함수 선언에 적용됩니다.  \n이 때문에 `JavaScript 함수`는 선언되기 전에 호출 할 수 있습니다.\n\n> myFunction(5);\n>function myFunction(y) {  \nreturn y * y;  \n}\n\n* * *\n\n#### Arrow Functions\n\n`Arrow` 함수는 함수 표현식 작성을위한 짧은 구문을 허용합니다.  \n`function`(함수) 키워드,  \n`return`(반환) 키워드 및 `{}`중괄호가 필요하지 않습니다.\n\n> // ES5  \n> var x = function(x, y) {  \n> return x * y;  \n> }  \n> // ES6  \n> const x = (x, y) => x * y;\n\n*   `Arrow` 함수는 `hoisting` 되지않습니다.  \n    반드시 사용하기 전에 정의해야합니다.  \n    또한 IE 11 이전 버젼에서는 사용할 수 없습니다.\n\n**함수 표현식은 항상 상수 값이므로**  \n**const를 사용하는 것이 var를 사용하는 것보다 안전합니다.**\n\n* * *\n\n### 내장 함수\n\n내장 함수는 자바스크립트 엔진에 내장된 함수 정의문을 말합니다.  \n정의문 선언 없이 단지 함수 호출만으로 사용 가능합니다.\n\n| 종류         | 설명                                                 | 예시                      |\n|--------------|------------------------------------------------------|---------------------------|\n| parseInt()   | 문자형 데이터를 정수형 데이터로 바꿉니다             | pareInt(“5.12”) = 5       |\n| parseFloat() | 문자형 데이터를 실수형 데이터로 바꿉니다             | parseFloat(“5.12”) = 5.12 |\n| String()     | 문자형 데이터로 바꿉니다                             | String(5) =”5”            |\n| Number()     | 숫자형 데이토로 바꿉니다                             | Number(“5”) = 5           |\n| Boolean()    | 논리형 데이터로 바꿉니다                             | Boolean(5) = true         |\n| isNaN()      | 데이터에 숫자가 아닌 문자를 포함하면 true값 반환     |                           |\n| eval()       | 문자형 데이터를 “”가 없는 스크립트 코드로 처리합니다 | eval(“15+5”) = 20         |\n","source":"_posts/function 함수 -JavaScript.md","raw":"---\ntitle: function (함수) -JavaScript\ndate: 2020-03-09 08:53:26\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\n데이터를 저장할 때는 변수를 선언하여 저장했습니다.  \n하지만 변수에는 데이터만 저장할 수 있고,  \n실행문을 저장할 수 없습니다.  \n함수를 사용하면 실행문을 메모리에 저장했다가  \n필요할 때 마다 호출하여 사용할 수 있습니다.\n\n<!-- more -->\n\n* * *\n\n### 함수 정의문\n\n함수를 사용하여 실행문을 저장한 것을 함수 정의문이라고 합니다.\n\n함수를 정의하는 여러 방법이 있습니다:\n\n* * *\n\n#### 1.1 함수 선언 (function 문)\n\n> function name([param[, param[, … param]]]) {  \n> statements  \n> }\n\n*   name  \n    함수 이름.\n    \n*   param  \n    함수에 전달되는 인수의 이름. 함수는 255개까지 인수를 가질 수 있습니다.\n    \n*   statements  \n    함수의 몸통을 구성하는 문.\n    \n*   세미콜론은 실행 가능한 JavaScript 문을 분리하는 데 사용됩니다. 함수 선언은 실행 문이 아니므로 세미콜론으로 끝나는 것은 일반적이지 않습니다.\n    \n\n* * *\n\n#### 1.2 표현식\n\n표현식을 사용하여 정의 할 수도 있습니다.  \n함수 표현식은 변수에 저장 될 수 있습니다\n\n> var x = function (a, b) {return a * b};  \n> var z = x(4, 3); // 12\n\n함수 표현식이 변수에 저장된 후에는 변수를 함수로 사용할 수 있습니다.\n\n위의 함수는 실제로 익명 함수 (이름이없는 함수)입니다.  \n변수에 저장된 함수는 함수 이름이 필요하지 않습니다.  \n변수 이름을 사용하여 항상 호출됩니다.\n\n*   위의 함수는 실행 가능한 명령문의 일부이므로 세미콜론으로 끝납니다.\n\n* * *\n\n#### Self-invoking functions\n\n함수 표현식은 자기 호출을 할수 있습니다.  \n자체 호출 표현식은 호출되지 않고 자동으로 호출 (시작)됩니다.  \n표현식 뒤에 ()가 있으면 함수 표현식이 자동으로 실행됩니다.\n\n*   함수 선언을 자체 호출 할 수 없습니다. 함수 주위에 ()괄호를 추가하여 함수 표현식임을 표시해야합니다.\n\n> (function () {  \n> var x = “Hello!!”; // 자체 호출되어 실행됩니다.  \n> })();\n\n* * *\n\n#### Function Hoisting\n\n`Hoisting`은 변수 선언 및 함수 선언에 적용됩니다.  \n이 때문에 `JavaScript 함수`는 선언되기 전에 호출 할 수 있습니다.\n\n> myFunction(5);\n>function myFunction(y) {  \nreturn y * y;  \n}\n\n* * *\n\n#### Arrow Functions\n\n`Arrow` 함수는 함수 표현식 작성을위한 짧은 구문을 허용합니다.  \n`function`(함수) 키워드,  \n`return`(반환) 키워드 및 `{}`중괄호가 필요하지 않습니다.\n\n> // ES5  \n> var x = function(x, y) {  \n> return x * y;  \n> }  \n> // ES6  \n> const x = (x, y) => x * y;\n\n*   `Arrow` 함수는 `hoisting` 되지않습니다.  \n    반드시 사용하기 전에 정의해야합니다.  \n    또한 IE 11 이전 버젼에서는 사용할 수 없습니다.\n\n**함수 표현식은 항상 상수 값이므로**  \n**const를 사용하는 것이 var를 사용하는 것보다 안전합니다.**\n\n* * *\n\n### 내장 함수\n\n내장 함수는 자바스크립트 엔진에 내장된 함수 정의문을 말합니다.  \n정의문 선언 없이 단지 함수 호출만으로 사용 가능합니다.\n\n| 종류         | 설명                                                 | 예시                      |\n|--------------|------------------------------------------------------|---------------------------|\n| parseInt()   | 문자형 데이터를 정수형 데이터로 바꿉니다             | pareInt(“5.12”) = 5       |\n| parseFloat() | 문자형 데이터를 실수형 데이터로 바꿉니다             | parseFloat(“5.12”) = 5.12 |\n| String()     | 문자형 데이터로 바꿉니다                             | String(5) =”5”            |\n| Number()     | 숫자형 데이토로 바꿉니다                             | Number(“5”) = 5           |\n| Boolean()    | 논리형 데이터로 바꿉니다                             | Boolean(5) = true         |\n| isNaN()      | 데이터에 숫자가 아닌 문자를 포함하면 true값 반환     |                           |\n| eval()       | 문자형 데이터를 “”가 없는 스크립트 코드로 처리합니다 | eval(“15+5”) = 20         |\n","slug":"function 함수 -JavaScript","published":1,"updated":"2020-05-08T11:13:46.119Z","_id":"ck9iqcrt4002bqgvq6jan5p5t","comments":1,"layout":"post","photos":[],"link":"","content":"<p>데이터를 저장할 때는 변수를 선언하여 저장했습니다.<br>하지만 변수에는 데이터만 저장할 수 있고,<br>실행문을 저장할 수 없습니다.<br>함수를 사용하면 실행문을 메모리에 저장했다가<br>필요할 때 마다 호출하여 사용할 수 있습니다.</p>\n<a id=\"more\"></a>\n\n<hr>\n<h3 id=\"함수-정의문\"><a href=\"#함수-정의문\" class=\"headerlink\" title=\"함수 정의문\"></a>함수 정의문</h3><p>함수를 사용하여 실행문을 저장한 것을 함수 정의문이라고 합니다.</p>\n<p>함수를 정의하는 여러 방법이 있습니다:</p>\n<hr>\n<h4 id=\"1-1-함수-선언-function-문\"><a href=\"#1-1-함수-선언-function-문\" class=\"headerlink\" title=\"1.1 함수 선언 (function 문)\"></a>1.1 함수 선언 (function 문)</h4><blockquote>\n<p>function name([param[, param[, … param]]]) {<br>statements<br>}</p>\n</blockquote>\n<ul>\n<li><p>name<br>함수 이름.</p>\n</li>\n<li><p>param<br>함수에 전달되는 인수의 이름. 함수는 255개까지 인수를 가질 수 있습니다.</p>\n</li>\n<li><p>statements<br>함수의 몸통을 구성하는 문.</p>\n</li>\n<li><p>세미콜론은 실행 가능한 JavaScript 문을 분리하는 데 사용됩니다. 함수 선언은 실행 문이 아니므로 세미콜론으로 끝나는 것은 일반적이지 않습니다.</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"1-2-표현식\"><a href=\"#1-2-표현식\" class=\"headerlink\" title=\"1.2 표현식\"></a>1.2 표현식</h4><p>표현식을 사용하여 정의 할 수도 있습니다.<br>함수 표현식은 변수에 저장 될 수 있습니다</p>\n<blockquote>\n<p>var x = function (a, b) {return a * b};<br>var z = x(4, 3); // 12</p>\n</blockquote>\n<p>함수 표현식이 변수에 저장된 후에는 변수를 함수로 사용할 수 있습니다.</p>\n<p>위의 함수는 실제로 익명 함수 (이름이없는 함수)입니다.<br>변수에 저장된 함수는 함수 이름이 필요하지 않습니다.<br>변수 이름을 사용하여 항상 호출됩니다.</p>\n<ul>\n<li>위의 함수는 실행 가능한 명령문의 일부이므로 세미콜론으로 끝납니다.</li>\n</ul>\n<hr>\n<h4 id=\"Self-invoking-functions\"><a href=\"#Self-invoking-functions\" class=\"headerlink\" title=\"Self-invoking functions\"></a>Self-invoking functions</h4><p>함수 표현식은 자기 호출을 할수 있습니다.<br>자체 호출 표현식은 호출되지 않고 자동으로 호출 (시작)됩니다.<br>표현식 뒤에 ()가 있으면 함수 표현식이 자동으로 실행됩니다.</p>\n<ul>\n<li>함수 선언을 자체 호출 할 수 없습니다. 함수 주위에 ()괄호를 추가하여 함수 표현식임을 표시해야합니다.</li>\n</ul>\n<blockquote>\n<p>(function () {<br>var x = “Hello!!”; // 자체 호출되어 실행됩니다.<br>})();</p>\n</blockquote>\n<hr>\n<h4 id=\"Function-Hoisting\"><a href=\"#Function-Hoisting\" class=\"headerlink\" title=\"Function Hoisting\"></a>Function Hoisting</h4><p><code>Hoisting</code>은 변수 선언 및 함수 선언에 적용됩니다.<br>이 때문에 <code>JavaScript 함수</code>는 선언되기 전에 호출 할 수 있습니다.</p>\n<blockquote>\n<p>myFunction(5);<br>function myFunction(y) {<br>return y * y;<br>}</p>\n</blockquote>\n<hr>\n<h4 id=\"Arrow-Functions\"><a href=\"#Arrow-Functions\" class=\"headerlink\" title=\"Arrow Functions\"></a>Arrow Functions</h4><p><code>Arrow</code> 함수는 함수 표현식 작성을위한 짧은 구문을 허용합니다.<br><code>function</code>(함수) 키워드,<br><code>return</code>(반환) 키워드 및 <code>{}</code>중괄호가 필요하지 않습니다.</p>\n<blockquote>\n<p>// ES5<br>var x = function(x, y) {<br>return x * y;<br>}<br>// ES6<br>const x = (x, y) =&gt; x * y;</p>\n</blockquote>\n<ul>\n<li><code>Arrow</code> 함수는 <code>hoisting</code> 되지않습니다.<br>반드시 사용하기 전에 정의해야합니다.<br>또한 IE 11 이전 버젼에서는 사용할 수 없습니다.</li>\n</ul>\n<p><strong>함수 표현식은 항상 상수 값이므로</strong><br><strong>const를 사용하는 것이 var를 사용하는 것보다 안전합니다.</strong></p>\n<hr>\n<h3 id=\"내장-함수\"><a href=\"#내장-함수\" class=\"headerlink\" title=\"내장 함수\"></a>내장 함수</h3><p>내장 함수는 자바스크립트 엔진에 내장된 함수 정의문을 말합니다.<br>정의문 선언 없이 단지 함수 호출만으로 사용 가능합니다.</p>\n<table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n<th>예시</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>parseInt()</td>\n<td>문자형 데이터를 정수형 데이터로 바꿉니다</td>\n<td>pareInt(“5.12”) = 5</td>\n</tr>\n<tr>\n<td>parseFloat()</td>\n<td>문자형 데이터를 실수형 데이터로 바꿉니다</td>\n<td>parseFloat(“5.12”) = 5.12</td>\n</tr>\n<tr>\n<td>String()</td>\n<td>문자형 데이터로 바꿉니다</td>\n<td>String(5) =”5”</td>\n</tr>\n<tr>\n<td>Number()</td>\n<td>숫자형 데이토로 바꿉니다</td>\n<td>Number(“5”) = 5</td>\n</tr>\n<tr>\n<td>Boolean()</td>\n<td>논리형 데이터로 바꿉니다</td>\n<td>Boolean(5) = true</td>\n</tr>\n<tr>\n<td>isNaN()</td>\n<td>데이터에 숫자가 아닌 문자를 포함하면 true값 반환</td>\n<td></td>\n</tr>\n<tr>\n<td>eval()</td>\n<td>문자형 데이터를 “”가 없는 스크립트 코드로 처리합니다</td>\n<td>eval(“15+5”) = 20</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<p>데이터를 저장할 때는 변수를 선언하여 저장했습니다.<br>하지만 변수에는 데이터만 저장할 수 있고,<br>실행문을 저장할 수 없습니다.<br>함수를 사용하면 실행문을 메모리에 저장했다가<br>필요할 때 마다 호출하여 사용할 수 있습니다.</p>","more":"<hr>\n<h3 id=\"함수-정의문\"><a href=\"#함수-정의문\" class=\"headerlink\" title=\"함수 정의문\"></a>함수 정의문</h3><p>함수를 사용하여 실행문을 저장한 것을 함수 정의문이라고 합니다.</p>\n<p>함수를 정의하는 여러 방법이 있습니다:</p>\n<hr>\n<h4 id=\"1-1-함수-선언-function-문\"><a href=\"#1-1-함수-선언-function-문\" class=\"headerlink\" title=\"1.1 함수 선언 (function 문)\"></a>1.1 함수 선언 (function 문)</h4><blockquote>\n<p>function name([param[, param[, … param]]]) {<br>statements<br>}</p>\n</blockquote>\n<ul>\n<li><p>name<br>함수 이름.</p>\n</li>\n<li><p>param<br>함수에 전달되는 인수의 이름. 함수는 255개까지 인수를 가질 수 있습니다.</p>\n</li>\n<li><p>statements<br>함수의 몸통을 구성하는 문.</p>\n</li>\n<li><p>세미콜론은 실행 가능한 JavaScript 문을 분리하는 데 사용됩니다. 함수 선언은 실행 문이 아니므로 세미콜론으로 끝나는 것은 일반적이지 않습니다.</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"1-2-표현식\"><a href=\"#1-2-표현식\" class=\"headerlink\" title=\"1.2 표현식\"></a>1.2 표현식</h4><p>표현식을 사용하여 정의 할 수도 있습니다.<br>함수 표현식은 변수에 저장 될 수 있습니다</p>\n<blockquote>\n<p>var x = function (a, b) {return a * b};<br>var z = x(4, 3); // 12</p>\n</blockquote>\n<p>함수 표현식이 변수에 저장된 후에는 변수를 함수로 사용할 수 있습니다.</p>\n<p>위의 함수는 실제로 익명 함수 (이름이없는 함수)입니다.<br>변수에 저장된 함수는 함수 이름이 필요하지 않습니다.<br>변수 이름을 사용하여 항상 호출됩니다.</p>\n<ul>\n<li>위의 함수는 실행 가능한 명령문의 일부이므로 세미콜론으로 끝납니다.</li>\n</ul>\n<hr>\n<h4 id=\"Self-invoking-functions\"><a href=\"#Self-invoking-functions\" class=\"headerlink\" title=\"Self-invoking functions\"></a>Self-invoking functions</h4><p>함수 표현식은 자기 호출을 할수 있습니다.<br>자체 호출 표현식은 호출되지 않고 자동으로 호출 (시작)됩니다.<br>표현식 뒤에 ()가 있으면 함수 표현식이 자동으로 실행됩니다.</p>\n<ul>\n<li>함수 선언을 자체 호출 할 수 없습니다. 함수 주위에 ()괄호를 추가하여 함수 표현식임을 표시해야합니다.</li>\n</ul>\n<blockquote>\n<p>(function () {<br>var x = “Hello!!”; // 자체 호출되어 실행됩니다.<br>})();</p>\n</blockquote>\n<hr>\n<h4 id=\"Function-Hoisting\"><a href=\"#Function-Hoisting\" class=\"headerlink\" title=\"Function Hoisting\"></a>Function Hoisting</h4><p><code>Hoisting</code>은 변수 선언 및 함수 선언에 적용됩니다.<br>이 때문에 <code>JavaScript 함수</code>는 선언되기 전에 호출 할 수 있습니다.</p>\n<blockquote>\n<p>myFunction(5);<br>function myFunction(y) {<br>return y * y;<br>}</p>\n</blockquote>\n<hr>\n<h4 id=\"Arrow-Functions\"><a href=\"#Arrow-Functions\" class=\"headerlink\" title=\"Arrow Functions\"></a>Arrow Functions</h4><p><code>Arrow</code> 함수는 함수 표현식 작성을위한 짧은 구문을 허용합니다.<br><code>function</code>(함수) 키워드,<br><code>return</code>(반환) 키워드 및 <code>{}</code>중괄호가 필요하지 않습니다.</p>\n<blockquote>\n<p>// ES5<br>var x = function(x, y) {<br>return x * y;<br>}<br>// ES6<br>const x = (x, y) =&gt; x * y;</p>\n</blockquote>\n<ul>\n<li><code>Arrow</code> 함수는 <code>hoisting</code> 되지않습니다.<br>반드시 사용하기 전에 정의해야합니다.<br>또한 IE 11 이전 버젼에서는 사용할 수 없습니다.</li>\n</ul>\n<p><strong>함수 표현식은 항상 상수 값이므로</strong><br><strong>const를 사용하는 것이 var를 사용하는 것보다 안전합니다.</strong></p>\n<hr>\n<h3 id=\"내장-함수\"><a href=\"#내장-함수\" class=\"headerlink\" title=\"내장 함수\"></a>내장 함수</h3><p>내장 함수는 자바스크립트 엔진에 내장된 함수 정의문을 말합니다.<br>정의문 선언 없이 단지 함수 호출만으로 사용 가능합니다.</p>\n<table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n<th>예시</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>parseInt()</td>\n<td>문자형 데이터를 정수형 데이터로 바꿉니다</td>\n<td>pareInt(“5.12”) = 5</td>\n</tr>\n<tr>\n<td>parseFloat()</td>\n<td>문자형 데이터를 실수형 데이터로 바꿉니다</td>\n<td>parseFloat(“5.12”) = 5.12</td>\n</tr>\n<tr>\n<td>String()</td>\n<td>문자형 데이터로 바꿉니다</td>\n<td>String(5) =”5”</td>\n</tr>\n<tr>\n<td>Number()</td>\n<td>숫자형 데이토로 바꿉니다</td>\n<td>Number(“5”) = 5</td>\n</tr>\n<tr>\n<td>Boolean()</td>\n<td>논리형 데이터로 바꿉니다</td>\n<td>Boolean(5) = true</td>\n</tr>\n<tr>\n<td>isNaN()</td>\n<td>데이터에 숫자가 아닌 문자를 포함하면 true값 반환</td>\n<td></td>\n</tr>\n<tr>\n<td>eval()</td>\n<td>문자형 데이터를 “”가 없는 스크립트 코드로 처리합니다</td>\n<td>eval(“15+5”) = 20</td>\n</tr>\n</tbody></table>"},{"title":"jQuery 이벤트 핸들러 -jQuery","date":"2020-03-12T01:40:59.000Z","disqusId":"tunas-blog-1","_content":"\njQuery에서의 이벤트 사용 기본형\n\n```html\n<a href=\"#\" id=\"btn\">버튼<a>  \n <script>  \n $(\"#btn\").click(function(){...})  \n </script>  \n```\n\n1.  $(“#btn”)    \n 이벤트 대상\n2.  click()    \n 이벤트 등록 메서드\n3.  function(){…}  \n    이벤트가 발생 했을 때 (이벤트 대상이 클릭되었을 때)  \n    실행되는 이벤트 핸들러\n\n<!-- more -->\n\n* * *\n\n## ready() / load() 메서드\n\nHTML 문서를 불러올 때 지정된 객체의 로딩이 완료되면  \n실행되는 이벤트 핸들러.\n\n    1. $(문서 객체).ready(function)(){...});\n    2. $(\"이미지 또는 프레임\").load(function(){...});\n\n*   1.  문서의 로딩이 완료된 후 실행됩니다.\n*   2. HTML 문서 로딩이 완료되더라도  \n    이미지나 프레임 소스는 그 이후에 로딩됩니다.\n    load() 메서드는 이런 이미지나 프레임에 연동된 소스가 로딩이  \n    완료된 후 실행됩니다.  \n    _이미지나 프레임을 제외한 객체에는 사용할 수 없습니다._\n    \n\n* * *\n\n## click() / dbclick() 메서드\n\n>1. $(\"요소 선택\").click(function(){...});\n>2. $(\"요소 선택\").click();\n\n1.  선택한 요소를 클릭할 때 마다 실행문을 실행합니다.\n    \n2.  선택한 요소에 강제로 click이벤트가 발생, 유저가 클릭하지 않아도 실행됩니다.\n    \n>3.  $(“요소 선택”).on(“dbclick”,function(){…});\n>4.  $(“요소 선택”).dbclick();\n\n3.  선택한 요소를 두번 연속으로 클릭했을 때 실행됩니다.\n    \n4.  강제로 더블클릭 이벤트가 발생합니다.\n    \n\n* * *\n\n## 이벤트 대상이 < a> 태그일 때\n\n< a>태그의 경우 클릭할 때 마다 링크된 주소로 이동됩니다.\n\n**링크된 주소로 이동되지 않도록 만드는 방법**\n\n1. return false  \n    return false를 이용하여 a 태그를 클릭 했을 때  \n    링크된 주소로 이동되는 것을 막을 수 있습니다.  \n    단 return은 function 실행문을 강제로 종료시키므로  \n    함수의 마지막 부분에 작성합니다.\n\n```js \n$(\"a\").click(function(){  \n ...실행문...  \n return false;  \n});  \n```\n\n2. preventDefault()  \n    function 매개변수에 .preventDefalut() 메서드를 사용하면  \n    링크된 주소로 이동되는 것을 막을 수 있습니다.\n\n```js\n$(\"a\").click(function(x){  \n x.preventDefalut();  \n //...실행문...  \n});  \n```\n\n* * *\n\n## mouseover() / mouseout() / hover() / mousemove()\n\n```js\n1. $(\"요소 선택\").mouseover(function(){...});  \n2. $(\"요소 선택\").mouseover();  \n  \n3. $(\"요소 선택\").mouseout(function(){...});  \n4. $(\"요소 선택\").mouseout();  \n  \n5. $(\"요소 선택\").hover(  \n function() {실행문1},  \n function() {실행문2}  \n);  \n  \n6. $(\"요소 선택\").mousemove(function(){...});  \n7. $(\"요소 선택\").mousemove();  \n```\n\n*   mouseover()\n    \n    1.  선택한 요소에 **마우스를 올릴 때 마다** 실행됩니다.\n    2.  선택한 요소에 강제로 mouseover 이벤트를 발생시킵니다.\n\n*   mouseout()\n\n    3.  선택한 요소에서 **마우스가 벗어날 때마다** 실행됩니다.\n    4.  선택한 요소에 강제로 mouseout 이벤트를 발생시킵니다.\n\n*   hover()\n\n    5.  마우스를 올릴 때 마다 {실행문1}을 실행시키고,  \n        마우스가 벗어날 때 마다 {실행문2}를 실행시킵니다.\n\n*   mousemove()\n\n    6.  선택한 **요소의 영역에서 마우스를 움직일 때 마다** 실행됩니다.\n    7.  선택한 요소에 강제로 mousemove 이벤트를 발생시킵니다.\n\n```js mousemove() 마우스 좌표값 구하기\n$(function(){  \n $(document).mousemove(function(e){ // document 영역내에서 마우스를 움직일때 마다 실행  \n var x=e.pageX; // X 좌표값 구하기  \n var y=e.pageY; // Y 좌표값 구하기  \n $(\"p\").text(\"x좌표값:\"+x+\"y좌표값:\"+y); // x,y 좌표값을 출력  \n });  \n});  \n```\n\n* * *\n\n## change() / index()\n\n```js\n1. $(\"요소 선택\").change(function(){...});  \n2. $(\"요소 선택\").change();  \n  \n3.$(\"요소 선택\").이벤트(function(){  \n $(\"요소 선택\").index(this);  \n});  \n```\n\n1.  요소의 값이(value) 새 값으로 바뀌고 포커스가 다른 요소로 이동  \n    되었을 때 실행됩니다.\n    \n2.  강제로 change 이벤트 메서드를 발생시킵니다.\n    \n3.  이벤트를 등록한 요소 중에서 이벤트가 발생한 요소의 인덱스 값을 반환합니다.\n    \n* * *\n\n## 그룹 이벤트 등록 및 삭제\n\n\n| 종류       | 설명                                                                                                             |\n|------------|------------------------------------------------------------------------------------------------------------------|\n| on()       | 여러 개의 이벤트를 등록할 때 사용합니다. 이벤트를 등록한 이후에 동일한 태그가 생성되어도 같이 이벤트 실행됩니다. |\n| bind()     | 선택 요소에 한 개 이상의 이벤트를 등록.                                                                          |\n| delegate() | 선택 요소의 하위 요소에 여러 개의 이벤트 등록. 등록 이후 생성된 동일한 요소에도 같이 이벤트 생성됩니다.          |\n| one()      | 한번 이벤트가 발생되면 자동으로 등록된 이벤트가 제거되어 한 번만 실행됩니다.                                     |\n| off()      | 선택한 요소에 등록된 이벤트를 제거합니다.                                                                        |\n| unbind()   | 선택한 요소에 등록된 이벤트를 제거합니다.                                                                        |\n\n```js 사용 ex)\n$(function(){  \n $(\"#btn\").on({  \n \"mouseover focus\":function(){  \n $(this).css(\"background-color\",\"yellow\");  \n }, // id 값 btn에 마우스가 올라가거나 포커스되면 배경색을 바꿉니다.  \n \"mouseout blur\":function(){  \n $(this).css(\"background-color\",\"red\");  \n } // id 값 btn에 마우스가 벗어나거나 포커스아웃 되면 배경색을 바꿉니다.  \n });  \n $(\"#btn\").append(\"<a href='#'>버튼2</a>\");  \n //id값 btn의 마지막에 새 요소 (a태그로 감싼 버튼2)를 추가했습니다.  \n // .on 이벤트로 적용된 이벤트가 그대로 적용됩니다.   \n});  \n```","source":"_posts/jQuery 이벤트 핸들러.md","raw":"---\ntitle: jQuery 이벤트 핸들러 -jQuery\ndate: 2020-03-12 10:40:59\ndisqusId: tunas-blog-1\ncategories: jQuery\ntag: \n- jQuery\n- JavaScript\n---\n\njQuery에서의 이벤트 사용 기본형\n\n```html\n<a href=\"#\" id=\"btn\">버튼<a>  \n <script>  \n $(\"#btn\").click(function(){...})  \n </script>  \n```\n\n1.  $(“#btn”)    \n 이벤트 대상\n2.  click()    \n 이벤트 등록 메서드\n3.  function(){…}  \n    이벤트가 발생 했을 때 (이벤트 대상이 클릭되었을 때)  \n    실행되는 이벤트 핸들러\n\n<!-- more -->\n\n* * *\n\n## ready() / load() 메서드\n\nHTML 문서를 불러올 때 지정된 객체의 로딩이 완료되면  \n실행되는 이벤트 핸들러.\n\n    1. $(문서 객체).ready(function)(){...});\n    2. $(\"이미지 또는 프레임\").load(function(){...});\n\n*   1.  문서의 로딩이 완료된 후 실행됩니다.\n*   2. HTML 문서 로딩이 완료되더라도  \n    이미지나 프레임 소스는 그 이후에 로딩됩니다.\n    load() 메서드는 이런 이미지나 프레임에 연동된 소스가 로딩이  \n    완료된 후 실행됩니다.  \n    _이미지나 프레임을 제외한 객체에는 사용할 수 없습니다._\n    \n\n* * *\n\n## click() / dbclick() 메서드\n\n>1. $(\"요소 선택\").click(function(){...});\n>2. $(\"요소 선택\").click();\n\n1.  선택한 요소를 클릭할 때 마다 실행문을 실행합니다.\n    \n2.  선택한 요소에 강제로 click이벤트가 발생, 유저가 클릭하지 않아도 실행됩니다.\n    \n>3.  $(“요소 선택”).on(“dbclick”,function(){…});\n>4.  $(“요소 선택”).dbclick();\n\n3.  선택한 요소를 두번 연속으로 클릭했을 때 실행됩니다.\n    \n4.  강제로 더블클릭 이벤트가 발생합니다.\n    \n\n* * *\n\n## 이벤트 대상이 < a> 태그일 때\n\n< a>태그의 경우 클릭할 때 마다 링크된 주소로 이동됩니다.\n\n**링크된 주소로 이동되지 않도록 만드는 방법**\n\n1. return false  \n    return false를 이용하여 a 태그를 클릭 했을 때  \n    링크된 주소로 이동되는 것을 막을 수 있습니다.  \n    단 return은 function 실행문을 강제로 종료시키므로  \n    함수의 마지막 부분에 작성합니다.\n\n```js \n$(\"a\").click(function(){  \n ...실행문...  \n return false;  \n});  \n```\n\n2. preventDefault()  \n    function 매개변수에 .preventDefalut() 메서드를 사용하면  \n    링크된 주소로 이동되는 것을 막을 수 있습니다.\n\n```js\n$(\"a\").click(function(x){  \n x.preventDefalut();  \n //...실행문...  \n});  \n```\n\n* * *\n\n## mouseover() / mouseout() / hover() / mousemove()\n\n```js\n1. $(\"요소 선택\").mouseover(function(){...});  \n2. $(\"요소 선택\").mouseover();  \n  \n3. $(\"요소 선택\").mouseout(function(){...});  \n4. $(\"요소 선택\").mouseout();  \n  \n5. $(\"요소 선택\").hover(  \n function() {실행문1},  \n function() {실행문2}  \n);  \n  \n6. $(\"요소 선택\").mousemove(function(){...});  \n7. $(\"요소 선택\").mousemove();  \n```\n\n*   mouseover()\n    \n    1.  선택한 요소에 **마우스를 올릴 때 마다** 실행됩니다.\n    2.  선택한 요소에 강제로 mouseover 이벤트를 발생시킵니다.\n\n*   mouseout()\n\n    3.  선택한 요소에서 **마우스가 벗어날 때마다** 실행됩니다.\n    4.  선택한 요소에 강제로 mouseout 이벤트를 발생시킵니다.\n\n*   hover()\n\n    5.  마우스를 올릴 때 마다 {실행문1}을 실행시키고,  \n        마우스가 벗어날 때 마다 {실행문2}를 실행시킵니다.\n\n*   mousemove()\n\n    6.  선택한 **요소의 영역에서 마우스를 움직일 때 마다** 실행됩니다.\n    7.  선택한 요소에 강제로 mousemove 이벤트를 발생시킵니다.\n\n```js mousemove() 마우스 좌표값 구하기\n$(function(){  \n $(document).mousemove(function(e){ // document 영역내에서 마우스를 움직일때 마다 실행  \n var x=e.pageX; // X 좌표값 구하기  \n var y=e.pageY; // Y 좌표값 구하기  \n $(\"p\").text(\"x좌표값:\"+x+\"y좌표값:\"+y); // x,y 좌표값을 출력  \n });  \n});  \n```\n\n* * *\n\n## change() / index()\n\n```js\n1. $(\"요소 선택\").change(function(){...});  \n2. $(\"요소 선택\").change();  \n  \n3.$(\"요소 선택\").이벤트(function(){  \n $(\"요소 선택\").index(this);  \n});  \n```\n\n1.  요소의 값이(value) 새 값으로 바뀌고 포커스가 다른 요소로 이동  \n    되었을 때 실행됩니다.\n    \n2.  강제로 change 이벤트 메서드를 발생시킵니다.\n    \n3.  이벤트를 등록한 요소 중에서 이벤트가 발생한 요소의 인덱스 값을 반환합니다.\n    \n* * *\n\n## 그룹 이벤트 등록 및 삭제\n\n\n| 종류       | 설명                                                                                                             |\n|------------|------------------------------------------------------------------------------------------------------------------|\n| on()       | 여러 개의 이벤트를 등록할 때 사용합니다. 이벤트를 등록한 이후에 동일한 태그가 생성되어도 같이 이벤트 실행됩니다. |\n| bind()     | 선택 요소에 한 개 이상의 이벤트를 등록.                                                                          |\n| delegate() | 선택 요소의 하위 요소에 여러 개의 이벤트 등록. 등록 이후 생성된 동일한 요소에도 같이 이벤트 생성됩니다.          |\n| one()      | 한번 이벤트가 발생되면 자동으로 등록된 이벤트가 제거되어 한 번만 실행됩니다.                                     |\n| off()      | 선택한 요소에 등록된 이벤트를 제거합니다.                                                                        |\n| unbind()   | 선택한 요소에 등록된 이벤트를 제거합니다.                                                                        |\n\n```js 사용 ex)\n$(function(){  \n $(\"#btn\").on({  \n \"mouseover focus\":function(){  \n $(this).css(\"background-color\",\"yellow\");  \n }, // id 값 btn에 마우스가 올라가거나 포커스되면 배경색을 바꿉니다.  \n \"mouseout blur\":function(){  \n $(this).css(\"background-color\",\"red\");  \n } // id 값 btn에 마우스가 벗어나거나 포커스아웃 되면 배경색을 바꿉니다.  \n });  \n $(\"#btn\").append(\"<a href='#'>버튼2</a>\");  \n //id값 btn의 마지막에 새 요소 (a태그로 감싼 버튼2)를 추가했습니다.  \n // .on 이벤트로 적용된 이벤트가 그대로 적용됩니다.   \n});  \n```","slug":"jQuery 이벤트 핸들러","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrt6002eqgvqfnvr1i8m","content":"<p>jQuery에서의 이벤트 사용 기본형</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"btn\"</span>&gt;</span>버튼<span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span>  </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"javascript\"> $(<span class=\"string\">\"#btn\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;)  </span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>$(“#btn”)<br>이벤트 대상</li>\n<li>click()<br>이벤트 등록 메서드</li>\n<li>function(){…}<br>이벤트가 발생 했을 때 (이벤트 대상이 클릭되었을 때)<br>실행되는 이벤트 핸들러</li>\n</ol>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"ready-load-메서드\"><a href=\"#ready-load-메서드\" class=\"headerlink\" title=\"ready() / load() 메서드\"></a>ready() / load() 메서드</h2><p>HTML 문서를 불러올 때 지정된 객체의 로딩이 완료되면<br>실행되는 이벤트 핸들러.</p>\n<pre><code>1. $(문서 객체).ready(function)(){...});\n2. $(&quot;이미지 또는 프레임&quot;).load(function(){...});</code></pre><ul>\n<li><ol>\n<li>문서의 로딩이 완료된 후 실행됩니다.</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>HTML 문서 로딩이 완료되더라도<br>이미지나 프레임 소스는 그 이후에 로딩됩니다.<br>load() 메서드는 이런 이미지나 프레임에 연동된 소스가 로딩이<br>완료된 후 실행됩니다.<br><em>이미지나 프레임을 제외한 객체에는 사용할 수 없습니다.</em></li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"click-dbclick-메서드\"><a href=\"#click-dbclick-메서드\" class=\"headerlink\" title=\"click() / dbclick() 메서드\"></a>click() / dbclick() 메서드</h2><blockquote>\n<ol>\n<li>$(“요소 선택”).click(function(){…});</li>\n<li>$(“요소 선택”).click();</li>\n</ol>\n</blockquote>\n<ol>\n<li><p>선택한 요소를 클릭할 때 마다 실행문을 실행합니다.</p>\n</li>\n<li><p>선택한 요소에 강제로 click이벤트가 발생, 유저가 클릭하지 않아도 실행됩니다.</p>\n</li>\n</ol>\n<blockquote>\n<ol start=\"3\">\n<li>$(“요소 선택”).on(“dbclick”,function(){…});</li>\n<li>$(“요소 선택”).dbclick();</li>\n</ol>\n</blockquote>\n<ol start=\"3\">\n<li><p>선택한 요소를 두번 연속으로 클릭했을 때 실행됩니다.</p>\n</li>\n<li><p>강제로 더블클릭 이벤트가 발생합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"이벤트-대상이-lt-a-gt-태그일-때\"><a href=\"#이벤트-대상이-lt-a-gt-태그일-때\" class=\"headerlink\" title=\"이벤트 대상이 &lt; a&gt; 태그일 때\"></a>이벤트 대상이 &lt; a&gt; 태그일 때</h2><p>&lt; a&gt;태그의 경우 클릭할 때 마다 링크된 주소로 이동됩니다.</p>\n<p><strong>링크된 주소로 이동되지 않도록 만드는 방법</strong></p>\n<ol>\n<li>return false<br> return false를 이용하여 a 태그를 클릭 했을 때<br> 링크된 주소로 이동되는 것을 막을 수 있습니다.<br> 단 return은 function 실행문을 강제로 종료시키므로<br> 함수의 마지막 부분에 작성합니다.</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> ...실행문...  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>preventDefault()<br> function 매개변수에 .preventDefalut() 메서드를 사용하면<br> 링크된 주소로 이동되는 것을 막을 수 있습니다.</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;  </span><br><span class=\"line\"> x.preventDefalut();  </span><br><span class=\"line\"> <span class=\"comment\">//...실행문...  </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"mouseover-mouseout-hover-mousemove\"><a href=\"#mouseover-mouseout-hover-mousemove\" class=\"headerlink\" title=\"mouseover() / mouseout() / hover() / mousemove()\"></a>mouseover() / mouseout() / hover() / mousemove()</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> $(<span class=\"string\">\"요소 선택\"</span>).mouseover(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;);  </span><br><span class=\"line\"><span class=\"number\">2.</span> $(<span class=\"string\">\"요소 선택\"</span>).mouseover();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> $(<span class=\"string\">\"요소 선택\"</span>).mouseout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;);  </span><br><span class=\"line\"><span class=\"number\">4.</span> $(<span class=\"string\">\"요소 선택\"</span>).mouseout();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">5.</span> $(<span class=\"string\">\"요소 선택\"</span>).hover(  </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;실행문<span class=\"number\">1</span>&#125;,  </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;실행문<span class=\"number\">2</span>&#125;  </span><br><span class=\"line\">);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">6.</span> $(<span class=\"string\">\"요소 선택\"</span>).mousemove(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;);  </span><br><span class=\"line\"><span class=\"number\">7.</span> $(<span class=\"string\">\"요소 선택\"</span>).mousemove();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>mouseover()</p>\n<ol>\n<li>선택한 요소에 <strong>마우스를 올릴 때 마다</strong> 실행됩니다.</li>\n<li>선택한 요소에 강제로 mouseover 이벤트를 발생시킵니다.</li>\n</ol>\n</li>\n<li><p>mouseout()</p>\n<ol start=\"3\">\n<li>선택한 요소에서 <strong>마우스가 벗어날 때마다</strong> 실행됩니다.</li>\n<li>선택한 요소에 강제로 mouseout 이벤트를 발생시킵니다.</li>\n</ol>\n</li>\n<li><p>hover()</p>\n<ol start=\"5\">\n<li>마우스를 올릴 때 마다 {실행문1}을 실행시키고,<br>마우스가 벗어날 때 마다 {실행문2}를 실행시킵니다.</li>\n</ol>\n</li>\n<li><p>mousemove()</p>\n<ol start=\"6\">\n<li>선택한 <strong>요소의 영역에서 마우스를 움직일 때 마다</strong> 실행됩니다.</li>\n<li>선택한 요소에 강제로 mousemove 이벤트를 발생시킵니다.</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>mousemove() 마우스 좌표값 구하기</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"built_in\">document</span>).mousemove(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123; <span class=\"comment\">// document 영역내에서 마우스를 움직일때 마다 실행  </span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> x=e.pageX; <span class=\"comment\">// X 좌표값 구하기  </span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> y=e.pageY; <span class=\"comment\">// Y 좌표값 구하기  </span></span><br><span class=\"line\"> $(<span class=\"string\">\"p\"</span>).text(<span class=\"string\">\"x좌표값:\"</span>+x+<span class=\"string\">\"y좌표값:\"</span>+y); <span class=\"comment\">// x,y 좌표값을 출력  </span></span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"change-index\"><a href=\"#change-index\" class=\"headerlink\" title=\"change() / index()\"></a>change() / index()</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> $(<span class=\"string\">\"요소 선택\"</span>).change(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;);  </span><br><span class=\"line\"><span class=\"number\">2.</span> $(<span class=\"string\">\"요소 선택\"</span>).change();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span>$(<span class=\"string\">\"요소 선택\"</span>).이벤트(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"요소 선택\"</span>).index(<span class=\"keyword\">this</span>);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>요소의 값이(value) 새 값으로 바뀌고 포커스가 다른 요소로 이동<br>되었을 때 실행됩니다.</p>\n</li>\n<li><p>강제로 change 이벤트 메서드를 발생시킵니다.</p>\n</li>\n<li><p>이벤트를 등록한 요소 중에서 이벤트가 발생한 요소의 인덱스 값을 반환합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"그룹-이벤트-등록-및-삭제\"><a href=\"#그룹-이벤트-등록-및-삭제\" class=\"headerlink\" title=\"그룹 이벤트 등록 및 삭제\"></a>그룹 이벤트 등록 및 삭제</h2><table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>on()</td>\n<td>여러 개의 이벤트를 등록할 때 사용합니다. 이벤트를 등록한 이후에 동일한 태그가 생성되어도 같이 이벤트 실행됩니다.</td>\n</tr>\n<tr>\n<td>bind()</td>\n<td>선택 요소에 한 개 이상의 이벤트를 등록.</td>\n</tr>\n<tr>\n<td>delegate()</td>\n<td>선택 요소의 하위 요소에 여러 개의 이벤트 등록. 등록 이후 생성된 동일한 요소에도 같이 이벤트 생성됩니다.</td>\n</tr>\n<tr>\n<td>one()</td>\n<td>한번 이벤트가 발생되면 자동으로 등록된 이벤트가 제거되어 한 번만 실행됩니다.</td>\n</tr>\n<tr>\n<td>off()</td>\n<td>선택한 요소에 등록된 이벤트를 제거합니다.</td>\n</tr>\n<tr>\n<td>unbind()</td>\n<td>선택한 요소에 등록된 이벤트를 제거합니다.</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight js\"><figcaption><span>사용 ex)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"#btn\"</span>).on(&#123;  </span><br><span class=\"line\"> <span class=\"string\">\"mouseover focus\"</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"keyword\">this</span>).css(<span class=\"string\">\"background-color\"</span>,<span class=\"string\">\"yellow\"</span>);  </span><br><span class=\"line\"> &#125;, <span class=\"comment\">// id 값 btn에 마우스가 올라가거나 포커스되면 배경색을 바꿉니다.  </span></span><br><span class=\"line\"> <span class=\"string\">\"mouseout blur\"</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"keyword\">this</span>).css(<span class=\"string\">\"background-color\"</span>,<span class=\"string\">\"red\"</span>);  </span><br><span class=\"line\"> &#125; <span class=\"comment\">// id 값 btn에 마우스가 벗어나거나 포커스아웃 되면 배경색을 바꿉니다.  </span></span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\"> $(<span class=\"string\">\"#btn\"</span>).append(<span class=\"string\">\"&lt;a href='#'&gt;버튼2&lt;/a&gt;\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//id값 btn의 마지막에 새 요소 (a태그로 감싼 버튼2)를 추가했습니다.  </span></span><br><span class=\"line\"> <span class=\"comment\">// .on 이벤트로 적용된 이벤트가 그대로 적용됩니다.   </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>jQuery에서의 이벤트 사용 기본형</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"btn\"</span>&gt;</span>버튼<span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span>  </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"javascript\"> $(<span class=\"string\">\"#btn\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;)  </span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>$(“#btn”)<br>이벤트 대상</li>\n<li>click()<br>이벤트 등록 메서드</li>\n<li>function(){…}<br>이벤트가 발생 했을 때 (이벤트 대상이 클릭되었을 때)<br>실행되는 이벤트 핸들러</li>\n</ol>","more":"<hr>\n<h2 id=\"ready-load-메서드\"><a href=\"#ready-load-메서드\" class=\"headerlink\" title=\"ready() / load() 메서드\"></a>ready() / load() 메서드</h2><p>HTML 문서를 불러올 때 지정된 객체의 로딩이 완료되면<br>실행되는 이벤트 핸들러.</p>\n<pre><code>1. $(문서 객체).ready(function)(){...});\n2. $(&quot;이미지 또는 프레임&quot;).load(function(){...});</code></pre><ul>\n<li><ol>\n<li>문서의 로딩이 완료된 후 실행됩니다.</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>HTML 문서 로딩이 완료되더라도<br>이미지나 프레임 소스는 그 이후에 로딩됩니다.<br>load() 메서드는 이런 이미지나 프레임에 연동된 소스가 로딩이<br>완료된 후 실행됩니다.<br><em>이미지나 프레임을 제외한 객체에는 사용할 수 없습니다.</em></li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"click-dbclick-메서드\"><a href=\"#click-dbclick-메서드\" class=\"headerlink\" title=\"click() / dbclick() 메서드\"></a>click() / dbclick() 메서드</h2><blockquote>\n<ol>\n<li>$(“요소 선택”).click(function(){…});</li>\n<li>$(“요소 선택”).click();</li>\n</ol>\n</blockquote>\n<ol>\n<li><p>선택한 요소를 클릭할 때 마다 실행문을 실행합니다.</p>\n</li>\n<li><p>선택한 요소에 강제로 click이벤트가 발생, 유저가 클릭하지 않아도 실행됩니다.</p>\n</li>\n</ol>\n<blockquote>\n<ol start=\"3\">\n<li>$(“요소 선택”).on(“dbclick”,function(){…});</li>\n<li>$(“요소 선택”).dbclick();</li>\n</ol>\n</blockquote>\n<ol start=\"3\">\n<li><p>선택한 요소를 두번 연속으로 클릭했을 때 실행됩니다.</p>\n</li>\n<li><p>강제로 더블클릭 이벤트가 발생합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"이벤트-대상이-lt-a-gt-태그일-때\"><a href=\"#이벤트-대상이-lt-a-gt-태그일-때\" class=\"headerlink\" title=\"이벤트 대상이 &lt; a&gt; 태그일 때\"></a>이벤트 대상이 &lt; a&gt; 태그일 때</h2><p>&lt; a&gt;태그의 경우 클릭할 때 마다 링크된 주소로 이동됩니다.</p>\n<p><strong>링크된 주소로 이동되지 않도록 만드는 방법</strong></p>\n<ol>\n<li>return false<br> return false를 이용하여 a 태그를 클릭 했을 때<br> 링크된 주소로 이동되는 것을 막을 수 있습니다.<br> 단 return은 function 실행문을 강제로 종료시키므로<br> 함수의 마지막 부분에 작성합니다.</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> ...실행문...  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>preventDefault()<br> function 매개변수에 .preventDefalut() 메서드를 사용하면<br> 링크된 주소로 이동되는 것을 막을 수 있습니다.</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"a\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;  </span><br><span class=\"line\"> x.preventDefalut();  </span><br><span class=\"line\"> <span class=\"comment\">//...실행문...  </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"mouseover-mouseout-hover-mousemove\"><a href=\"#mouseover-mouseout-hover-mousemove\" class=\"headerlink\" title=\"mouseover() / mouseout() / hover() / mousemove()\"></a>mouseover() / mouseout() / hover() / mousemove()</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> $(<span class=\"string\">\"요소 선택\"</span>).mouseover(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;);  </span><br><span class=\"line\"><span class=\"number\">2.</span> $(<span class=\"string\">\"요소 선택\"</span>).mouseover();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> $(<span class=\"string\">\"요소 선택\"</span>).mouseout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;);  </span><br><span class=\"line\"><span class=\"number\">4.</span> $(<span class=\"string\">\"요소 선택\"</span>).mouseout();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">5.</span> $(<span class=\"string\">\"요소 선택\"</span>).hover(  </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;실행문<span class=\"number\">1</span>&#125;,  </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;실행문<span class=\"number\">2</span>&#125;  </span><br><span class=\"line\">);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">6.</span> $(<span class=\"string\">\"요소 선택\"</span>).mousemove(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;);  </span><br><span class=\"line\"><span class=\"number\">7.</span> $(<span class=\"string\">\"요소 선택\"</span>).mousemove();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>mouseover()</p>\n<ol>\n<li>선택한 요소에 <strong>마우스를 올릴 때 마다</strong> 실행됩니다.</li>\n<li>선택한 요소에 강제로 mouseover 이벤트를 발생시킵니다.</li>\n</ol>\n</li>\n<li><p>mouseout()</p>\n<ol start=\"3\">\n<li>선택한 요소에서 <strong>마우스가 벗어날 때마다</strong> 실행됩니다.</li>\n<li>선택한 요소에 강제로 mouseout 이벤트를 발생시킵니다.</li>\n</ol>\n</li>\n<li><p>hover()</p>\n<ol start=\"5\">\n<li>마우스를 올릴 때 마다 {실행문1}을 실행시키고,<br>마우스가 벗어날 때 마다 {실행문2}를 실행시킵니다.</li>\n</ol>\n</li>\n<li><p>mousemove()</p>\n<ol start=\"6\">\n<li>선택한 <strong>요소의 영역에서 마우스를 움직일 때 마다</strong> 실행됩니다.</li>\n<li>선택한 요소에 강제로 mousemove 이벤트를 발생시킵니다.</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>mousemove() 마우스 좌표값 구하기</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"built_in\">document</span>).mousemove(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123; <span class=\"comment\">// document 영역내에서 마우스를 움직일때 마다 실행  </span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> x=e.pageX; <span class=\"comment\">// X 좌표값 구하기  </span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> y=e.pageY; <span class=\"comment\">// Y 좌표값 구하기  </span></span><br><span class=\"line\"> $(<span class=\"string\">\"p\"</span>).text(<span class=\"string\">\"x좌표값:\"</span>+x+<span class=\"string\">\"y좌표값:\"</span>+y); <span class=\"comment\">// x,y 좌표값을 출력  </span></span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"change-index\"><a href=\"#change-index\" class=\"headerlink\" title=\"change() / index()\"></a>change() / index()</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> $(<span class=\"string\">\"요소 선택\"</span>).change(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;);  </span><br><span class=\"line\"><span class=\"number\">2.</span> $(<span class=\"string\">\"요소 선택\"</span>).change();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span>$(<span class=\"string\">\"요소 선택\"</span>).이벤트(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"요소 선택\"</span>).index(<span class=\"keyword\">this</span>);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>요소의 값이(value) 새 값으로 바뀌고 포커스가 다른 요소로 이동<br>되었을 때 실행됩니다.</p>\n</li>\n<li><p>강제로 change 이벤트 메서드를 발생시킵니다.</p>\n</li>\n<li><p>이벤트를 등록한 요소 중에서 이벤트가 발생한 요소의 인덱스 값을 반환합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"그룹-이벤트-등록-및-삭제\"><a href=\"#그룹-이벤트-등록-및-삭제\" class=\"headerlink\" title=\"그룹 이벤트 등록 및 삭제\"></a>그룹 이벤트 등록 및 삭제</h2><table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>on()</td>\n<td>여러 개의 이벤트를 등록할 때 사용합니다. 이벤트를 등록한 이후에 동일한 태그가 생성되어도 같이 이벤트 실행됩니다.</td>\n</tr>\n<tr>\n<td>bind()</td>\n<td>선택 요소에 한 개 이상의 이벤트를 등록.</td>\n</tr>\n<tr>\n<td>delegate()</td>\n<td>선택 요소의 하위 요소에 여러 개의 이벤트 등록. 등록 이후 생성된 동일한 요소에도 같이 이벤트 생성됩니다.</td>\n</tr>\n<tr>\n<td>one()</td>\n<td>한번 이벤트가 발생되면 자동으로 등록된 이벤트가 제거되어 한 번만 실행됩니다.</td>\n</tr>\n<tr>\n<td>off()</td>\n<td>선택한 요소에 등록된 이벤트를 제거합니다.</td>\n</tr>\n<tr>\n<td>unbind()</td>\n<td>선택한 요소에 등록된 이벤트를 제거합니다.</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight js\"><figcaption><span>사용 ex)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"#btn\"</span>).on(&#123;  </span><br><span class=\"line\"> <span class=\"string\">\"mouseover focus\"</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"keyword\">this</span>).css(<span class=\"string\">\"background-color\"</span>,<span class=\"string\">\"yellow\"</span>);  </span><br><span class=\"line\"> &#125;, <span class=\"comment\">// id 값 btn에 마우스가 올라가거나 포커스되면 배경색을 바꿉니다.  </span></span><br><span class=\"line\"> <span class=\"string\">\"mouseout blur\"</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"keyword\">this</span>).css(<span class=\"string\">\"background-color\"</span>,<span class=\"string\">\"red\"</span>);  </span><br><span class=\"line\"> &#125; <span class=\"comment\">// id 값 btn에 마우스가 벗어나거나 포커스아웃 되면 배경색을 바꿉니다.  </span></span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\"> $(<span class=\"string\">\"#btn\"</span>).append(<span class=\"string\">\"&lt;a href='#'&gt;버튼2&lt;/a&gt;\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//id값 btn의 마지막에 새 요소 (a태그로 감싼 버튼2)를 추가했습니다.  </span></span><br><span class=\"line\"> <span class=\"comment\">// .on 이벤트로 적용된 이벤트가 그대로 적용됩니다.   </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"this Keyword -JavaScript","date":"2020-03-10T00:41:19.000Z","disqusId":"tunas-blog-1","_content":"\njavascript this 키워드는 속한 객체를 나타냅니다.\n\n사용 위치에 따라 다른 값을 갖습니다.\n\n<!-- more -->\n\n*   method  \n    메소드에서 this는 메소드의 소유자 오브젝트를 나타냅니다.\n\n```js\nvar person = {  \n firstName: \"Han\",  \n lastName : \"Dongwon\",  \n id       : 2020,  \n fullName : function() {  \n return this.firstName + \" \" + this.lastName;  \n }  \n};  \n```\n\nthis는 person 객체를 나타냅니다.  \nperson 오브젝트는 fullName 메소드의 소유자입니다.\n\n*   Alone  \n    this 혼자 사용되면 전역 객체를 나타냅니다.  \n    브라우저 창에서 전역 개체는 [object Window]입니다.\n    \n*   function  \n    함수에서 this는 전역 객체를 나타냅니다.  \n    함수에서 엄격 모드에서(in strict mode)는 정의되지 않습니다.(undefined)\n    \n*   event  \n    이벤트에서 this는 이벤트를 받은 HTML요소(element)를 나타냅니다.\n    \n\n```html\n<button onclick=\"this.style.display='none'\">  \n display none  \n</button>  \n```\n\nthis는 이벤트를 받는 HTML요소 button을 나타냅니다.\n\n*   call() 및 apply()와 같은 메소드는 this를 모든 객체에 참조 할 수 있습니다.\n\n```js\nvar person1 = {  \n fullName: function() {  \n return this.firstName + \" \" + this.lastName;  \n }  \n}  \nvar person2 = {  \n firstName:\"Han\",  \n lastName: \"Dongwon\",  \n}  \nperson1.fullName.call(person2);  \n```\n\nperson2를 인수로 사용하여 person1.fullName을 호출하는 경우  \nperson1의 메소드 인 경우에도 this가 person2를 참조합니다.\n","source":"_posts/this Keyword -JavaScript.md","raw":"---\ntitle: this Keyword -JavaScript\ndate: 2020-03-10 09:41:19\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\njavascript this 키워드는 속한 객체를 나타냅니다.\n\n사용 위치에 따라 다른 값을 갖습니다.\n\n<!-- more -->\n\n*   method  \n    메소드에서 this는 메소드의 소유자 오브젝트를 나타냅니다.\n\n```js\nvar person = {  \n firstName: \"Han\",  \n lastName : \"Dongwon\",  \n id       : 2020,  \n fullName : function() {  \n return this.firstName + \" \" + this.lastName;  \n }  \n};  \n```\n\nthis는 person 객체를 나타냅니다.  \nperson 오브젝트는 fullName 메소드의 소유자입니다.\n\n*   Alone  \n    this 혼자 사용되면 전역 객체를 나타냅니다.  \n    브라우저 창에서 전역 개체는 [object Window]입니다.\n    \n*   function  \n    함수에서 this는 전역 객체를 나타냅니다.  \n    함수에서 엄격 모드에서(in strict mode)는 정의되지 않습니다.(undefined)\n    \n*   event  \n    이벤트에서 this는 이벤트를 받은 HTML요소(element)를 나타냅니다.\n    \n\n```html\n<button onclick=\"this.style.display='none'\">  \n display none  \n</button>  \n```\n\nthis는 이벤트를 받는 HTML요소 button을 나타냅니다.\n\n*   call() 및 apply()와 같은 메소드는 this를 모든 객체에 참조 할 수 있습니다.\n\n```js\nvar person1 = {  \n fullName: function() {  \n return this.firstName + \" \" + this.lastName;  \n }  \n}  \nvar person2 = {  \n firstName:\"Han\",  \n lastName: \"Dongwon\",  \n}  \nperson1.fullName.call(person2);  \n```\n\nperson2를 인수로 사용하여 person1.fullName을 호출하는 경우  \nperson1의 메소드 인 경우에도 this가 person2를 참조합니다.\n","slug":"this Keyword -JavaScript","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrt7002hqgvqbigbbyld","content":"<p>javascript this 키워드는 속한 객체를 나타냅니다.</p>\n<p>사용 위치에 따라 다른 값을 갖습니다.</p>\n<a id=\"more\"></a>\n\n<ul>\n<li>method<br>메소드에서 this는 메소드의 소유자 오브젝트를 나타냅니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;  </span><br><span class=\"line\"> firstName: <span class=\"string\">\"Han\"</span>,  </span><br><span class=\"line\"> lastName : <span class=\"string\">\"Dongwon\"</span>,  </span><br><span class=\"line\"> id       : <span class=\"number\">2020</span>,  </span><br><span class=\"line\"> fullName : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">\" \"</span> + <span class=\"keyword\">this</span>.lastName;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>this는 person 객체를 나타냅니다.<br>person 오브젝트는 fullName 메소드의 소유자입니다.</p>\n<ul>\n<li><p>Alone<br>this 혼자 사용되면 전역 객체를 나타냅니다.<br>브라우저 창에서 전역 개체는 [object Window]입니다.</p>\n</li>\n<li><p>function<br>함수에서 this는 전역 객체를 나타냅니다.<br>함수에서 엄격 모드에서(in strict mode)는 정의되지 않습니다.(undefined)</p>\n</li>\n<li><p>event<br>이벤트에서 this는 이벤트를 받은 HTML요소(element)를 나타냅니다.</p>\n</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"this.style.display='none'\"</span>&gt;</span>  </span><br><span class=\"line\"> display none  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>this는 이벤트를 받는 HTML요소 button을 나타냅니다.</p>\n<ul>\n<li>call() 및 apply()와 같은 메소드는 this를 모든 객체에 참조 할 수 있습니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person1 = &#123;  </span><br><span class=\"line\"> fullName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">\" \"</span> + <span class=\"keyword\">this</span>.lastName;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = &#123;  </span><br><span class=\"line\"> firstName:<span class=\"string\">\"Han\"</span>,  </span><br><span class=\"line\"> lastName: <span class=\"string\">\"Dongwon\"</span>,  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">person1.fullName.call(person2);</span><br></pre></td></tr></table></figure>\n\n<p>person2를 인수로 사용하여 person1.fullName을 호출하는 경우<br>person1의 메소드 인 경우에도 this가 person2를 참조합니다.</p>\n","site":{"data":{}},"excerpt":"<p>javascript this 키워드는 속한 객체를 나타냅니다.</p>\n<p>사용 위치에 따라 다른 값을 갖습니다.</p>","more":"<ul>\n<li>method<br>메소드에서 this는 메소드의 소유자 오브젝트를 나타냅니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;  </span><br><span class=\"line\"> firstName: <span class=\"string\">\"Han\"</span>,  </span><br><span class=\"line\"> lastName : <span class=\"string\">\"Dongwon\"</span>,  </span><br><span class=\"line\"> id       : <span class=\"number\">2020</span>,  </span><br><span class=\"line\"> fullName : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">\" \"</span> + <span class=\"keyword\">this</span>.lastName;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>this는 person 객체를 나타냅니다.<br>person 오브젝트는 fullName 메소드의 소유자입니다.</p>\n<ul>\n<li><p>Alone<br>this 혼자 사용되면 전역 객체를 나타냅니다.<br>브라우저 창에서 전역 개체는 [object Window]입니다.</p>\n</li>\n<li><p>function<br>함수에서 this는 전역 객체를 나타냅니다.<br>함수에서 엄격 모드에서(in strict mode)는 정의되지 않습니다.(undefined)</p>\n</li>\n<li><p>event<br>이벤트에서 this는 이벤트를 받은 HTML요소(element)를 나타냅니다.</p>\n</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"this.style.display='none'\"</span>&gt;</span>  </span><br><span class=\"line\"> display none  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>this는 이벤트를 받는 HTML요소 button을 나타냅니다.</p>\n<ul>\n<li>call() 및 apply()와 같은 메소드는 this를 모든 객체에 참조 할 수 있습니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person1 = &#123;  </span><br><span class=\"line\"> fullName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">\" \"</span> + <span class=\"keyword\">this</span>.lastName;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = &#123;  </span><br><span class=\"line\"> firstName:<span class=\"string\">\"Han\"</span>,  </span><br><span class=\"line\"> lastName: <span class=\"string\">\"Dongwon\"</span>,  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">person1.fullName.call(person2);</span><br></pre></td></tr></table></figure>\n\n<p>person2를 인수로 사용하여 person1.fullName을 호출하는 경우<br>person1의 메소드 인 경우에도 this가 person2를 참조합니다.</p>"},{"title":"this -Core JavaScript","disqusId":"tunas-blog-1","date":"2020-04-27T12:50:04.000Z","_content":"\n자바스크립트에서의 this는 어디서든 사용할 수 있습니다.\nthis는 상황에 따라 참조하는 대상이 달라질 수 있습니다.\n함수와 객체(메서드) 구분이 느슨한 자바스크립트에서 이 둘을 구분하는 유일한 기능입니다.\n\n* this\n  * [상황에 따라 달라지는 this](/2020/04/27/this-Core-JavaScript/#this)\n    * 전역 공간에서의 this\n    * 메서드로서 호출할 때 메서드 내부의 this\n      * 함수 vs 메서드\n      * 메서드 내부에서의 this\n    * 함수로서 호출할 때 그 함수 내부에서의 this\n      * 함수 내부에서의 this\n      * 메서드의 내부함수에서의 this\n      * 메서드 내부 함수에서의 this를 우회하는 방법\n      * this를 바인딩하지 않는 함수\n    * 콜백 함수 호출시 그 함수 내부에서의 this\n    * Class 함수 내부에서의 this \n  * [명시적으로 this를 바인딩하는 방법](/2020/04/27/this-Core-JavaScript/#this_binding)\n    * call 메서드\n    * apply 메서드\n    * call / apply 메서드의 활용\n      * 생성자 내부에서 다른 생성자를 호출\n      * 여러 인수를 묶어 하나의 배열로 전달\n    * bind 메서드\n      * name 프로퍼티\n      * 상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기\n    * 화살표 => 함수의 예외사항\n    * 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n  * [this 정리](/2020/04/27/this-Core-JavaScript/#this_point) \n\n<!-- more -->\n\n------\n<h2 id=\"this\">상황에 따라 달라지는 this</h2>\n\n* `this`는 기본적으로 <mark>실행 컨텍스트가 생성될 때 함께 결정됩니다.</mark>\n실행 컨텍스트는 함수를 호출할 때 생성되므로, `this`<mark>는 함수를 호출할 때 결정된다고 할 수 있습니다.</mark>\n\n------\n### 전역 공간에서의 this\n\n전역 공간에서 `this`는 전역 객체를 가리킵니다. 브라우저 환경에서 전역객체는 `window`이고 Node.js 환경에서는 `global`입니다.\n\n  * 참고 : 전역 변수\n전역 변수를 선언하면 자바스크립트 엔진은 전역객체의 프로퍼티로 할당시킴.\n```js 전역객체 window의 프로퍼티\nvar a = 1;\nconsole.log(a); // 1\nconsole.log(window.a); // 1 (전역객체의 프로퍼티)\nconsole.log(this.a); // 1 (this는 현재 전역객체 참조)\n```\n<mark>사실 자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로 동작합니다.</mark>\n이 특정 객체란 실행 컨텍스트의 `LexicalEnvironment`를 말합니다.\n실행 컨텍스트는 변수를 수집하여 `LexicalEnvironment`의 프로퍼티로 지정합니다.\n이후 변수를 호출하면 `LexicalEnvironment`를 조회하여 일치하는 프로퍼티가 있을 경우 그 값을 반환합니다.\n\n  전역 컨텍스트의 `LexicalEnvironment`는 전역객체를 참조하므로 var a 선언/할당 이후 `window.a` 와 `this.a`가 1이 나오는 이유는 당연합니다.\n<mark>a를 직접 호출했을 때도 1이 나오는 이유는 무엇일까요?</mark>\n변수 a에 접근하려고 하면 스코프 체인에서 a를 검색하다가 가장 마지막에 도달하는 전역 스코프의 `LexicalEnvironment`에서 해당 프로퍼티 a를 조회하여 그 값을 반환하기 때문입니다.\n\n* 전역 공간에서 var로 변수를 선언하는 대신 window의 프로퍼티에 직접 할당하더라도 결과적으로 똑같이 동작합니다. 하지만 `delete` 연산자를 사용하는 경우 다른 결과를 반환합니다.\n\n  * `var` 변수로 선언한 경우 : delete window 형식으로 삭제 불가,\n  delete 변수명 형식으로도 삭제 불가\n  * `window` 프로퍼티에 직접 할당한 경우: delete window 형식으로 삭제 가능,\n  delete 변수명 형식으로도 삭제 가능\n\n------\n### 메서드로서 호출할 때 그 메서드 내부에서의 this\n\n#### 함수 vs 메서드\n\n함수를 실행하는 방법 중에는 함수로 호출하는 경우와 메서드로서 호출하는 경우가 있습니다.\n함수와 메서드를 구분하는 유일한 차이는 <u>독립성</u>에 있습니다.\n\n* 함수는 그 자체로 독립적인 기능을 수행합니다.\n\n* 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행합니다.\n\n<mark>어떤 함수를 객체의 프로퍼티에 할당한다고 해서 무조건 메서드가 되는 것이 아니라\n객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작합니다.</mark>\n\n```js 메서드로 호출 (점 표기법, 대괄호 표기법)\nvar obj = {\n  method: function(x) {\n    console.log(this, x);\n  },\n};\nobj.method(1); // { method: f } 1\nobj['method'](2); // { method: f } 2\n```\n\n다시 말해 점 표기법이든 대괄호 표기법이든, 어떤 함수를 호출할 때 그 함수 이름 앞에\n객체가 명시돼 있는 경우 메서드로 호출한 것이고, 그렇지 않은 경우에는 함수로 호출한 것입니다.\n\n#### 메서드 내부에서의 this\n\n`this`에는 호출한 주체에 대한 정보가 담깁니다. 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티 명)앞의 객체입니다. 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 `this`가 됩니다.\n\n```js 메서드 내부에서의 this\nvar obj = {\n  methodA: function() {\n    console.log(this);\n  },\n  inner: {\n    methodB: function() {\n      console.log(this);\n    },\n  },\n};\nobj.methodA(); // { methodA: f, inner: {...} }    ( === obj)\nobj['methodA'](); // { methodA: f, inner: {...} } ( === obj)\n\nobj.inner.methodB(); // { methodB: f }            ( === obj.inner)\nobj.inner['methodB'](); // { methodB: f }         ( === obj.inner)\nobj['inner'].methodB(); // { methodB: f }         ( === obj.inner)\nobj['inner']['methodB'](); // { methodB: f }      ( === obj.inner)\n```\n\n------\n### 함수로서 호출할 때 그 함수 내부에서의 this\n\n------\n#### 함수 내부에서의 this\n\n어떤 함수를 함수로서 호출할 경우 `this`가 지정되지 않습니다.(this는 호출한 주체에 대한 정보가 담깁니다.)\n함수로서 호출하는 것은 호출 주체(객체지향 언어에서의 객체)를 명시하지 않고 실행한 것이기 때문에 호출 주체의 정보를 알 수 없는 것입니다. \n<mark>this가 지정되지 않은 경우 this는 전역 객체를 참조합니다.</mark>\n따라서 함수에서의 `this`는 전역 객체를 가리킵니다.\n\n------\n#### 메서드의 내부함수에서의 this\n\n메서드 내부에서 정의하고 실행한 함수에서의 this는 자바스크립트 초심자들이 this에 관해 가장 자주 혼란을 느끼는 점입니다.\n\n<mark>내부함수 역시 이를 함수로 호출했는지 메서드로 호출했는지만 파악하면 this의 값을 정확히 맞출 수 있습니다.</mark>\n\n```js 내부함수에서의 this\n1. var obj1 = {\n  3. outer: function() {\n    4. console.log(this); // (1)\n    5. 7. var innerFunc = function() {\n      8. console.log(this); // (2) (3)\n    };\n    6. innerFunc();\n\n    9. 11. var obj2 = {\n      12. innerMethod: innerFunc,\n    };\n    10. obj2.innerMethod();\n  },\n};\n2. obj1.outer();\n// (1): obj1\n// (2): 전역객체(window)\n// (3): obj2\n```\n\n(2)는 `innerFunc`를 호출한 결과를, (3)은 `obj2.innerMethod`를 호출한 결과입니다.\n\n1. 객체를 생성하는데 내부에 outer 프로퍼티가 있습니다. outer 프로퍼티에 익명함수가 연결되고 생성된 객체를 변수 `obj1`에 할당합니다.\n\n\n2. `obj1.outer()`를 호출합니다.\n\n\n3. `obj1.outer` 함수의 실행 컨텍스트가 생성되면서 호이스팅하고, 스코프 체인 정보를 수집하고, this를 바인딩합니다.\n이 함수는 호출될 때 함수명 `outer` 앞에 점(.)이 있었으므로 메서드로서 호출된 것입니다.\n따라서 `this`는 점(.)앞에 객체인 `obj1`을 바인딩합니다.\n\n\n4. `this`가 바인딩된 `obj1` 객체 정보가 출력됩니다.\n\n\n5. 호이스팅된 변수 `innerFunc`는 outer 스코프 내에서만 접근할 수 있는 지역변수 입니다. 이 변수에 익명 함수를 할당합니다.\n\n\n6. `innerFunc()`를 호출합니다.\n\n\n7. `innerFunc` 함수의 실행 컨텍스트가 생성되면서 호이스팅,스코프 체인 수집, this 바인딩 등을 수행합니다.\n이 함수는 호출될 때 ~~함수명 앞에 점(.)이 없었습니다.~~ 함수로서 호출되었습니다.\n따라서 this가 지정되지 않았고, 자동으로 스코프 체인상의 최상위 객체인 전역객체(window)가 바인딩 됩니다.\n\n\n8. `this`가 바인딩된 `window` 객체 정보가 출력됩니다.\n\n\n9. `obj2` 역시 outer 스코프 내부에서만 접근할 수 있는 지역변수 입니다. \n`obj2` 변수에는 `object`를 할당하는데, object 안에 `innerMethod`라는 프로퍼티가 존재하고, 프로퍼티 값으로 앞서 정의된 변수 `innerFunc`와 연결된 익명 함수가 지정됩니다.\n\n\n10. `obj2.innerMethod()`를 호출합니다.\n\n\n11. `obj2. innerMethod` 함수의 실행 컨텍스트가 생성됩니다. 이 함수는 호출할 때 함수명인 `innerMethod` 앞에 점(.)이 있었으므로 메서드로서 호출한 것입니다.\n따라서 `this`에는 마지막 점 앞의 객체인 `obj2`가 바인딩 됩니다.\n\n\n12. `obj2` 객체 정보가 출력됩니다.\n\n* 정리하자면 \n<mark>this 바인딩에 관해서는 함수를 실행하는 당시의 주변 환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고 오직 해당 함수를 호출하는 구문 앞에 점(.) 또는 대괄호[] 표기가 있는지 없는지가 관건입니다.</mark>\n\n------\n#### 메서드의 내부 함수에서의 this를 우회하는 방법\n\n호출 주체가 없을 때 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변 환경의 `this`를 그대로 상속받아 사용하고 싶다면\n간단하고 대표적인 방법으로 변수를 활용하는 방법이 있습니다.\n\n```js 내부함수에서의 this를 변수를 활용하여 우회하기\nvar obj = {\n  outer: function() {\n    console.log(this); // (1) { outer: f }\n    var innerFunc1 = function() {\n      console.log(this); // (2) Window { ... }\n    };\n    innerFunc1();\n\n    var self = this;\n    var innerFunc2 = function() {\n      console.log(self); // (3) { outer: f }\n    };\n    innerFunc2();\n  },\n};\nobj.outer();\n```\n\n1. `innerFunc1` 내부에서 `this`는 전역객체를 가리킵니다.\n\n2. outer 스코프에서 `self`라는 변수에 `this`를 저장한 상태에서 호출한 `innerFunc2`의 경우 `self`에는 객체 obj가 출력됩니다.\n\n~~그저 상위 스코프의 this를 저장해서 내부함수에서 활용하려는 수단이므로 변수명은 달라도 무관합니다.~~\n\n------\n#### this를 바인딩하지 않는 함수\n\nES6에서는 함수 내부에서 `this`가 전역객체를 바라보는 문제를 보안하고자, \n`this`를 바인딩하지 않는 <mark>화살표 함수(Arrow function)</mark>를 새로 도입했습니다. \n\n화살표 함수는 실행 컨텍스트를 생성할 때 `this` 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 `this`를 그대로 활용할 수 있습니다.\n\n```js 화살표 함수\nvar obj = {\n  outer: function() {\n    console.log(this); // (1) { outer: f }\n    var innerFunc = () => {\n      console.log(this); // (2) { outer: f }\n    };\n    innerFunc();\n  },\n};\nobj.outer();\n```\n\n이 밖에도 `call`, `apply` 등의 메서드를 활용해 함수를 호출할 때 명시적으로 `this`를 지정하는 방법이 있습니다.\n\n------\n### 콜백 함수 호출 시 그 함수 내부에서의 this\n\n* `함수 A`의 제어권을 `다른 함수(또는 메서드) B`에게 넘겨주는 경우 `함수 A`를 `콜백 함수`라고 합니다.\n\n* 이때 `함수 A`는 `함수 B`의 내부 로직에 따라 실행되며, `this` 역시 `함수 B` 내부 로직에서 정한 규칙에 따라 값이 결정됩니다.\n\n* `콜백 함수` 역시 함수이므로 기본적으로 `this`가 전역객체를 참조하지만, 제어권을 받은 함수 (함수 B)에서 `콜백 함수`에 별도로 `this`가 될 대상을 지정한 경우에는 그 대상을 참조하게 됩니다.\n\n```js 콜백 함수 내부에서의 this\nsetTimeout(function() {\n  console.log(this);\n}, 300); // (1) window\n\n[1, 2, 3, 4, 5].forEach(function(x) {\n  // (2) window\n  console.log(this, x);\n});\n\ndocument.body.innerHTML += '<button id=\"a\">클릭</button>';\ndocument.body.querySelector('#a').addEventListener('click', function(e) {\n  // (3) <button id=\"a\">클릭</button>\n  console.log(this, e);\n});\n```\n\n1. 0.3초 뒤 전역객체가 출력됩니다.\n\n2. 배열의 각 요소를 차례대로 콜백 함수의 첫 번째 인자로 삼아 전역객체와 배열의 각 요소가 총 5회 출력됩니다.\n\n3. 지정한 `HTML` 엘리먼트에 `'click'` 이벤트가 발생할 때 마다 그 이벤트 정보를 콜백 함수의 첫 번째 인자로 삼아 함수를 실행합니다. 버튼을 클릭하면 앞서 지정한 엘리먼트와 클릭 이벤트에 관한 정보가 담긴 객체가 출력됩니다.\n\n이 처럼 콜백 함수에서의 `this`는 한가지로 정의할 수 없습니다.\n<mark>콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 정할지 결정하며</mark>,\n따로 정의하지 않은 경우 기본적으로 전역객체를 참조합니다.\n\n------\n### Class 함수 내부에서의 this\n\n객체지향 언어에서 생성자를 클래스(`class`), \n클래스를 통해 만든 객체를 인스턴스 (`instance`)라고 합니다.\n\n프로그래밍적으로 `class`는 구체적인 `instance`를 만들기 위한 일종의 틀입니다.\n틀 안에는 해당 `class`의 공통 속성들이 준비되어 있고, 추가로 개별 `instance`를 만들 수 있습니다.\n\n`new` 키워드와 함께 함수를 호출하면 해당 함수가 `class`로서 동작합니다.\n`class`로서 함수가 호출된 경우 내부에서의 `this`는 `instance`가 됩니다.\n\n* `class` 함수를 `new`키워드로 호출 하면 엔진은 `class`의 `prototype` 프로퍼티를 참조하는 `__proto__` 프로퍼티 `instance`를 만들고 공통 속성 및 특성 들을 해당 객체(`this`)에 부여합니다.\n`instance`가 생성됩니다.\n\n```js class 함수\nvar Cat = function(name, age) {\n  this.bark = '야옹';\n  this.name = name;\n  this.age = age;\n};\nvar choco = new Cat('초코', 7);\nvar nabi = new Cat('나비', 5);\nconsole.log(choco, nabi);\n\n/* 결과\nCat { bark: '야옹', name: '초코', age: 7 }\nCat { bark: '야옹', name: '나비', age: 5 }\n*/\n```\n\n1. `new` 키워드와 함께 Cat 함수를 호출하여 변수 choco, nabi에 각각 할당 했습니다.\n\n2. `console.log` 출력 결과 `this`가 각각 Cat `class`의 `instance`를 참조하여 반환합니다.\n(`choco instance`, `nabi instance`)\n\n------\n<h2 id=\"this_binding\">명시적으로 this를 바인딩하는 방법</h2>\n\n상황에 따라 this에 바인딩 되는 값들을 살펴봤지만 이런 규칙을 무시?하고 this에 대상을 지정하여 바인딩하는 방법도 있습니다.\n\n------\n### call 메서드\n\n> Function.prototype.call(thisArg[, arg1[, arg2[, ...]]])\n\n`call` 메서드는 호출 주체인 함수를 즉시 실행하도록 합니다.\n`call` 메서드의 첫 번째 인자를 `this`로 바인딩 하고, 이후에 인자들을 호출할 함수의 매개변수로 사용합니다.\n\n`call`메서드를 이용하여 `this` 값으로 참조할 객체를 지정할 수 있습니다. \n\n```js call 메서드\nvar func = function(a, b, c) {\n  console.log(this, a, b, c);\n};\n\nfunc(1, 2, 3); // Window{ ... } 1 2 3\nfunc.call({ x: 1 }, 4, 5, 6); // { x: 1 } 4 5 6\n```\n\n* `func.call`에서 메서드의 첫 번째 인자 `{x : 1}`를 `this`가 참조할 값으로 던져줍니다.\n\n* 객체의 메서드를 호출하면 `this`는 객체를 참조하게 되지만, `call` 메서드는 이렇듯 임의의 객체를 `this`로 지정할 수 있습니다.\n\n------\n### apply 메서드\n\n> Function.prototype.apply(thisArg[, argsArray])\n\n`apply` 메서드는 기능적으로 `call` 메서드와 완전히 동일합니다.\n\n`apply`메서드는 <mark>두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 점에서 차이가 있습니다.</mark>\n\n```js apply 메서드\nvar func = function(a, b, c) {\n  console.log(this, a, b, c);\n};\nfunc.apply({ x: 1 }, [4, 5, 6]); // { x: 1 } 4 5 6\n\nvar obj = {\n  a: 1,\n  method: function(x, y) {\n    console.log(this.a, x, y);\n  },\n};\nobj.method.apply({ a: 4 }, [5, 6]); // 4 5 6\n```\n\n------\n### call / apply 메서드의 활용\n\n`call` 과 `apply` 메서드의 활용 사례\n\n------\n#### 유사 배열객체에 배열 메서드 적용\n\n```js 유사 배열객체에서 배열 메서드 사용하기\nvar obj = {\n  0: 'a',\n  1: 'b',\n  2: 'c',\n  length: 3,\n};\nArray.prototype.push.call(obj, 'd');\nconsole.log(obj); // { 0: 'a', 1: 'b', 2: 'c', 3: 'd', length: 4 }\n\nvar arr = Array.prototype.slice.call(obj);\nconsole.log(arr); // [ 'a', 'b', 'c', 'd' ]\n```\n\n* 유사배열객체인 경우 `call` 또는 `apply` 메서드를 이용해 배열 메서드를 사용할 수 있습니다.\n\n* 배열 메서드인 `push`를 `객체 obj`에 적용해 프로퍼티 3에 'd'를 추가했습니다.\n\n* 배열 메서드인 `slice`로 얕은 복사하여 객체를 배열로 반환했습니다.\n\n이 밖에도 유사배열객체에는 `call`, `apply` 메서드를 이용해 모든 배열 메서드를 적용할 수 있습니다.\n단, 문자열의 경우 `length` 프로퍼티가 읽기 전용이기 때문에 원본 문자열에 변경을 가하는 메서드(`push`, `pop`, `shift`, `unshift`, `splice` 등)는 에러를 던지며, `concat` 처럼 대상이 반드시 배열이어야 하는 경우에는 에러는 나지 않지만 재대로 된 결과를 얻을 수 없습니다.\n\n* 사실 `call`, `apply`를 이용해 형변환하는 것은 '`this`를 원하는 값으로 지정해서 호출한다'라는 본래의 메서드의 의도와는 어긋나는 활용법이라고 할 수 있습니다.\n또한 코드만 봐서는 어떤 의도인지 파악하기 쉽지 않습니다.\n\n\n* <mark>ES6 에서는 유사배열객체 또는 이터러블한 모든 종류의 데이터 타입을 배열로 전환</mark>하는 `Array.from`메서드가 추가되었습니다.\n\n------\n#### Array.from\n\nArray 오브젝트를 생성하고 콜백 함수에서 반환된 값을 엘리먼트 값으로 설정하여 새로운 Array 객체를 반환합니다.\n\n>Array.from(arrayLike[, mapFn[, thisArg]])\n\n* arrayLike\n배열로 변환하고자 하는 유사 배열 객체(Array-like)나 반복 가능한 객체(이터러블 오브젝트).\n\n* mapFn (선택적 파라미터)\n배열의 모든 엘리먼트 마다 호출할 함수.\n\n* thisArg (선택적 파라미터)\n두 번째 파라미터 함수 실행 시에 this로 참조할 값.\n\n* 반환 값\n새로운 Array 인스턴스.\n\n```js ES6의 Array.from\nvar obj = {\n  0: 'a',\n  1: 'b',\n  2: 'c',\n  length: 3,\n};\nvar arr = Array.from(obj);\nconsole.log(arr); // ['a', 'b', 'c']\n```\n\n------\n#### class 내부에서 다른 class를 호출\n\n`class` 내부에 다른 `class`와 공통된 내용이 있을 경우 `call` 또는 `apply`를 이용해 다른 `class`를 호출하면 간단하게 반복을 줄일 수 있습니다.\n\n```js class 내부에서 다른 class 호출\nfunction Person(name, gender) {\n  this.name = name;\n  this.gender = gender;\n}\nfunction Student(name, gender, school) {\n  Person.call(this, name, gender);\n  this.school = school;\n}\nfunction Employee(name, gender, company) {\n  Person.apply(this, [name, gender]);\n  this.company = company;\n}\nvar by = new Student('보영', 'female', '단국대');\nvar jn = new Employee('재난', 'male', '구골');\n```\n\nStudent, Employee class함수 내부에서 Person 함수를 호출해서 instance 속성을 정의하게 했습니다.\n\n------\n#### 여러 인수를 묶어 하나의 배열로 전달하고 싶을 때\n\n`apply`메서드를 사용해 하나의 배열로 인수들을 전달할 수 있습니다.\n\n```js 여러 인수를 받는 메서드(Math.max/Math.min)에 apply 적용\nvar numbers = [10, 20, 3, 16, 45];\nvar max = Math.max.apply(null, numbers);\nvar min = Math.min.apply(null, numbers);\nconsole.log(max, min); // 45 3\n```\n\nES6에서는 `spread` 연산자를 이용하면 `apply`를 적용하는 것보다 더욱 간편하게 작성할 수 있습니다.\n\n```js\nconst numbers = [10, 20, 3, 16, 45];\nconst max = Math.max(...numbers);\nconst min = Math.min(...numbers);\nconsole.log(max, min); // 45 3\n```\n\n------\n### bind 메서드\n\n>Function.prototype.bind(thisArg[,arg1[, arg2[, ...]]])\n\n`bind` 메서드는 ES5에서 추가된 기능으로, call과 비슷하지만 즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드입니다.\n다시 새로운 함수를 호출할 때 인수를 넘기면 그 인수들은 기존 `bind` 메서드를 호출할 때 전달했던 인수들의 뒤에 이어서 등록됩니다.\n즉 `bind`메서드는 함수에 this를 미리 적용하는 것과 부분 적용 함수를 구현하는 두 가지 목적을 모두 지닙니다.\n\n```js bind메서드의 this 지정과 부분 적용 함수 구현\nvar func = function(a, b, c, d) {\n  console.log(this, a, b, c, d);\n};\nfunc(1, 2, 3, 4); // Window{ ... } 1 2 3 4\n\n1. var bindFunc1 = func.bind({ x: 1 });\nbindFunc1(5, 6, 7, 8); // { x: 1 } 5 6 7 8\n\n2. var bindFunc2 = func.bind({ x: 1 }, 4, 5);\nbindFunc2(6, 7); // { x: 1 } 4 5 6 7\nbindFunc2(8, 9); // { x: 1 } 4 5 8 9\n```\n\n1. `bindFunc1` 변수에 `func` 변수에 `this`를 `{x : 1}`로 지정하는 새로운 함수가 할당됩니다.\n다음 줄에서 `bindFunc1`을 호출하면 지정된 `this`값과 함께 반환됩니다.\n\n2. `bindFunc2` 변수에는 `func` 변수에 `this`를 `{x : 1}`로 지정하고, 파라미터를 차례대로 4, 5로 지정한 함수 새로운 함수가 할당됩니다. 다음 코드를 호출하면 `this`로 지정해준 값과 파라미터에 지정해준 값이 적용되고 그 다음 함수를 호출하며 넘겨준 파라미터 값이 붙습니다 `{x : 1} 4 5 6 7`, `{x : 1} 4 5 8 9` 형태로 반환됩니다.\n<mark>이것이 bind의 부분 적용 함수 구현법입니다.</mark>\n\n------\n#### name 프로퍼티\n\n<u>bind 메서드를 적용해서 새로 만든 함수는 한 가지 독특한 성질이 있습니다.</u>\nname 프로퍼티에 동사 bind의 수동태인 `bound`라는 접두어가 붙습니다.\n\n함수의 name 프로퍼티가 `bound xxx`이라면 함수명이 xxx인 원본 함수에 `bind`메서드를 적용한 새로운 함수라는 의미가 되므로 call 과 apply 메서드에 비해 코드 추적이 용이한 점이 있습니다.\n\n```js\nvar func = function(a, b, c, d) {\n  console.log(this, a, b, c, d);\n};\nvar bindFunc = func.bind({ x: 1 }, 4, 5);\nconsole.log(func.name); // func\nconsole.log(bindFunc.name); // bound func\n```\n\n------\n#### 상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기\n\n메서드의 내부함수에서 메서드의 `this`를 그대로 바라보게 하기 위한 방법으로\nself 등의 변수를 활용하거나 화살표 함수를 이용한 우회법이 있었는데\n`call`, `apply`, `bind` 메서드를 이용하면 더 깔끔하게 처리할 수 있습니다.\n\n```js 내부함수에 this 전달 - call\nvar obj = {\n  outer: function() {\n    console.log(this); //{outer : f}\n    var innerFunc = function() {\n      console.log(this); //{outer : f}\n    };\n    innerFunc.call(this);\n  },\n};\nobj.outer();\n```\n\n```js 내부함수에 this 전달 -bind\nvar obj = {\n  outer: function() {\n    console.log(this); //{outer : f}\n    var innerFunc = function() {\n      console.log(this); //{outer : f}\n    }.bind(this); // 호출x, 새로운 함수 바인드\n    innerFunc(); // 호출\n  },\n};\nobj.outer();\n```\n\n* 또한 콜백 함수를 인자로 받는 함수(메서드) 중에서 기본적으로 콜백 함수 내에서의 `this`에 관여하는 함수(메서드)에 대해서도 `bind` 메서드를 사용하면 `this`값을 지정하여 바꿀 수 있습니다.\n\n```js bind 메서드 - 내부 함수에 this 전달\nvar obj = {\n  logThis: function() {\n    console.log(this);\n  },\n  logThisLater1: function() {\n    setTimeout(this.logThis, 500);\n  },\n  logThisLater2: function() {\n    setTimeout(this.logThis.bind(this), 1000);\n  },\n};\nobj.logThisLater1(); // Window { ... }\nobj.logThisLater2(); // obj { logThis: f, ... }\n```\n\n------\n### 화살표 함수의 예외사항\n\nES6에 새롭게 도입된 화살표 함수 `=>`는 실행 컨텍스트 생성 시 this를 바인딩 하지 않습니다.\n즉 화살표 함수 `=>` 내부에는 `this`가 아예 없으며, `this`에 접근하고자 하면 스코프체인상 가장 가까운 `this`에 접근하게 됩니다.\n\n```js 화삺표 함수 내부에서의 this\nvar obj = {\n  outer: function() {\n    console.log(this);\n    var innerFunc = () => {\n      console.log(this);\n    };\n    innerFunc();\n  },\n};\nobj.outer();\n```\n\n* `call`, `apply`, `bind`를 사용했던 예제의 내부함수를 `=>`함수로 바꾼 것입니다.\n더욱 간결해졌습니다.\n\n------\n### 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n\n콜백 함수를 인자로 받는 메서드에는 `this`로 지정할 객체(`thisArg`)를 인자로 지정할 수 있는 것들이 있습니다. 이러한 메서드를 이용하여 `this`값을 원하는대로 변경할 수 있습니다.\n\n이러한 메서드는 내부 요소에 대해 같은 동작을 반복 수행해야하는 배열 메서드에 많이 존재하고, 같은 이유로 ES6에 추가된 `Set`, `Map`등의 메서드에도 일부 존재합니다.\n\n* 콜백 함수와 함께 thisArg를 인자로 받는 메서드\n  | Array.prototype                        | Set.prototype                | Map.prototype                |\n|----------------------------------------|------------------------------|------------------------------|\n| `forEach`(callback[, thisArg])           | `forEach`(callback[, thisArg]) | `forEach`(callback[, thisArg]) |\n| `map`(callback[, thisArg])               |                              |                              |\n| `filter`(callback[, thisArg])            |                              |                              |\n| `some`(callback[, thisArg])              |                              |                              |\n| `every`(callback[, thisArg])             |                              |                              |\n| `find`(callback[, thisArg])              |                              |                              |\n| `findIndex`(callback[, thisArg])         |                              |                              |\n| `flatMap`(callback[, thisArg])           |                              |                              |\n| `from`(arrayLike[, callback[, thisArg]]) |                              |                              |\n\n* 대표적인 배열 메서드인 `forEach` 예시\n\n```js forEach\nvar report = {\n  sum: 0,\n  count: 0,\n  add: function() {\n    var args = Array.prototype.slice.call(arguments);\n    args.forEach(function(entry) {\n      this.sum += entry;\n      ++this.count;\n    }, this);\n  },\n  average: function() {\n    return this.sum / this.count;\n  },\n};\nreport.add(60, 85, 95);\nconsole.log(report.sum, report.count, report.average()); // 240 3 80\n```\n\n* `60, 85, 95`를 인자로 삼아 `add` 메서드를 호출하면 `slice.call`메서드가 인자를 받아 새로운 배열로 반환합니다. 이후 `forEach` 메서드가 실행됩니다.\n\n* 콜백 함수 내부의 `this`는 `forEach` 함수의 두 번째 인자로 전달해준 `this`(add 메서드의 this)가 전달된 상태이므로 `add` 메서드의 `this(report)`를 가리킵니다.\n\n* 따라서 배열의 요소들을 순회 반복하며 `report.sum` , `report.count`값이 차례로 바뀌게 됩니다.\n출력 결과로 `report.sum`에 240, `report.count`에 3이 반환되어 출력됩니다.\n\n\n------\n<h2 id=\"this_point\">this 정리</h2>\n\n명시적 `this` 바인딩이 없는 한 항상 성립하는 규칙\n\n  * 전역공간에서의 `this`는 전역객체를 참조 (브라우저에서는 `window`, Node.js에서는 `global`)\n\n  * 함수를 메서드로 호출한 경우 `this`는 메서드 호출 주체를 참조 (메서드명 앞의 객체)\n\n  * 함수를 함수로 호출한 경우 `this`는 전역객체를 참조 (메서드의 내부함수에서도 동일)\n\n  * 콜백 함수 내부에서의 `this`는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바를 참조\n`this`가 정의되어 있지않다면 전역객체를 참조\n\n  * `class` 함수에서 `this`는 생성될 `instance`를 참조\n\n위 규칙에 부합하지 않는 경우 명시적 `this` 바인딩 규칙으로 예측할 수 있습니다.\n\n  * `call`, `apply` 메서드는 `this`를 명시적으로 지정하면서 함수 또는 메서드를 호출\n\n  * `bind` 메서드는 `this` 및 함수에 넘길 파라미터를 일부 지정해 새로운 함수를 만듭니다.\n\n  * 콜백 함수를 반복 순회,호출 하는 일부 메서드는 별도의 인자로 `this`를 받기도 합니다.\n","source":"_posts/this-Core-JavaScript.md","raw":"---\ntitle: this -Core JavaScript\ndisqusId: tunas-blog-1\ntags:\n  - Core JavaScript\n  - JavaScript\ndate: 2020-04-27 21:50:04\ncategories: Core JavaScript\n---\n\n자바스크립트에서의 this는 어디서든 사용할 수 있습니다.\nthis는 상황에 따라 참조하는 대상이 달라질 수 있습니다.\n함수와 객체(메서드) 구분이 느슨한 자바스크립트에서 이 둘을 구분하는 유일한 기능입니다.\n\n* this\n  * [상황에 따라 달라지는 this](/2020/04/27/this-Core-JavaScript/#this)\n    * 전역 공간에서의 this\n    * 메서드로서 호출할 때 메서드 내부의 this\n      * 함수 vs 메서드\n      * 메서드 내부에서의 this\n    * 함수로서 호출할 때 그 함수 내부에서의 this\n      * 함수 내부에서의 this\n      * 메서드의 내부함수에서의 this\n      * 메서드 내부 함수에서의 this를 우회하는 방법\n      * this를 바인딩하지 않는 함수\n    * 콜백 함수 호출시 그 함수 내부에서의 this\n    * Class 함수 내부에서의 this \n  * [명시적으로 this를 바인딩하는 방법](/2020/04/27/this-Core-JavaScript/#this_binding)\n    * call 메서드\n    * apply 메서드\n    * call / apply 메서드의 활용\n      * 생성자 내부에서 다른 생성자를 호출\n      * 여러 인수를 묶어 하나의 배열로 전달\n    * bind 메서드\n      * name 프로퍼티\n      * 상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기\n    * 화살표 => 함수의 예외사항\n    * 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n  * [this 정리](/2020/04/27/this-Core-JavaScript/#this_point) \n\n<!-- more -->\n\n------\n<h2 id=\"this\">상황에 따라 달라지는 this</h2>\n\n* `this`는 기본적으로 <mark>실행 컨텍스트가 생성될 때 함께 결정됩니다.</mark>\n실행 컨텍스트는 함수를 호출할 때 생성되므로, `this`<mark>는 함수를 호출할 때 결정된다고 할 수 있습니다.</mark>\n\n------\n### 전역 공간에서의 this\n\n전역 공간에서 `this`는 전역 객체를 가리킵니다. 브라우저 환경에서 전역객체는 `window`이고 Node.js 환경에서는 `global`입니다.\n\n  * 참고 : 전역 변수\n전역 변수를 선언하면 자바스크립트 엔진은 전역객체의 프로퍼티로 할당시킴.\n```js 전역객체 window의 프로퍼티\nvar a = 1;\nconsole.log(a); // 1\nconsole.log(window.a); // 1 (전역객체의 프로퍼티)\nconsole.log(this.a); // 1 (this는 현재 전역객체 참조)\n```\n<mark>사실 자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로 동작합니다.</mark>\n이 특정 객체란 실행 컨텍스트의 `LexicalEnvironment`를 말합니다.\n실행 컨텍스트는 변수를 수집하여 `LexicalEnvironment`의 프로퍼티로 지정합니다.\n이후 변수를 호출하면 `LexicalEnvironment`를 조회하여 일치하는 프로퍼티가 있을 경우 그 값을 반환합니다.\n\n  전역 컨텍스트의 `LexicalEnvironment`는 전역객체를 참조하므로 var a 선언/할당 이후 `window.a` 와 `this.a`가 1이 나오는 이유는 당연합니다.\n<mark>a를 직접 호출했을 때도 1이 나오는 이유는 무엇일까요?</mark>\n변수 a에 접근하려고 하면 스코프 체인에서 a를 검색하다가 가장 마지막에 도달하는 전역 스코프의 `LexicalEnvironment`에서 해당 프로퍼티 a를 조회하여 그 값을 반환하기 때문입니다.\n\n* 전역 공간에서 var로 변수를 선언하는 대신 window의 프로퍼티에 직접 할당하더라도 결과적으로 똑같이 동작합니다. 하지만 `delete` 연산자를 사용하는 경우 다른 결과를 반환합니다.\n\n  * `var` 변수로 선언한 경우 : delete window 형식으로 삭제 불가,\n  delete 변수명 형식으로도 삭제 불가\n  * `window` 프로퍼티에 직접 할당한 경우: delete window 형식으로 삭제 가능,\n  delete 변수명 형식으로도 삭제 가능\n\n------\n### 메서드로서 호출할 때 그 메서드 내부에서의 this\n\n#### 함수 vs 메서드\n\n함수를 실행하는 방법 중에는 함수로 호출하는 경우와 메서드로서 호출하는 경우가 있습니다.\n함수와 메서드를 구분하는 유일한 차이는 <u>독립성</u>에 있습니다.\n\n* 함수는 그 자체로 독립적인 기능을 수행합니다.\n\n* 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행합니다.\n\n<mark>어떤 함수를 객체의 프로퍼티에 할당한다고 해서 무조건 메서드가 되는 것이 아니라\n객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작합니다.</mark>\n\n```js 메서드로 호출 (점 표기법, 대괄호 표기법)\nvar obj = {\n  method: function(x) {\n    console.log(this, x);\n  },\n};\nobj.method(1); // { method: f } 1\nobj['method'](2); // { method: f } 2\n```\n\n다시 말해 점 표기법이든 대괄호 표기법이든, 어떤 함수를 호출할 때 그 함수 이름 앞에\n객체가 명시돼 있는 경우 메서드로 호출한 것이고, 그렇지 않은 경우에는 함수로 호출한 것입니다.\n\n#### 메서드 내부에서의 this\n\n`this`에는 호출한 주체에 대한 정보가 담깁니다. 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티 명)앞의 객체입니다. 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 `this`가 됩니다.\n\n```js 메서드 내부에서의 this\nvar obj = {\n  methodA: function() {\n    console.log(this);\n  },\n  inner: {\n    methodB: function() {\n      console.log(this);\n    },\n  },\n};\nobj.methodA(); // { methodA: f, inner: {...} }    ( === obj)\nobj['methodA'](); // { methodA: f, inner: {...} } ( === obj)\n\nobj.inner.methodB(); // { methodB: f }            ( === obj.inner)\nobj.inner['methodB'](); // { methodB: f }         ( === obj.inner)\nobj['inner'].methodB(); // { methodB: f }         ( === obj.inner)\nobj['inner']['methodB'](); // { methodB: f }      ( === obj.inner)\n```\n\n------\n### 함수로서 호출할 때 그 함수 내부에서의 this\n\n------\n#### 함수 내부에서의 this\n\n어떤 함수를 함수로서 호출할 경우 `this`가 지정되지 않습니다.(this는 호출한 주체에 대한 정보가 담깁니다.)\n함수로서 호출하는 것은 호출 주체(객체지향 언어에서의 객체)를 명시하지 않고 실행한 것이기 때문에 호출 주체의 정보를 알 수 없는 것입니다. \n<mark>this가 지정되지 않은 경우 this는 전역 객체를 참조합니다.</mark>\n따라서 함수에서의 `this`는 전역 객체를 가리킵니다.\n\n------\n#### 메서드의 내부함수에서의 this\n\n메서드 내부에서 정의하고 실행한 함수에서의 this는 자바스크립트 초심자들이 this에 관해 가장 자주 혼란을 느끼는 점입니다.\n\n<mark>내부함수 역시 이를 함수로 호출했는지 메서드로 호출했는지만 파악하면 this의 값을 정확히 맞출 수 있습니다.</mark>\n\n```js 내부함수에서의 this\n1. var obj1 = {\n  3. outer: function() {\n    4. console.log(this); // (1)\n    5. 7. var innerFunc = function() {\n      8. console.log(this); // (2) (3)\n    };\n    6. innerFunc();\n\n    9. 11. var obj2 = {\n      12. innerMethod: innerFunc,\n    };\n    10. obj2.innerMethod();\n  },\n};\n2. obj1.outer();\n// (1): obj1\n// (2): 전역객체(window)\n// (3): obj2\n```\n\n(2)는 `innerFunc`를 호출한 결과를, (3)은 `obj2.innerMethod`를 호출한 결과입니다.\n\n1. 객체를 생성하는데 내부에 outer 프로퍼티가 있습니다. outer 프로퍼티에 익명함수가 연결되고 생성된 객체를 변수 `obj1`에 할당합니다.\n\n\n2. `obj1.outer()`를 호출합니다.\n\n\n3. `obj1.outer` 함수의 실행 컨텍스트가 생성되면서 호이스팅하고, 스코프 체인 정보를 수집하고, this를 바인딩합니다.\n이 함수는 호출될 때 함수명 `outer` 앞에 점(.)이 있었으므로 메서드로서 호출된 것입니다.\n따라서 `this`는 점(.)앞에 객체인 `obj1`을 바인딩합니다.\n\n\n4. `this`가 바인딩된 `obj1` 객체 정보가 출력됩니다.\n\n\n5. 호이스팅된 변수 `innerFunc`는 outer 스코프 내에서만 접근할 수 있는 지역변수 입니다. 이 변수에 익명 함수를 할당합니다.\n\n\n6. `innerFunc()`를 호출합니다.\n\n\n7. `innerFunc` 함수의 실행 컨텍스트가 생성되면서 호이스팅,스코프 체인 수집, this 바인딩 등을 수행합니다.\n이 함수는 호출될 때 ~~함수명 앞에 점(.)이 없었습니다.~~ 함수로서 호출되었습니다.\n따라서 this가 지정되지 않았고, 자동으로 스코프 체인상의 최상위 객체인 전역객체(window)가 바인딩 됩니다.\n\n\n8. `this`가 바인딩된 `window` 객체 정보가 출력됩니다.\n\n\n9. `obj2` 역시 outer 스코프 내부에서만 접근할 수 있는 지역변수 입니다. \n`obj2` 변수에는 `object`를 할당하는데, object 안에 `innerMethod`라는 프로퍼티가 존재하고, 프로퍼티 값으로 앞서 정의된 변수 `innerFunc`와 연결된 익명 함수가 지정됩니다.\n\n\n10. `obj2.innerMethod()`를 호출합니다.\n\n\n11. `obj2. innerMethod` 함수의 실행 컨텍스트가 생성됩니다. 이 함수는 호출할 때 함수명인 `innerMethod` 앞에 점(.)이 있었으므로 메서드로서 호출한 것입니다.\n따라서 `this`에는 마지막 점 앞의 객체인 `obj2`가 바인딩 됩니다.\n\n\n12. `obj2` 객체 정보가 출력됩니다.\n\n* 정리하자면 \n<mark>this 바인딩에 관해서는 함수를 실행하는 당시의 주변 환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고 오직 해당 함수를 호출하는 구문 앞에 점(.) 또는 대괄호[] 표기가 있는지 없는지가 관건입니다.</mark>\n\n------\n#### 메서드의 내부 함수에서의 this를 우회하는 방법\n\n호출 주체가 없을 때 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변 환경의 `this`를 그대로 상속받아 사용하고 싶다면\n간단하고 대표적인 방법으로 변수를 활용하는 방법이 있습니다.\n\n```js 내부함수에서의 this를 변수를 활용하여 우회하기\nvar obj = {\n  outer: function() {\n    console.log(this); // (1) { outer: f }\n    var innerFunc1 = function() {\n      console.log(this); // (2) Window { ... }\n    };\n    innerFunc1();\n\n    var self = this;\n    var innerFunc2 = function() {\n      console.log(self); // (3) { outer: f }\n    };\n    innerFunc2();\n  },\n};\nobj.outer();\n```\n\n1. `innerFunc1` 내부에서 `this`는 전역객체를 가리킵니다.\n\n2. outer 스코프에서 `self`라는 변수에 `this`를 저장한 상태에서 호출한 `innerFunc2`의 경우 `self`에는 객체 obj가 출력됩니다.\n\n~~그저 상위 스코프의 this를 저장해서 내부함수에서 활용하려는 수단이므로 변수명은 달라도 무관합니다.~~\n\n------\n#### this를 바인딩하지 않는 함수\n\nES6에서는 함수 내부에서 `this`가 전역객체를 바라보는 문제를 보안하고자, \n`this`를 바인딩하지 않는 <mark>화살표 함수(Arrow function)</mark>를 새로 도입했습니다. \n\n화살표 함수는 실행 컨텍스트를 생성할 때 `this` 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 `this`를 그대로 활용할 수 있습니다.\n\n```js 화살표 함수\nvar obj = {\n  outer: function() {\n    console.log(this); // (1) { outer: f }\n    var innerFunc = () => {\n      console.log(this); // (2) { outer: f }\n    };\n    innerFunc();\n  },\n};\nobj.outer();\n```\n\n이 밖에도 `call`, `apply` 등의 메서드를 활용해 함수를 호출할 때 명시적으로 `this`를 지정하는 방법이 있습니다.\n\n------\n### 콜백 함수 호출 시 그 함수 내부에서의 this\n\n* `함수 A`의 제어권을 `다른 함수(또는 메서드) B`에게 넘겨주는 경우 `함수 A`를 `콜백 함수`라고 합니다.\n\n* 이때 `함수 A`는 `함수 B`의 내부 로직에 따라 실행되며, `this` 역시 `함수 B` 내부 로직에서 정한 규칙에 따라 값이 결정됩니다.\n\n* `콜백 함수` 역시 함수이므로 기본적으로 `this`가 전역객체를 참조하지만, 제어권을 받은 함수 (함수 B)에서 `콜백 함수`에 별도로 `this`가 될 대상을 지정한 경우에는 그 대상을 참조하게 됩니다.\n\n```js 콜백 함수 내부에서의 this\nsetTimeout(function() {\n  console.log(this);\n}, 300); // (1) window\n\n[1, 2, 3, 4, 5].forEach(function(x) {\n  // (2) window\n  console.log(this, x);\n});\n\ndocument.body.innerHTML += '<button id=\"a\">클릭</button>';\ndocument.body.querySelector('#a').addEventListener('click', function(e) {\n  // (3) <button id=\"a\">클릭</button>\n  console.log(this, e);\n});\n```\n\n1. 0.3초 뒤 전역객체가 출력됩니다.\n\n2. 배열의 각 요소를 차례대로 콜백 함수의 첫 번째 인자로 삼아 전역객체와 배열의 각 요소가 총 5회 출력됩니다.\n\n3. 지정한 `HTML` 엘리먼트에 `'click'` 이벤트가 발생할 때 마다 그 이벤트 정보를 콜백 함수의 첫 번째 인자로 삼아 함수를 실행합니다. 버튼을 클릭하면 앞서 지정한 엘리먼트와 클릭 이벤트에 관한 정보가 담긴 객체가 출력됩니다.\n\n이 처럼 콜백 함수에서의 `this`는 한가지로 정의할 수 없습니다.\n<mark>콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 정할지 결정하며</mark>,\n따로 정의하지 않은 경우 기본적으로 전역객체를 참조합니다.\n\n------\n### Class 함수 내부에서의 this\n\n객체지향 언어에서 생성자를 클래스(`class`), \n클래스를 통해 만든 객체를 인스턴스 (`instance`)라고 합니다.\n\n프로그래밍적으로 `class`는 구체적인 `instance`를 만들기 위한 일종의 틀입니다.\n틀 안에는 해당 `class`의 공통 속성들이 준비되어 있고, 추가로 개별 `instance`를 만들 수 있습니다.\n\n`new` 키워드와 함께 함수를 호출하면 해당 함수가 `class`로서 동작합니다.\n`class`로서 함수가 호출된 경우 내부에서의 `this`는 `instance`가 됩니다.\n\n* `class` 함수를 `new`키워드로 호출 하면 엔진은 `class`의 `prototype` 프로퍼티를 참조하는 `__proto__` 프로퍼티 `instance`를 만들고 공통 속성 및 특성 들을 해당 객체(`this`)에 부여합니다.\n`instance`가 생성됩니다.\n\n```js class 함수\nvar Cat = function(name, age) {\n  this.bark = '야옹';\n  this.name = name;\n  this.age = age;\n};\nvar choco = new Cat('초코', 7);\nvar nabi = new Cat('나비', 5);\nconsole.log(choco, nabi);\n\n/* 결과\nCat { bark: '야옹', name: '초코', age: 7 }\nCat { bark: '야옹', name: '나비', age: 5 }\n*/\n```\n\n1. `new` 키워드와 함께 Cat 함수를 호출하여 변수 choco, nabi에 각각 할당 했습니다.\n\n2. `console.log` 출력 결과 `this`가 각각 Cat `class`의 `instance`를 참조하여 반환합니다.\n(`choco instance`, `nabi instance`)\n\n------\n<h2 id=\"this_binding\">명시적으로 this를 바인딩하는 방법</h2>\n\n상황에 따라 this에 바인딩 되는 값들을 살펴봤지만 이런 규칙을 무시?하고 this에 대상을 지정하여 바인딩하는 방법도 있습니다.\n\n------\n### call 메서드\n\n> Function.prototype.call(thisArg[, arg1[, arg2[, ...]]])\n\n`call` 메서드는 호출 주체인 함수를 즉시 실행하도록 합니다.\n`call` 메서드의 첫 번째 인자를 `this`로 바인딩 하고, 이후에 인자들을 호출할 함수의 매개변수로 사용합니다.\n\n`call`메서드를 이용하여 `this` 값으로 참조할 객체를 지정할 수 있습니다. \n\n```js call 메서드\nvar func = function(a, b, c) {\n  console.log(this, a, b, c);\n};\n\nfunc(1, 2, 3); // Window{ ... } 1 2 3\nfunc.call({ x: 1 }, 4, 5, 6); // { x: 1 } 4 5 6\n```\n\n* `func.call`에서 메서드의 첫 번째 인자 `{x : 1}`를 `this`가 참조할 값으로 던져줍니다.\n\n* 객체의 메서드를 호출하면 `this`는 객체를 참조하게 되지만, `call` 메서드는 이렇듯 임의의 객체를 `this`로 지정할 수 있습니다.\n\n------\n### apply 메서드\n\n> Function.prototype.apply(thisArg[, argsArray])\n\n`apply` 메서드는 기능적으로 `call` 메서드와 완전히 동일합니다.\n\n`apply`메서드는 <mark>두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 점에서 차이가 있습니다.</mark>\n\n```js apply 메서드\nvar func = function(a, b, c) {\n  console.log(this, a, b, c);\n};\nfunc.apply({ x: 1 }, [4, 5, 6]); // { x: 1 } 4 5 6\n\nvar obj = {\n  a: 1,\n  method: function(x, y) {\n    console.log(this.a, x, y);\n  },\n};\nobj.method.apply({ a: 4 }, [5, 6]); // 4 5 6\n```\n\n------\n### call / apply 메서드의 활용\n\n`call` 과 `apply` 메서드의 활용 사례\n\n------\n#### 유사 배열객체에 배열 메서드 적용\n\n```js 유사 배열객체에서 배열 메서드 사용하기\nvar obj = {\n  0: 'a',\n  1: 'b',\n  2: 'c',\n  length: 3,\n};\nArray.prototype.push.call(obj, 'd');\nconsole.log(obj); // { 0: 'a', 1: 'b', 2: 'c', 3: 'd', length: 4 }\n\nvar arr = Array.prototype.slice.call(obj);\nconsole.log(arr); // [ 'a', 'b', 'c', 'd' ]\n```\n\n* 유사배열객체인 경우 `call` 또는 `apply` 메서드를 이용해 배열 메서드를 사용할 수 있습니다.\n\n* 배열 메서드인 `push`를 `객체 obj`에 적용해 프로퍼티 3에 'd'를 추가했습니다.\n\n* 배열 메서드인 `slice`로 얕은 복사하여 객체를 배열로 반환했습니다.\n\n이 밖에도 유사배열객체에는 `call`, `apply` 메서드를 이용해 모든 배열 메서드를 적용할 수 있습니다.\n단, 문자열의 경우 `length` 프로퍼티가 읽기 전용이기 때문에 원본 문자열에 변경을 가하는 메서드(`push`, `pop`, `shift`, `unshift`, `splice` 등)는 에러를 던지며, `concat` 처럼 대상이 반드시 배열이어야 하는 경우에는 에러는 나지 않지만 재대로 된 결과를 얻을 수 없습니다.\n\n* 사실 `call`, `apply`를 이용해 형변환하는 것은 '`this`를 원하는 값으로 지정해서 호출한다'라는 본래의 메서드의 의도와는 어긋나는 활용법이라고 할 수 있습니다.\n또한 코드만 봐서는 어떤 의도인지 파악하기 쉽지 않습니다.\n\n\n* <mark>ES6 에서는 유사배열객체 또는 이터러블한 모든 종류의 데이터 타입을 배열로 전환</mark>하는 `Array.from`메서드가 추가되었습니다.\n\n------\n#### Array.from\n\nArray 오브젝트를 생성하고 콜백 함수에서 반환된 값을 엘리먼트 값으로 설정하여 새로운 Array 객체를 반환합니다.\n\n>Array.from(arrayLike[, mapFn[, thisArg]])\n\n* arrayLike\n배열로 변환하고자 하는 유사 배열 객체(Array-like)나 반복 가능한 객체(이터러블 오브젝트).\n\n* mapFn (선택적 파라미터)\n배열의 모든 엘리먼트 마다 호출할 함수.\n\n* thisArg (선택적 파라미터)\n두 번째 파라미터 함수 실행 시에 this로 참조할 값.\n\n* 반환 값\n새로운 Array 인스턴스.\n\n```js ES6의 Array.from\nvar obj = {\n  0: 'a',\n  1: 'b',\n  2: 'c',\n  length: 3,\n};\nvar arr = Array.from(obj);\nconsole.log(arr); // ['a', 'b', 'c']\n```\n\n------\n#### class 내부에서 다른 class를 호출\n\n`class` 내부에 다른 `class`와 공통된 내용이 있을 경우 `call` 또는 `apply`를 이용해 다른 `class`를 호출하면 간단하게 반복을 줄일 수 있습니다.\n\n```js class 내부에서 다른 class 호출\nfunction Person(name, gender) {\n  this.name = name;\n  this.gender = gender;\n}\nfunction Student(name, gender, school) {\n  Person.call(this, name, gender);\n  this.school = school;\n}\nfunction Employee(name, gender, company) {\n  Person.apply(this, [name, gender]);\n  this.company = company;\n}\nvar by = new Student('보영', 'female', '단국대');\nvar jn = new Employee('재난', 'male', '구골');\n```\n\nStudent, Employee class함수 내부에서 Person 함수를 호출해서 instance 속성을 정의하게 했습니다.\n\n------\n#### 여러 인수를 묶어 하나의 배열로 전달하고 싶을 때\n\n`apply`메서드를 사용해 하나의 배열로 인수들을 전달할 수 있습니다.\n\n```js 여러 인수를 받는 메서드(Math.max/Math.min)에 apply 적용\nvar numbers = [10, 20, 3, 16, 45];\nvar max = Math.max.apply(null, numbers);\nvar min = Math.min.apply(null, numbers);\nconsole.log(max, min); // 45 3\n```\n\nES6에서는 `spread` 연산자를 이용하면 `apply`를 적용하는 것보다 더욱 간편하게 작성할 수 있습니다.\n\n```js\nconst numbers = [10, 20, 3, 16, 45];\nconst max = Math.max(...numbers);\nconst min = Math.min(...numbers);\nconsole.log(max, min); // 45 3\n```\n\n------\n### bind 메서드\n\n>Function.prototype.bind(thisArg[,arg1[, arg2[, ...]]])\n\n`bind` 메서드는 ES5에서 추가된 기능으로, call과 비슷하지만 즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드입니다.\n다시 새로운 함수를 호출할 때 인수를 넘기면 그 인수들은 기존 `bind` 메서드를 호출할 때 전달했던 인수들의 뒤에 이어서 등록됩니다.\n즉 `bind`메서드는 함수에 this를 미리 적용하는 것과 부분 적용 함수를 구현하는 두 가지 목적을 모두 지닙니다.\n\n```js bind메서드의 this 지정과 부분 적용 함수 구현\nvar func = function(a, b, c, d) {\n  console.log(this, a, b, c, d);\n};\nfunc(1, 2, 3, 4); // Window{ ... } 1 2 3 4\n\n1. var bindFunc1 = func.bind({ x: 1 });\nbindFunc1(5, 6, 7, 8); // { x: 1 } 5 6 7 8\n\n2. var bindFunc2 = func.bind({ x: 1 }, 4, 5);\nbindFunc2(6, 7); // { x: 1 } 4 5 6 7\nbindFunc2(8, 9); // { x: 1 } 4 5 8 9\n```\n\n1. `bindFunc1` 변수에 `func` 변수에 `this`를 `{x : 1}`로 지정하는 새로운 함수가 할당됩니다.\n다음 줄에서 `bindFunc1`을 호출하면 지정된 `this`값과 함께 반환됩니다.\n\n2. `bindFunc2` 변수에는 `func` 변수에 `this`를 `{x : 1}`로 지정하고, 파라미터를 차례대로 4, 5로 지정한 함수 새로운 함수가 할당됩니다. 다음 코드를 호출하면 `this`로 지정해준 값과 파라미터에 지정해준 값이 적용되고 그 다음 함수를 호출하며 넘겨준 파라미터 값이 붙습니다 `{x : 1} 4 5 6 7`, `{x : 1} 4 5 8 9` 형태로 반환됩니다.\n<mark>이것이 bind의 부분 적용 함수 구현법입니다.</mark>\n\n------\n#### name 프로퍼티\n\n<u>bind 메서드를 적용해서 새로 만든 함수는 한 가지 독특한 성질이 있습니다.</u>\nname 프로퍼티에 동사 bind의 수동태인 `bound`라는 접두어가 붙습니다.\n\n함수의 name 프로퍼티가 `bound xxx`이라면 함수명이 xxx인 원본 함수에 `bind`메서드를 적용한 새로운 함수라는 의미가 되므로 call 과 apply 메서드에 비해 코드 추적이 용이한 점이 있습니다.\n\n```js\nvar func = function(a, b, c, d) {\n  console.log(this, a, b, c, d);\n};\nvar bindFunc = func.bind({ x: 1 }, 4, 5);\nconsole.log(func.name); // func\nconsole.log(bindFunc.name); // bound func\n```\n\n------\n#### 상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기\n\n메서드의 내부함수에서 메서드의 `this`를 그대로 바라보게 하기 위한 방법으로\nself 등의 변수를 활용하거나 화살표 함수를 이용한 우회법이 있었는데\n`call`, `apply`, `bind` 메서드를 이용하면 더 깔끔하게 처리할 수 있습니다.\n\n```js 내부함수에 this 전달 - call\nvar obj = {\n  outer: function() {\n    console.log(this); //{outer : f}\n    var innerFunc = function() {\n      console.log(this); //{outer : f}\n    };\n    innerFunc.call(this);\n  },\n};\nobj.outer();\n```\n\n```js 내부함수에 this 전달 -bind\nvar obj = {\n  outer: function() {\n    console.log(this); //{outer : f}\n    var innerFunc = function() {\n      console.log(this); //{outer : f}\n    }.bind(this); // 호출x, 새로운 함수 바인드\n    innerFunc(); // 호출\n  },\n};\nobj.outer();\n```\n\n* 또한 콜백 함수를 인자로 받는 함수(메서드) 중에서 기본적으로 콜백 함수 내에서의 `this`에 관여하는 함수(메서드)에 대해서도 `bind` 메서드를 사용하면 `this`값을 지정하여 바꿀 수 있습니다.\n\n```js bind 메서드 - 내부 함수에 this 전달\nvar obj = {\n  logThis: function() {\n    console.log(this);\n  },\n  logThisLater1: function() {\n    setTimeout(this.logThis, 500);\n  },\n  logThisLater2: function() {\n    setTimeout(this.logThis.bind(this), 1000);\n  },\n};\nobj.logThisLater1(); // Window { ... }\nobj.logThisLater2(); // obj { logThis: f, ... }\n```\n\n------\n### 화살표 함수의 예외사항\n\nES6에 새롭게 도입된 화살표 함수 `=>`는 실행 컨텍스트 생성 시 this를 바인딩 하지 않습니다.\n즉 화살표 함수 `=>` 내부에는 `this`가 아예 없으며, `this`에 접근하고자 하면 스코프체인상 가장 가까운 `this`에 접근하게 됩니다.\n\n```js 화삺표 함수 내부에서의 this\nvar obj = {\n  outer: function() {\n    console.log(this);\n    var innerFunc = () => {\n      console.log(this);\n    };\n    innerFunc();\n  },\n};\nobj.outer();\n```\n\n* `call`, `apply`, `bind`를 사용했던 예제의 내부함수를 `=>`함수로 바꾼 것입니다.\n더욱 간결해졌습니다.\n\n------\n### 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n\n콜백 함수를 인자로 받는 메서드에는 `this`로 지정할 객체(`thisArg`)를 인자로 지정할 수 있는 것들이 있습니다. 이러한 메서드를 이용하여 `this`값을 원하는대로 변경할 수 있습니다.\n\n이러한 메서드는 내부 요소에 대해 같은 동작을 반복 수행해야하는 배열 메서드에 많이 존재하고, 같은 이유로 ES6에 추가된 `Set`, `Map`등의 메서드에도 일부 존재합니다.\n\n* 콜백 함수와 함께 thisArg를 인자로 받는 메서드\n  | Array.prototype                        | Set.prototype                | Map.prototype                |\n|----------------------------------------|------------------------------|------------------------------|\n| `forEach`(callback[, thisArg])           | `forEach`(callback[, thisArg]) | `forEach`(callback[, thisArg]) |\n| `map`(callback[, thisArg])               |                              |                              |\n| `filter`(callback[, thisArg])            |                              |                              |\n| `some`(callback[, thisArg])              |                              |                              |\n| `every`(callback[, thisArg])             |                              |                              |\n| `find`(callback[, thisArg])              |                              |                              |\n| `findIndex`(callback[, thisArg])         |                              |                              |\n| `flatMap`(callback[, thisArg])           |                              |                              |\n| `from`(arrayLike[, callback[, thisArg]]) |                              |                              |\n\n* 대표적인 배열 메서드인 `forEach` 예시\n\n```js forEach\nvar report = {\n  sum: 0,\n  count: 0,\n  add: function() {\n    var args = Array.prototype.slice.call(arguments);\n    args.forEach(function(entry) {\n      this.sum += entry;\n      ++this.count;\n    }, this);\n  },\n  average: function() {\n    return this.sum / this.count;\n  },\n};\nreport.add(60, 85, 95);\nconsole.log(report.sum, report.count, report.average()); // 240 3 80\n```\n\n* `60, 85, 95`를 인자로 삼아 `add` 메서드를 호출하면 `slice.call`메서드가 인자를 받아 새로운 배열로 반환합니다. 이후 `forEach` 메서드가 실행됩니다.\n\n* 콜백 함수 내부의 `this`는 `forEach` 함수의 두 번째 인자로 전달해준 `this`(add 메서드의 this)가 전달된 상태이므로 `add` 메서드의 `this(report)`를 가리킵니다.\n\n* 따라서 배열의 요소들을 순회 반복하며 `report.sum` , `report.count`값이 차례로 바뀌게 됩니다.\n출력 결과로 `report.sum`에 240, `report.count`에 3이 반환되어 출력됩니다.\n\n\n------\n<h2 id=\"this_point\">this 정리</h2>\n\n명시적 `this` 바인딩이 없는 한 항상 성립하는 규칙\n\n  * 전역공간에서의 `this`는 전역객체를 참조 (브라우저에서는 `window`, Node.js에서는 `global`)\n\n  * 함수를 메서드로 호출한 경우 `this`는 메서드 호출 주체를 참조 (메서드명 앞의 객체)\n\n  * 함수를 함수로 호출한 경우 `this`는 전역객체를 참조 (메서드의 내부함수에서도 동일)\n\n  * 콜백 함수 내부에서의 `this`는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바를 참조\n`this`가 정의되어 있지않다면 전역객체를 참조\n\n  * `class` 함수에서 `this`는 생성될 `instance`를 참조\n\n위 규칙에 부합하지 않는 경우 명시적 `this` 바인딩 규칙으로 예측할 수 있습니다.\n\n  * `call`, `apply` 메서드는 `this`를 명시적으로 지정하면서 함수 또는 메서드를 호출\n\n  * `bind` 메서드는 `this` 및 함수에 넘길 파라미터를 일부 지정해 새로운 함수를 만듭니다.\n\n  * 콜백 함수를 반복 순회,호출 하는 일부 메서드는 별도의 인자로 `this`를 받기도 합니다.\n","slug":"this-Core-JavaScript","published":1,"updated":"2020-05-04T12:54:06.982Z","_id":"ck9iqcrt8002mqgvq2wa9c5ob","comments":1,"layout":"post","photos":[],"link":"","content":"<p>자바스크립트에서의 this는 어디서든 사용할 수 있습니다.<br>this는 상황에 따라 참조하는 대상이 달라질 수 있습니다.<br>함수와 객체(메서드) 구분이 느슨한 자바스크립트에서 이 둘을 구분하는 유일한 기능입니다.</p>\n<ul>\n<li>this<ul>\n<li><a href=\"/2020/04/27/this-Core-JavaScript/#this\">상황에 따라 달라지는 this</a><ul>\n<li>전역 공간에서의 this</li>\n<li>메서드로서 호출할 때 메서드 내부의 this<ul>\n<li>함수 vs 메서드</li>\n<li>메서드 내부에서의 this</li>\n</ul>\n</li>\n<li>함수로서 호출할 때 그 함수 내부에서의 this<ul>\n<li>함수 내부에서의 this</li>\n<li>메서드의 내부함수에서의 this</li>\n<li>메서드 내부 함수에서의 this를 우회하는 방법</li>\n<li>this를 바인딩하지 않는 함수</li>\n</ul>\n</li>\n<li>콜백 함수 호출시 그 함수 내부에서의 this</li>\n<li>Class 함수 내부에서의 this </li>\n</ul>\n</li>\n<li><a href=\"/2020/04/27/this-Core-JavaScript/#this_binding\">명시적으로 this를 바인딩하는 방법</a><ul>\n<li>call 메서드</li>\n<li>apply 메서드</li>\n<li>call / apply 메서드의 활용<ul>\n<li>생성자 내부에서 다른 생성자를 호출</li>\n<li>여러 인수를 묶어 하나의 배열로 전달</li>\n</ul>\n</li>\n<li>bind 메서드<ul>\n<li>name 프로퍼티</li>\n<li>상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기</li>\n</ul>\n</li>\n<li>화살표 =&gt; 함수의 예외사항</li>\n<li>별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/27/this-Core-JavaScript/#this_point\">this 정리</a> </li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"this\">상황에 따라 달라지는 this</h2>\n\n<ul>\n<li><code>this</code>는 기본적으로 <mark>실행 컨텍스트가 생성될 때 함께 결정됩니다.</mark><br>실행 컨텍스트는 함수를 호출할 때 생성되므로, <code>this</code><mark>는 함수를 호출할 때 결정된다고 할 수 있습니다.</mark></li>\n</ul>\n<hr>\n<h3 id=\"전역-공간에서의-this\"><a href=\"#전역-공간에서의-this\" class=\"headerlink\" title=\"전역 공간에서의 this\"></a>전역 공간에서의 this</h3><p>전역 공간에서 <code>this</code>는 전역 객체를 가리킵니다. 브라우저 환경에서 전역객체는 <code>window</code>이고 Node.js 환경에서는 <code>global</code>입니다.</p>\n<ul>\n<li><p>참고 : 전역 변수<br>전역 변수를 선언하면 자바스크립트 엔진은 전역객체의 프로퍼티로 할당시킴.</p>\n<figure class=\"highlight js\"><figcaption><span>전역객체 window의 프로퍼티</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.a); <span class=\"comment\">// 1 (전역객체의 프로퍼티)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a); <span class=\"comment\">// 1 (this는 현재 전역객체 참조)</span></span><br></pre></td></tr></table></figure>\n<p><mark>사실 자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로 동작합니다.</mark><br>이 특정 객체란 실행 컨텍스트의 <code>LexicalEnvironment</code>를 말합니다.<br>실행 컨텍스트는 변수를 수집하여 <code>LexicalEnvironment</code>의 프로퍼티로 지정합니다.<br>이후 변수를 호출하면 <code>LexicalEnvironment</code>를 조회하여 일치하는 프로퍼티가 있을 경우 그 값을 반환합니다.</p>\n<p>전역 컨텍스트의 <code>LexicalEnvironment</code>는 전역객체를 참조하므로 var a 선언/할당 이후 <code>window.a</code> 와 <code>this.a</code>가 1이 나오는 이유는 당연합니다.<br><mark>a를 직접 호출했을 때도 1이 나오는 이유는 무엇일까요?</mark><br>변수 a에 접근하려고 하면 스코프 체인에서 a를 검색하다가 가장 마지막에 도달하는 전역 스코프의 <code>LexicalEnvironment</code>에서 해당 프로퍼티 a를 조회하여 그 값을 반환하기 때문입니다.</p>\n</li>\n</ul>\n<ul>\n<li><p>전역 공간에서 var로 변수를 선언하는 대신 window의 프로퍼티에 직접 할당하더라도 결과적으로 똑같이 동작합니다. 하지만 <code>delete</code> 연산자를 사용하는 경우 다른 결과를 반환합니다.</p>\n<ul>\n<li><code>var</code> 변수로 선언한 경우 : delete window 형식으로 삭제 불가,<br>delete 변수명 형식으로도 삭제 불가</li>\n<li><code>window</code> 프로퍼티에 직접 할당한 경우: delete window 형식으로 삭제 가능,<br>delete 변수명 형식으로도 삭제 가능</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"메서드로서-호출할-때-그-메서드-내부에서의-this\"><a href=\"#메서드로서-호출할-때-그-메서드-내부에서의-this\" class=\"headerlink\" title=\"메서드로서 호출할 때 그 메서드 내부에서의 this\"></a>메서드로서 호출할 때 그 메서드 내부에서의 this</h3><h4 id=\"함수-vs-메서드\"><a href=\"#함수-vs-메서드\" class=\"headerlink\" title=\"함수 vs 메서드\"></a>함수 vs 메서드</h4><p>함수를 실행하는 방법 중에는 함수로 호출하는 경우와 메서드로서 호출하는 경우가 있습니다.<br>함수와 메서드를 구분하는 유일한 차이는 <u>독립성</u>에 있습니다.</p>\n<ul>\n<li><p>함수는 그 자체로 독립적인 기능을 수행합니다.</p>\n</li>\n<li><p>메서드는 자신을 호출한 대상 객체에 관한 동작을 수행합니다.</p>\n</li>\n</ul>\n<p><mark>어떤 함수를 객체의 프로퍼티에 할당한다고 해서 무조건 메서드가 되는 것이 아니라<br>객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작합니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>메서드로 호출 (점 표기법, 대괄호 표기법)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, x);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.method(<span class=\"number\">1</span>); <span class=\"comment\">// &#123; method: f &#125; 1</span></span><br><span class=\"line\">obj[<span class=\"string\">'method'</span>](<span class=\"number\">2</span>); <span class=\"comment\">// &#123; method: f &#125; 2</span></span><br></pre></td></tr></table></figure>\n\n<p>다시 말해 점 표기법이든 대괄호 표기법이든, 어떤 함수를 호출할 때 그 함수 이름 앞에<br>객체가 명시돼 있는 경우 메서드로 호출한 것이고, 그렇지 않은 경우에는 함수로 호출한 것입니다.</p>\n<h4 id=\"메서드-내부에서의-this\"><a href=\"#메서드-내부에서의-this\" class=\"headerlink\" title=\"메서드 내부에서의 this\"></a>메서드 내부에서의 this</h4><p><code>this</code>에는 호출한 주체에 대한 정보가 담깁니다. 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티 명)앞의 객체입니다. 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 <code>this</code>가 됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>메서드 내부에서의 this</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  methodA: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  inner: &#123;</span><br><span class=\"line\">    methodB: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.methodA(); <span class=\"comment\">// &#123; methodA: f, inner: &#123;...&#125; &#125;    ( === obj)</span></span><br><span class=\"line\">obj[<span class=\"string\">'methodA'</span>](); <span class=\"comment\">// &#123; methodA: f, inner: &#123;...&#125; &#125; ( === obj)</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.inner.methodB(); <span class=\"comment\">// &#123; methodB: f &#125;            ( === obj.inner)</span></span><br><span class=\"line\">obj.inner[<span class=\"string\">'methodB'</span>](); <span class=\"comment\">// &#123; methodB: f &#125;         ( === obj.inner)</span></span><br><span class=\"line\">obj[<span class=\"string\">'inner'</span>].methodB(); <span class=\"comment\">// &#123; methodB: f &#125;         ( === obj.inner)</span></span><br><span class=\"line\">obj[<span class=\"string\">'inner'</span>][<span class=\"string\">'methodB'</span>](); <span class=\"comment\">// &#123; methodB: f &#125;      ( === obj.inner)</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"함수로서-호출할-때-그-함수-내부에서의-this\"><a href=\"#함수로서-호출할-때-그-함수-내부에서의-this\" class=\"headerlink\" title=\"함수로서 호출할 때 그 함수 내부에서의 this\"></a>함수로서 호출할 때 그 함수 내부에서의 this</h3><hr>\n<h4 id=\"함수-내부에서의-this\"><a href=\"#함수-내부에서의-this\" class=\"headerlink\" title=\"함수 내부에서의 this\"></a>함수 내부에서의 this</h4><p>어떤 함수를 함수로서 호출할 경우 <code>this</code>가 지정되지 않습니다.(this는 호출한 주체에 대한 정보가 담깁니다.)<br>함수로서 호출하는 것은 호출 주체(객체지향 언어에서의 객체)를 명시하지 않고 실행한 것이기 때문에 호출 주체의 정보를 알 수 없는 것입니다.<br><mark>this가 지정되지 않은 경우 this는 전역 객체를 참조합니다.</mark><br>따라서 함수에서의 <code>this</code>는 전역 객체를 가리킵니다.</p>\n<hr>\n<h4 id=\"메서드의-내부함수에서의-this\"><a href=\"#메서드의-내부함수에서의-this\" class=\"headerlink\" title=\"메서드의 내부함수에서의 this\"></a>메서드의 내부함수에서의 this</h4><p>메서드 내부에서 정의하고 실행한 함수에서의 this는 자바스크립트 초심자들이 this에 관해 가장 자주 혼란을 느끼는 점입니다.</p>\n<p><mark>내부함수 역시 이를 함수로 호출했는지 메서드로 호출했는지만 파악하면 this의 값을 정확히 맞출 수 있습니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>내부함수에서의 this</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  <span class=\"number\">3.</span> outer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// (1)</span></span><br><span class=\"line\">    <span class=\"number\">5.</span> <span class=\"number\">7.</span> <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"number\">8.</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// (2) (3)</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"number\">6.</span> innerFunc();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">9.</span> <span class=\"number\">11.</span> <span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">      <span class=\"number\">12.</span> innerMethod: innerFunc,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"number\">10.</span> obj2.innerMethod();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"number\">2.</span> obj1.outer();</span><br><span class=\"line\"><span class=\"comment\">// (1): obj1</span></span><br><span class=\"line\"><span class=\"comment\">// (2): 전역객체(window)</span></span><br><span class=\"line\"><span class=\"comment\">// (3): obj2</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)는 <code>innerFunc</code>를 호출한 결과를, (3)은 <code>obj2.innerMethod</code>를 호출한 결과입니다.</p>\n<ol>\n<li>객체를 생성하는데 내부에 outer 프로퍼티가 있습니다. outer 프로퍼티에 익명함수가 연결되고 생성된 객체를 변수 <code>obj1</code>에 할당합니다.</li>\n</ol>\n<ol start=\"2\">\n<li><code>obj1.outer()</code>를 호출합니다.</li>\n</ol>\n<ol start=\"3\">\n<li><code>obj1.outer</code> 함수의 실행 컨텍스트가 생성되면서 호이스팅하고, 스코프 체인 정보를 수집하고, this를 바인딩합니다.<br>이 함수는 호출될 때 함수명 <code>outer</code> 앞에 점(.)이 있었으므로 메서드로서 호출된 것입니다.<br>따라서 <code>this</code>는 점(.)앞에 객체인 <code>obj1</code>을 바인딩합니다.</li>\n</ol>\n<ol start=\"4\">\n<li><code>this</code>가 바인딩된 <code>obj1</code> 객체 정보가 출력됩니다.</li>\n</ol>\n<ol start=\"5\">\n<li>호이스팅된 변수 <code>innerFunc</code>는 outer 스코프 내에서만 접근할 수 있는 지역변수 입니다. 이 변수에 익명 함수를 할당합니다.</li>\n</ol>\n<ol start=\"6\">\n<li><code>innerFunc()</code>를 호출합니다.</li>\n</ol>\n<ol start=\"7\">\n<li><code>innerFunc</code> 함수의 실행 컨텍스트가 생성되면서 호이스팅,스코프 체인 수집, this 바인딩 등을 수행합니다.<br>이 함수는 호출될 때 <del>함수명 앞에 점(.)이 없었습니다.</del> 함수로서 호출되었습니다.<br>따라서 this가 지정되지 않았고, 자동으로 스코프 체인상의 최상위 객체인 전역객체(window)가 바인딩 됩니다.</li>\n</ol>\n<ol start=\"8\">\n<li><code>this</code>가 바인딩된 <code>window</code> 객체 정보가 출력됩니다.</li>\n</ol>\n<ol start=\"9\">\n<li><code>obj2</code> 역시 outer 스코프 내부에서만 접근할 수 있는 지역변수 입니다.<br><code>obj2</code> 변수에는 <code>object</code>를 할당하는데, object 안에 <code>innerMethod</code>라는 프로퍼티가 존재하고, 프로퍼티 값으로 앞서 정의된 변수 <code>innerFunc</code>와 연결된 익명 함수가 지정됩니다.</li>\n</ol>\n<ol start=\"10\">\n<li><code>obj2.innerMethod()</code>를 호출합니다.</li>\n</ol>\n<ol start=\"11\">\n<li><code>obj2. innerMethod</code> 함수의 실행 컨텍스트가 생성됩니다. 이 함수는 호출할 때 함수명인 <code>innerMethod</code> 앞에 점(.)이 있었으므로 메서드로서 호출한 것입니다.<br>따라서 <code>this</code>에는 마지막 점 앞의 객체인 <code>obj2</code>가 바인딩 됩니다.</li>\n</ol>\n<ol start=\"12\">\n<li><code>obj2</code> 객체 정보가 출력됩니다.</li>\n</ol>\n<ul>\n<li>정리하자면<br><mark>this 바인딩에 관해서는 함수를 실행하는 당시의 주변 환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고 오직 해당 함수를 호출하는 구문 앞에 점(.) 또는 대괄호[] 표기가 있는지 없는지가 관건입니다.</mark></li>\n</ul>\n<hr>\n<h4 id=\"메서드의-내부-함수에서의-this를-우회하는-방법\"><a href=\"#메서드의-내부-함수에서의-this를-우회하는-방법\" class=\"headerlink\" title=\"메서드의 내부 함수에서의 this를 우회하는 방법\"></a>메서드의 내부 함수에서의 this를 우회하는 방법</h4><p>호출 주체가 없을 때 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변 환경의 <code>this</code>를 그대로 상속받아 사용하고 싶다면<br>간단하고 대표적인 방법으로 변수를 활용하는 방법이 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>내부함수에서의 this를 변수를 활용하여 우회하기</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  outer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// (1) &#123; outer: f &#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerFunc1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// (2) Window &#123; ... &#125;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    innerFunc1();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerFunc2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(self); <span class=\"comment\">// (3) &#123; outer: f &#125;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    innerFunc2();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.outer();</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><code>innerFunc1</code> 내부에서 <code>this</code>는 전역객체를 가리킵니다.</p>\n</li>\n<li><p>outer 스코프에서 <code>self</code>라는 변수에 <code>this</code>를 저장한 상태에서 호출한 <code>innerFunc2</code>의 경우 <code>self</code>에는 객체 obj가 출력됩니다.</p>\n</li>\n</ol>\n<p><del>그저 상위 스코프의 this를 저장해서 내부함수에서 활용하려는 수단이므로 변수명은 달라도 무관합니다.</del></p>\n<hr>\n<h4 id=\"this를-바인딩하지-않는-함수\"><a href=\"#this를-바인딩하지-않는-함수\" class=\"headerlink\" title=\"this를 바인딩하지 않는 함수\"></a>this를 바인딩하지 않는 함수</h4><p>ES6에서는 함수 내부에서 <code>this</code>가 전역객체를 바라보는 문제를 보안하고자,<br><code>this</code>를 바인딩하지 않는 <mark>화살표 함수(Arrow function)</mark>를 새로 도입했습니다. </p>\n<p>화살표 함수는 실행 컨텍스트를 생성할 때 <code>this</code> 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 <code>this</code>를 그대로 활용할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>화살표 함수</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  outer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// (1) &#123; outer: f &#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// (2) &#123; outer: f &#125;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    innerFunc();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.outer();</span><br></pre></td></tr></table></figure>\n\n<p>이 밖에도 <code>call</code>, <code>apply</code> 등의 메서드를 활용해 함수를 호출할 때 명시적으로 <code>this</code>를 지정하는 방법이 있습니다.</p>\n<hr>\n<h3 id=\"콜백-함수-호출-시-그-함수-내부에서의-this\"><a href=\"#콜백-함수-호출-시-그-함수-내부에서의-this\" class=\"headerlink\" title=\"콜백 함수 호출 시 그 함수 내부에서의 this\"></a>콜백 함수 호출 시 그 함수 내부에서의 this</h3><ul>\n<li><p><code>함수 A</code>의 제어권을 <code>다른 함수(또는 메서드) B</code>에게 넘겨주는 경우 <code>함수 A</code>를 <code>콜백 함수</code>라고 합니다.</p>\n</li>\n<li><p>이때 <code>함수 A</code>는 <code>함수 B</code>의 내부 로직에 따라 실행되며, <code>this</code> 역시 <code>함수 B</code> 내부 로직에서 정한 규칙에 따라 값이 결정됩니다.</p>\n</li>\n<li><p><code>콜백 함수</code> 역시 함수이므로 기본적으로 <code>this</code>가 전역객체를 참조하지만, 제어권을 받은 함수 (함수 B)에서 <code>콜백 함수</code>에 별도로 <code>this</code>가 될 대상을 지정한 경우에는 그 대상을 참조하게 됩니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>콜백 함수 내부에서의 this</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">300</span>); <span class=\"comment\">// (1) window</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// (2) window</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, x);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.innerHTML += <span class=\"string\">'&lt;button id=\"a\"&gt;클릭&lt;/button&gt;'</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.querySelector(<span class=\"string\">'#a'</span>).addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// (3) &lt;button id=\"a\"&gt;클릭&lt;/button&gt;</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>0.3초 뒤 전역객체가 출력됩니다.</p>\n</li>\n<li><p>배열의 각 요소를 차례대로 콜백 함수의 첫 번째 인자로 삼아 전역객체와 배열의 각 요소가 총 5회 출력됩니다.</p>\n</li>\n<li><p>지정한 <code>HTML</code> 엘리먼트에 <code>&#39;click&#39;</code> 이벤트가 발생할 때 마다 그 이벤트 정보를 콜백 함수의 첫 번째 인자로 삼아 함수를 실행합니다. 버튼을 클릭하면 앞서 지정한 엘리먼트와 클릭 이벤트에 관한 정보가 담긴 객체가 출력됩니다.</p>\n</li>\n</ol>\n<p>이 처럼 콜백 함수에서의 <code>this</code>는 한가지로 정의할 수 없습니다.<br><mark>콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 정할지 결정하며</mark>,<br>따로 정의하지 않은 경우 기본적으로 전역객체를 참조합니다.</p>\n<hr>\n<h3 id=\"Class-함수-내부에서의-this\"><a href=\"#Class-함수-내부에서의-this\" class=\"headerlink\" title=\"Class 함수 내부에서의 this\"></a>Class 함수 내부에서의 this</h3><p>객체지향 언어에서 생성자를 클래스(<code>class</code>),<br>클래스를 통해 만든 객체를 인스턴스 (<code>instance</code>)라고 합니다.</p>\n<p>프로그래밍적으로 <code>class</code>는 구체적인 <code>instance</code>를 만들기 위한 일종의 틀입니다.<br>틀 안에는 해당 <code>class</code>의 공통 속성들이 준비되어 있고, 추가로 개별 <code>instance</code>를 만들 수 있습니다.</p>\n<p><code>new</code> 키워드와 함께 함수를 호출하면 해당 함수가 <code>class</code>로서 동작합니다.<br><code>class</code>로서 함수가 호출된 경우 내부에서의 <code>this</code>는 <code>instance</code>가 됩니다.</p>\n<ul>\n<li><code>class</code> 함수를 <code>new</code>키워드로 호출 하면 엔진은 <code>class</code>의 <code>prototype</code> 프로퍼티를 참조하는 <code>__proto__</code> 프로퍼티 <code>instance</code>를 만들고 공통 속성 및 특성 들을 해당 객체(<code>this</code>)에 부여합니다.<br><code>instance</code>가 생성됩니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>class 함수</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Cat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.bark = <span class=\"string\">'야옹'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> choco = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'초코'</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> nabi = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'나비'</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(choco, nabi);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 결과</span></span><br><span class=\"line\"><span class=\"comment\">Cat &#123; bark: '야옹', name: '초코', age: 7 &#125;</span></span><br><span class=\"line\"><span class=\"comment\">Cat &#123; bark: '야옹', name: '나비', age: 5 &#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><code>new</code> 키워드와 함께 Cat 함수를 호출하여 변수 choco, nabi에 각각 할당 했습니다.</p>\n</li>\n<li><p><code>console.log</code> 출력 결과 <code>this</code>가 각각 Cat <code>class</code>의 <code>instance</code>를 참조하여 반환합니다.<br>(<code>choco instance</code>, <code>nabi instance</code>)</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"this_binding\">명시적으로 this를 바인딩하는 방법</h2>\n\n<p>상황에 따라 this에 바인딩 되는 값들을 살펴봤지만 이런 규칙을 무시?하고 this에 대상을 지정하여 바인딩하는 방법도 있습니다.</p>\n<hr>\n<h3 id=\"call-메서드\"><a href=\"#call-메서드\" class=\"headerlink\" title=\"call 메서드\"></a>call 메서드</h3><blockquote>\n<p>Function.prototype.call(thisArg[, arg1[, arg2[, …]]])</p>\n</blockquote>\n<p><code>call</code> 메서드는 호출 주체인 함수를 즉시 실행하도록 합니다.<br><code>call</code> 메서드의 첫 번째 인자를 <code>this</code>로 바인딩 하고, 이후에 인자들을 호출할 함수의 매개변수로 사용합니다.</p>\n<p><code>call</code>메서드를 이용하여 <code>this</code> 값으로 참조할 객체를 지정할 수 있습니다. </p>\n<figure class=\"highlight js\"><figcaption><span>call 메서드</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, a, b, c);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">func(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// Window&#123; ... &#125; 1 2 3</span></span><br><span class=\"line\">func.call(&#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span> &#125;, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>); <span class=\"comment\">// &#123; x: 1 &#125; 4 5 6</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>func.call</code>에서 메서드의 첫 번째 인자 <code>{x : 1}</code>를 <code>this</code>가 참조할 값으로 던져줍니다.</p>\n</li>\n<li><p>객체의 메서드를 호출하면 <code>this</code>는 객체를 참조하게 되지만, <code>call</code> 메서드는 이렇듯 임의의 객체를 <code>this</code>로 지정할 수 있습니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"apply-메서드\"><a href=\"#apply-메서드\" class=\"headerlink\" title=\"apply 메서드\"></a>apply 메서드</h3><blockquote>\n<p>Function.prototype.apply(thisArg[, argsArray])</p>\n</blockquote>\n<p><code>apply</code> 메서드는 기능적으로 <code>call</code> 메서드와 완전히 동일합니다.</p>\n<p><code>apply</code>메서드는 <mark>두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 점에서 차이가 있습니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>apply 메서드</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, a, b, c);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func.apply(&#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span> &#125;, [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]); <span class=\"comment\">// &#123; x: 1 &#125; 4 5 6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a, x, y);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.method.apply(&#123; <span class=\"attr\">a</span>: <span class=\"number\">4</span> &#125;, [<span class=\"number\">5</span>, <span class=\"number\">6</span>]); <span class=\"comment\">// 4 5 6</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"call-apply-메서드의-활용\"><a href=\"#call-apply-메서드의-활용\" class=\"headerlink\" title=\"call / apply 메서드의 활용\"></a>call / apply 메서드의 활용</h3><p><code>call</code> 과 <code>apply</code> 메서드의 활용 사례</p>\n<hr>\n<h4 id=\"유사-배열객체에-배열-메서드-적용\"><a href=\"#유사-배열객체에-배열-메서드-적용\" class=\"headerlink\" title=\"유사 배열객체에 배열 메서드 적용\"></a>유사 배열객체에 배열 메서드 적용</h4><figure class=\"highlight js\"><figcaption><span>유사 배열객체에서 배열 메서드 사용하기</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">  length: <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.call(obj, <span class=\"string\">'d'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123; 0: 'a', 1: 'b', 2: 'c', 3: 'd', length: 4 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>.prototype.slice.call(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [ 'a', 'b', 'c', 'd' ]</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>유사배열객체인 경우 <code>call</code> 또는 <code>apply</code> 메서드를 이용해 배열 메서드를 사용할 수 있습니다.</p>\n</li>\n<li><p>배열 메서드인 <code>push</code>를 <code>객체 obj</code>에 적용해 프로퍼티 3에 ‘d’를 추가했습니다.</p>\n</li>\n<li><p>배열 메서드인 <code>slice</code>로 얕은 복사하여 객체를 배열로 반환했습니다.</p>\n</li>\n</ul>\n<p>이 밖에도 유사배열객체에는 <code>call</code>, <code>apply</code> 메서드를 이용해 모든 배열 메서드를 적용할 수 있습니다.<br>단, 문자열의 경우 <code>length</code> 프로퍼티가 읽기 전용이기 때문에 원본 문자열에 변경을 가하는 메서드(<code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>splice</code> 등)는 에러를 던지며, <code>concat</code> 처럼 대상이 반드시 배열이어야 하는 경우에는 에러는 나지 않지만 재대로 된 결과를 얻을 수 없습니다.</p>\n<ul>\n<li>사실 <code>call</code>, <code>apply</code>를 이용해 형변환하는 것은 ‘<code>this</code>를 원하는 값으로 지정해서 호출한다’라는 본래의 메서드의 의도와는 어긋나는 활용법이라고 할 수 있습니다.<br>또한 코드만 봐서는 어떤 의도인지 파악하기 쉽지 않습니다.</li>\n</ul>\n<ul>\n<li><mark>ES6 에서는 유사배열객체 또는 이터러블한 모든 종류의 데이터 타입을 배열로 전환</mark>하는 <code>Array.from</code>메서드가 추가되었습니다.</li>\n</ul>\n<hr>\n<h4 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from\"></a>Array.from</h4><p>Array 오브젝트를 생성하고 콜백 함수에서 반환된 값을 엘리먼트 값으로 설정하여 새로운 Array 객체를 반환합니다.</p>\n<blockquote>\n<p>Array.from(arrayLike[, mapFn[, thisArg]])</p>\n</blockquote>\n<ul>\n<li><p>arrayLike<br>배열로 변환하고자 하는 유사 배열 객체(Array-like)나 반복 가능한 객체(이터러블 오브젝트).</p>\n</li>\n<li><p>mapFn (선택적 파라미터)<br>배열의 모든 엘리먼트 마다 호출할 함수.</p>\n</li>\n<li><p>thisArg (선택적 파라미터)<br>두 번째 파라미터 함수 실행 시에 this로 참조할 값.</p>\n</li>\n<li><p>반환 값<br>새로운 Array 인스턴스.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>ES6의 Array.from</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">  length: <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>.from(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"class-내부에서-다른-class를-호출\"><a href=\"#class-내부에서-다른-class를-호출\" class=\"headerlink\" title=\"class 내부에서 다른 class를 호출\"></a>class 내부에서 다른 class를 호출</h4><p><code>class</code> 내부에 다른 <code>class</code>와 공통된 내용이 있을 경우 <code>call</code> 또는 <code>apply</code>를 이용해 다른 <code>class</code>를 호출하면 간단하게 반복을 줄일 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>class 내부에서 다른 class 호출</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, gender</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.gender = gender;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span>(<span class=\"params\">name, gender, school</span>) </span>&#123;</span><br><span class=\"line\">  Person.call(<span class=\"keyword\">this</span>, name, gender);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.school = school;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Employee</span>(<span class=\"params\">name, gender, company</span>) </span>&#123;</span><br><span class=\"line\">  Person.apply(<span class=\"keyword\">this</span>, [name, gender]);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.company = company;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> by = <span class=\"keyword\">new</span> Student(<span class=\"string\">'보영'</span>, <span class=\"string\">'female'</span>, <span class=\"string\">'단국대'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> jn = <span class=\"keyword\">new</span> Employee(<span class=\"string\">'재난'</span>, <span class=\"string\">'male'</span>, <span class=\"string\">'구골'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Student, Employee class함수 내부에서 Person 함수를 호출해서 instance 속성을 정의하게 했습니다.</p>\n<hr>\n<h4 id=\"여러-인수를-묶어-하나의-배열로-전달하고-싶을-때\"><a href=\"#여러-인수를-묶어-하나의-배열로-전달하고-싶을-때\" class=\"headerlink\" title=\"여러 인수를 묶어 하나의 배열로 전달하고 싶을 때\"></a>여러 인수를 묶어 하나의 배열로 전달하고 싶을 때</h4><p><code>apply</code>메서드를 사용해 하나의 배열로 인수들을 전달할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>여러 인수를 받는 메서드(Math.max/Math.min)에 apply 적용</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">3</span>, <span class=\"number\">16</span>, <span class=\"number\">45</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> max = <span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, numbers);</span><br><span class=\"line\"><span class=\"keyword\">var</span> min = <span class=\"built_in\">Math</span>.min.apply(<span class=\"literal\">null</span>, numbers);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(max, min); <span class=\"comment\">// 45 3</span></span><br></pre></td></tr></table></figure>\n\n<p>ES6에서는 <code>spread</code> 연산자를 이용하면 <code>apply</code>를 적용하는 것보다 더욱 간편하게 작성할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">3</span>, <span class=\"number\">16</span>, <span class=\"number\">45</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> max = <span class=\"built_in\">Math</span>.max(...numbers);</span><br><span class=\"line\"><span class=\"keyword\">const</span> min = <span class=\"built_in\">Math</span>.min(...numbers);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(max, min); <span class=\"comment\">// 45 3</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"bind-메서드\"><a href=\"#bind-메서드\" class=\"headerlink\" title=\"bind 메서드\"></a>bind 메서드</h3><blockquote>\n<p>Function.prototype.bind(thisArg[,arg1[, arg2[, …]]])</p>\n</blockquote>\n<p><code>bind</code> 메서드는 ES5에서 추가된 기능으로, call과 비슷하지만 즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드입니다.<br>다시 새로운 함수를 호출할 때 인수를 넘기면 그 인수들은 기존 <code>bind</code> 메서드를 호출할 때 전달했던 인수들의 뒤에 이어서 등록됩니다.<br>즉 <code>bind</code>메서드는 함수에 this를 미리 적용하는 것과 부분 적용 함수를 구현하는 두 가지 목적을 모두 지닙니다.</p>\n<figure class=\"highlight js\"><figcaption><span>bind메서드의 this 지정과 부분 적용 함수 구현</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c, d</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, a, b, c, d);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>); <span class=\"comment\">// Window&#123; ... &#125; 1 2 3 4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> bindFunc1 = func.bind(&#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span> &#125;);</span><br><span class=\"line\">bindFunc1(<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>); <span class=\"comment\">// &#123; x: 1 &#125; 5 6 7 8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">var</span> bindFunc2 = func.bind(&#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span> &#125;, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">bindFunc2(<span class=\"number\">6</span>, <span class=\"number\">7</span>); <span class=\"comment\">// &#123; x: 1 &#125; 4 5 6 7</span></span><br><span class=\"line\">bindFunc2(<span class=\"number\">8</span>, <span class=\"number\">9</span>); <span class=\"comment\">// &#123; x: 1 &#125; 4 5 8 9</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><code>bindFunc1</code> 변수에 <code>func</code> 변수에 <code>this</code>를 <code>{x : 1}</code>로 지정하는 새로운 함수가 할당됩니다.<br>다음 줄에서 <code>bindFunc1</code>을 호출하면 지정된 <code>this</code>값과 함께 반환됩니다.</p>\n</li>\n<li><p><code>bindFunc2</code> 변수에는 <code>func</code> 변수에 <code>this</code>를 <code>{x : 1}</code>로 지정하고, 파라미터를 차례대로 4, 5로 지정한 함수 새로운 함수가 할당됩니다. 다음 코드를 호출하면 <code>this</code>로 지정해준 값과 파라미터에 지정해준 값이 적용되고 그 다음 함수를 호출하며 넘겨준 파라미터 값이 붙습니다 <code>{x : 1} 4 5 6 7</code>, <code>{x : 1} 4 5 8 9</code> 형태로 반환됩니다.<br><mark>이것이 bind의 부분 적용 함수 구현법입니다.</mark></p>\n</li>\n</ol>\n<hr>\n<h4 id=\"name-프로퍼티\"><a href=\"#name-프로퍼티\" class=\"headerlink\" title=\"name 프로퍼티\"></a>name 프로퍼티</h4><p><u>bind 메서드를 적용해서 새로 만든 함수는 한 가지 독특한 성질이 있습니다.</u><br>name 프로퍼티에 동사 bind의 수동태인 <code>bound</code>라는 접두어가 붙습니다.</p>\n<p>함수의 name 프로퍼티가 <code>bound xxx</code>이라면 함수명이 xxx인 원본 함수에 <code>bind</code>메서드를 적용한 새로운 함수라는 의미가 되므로 call 과 apply 메서드에 비해 코드 추적이 용이한 점이 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c, d</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, a, b, c, d);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bindFunc = func.bind(&#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span> &#125;, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(func.name); <span class=\"comment\">// func</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bindFunc.name); <span class=\"comment\">// bound func</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"상위-컨텍스트의-this를-내부함수나-콜백-함수에-전달하기\"><a href=\"#상위-컨텍스트의-this를-내부함수나-콜백-함수에-전달하기\" class=\"headerlink\" title=\"상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기\"></a>상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기</h4><p>메서드의 내부함수에서 메서드의 <code>this</code>를 그대로 바라보게 하기 위한 방법으로<br>self 등의 변수를 활용하거나 화살표 함수를 이용한 우회법이 있었는데<br><code>call</code>, <code>apply</code>, <code>bind</code> 메서드를 이용하면 더 깔끔하게 처리할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>내부함수에 this 전달 - call</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  outer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">//&#123;outer : f&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">//&#123;outer : f&#125;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    innerFunc.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.outer();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>내부함수에 this 전달 -bind</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  outer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">//&#123;outer : f&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">//&#123;outer : f&#125;</span></span><br><span class=\"line\">    &#125;.bind(<span class=\"keyword\">this</span>); <span class=\"comment\">// 호출x, 새로운 함수 바인드</span></span><br><span class=\"line\">    innerFunc(); <span class=\"comment\">// 호출</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.outer();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>또한 콜백 함수를 인자로 받는 함수(메서드) 중에서 기본적으로 콜백 함수 내에서의 <code>this</code>에 관여하는 함수(메서드)에 대해서도 <code>bind</code> 메서드를 사용하면 <code>this</code>값을 지정하여 바꿀 수 있습니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>bind 메서드 - 내부 함수에 this 전달</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  logThis: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  logThisLater1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"keyword\">this</span>.logThis, <span class=\"number\">500</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  logThisLater2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"keyword\">this</span>.logThis.bind(<span class=\"keyword\">this</span>), <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.logThisLater1(); <span class=\"comment\">// Window &#123; ... &#125;</span></span><br><span class=\"line\">obj.logThisLater2(); <span class=\"comment\">// obj &#123; logThis: f, ... &#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"화살표-함수의-예외사항\"><a href=\"#화살표-함수의-예외사항\" class=\"headerlink\" title=\"화살표 함수의 예외사항\"></a>화살표 함수의 예외사항</h3><p>ES6에 새롭게 도입된 화살표 함수 <code>=&gt;</code>는 실행 컨텍스트 생성 시 this를 바인딩 하지 않습니다.<br>즉 화살표 함수 <code>=&gt;</code> 내부에는 <code>this</code>가 아예 없으며, <code>this</code>에 접근하고자 하면 스코프체인상 가장 가까운 <code>this</code>에 접근하게 됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>화삺표 함수 내부에서의 this</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  outer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    innerFunc();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.outer();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>call</code>, <code>apply</code>, <code>bind</code>를 사용했던 예제의 내부함수를 <code>=&gt;</code>함수로 바꾼 것입니다.<br>더욱 간결해졌습니다.</li>\n</ul>\n<hr>\n<h3 id=\"별도의-인자로-this를-받는-경우-콜백-함수-내에서의-this\"><a href=\"#별도의-인자로-this를-받는-경우-콜백-함수-내에서의-this\" class=\"headerlink\" title=\"별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\"></a>별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)</h3><p>콜백 함수를 인자로 받는 메서드에는 <code>this</code>로 지정할 객체(<code>thisArg</code>)를 인자로 지정할 수 있는 것들이 있습니다. 이러한 메서드를 이용하여 <code>this</code>값을 원하는대로 변경할 수 있습니다.</p>\n<p>이러한 메서드는 내부 요소에 대해 같은 동작을 반복 수행해야하는 배열 메서드에 많이 존재하고, 같은 이유로 ES6에 추가된 <code>Set</code>, <code>Map</code>등의 메서드에도 일부 존재합니다.</p>\n<ul>\n<li><p>콜백 함수와 함께 thisArg를 인자로 받는 메서드</p>\n<table>\n<thead>\n<tr>\n<th>Array.prototype</th>\n<th>Set.prototype</th>\n<th>Map.prototype</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>forEach</code>(callback[, thisArg])</td>\n<td><code>forEach</code>(callback[, thisArg])</td>\n<td><code>forEach</code>(callback[, thisArg])</td>\n</tr>\n<tr>\n<td><code>map</code>(callback[, thisArg])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>filter</code>(callback[, thisArg])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>some</code>(callback[, thisArg])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>every</code>(callback[, thisArg])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>find</code>(callback[, thisArg])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>findIndex</code>(callback[, thisArg])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>flatMap</code>(callback[, thisArg])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>from</code>(arrayLike[, callback[, thisArg]])</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>대표적인 배열 메서드인 <code>forEach</code> 예시</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>forEach</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> report = &#123;</span><br><span class=\"line\">  sum: <span class=\"number\">0</span>,</span><br><span class=\"line\">  count: <span class=\"number\">0</span>,</span><br><span class=\"line\">  add: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    args.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">entry</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.sum += entry;</span><br><span class=\"line\">      ++<span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">    &#125;, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  average: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.sum / <span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">report.add(<span class=\"number\">60</span>, <span class=\"number\">85</span>, <span class=\"number\">95</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(report.sum, report.count, report.average()); <span class=\"comment\">// 240 3 80</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>60, 85, 95</code>를 인자로 삼아 <code>add</code> 메서드를 호출하면 <code>slice.call</code>메서드가 인자를 받아 새로운 배열로 반환합니다. 이후 <code>forEach</code> 메서드가 실행됩니다.</p>\n</li>\n<li><p>콜백 함수 내부의 <code>this</code>는 <code>forEach</code> 함수의 두 번째 인자로 전달해준 <code>this</code>(add 메서드의 this)가 전달된 상태이므로 <code>add</code> 메서드의 <code>this(report)</code>를 가리킵니다.</p>\n</li>\n<li><p>따라서 배열의 요소들을 순회 반복하며 <code>report.sum</code> , <code>report.count</code>값이 차례로 바뀌게 됩니다.<br>출력 결과로 <code>report.sum</code>에 240, <code>report.count</code>에 3이 반환되어 출력됩니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"this_point\">this 정리</h2>\n\n<p>명시적 <code>this</code> 바인딩이 없는 한 항상 성립하는 규칙</p>\n<ul>\n<li><p>전역공간에서의 <code>this</code>는 전역객체를 참조 (브라우저에서는 <code>window</code>, Node.js에서는 <code>global</code>)</p>\n</li>\n<li><p>함수를 메서드로 호출한 경우 <code>this</code>는 메서드 호출 주체를 참조 (메서드명 앞의 객체)</p>\n</li>\n<li><p>함수를 함수로 호출한 경우 <code>this</code>는 전역객체를 참조 (메서드의 내부함수에서도 동일)</p>\n</li>\n<li><p>콜백 함수 내부에서의 <code>this</code>는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바를 참조<br><code>this</code>가 정의되어 있지않다면 전역객체를 참조</p>\n</li>\n<li><p><code>class</code> 함수에서 <code>this</code>는 생성될 <code>instance</code>를 참조</p>\n</li>\n</ul>\n<p>위 규칙에 부합하지 않는 경우 명시적 <code>this</code> 바인딩 규칙으로 예측할 수 있습니다.</p>\n<ul>\n<li><p><code>call</code>, <code>apply</code> 메서드는 <code>this</code>를 명시적으로 지정하면서 함수 또는 메서드를 호출</p>\n</li>\n<li><p><code>bind</code> 메서드는 <code>this</code> 및 함수에 넘길 파라미터를 일부 지정해 새로운 함수를 만듭니다.</p>\n</li>\n<li><p>콜백 함수를 반복 순회,호출 하는 일부 메서드는 별도의 인자로 <code>this</code>를 받기도 합니다.</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>자바스크립트에서의 this는 어디서든 사용할 수 있습니다.<br>this는 상황에 따라 참조하는 대상이 달라질 수 있습니다.<br>함수와 객체(메서드) 구분이 느슨한 자바스크립트에서 이 둘을 구분하는 유일한 기능입니다.</p>\n<ul>\n<li>this<ul>\n<li><a href=\"/2020/04/27/this-Core-JavaScript/#this\">상황에 따라 달라지는 this</a><ul>\n<li>전역 공간에서의 this</li>\n<li>메서드로서 호출할 때 메서드 내부의 this<ul>\n<li>함수 vs 메서드</li>\n<li>메서드 내부에서의 this</li>\n</ul>\n</li>\n<li>함수로서 호출할 때 그 함수 내부에서의 this<ul>\n<li>함수 내부에서의 this</li>\n<li>메서드의 내부함수에서의 this</li>\n<li>메서드 내부 함수에서의 this를 우회하는 방법</li>\n<li>this를 바인딩하지 않는 함수</li>\n</ul>\n</li>\n<li>콜백 함수 호출시 그 함수 내부에서의 this</li>\n<li>Class 함수 내부에서의 this </li>\n</ul>\n</li>\n<li><a href=\"/2020/04/27/this-Core-JavaScript/#this_binding\">명시적으로 this를 바인딩하는 방법</a><ul>\n<li>call 메서드</li>\n<li>apply 메서드</li>\n<li>call / apply 메서드의 활용<ul>\n<li>생성자 내부에서 다른 생성자를 호출</li>\n<li>여러 인수를 묶어 하나의 배열로 전달</li>\n</ul>\n</li>\n<li>bind 메서드<ul>\n<li>name 프로퍼티</li>\n<li>상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기</li>\n</ul>\n</li>\n<li>화살표 =&gt; 함수의 예외사항</li>\n<li>별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/27/this-Core-JavaScript/#this_point\">this 정리</a> </li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"this\">상황에 따라 달라지는 this</h2>\n\n<ul>\n<li><code>this</code>는 기본적으로 <mark>실행 컨텍스트가 생성될 때 함께 결정됩니다.</mark><br>실행 컨텍스트는 함수를 호출할 때 생성되므로, <code>this</code><mark>는 함수를 호출할 때 결정된다고 할 수 있습니다.</mark></li>\n</ul>\n<hr>\n<h3 id=\"전역-공간에서의-this\"><a href=\"#전역-공간에서의-this\" class=\"headerlink\" title=\"전역 공간에서의 this\"></a>전역 공간에서의 this</h3><p>전역 공간에서 <code>this</code>는 전역 객체를 가리킵니다. 브라우저 환경에서 전역객체는 <code>window</code>이고 Node.js 환경에서는 <code>global</code>입니다.</p>\n<ul>\n<li><p>참고 : 전역 변수<br>전역 변수를 선언하면 자바스크립트 엔진은 전역객체의 프로퍼티로 할당시킴.</p>\n<figure class=\"highlight js\"><figcaption><span>전역객체 window의 프로퍼티</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.a); <span class=\"comment\">// 1 (전역객체의 프로퍼티)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a); <span class=\"comment\">// 1 (this는 현재 전역객체 참조)</span></span><br></pre></td></tr></table></figure>\n<p><mark>사실 자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로 동작합니다.</mark><br>이 특정 객체란 실행 컨텍스트의 <code>LexicalEnvironment</code>를 말합니다.<br>실행 컨텍스트는 변수를 수집하여 <code>LexicalEnvironment</code>의 프로퍼티로 지정합니다.<br>이후 변수를 호출하면 <code>LexicalEnvironment</code>를 조회하여 일치하는 프로퍼티가 있을 경우 그 값을 반환합니다.</p>\n<p>전역 컨텍스트의 <code>LexicalEnvironment</code>는 전역객체를 참조하므로 var a 선언/할당 이후 <code>window.a</code> 와 <code>this.a</code>가 1이 나오는 이유는 당연합니다.<br><mark>a를 직접 호출했을 때도 1이 나오는 이유는 무엇일까요?</mark><br>변수 a에 접근하려고 하면 스코프 체인에서 a를 검색하다가 가장 마지막에 도달하는 전역 스코프의 <code>LexicalEnvironment</code>에서 해당 프로퍼티 a를 조회하여 그 값을 반환하기 때문입니다.</p>\n</li>\n</ul>\n<ul>\n<li><p>전역 공간에서 var로 변수를 선언하는 대신 window의 프로퍼티에 직접 할당하더라도 결과적으로 똑같이 동작합니다. 하지만 <code>delete</code> 연산자를 사용하는 경우 다른 결과를 반환합니다.</p>\n<ul>\n<li><code>var</code> 변수로 선언한 경우 : delete window 형식으로 삭제 불가,<br>delete 변수명 형식으로도 삭제 불가</li>\n<li><code>window</code> 프로퍼티에 직접 할당한 경우: delete window 형식으로 삭제 가능,<br>delete 변수명 형식으로도 삭제 가능</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"메서드로서-호출할-때-그-메서드-내부에서의-this\"><a href=\"#메서드로서-호출할-때-그-메서드-내부에서의-this\" class=\"headerlink\" title=\"메서드로서 호출할 때 그 메서드 내부에서의 this\"></a>메서드로서 호출할 때 그 메서드 내부에서의 this</h3><h4 id=\"함수-vs-메서드\"><a href=\"#함수-vs-메서드\" class=\"headerlink\" title=\"함수 vs 메서드\"></a>함수 vs 메서드</h4><p>함수를 실행하는 방법 중에는 함수로 호출하는 경우와 메서드로서 호출하는 경우가 있습니다.<br>함수와 메서드를 구분하는 유일한 차이는 <u>독립성</u>에 있습니다.</p>\n<ul>\n<li><p>함수는 그 자체로 독립적인 기능을 수행합니다.</p>\n</li>\n<li><p>메서드는 자신을 호출한 대상 객체에 관한 동작을 수행합니다.</p>\n</li>\n</ul>\n<p><mark>어떤 함수를 객체의 프로퍼티에 할당한다고 해서 무조건 메서드가 되는 것이 아니라<br>객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작합니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>메서드로 호출 (점 표기법, 대괄호 표기법)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, x);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.method(<span class=\"number\">1</span>); <span class=\"comment\">// &#123; method: f &#125; 1</span></span><br><span class=\"line\">obj[<span class=\"string\">'method'</span>](<span class=\"number\">2</span>); <span class=\"comment\">// &#123; method: f &#125; 2</span></span><br></pre></td></tr></table></figure>\n\n<p>다시 말해 점 표기법이든 대괄호 표기법이든, 어떤 함수를 호출할 때 그 함수 이름 앞에<br>객체가 명시돼 있는 경우 메서드로 호출한 것이고, 그렇지 않은 경우에는 함수로 호출한 것입니다.</p>\n<h4 id=\"메서드-내부에서의-this\"><a href=\"#메서드-내부에서의-this\" class=\"headerlink\" title=\"메서드 내부에서의 this\"></a>메서드 내부에서의 this</h4><p><code>this</code>에는 호출한 주체에 대한 정보가 담깁니다. 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티 명)앞의 객체입니다. 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 <code>this</code>가 됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>메서드 내부에서의 this</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  methodA: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  inner: &#123;</span><br><span class=\"line\">    methodB: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.methodA(); <span class=\"comment\">// &#123; methodA: f, inner: &#123;...&#125; &#125;    ( === obj)</span></span><br><span class=\"line\">obj[<span class=\"string\">'methodA'</span>](); <span class=\"comment\">// &#123; methodA: f, inner: &#123;...&#125; &#125; ( === obj)</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.inner.methodB(); <span class=\"comment\">// &#123; methodB: f &#125;            ( === obj.inner)</span></span><br><span class=\"line\">obj.inner[<span class=\"string\">'methodB'</span>](); <span class=\"comment\">// &#123; methodB: f &#125;         ( === obj.inner)</span></span><br><span class=\"line\">obj[<span class=\"string\">'inner'</span>].methodB(); <span class=\"comment\">// &#123; methodB: f &#125;         ( === obj.inner)</span></span><br><span class=\"line\">obj[<span class=\"string\">'inner'</span>][<span class=\"string\">'methodB'</span>](); <span class=\"comment\">// &#123; methodB: f &#125;      ( === obj.inner)</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"함수로서-호출할-때-그-함수-내부에서의-this\"><a href=\"#함수로서-호출할-때-그-함수-내부에서의-this\" class=\"headerlink\" title=\"함수로서 호출할 때 그 함수 내부에서의 this\"></a>함수로서 호출할 때 그 함수 내부에서의 this</h3><hr>\n<h4 id=\"함수-내부에서의-this\"><a href=\"#함수-내부에서의-this\" class=\"headerlink\" title=\"함수 내부에서의 this\"></a>함수 내부에서의 this</h4><p>어떤 함수를 함수로서 호출할 경우 <code>this</code>가 지정되지 않습니다.(this는 호출한 주체에 대한 정보가 담깁니다.)<br>함수로서 호출하는 것은 호출 주체(객체지향 언어에서의 객체)를 명시하지 않고 실행한 것이기 때문에 호출 주체의 정보를 알 수 없는 것입니다.<br><mark>this가 지정되지 않은 경우 this는 전역 객체를 참조합니다.</mark><br>따라서 함수에서의 <code>this</code>는 전역 객체를 가리킵니다.</p>\n<hr>\n<h4 id=\"메서드의-내부함수에서의-this\"><a href=\"#메서드의-내부함수에서의-this\" class=\"headerlink\" title=\"메서드의 내부함수에서의 this\"></a>메서드의 내부함수에서의 this</h4><p>메서드 내부에서 정의하고 실행한 함수에서의 this는 자바스크립트 초심자들이 this에 관해 가장 자주 혼란을 느끼는 점입니다.</p>\n<p><mark>내부함수 역시 이를 함수로 호출했는지 메서드로 호출했는지만 파악하면 this의 값을 정확히 맞출 수 있습니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>내부함수에서의 this</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  <span class=\"number\">3.</span> outer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// (1)</span></span><br><span class=\"line\">    <span class=\"number\">5.</span> <span class=\"number\">7.</span> <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"number\">8.</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// (2) (3)</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"number\">6.</span> innerFunc();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">9.</span> <span class=\"number\">11.</span> <span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">      <span class=\"number\">12.</span> innerMethod: innerFunc,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"number\">10.</span> obj2.innerMethod();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"number\">2.</span> obj1.outer();</span><br><span class=\"line\"><span class=\"comment\">// (1): obj1</span></span><br><span class=\"line\"><span class=\"comment\">// (2): 전역객체(window)</span></span><br><span class=\"line\"><span class=\"comment\">// (3): obj2</span></span><br></pre></td></tr></table></figure>\n\n<p>(2)는 <code>innerFunc</code>를 호출한 결과를, (3)은 <code>obj2.innerMethod</code>를 호출한 결과입니다.</p>\n<ol>\n<li>객체를 생성하는데 내부에 outer 프로퍼티가 있습니다. outer 프로퍼티에 익명함수가 연결되고 생성된 객체를 변수 <code>obj1</code>에 할당합니다.</li>\n</ol>\n<ol start=\"2\">\n<li><code>obj1.outer()</code>를 호출합니다.</li>\n</ol>\n<ol start=\"3\">\n<li><code>obj1.outer</code> 함수의 실행 컨텍스트가 생성되면서 호이스팅하고, 스코프 체인 정보를 수집하고, this를 바인딩합니다.<br>이 함수는 호출될 때 함수명 <code>outer</code> 앞에 점(.)이 있었으므로 메서드로서 호출된 것입니다.<br>따라서 <code>this</code>는 점(.)앞에 객체인 <code>obj1</code>을 바인딩합니다.</li>\n</ol>\n<ol start=\"4\">\n<li><code>this</code>가 바인딩된 <code>obj1</code> 객체 정보가 출력됩니다.</li>\n</ol>\n<ol start=\"5\">\n<li>호이스팅된 변수 <code>innerFunc</code>는 outer 스코프 내에서만 접근할 수 있는 지역변수 입니다. 이 변수에 익명 함수를 할당합니다.</li>\n</ol>\n<ol start=\"6\">\n<li><code>innerFunc()</code>를 호출합니다.</li>\n</ol>\n<ol start=\"7\">\n<li><code>innerFunc</code> 함수의 실행 컨텍스트가 생성되면서 호이스팅,스코프 체인 수집, this 바인딩 등을 수행합니다.<br>이 함수는 호출될 때 <del>함수명 앞에 점(.)이 없었습니다.</del> 함수로서 호출되었습니다.<br>따라서 this가 지정되지 않았고, 자동으로 스코프 체인상의 최상위 객체인 전역객체(window)가 바인딩 됩니다.</li>\n</ol>\n<ol start=\"8\">\n<li><code>this</code>가 바인딩된 <code>window</code> 객체 정보가 출력됩니다.</li>\n</ol>\n<ol start=\"9\">\n<li><code>obj2</code> 역시 outer 스코프 내부에서만 접근할 수 있는 지역변수 입니다.<br><code>obj2</code> 변수에는 <code>object</code>를 할당하는데, object 안에 <code>innerMethod</code>라는 프로퍼티가 존재하고, 프로퍼티 값으로 앞서 정의된 변수 <code>innerFunc</code>와 연결된 익명 함수가 지정됩니다.</li>\n</ol>\n<ol start=\"10\">\n<li><code>obj2.innerMethod()</code>를 호출합니다.</li>\n</ol>\n<ol start=\"11\">\n<li><code>obj2. innerMethod</code> 함수의 실행 컨텍스트가 생성됩니다. 이 함수는 호출할 때 함수명인 <code>innerMethod</code> 앞에 점(.)이 있었으므로 메서드로서 호출한 것입니다.<br>따라서 <code>this</code>에는 마지막 점 앞의 객체인 <code>obj2</code>가 바인딩 됩니다.</li>\n</ol>\n<ol start=\"12\">\n<li><code>obj2</code> 객체 정보가 출력됩니다.</li>\n</ol>\n<ul>\n<li>정리하자면<br><mark>this 바인딩에 관해서는 함수를 실행하는 당시의 주변 환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고 오직 해당 함수를 호출하는 구문 앞에 점(.) 또는 대괄호[] 표기가 있는지 없는지가 관건입니다.</mark></li>\n</ul>\n<hr>\n<h4 id=\"메서드의-내부-함수에서의-this를-우회하는-방법\"><a href=\"#메서드의-내부-함수에서의-this를-우회하는-방법\" class=\"headerlink\" title=\"메서드의 내부 함수에서의 this를 우회하는 방법\"></a>메서드의 내부 함수에서의 this를 우회하는 방법</h4><p>호출 주체가 없을 때 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변 환경의 <code>this</code>를 그대로 상속받아 사용하고 싶다면<br>간단하고 대표적인 방법으로 변수를 활용하는 방법이 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>내부함수에서의 this를 변수를 활용하여 우회하기</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  outer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// (1) &#123; outer: f &#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerFunc1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// (2) Window &#123; ... &#125;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    innerFunc1();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerFunc2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(self); <span class=\"comment\">// (3) &#123; outer: f &#125;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    innerFunc2();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.outer();</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><code>innerFunc1</code> 내부에서 <code>this</code>는 전역객체를 가리킵니다.</p>\n</li>\n<li><p>outer 스코프에서 <code>self</code>라는 변수에 <code>this</code>를 저장한 상태에서 호출한 <code>innerFunc2</code>의 경우 <code>self</code>에는 객체 obj가 출력됩니다.</p>\n</li>\n</ol>\n<p><del>그저 상위 스코프의 this를 저장해서 내부함수에서 활용하려는 수단이므로 변수명은 달라도 무관합니다.</del></p>\n<hr>\n<h4 id=\"this를-바인딩하지-않는-함수\"><a href=\"#this를-바인딩하지-않는-함수\" class=\"headerlink\" title=\"this를 바인딩하지 않는 함수\"></a>this를 바인딩하지 않는 함수</h4><p>ES6에서는 함수 내부에서 <code>this</code>가 전역객체를 바라보는 문제를 보안하고자,<br><code>this</code>를 바인딩하지 않는 <mark>화살표 함수(Arrow function)</mark>를 새로 도입했습니다. </p>\n<p>화살표 함수는 실행 컨텍스트를 생성할 때 <code>this</code> 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 <code>this</code>를 그대로 활용할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>화살표 함수</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  outer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// (1) &#123; outer: f &#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// (2) &#123; outer: f &#125;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    innerFunc();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.outer();</span><br></pre></td></tr></table></figure>\n\n<p>이 밖에도 <code>call</code>, <code>apply</code> 등의 메서드를 활용해 함수를 호출할 때 명시적으로 <code>this</code>를 지정하는 방법이 있습니다.</p>\n<hr>\n<h3 id=\"콜백-함수-호출-시-그-함수-내부에서의-this\"><a href=\"#콜백-함수-호출-시-그-함수-내부에서의-this\" class=\"headerlink\" title=\"콜백 함수 호출 시 그 함수 내부에서의 this\"></a>콜백 함수 호출 시 그 함수 내부에서의 this</h3><ul>\n<li><p><code>함수 A</code>의 제어권을 <code>다른 함수(또는 메서드) B</code>에게 넘겨주는 경우 <code>함수 A</code>를 <code>콜백 함수</code>라고 합니다.</p>\n</li>\n<li><p>이때 <code>함수 A</code>는 <code>함수 B</code>의 내부 로직에 따라 실행되며, <code>this</code> 역시 <code>함수 B</code> 내부 로직에서 정한 규칙에 따라 값이 결정됩니다.</p>\n</li>\n<li><p><code>콜백 함수</code> 역시 함수이므로 기본적으로 <code>this</code>가 전역객체를 참조하지만, 제어권을 받은 함수 (함수 B)에서 <code>콜백 함수</code>에 별도로 <code>this</code>가 될 대상을 지정한 경우에는 그 대상을 참조하게 됩니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>콜백 함수 내부에서의 this</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">300</span>); <span class=\"comment\">// (1) window</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// (2) window</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, x);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.innerHTML += <span class=\"string\">'&lt;button id=\"a\"&gt;클릭&lt;/button&gt;'</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.querySelector(<span class=\"string\">'#a'</span>).addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// (3) &lt;button id=\"a\"&gt;클릭&lt;/button&gt;</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>0.3초 뒤 전역객체가 출력됩니다.</p>\n</li>\n<li><p>배열의 각 요소를 차례대로 콜백 함수의 첫 번째 인자로 삼아 전역객체와 배열의 각 요소가 총 5회 출력됩니다.</p>\n</li>\n<li><p>지정한 <code>HTML</code> 엘리먼트에 <code>&#39;click&#39;</code> 이벤트가 발생할 때 마다 그 이벤트 정보를 콜백 함수의 첫 번째 인자로 삼아 함수를 실행합니다. 버튼을 클릭하면 앞서 지정한 엘리먼트와 클릭 이벤트에 관한 정보가 담긴 객체가 출력됩니다.</p>\n</li>\n</ol>\n<p>이 처럼 콜백 함수에서의 <code>this</code>는 한가지로 정의할 수 없습니다.<br><mark>콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 정할지 결정하며</mark>,<br>따로 정의하지 않은 경우 기본적으로 전역객체를 참조합니다.</p>\n<hr>\n<h3 id=\"Class-함수-내부에서의-this\"><a href=\"#Class-함수-내부에서의-this\" class=\"headerlink\" title=\"Class 함수 내부에서의 this\"></a>Class 함수 내부에서의 this</h3><p>객체지향 언어에서 생성자를 클래스(<code>class</code>),<br>클래스를 통해 만든 객체를 인스턴스 (<code>instance</code>)라고 합니다.</p>\n<p>프로그래밍적으로 <code>class</code>는 구체적인 <code>instance</code>를 만들기 위한 일종의 틀입니다.<br>틀 안에는 해당 <code>class</code>의 공통 속성들이 준비되어 있고, 추가로 개별 <code>instance</code>를 만들 수 있습니다.</p>\n<p><code>new</code> 키워드와 함께 함수를 호출하면 해당 함수가 <code>class</code>로서 동작합니다.<br><code>class</code>로서 함수가 호출된 경우 내부에서의 <code>this</code>는 <code>instance</code>가 됩니다.</p>\n<ul>\n<li><code>class</code> 함수를 <code>new</code>키워드로 호출 하면 엔진은 <code>class</code>의 <code>prototype</code> 프로퍼티를 참조하는 <code>__proto__</code> 프로퍼티 <code>instance</code>를 만들고 공통 속성 및 특성 들을 해당 객체(<code>this</code>)에 부여합니다.<br><code>instance</code>가 생성됩니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>class 함수</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Cat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.bark = <span class=\"string\">'야옹'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> choco = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'초코'</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> nabi = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'나비'</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(choco, nabi);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 결과</span></span><br><span class=\"line\"><span class=\"comment\">Cat &#123; bark: '야옹', name: '초코', age: 7 &#125;</span></span><br><span class=\"line\"><span class=\"comment\">Cat &#123; bark: '야옹', name: '나비', age: 5 &#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><code>new</code> 키워드와 함께 Cat 함수를 호출하여 변수 choco, nabi에 각각 할당 했습니다.</p>\n</li>\n<li><p><code>console.log</code> 출력 결과 <code>this</code>가 각각 Cat <code>class</code>의 <code>instance</code>를 참조하여 반환합니다.<br>(<code>choco instance</code>, <code>nabi instance</code>)</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"this_binding\">명시적으로 this를 바인딩하는 방법</h2>\n\n<p>상황에 따라 this에 바인딩 되는 값들을 살펴봤지만 이런 규칙을 무시?하고 this에 대상을 지정하여 바인딩하는 방법도 있습니다.</p>\n<hr>\n<h3 id=\"call-메서드\"><a href=\"#call-메서드\" class=\"headerlink\" title=\"call 메서드\"></a>call 메서드</h3><blockquote>\n<p>Function.prototype.call(thisArg[, arg1[, arg2[, …]]])</p>\n</blockquote>\n<p><code>call</code> 메서드는 호출 주체인 함수를 즉시 실행하도록 합니다.<br><code>call</code> 메서드의 첫 번째 인자를 <code>this</code>로 바인딩 하고, 이후에 인자들을 호출할 함수의 매개변수로 사용합니다.</p>\n<p><code>call</code>메서드를 이용하여 <code>this</code> 값으로 참조할 객체를 지정할 수 있습니다. </p>\n<figure class=\"highlight js\"><figcaption><span>call 메서드</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, a, b, c);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">func(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// Window&#123; ... &#125; 1 2 3</span></span><br><span class=\"line\">func.call(&#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span> &#125;, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>); <span class=\"comment\">// &#123; x: 1 &#125; 4 5 6</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>func.call</code>에서 메서드의 첫 번째 인자 <code>{x : 1}</code>를 <code>this</code>가 참조할 값으로 던져줍니다.</p>\n</li>\n<li><p>객체의 메서드를 호출하면 <code>this</code>는 객체를 참조하게 되지만, <code>call</code> 메서드는 이렇듯 임의의 객체를 <code>this</code>로 지정할 수 있습니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"apply-메서드\"><a href=\"#apply-메서드\" class=\"headerlink\" title=\"apply 메서드\"></a>apply 메서드</h3><blockquote>\n<p>Function.prototype.apply(thisArg[, argsArray])</p>\n</blockquote>\n<p><code>apply</code> 메서드는 기능적으로 <code>call</code> 메서드와 완전히 동일합니다.</p>\n<p><code>apply</code>메서드는 <mark>두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 점에서 차이가 있습니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>apply 메서드</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, a, b, c);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func.apply(&#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span> &#125;, [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]); <span class=\"comment\">// &#123; x: 1 &#125; 4 5 6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a, x, y);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.method.apply(&#123; <span class=\"attr\">a</span>: <span class=\"number\">4</span> &#125;, [<span class=\"number\">5</span>, <span class=\"number\">6</span>]); <span class=\"comment\">// 4 5 6</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"call-apply-메서드의-활용\"><a href=\"#call-apply-메서드의-활용\" class=\"headerlink\" title=\"call / apply 메서드의 활용\"></a>call / apply 메서드의 활용</h3><p><code>call</code> 과 <code>apply</code> 메서드의 활용 사례</p>\n<hr>\n<h4 id=\"유사-배열객체에-배열-메서드-적용\"><a href=\"#유사-배열객체에-배열-메서드-적용\" class=\"headerlink\" title=\"유사 배열객체에 배열 메서드 적용\"></a>유사 배열객체에 배열 메서드 적용</h4><figure class=\"highlight js\"><figcaption><span>유사 배열객체에서 배열 메서드 사용하기</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">  length: <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.call(obj, <span class=\"string\">'d'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123; 0: 'a', 1: 'b', 2: 'c', 3: 'd', length: 4 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>.prototype.slice.call(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [ 'a', 'b', 'c', 'd' ]</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>유사배열객체인 경우 <code>call</code> 또는 <code>apply</code> 메서드를 이용해 배열 메서드를 사용할 수 있습니다.</p>\n</li>\n<li><p>배열 메서드인 <code>push</code>를 <code>객체 obj</code>에 적용해 프로퍼티 3에 ‘d’를 추가했습니다.</p>\n</li>\n<li><p>배열 메서드인 <code>slice</code>로 얕은 복사하여 객체를 배열로 반환했습니다.</p>\n</li>\n</ul>\n<p>이 밖에도 유사배열객체에는 <code>call</code>, <code>apply</code> 메서드를 이용해 모든 배열 메서드를 적용할 수 있습니다.<br>단, 문자열의 경우 <code>length</code> 프로퍼티가 읽기 전용이기 때문에 원본 문자열에 변경을 가하는 메서드(<code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>splice</code> 등)는 에러를 던지며, <code>concat</code> 처럼 대상이 반드시 배열이어야 하는 경우에는 에러는 나지 않지만 재대로 된 결과를 얻을 수 없습니다.</p>\n<ul>\n<li>사실 <code>call</code>, <code>apply</code>를 이용해 형변환하는 것은 ‘<code>this</code>를 원하는 값으로 지정해서 호출한다’라는 본래의 메서드의 의도와는 어긋나는 활용법이라고 할 수 있습니다.<br>또한 코드만 봐서는 어떤 의도인지 파악하기 쉽지 않습니다.</li>\n</ul>\n<ul>\n<li><mark>ES6 에서는 유사배열객체 또는 이터러블한 모든 종류의 데이터 타입을 배열로 전환</mark>하는 <code>Array.from</code>메서드가 추가되었습니다.</li>\n</ul>\n<hr>\n<h4 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from\"></a>Array.from</h4><p>Array 오브젝트를 생성하고 콜백 함수에서 반환된 값을 엘리먼트 값으로 설정하여 새로운 Array 객체를 반환합니다.</p>\n<blockquote>\n<p>Array.from(arrayLike[, mapFn[, thisArg]])</p>\n</blockquote>\n<ul>\n<li><p>arrayLike<br>배열로 변환하고자 하는 유사 배열 객체(Array-like)나 반복 가능한 객체(이터러블 오브젝트).</p>\n</li>\n<li><p>mapFn (선택적 파라미터)<br>배열의 모든 엘리먼트 마다 호출할 함수.</p>\n</li>\n<li><p>thisArg (선택적 파라미터)<br>두 번째 파라미터 함수 실행 시에 this로 참조할 값.</p>\n</li>\n<li><p>반환 값<br>새로운 Array 인스턴스.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>ES6의 Array.from</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">  length: <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>.from(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"class-내부에서-다른-class를-호출\"><a href=\"#class-내부에서-다른-class를-호출\" class=\"headerlink\" title=\"class 내부에서 다른 class를 호출\"></a>class 내부에서 다른 class를 호출</h4><p><code>class</code> 내부에 다른 <code>class</code>와 공통된 내용이 있을 경우 <code>call</code> 또는 <code>apply</code>를 이용해 다른 <code>class</code>를 호출하면 간단하게 반복을 줄일 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>class 내부에서 다른 class 호출</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, gender</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.gender = gender;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span>(<span class=\"params\">name, gender, school</span>) </span>&#123;</span><br><span class=\"line\">  Person.call(<span class=\"keyword\">this</span>, name, gender);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.school = school;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Employee</span>(<span class=\"params\">name, gender, company</span>) </span>&#123;</span><br><span class=\"line\">  Person.apply(<span class=\"keyword\">this</span>, [name, gender]);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.company = company;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> by = <span class=\"keyword\">new</span> Student(<span class=\"string\">'보영'</span>, <span class=\"string\">'female'</span>, <span class=\"string\">'단국대'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> jn = <span class=\"keyword\">new</span> Employee(<span class=\"string\">'재난'</span>, <span class=\"string\">'male'</span>, <span class=\"string\">'구골'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Student, Employee class함수 내부에서 Person 함수를 호출해서 instance 속성을 정의하게 했습니다.</p>\n<hr>\n<h4 id=\"여러-인수를-묶어-하나의-배열로-전달하고-싶을-때\"><a href=\"#여러-인수를-묶어-하나의-배열로-전달하고-싶을-때\" class=\"headerlink\" title=\"여러 인수를 묶어 하나의 배열로 전달하고 싶을 때\"></a>여러 인수를 묶어 하나의 배열로 전달하고 싶을 때</h4><p><code>apply</code>메서드를 사용해 하나의 배열로 인수들을 전달할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>여러 인수를 받는 메서드(Math.max/Math.min)에 apply 적용</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">3</span>, <span class=\"number\">16</span>, <span class=\"number\">45</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> max = <span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, numbers);</span><br><span class=\"line\"><span class=\"keyword\">var</span> min = <span class=\"built_in\">Math</span>.min.apply(<span class=\"literal\">null</span>, numbers);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(max, min); <span class=\"comment\">// 45 3</span></span><br></pre></td></tr></table></figure>\n\n<p>ES6에서는 <code>spread</code> 연산자를 이용하면 <code>apply</code>를 적용하는 것보다 더욱 간편하게 작성할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">3</span>, <span class=\"number\">16</span>, <span class=\"number\">45</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> max = <span class=\"built_in\">Math</span>.max(...numbers);</span><br><span class=\"line\"><span class=\"keyword\">const</span> min = <span class=\"built_in\">Math</span>.min(...numbers);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(max, min); <span class=\"comment\">// 45 3</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"bind-메서드\"><a href=\"#bind-메서드\" class=\"headerlink\" title=\"bind 메서드\"></a>bind 메서드</h3><blockquote>\n<p>Function.prototype.bind(thisArg[,arg1[, arg2[, …]]])</p>\n</blockquote>\n<p><code>bind</code> 메서드는 ES5에서 추가된 기능으로, call과 비슷하지만 즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드입니다.<br>다시 새로운 함수를 호출할 때 인수를 넘기면 그 인수들은 기존 <code>bind</code> 메서드를 호출할 때 전달했던 인수들의 뒤에 이어서 등록됩니다.<br>즉 <code>bind</code>메서드는 함수에 this를 미리 적용하는 것과 부분 적용 함수를 구현하는 두 가지 목적을 모두 지닙니다.</p>\n<figure class=\"highlight js\"><figcaption><span>bind메서드의 this 지정과 부분 적용 함수 구현</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c, d</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, a, b, c, d);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>); <span class=\"comment\">// Window&#123; ... &#125; 1 2 3 4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> bindFunc1 = func.bind(&#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span> &#125;);</span><br><span class=\"line\">bindFunc1(<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>); <span class=\"comment\">// &#123; x: 1 &#125; 5 6 7 8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">var</span> bindFunc2 = func.bind(&#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span> &#125;, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">bindFunc2(<span class=\"number\">6</span>, <span class=\"number\">7</span>); <span class=\"comment\">// &#123; x: 1 &#125; 4 5 6 7</span></span><br><span class=\"line\">bindFunc2(<span class=\"number\">8</span>, <span class=\"number\">9</span>); <span class=\"comment\">// &#123; x: 1 &#125; 4 5 8 9</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><code>bindFunc1</code> 변수에 <code>func</code> 변수에 <code>this</code>를 <code>{x : 1}</code>로 지정하는 새로운 함수가 할당됩니다.<br>다음 줄에서 <code>bindFunc1</code>을 호출하면 지정된 <code>this</code>값과 함께 반환됩니다.</p>\n</li>\n<li><p><code>bindFunc2</code> 변수에는 <code>func</code> 변수에 <code>this</code>를 <code>{x : 1}</code>로 지정하고, 파라미터를 차례대로 4, 5로 지정한 함수 새로운 함수가 할당됩니다. 다음 코드를 호출하면 <code>this</code>로 지정해준 값과 파라미터에 지정해준 값이 적용되고 그 다음 함수를 호출하며 넘겨준 파라미터 값이 붙습니다 <code>{x : 1} 4 5 6 7</code>, <code>{x : 1} 4 5 8 9</code> 형태로 반환됩니다.<br><mark>이것이 bind의 부분 적용 함수 구현법입니다.</mark></p>\n</li>\n</ol>\n<hr>\n<h4 id=\"name-프로퍼티\"><a href=\"#name-프로퍼티\" class=\"headerlink\" title=\"name 프로퍼티\"></a>name 프로퍼티</h4><p><u>bind 메서드를 적용해서 새로 만든 함수는 한 가지 독특한 성질이 있습니다.</u><br>name 프로퍼티에 동사 bind의 수동태인 <code>bound</code>라는 접두어가 붙습니다.</p>\n<p>함수의 name 프로퍼티가 <code>bound xxx</code>이라면 함수명이 xxx인 원본 함수에 <code>bind</code>메서드를 적용한 새로운 함수라는 의미가 되므로 call 과 apply 메서드에 비해 코드 추적이 용이한 점이 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c, d</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, a, b, c, d);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bindFunc = func.bind(&#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span> &#125;, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(func.name); <span class=\"comment\">// func</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bindFunc.name); <span class=\"comment\">// bound func</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"상위-컨텍스트의-this를-내부함수나-콜백-함수에-전달하기\"><a href=\"#상위-컨텍스트의-this를-내부함수나-콜백-함수에-전달하기\" class=\"headerlink\" title=\"상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기\"></a>상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기</h4><p>메서드의 내부함수에서 메서드의 <code>this</code>를 그대로 바라보게 하기 위한 방법으로<br>self 등의 변수를 활용하거나 화살표 함수를 이용한 우회법이 있었는데<br><code>call</code>, <code>apply</code>, <code>bind</code> 메서드를 이용하면 더 깔끔하게 처리할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>내부함수에 this 전달 - call</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  outer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">//&#123;outer : f&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">//&#123;outer : f&#125;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    innerFunc.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.outer();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>내부함수에 this 전달 -bind</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  outer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">//&#123;outer : f&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">//&#123;outer : f&#125;</span></span><br><span class=\"line\">    &#125;.bind(<span class=\"keyword\">this</span>); <span class=\"comment\">// 호출x, 새로운 함수 바인드</span></span><br><span class=\"line\">    innerFunc(); <span class=\"comment\">// 호출</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.outer();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>또한 콜백 함수를 인자로 받는 함수(메서드) 중에서 기본적으로 콜백 함수 내에서의 <code>this</code>에 관여하는 함수(메서드)에 대해서도 <code>bind</code> 메서드를 사용하면 <code>this</code>값을 지정하여 바꿀 수 있습니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>bind 메서드 - 내부 함수에 this 전달</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  logThis: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  logThisLater1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"keyword\">this</span>.logThis, <span class=\"number\">500</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  logThisLater2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"keyword\">this</span>.logThis.bind(<span class=\"keyword\">this</span>), <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.logThisLater1(); <span class=\"comment\">// Window &#123; ... &#125;</span></span><br><span class=\"line\">obj.logThisLater2(); <span class=\"comment\">// obj &#123; logThis: f, ... &#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"화살표-함수의-예외사항\"><a href=\"#화살표-함수의-예외사항\" class=\"headerlink\" title=\"화살표 함수의 예외사항\"></a>화살표 함수의 예외사항</h3><p>ES6에 새롭게 도입된 화살표 함수 <code>=&gt;</code>는 실행 컨텍스트 생성 시 this를 바인딩 하지 않습니다.<br>즉 화살표 함수 <code>=&gt;</code> 내부에는 <code>this</code>가 아예 없으며, <code>this</code>에 접근하고자 하면 스코프체인상 가장 가까운 <code>this</code>에 접근하게 됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>화삺표 함수 내부에서의 this</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  outer: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    innerFunc();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.outer();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>call</code>, <code>apply</code>, <code>bind</code>를 사용했던 예제의 내부함수를 <code>=&gt;</code>함수로 바꾼 것입니다.<br>더욱 간결해졌습니다.</li>\n</ul>\n<hr>\n<h3 id=\"별도의-인자로-this를-받는-경우-콜백-함수-내에서의-this\"><a href=\"#별도의-인자로-this를-받는-경우-콜백-함수-내에서의-this\" class=\"headerlink\" title=\"별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\"></a>별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)</h3><p>콜백 함수를 인자로 받는 메서드에는 <code>this</code>로 지정할 객체(<code>thisArg</code>)를 인자로 지정할 수 있는 것들이 있습니다. 이러한 메서드를 이용하여 <code>this</code>값을 원하는대로 변경할 수 있습니다.</p>\n<p>이러한 메서드는 내부 요소에 대해 같은 동작을 반복 수행해야하는 배열 메서드에 많이 존재하고, 같은 이유로 ES6에 추가된 <code>Set</code>, <code>Map</code>등의 메서드에도 일부 존재합니다.</p>\n<ul>\n<li><p>콜백 함수와 함께 thisArg를 인자로 받는 메서드</p>\n<table>\n<thead>\n<tr>\n<th>Array.prototype</th>\n<th>Set.prototype</th>\n<th>Map.prototype</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>forEach</code>(callback[, thisArg])</td>\n<td><code>forEach</code>(callback[, thisArg])</td>\n<td><code>forEach</code>(callback[, thisArg])</td>\n</tr>\n<tr>\n<td><code>map</code>(callback[, thisArg])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>filter</code>(callback[, thisArg])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>some</code>(callback[, thisArg])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>every</code>(callback[, thisArg])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>find</code>(callback[, thisArg])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>findIndex</code>(callback[, thisArg])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>flatMap</code>(callback[, thisArg])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>from</code>(arrayLike[, callback[, thisArg]])</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>대표적인 배열 메서드인 <code>forEach</code> 예시</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>forEach</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> report = &#123;</span><br><span class=\"line\">  sum: <span class=\"number\">0</span>,</span><br><span class=\"line\">  count: <span class=\"number\">0</span>,</span><br><span class=\"line\">  add: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    args.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">entry</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.sum += entry;</span><br><span class=\"line\">      ++<span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">    &#125;, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  average: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.sum / <span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">report.add(<span class=\"number\">60</span>, <span class=\"number\">85</span>, <span class=\"number\">95</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(report.sum, report.count, report.average()); <span class=\"comment\">// 240 3 80</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>60, 85, 95</code>를 인자로 삼아 <code>add</code> 메서드를 호출하면 <code>slice.call</code>메서드가 인자를 받아 새로운 배열로 반환합니다. 이후 <code>forEach</code> 메서드가 실행됩니다.</p>\n</li>\n<li><p>콜백 함수 내부의 <code>this</code>는 <code>forEach</code> 함수의 두 번째 인자로 전달해준 <code>this</code>(add 메서드의 this)가 전달된 상태이므로 <code>add</code> 메서드의 <code>this(report)</code>를 가리킵니다.</p>\n</li>\n<li><p>따라서 배열의 요소들을 순회 반복하며 <code>report.sum</code> , <code>report.count</code>값이 차례로 바뀌게 됩니다.<br>출력 결과로 <code>report.sum</code>에 240, <code>report.count</code>에 3이 반환되어 출력됩니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"this_point\">this 정리</h2>\n\n<p>명시적 <code>this</code> 바인딩이 없는 한 항상 성립하는 규칙</p>\n<ul>\n<li><p>전역공간에서의 <code>this</code>는 전역객체를 참조 (브라우저에서는 <code>window</code>, Node.js에서는 <code>global</code>)</p>\n</li>\n<li><p>함수를 메서드로 호출한 경우 <code>this</code>는 메서드 호출 주체를 참조 (메서드명 앞의 객체)</p>\n</li>\n<li><p>함수를 함수로 호출한 경우 <code>this</code>는 전역객체를 참조 (메서드의 내부함수에서도 동일)</p>\n</li>\n<li><p>콜백 함수 내부에서의 <code>this</code>는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바를 참조<br><code>this</code>가 정의되어 있지않다면 전역객체를 참조</p>\n</li>\n<li><p><code>class</code> 함수에서 <code>this</code>는 생성될 <code>instance</code>를 참조</p>\n</li>\n</ul>\n<p>위 규칙에 부합하지 않는 경우 명시적 <code>this</code> 바인딩 규칙으로 예측할 수 있습니다.</p>\n<ul>\n<li><p><code>call</code>, <code>apply</code> 메서드는 <code>this</code>를 명시적으로 지정하면서 함수 또는 메서드를 호출</p>\n</li>\n<li><p><code>bind</code> 메서드는 <code>this</code> 및 함수에 넘길 파라미터를 일부 지정해 새로운 함수를 만듭니다.</p>\n</li>\n<li><p>콜백 함수를 반복 순회,호출 하는 일부 메서드는 별도의 인자로 <code>this</code>를 받기도 합니다.</p>\n</li>\n</ul>"},{"title":"객체 조작 메서드 -jQuery","date":"2020-03-10T04:52:04.000Z","disqusId":"tunas-blog-1","_content":"\n\n<!-- more -->\n\n\n* * *\n\n### 속성 조작 메서드\n\n*   html() 메서드\n\n    1. $(\"요소 선택\").html();\n    2. $(\"요소 선택\").html(\"새 요소\");\n\n1.  선택한 요소에 하위 요소들을 불러옵니다.\n2.  선택한 요소에 하위 요소를 모두 지우고 “새 요소”로 바꿉니다\n\n*   text() 메서드\n\n    1. $(\"요소 선택\").text();\n    2. $(\"요소 선택\").text(\"새 택스트\");\n\n1.  선택한 요소에 포함하는 모든 텍스트을 불러옵니다.\n2.  선택한 요소에 있는 텍스트를 제거하고 “새 텍스트”로 바꿉니다\n\n*   css() 메서드\n\n    1. $(\"요소 선택\").css(\"속성\");\n    2. $(\"요소 선택\").css(\"속성\",\"값\");\n\n1.  선택한 요소에 스타일(css)속성을 불러옵니다.\n2.  선택한 요소에 스타일(css)속성을 바꾸거나 새 스타일(css)을 추가합니다.\n\n*   attr() 메서드\n\n    1. $(\"요소 선택\").attr(\"속성\");\n    2. $(\"요소 선택\").attr(\"속성\",\"새 값\");\n\n1.  선택한 요소에 지정한 속성 값을 불러옵니다.\n2.  선택한 요소에 지정한 속성 값을 새로 생성하거나 변경합니다.\n\n*   removeAttr() 메서드\n\n    1. $(\"요소 선택\").revomeAttr(\"속성\");\n\n1.  선택한 요소에 지정한 속성을 제거합니다.\n\n*   addClass() 메서드\n\n    1. $(\"요소 선택\").addClass(\"클래스 값\");\n\n1.  선택한 요소에 새 클래스(class)를 생성합니다.\n\n*   removeClass() 메서드\n\n    1. $(\"요소 선택\").removeClass(\"클래스 값\");\n\n1.  선택한 요소에 지정한 클래스를 삭제합니다.\n\n*   toggleClass() 메서드\n\n    1. $(\"요소 선택\").toggleClass(\"클래스 값\");\n\n1.  선택한 요소에 지정한 클래스의 존재 여부에 따라  \n    존재 하지않으면 생성하고, 존재 하면 삭제합니다.\n\n*   hasClass() 메서드\n\n    1. $(\"요소 선택\").hasClass(\"클래스 값\");\n\n1.  선택한 요소에 지정한 클래스 존재 여부의 따라  \n    존재할 시 true 아닐시 false를 반환합니다.\n\n*   val() 메서드\n\n    1. $(\"입력 요소 선택\").val();\n    2. $(\"입력 요소 선택\").val(\"새 값\");\n\n1.  선택한 입력 요소의 value 속성 값을 가져옵니다.\n2.  선택한 입력 요소의 value 속성에 새 값을 입력하거나 변경합니다.\n\n*   prop() 메서드\n\n    1. $(\"요소 선택\").prop(\"속성\");\n    2. $(\"요소 선택\").prop(\"속성\",\"새 값\");\n    3. $(\"요소 선택\").prop(\"[tagname | nodeType | selectedIndex]\");\n\n1.  선택한 요소의 속성 값을 반환합니다.\n2.  선택한 요소에 새 속성과 새 값을 생성하거나 기존 속성을 변경합니다.\n3.  선택한 요소에 태그명, 노드타입, 선택상자의 선택된 옵션의 인덱스를 반환합니다.\n\n* * *\n\n### 수치 조작 메서드\n\n\n| 종류          | 설명                                                                                     |\n|---------------|------------------------------------------------------------------------------------------|\n| height()      | **순수 요소**의 높이 값 (margin,padding,border 제외)                                     |\n| width()       | **순수 요소의** 너비 값 (margin,padding,border 제외)                                     |\n| innerHeight() | **여백(padding)을 포함**한 높이 값 (margin,border 제외)                                  |\n| innerWidth()  | **여백(padding)을 포함**한 너비 값 (margin,border 제외)                                  |\n| outerHeight() | **여백(padding)과 선(border) 포함**한 높이 값 (margin제외)                               |\n| outerWidth()  | **여백(padding)과 선(border) 포함**한 너비 값 (margin제외)                               |\n| position()    | 선택한 기준 요소(position:relative)위치로 부터 (position:absolute) 위치 값을 반환합니다. |\n| offset()      | 선택한 요소가 문서(document)에서 수평/수직으로 얼마나 떨어져 있는지 떨어져있는 값을 반환 |\n| scrollLeft()  | 브라우저 수평 스크롤 이동 높이 값 반환                                                   |\n| scrollTop()   | 브라우저 수직 스크롤 이동 너비 값 반환                                                   |\n\n\n* * *\n\n### 객체 편집 메서드\n\n\n*   before() / after() 메서드\n\n    1. $(\"요소 선택\").before(새 요소);\n    2. $(\"요소 선택\").after(새 요소);\n\n1.  선택한 요소의 이전 위치에 새 요소 생성\n2.  선택한 요소의 다음 위치에 새 요소 생성\n\n*   append() / appendTo() / prepend() / prependTo() 메서드\n\n    1. $(\"요소 선택\").append(\"새 요소\");\n    // 선택한 요소 내의 마지막 위치에 새 요소를 추가합니다.\n    \n    1. $(\"새 요소\").appendTo(\"요소 선택\");\n    // 새 요소를 선택한 요소 내의 마지막 위치에 추가합니다.\n    \n    2. $(\"요소 선택\").prepend(\"새 요소\");\n    // 선택한 요소 내의 앞 위치에 새 요소를 추가합니다.\n    \n    2. $(\"새 요소\").prependTo(\"요소 선택\");\n    // 새 요소를 선택한 요소 내의 앞 위치에 추가합니다.\n\nto : ~을 ~에게  \n영어 뜻을 잘생각하여 사용해야 합니다.\n\n*   inserBefore() / inserAfter() / clone() 메서드\n\n    1. $(\"새 요소\").inserBefore(\"요소 선택\");\n    1. $(\"새 요소\").inserAfter(\"요소 선택\");\n    3. $(\"요소 선택\").clone(ture);\n    4. $(\"요소 선택\").clone(false);\n\n1.  선택한 요소의 이전 위치에 새 요소를 생성합니다.\n2.  선택한 요소의 다음 위치에 새 요소를 생성합니다.\n3.  선택한 요소의 하위 요소까지 복제합니다. ()값 작성안할시 기본 true값 입니다.\n4.  선택한 요소의 하위 요소를 제외하고 복제합니다.\n\n*   empty() / remove() 메서드\n\n    1. $(\"요소 선택\").empty();\n    2. $(\"요소 선택\").remove();\n\n1.  선택한 요소에 모든 하위 요소를 비웁니다.\n2.  선택한 요소를 삭제 합니다.\n\n*   replaceAll() / replaceWith() 메서드\n\n    1. $(\"새 요소\").replaceAll(\"요소 선택\");\n    2. $(\"요소 선택\").replaceWith(\"새 요소\");\n\n1.  replaceAll() 메서드는 선택한 요소를 새 HTML 요소로 바꿉니다.\n2.  replaceWith() 메서드는 선택한 요소를 새 내용으로 바꿉니다.\n\n*   unwrap() / wrap() / wrapAll() / wrapInner() 메서드\n\n    1. $(\"요소 선택\").unwrap();\n    2. $(\"요소 선택\").wrap(\"새 요소\");\n    3. $(\"요소 선택\").wrapAll(\"새 요소\");\n    4. $(\"요소 선택\").wrapInner(\"새 요소\");\n\n1.  선택한 요소의 **부모 요소를 삭제**합니다.\n2.  선택한 요소를 새 요소로 **각각** 감쌉니다.\n3.  선택한 요소를 **새 요소로 한꺼번에** 감쌉니다.\n4.  선택한 요소에 **하위 요소를** 새 요소로 감쌉니다.\n\n----------\n\n### jQuery선택자 정리 예제\n\n```js style , body ex)\n<style type=\"text/css\">  \n div{background-color:yellow;}  \n .tit{background-color:orange;}  \n</style>  \n</head>  \n<body>  \n <h1 align=\"center\"><strong>내용1</strong></h1>  \n <h2><strong>내용2</strong></h2>  \n <h2>내용3</h2>  \n <h2 class=\"tit\">내용4</h2>  \n <ul class=\"myList\">  \n <li>리스트1</li>  \n <li id=\"two\">리스트2</li>  \n <li class=\"three\">리스트3</li>  \n <li>리스트4</li>  \n </ul>  \n</body>  \n```\n\n```js JavasSript-jQuery\n<script type=\"text/javascript\" src=\"경로/jQuery-버전.js\"></script>  \n<script type=\"text/javascript\">  \n  \n$(function(){  \n $(\"h1\").attr(\"align\",\"left\");   \n // h1 태그의 align 속성값을 left로 적용합니다  \n $(\"li:first\").text(\"첫 번째 리스트\");  \n // li 태그 첫 번째 요소의 텍스트를 \"첫 번째 리스트\"로 바꿉니다.  \n $(\"h2 > strong\").css(\"color\",\"red\");  \n // h2 태그 안에 있는 strong 태그에 css적용하여 빨간색으로 적용합니다.  \n $(\"#two\").prev().css(\"color\",\"blue\");  \n // id값 two인 요소 이전 요소에 css적용하여 파란색으로 적용합니다.  \n $(\"#two\").next().css(\"color\",\"purple\");  \n // id값 two인 요소 다음 요소에 css적용하여 보라색으로 적용합니다.  \n $(\"#two\").parent().css(\"border\",\"2px dashed navy\");  \n // id값 two인 요소의 부모 요소를 선택하고 css로 border값, 속성을 적용합니다.  \n  \n $(\".myList\").prepend(\"<li>Front</li>\");  \n //class명 myList 요소 내의 가장 앞 위치에 \"<li>Front</li>\" 요소를 추가합니다.  \n $(\".myList\").append(\"<li>Back</li>\");  \n //class명 myList 요소 내의 마지막 위치에 \"<li>Back</li>\" 요소를 추가합니다.  \n  \n $(\"<li>앞에 생성</li>\").insertBefore(\".three\");  \n //\"<li>앞에 생성</li>\"요소를 class명 \"three\"인 요소의 이전 위치에 생성합니다.  \n $(\"<li>뒤에 생성</li>\").insertAfter(\".three\");  \n //\"<li>뒤에 생성</li>\"요소를 class명 \"three\"인 요소의 다음 위치에 생성합니다.  \n  \n $(\"h2\").eq(1).wrap(\"<div/>\");  \n //h2 태그중 인덱스(1) 즉 2번째 h2요소를 div 태그로 감쌉니다.  \n $(\"h2:has('strong')\").addClass(\"tit\");  \n //strong 태그를 가지고 있는 h2태그에 class \"tit\"를 추가합니다.  \n $(\"h2:last\").removeClass(\"tit\");  \n //h2 태그중 마지막 요소에 class \"tit\"속성을 제거합니다.  \n  \n});  \n</script>  \n```","source":"_posts/객체 조작 메서드 -jQuery.md","raw":"---\ntitle: 객체 조작 메서드 -jQuery\ndate: 2020-03-10 13:52:04\ndisqusId: tunas-blog-1\ncategories: jQuery\ntag: \n- jQuery\n- JavaScript\n---\n\n\n<!-- more -->\n\n\n* * *\n\n### 속성 조작 메서드\n\n*   html() 메서드\n\n    1. $(\"요소 선택\").html();\n    2. $(\"요소 선택\").html(\"새 요소\");\n\n1.  선택한 요소에 하위 요소들을 불러옵니다.\n2.  선택한 요소에 하위 요소를 모두 지우고 “새 요소”로 바꿉니다\n\n*   text() 메서드\n\n    1. $(\"요소 선택\").text();\n    2. $(\"요소 선택\").text(\"새 택스트\");\n\n1.  선택한 요소에 포함하는 모든 텍스트을 불러옵니다.\n2.  선택한 요소에 있는 텍스트를 제거하고 “새 텍스트”로 바꿉니다\n\n*   css() 메서드\n\n    1. $(\"요소 선택\").css(\"속성\");\n    2. $(\"요소 선택\").css(\"속성\",\"값\");\n\n1.  선택한 요소에 스타일(css)속성을 불러옵니다.\n2.  선택한 요소에 스타일(css)속성을 바꾸거나 새 스타일(css)을 추가합니다.\n\n*   attr() 메서드\n\n    1. $(\"요소 선택\").attr(\"속성\");\n    2. $(\"요소 선택\").attr(\"속성\",\"새 값\");\n\n1.  선택한 요소에 지정한 속성 값을 불러옵니다.\n2.  선택한 요소에 지정한 속성 값을 새로 생성하거나 변경합니다.\n\n*   removeAttr() 메서드\n\n    1. $(\"요소 선택\").revomeAttr(\"속성\");\n\n1.  선택한 요소에 지정한 속성을 제거합니다.\n\n*   addClass() 메서드\n\n    1. $(\"요소 선택\").addClass(\"클래스 값\");\n\n1.  선택한 요소에 새 클래스(class)를 생성합니다.\n\n*   removeClass() 메서드\n\n    1. $(\"요소 선택\").removeClass(\"클래스 값\");\n\n1.  선택한 요소에 지정한 클래스를 삭제합니다.\n\n*   toggleClass() 메서드\n\n    1. $(\"요소 선택\").toggleClass(\"클래스 값\");\n\n1.  선택한 요소에 지정한 클래스의 존재 여부에 따라  \n    존재 하지않으면 생성하고, 존재 하면 삭제합니다.\n\n*   hasClass() 메서드\n\n    1. $(\"요소 선택\").hasClass(\"클래스 값\");\n\n1.  선택한 요소에 지정한 클래스 존재 여부의 따라  \n    존재할 시 true 아닐시 false를 반환합니다.\n\n*   val() 메서드\n\n    1. $(\"입력 요소 선택\").val();\n    2. $(\"입력 요소 선택\").val(\"새 값\");\n\n1.  선택한 입력 요소의 value 속성 값을 가져옵니다.\n2.  선택한 입력 요소의 value 속성에 새 값을 입력하거나 변경합니다.\n\n*   prop() 메서드\n\n    1. $(\"요소 선택\").prop(\"속성\");\n    2. $(\"요소 선택\").prop(\"속성\",\"새 값\");\n    3. $(\"요소 선택\").prop(\"[tagname | nodeType | selectedIndex]\");\n\n1.  선택한 요소의 속성 값을 반환합니다.\n2.  선택한 요소에 새 속성과 새 값을 생성하거나 기존 속성을 변경합니다.\n3.  선택한 요소에 태그명, 노드타입, 선택상자의 선택된 옵션의 인덱스를 반환합니다.\n\n* * *\n\n### 수치 조작 메서드\n\n\n| 종류          | 설명                                                                                     |\n|---------------|------------------------------------------------------------------------------------------|\n| height()      | **순수 요소**의 높이 값 (margin,padding,border 제외)                                     |\n| width()       | **순수 요소의** 너비 값 (margin,padding,border 제외)                                     |\n| innerHeight() | **여백(padding)을 포함**한 높이 값 (margin,border 제외)                                  |\n| innerWidth()  | **여백(padding)을 포함**한 너비 값 (margin,border 제외)                                  |\n| outerHeight() | **여백(padding)과 선(border) 포함**한 높이 값 (margin제외)                               |\n| outerWidth()  | **여백(padding)과 선(border) 포함**한 너비 값 (margin제외)                               |\n| position()    | 선택한 기준 요소(position:relative)위치로 부터 (position:absolute) 위치 값을 반환합니다. |\n| offset()      | 선택한 요소가 문서(document)에서 수평/수직으로 얼마나 떨어져 있는지 떨어져있는 값을 반환 |\n| scrollLeft()  | 브라우저 수평 스크롤 이동 높이 값 반환                                                   |\n| scrollTop()   | 브라우저 수직 스크롤 이동 너비 값 반환                                                   |\n\n\n* * *\n\n### 객체 편집 메서드\n\n\n*   before() / after() 메서드\n\n    1. $(\"요소 선택\").before(새 요소);\n    2. $(\"요소 선택\").after(새 요소);\n\n1.  선택한 요소의 이전 위치에 새 요소 생성\n2.  선택한 요소의 다음 위치에 새 요소 생성\n\n*   append() / appendTo() / prepend() / prependTo() 메서드\n\n    1. $(\"요소 선택\").append(\"새 요소\");\n    // 선택한 요소 내의 마지막 위치에 새 요소를 추가합니다.\n    \n    1. $(\"새 요소\").appendTo(\"요소 선택\");\n    // 새 요소를 선택한 요소 내의 마지막 위치에 추가합니다.\n    \n    2. $(\"요소 선택\").prepend(\"새 요소\");\n    // 선택한 요소 내의 앞 위치에 새 요소를 추가합니다.\n    \n    2. $(\"새 요소\").prependTo(\"요소 선택\");\n    // 새 요소를 선택한 요소 내의 앞 위치에 추가합니다.\n\nto : ~을 ~에게  \n영어 뜻을 잘생각하여 사용해야 합니다.\n\n*   inserBefore() / inserAfter() / clone() 메서드\n\n    1. $(\"새 요소\").inserBefore(\"요소 선택\");\n    1. $(\"새 요소\").inserAfter(\"요소 선택\");\n    3. $(\"요소 선택\").clone(ture);\n    4. $(\"요소 선택\").clone(false);\n\n1.  선택한 요소의 이전 위치에 새 요소를 생성합니다.\n2.  선택한 요소의 다음 위치에 새 요소를 생성합니다.\n3.  선택한 요소의 하위 요소까지 복제합니다. ()값 작성안할시 기본 true값 입니다.\n4.  선택한 요소의 하위 요소를 제외하고 복제합니다.\n\n*   empty() / remove() 메서드\n\n    1. $(\"요소 선택\").empty();\n    2. $(\"요소 선택\").remove();\n\n1.  선택한 요소에 모든 하위 요소를 비웁니다.\n2.  선택한 요소를 삭제 합니다.\n\n*   replaceAll() / replaceWith() 메서드\n\n    1. $(\"새 요소\").replaceAll(\"요소 선택\");\n    2. $(\"요소 선택\").replaceWith(\"새 요소\");\n\n1.  replaceAll() 메서드는 선택한 요소를 새 HTML 요소로 바꿉니다.\n2.  replaceWith() 메서드는 선택한 요소를 새 내용으로 바꿉니다.\n\n*   unwrap() / wrap() / wrapAll() / wrapInner() 메서드\n\n    1. $(\"요소 선택\").unwrap();\n    2. $(\"요소 선택\").wrap(\"새 요소\");\n    3. $(\"요소 선택\").wrapAll(\"새 요소\");\n    4. $(\"요소 선택\").wrapInner(\"새 요소\");\n\n1.  선택한 요소의 **부모 요소를 삭제**합니다.\n2.  선택한 요소를 새 요소로 **각각** 감쌉니다.\n3.  선택한 요소를 **새 요소로 한꺼번에** 감쌉니다.\n4.  선택한 요소에 **하위 요소를** 새 요소로 감쌉니다.\n\n----------\n\n### jQuery선택자 정리 예제\n\n```js style , body ex)\n<style type=\"text/css\">  \n div{background-color:yellow;}  \n .tit{background-color:orange;}  \n</style>  \n</head>  \n<body>  \n <h1 align=\"center\"><strong>내용1</strong></h1>  \n <h2><strong>내용2</strong></h2>  \n <h2>내용3</h2>  \n <h2 class=\"tit\">내용4</h2>  \n <ul class=\"myList\">  \n <li>리스트1</li>  \n <li id=\"two\">리스트2</li>  \n <li class=\"three\">리스트3</li>  \n <li>리스트4</li>  \n </ul>  \n</body>  \n```\n\n```js JavasSript-jQuery\n<script type=\"text/javascript\" src=\"경로/jQuery-버전.js\"></script>  \n<script type=\"text/javascript\">  \n  \n$(function(){  \n $(\"h1\").attr(\"align\",\"left\");   \n // h1 태그의 align 속성값을 left로 적용합니다  \n $(\"li:first\").text(\"첫 번째 리스트\");  \n // li 태그 첫 번째 요소의 텍스트를 \"첫 번째 리스트\"로 바꿉니다.  \n $(\"h2 > strong\").css(\"color\",\"red\");  \n // h2 태그 안에 있는 strong 태그에 css적용하여 빨간색으로 적용합니다.  \n $(\"#two\").prev().css(\"color\",\"blue\");  \n // id값 two인 요소 이전 요소에 css적용하여 파란색으로 적용합니다.  \n $(\"#two\").next().css(\"color\",\"purple\");  \n // id값 two인 요소 다음 요소에 css적용하여 보라색으로 적용합니다.  \n $(\"#two\").parent().css(\"border\",\"2px dashed navy\");  \n // id값 two인 요소의 부모 요소를 선택하고 css로 border값, 속성을 적용합니다.  \n  \n $(\".myList\").prepend(\"<li>Front</li>\");  \n //class명 myList 요소 내의 가장 앞 위치에 \"<li>Front</li>\" 요소를 추가합니다.  \n $(\".myList\").append(\"<li>Back</li>\");  \n //class명 myList 요소 내의 마지막 위치에 \"<li>Back</li>\" 요소를 추가합니다.  \n  \n $(\"<li>앞에 생성</li>\").insertBefore(\".three\");  \n //\"<li>앞에 생성</li>\"요소를 class명 \"three\"인 요소의 이전 위치에 생성합니다.  \n $(\"<li>뒤에 생성</li>\").insertAfter(\".three\");  \n //\"<li>뒤에 생성</li>\"요소를 class명 \"three\"인 요소의 다음 위치에 생성합니다.  \n  \n $(\"h2\").eq(1).wrap(\"<div/>\");  \n //h2 태그중 인덱스(1) 즉 2번째 h2요소를 div 태그로 감쌉니다.  \n $(\"h2:has('strong')\").addClass(\"tit\");  \n //strong 태그를 가지고 있는 h2태그에 class \"tit\"를 추가합니다.  \n $(\"h2:last\").removeClass(\"tit\");  \n //h2 태그중 마지막 요소에 class \"tit\"속성을 제거합니다.  \n  \n});  \n</script>  \n```","slug":"객체 조작 메서드 -jQuery","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrt9002pqgvq49wk6rzw","content":"<a id=\"more\"></a>\n\n\n<hr>\n<h3 id=\"속성-조작-메서드\"><a href=\"#속성-조작-메서드\" class=\"headerlink\" title=\"속성 조작 메서드\"></a>속성 조작 메서드</h3><ul>\n<li><p>html() 메서드</p>\n<ol>\n<li>$(“요소 선택”).html();</li>\n<li>$(“요소 선택”).html(“새 요소”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 하위 요소들을 불러옵니다.</li>\n<li>선택한 요소에 하위 요소를 모두 지우고 “새 요소”로 바꿉니다</li>\n</ol>\n<ul>\n<li><p>text() 메서드</p>\n<ol>\n<li>$(“요소 선택”).text();</li>\n<li>$(“요소 선택”).text(“새 택스트”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 포함하는 모든 텍스트을 불러옵니다.</li>\n<li>선택한 요소에 있는 텍스트를 제거하고 “새 텍스트”로 바꿉니다</li>\n</ol>\n<ul>\n<li><p>css() 메서드</p>\n<ol>\n<li>$(“요소 선택”).css(“속성”);</li>\n<li>$(“요소 선택”).css(“속성”,”값”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 스타일(css)속성을 불러옵니다.</li>\n<li>선택한 요소에 스타일(css)속성을 바꾸거나 새 스타일(css)을 추가합니다.</li>\n</ol>\n<ul>\n<li><p>attr() 메서드</p>\n<ol>\n<li>$(“요소 선택”).attr(“속성”);</li>\n<li>$(“요소 선택”).attr(“속성”,”새 값”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 지정한 속성 값을 불러옵니다.</li>\n<li>선택한 요소에 지정한 속성 값을 새로 생성하거나 변경합니다.</li>\n</ol>\n<ul>\n<li><p>removeAttr() 메서드</p>\n<ol>\n<li>$(“요소 선택”).revomeAttr(“속성”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 지정한 속성을 제거합니다.</li>\n</ol>\n<ul>\n<li><p>addClass() 메서드</p>\n<ol>\n<li>$(“요소 선택”).addClass(“클래스 값”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 새 클래스(class)를 생성합니다.</li>\n</ol>\n<ul>\n<li><p>removeClass() 메서드</p>\n<ol>\n<li>$(“요소 선택”).removeClass(“클래스 값”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 지정한 클래스를 삭제합니다.</li>\n</ol>\n<ul>\n<li><p>toggleClass() 메서드</p>\n<ol>\n<li>$(“요소 선택”).toggleClass(“클래스 값”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 지정한 클래스의 존재 여부에 따라<br>존재 하지않으면 생성하고, 존재 하면 삭제합니다.</li>\n</ol>\n<ul>\n<li><p>hasClass() 메서드</p>\n<ol>\n<li>$(“요소 선택”).hasClass(“클래스 값”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 지정한 클래스 존재 여부의 따라<br>존재할 시 true 아닐시 false를 반환합니다.</li>\n</ol>\n<ul>\n<li><p>val() 메서드</p>\n<ol>\n<li>$(“입력 요소 선택”).val();</li>\n<li>$(“입력 요소 선택”).val(“새 값”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 입력 요소의 value 속성 값을 가져옵니다.</li>\n<li>선택한 입력 요소의 value 속성에 새 값을 입력하거나 변경합니다.</li>\n</ol>\n<ul>\n<li><p>prop() 메서드</p>\n<ol>\n<li>$(“요소 선택”).prop(“속성”);</li>\n<li>$(“요소 선택”).prop(“속성”,”새 값”);</li>\n<li>$(“요소 선택”).prop(“[tagname | nodeType | selectedIndex]”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소의 속성 값을 반환합니다.</li>\n<li>선택한 요소에 새 속성과 새 값을 생성하거나 기존 속성을 변경합니다.</li>\n<li>선택한 요소에 태그명, 노드타입, 선택상자의 선택된 옵션의 인덱스를 반환합니다.</li>\n</ol>\n<hr>\n<h3 id=\"수치-조작-메서드\"><a href=\"#수치-조작-메서드\" class=\"headerlink\" title=\"수치 조작 메서드\"></a>수치 조작 메서드</h3><table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>height()</td>\n<td><strong>순수 요소</strong>의 높이 값 (margin,padding,border 제외)</td>\n</tr>\n<tr>\n<td>width()</td>\n<td><strong>순수 요소의</strong> 너비 값 (margin,padding,border 제외)</td>\n</tr>\n<tr>\n<td>innerHeight()</td>\n<td><strong>여백(padding)을 포함</strong>한 높이 값 (margin,border 제외)</td>\n</tr>\n<tr>\n<td>innerWidth()</td>\n<td><strong>여백(padding)을 포함</strong>한 너비 값 (margin,border 제외)</td>\n</tr>\n<tr>\n<td>outerHeight()</td>\n<td><strong>여백(padding)과 선(border) 포함</strong>한 높이 값 (margin제외)</td>\n</tr>\n<tr>\n<td>outerWidth()</td>\n<td><strong>여백(padding)과 선(border) 포함</strong>한 너비 값 (margin제외)</td>\n</tr>\n<tr>\n<td>position()</td>\n<td>선택한 기준 요소(position:relative)위치로 부터 (position:absolute) 위치 값을 반환합니다.</td>\n</tr>\n<tr>\n<td>offset()</td>\n<td>선택한 요소가 문서(document)에서 수평/수직으로 얼마나 떨어져 있는지 떨어져있는 값을 반환</td>\n</tr>\n<tr>\n<td>scrollLeft()</td>\n<td>브라우저 수평 스크롤 이동 높이 값 반환</td>\n</tr>\n<tr>\n<td>scrollTop()</td>\n<td>브라우저 수직 스크롤 이동 너비 값 반환</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"객체-편집-메서드\"><a href=\"#객체-편집-메서드\" class=\"headerlink\" title=\"객체 편집 메서드\"></a>객체 편집 메서드</h3><ul>\n<li><p>before() / after() 메서드</p>\n<ol>\n<li>$(“요소 선택”).before(새 요소);</li>\n<li>$(“요소 선택”).after(새 요소);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소의 이전 위치에 새 요소 생성</li>\n<li>선택한 요소의 다음 위치에 새 요소 생성</li>\n</ol>\n<ul>\n<li><p>append() / appendTo() / prepend() / prependTo() 메서드</p>\n<ol>\n<li><p>$(“요소 선택”).append(“새 요소”);<br>// 선택한 요소 내의 마지막 위치에 새 요소를 추가합니다.</p>\n</li>\n<li><p>$(“새 요소”).appendTo(“요소 선택”);<br>// 새 요소를 선택한 요소 내의 마지막 위치에 추가합니다.</p>\n</li>\n<li><p>$(“요소 선택”).prepend(“새 요소”);<br>// 선택한 요소 내의 앞 위치에 새 요소를 추가합니다.</p>\n</li>\n<li><p>$(“새 요소”).prependTo(“요소 선택”);<br>// 새 요소를 선택한 요소 내의 앞 위치에 추가합니다.</p>\n</li>\n</ol>\n</li>\n</ul>\n<p>to : ~을 ~에게<br>영어 뜻을 잘생각하여 사용해야 합니다.</p>\n<ul>\n<li><p>inserBefore() / inserAfter() / clone() 메서드</p>\n<ol>\n<li>$(“새 요소”).inserBefore(“요소 선택”);</li>\n<li>$(“새 요소”).inserAfter(“요소 선택”);</li>\n<li>$(“요소 선택”).clone(ture);</li>\n<li>$(“요소 선택”).clone(false);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소의 이전 위치에 새 요소를 생성합니다.</li>\n<li>선택한 요소의 다음 위치에 새 요소를 생성합니다.</li>\n<li>선택한 요소의 하위 요소까지 복제합니다. ()값 작성안할시 기본 true값 입니다.</li>\n<li>선택한 요소의 하위 요소를 제외하고 복제합니다.</li>\n</ol>\n<ul>\n<li><p>empty() / remove() 메서드</p>\n<ol>\n<li>$(“요소 선택”).empty();</li>\n<li>$(“요소 선택”).remove();</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 모든 하위 요소를 비웁니다.</li>\n<li>선택한 요소를 삭제 합니다.</li>\n</ol>\n<ul>\n<li><p>replaceAll() / replaceWith() 메서드</p>\n<ol>\n<li>$(“새 요소”).replaceAll(“요소 선택”);</li>\n<li>$(“요소 선택”).replaceWith(“새 요소”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>replaceAll() 메서드는 선택한 요소를 새 HTML 요소로 바꿉니다.</li>\n<li>replaceWith() 메서드는 선택한 요소를 새 내용으로 바꿉니다.</li>\n</ol>\n<ul>\n<li><p>unwrap() / wrap() / wrapAll() / wrapInner() 메서드</p>\n<ol>\n<li>$(“요소 선택”).unwrap();</li>\n<li>$(“요소 선택”).wrap(“새 요소”);</li>\n<li>$(“요소 선택”).wrapAll(“새 요소”);</li>\n<li>$(“요소 선택”).wrapInner(“새 요소”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소의 <strong>부모 요소를 삭제</strong>합니다.</li>\n<li>선택한 요소를 새 요소로 <strong>각각</strong> 감쌉니다.</li>\n<li>선택한 요소를 <strong>새 요소로 한꺼번에</strong> 감쌉니다.</li>\n<li>선택한 요소에 <strong>하위 요소를</strong> 새 요소로 감쌉니다.</li>\n</ol>\n<hr>\n<h3 id=\"jQuery선택자-정리-예제\"><a href=\"#jQuery선택자-정리-예제\" class=\"headerlink\" title=\"jQuery선택자 정리 예제\"></a>jQuery선택자 정리 예제</h3><figure class=\"highlight js\"><figcaption><span>style , body ex)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style type=<span class=\"string\">\"text/css\"</span>&gt;  </span><br><span class=\"line\"> div&#123;background-color:yellow;&#125;  </span><br><span class=\"line\"> .tit&#123;background-color:orange;&#125;  </span><br><span class=\"line\">&lt;<span class=\"regexp\">/style&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>head&gt;  </span><br><span class=\"line\">&lt;body&gt;  </span><br><span class=\"line\"> &lt;h1 align=<span class=\"string\">\"center\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">strong</span>&gt;</span>내용1<span class=\"tag\">&lt;/<span class=\"name\">strong</span>&gt;</span></span>&lt;<span class=\"regexp\">/h1&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;h2&gt;&lt;strong&gt;내용2&lt;/</span>strong&gt;&lt;<span class=\"regexp\">/h2&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;h2&gt;내용3&lt;/</span>h2&gt;  </span><br><span class=\"line\"> &lt;h2 <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"tit\"</span>&gt;내용<span class=\"number\">4</span>&lt;<span class=\"regexp\">/h2&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;ul class=\"myList\"&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;li&gt;리스트1&lt;/</span>li&gt;  </span><br><span class=\"line\"> &lt;li id=<span class=\"string\">\"two\"</span>&gt;리스트<span class=\"number\">2</span>&lt;<span class=\"regexp\">/li&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;li class=\"three\"&gt;리스트3&lt;/</span>li&gt;  </span><br><span class=\"line\"> &lt;li&gt;리스트<span class=\"number\">4</span>&lt;<span class=\"regexp\">/li&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;/u</span>l&gt;  </span><br><span class=\"line\">&lt;<span class=\"regexp\">/body&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>JavasSript-jQuery</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"경로/jQuery-버전.js\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script type=\"text/</span>javascript<span class=\"string\">\"&gt;  </span></span><br><span class=\"line\"><span class=\"string\">  </span></span><br><span class=\"line\"><span class=\"string\">$(function()&#123;  </span></span><br><span class=\"line\"><span class=\"string\"> $(\"</span>h1<span class=\"string\">\").attr(\"</span>align<span class=\"string\">\",\"</span>left<span class=\"string\">\");   </span></span><br><span class=\"line\"><span class=\"string\"> // h1 태그의 align 속성값을 left로 적용합니다  </span></span><br><span class=\"line\"><span class=\"string\"> $(\"</span>li:first<span class=\"string\">\").text(\"</span>첫 번째 리스트<span class=\"string\">\");  </span></span><br><span class=\"line\"><span class=\"string\"> // li 태그 첫 번째 요소의 텍스트를 \"</span>첫 번째 리스트<span class=\"string\">\"로 바꿉니다.  </span></span><br><span class=\"line\"><span class=\"string\"> $(\"</span>h2 &gt; strong<span class=\"string\">\").css(\"</span>color<span class=\"string\">\",\"</span>red<span class=\"string\">\");  </span></span><br><span class=\"line\"><span class=\"string\"> // h2 태그 안에 있는 strong 태그에 css적용하여 빨간색으로 적용합니다.  </span></span><br><span class=\"line\"> $(\"#two\").prev().css(\"color\",\"blue\");  </span><br><span class=\"line\"> <span class=\"comment\">// id값 two인 요소 이전 요소에 css적용하여 파란색으로 적용합니다.  </span></span><br><span class=\"line\"> $(<span class=\"string\">\"#two\"</span>).next().css(<span class=\"string\">\"color\"</span>,<span class=\"string\">\"purple\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">// id값 two인 요소 다음 요소에 css적용하여 보라색으로 적용합니다.  </span></span><br><span class=\"line\"> $(<span class=\"string\">\"#two\"</span>).parent().css(<span class=\"string\">\"border\"</span>,<span class=\"string\">\"2px dashed navy\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">// id값 two인 요소의 부모 요소를 선택하고 css로 border값, 속성을 적용합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> $(<span class=\"string\">\".myList\"</span>).prepend(<span class=\"string\">\"&lt;li&gt;Front&lt;/li&gt;\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//class명 myList 요소 내의 가장 앞 위치에 \"&lt;li&gt;Front&lt;/li&gt;\" 요소를 추가합니다.  </span></span><br><span class=\"line\"> $(<span class=\"string\">\".myList\"</span>).append(<span class=\"string\">\"&lt;li&gt;Back&lt;/li&gt;\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//class명 myList 요소 내의 마지막 위치에 \"&lt;li&gt;Back&lt;/li&gt;\" 요소를 추가합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> $(<span class=\"string\">\"&lt;li&gt;앞에 생성&lt;/li&gt;\"</span>).insertBefore(<span class=\"string\">\".three\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//\"&lt;li&gt;앞에 생성&lt;/li&gt;\"요소를 class명 \"three\"인 요소의 이전 위치에 생성합니다.  </span></span><br><span class=\"line\"> $(<span class=\"string\">\"&lt;li&gt;뒤에 생성&lt;/li&gt;\"</span>).insertAfter(<span class=\"string\">\".three\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//\"&lt;li&gt;뒤에 생성&lt;/li&gt;\"요소를 class명 \"three\"인 요소의 다음 위치에 생성합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> $(<span class=\"string\">\"h2\"</span>).eq(<span class=\"number\">1</span>).wrap(<span class=\"string\">\"&lt;div/&gt;\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//h2 태그중 인덱스(1) 즉 2번째 h2요소를 div 태그로 감쌉니다.  </span></span><br><span class=\"line\"> $(<span class=\"string\">\"h2:has('strong')\"</span>).addClass(<span class=\"string\">\"tit\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//strong 태그를 가지고 있는 h2태그에 class \"tit\"를 추가합니다.  </span></span><br><span class=\"line\"> $(<span class=\"string\">\"h2:last\"</span>).removeClass(<span class=\"string\">\"tit\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//h2 태그중 마지막 요소에 class \"tit\"속성을 제거합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<hr>\n<h3 id=\"속성-조작-메서드\"><a href=\"#속성-조작-메서드\" class=\"headerlink\" title=\"속성 조작 메서드\"></a>속성 조작 메서드</h3><ul>\n<li><p>html() 메서드</p>\n<ol>\n<li>$(“요소 선택”).html();</li>\n<li>$(“요소 선택”).html(“새 요소”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 하위 요소들을 불러옵니다.</li>\n<li>선택한 요소에 하위 요소를 모두 지우고 “새 요소”로 바꿉니다</li>\n</ol>\n<ul>\n<li><p>text() 메서드</p>\n<ol>\n<li>$(“요소 선택”).text();</li>\n<li>$(“요소 선택”).text(“새 택스트”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 포함하는 모든 텍스트을 불러옵니다.</li>\n<li>선택한 요소에 있는 텍스트를 제거하고 “새 텍스트”로 바꿉니다</li>\n</ol>\n<ul>\n<li><p>css() 메서드</p>\n<ol>\n<li>$(“요소 선택”).css(“속성”);</li>\n<li>$(“요소 선택”).css(“속성”,”값”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 스타일(css)속성을 불러옵니다.</li>\n<li>선택한 요소에 스타일(css)속성을 바꾸거나 새 스타일(css)을 추가합니다.</li>\n</ol>\n<ul>\n<li><p>attr() 메서드</p>\n<ol>\n<li>$(“요소 선택”).attr(“속성”);</li>\n<li>$(“요소 선택”).attr(“속성”,”새 값”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 지정한 속성 값을 불러옵니다.</li>\n<li>선택한 요소에 지정한 속성 값을 새로 생성하거나 변경합니다.</li>\n</ol>\n<ul>\n<li><p>removeAttr() 메서드</p>\n<ol>\n<li>$(“요소 선택”).revomeAttr(“속성”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 지정한 속성을 제거합니다.</li>\n</ol>\n<ul>\n<li><p>addClass() 메서드</p>\n<ol>\n<li>$(“요소 선택”).addClass(“클래스 값”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 새 클래스(class)를 생성합니다.</li>\n</ol>\n<ul>\n<li><p>removeClass() 메서드</p>\n<ol>\n<li>$(“요소 선택”).removeClass(“클래스 값”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 지정한 클래스를 삭제합니다.</li>\n</ol>\n<ul>\n<li><p>toggleClass() 메서드</p>\n<ol>\n<li>$(“요소 선택”).toggleClass(“클래스 값”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 지정한 클래스의 존재 여부에 따라<br>존재 하지않으면 생성하고, 존재 하면 삭제합니다.</li>\n</ol>\n<ul>\n<li><p>hasClass() 메서드</p>\n<ol>\n<li>$(“요소 선택”).hasClass(“클래스 값”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 지정한 클래스 존재 여부의 따라<br>존재할 시 true 아닐시 false를 반환합니다.</li>\n</ol>\n<ul>\n<li><p>val() 메서드</p>\n<ol>\n<li>$(“입력 요소 선택”).val();</li>\n<li>$(“입력 요소 선택”).val(“새 값”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 입력 요소의 value 속성 값을 가져옵니다.</li>\n<li>선택한 입력 요소의 value 속성에 새 값을 입력하거나 변경합니다.</li>\n</ol>\n<ul>\n<li><p>prop() 메서드</p>\n<ol>\n<li>$(“요소 선택”).prop(“속성”);</li>\n<li>$(“요소 선택”).prop(“속성”,”새 값”);</li>\n<li>$(“요소 선택”).prop(“[tagname | nodeType | selectedIndex]”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소의 속성 값을 반환합니다.</li>\n<li>선택한 요소에 새 속성과 새 값을 생성하거나 기존 속성을 변경합니다.</li>\n<li>선택한 요소에 태그명, 노드타입, 선택상자의 선택된 옵션의 인덱스를 반환합니다.</li>\n</ol>\n<hr>\n<h3 id=\"수치-조작-메서드\"><a href=\"#수치-조작-메서드\" class=\"headerlink\" title=\"수치 조작 메서드\"></a>수치 조작 메서드</h3><table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>height()</td>\n<td><strong>순수 요소</strong>의 높이 값 (margin,padding,border 제외)</td>\n</tr>\n<tr>\n<td>width()</td>\n<td><strong>순수 요소의</strong> 너비 값 (margin,padding,border 제외)</td>\n</tr>\n<tr>\n<td>innerHeight()</td>\n<td><strong>여백(padding)을 포함</strong>한 높이 값 (margin,border 제외)</td>\n</tr>\n<tr>\n<td>innerWidth()</td>\n<td><strong>여백(padding)을 포함</strong>한 너비 값 (margin,border 제외)</td>\n</tr>\n<tr>\n<td>outerHeight()</td>\n<td><strong>여백(padding)과 선(border) 포함</strong>한 높이 값 (margin제외)</td>\n</tr>\n<tr>\n<td>outerWidth()</td>\n<td><strong>여백(padding)과 선(border) 포함</strong>한 너비 값 (margin제외)</td>\n</tr>\n<tr>\n<td>position()</td>\n<td>선택한 기준 요소(position:relative)위치로 부터 (position:absolute) 위치 값을 반환합니다.</td>\n</tr>\n<tr>\n<td>offset()</td>\n<td>선택한 요소가 문서(document)에서 수평/수직으로 얼마나 떨어져 있는지 떨어져있는 값을 반환</td>\n</tr>\n<tr>\n<td>scrollLeft()</td>\n<td>브라우저 수평 스크롤 이동 높이 값 반환</td>\n</tr>\n<tr>\n<td>scrollTop()</td>\n<td>브라우저 수직 스크롤 이동 너비 값 반환</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"객체-편집-메서드\"><a href=\"#객체-편집-메서드\" class=\"headerlink\" title=\"객체 편집 메서드\"></a>객체 편집 메서드</h3><ul>\n<li><p>before() / after() 메서드</p>\n<ol>\n<li>$(“요소 선택”).before(새 요소);</li>\n<li>$(“요소 선택”).after(새 요소);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소의 이전 위치에 새 요소 생성</li>\n<li>선택한 요소의 다음 위치에 새 요소 생성</li>\n</ol>\n<ul>\n<li><p>append() / appendTo() / prepend() / prependTo() 메서드</p>\n<ol>\n<li><p>$(“요소 선택”).append(“새 요소”);<br>// 선택한 요소 내의 마지막 위치에 새 요소를 추가합니다.</p>\n</li>\n<li><p>$(“새 요소”).appendTo(“요소 선택”);<br>// 새 요소를 선택한 요소 내의 마지막 위치에 추가합니다.</p>\n</li>\n<li><p>$(“요소 선택”).prepend(“새 요소”);<br>// 선택한 요소 내의 앞 위치에 새 요소를 추가합니다.</p>\n</li>\n<li><p>$(“새 요소”).prependTo(“요소 선택”);<br>// 새 요소를 선택한 요소 내의 앞 위치에 추가합니다.</p>\n</li>\n</ol>\n</li>\n</ul>\n<p>to : ~을 ~에게<br>영어 뜻을 잘생각하여 사용해야 합니다.</p>\n<ul>\n<li><p>inserBefore() / inserAfter() / clone() 메서드</p>\n<ol>\n<li>$(“새 요소”).inserBefore(“요소 선택”);</li>\n<li>$(“새 요소”).inserAfter(“요소 선택”);</li>\n<li>$(“요소 선택”).clone(ture);</li>\n<li>$(“요소 선택”).clone(false);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소의 이전 위치에 새 요소를 생성합니다.</li>\n<li>선택한 요소의 다음 위치에 새 요소를 생성합니다.</li>\n<li>선택한 요소의 하위 요소까지 복제합니다. ()값 작성안할시 기본 true값 입니다.</li>\n<li>선택한 요소의 하위 요소를 제외하고 복제합니다.</li>\n</ol>\n<ul>\n<li><p>empty() / remove() 메서드</p>\n<ol>\n<li>$(“요소 선택”).empty();</li>\n<li>$(“요소 선택”).remove();</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소에 모든 하위 요소를 비웁니다.</li>\n<li>선택한 요소를 삭제 합니다.</li>\n</ol>\n<ul>\n<li><p>replaceAll() / replaceWith() 메서드</p>\n<ol>\n<li>$(“새 요소”).replaceAll(“요소 선택”);</li>\n<li>$(“요소 선택”).replaceWith(“새 요소”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>replaceAll() 메서드는 선택한 요소를 새 HTML 요소로 바꿉니다.</li>\n<li>replaceWith() 메서드는 선택한 요소를 새 내용으로 바꿉니다.</li>\n</ol>\n<ul>\n<li><p>unwrap() / wrap() / wrapAll() / wrapInner() 메서드</p>\n<ol>\n<li>$(“요소 선택”).unwrap();</li>\n<li>$(“요소 선택”).wrap(“새 요소”);</li>\n<li>$(“요소 선택”).wrapAll(“새 요소”);</li>\n<li>$(“요소 선택”).wrapInner(“새 요소”);</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>선택한 요소의 <strong>부모 요소를 삭제</strong>합니다.</li>\n<li>선택한 요소를 새 요소로 <strong>각각</strong> 감쌉니다.</li>\n<li>선택한 요소를 <strong>새 요소로 한꺼번에</strong> 감쌉니다.</li>\n<li>선택한 요소에 <strong>하위 요소를</strong> 새 요소로 감쌉니다.</li>\n</ol>\n<hr>\n<h3 id=\"jQuery선택자-정리-예제\"><a href=\"#jQuery선택자-정리-예제\" class=\"headerlink\" title=\"jQuery선택자 정리 예제\"></a>jQuery선택자 정리 예제</h3><figure class=\"highlight js\"><figcaption><span>style , body ex)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style type=<span class=\"string\">\"text/css\"</span>&gt;  </span><br><span class=\"line\"> div&#123;background-color:yellow;&#125;  </span><br><span class=\"line\"> .tit&#123;background-color:orange;&#125;  </span><br><span class=\"line\">&lt;<span class=\"regexp\">/style&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>head&gt;  </span><br><span class=\"line\">&lt;body&gt;  </span><br><span class=\"line\"> &lt;h1 align=<span class=\"string\">\"center\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">strong</span>&gt;</span>내용1<span class=\"tag\">&lt;/<span class=\"name\">strong</span>&gt;</span></span>&lt;<span class=\"regexp\">/h1&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;h2&gt;&lt;strong&gt;내용2&lt;/</span>strong&gt;&lt;<span class=\"regexp\">/h2&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;h2&gt;내용3&lt;/</span>h2&gt;  </span><br><span class=\"line\"> &lt;h2 <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"tit\"</span>&gt;내용<span class=\"number\">4</span>&lt;<span class=\"regexp\">/h2&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;ul class=\"myList\"&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;li&gt;리스트1&lt;/</span>li&gt;  </span><br><span class=\"line\"> &lt;li id=<span class=\"string\">\"two\"</span>&gt;리스트<span class=\"number\">2</span>&lt;<span class=\"regexp\">/li&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;li class=\"three\"&gt;리스트3&lt;/</span>li&gt;  </span><br><span class=\"line\"> &lt;li&gt;리스트<span class=\"number\">4</span>&lt;<span class=\"regexp\">/li&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;/u</span>l&gt;  </span><br><span class=\"line\">&lt;<span class=\"regexp\">/body&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>JavasSript-jQuery</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"경로/jQuery-버전.js\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script type=\"text/</span>javascript<span class=\"string\">\"&gt;  </span></span><br><span class=\"line\"><span class=\"string\">  </span></span><br><span class=\"line\"><span class=\"string\">$(function()&#123;  </span></span><br><span class=\"line\"><span class=\"string\"> $(\"</span>h1<span class=\"string\">\").attr(\"</span>align<span class=\"string\">\",\"</span>left<span class=\"string\">\");   </span></span><br><span class=\"line\"><span class=\"string\"> // h1 태그의 align 속성값을 left로 적용합니다  </span></span><br><span class=\"line\"><span class=\"string\"> $(\"</span>li:first<span class=\"string\">\").text(\"</span>첫 번째 리스트<span class=\"string\">\");  </span></span><br><span class=\"line\"><span class=\"string\"> // li 태그 첫 번째 요소의 텍스트를 \"</span>첫 번째 리스트<span class=\"string\">\"로 바꿉니다.  </span></span><br><span class=\"line\"><span class=\"string\"> $(\"</span>h2 &gt; strong<span class=\"string\">\").css(\"</span>color<span class=\"string\">\",\"</span>red<span class=\"string\">\");  </span></span><br><span class=\"line\"><span class=\"string\"> // h2 태그 안에 있는 strong 태그에 css적용하여 빨간색으로 적용합니다.  </span></span><br><span class=\"line\"> $(\"#two\").prev().css(\"color\",\"blue\");  </span><br><span class=\"line\"> <span class=\"comment\">// id값 two인 요소 이전 요소에 css적용하여 파란색으로 적용합니다.  </span></span><br><span class=\"line\"> $(<span class=\"string\">\"#two\"</span>).next().css(<span class=\"string\">\"color\"</span>,<span class=\"string\">\"purple\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">// id값 two인 요소 다음 요소에 css적용하여 보라색으로 적용합니다.  </span></span><br><span class=\"line\"> $(<span class=\"string\">\"#two\"</span>).parent().css(<span class=\"string\">\"border\"</span>,<span class=\"string\">\"2px dashed navy\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">// id값 two인 요소의 부모 요소를 선택하고 css로 border값, 속성을 적용합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> $(<span class=\"string\">\".myList\"</span>).prepend(<span class=\"string\">\"&lt;li&gt;Front&lt;/li&gt;\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//class명 myList 요소 내의 가장 앞 위치에 \"&lt;li&gt;Front&lt;/li&gt;\" 요소를 추가합니다.  </span></span><br><span class=\"line\"> $(<span class=\"string\">\".myList\"</span>).append(<span class=\"string\">\"&lt;li&gt;Back&lt;/li&gt;\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//class명 myList 요소 내의 마지막 위치에 \"&lt;li&gt;Back&lt;/li&gt;\" 요소를 추가합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> $(<span class=\"string\">\"&lt;li&gt;앞에 생성&lt;/li&gt;\"</span>).insertBefore(<span class=\"string\">\".three\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//\"&lt;li&gt;앞에 생성&lt;/li&gt;\"요소를 class명 \"three\"인 요소의 이전 위치에 생성합니다.  </span></span><br><span class=\"line\"> $(<span class=\"string\">\"&lt;li&gt;뒤에 생성&lt;/li&gt;\"</span>).insertAfter(<span class=\"string\">\".three\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//\"&lt;li&gt;뒤에 생성&lt;/li&gt;\"요소를 class명 \"three\"인 요소의 다음 위치에 생성합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> $(<span class=\"string\">\"h2\"</span>).eq(<span class=\"number\">1</span>).wrap(<span class=\"string\">\"&lt;div/&gt;\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//h2 태그중 인덱스(1) 즉 2번째 h2요소를 div 태그로 감쌉니다.  </span></span><br><span class=\"line\"> $(<span class=\"string\">\"h2:has('strong')\"</span>).addClass(<span class=\"string\">\"tit\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//strong 태그를 가지고 있는 h2태그에 class \"tit\"를 추가합니다.  </span></span><br><span class=\"line\"> $(<span class=\"string\">\"h2:last\"</span>).removeClass(<span class=\"string\">\"tit\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">//h2 태그중 마지막 요소에 class \"tit\"속성을 제거합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"Date(날짜) 객체 -JavaScript","date":"2020-03-01T23:45:52.000Z","disqusId":"tunas-blog-1","_content":"\n\n| 날짜 정보를 가져올 때 (GET)                                | 날짜 정보를 수정할 때 (SET)                                      |\n|------------------------------------------------------------|------------------------------------------------------------------|\n| getFullYear() 연도 정보를 가져옴                           | setFullYear() 연도 정보만 수정                                   |\n| getMonth() 월 정보를 가져옴(현재 월-1)                     | setMonth() 월 정보만 수정(월-1)                                  |\n| getDate() 일 정보를 가져옴                                 | setDate() 일 정보만 수정                                         |\n| getDay() 요일 정보를 가져옴(일:0~토:6)                     | 요일은 날자를 바꾸면 자동으로바뀌므로 setDate없음                |\n| getHours() 시 정보를 가져옴                                | setHours() 시 정보만 수정                                        |\n| getMinutes() 분 정보를 가져옴                              | setMinutes() 분 정보만 수정                                      |\n| getSeconds() 초 정보를 가져옴                              | setSeconds() 초 정보만 수정                                      |\n| getMilliseconds() 밀리초 정보를 가져옴                     | setMilliseconds() 밀리초 정보만 수정                             |\n| getTime() 1970년 1월1일부터 경과된 시간을 밀리초로 표기함  | setTime() 1970년 1월 1일부터 경과된 시간을 밀리초로 수정         |\n| toGMTString(); GMT 표준 표기 방식으로 문자형 데이터로 반환 | toLocaleString(); 운영 시스템 표기 방식으로 문자형 데이터로 반환 |\n\n<!-- more -->\n\n\n* * *\n\n### 날짜 정보 받아오기\n\n\n```js\nvar t =new Date(); // 변수 t에 오늘 날짜 객체 생성  \nvar nowMonth=t.getMonth(); // 현재 월 정보 반환하여, 현제 월보다 한달 적게나옴  \nvar nowDate=t.getDate(); // 현재 일자 정보 반환  \nvar nowDay=t.getDay(); // 현재 요일 정보 반환 (0:일요일 ~ 6:토요일)  \n\ndocument.write(\"현재 월:\"+nowMonth,\"<br />\");  \ndocument.write(\"현재 일:\"+nowDate,\"<br />\");  \ndocument.write(\"현재 요일:\"+nowDay,\"<br />\");  \n\nvar m=new Date(2002,5,31); // 변수 m에 특정 날짜 객체 생성 (월드컵)  \n\nvar theMonth=m.getMonth(); // 날짜 객체에서 월 정보만 가져옴  \nvar theDate=m.getDate(); // 날자 객체에서 일 정보만 가져옴  \nvar theDay=m.getDay(); // 날짜 객체에서 요일 정보만 가져옴  \n\ndocument.write(\"2002월드컵 몇 월:\"+theMonth,\"<br />\");  \ndocument.write(\"2002월드컵 몇 일:\"+theDate,\"<br />\");  \ndocument.write(\"2002월드컵 무슨 요일:\"+theDay,\"<br />\");  \n```\n\n* * *\n\n### 현재 날짜부터 특정 날짜까지 몇일 남았는지 구하기\n\n\n연말까지 얼마남았는지 구하기 예제\n\n```js\nvar t=new Date(); // 오늘 날짜 객체  \nvar nowYear=t.getFullYear(); // 현재 연도 정보를 받아옴  \n\n//현재 연도 12월 31일 날짜 객체를 생성  \nvar theDate=new Date(nowYear,11,31);  \n\n//연말까지 남은 기간(밀리초msc) = 연말 날짜 - 현재 날짜  \nvar diffDate=theDate-t  \n\n//밀리초를 일로 계산, 1일=86,400,000밀리초  \nvar result=Math.ceil(diffDate /(60 * 1000 * 60 * 24));  \n\n//결과 값 출력  \ndocument.write(\"현재일로 부터 올해 말일 까지는 \"+result+\"일 남았습니다.\");  \n```\n\n**남은일수(밀리 초)= 특정 날짜 객체 - 현재 날짜 객체**\n\n 1초 = 1000(msc)\n\n 1분(60초) = 1000 * (60)  // 60,000(msc)\n\n 1시간(60분) = 1000 * 60 * (60) // 3,600,000(msc)\n\n 1일(24시간) = 1000 * 60 * 60 * (24) // 86,400,000(msc)\n","source":"_posts/날짜 객체 메서드.md","raw":"---\ntitle: Date(날짜) 객체 -JavaScript\ndate: 2020-03-02 08:45:52\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\n\n| 날짜 정보를 가져올 때 (GET)                                | 날짜 정보를 수정할 때 (SET)                                      |\n|------------------------------------------------------------|------------------------------------------------------------------|\n| getFullYear() 연도 정보를 가져옴                           | setFullYear() 연도 정보만 수정                                   |\n| getMonth() 월 정보를 가져옴(현재 월-1)                     | setMonth() 월 정보만 수정(월-1)                                  |\n| getDate() 일 정보를 가져옴                                 | setDate() 일 정보만 수정                                         |\n| getDay() 요일 정보를 가져옴(일:0~토:6)                     | 요일은 날자를 바꾸면 자동으로바뀌므로 setDate없음                |\n| getHours() 시 정보를 가져옴                                | setHours() 시 정보만 수정                                        |\n| getMinutes() 분 정보를 가져옴                              | setMinutes() 분 정보만 수정                                      |\n| getSeconds() 초 정보를 가져옴                              | setSeconds() 초 정보만 수정                                      |\n| getMilliseconds() 밀리초 정보를 가져옴                     | setMilliseconds() 밀리초 정보만 수정                             |\n| getTime() 1970년 1월1일부터 경과된 시간을 밀리초로 표기함  | setTime() 1970년 1월 1일부터 경과된 시간을 밀리초로 수정         |\n| toGMTString(); GMT 표준 표기 방식으로 문자형 데이터로 반환 | toLocaleString(); 운영 시스템 표기 방식으로 문자형 데이터로 반환 |\n\n<!-- more -->\n\n\n* * *\n\n### 날짜 정보 받아오기\n\n\n```js\nvar t =new Date(); // 변수 t에 오늘 날짜 객체 생성  \nvar nowMonth=t.getMonth(); // 현재 월 정보 반환하여, 현제 월보다 한달 적게나옴  \nvar nowDate=t.getDate(); // 현재 일자 정보 반환  \nvar nowDay=t.getDay(); // 현재 요일 정보 반환 (0:일요일 ~ 6:토요일)  \n\ndocument.write(\"현재 월:\"+nowMonth,\"<br />\");  \ndocument.write(\"현재 일:\"+nowDate,\"<br />\");  \ndocument.write(\"현재 요일:\"+nowDay,\"<br />\");  \n\nvar m=new Date(2002,5,31); // 변수 m에 특정 날짜 객체 생성 (월드컵)  \n\nvar theMonth=m.getMonth(); // 날짜 객체에서 월 정보만 가져옴  \nvar theDate=m.getDate(); // 날자 객체에서 일 정보만 가져옴  \nvar theDay=m.getDay(); // 날짜 객체에서 요일 정보만 가져옴  \n\ndocument.write(\"2002월드컵 몇 월:\"+theMonth,\"<br />\");  \ndocument.write(\"2002월드컵 몇 일:\"+theDate,\"<br />\");  \ndocument.write(\"2002월드컵 무슨 요일:\"+theDay,\"<br />\");  \n```\n\n* * *\n\n### 현재 날짜부터 특정 날짜까지 몇일 남았는지 구하기\n\n\n연말까지 얼마남았는지 구하기 예제\n\n```js\nvar t=new Date(); // 오늘 날짜 객체  \nvar nowYear=t.getFullYear(); // 현재 연도 정보를 받아옴  \n\n//현재 연도 12월 31일 날짜 객체를 생성  \nvar theDate=new Date(nowYear,11,31);  \n\n//연말까지 남은 기간(밀리초msc) = 연말 날짜 - 현재 날짜  \nvar diffDate=theDate-t  \n\n//밀리초를 일로 계산, 1일=86,400,000밀리초  \nvar result=Math.ceil(diffDate /(60 * 1000 * 60 * 24));  \n\n//결과 값 출력  \ndocument.write(\"현재일로 부터 올해 말일 까지는 \"+result+\"일 남았습니다.\");  \n```\n\n**남은일수(밀리 초)= 특정 날짜 객체 - 현재 날짜 객체**\n\n 1초 = 1000(msc)\n\n 1분(60초) = 1000 * (60)  // 60,000(msc)\n\n 1시간(60분) = 1000 * 60 * (60) // 3,600,000(msc)\n\n 1일(24시간) = 1000 * 60 * 60 * (24) // 86,400,000(msc)\n","slug":"날짜 객체 메서드","published":1,"updated":"2020-04-26T08:05:21.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrta002sqgvqefwk1n1r","content":"<table>\n<thead>\n<tr>\n<th>날짜 정보를 가져올 때 (GET)</th>\n<th>날짜 정보를 수정할 때 (SET)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>getFullYear() 연도 정보를 가져옴</td>\n<td>setFullYear() 연도 정보만 수정</td>\n</tr>\n<tr>\n<td>getMonth() 월 정보를 가져옴(현재 월-1)</td>\n<td>setMonth() 월 정보만 수정(월-1)</td>\n</tr>\n<tr>\n<td>getDate() 일 정보를 가져옴</td>\n<td>setDate() 일 정보만 수정</td>\n</tr>\n<tr>\n<td>getDay() 요일 정보를 가져옴(일:0~토:6)</td>\n<td>요일은 날자를 바꾸면 자동으로바뀌므로 setDate없음</td>\n</tr>\n<tr>\n<td>getHours() 시 정보를 가져옴</td>\n<td>setHours() 시 정보만 수정</td>\n</tr>\n<tr>\n<td>getMinutes() 분 정보를 가져옴</td>\n<td>setMinutes() 분 정보만 수정</td>\n</tr>\n<tr>\n<td>getSeconds() 초 정보를 가져옴</td>\n<td>setSeconds() 초 정보만 수정</td>\n</tr>\n<tr>\n<td>getMilliseconds() 밀리초 정보를 가져옴</td>\n<td>setMilliseconds() 밀리초 정보만 수정</td>\n</tr>\n<tr>\n<td>getTime() 1970년 1월1일부터 경과된 시간을 밀리초로 표기함</td>\n<td>setTime() 1970년 1월 1일부터 경과된 시간을 밀리초로 수정</td>\n</tr>\n<tr>\n<td>toGMTString(); GMT 표준 표기 방식으로 문자형 데이터로 반환</td>\n<td>toLocaleString(); 운영 시스템 표기 방식으로 문자형 데이터로 반환</td>\n</tr>\n</tbody></table>\n<a id=\"more\"></a>\n\n\n<hr>\n<h3 id=\"날짜-정보-받아오기\"><a href=\"#날짜-정보-받아오기\" class=\"headerlink\" title=\"날짜 정보 받아오기\"></a>날짜 정보 받아오기</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> t =<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"comment\">// 변수 t에 오늘 날짜 객체 생성  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nowMonth=t.getMonth(); <span class=\"comment\">// 현재 월 정보 반환하여, 현제 월보다 한달 적게나옴  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nowDate=t.getDate(); <span class=\"comment\">// 현재 일자 정보 반환  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nowDay=t.getDay(); <span class=\"comment\">// 현재 요일 정보 반환 (0:일요일 ~ 6:토요일)  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"현재 월:\"</span>+nowMonth,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"현재 일:\"</span>+nowDate,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"현재 요일:\"</span>+nowDay,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> m=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">2002</span>,<span class=\"number\">5</span>,<span class=\"number\">31</span>); <span class=\"comment\">// 변수 m에 특정 날짜 객체 생성 (월드컵)  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> theMonth=m.getMonth(); <span class=\"comment\">// 날짜 객체에서 월 정보만 가져옴  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> theDate=m.getDate(); <span class=\"comment\">// 날자 객체에서 일 정보만 가져옴  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> theDay=m.getDay(); <span class=\"comment\">// 날짜 객체에서 요일 정보만 가져옴  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"2002월드컵 몇 월:\"</span>+theMonth,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"2002월드컵 몇 일:\"</span>+theDate,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"2002월드컵 무슨 요일:\"</span>+theDay,<span class=\"string\">\"&lt;br /&gt;\"</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"현재-날짜부터-특정-날짜까지-몇일-남았는지-구하기\"><a href=\"#현재-날짜부터-특정-날짜까지-몇일-남았는지-구하기\" class=\"headerlink\" title=\"현재 날짜부터 특정 날짜까지 몇일 남았는지 구하기\"></a>현재 날짜부터 특정 날짜까지 몇일 남았는지 구하기</h3><p>연말까지 얼마남았는지 구하기 예제</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> t=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"comment\">// 오늘 날짜 객체  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nowYear=t.getFullYear(); <span class=\"comment\">// 현재 연도 정보를 받아옴  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//현재 연도 12월 31일 날짜 객체를 생성  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> theDate=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(nowYear,<span class=\"number\">11</span>,<span class=\"number\">31</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//연말까지 남은 기간(밀리초msc) = 연말 날짜 - 현재 날짜  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> diffDate=theDate-t  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//밀리초를 일로 계산, 1일=86,400,000밀리초  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result=<span class=\"built_in\">Math</span>.ceil(diffDate /(<span class=\"number\">60</span> * <span class=\"number\">1000</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>));  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//결과 값 출력  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"현재일로 부터 올해 말일 까지는 \"</span>+result+<span class=\"string\">\"일 남았습니다.\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>남은일수(밀리 초)= 특정 날짜 객체 - 현재 날짜 객체</strong></p>\n<p> 1초 = 1000(msc)</p>\n<p> 1분(60초) = 1000 * (60)  // 60,000(msc)</p>\n<p> 1시간(60분) = 1000 * 60 * (60) // 3,600,000(msc)</p>\n<p> 1일(24시간) = 1000 * 60 * 60 * (24) // 86,400,000(msc)</p>\n","site":{"data":{}},"excerpt":"<table>\n<thead>\n<tr>\n<th>날짜 정보를 가져올 때 (GET)</th>\n<th>날짜 정보를 수정할 때 (SET)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>getFullYear() 연도 정보를 가져옴</td>\n<td>setFullYear() 연도 정보만 수정</td>\n</tr>\n<tr>\n<td>getMonth() 월 정보를 가져옴(현재 월-1)</td>\n<td>setMonth() 월 정보만 수정(월-1)</td>\n</tr>\n<tr>\n<td>getDate() 일 정보를 가져옴</td>\n<td>setDate() 일 정보만 수정</td>\n</tr>\n<tr>\n<td>getDay() 요일 정보를 가져옴(일:0~토:6)</td>\n<td>요일은 날자를 바꾸면 자동으로바뀌므로 setDate없음</td>\n</tr>\n<tr>\n<td>getHours() 시 정보를 가져옴</td>\n<td>setHours() 시 정보만 수정</td>\n</tr>\n<tr>\n<td>getMinutes() 분 정보를 가져옴</td>\n<td>setMinutes() 분 정보만 수정</td>\n</tr>\n<tr>\n<td>getSeconds() 초 정보를 가져옴</td>\n<td>setSeconds() 초 정보만 수정</td>\n</tr>\n<tr>\n<td>getMilliseconds() 밀리초 정보를 가져옴</td>\n<td>setMilliseconds() 밀리초 정보만 수정</td>\n</tr>\n<tr>\n<td>getTime() 1970년 1월1일부터 경과된 시간을 밀리초로 표기함</td>\n<td>setTime() 1970년 1월 1일부터 경과된 시간을 밀리초로 수정</td>\n</tr>\n<tr>\n<td>toGMTString(); GMT 표준 표기 방식으로 문자형 데이터로 반환</td>\n<td>toLocaleString(); 운영 시스템 표기 방식으로 문자형 데이터로 반환</td>\n</tr>\n</tbody></table>","more":"<hr>\n<h3 id=\"날짜-정보-받아오기\"><a href=\"#날짜-정보-받아오기\" class=\"headerlink\" title=\"날짜 정보 받아오기\"></a>날짜 정보 받아오기</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> t =<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"comment\">// 변수 t에 오늘 날짜 객체 생성  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nowMonth=t.getMonth(); <span class=\"comment\">// 현재 월 정보 반환하여, 현제 월보다 한달 적게나옴  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nowDate=t.getDate(); <span class=\"comment\">// 현재 일자 정보 반환  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nowDay=t.getDay(); <span class=\"comment\">// 현재 요일 정보 반환 (0:일요일 ~ 6:토요일)  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"현재 월:\"</span>+nowMonth,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"현재 일:\"</span>+nowDate,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"현재 요일:\"</span>+nowDay,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> m=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">2002</span>,<span class=\"number\">5</span>,<span class=\"number\">31</span>); <span class=\"comment\">// 변수 m에 특정 날짜 객체 생성 (월드컵)  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> theMonth=m.getMonth(); <span class=\"comment\">// 날짜 객체에서 월 정보만 가져옴  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> theDate=m.getDate(); <span class=\"comment\">// 날자 객체에서 일 정보만 가져옴  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> theDay=m.getDay(); <span class=\"comment\">// 날짜 객체에서 요일 정보만 가져옴  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"2002월드컵 몇 월:\"</span>+theMonth,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"2002월드컵 몇 일:\"</span>+theDate,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"2002월드컵 무슨 요일:\"</span>+theDay,<span class=\"string\">\"&lt;br /&gt;\"</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"현재-날짜부터-특정-날짜까지-몇일-남았는지-구하기\"><a href=\"#현재-날짜부터-특정-날짜까지-몇일-남았는지-구하기\" class=\"headerlink\" title=\"현재 날짜부터 특정 날짜까지 몇일 남았는지 구하기\"></a>현재 날짜부터 특정 날짜까지 몇일 남았는지 구하기</h3><p>연말까지 얼마남았는지 구하기 예제</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> t=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"comment\">// 오늘 날짜 객체  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nowYear=t.getFullYear(); <span class=\"comment\">// 현재 연도 정보를 받아옴  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//현재 연도 12월 31일 날짜 객체를 생성  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> theDate=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(nowYear,<span class=\"number\">11</span>,<span class=\"number\">31</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//연말까지 남은 기간(밀리초msc) = 연말 날짜 - 현재 날짜  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> diffDate=theDate-t  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//밀리초를 일로 계산, 1일=86,400,000밀리초  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result=<span class=\"built_in\">Math</span>.ceil(diffDate /(<span class=\"number\">60</span> * <span class=\"number\">1000</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>));  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//결과 값 출력  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"현재일로 부터 올해 말일 까지는 \"</span>+result+<span class=\"string\">\"일 남았습니다.\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>남은일수(밀리 초)= 특정 날짜 객체 - 현재 날짜 객체</strong></p>\n<p> 1초 = 1000(msc)</p>\n<p> 1분(60초) = 1000 * (60)  // 60,000(msc)</p>\n<p> 1시간(60분) = 1000 * 60 * (60) // 3,600,000(msc)</p>\n<p> 1일(24시간) = 1000 * 60 * 60 * (24) // 86,400,000(msc)</p>"},{"title":"데이터 타입 -Core JavaScript","date":"2020-04-16T00:00:39.000Z","disqusId":"tunas-blog-1","_content":"\n자바스크립트가 데이터를 처리하는 과정을 살펴봄으로써  \n기본형 타입과 참조형 타입이 서로 다르게 동작하는 이유를 이해하고  \n이를 적절히 활용할 수 있게 되는 것을 목표로 합니다.  \n나아가 데이터 타입과 관련된 중요한 개념 몇 가지를 추가로 살펴봅니다.\n\n*   [데이터 타입의 종류](/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_1)\n*   [데이터 타입에 관한 배경 지식](/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_2)\n    *   메모리와 데이터\n    *   식별자와 변수\n*   [변수 선언과 데이터 할당](/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_3)\n    *   변수 선언\n    *   데이터 할당\n*   [기본형 데이터와 참조형 데이터](/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_4)\n    *   불변값\n    *   가변값\n    *   변수 복사 비교\n*   [불변 객체](/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_5)\n    *   불변 객체를 만드는 간단한 방법\n    *   얕은 복사와 깊은 복사\n*   [undefined 와 null](/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_6)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"1_1\">데이터 타입의 종류</h2>\n\n자바스크립트의 데이터 타입에는 크게 두 가지가 있습니다. 바로 기본형과 참조형 입니다.\n\n*   **기본형**(원시형, `primitive type`)  \n    number, string, boolean, null, undefined, Symbol\n\n*   **참조형**(`reference type`)  \n    object, Array, Function, Date, RegExp, Map, WeakMap, Set, WeakSet 등이 객체의 하위 분류에 속합니다.\n\n<img src=\"/images/JavaScript-Data-Types.PNG\">\n\n[https://tutorial.eyehunts.com/js/javascript-data-types-and-examples](https://tutorial.eyehunts.com/js/javascript-data-types-and-examples)\n\n일반적으로 기본형은 할당이나 연산시 복제되고 참조형은 참조된다고 알려져 있습니다.  \n엄밀히 말하면 둘 모두 복제를 하긴 합니다.  \n다만 <u>기본형은 값이 담긴 주소값을 바로 복제하는 반면 참조형은 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제한다는 점이 다릅니다.</u>\n\n*   기본형은 `불변성(immutability)`을 뜁니다.  \n    ~~언뜻 생각해 보면 혼란스러울 수 있습니다.~~  \n    \n    불변성을 잘 이해하려면 메모리와 데이터에 대한 지식이 필요하고, 식별자와 변수의 개념을 구분할 수 있어야합니다.  \n    메모리 영역에서 자바스크립트의 데이터가 처리되는 과정을 알아봅시다.\n\n* * *\n\n<h2 id=\"1_2\">데이터 타입에 관한 배경 지식</h2>\n\n------\n### 메모리와 데이터\n\n컴퓨터는 모든 데이터를 `0 또는 1`로 기억합니다.  \n`0 또는 1`만 표현할 수 있는 하나의 메모리 조각을 `비트(bit)`라고 합니다. 각 비트는 고유한 식별자(`unique identifier`)를 통해 위치를 확인할 수 있습니다.\n\n1byte = 8 bit 입니다.\n\n메모리 용량이 과거보다 월등히 커진 영향으로 자바스크립트에서는 숫자의 경우 정수형인지 부동소수형인지 구분하지 않고 64비트 (8바이트)를 확보합니다.\n\n<mark>모든 데이터는 바이트 단위의 식별자, 즉 메모리 주소값(memory address)을 통해 서로 구분하고 연결할 수 있습니다.</mark>\n\n------\n### 식별자와 변수\n\n* **변수**는 “변할 수 있는 데이터” 입니다. (숫자,문자열,객체,배열 모두가 데이터 입니다.)\n\n* **식별자**는 어떤 데이터를 식별하는데 사용하는 이름. 즉 `변수명` 입니다.\n\n* * *\n\n<h2 id=\"1_3\">변수 선언과 데이터 할당</h2>\n\n------\n### 변수 선언\n\n변수 선언의 동작 원리를 알아봅니다.\n\n> var a;\n\n위 코드를 말로 해석하자면 **변할 수 있는 데이터를 만들고**, `식별자 이름을 a`로 설정합니다.\n\n즉, 엔진에서는 **메모리에서 비어있는 공간을 확보**하고 이 <u>메모리 영역의 이름(식별자)을 a</u>로 설정합니다.\n\n여기까지가 변수 선언 과정입니다. \n이후에 a에 접근하고자 하면 엔진은 메모리 영역에서 a라는 이름을 가진 주소를 검색해 해당 영역에 담긴 데이터를 반환합니다.\n\n------\n### 데이터 할당\n\n> var a = ‘abc’;\n\na라는 이름의 주소를 검색해서 그곳에 문자열 ‘abc’를 할당할 것 같지만,  \n실제로 <u>해당 위치에 문자열을 직접 저장하지는 않습니다.</u>\n\n엔진에서는 데이터를 저장하기 위한 **별도의 메모리 공간을 확보하여 문자열 ‘abc’를 저장**하고,  \n<mark>그 주소를 변수 영역에 저장하는 식으로 이뤄집니다.</mark>\n**메모리 공간**은 **변수영역** 과 **데이터 영역**을 <u>구분지어 값을 저장</u>한다고 생각하면 됩니다.\n\n*   데이터 할당과 변수 선언 흐름\n    \n```js\nvar a = 'abc';  \n// 위 코드는 아래 코드와 동일 합니다.  \nvar a;  \na = 'abc';  \n// 즉 엔진의 흐름은  \n1. 변수 영역에서 빈 공간을 확보하고  \n2. 확보한 공간의 식별자를 a로 지정합니다.  \n3. 변수 영역이 아닌 데이터 영역의 빈 공간에 문자열 'abc'를 저장합니다.  \n4. 변수 영역에서 a 식별자를 검색합니다.  \n5. 데이터 영역에서 생성한 문자열의 주소를   \n a 식별자로 검색한 변수 영역에 대입합니다.  \n```\n\n이러한 방식은 데이터를 변경(or 삭제/추가)등의 작업을 할때  \n변경된 데이터의 주소들을 다시 식별자에 연결하여 저장하지 않아도 됩니다.  \n(엔진이 처리할 연산을 최소한으로 해줍니다.)\n\n효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적입니다.\n\n예를 들어 다수의 변수를 생성하여 모든 변수에 숫자 5를 할당한다면,  \n변수의 개수만큼 변수의 메모리 공간마다 5를 할당해야 합니다.  \n하지만 5를 별도의 공간(메모리 공간 중 변수 영역이 아닌 데이터 영역)에 한 번만 저장하고 그 주소를 연결한다면? 엔진의 중복 연산 처리 효율이 높아집니다.\n\n* * *\n\n<h2 id=\"1_4\">기본형 데이터와 참조형 데이터</h2>\n\n------\n### 불변값\n\n변수 와 상수의 차이는 `“변경 가능성”`입니다. \n**변수**는 변할 수 있는 데이터, \n**상수**는 바뀌지 않습니다.  \n\n이 `“변경 가능성”`의 기준은 변수 영역의 메모리 입니다.  \n<mark>한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건입니다.</mark>\n\n반면 상수 와 불변값을 구분짓는 `“변경 가능성”`의 기준은 **데이터 영역 메모리** 입니다.\n\n```js\n1. var a = 'abc';  \na = a + 'def';  \n  \n2. var b = 5;  \nvar c = 5;  \n3. b = 7;  \n```\n\n1.  `변수 a` 에 문자열 `‘abc’`를 할당했다가 아래 코드로 `‘def’`를 추가하면  \n    기존의 `‘abc’`가 `‘abcdef’`로 바뀌는 것이 아니라 **새로운 문자열** `‘abcdef’`를 만들어  \n    **그 주소를 변수 a에 저장**합니다. `‘abc’`와 `‘abcdef’`는 **완전히 별개의 데이터** 입니다.\n\n\n2.  `변수 b` 에 데이터 영역을 만들어 **5를 설정하고 그 주소를 b에 저장**합니다.  \n    다음 코드에서 `c`에 5를 할당하려고 하면 **엔진은 데이터 영역에서 5를 찾습니다.**  \n    이미 만들어진 주소가 있으므로 그 주소를 **재활용하여 c에 저장**합니다.\n\n\n3. ` 변수 b` 의 값을 7로 바꾸려고 합니다. **기존에 저장된 5를 7로 바꾸는 것이 아니라**  \n    **데이터 영역에서 7을 찾아 있으면 그 주소를 재활용하고 없다면 새로 만들어 b에 저장합니다.**  \n    `결국 5 와 7 모두 다른 값으로 변경할 수 없습니다.`\n\n이처럼 문자열 값 과 숫자 값 모두 한 번 만든 값을 바꿀 수 없고, 다른 값으로 변경할 수 없습니다. 변경은 새로 만드는 동작을 통해서만 이뤄집니다. 한 번 만들어진 값은 `GC(Garbage Collection)` 당하지 않는 한 영원히 변하지 않습니다. 이것이 바로 **불변값의 특징**입니다.\n\n**기본형(원시값, `primitive`)데이터**인 number, string, boolean, null, undefined, Symbol은 모두 불변값입니다.\n\n------\n### 가변값\n\n**참조형(`reference`) 데이터**의 기본적인 성질은 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용하는 방법도 있습니다.\n\n참조형 데이터를 변수에 할당하는 과정부터 확인해 봅니다.\n\n```js 참조형 데이터의 할당\nvar obj1 ={  \n a: 1,  \n b: 'bbb'  \n};  \n```\n\n1.  엔진은 우선 변수 영역의 빈공간을 확보하고, 그 주소의 이름을 obj로 지정합니다.\n\n2.  {} 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 주소 이름으로 각각 a 와 b라는 프로퍼티 이름을 지정합니다.\n\n3.  데이터 영역에서 숫자 1을 검색합니다. 검색 결과가 없으므로 데이터 영역에 저장하고 이 주소를 a 주소에 저장합니다. 문자열 ‘bbb’역시 데이터 영역에 저장하고 이 주소를 b 주소에 저장합니다.\n\n<mark>기본형 데이터와의 차이는 “객체의 변수(프로퍼티) 영역”이 별도로 존재한다는 점입니다.</mark>  \n객체가 별도로 할애한 영역은 변수 영역일 뿐 “데이터 영역”은 기존의 메모리 공간을 그대로 활용하고 있습니다.  \n데이터 영역에 저장된 값은 모두 불변값입니다. 그러나 변수에는 얼마든지 다른 값을 대입할 수 있습니다.  \n바로 **이 부분 때문에 흔히 참조형(reference)데이터는 가변값이라고 하는 것**입니다.\n\n```js 참조형 데이터의 프로퍼티 재할당\nvar obj1 ={  \n a: 1,  \n b: 'bbb'  \n};  \nobj.a = 2;  \n```\n\n*   `obj1`의 `a` 프로퍼티에 숫자 `2`를 할당하려고 합니다. 데이터 영역에서 숫자 `2`를 검색합니다.  \n    존재하지 않으므로 데이터 영역을 새로만들어 `2`를 저장합니다. 이 주소를 프로퍼티 영역의 `a` 주소에 저장합니다.  \n    변수 `obj1`이 **바라보고 있는 주소는 데이터 영역으로 변하지 않았습니다. 즉 새로운 Object가 만들어진 것이 아니라** `Object` 내부의 프로퍼티 영역 `a`의 값만 바뀐 것 입니다.\n\n다음은 **참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우** 입니다.  \n이러한 경우를 `중첩객체(nested object)`라고 합니다.\n\n```js 중첩된 참조형 데이터(객체)의 프로퍼티 할당\nvar obj = {  \n x : 3,  \n arr : [ 3, 4, 5 ]  \n};  \n```\n\n1.  엔진은 우선 **변수 영역의 빈공간을 확보**하고, 그 주소의 이름을 `obj`로 지정합니다.\n\n\n2.  데이터 저장 공간에 데이터를 저장하려는데( {} ), 이 데이터는 여러개의 프로퍼티와 값들을 모아놓은 그룹(객체)입니다. **각 프로퍼티들을 저장하기 위해 별도의 프로퍼티 영역을 마련하고 그 주소를 {}의 주소에 저장합니다.**\n\n\n3.  각 프로퍼티 영역에 `x` 와 `arr` 를 주소 이름으로 지정합니다.\n\n\n4.  데이터 영역에서 숫자 `3`을 검색합니다. 없으므로 새로 만들고 이 주소를 프로퍼티 영역 x의 주소에 저장합니다.\n\n\n5.  데이터 영역에 `arr` 로 저장할 값은 `Array`로써 별도의 `Array` 영역을 만들어 저장하고 프로퍼티 영역 `arr`의 주소에 저장합니다.\n\n\n6.  배열의 요소가 총 `3`개 이므로 `Array` 영역에 공간을 확보하고 각각 **인덱스를 부여하고 주소이름으로 사용**합니다.\n\n\n7.  데이터 영역에서 숫자 `3`을 검색하여 그 주소를 `인덱스 0`의 주소에 저장합니다.\n\n\n8.  데이터 영역에 숫자 `4`가 없으므로 **새로운 데이터 영역을 만들고 그 주소를** `인덱스 1`의 주소에 저장합니다.\n\n\n9.  데이터 영역에 숫자 `5`도 없으므로 생성한 주소를 `인덱스 2`의 주소에 저장합니다.\n\n\n<mark>이제 obj.arr[1]을 검색하고자 하면 엔진의 메모리에서는 다음과 같은 과정을 거칩니다.</mark>\n\n    1. obj라는 식별자를 가진 주소를 찾습니다.\n    2. obj 주소에 연결된 데이터 영역의 주소로 이동합니다.\n    3. 데이터 영역에 연결된 프로퍼티 영역의 주소로 이동합니다.\n    4. 프로퍼티 영역에서 arr이라는 식별자를 가진 주소를 찾습니다.\n    5. arr 주소에 연결된 Array 영역의 주소로 이동합니다.\n    6. Array 영역에서 인덱스 1(==식별자 이름)을 검색하여 해당하는 주소로 이동합니다.\n    7. 해당하는 주소의 값 숫자형 데이터 4를 반환합니다.\n\n<mark>만약 이 상태에서 다음과 같이 재할당을 하면 다음과 같은 과정을 거칩니다.</mark>\n\n> obj.arr = “str”;\n\n데이터 영역에 문자열 `“str”`을 저장하고, 그 주소를 프로퍼티 영역에 저장합니다.(재할당)  \n\n그러면 기존에 있던 `Array` 영역의 인덱스 주소를 저장하던 데이터 영역(공간)은 자신의 주소를 참조하는 변수가 하나도 없게 됩니다. (프로퍼티 영역인 arr 주소의 값이 재할당 되므로 데이터 영역의 str을 주소로 갖음)  \n\n`참조 카운트`(자신을 참조하는 변수의 개수)가 `0`인 메모리는 `garbage collector`의 수거 대상이 됩니다.  \n\n즉, **Array 영역의 주소를 저장하던 데이터 영역은** `GC`의 수거 대상이며,  \n\n`GC`가 처리되는 과정에서 연쇄적으로 `Array` 영역의 `참조 카운트`도 `0`이 되고 `GC`의 대상이되어 제거됩니다.\n\n제거된 메모리 영역은 다시 새로운 값을 할당할 수 있는 빈 공간이 됩니다.\n\n------\n### 변수 복사 비교\n\n변수를 복사할 때  \n`기본형`(원시값, primitive) 데이터 와 `참조형`(reference) 데이터의 차이\n\n```js 변수 복사\n// primitive  \nvar a = 10;  \nvar b = a;   \n  \n// reference  \nvar obj1 = { c: 10, d: 'ddd' };  \nvar obj2 = obj1;  \n```\n\n1.  변수 영역의 빈 공간을 확보하고 `식별자를 a`로 지정합니다.  \n    `숫자 10`을 데이터 영역에서 검색하여, 없으면 데이터 영역에 새로 만들어 저장하고 주소를 `a`의 주소에 저장합니다.\n\n2.  변수 영역의 빈 공간을 확보하고 `식별자를 b`로 지정합니다. 그 후에 변수 영역에서 `a`식별자를 검색해 `a`에 저장된 데이터 주소(10)를 `b 변수 영역`에 저장합니다.\n\n3.  변수 영역의 빈 공간을 확보하고 식별자를 `obj1`로 지정합니다. 데이터 영역을 새로 만들고 데이터 그룹을 담을 프로퍼티 영역을 만들어 이 주소를 데이터 영역에 저장합니다.  \n    각각의 프로퍼티 영역에 식별자 이름으로 `c` , `d`으로 사용하고 각각의 값 `(10, ‘ddd’)`을 데이터 영역에서 검색합니다. `10`은 이미 있으므로 기존의 주소를 프로퍼티 영역에 연결하고, `‘ddd’`는 새로 만들어 프로퍼티 영역에 연결합니다.\n\n4.  변수 영역의 빈 공간을 확보하고 식별자를 `obj2`로 지정합니다. 그 후에 변수 영역에서 식별자 `obj1`을 검색해 `obj1`에 저장된 데이터 주소를 `obj2` 변수 영역에 저장합니다.\n\n<mark>변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일합니다. 복사 과정은 동일하지만 데이터 할당 과정에서 이미 차이가 있기 때문에 변수 복사 이후의 동작에서 큰 차이가 발생합니다.</mark>\n\n```js\n// 변수 복사이후 값 변경 결과 비교(1)  \n// object 프로퍼티 변경 시  \n  \n// primitive  \nvar a = 10;  \nvar b = a;   \n  \n// reference  \nvar obj1 = { c: 10, d: 'ddd' };  \nvar obj2 = obj1;  \n  \n// 프로퍼티 값 변경  \nb = 15;  \nobj2.c = 20;  \n```\n\n*   `b = 15` 코드는 데이터 영역에 `15`가 없으므로 새로운 데이터 영역에 저장하고 그 주소를 변수 영역 식별자 `b`인 주소에 저장합니다.\n\n*   `obj.c = 20` 코드는 데이터 영역에 `20`이 없으므르 새로운 데이터 영역에 저장하고 그 주소를 변수 영역 식별자 `obj2`의 주소를 찾고 이어서 `obj2`에 저장되있는 프로퍼티 영역의 `c`주소를 찾아 그 곳에 주소를 저장합니다.\n\n**기본형(원시값, primitive) 데이터를 복사한** `변수b`의 값을 바꾸면 `데이터영역 b 주소`의 값이 달라집니다.  \n\n**참조형(reference) 데이터를 복사한** `변수 obj2`의 프로퍼티 값을 바꾸면 바라보는 `obj2의 프로퍼티 주소`는 달라지지 않습니다. 값만 변합니다.\n\n즉, 변수 a와 b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1 과 obj2는 여전히 같은 객체를 바라보고 있는 상태입니다. (a !== b), (obj1 === obj2)\n\n<mark>이 결과가 바로 기본형과 참조형 데이터의 가장 큰 차이점 입니다.</mark> ~~대부분의 자바스크립트 책에서 ‘기본형은 값을 복사하고 참조형은 주솟값을 복사한다’고 설명하고 있지만, 사실은 어떤 데이터 타입이든 변수에 할당하기 위해서는 주솟값을 복사해야 하기 때문에~~ <mark>엄밀히 따지면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수 밖에 없습니다. 다만 기본형은 주솟값 복사 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이가 있는 것입니다.</mark>\n\n```js Object 자체를 변경 시\n// 변수 복사이후 값 변경 결과 비교(2)  \n// object 변경 시  \n  \n// primitive  \nvar a = 10;  \nvar b = a;   \n  \n// reference  \nvar obj1 = { c: 10, d: 'ddd' };  \nvar obj2 = obj1;  \n  \nb = 15;  \nobj2 = { c: 20, d: 'ddd' }; //object 자체를 변경  \n```\n\n*   obj2에도 새로운 객체를 할당함으로써 값을 직접 변경했습니다.  \n    데이터 영역에 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 주소에 저장하게 됩니다.  \n    즉, 기본형 데이터의 값 변경처럼 참조형 데이터가 바라보는 주소가 달라지게 되는 것입니다.  \n    <mark>따라서 참조형 데이터가 “가변값”이라고 설명할 때의 “가변”은 참조형 데이터 내부의 프로퍼티 값을 변경할 때의 성질입니다. 참조형 데이터 자체를 변경하는 경우는 성립되지 않습니다.</mark>\n\n* * *\n\n<h2 id=\"1_5\">불변 객체</h2>\n\n------\n### 불변 객체를 만드는 간단한 방법\n\n참조형 데이터의 “가변”은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때 성립되므로  \n내부 프로퍼티를 변경할 필요가 있을 때 마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하거나  \n자동으로 새로운 객체를 만드는 도구*를 활용하면 객체 역시 불변성을 확보할 수 있습니다.  \n<sub>*대표적으로 immutable.js, immer.js, immutability-helper 등의 라이브러리가 있고,  \nES6의 spread operator, Object.assign 메서드 등도 새로운 객체를 만드는 도구 목적으로 활용할 수 있습니다.</sub>\n\nex)값으로 전달받은 객체를 변경하더라도 원본 객체는 변하지 않게 하고 싶을 경우 불변 객체가 필요합니다.\n\n```js 가변성의 문제점\nvar user = {  \n name: 'Jaenam',  \n gender: 'male',  \n};  \n  \nvar changeName = function(user, newName) {  \n var newUser = user;  \n newUser.name = newName;  \n return newUser;  \n};  \n  \nvar user2 = changeName(user, 'Jung');  \n  \nif (user !== user2) {  \n console.log('유저 정보가 변경되었습니다.');  \n}  \nconsole.log(user.name, user2.name); // Jung Jung  \nconsole.log(user === user2); // true  \n```\n\n*   `user` 객체의 `name` 프로퍼티를 `‘Jung’`으로 바꾸는 함수를 호출해 반환 값을 `user2` 변수에 담습니다.  \n    그 결과 `user` 와 `user2`의 `name` 프로퍼티가 모두 `‘Jung’`으로 출력되고 (user === user2)가 true로 같다는 것을 알 수 있습니다.\n\n원본 데이터를 변경하고 싶지 않은 경우 각 변수마다 다른 객체를 바라보게 만들어야겠습니다.\n\n```js 서로 다른 객체를 바라보게\nvar user = {  \n name: 'Jaenam',  \n gender: 'male',  \n};  \n  \nvar changeName = function(user, newName) {\n    return {  \n        name: newName,  \n        gender: user.gender,  \n    };  \n};  \n  \nvar user2 = changeName(user, 'Jung');  \n  \nif (user !== user2) {  \n console.log('유저 정보가 변경되었습니다.'); // 유저 정보가 변경되었습니다.  \n}  \nconsole.log(user.name, user2.name); // Jaenam Jung  \nconsole.log(user === user2); // false  \n```\n\n*   changeName() 함수가 새로운 Object를 반환하도록 한 간단한 예시 입니다.  \n    user 와 user2는 서로 다른 Object가 됩니다.\n\n------\n### 얕은 복사와 깊은 복사\n\n얕은 복사(`shallow copy`)는 바로 아래 단계의 값만 복사하는 방법이고,\n깊은 복사(`deep copy`)는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법입니다.\n\n얕은 복사는 중접된 `object`에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사합니다.\n그러므로 해당 <u>프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터 주소</u>를 가리키게 됩니다.\n즉, <mark>얕은 복사는 사본을 바꾸면 원본도 바뀌고, 원본을 바꾸면 사본도 바뀝니다.</mark>\n\n```js 중첩된 객체에 대한 얕은 복사\n//복사해서 새로운 object를 반환하는 함수\nvar copyObject = function(target) {\n  var result = {};\n  for (var prop in target) {\n    result[prop] = target[prop];\n  }\n  return result;\n};\n\nvar user = {\n  name: 'Jaenam',\n  urls: {\n    portfolio: 'http://github.com/abc',\n    blog: 'http://blog.com',\n    facebook: 'http://facebook.com/abc',\n  },\n};\nvar user2 = copyObject(user);\n\n1. user2.name = 'Jung';\nconsole.log(user.name === user2.name); // false\n\n2. user.urls.portfolio = 'http://portfolio.com';\nconsole.log(user.urls.portfolio === user2.urls.portfolio); // true\n\n3. user2.urls.blog = '';\nconsole.log(user.urls.blog === user2.urls.blog); // true\n```\n\n1. 사본인 `user2`의 `name` 프로퍼티 값을 바꿔도 원본 `user`의 `name` 프로퍼티 값은 바뀌지 않습니다.\n\n2.  2번 과 3번 코드는 원본과 사본 어느 쪽을 바꾸더라도 다른 한쪽의 값 역시 바뀐 것을 확인할 수 있습니다.\n\n즉, `user` 객체에 직접 속한 프로퍼티에 대해서는 복사하여 새로운 데이터가 만들어진 반면,\n한 단계 더 들어간 `urls object`의 내부 프로퍼티들은 기존 데이터를 참조합니다.\n\n이런 현상을 막기 위해서는 한 단계 더 들어가는 프로퍼티들도 불변 객체로 만들 필요가 있습니다.\n\n```js 중첩된 객체에 대한 깊은 복사\n//복사해서 새로운 object를 반환하는 함수\nvar copyObject = function(target) {\n  var result = {};\n  for (var prop in target) {\n    result[prop] = target[prop];\n  }\n  return result;\n};\n\nvar user = {\n  name: 'Jaenam',\n  urls: {\n    portfolio: 'http://github.com/abc',\n    blog: 'http://blog.com',\n    facebook: 'http://facebook.com/abc',\n  },\n};\n\nvar user2 = copyObject(user);\n1. user2.urls = copyObject(user.urls);\n\nuser.urls.portfolio = 'http://portfolio.com';\nconsole.log(user.urls.portfolio === user2.urls.portfolio); // false\n\nuser2.urls.blog = '';\nconsole.log(user.urls.blog === user2.urls.blog); // false\n```\n\n1. 사본 `user2`의 `urls`프로퍼티에 `copyObject()` 함수를 실행하여 원본 `user`의 `urls`프로퍼티의 내부까지 복사하여 새로운 `object`를 만들어 할당했습니다. 그 결과 원본과 사본의 참조형 데이터 프로퍼티 값이 서로 다른 결과를 얻어냈습니다.\n\n------\n#### 정리\n\n정리하자면 <u>객체를 복사할 때 객체 내부의 모든 값을 복사하여 새로운 객체를 만들고자 할때</u>.\n객체의 프로퍼티가 <mark>기본형 데이터인 경우 그대로 복사하면 되지만,\n참조형 데이터는 내부의 프로퍼티들을 다시 복사하는 과정을 거쳐야 깊은 복사가 되는 것입니다.</mark>\n\n아래는 이 개념을 바탕으로 원본데이터를 깊은 복사 방식으로 새로운 객체를 반환하는 코드입니다.\n\n------\n#### 깊은 복사로 복사하는 방법\n\n```js 객체의 깊은 복사를 도와주는 범용 함수\nvar copyObjectDeep = function(target) {\n  var result = {};\n  /* target이 object인 경우 내부 프로퍼티들을 순회하여\n    copyObjectDeep 함수를 재귀적으로 호출합니다.*/\n  if (typeof target === 'object' && target !== null) {\n    for (var prop in target) {\n      result[prop] = copyObjectDeep(target[prop]);\n    }\n    //object가 아닌 경우 target을 그대로 지정합니다. \n  } else {\n    result = target;\n  }\n  return result;\n};\n```\n\n* `target === object` 뒤에 `target !== null` 조건이 붙은 이유는\ntypeof 메서드가 null 값에 대해 'object'를 반환하는 일종의 버그성? 때문입니다.\n\n* 이 함수를 사용해 객체를 복사하면 원본과 사본이 서로 다른 주소를 참조하게 되어 한 쪽의 프로퍼티를 변경하더라도 다른 한 쪽에 영향을 주지 않습니다.\n\n---------------\n\n객체를 JSON 문법으로 표현된 문자열로 변환했다가 다시 JSON객체로 바꾸는 방법도 있습니다.\n\n```js JSON을 이용한 간단한 깊은 복사\nvar copyObjectViaJSON = function(target) {\n  return JSON.parse(JSON.stringify(target));\n};\nvar obj = {\n  a: 1,\n  b: {\n    c: null,\n    d: [1, 2],\n    func1: function() {\n      console.log(3);\n    },\n  },\n  func2: function() {\n    console.log(4);\n  },\n};\nvar obj2 = copyObjectViaJSON(obj);\n\nobj2.a = 3;\nobj2.b.c = 4;\nobj.b.d[1] = 3;\n\nconsole.log(obj); // { a: 1. b: { c: null, d: [1, 3], func1: f() }, func2: f() }\nconsole.log(obj2); // { a: 3. b: { c: 4,    d: [1, 2] } }\n```\n\n이 방법은 단순하고 잘 동작합니다. 하지만 <mark>메서드(함수)나 숨겨진 프로퍼티인 &#95;&#95;proto&#95;&#95;나 getter/setter 등과 같이 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시됩니다.</mark>\n<u>httpReaquest로 받은 데이터를 저장한 object를 복사할 경우 등 순수한 정보만을 다루는 object 복사에 좋은 방법입니다.</u>\n\n* * *\n\n<h2 id=\"1_6\">undefined 와 null</h2>\n\n자바스크립트에 \"없음\"을 나타내는 두 값 `\"undefined\"` 와 `\"null\"`\n미세하게 다른 둘의 의미와 사용하는 목적을 살펴봅시다.\n\n------\n##### 자바스크립트는 다음과 같은 경우 엔진에서 undefined 값을 자동으로 부여합니다.\n\n1. 값을 대입하지 않은 변수,즉 데이터 영역에 메모리 주소를 지정하지 않은 식별자에 접근할 때\n\n2. 존재하지 않는 프로퍼티에 접근할 때\n\n3. return 문이 없거나 호출되지 않는 함수의 실행 결과\n\n```js 엔진에서 undefined를 부여하는 경우 예시\nvar a;\nconsole.log(a); // (1) undefined. 값을 대입하지 않은 변수에 접근\n                // a 는 데이터 영역의 메모리 주소가 지정되지 않은 식별자\n\nvar obj = { a: 1 };\nconsole.log(obj.a); // 1\nconsole.log(obj.b); // (2) 존재하지 않는 프로퍼티에 접근\nconsole.log(b); // c.f) ReferenceError: b is not defined\n\nvar func = function() {};\nvar c = func(); // (3) 반환(return)값이 없으면 undefined를 반환한 것으로 간주.\nconsole.log(c); // undefined\n```\n\n------\n##### 값을 대입하지 않은 변수가 빈 배열일 경우 \n\n값을 대입하지 않은 변수가 빈 배열일 경우 특이한 결과를 확인할 수 있습니다.\n\n```js undefined 와 빈 배열\n1. var arr1 = [];\narr1.length = 3;\nconsole.log(arr1); // [empty x 3]\n\n2. var arr2 = new Array(3);\nconsole.log(arr2); // [empty x 3]\n\n3. var arr3 = [undefined, undefined, undefined];\nconsole.log(arr3); // [undefined, undefined, undefined]\n```\n\n1. 빈 배열을 만들고 배열의 length 값을 3으로 지정하고 console에 찍으니 `[empty x 3]`이 출력됩니다.\n이는 배열에 3개의 빈 배열 요소를 확보했지만 확보된 요소에 어떤 값도 할당되어 있지 않음을 의미합니다.\n(undefined 조차 할당되어 있지 않습니다.)\n\n\n2. new 연산자를 사용해 Array 생성자 함수를 호출하고 length 값을 3으로 지정했습니다. 위에 1번과 같은 결과를 갖습니다.\n\n\n3. 배열을 만들고 각 요소에 undefined 값을 지정했습니다. 출력시 `[undefined, undefined, undefined]`가 출력됩니다.\n\n    ![undefined 와 null](/images/Array_empty.JPG)\n\n이처럼 \"비어있는 요소\"(`empty`)와 \"`undefined`를 할당한 요소는\" 출력 결과부터 다릅니다.\n> empty !=== undefined\n\n`\"비어있는 요소\"`는 이터러블과 관련된 많은 배열 메서드들의 대상에서 제외됩니다.\n\n사실은 `Array`도 `object`임을 생각해보면 자연스러운 현상입니다.\n\n존재하지 않는 프로퍼티를 이터러블 메서드로 순회할 수 없는 것이 당연합니다.\n\n~~배열은 length 프로퍼티의 개수만큼 빈 공간을 확보하고 각각의 인덱스를 이름으로 지정할 것이라고 생각할 수 있지만,~~\n\n<mark>실제로는 object와 마찬가지로 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 동작을 합니다.</mark>\n\n즉, 값이 지정되지 않은 인덱스는 프로퍼티값이 지정되지 않은 빈 공간입니다.\n\n위 처럼 `undefined`는 엔진이 부여하는 경우와 사용자가 값으로 할당한 실존하는 데이터인 경우로 나뉠수 있습니다.\n이러한 방식은 혼란을 가져올 수 있습니다. \n사용자가 \"비어 있음\"을 나타내고 싶어 할당한 값과, 엔진이 부여하는 \"해당 값이 없음\"\n이 두가지를 확실히 구분하기 위해 사용하는 것이 바로 `null` 입니다.\n\n------\n##### null 사용 뜻\n\n사용자가 `\"비어있음\"`을 뜻하는 용도로 사용하고 싶을 때는 `null`을 사용하도록 합니다.\n`null`을 이런 용도에 사용하는 규칙을 지킨다면, `undefined`가 **\"값을 대입하지 않은 변수에 접근할 때\" 엔진이 반환해 주는 값으로만 존재할 수 있습니다.**\n\n~~애초에 null이 이런 용도로 만들어진 데이터 타입입니다.~~","source":"_posts/데이터 타입 -Core JavaScript.md","raw":"---\ntitle: 데이터 타입 -Core JavaScript\ndate: 2020-04-16 09:00:39\ndisqusId: tunas-blog-1\ncategories: Core JavaScript\ntag: \n- Core JavaScript\n- JavaScript\n---\n\n자바스크립트가 데이터를 처리하는 과정을 살펴봄으로써  \n기본형 타입과 참조형 타입이 서로 다르게 동작하는 이유를 이해하고  \n이를 적절히 활용할 수 있게 되는 것을 목표로 합니다.  \n나아가 데이터 타입과 관련된 중요한 개념 몇 가지를 추가로 살펴봅니다.\n\n*   [데이터 타입의 종류](/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_1)\n*   [데이터 타입에 관한 배경 지식](/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_2)\n    *   메모리와 데이터\n    *   식별자와 변수\n*   [변수 선언과 데이터 할당](/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_3)\n    *   변수 선언\n    *   데이터 할당\n*   [기본형 데이터와 참조형 데이터](/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_4)\n    *   불변값\n    *   가변값\n    *   변수 복사 비교\n*   [불변 객체](/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_5)\n    *   불변 객체를 만드는 간단한 방법\n    *   얕은 복사와 깊은 복사\n*   [undefined 와 null](/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_6)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"1_1\">데이터 타입의 종류</h2>\n\n자바스크립트의 데이터 타입에는 크게 두 가지가 있습니다. 바로 기본형과 참조형 입니다.\n\n*   **기본형**(원시형, `primitive type`)  \n    number, string, boolean, null, undefined, Symbol\n\n*   **참조형**(`reference type`)  \n    object, Array, Function, Date, RegExp, Map, WeakMap, Set, WeakSet 등이 객체의 하위 분류에 속합니다.\n\n<img src=\"/images/JavaScript-Data-Types.PNG\">\n\n[https://tutorial.eyehunts.com/js/javascript-data-types-and-examples](https://tutorial.eyehunts.com/js/javascript-data-types-and-examples)\n\n일반적으로 기본형은 할당이나 연산시 복제되고 참조형은 참조된다고 알려져 있습니다.  \n엄밀히 말하면 둘 모두 복제를 하긴 합니다.  \n다만 <u>기본형은 값이 담긴 주소값을 바로 복제하는 반면 참조형은 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제한다는 점이 다릅니다.</u>\n\n*   기본형은 `불변성(immutability)`을 뜁니다.  \n    ~~언뜻 생각해 보면 혼란스러울 수 있습니다.~~  \n    \n    불변성을 잘 이해하려면 메모리와 데이터에 대한 지식이 필요하고, 식별자와 변수의 개념을 구분할 수 있어야합니다.  \n    메모리 영역에서 자바스크립트의 데이터가 처리되는 과정을 알아봅시다.\n\n* * *\n\n<h2 id=\"1_2\">데이터 타입에 관한 배경 지식</h2>\n\n------\n### 메모리와 데이터\n\n컴퓨터는 모든 데이터를 `0 또는 1`로 기억합니다.  \n`0 또는 1`만 표현할 수 있는 하나의 메모리 조각을 `비트(bit)`라고 합니다. 각 비트는 고유한 식별자(`unique identifier`)를 통해 위치를 확인할 수 있습니다.\n\n1byte = 8 bit 입니다.\n\n메모리 용량이 과거보다 월등히 커진 영향으로 자바스크립트에서는 숫자의 경우 정수형인지 부동소수형인지 구분하지 않고 64비트 (8바이트)를 확보합니다.\n\n<mark>모든 데이터는 바이트 단위의 식별자, 즉 메모리 주소값(memory address)을 통해 서로 구분하고 연결할 수 있습니다.</mark>\n\n------\n### 식별자와 변수\n\n* **변수**는 “변할 수 있는 데이터” 입니다. (숫자,문자열,객체,배열 모두가 데이터 입니다.)\n\n* **식별자**는 어떤 데이터를 식별하는데 사용하는 이름. 즉 `변수명` 입니다.\n\n* * *\n\n<h2 id=\"1_3\">변수 선언과 데이터 할당</h2>\n\n------\n### 변수 선언\n\n변수 선언의 동작 원리를 알아봅니다.\n\n> var a;\n\n위 코드를 말로 해석하자면 **변할 수 있는 데이터를 만들고**, `식별자 이름을 a`로 설정합니다.\n\n즉, 엔진에서는 **메모리에서 비어있는 공간을 확보**하고 이 <u>메모리 영역의 이름(식별자)을 a</u>로 설정합니다.\n\n여기까지가 변수 선언 과정입니다. \n이후에 a에 접근하고자 하면 엔진은 메모리 영역에서 a라는 이름을 가진 주소를 검색해 해당 영역에 담긴 데이터를 반환합니다.\n\n------\n### 데이터 할당\n\n> var a = ‘abc’;\n\na라는 이름의 주소를 검색해서 그곳에 문자열 ‘abc’를 할당할 것 같지만,  \n실제로 <u>해당 위치에 문자열을 직접 저장하지는 않습니다.</u>\n\n엔진에서는 데이터를 저장하기 위한 **별도의 메모리 공간을 확보하여 문자열 ‘abc’를 저장**하고,  \n<mark>그 주소를 변수 영역에 저장하는 식으로 이뤄집니다.</mark>\n**메모리 공간**은 **변수영역** 과 **데이터 영역**을 <u>구분지어 값을 저장</u>한다고 생각하면 됩니다.\n\n*   데이터 할당과 변수 선언 흐름\n    \n```js\nvar a = 'abc';  \n// 위 코드는 아래 코드와 동일 합니다.  \nvar a;  \na = 'abc';  \n// 즉 엔진의 흐름은  \n1. 변수 영역에서 빈 공간을 확보하고  \n2. 확보한 공간의 식별자를 a로 지정합니다.  \n3. 변수 영역이 아닌 데이터 영역의 빈 공간에 문자열 'abc'를 저장합니다.  \n4. 변수 영역에서 a 식별자를 검색합니다.  \n5. 데이터 영역에서 생성한 문자열의 주소를   \n a 식별자로 검색한 변수 영역에 대입합니다.  \n```\n\n이러한 방식은 데이터를 변경(or 삭제/추가)등의 작업을 할때  \n변경된 데이터의 주소들을 다시 식별자에 연결하여 저장하지 않아도 됩니다.  \n(엔진이 처리할 연산을 최소한으로 해줍니다.)\n\n효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적입니다.\n\n예를 들어 다수의 변수를 생성하여 모든 변수에 숫자 5를 할당한다면,  \n변수의 개수만큼 변수의 메모리 공간마다 5를 할당해야 합니다.  \n하지만 5를 별도의 공간(메모리 공간 중 변수 영역이 아닌 데이터 영역)에 한 번만 저장하고 그 주소를 연결한다면? 엔진의 중복 연산 처리 효율이 높아집니다.\n\n* * *\n\n<h2 id=\"1_4\">기본형 데이터와 참조형 데이터</h2>\n\n------\n### 불변값\n\n변수 와 상수의 차이는 `“변경 가능성”`입니다. \n**변수**는 변할 수 있는 데이터, \n**상수**는 바뀌지 않습니다.  \n\n이 `“변경 가능성”`의 기준은 변수 영역의 메모리 입니다.  \n<mark>한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건입니다.</mark>\n\n반면 상수 와 불변값을 구분짓는 `“변경 가능성”`의 기준은 **데이터 영역 메모리** 입니다.\n\n```js\n1. var a = 'abc';  \na = a + 'def';  \n  \n2. var b = 5;  \nvar c = 5;  \n3. b = 7;  \n```\n\n1.  `변수 a` 에 문자열 `‘abc’`를 할당했다가 아래 코드로 `‘def’`를 추가하면  \n    기존의 `‘abc’`가 `‘abcdef’`로 바뀌는 것이 아니라 **새로운 문자열** `‘abcdef’`를 만들어  \n    **그 주소를 변수 a에 저장**합니다. `‘abc’`와 `‘abcdef’`는 **완전히 별개의 데이터** 입니다.\n\n\n2.  `변수 b` 에 데이터 영역을 만들어 **5를 설정하고 그 주소를 b에 저장**합니다.  \n    다음 코드에서 `c`에 5를 할당하려고 하면 **엔진은 데이터 영역에서 5를 찾습니다.**  \n    이미 만들어진 주소가 있으므로 그 주소를 **재활용하여 c에 저장**합니다.\n\n\n3. ` 변수 b` 의 값을 7로 바꾸려고 합니다. **기존에 저장된 5를 7로 바꾸는 것이 아니라**  \n    **데이터 영역에서 7을 찾아 있으면 그 주소를 재활용하고 없다면 새로 만들어 b에 저장합니다.**  \n    `결국 5 와 7 모두 다른 값으로 변경할 수 없습니다.`\n\n이처럼 문자열 값 과 숫자 값 모두 한 번 만든 값을 바꿀 수 없고, 다른 값으로 변경할 수 없습니다. 변경은 새로 만드는 동작을 통해서만 이뤄집니다. 한 번 만들어진 값은 `GC(Garbage Collection)` 당하지 않는 한 영원히 변하지 않습니다. 이것이 바로 **불변값의 특징**입니다.\n\n**기본형(원시값, `primitive`)데이터**인 number, string, boolean, null, undefined, Symbol은 모두 불변값입니다.\n\n------\n### 가변값\n\n**참조형(`reference`) 데이터**의 기본적인 성질은 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용하는 방법도 있습니다.\n\n참조형 데이터를 변수에 할당하는 과정부터 확인해 봅니다.\n\n```js 참조형 데이터의 할당\nvar obj1 ={  \n a: 1,  \n b: 'bbb'  \n};  \n```\n\n1.  엔진은 우선 변수 영역의 빈공간을 확보하고, 그 주소의 이름을 obj로 지정합니다.\n\n2.  {} 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 주소 이름으로 각각 a 와 b라는 프로퍼티 이름을 지정합니다.\n\n3.  데이터 영역에서 숫자 1을 검색합니다. 검색 결과가 없으므로 데이터 영역에 저장하고 이 주소를 a 주소에 저장합니다. 문자열 ‘bbb’역시 데이터 영역에 저장하고 이 주소를 b 주소에 저장합니다.\n\n<mark>기본형 데이터와의 차이는 “객체의 변수(프로퍼티) 영역”이 별도로 존재한다는 점입니다.</mark>  \n객체가 별도로 할애한 영역은 변수 영역일 뿐 “데이터 영역”은 기존의 메모리 공간을 그대로 활용하고 있습니다.  \n데이터 영역에 저장된 값은 모두 불변값입니다. 그러나 변수에는 얼마든지 다른 값을 대입할 수 있습니다.  \n바로 **이 부분 때문에 흔히 참조형(reference)데이터는 가변값이라고 하는 것**입니다.\n\n```js 참조형 데이터의 프로퍼티 재할당\nvar obj1 ={  \n a: 1,  \n b: 'bbb'  \n};  \nobj.a = 2;  \n```\n\n*   `obj1`의 `a` 프로퍼티에 숫자 `2`를 할당하려고 합니다. 데이터 영역에서 숫자 `2`를 검색합니다.  \n    존재하지 않으므로 데이터 영역을 새로만들어 `2`를 저장합니다. 이 주소를 프로퍼티 영역의 `a` 주소에 저장합니다.  \n    변수 `obj1`이 **바라보고 있는 주소는 데이터 영역으로 변하지 않았습니다. 즉 새로운 Object가 만들어진 것이 아니라** `Object` 내부의 프로퍼티 영역 `a`의 값만 바뀐 것 입니다.\n\n다음은 **참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우** 입니다.  \n이러한 경우를 `중첩객체(nested object)`라고 합니다.\n\n```js 중첩된 참조형 데이터(객체)의 프로퍼티 할당\nvar obj = {  \n x : 3,  \n arr : [ 3, 4, 5 ]  \n};  \n```\n\n1.  엔진은 우선 **변수 영역의 빈공간을 확보**하고, 그 주소의 이름을 `obj`로 지정합니다.\n\n\n2.  데이터 저장 공간에 데이터를 저장하려는데( {} ), 이 데이터는 여러개의 프로퍼티와 값들을 모아놓은 그룹(객체)입니다. **각 프로퍼티들을 저장하기 위해 별도의 프로퍼티 영역을 마련하고 그 주소를 {}의 주소에 저장합니다.**\n\n\n3.  각 프로퍼티 영역에 `x` 와 `arr` 를 주소 이름으로 지정합니다.\n\n\n4.  데이터 영역에서 숫자 `3`을 검색합니다. 없으므로 새로 만들고 이 주소를 프로퍼티 영역 x의 주소에 저장합니다.\n\n\n5.  데이터 영역에 `arr` 로 저장할 값은 `Array`로써 별도의 `Array` 영역을 만들어 저장하고 프로퍼티 영역 `arr`의 주소에 저장합니다.\n\n\n6.  배열의 요소가 총 `3`개 이므로 `Array` 영역에 공간을 확보하고 각각 **인덱스를 부여하고 주소이름으로 사용**합니다.\n\n\n7.  데이터 영역에서 숫자 `3`을 검색하여 그 주소를 `인덱스 0`의 주소에 저장합니다.\n\n\n8.  데이터 영역에 숫자 `4`가 없으므로 **새로운 데이터 영역을 만들고 그 주소를** `인덱스 1`의 주소에 저장합니다.\n\n\n9.  데이터 영역에 숫자 `5`도 없으므로 생성한 주소를 `인덱스 2`의 주소에 저장합니다.\n\n\n<mark>이제 obj.arr[1]을 검색하고자 하면 엔진의 메모리에서는 다음과 같은 과정을 거칩니다.</mark>\n\n    1. obj라는 식별자를 가진 주소를 찾습니다.\n    2. obj 주소에 연결된 데이터 영역의 주소로 이동합니다.\n    3. 데이터 영역에 연결된 프로퍼티 영역의 주소로 이동합니다.\n    4. 프로퍼티 영역에서 arr이라는 식별자를 가진 주소를 찾습니다.\n    5. arr 주소에 연결된 Array 영역의 주소로 이동합니다.\n    6. Array 영역에서 인덱스 1(==식별자 이름)을 검색하여 해당하는 주소로 이동합니다.\n    7. 해당하는 주소의 값 숫자형 데이터 4를 반환합니다.\n\n<mark>만약 이 상태에서 다음과 같이 재할당을 하면 다음과 같은 과정을 거칩니다.</mark>\n\n> obj.arr = “str”;\n\n데이터 영역에 문자열 `“str”`을 저장하고, 그 주소를 프로퍼티 영역에 저장합니다.(재할당)  \n\n그러면 기존에 있던 `Array` 영역의 인덱스 주소를 저장하던 데이터 영역(공간)은 자신의 주소를 참조하는 변수가 하나도 없게 됩니다. (프로퍼티 영역인 arr 주소의 값이 재할당 되므로 데이터 영역의 str을 주소로 갖음)  \n\n`참조 카운트`(자신을 참조하는 변수의 개수)가 `0`인 메모리는 `garbage collector`의 수거 대상이 됩니다.  \n\n즉, **Array 영역의 주소를 저장하던 데이터 영역은** `GC`의 수거 대상이며,  \n\n`GC`가 처리되는 과정에서 연쇄적으로 `Array` 영역의 `참조 카운트`도 `0`이 되고 `GC`의 대상이되어 제거됩니다.\n\n제거된 메모리 영역은 다시 새로운 값을 할당할 수 있는 빈 공간이 됩니다.\n\n------\n### 변수 복사 비교\n\n변수를 복사할 때  \n`기본형`(원시값, primitive) 데이터 와 `참조형`(reference) 데이터의 차이\n\n```js 변수 복사\n// primitive  \nvar a = 10;  \nvar b = a;   \n  \n// reference  \nvar obj1 = { c: 10, d: 'ddd' };  \nvar obj2 = obj1;  \n```\n\n1.  변수 영역의 빈 공간을 확보하고 `식별자를 a`로 지정합니다.  \n    `숫자 10`을 데이터 영역에서 검색하여, 없으면 데이터 영역에 새로 만들어 저장하고 주소를 `a`의 주소에 저장합니다.\n\n2.  변수 영역의 빈 공간을 확보하고 `식별자를 b`로 지정합니다. 그 후에 변수 영역에서 `a`식별자를 검색해 `a`에 저장된 데이터 주소(10)를 `b 변수 영역`에 저장합니다.\n\n3.  변수 영역의 빈 공간을 확보하고 식별자를 `obj1`로 지정합니다. 데이터 영역을 새로 만들고 데이터 그룹을 담을 프로퍼티 영역을 만들어 이 주소를 데이터 영역에 저장합니다.  \n    각각의 프로퍼티 영역에 식별자 이름으로 `c` , `d`으로 사용하고 각각의 값 `(10, ‘ddd’)`을 데이터 영역에서 검색합니다. `10`은 이미 있으므로 기존의 주소를 프로퍼티 영역에 연결하고, `‘ddd’`는 새로 만들어 프로퍼티 영역에 연결합니다.\n\n4.  변수 영역의 빈 공간을 확보하고 식별자를 `obj2`로 지정합니다. 그 후에 변수 영역에서 식별자 `obj1`을 검색해 `obj1`에 저장된 데이터 주소를 `obj2` 변수 영역에 저장합니다.\n\n<mark>변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일합니다. 복사 과정은 동일하지만 데이터 할당 과정에서 이미 차이가 있기 때문에 변수 복사 이후의 동작에서 큰 차이가 발생합니다.</mark>\n\n```js\n// 변수 복사이후 값 변경 결과 비교(1)  \n// object 프로퍼티 변경 시  \n  \n// primitive  \nvar a = 10;  \nvar b = a;   \n  \n// reference  \nvar obj1 = { c: 10, d: 'ddd' };  \nvar obj2 = obj1;  \n  \n// 프로퍼티 값 변경  \nb = 15;  \nobj2.c = 20;  \n```\n\n*   `b = 15` 코드는 데이터 영역에 `15`가 없으므로 새로운 데이터 영역에 저장하고 그 주소를 변수 영역 식별자 `b`인 주소에 저장합니다.\n\n*   `obj.c = 20` 코드는 데이터 영역에 `20`이 없으므르 새로운 데이터 영역에 저장하고 그 주소를 변수 영역 식별자 `obj2`의 주소를 찾고 이어서 `obj2`에 저장되있는 프로퍼티 영역의 `c`주소를 찾아 그 곳에 주소를 저장합니다.\n\n**기본형(원시값, primitive) 데이터를 복사한** `변수b`의 값을 바꾸면 `데이터영역 b 주소`의 값이 달라집니다.  \n\n**참조형(reference) 데이터를 복사한** `변수 obj2`의 프로퍼티 값을 바꾸면 바라보는 `obj2의 프로퍼티 주소`는 달라지지 않습니다. 값만 변합니다.\n\n즉, 변수 a와 b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1 과 obj2는 여전히 같은 객체를 바라보고 있는 상태입니다. (a !== b), (obj1 === obj2)\n\n<mark>이 결과가 바로 기본형과 참조형 데이터의 가장 큰 차이점 입니다.</mark> ~~대부분의 자바스크립트 책에서 ‘기본형은 값을 복사하고 참조형은 주솟값을 복사한다’고 설명하고 있지만, 사실은 어떤 데이터 타입이든 변수에 할당하기 위해서는 주솟값을 복사해야 하기 때문에~~ <mark>엄밀히 따지면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수 밖에 없습니다. 다만 기본형은 주솟값 복사 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이가 있는 것입니다.</mark>\n\n```js Object 자체를 변경 시\n// 변수 복사이후 값 변경 결과 비교(2)  \n// object 변경 시  \n  \n// primitive  \nvar a = 10;  \nvar b = a;   \n  \n// reference  \nvar obj1 = { c: 10, d: 'ddd' };  \nvar obj2 = obj1;  \n  \nb = 15;  \nobj2 = { c: 20, d: 'ddd' }; //object 자체를 변경  \n```\n\n*   obj2에도 새로운 객체를 할당함으로써 값을 직접 변경했습니다.  \n    데이터 영역에 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 주소에 저장하게 됩니다.  \n    즉, 기본형 데이터의 값 변경처럼 참조형 데이터가 바라보는 주소가 달라지게 되는 것입니다.  \n    <mark>따라서 참조형 데이터가 “가변값”이라고 설명할 때의 “가변”은 참조형 데이터 내부의 프로퍼티 값을 변경할 때의 성질입니다. 참조형 데이터 자체를 변경하는 경우는 성립되지 않습니다.</mark>\n\n* * *\n\n<h2 id=\"1_5\">불변 객체</h2>\n\n------\n### 불변 객체를 만드는 간단한 방법\n\n참조형 데이터의 “가변”은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때 성립되므로  \n내부 프로퍼티를 변경할 필요가 있을 때 마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하거나  \n자동으로 새로운 객체를 만드는 도구*를 활용하면 객체 역시 불변성을 확보할 수 있습니다.  \n<sub>*대표적으로 immutable.js, immer.js, immutability-helper 등의 라이브러리가 있고,  \nES6의 spread operator, Object.assign 메서드 등도 새로운 객체를 만드는 도구 목적으로 활용할 수 있습니다.</sub>\n\nex)값으로 전달받은 객체를 변경하더라도 원본 객체는 변하지 않게 하고 싶을 경우 불변 객체가 필요합니다.\n\n```js 가변성의 문제점\nvar user = {  \n name: 'Jaenam',  \n gender: 'male',  \n};  \n  \nvar changeName = function(user, newName) {  \n var newUser = user;  \n newUser.name = newName;  \n return newUser;  \n};  \n  \nvar user2 = changeName(user, 'Jung');  \n  \nif (user !== user2) {  \n console.log('유저 정보가 변경되었습니다.');  \n}  \nconsole.log(user.name, user2.name); // Jung Jung  \nconsole.log(user === user2); // true  \n```\n\n*   `user` 객체의 `name` 프로퍼티를 `‘Jung’`으로 바꾸는 함수를 호출해 반환 값을 `user2` 변수에 담습니다.  \n    그 결과 `user` 와 `user2`의 `name` 프로퍼티가 모두 `‘Jung’`으로 출력되고 (user === user2)가 true로 같다는 것을 알 수 있습니다.\n\n원본 데이터를 변경하고 싶지 않은 경우 각 변수마다 다른 객체를 바라보게 만들어야겠습니다.\n\n```js 서로 다른 객체를 바라보게\nvar user = {  \n name: 'Jaenam',  \n gender: 'male',  \n};  \n  \nvar changeName = function(user, newName) {\n    return {  \n        name: newName,  \n        gender: user.gender,  \n    };  \n};  \n  \nvar user2 = changeName(user, 'Jung');  \n  \nif (user !== user2) {  \n console.log('유저 정보가 변경되었습니다.'); // 유저 정보가 변경되었습니다.  \n}  \nconsole.log(user.name, user2.name); // Jaenam Jung  \nconsole.log(user === user2); // false  \n```\n\n*   changeName() 함수가 새로운 Object를 반환하도록 한 간단한 예시 입니다.  \n    user 와 user2는 서로 다른 Object가 됩니다.\n\n------\n### 얕은 복사와 깊은 복사\n\n얕은 복사(`shallow copy`)는 바로 아래 단계의 값만 복사하는 방법이고,\n깊은 복사(`deep copy`)는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법입니다.\n\n얕은 복사는 중접된 `object`에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사합니다.\n그러므로 해당 <u>프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터 주소</u>를 가리키게 됩니다.\n즉, <mark>얕은 복사는 사본을 바꾸면 원본도 바뀌고, 원본을 바꾸면 사본도 바뀝니다.</mark>\n\n```js 중첩된 객체에 대한 얕은 복사\n//복사해서 새로운 object를 반환하는 함수\nvar copyObject = function(target) {\n  var result = {};\n  for (var prop in target) {\n    result[prop] = target[prop];\n  }\n  return result;\n};\n\nvar user = {\n  name: 'Jaenam',\n  urls: {\n    portfolio: 'http://github.com/abc',\n    blog: 'http://blog.com',\n    facebook: 'http://facebook.com/abc',\n  },\n};\nvar user2 = copyObject(user);\n\n1. user2.name = 'Jung';\nconsole.log(user.name === user2.name); // false\n\n2. user.urls.portfolio = 'http://portfolio.com';\nconsole.log(user.urls.portfolio === user2.urls.portfolio); // true\n\n3. user2.urls.blog = '';\nconsole.log(user.urls.blog === user2.urls.blog); // true\n```\n\n1. 사본인 `user2`의 `name` 프로퍼티 값을 바꿔도 원본 `user`의 `name` 프로퍼티 값은 바뀌지 않습니다.\n\n2.  2번 과 3번 코드는 원본과 사본 어느 쪽을 바꾸더라도 다른 한쪽의 값 역시 바뀐 것을 확인할 수 있습니다.\n\n즉, `user` 객체에 직접 속한 프로퍼티에 대해서는 복사하여 새로운 데이터가 만들어진 반면,\n한 단계 더 들어간 `urls object`의 내부 프로퍼티들은 기존 데이터를 참조합니다.\n\n이런 현상을 막기 위해서는 한 단계 더 들어가는 프로퍼티들도 불변 객체로 만들 필요가 있습니다.\n\n```js 중첩된 객체에 대한 깊은 복사\n//복사해서 새로운 object를 반환하는 함수\nvar copyObject = function(target) {\n  var result = {};\n  for (var prop in target) {\n    result[prop] = target[prop];\n  }\n  return result;\n};\n\nvar user = {\n  name: 'Jaenam',\n  urls: {\n    portfolio: 'http://github.com/abc',\n    blog: 'http://blog.com',\n    facebook: 'http://facebook.com/abc',\n  },\n};\n\nvar user2 = copyObject(user);\n1. user2.urls = copyObject(user.urls);\n\nuser.urls.portfolio = 'http://portfolio.com';\nconsole.log(user.urls.portfolio === user2.urls.portfolio); // false\n\nuser2.urls.blog = '';\nconsole.log(user.urls.blog === user2.urls.blog); // false\n```\n\n1. 사본 `user2`의 `urls`프로퍼티에 `copyObject()` 함수를 실행하여 원본 `user`의 `urls`프로퍼티의 내부까지 복사하여 새로운 `object`를 만들어 할당했습니다. 그 결과 원본과 사본의 참조형 데이터 프로퍼티 값이 서로 다른 결과를 얻어냈습니다.\n\n------\n#### 정리\n\n정리하자면 <u>객체를 복사할 때 객체 내부의 모든 값을 복사하여 새로운 객체를 만들고자 할때</u>.\n객체의 프로퍼티가 <mark>기본형 데이터인 경우 그대로 복사하면 되지만,\n참조형 데이터는 내부의 프로퍼티들을 다시 복사하는 과정을 거쳐야 깊은 복사가 되는 것입니다.</mark>\n\n아래는 이 개념을 바탕으로 원본데이터를 깊은 복사 방식으로 새로운 객체를 반환하는 코드입니다.\n\n------\n#### 깊은 복사로 복사하는 방법\n\n```js 객체의 깊은 복사를 도와주는 범용 함수\nvar copyObjectDeep = function(target) {\n  var result = {};\n  /* target이 object인 경우 내부 프로퍼티들을 순회하여\n    copyObjectDeep 함수를 재귀적으로 호출합니다.*/\n  if (typeof target === 'object' && target !== null) {\n    for (var prop in target) {\n      result[prop] = copyObjectDeep(target[prop]);\n    }\n    //object가 아닌 경우 target을 그대로 지정합니다. \n  } else {\n    result = target;\n  }\n  return result;\n};\n```\n\n* `target === object` 뒤에 `target !== null` 조건이 붙은 이유는\ntypeof 메서드가 null 값에 대해 'object'를 반환하는 일종의 버그성? 때문입니다.\n\n* 이 함수를 사용해 객체를 복사하면 원본과 사본이 서로 다른 주소를 참조하게 되어 한 쪽의 프로퍼티를 변경하더라도 다른 한 쪽에 영향을 주지 않습니다.\n\n---------------\n\n객체를 JSON 문법으로 표현된 문자열로 변환했다가 다시 JSON객체로 바꾸는 방법도 있습니다.\n\n```js JSON을 이용한 간단한 깊은 복사\nvar copyObjectViaJSON = function(target) {\n  return JSON.parse(JSON.stringify(target));\n};\nvar obj = {\n  a: 1,\n  b: {\n    c: null,\n    d: [1, 2],\n    func1: function() {\n      console.log(3);\n    },\n  },\n  func2: function() {\n    console.log(4);\n  },\n};\nvar obj2 = copyObjectViaJSON(obj);\n\nobj2.a = 3;\nobj2.b.c = 4;\nobj.b.d[1] = 3;\n\nconsole.log(obj); // { a: 1. b: { c: null, d: [1, 3], func1: f() }, func2: f() }\nconsole.log(obj2); // { a: 3. b: { c: 4,    d: [1, 2] } }\n```\n\n이 방법은 단순하고 잘 동작합니다. 하지만 <mark>메서드(함수)나 숨겨진 프로퍼티인 &#95;&#95;proto&#95;&#95;나 getter/setter 등과 같이 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시됩니다.</mark>\n<u>httpReaquest로 받은 데이터를 저장한 object를 복사할 경우 등 순수한 정보만을 다루는 object 복사에 좋은 방법입니다.</u>\n\n* * *\n\n<h2 id=\"1_6\">undefined 와 null</h2>\n\n자바스크립트에 \"없음\"을 나타내는 두 값 `\"undefined\"` 와 `\"null\"`\n미세하게 다른 둘의 의미와 사용하는 목적을 살펴봅시다.\n\n------\n##### 자바스크립트는 다음과 같은 경우 엔진에서 undefined 값을 자동으로 부여합니다.\n\n1. 값을 대입하지 않은 변수,즉 데이터 영역에 메모리 주소를 지정하지 않은 식별자에 접근할 때\n\n2. 존재하지 않는 프로퍼티에 접근할 때\n\n3. return 문이 없거나 호출되지 않는 함수의 실행 결과\n\n```js 엔진에서 undefined를 부여하는 경우 예시\nvar a;\nconsole.log(a); // (1) undefined. 값을 대입하지 않은 변수에 접근\n                // a 는 데이터 영역의 메모리 주소가 지정되지 않은 식별자\n\nvar obj = { a: 1 };\nconsole.log(obj.a); // 1\nconsole.log(obj.b); // (2) 존재하지 않는 프로퍼티에 접근\nconsole.log(b); // c.f) ReferenceError: b is not defined\n\nvar func = function() {};\nvar c = func(); // (3) 반환(return)값이 없으면 undefined를 반환한 것으로 간주.\nconsole.log(c); // undefined\n```\n\n------\n##### 값을 대입하지 않은 변수가 빈 배열일 경우 \n\n값을 대입하지 않은 변수가 빈 배열일 경우 특이한 결과를 확인할 수 있습니다.\n\n```js undefined 와 빈 배열\n1. var arr1 = [];\narr1.length = 3;\nconsole.log(arr1); // [empty x 3]\n\n2. var arr2 = new Array(3);\nconsole.log(arr2); // [empty x 3]\n\n3. var arr3 = [undefined, undefined, undefined];\nconsole.log(arr3); // [undefined, undefined, undefined]\n```\n\n1. 빈 배열을 만들고 배열의 length 값을 3으로 지정하고 console에 찍으니 `[empty x 3]`이 출력됩니다.\n이는 배열에 3개의 빈 배열 요소를 확보했지만 확보된 요소에 어떤 값도 할당되어 있지 않음을 의미합니다.\n(undefined 조차 할당되어 있지 않습니다.)\n\n\n2. new 연산자를 사용해 Array 생성자 함수를 호출하고 length 값을 3으로 지정했습니다. 위에 1번과 같은 결과를 갖습니다.\n\n\n3. 배열을 만들고 각 요소에 undefined 값을 지정했습니다. 출력시 `[undefined, undefined, undefined]`가 출력됩니다.\n\n    ![undefined 와 null](/images/Array_empty.JPG)\n\n이처럼 \"비어있는 요소\"(`empty`)와 \"`undefined`를 할당한 요소는\" 출력 결과부터 다릅니다.\n> empty !=== undefined\n\n`\"비어있는 요소\"`는 이터러블과 관련된 많은 배열 메서드들의 대상에서 제외됩니다.\n\n사실은 `Array`도 `object`임을 생각해보면 자연스러운 현상입니다.\n\n존재하지 않는 프로퍼티를 이터러블 메서드로 순회할 수 없는 것이 당연합니다.\n\n~~배열은 length 프로퍼티의 개수만큼 빈 공간을 확보하고 각각의 인덱스를 이름으로 지정할 것이라고 생각할 수 있지만,~~\n\n<mark>실제로는 object와 마찬가지로 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 동작을 합니다.</mark>\n\n즉, 값이 지정되지 않은 인덱스는 프로퍼티값이 지정되지 않은 빈 공간입니다.\n\n위 처럼 `undefined`는 엔진이 부여하는 경우와 사용자가 값으로 할당한 실존하는 데이터인 경우로 나뉠수 있습니다.\n이러한 방식은 혼란을 가져올 수 있습니다. \n사용자가 \"비어 있음\"을 나타내고 싶어 할당한 값과, 엔진이 부여하는 \"해당 값이 없음\"\n이 두가지를 확실히 구분하기 위해 사용하는 것이 바로 `null` 입니다.\n\n------\n##### null 사용 뜻\n\n사용자가 `\"비어있음\"`을 뜻하는 용도로 사용하고 싶을 때는 `null`을 사용하도록 합니다.\n`null`을 이런 용도에 사용하는 규칙을 지킨다면, `undefined`가 **\"값을 대입하지 않은 변수에 접근할 때\" 엔진이 반환해 주는 값으로만 존재할 수 있습니다.**\n\n~~애초에 null이 이런 용도로 만들어진 데이터 타입입니다.~~","slug":"데이터 타입 -Core JavaScript","published":1,"updated":"2020-05-08T12:02:47.825Z","_id":"ck9iqcrtc002xqgvq23twhxba","comments":1,"layout":"post","photos":[],"link":"","content":"<p>자바스크립트가 데이터를 처리하는 과정을 살펴봄으로써<br>기본형 타입과 참조형 타입이 서로 다르게 동작하는 이유를 이해하고<br>이를 적절히 활용할 수 있게 되는 것을 목표로 합니다.<br>나아가 데이터 타입과 관련된 중요한 개념 몇 가지를 추가로 살펴봅니다.</p>\n<ul>\n<li><a href=\"/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_1\">데이터 타입의 종류</a></li>\n<li><a href=\"/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_2\">데이터 타입에 관한 배경 지식</a><ul>\n<li>메모리와 데이터</li>\n<li>식별자와 변수</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_3\">변수 선언과 데이터 할당</a><ul>\n<li>변수 선언</li>\n<li>데이터 할당</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_4\">기본형 데이터와 참조형 데이터</a><ul>\n<li>불변값</li>\n<li>가변값</li>\n<li>변수 복사 비교</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_5\">불변 객체</a><ul>\n<li>불변 객체를 만드는 간단한 방법</li>\n<li>얕은 복사와 깊은 복사</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_6\">undefined 와 null</a></li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"1_1\">데이터 타입의 종류</h2>\n\n<p>자바스크립트의 데이터 타입에는 크게 두 가지가 있습니다. 바로 기본형과 참조형 입니다.</p>\n<ul>\n<li><p><strong>기본형</strong>(원시형, <code>primitive type</code>)<br>number, string, boolean, null, undefined, Symbol</p>\n</li>\n<li><p><strong>참조형</strong>(<code>reference type</code>)<br>object, Array, Function, Date, RegExp, Map, WeakMap, Set, WeakSet 등이 객체의 하위 분류에 속합니다.</p>\n</li>\n</ul>\n<img src=\"/images/JavaScript-Data-Types.PNG\">\n\n<p><a href=\"https://tutorial.eyehunts.com/js/javascript-data-types-and-examples\">https://tutorial.eyehunts.com/js/javascript-data-types-and-examples</a></p>\n<p>일반적으로 기본형은 할당이나 연산시 복제되고 참조형은 참조된다고 알려져 있습니다.<br>엄밀히 말하면 둘 모두 복제를 하긴 합니다.<br>다만 <u>기본형은 값이 담긴 주소값을 바로 복제하는 반면 참조형은 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제한다는 점이 다릅니다.</u></p>\n<ul>\n<li><p>기본형은 <code>불변성(immutability)</code>을 뜁니다.<br><del>언뜻 생각해 보면 혼란스러울 수 있습니다.</del>  </p>\n<p>불변성을 잘 이해하려면 메모리와 데이터에 대한 지식이 필요하고, 식별자와 변수의 개념을 구분할 수 있어야합니다.<br>메모리 영역에서 자바스크립트의 데이터가 처리되는 과정을 알아봅시다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"1_2\">데이터 타입에 관한 배경 지식</h2>\n\n<hr>\n<h3 id=\"메모리와-데이터\"><a href=\"#메모리와-데이터\" class=\"headerlink\" title=\"메모리와 데이터\"></a>메모리와 데이터</h3><p>컴퓨터는 모든 데이터를 <code>0 또는 1</code>로 기억합니다.<br><code>0 또는 1</code>만 표현할 수 있는 하나의 메모리 조각을 <code>비트(bit)</code>라고 합니다. 각 비트는 고유한 식별자(<code>unique identifier</code>)를 통해 위치를 확인할 수 있습니다.</p>\n<p>1byte = 8 bit 입니다.</p>\n<p>메모리 용량이 과거보다 월등히 커진 영향으로 자바스크립트에서는 숫자의 경우 정수형인지 부동소수형인지 구분하지 않고 64비트 (8바이트)를 확보합니다.</p>\n<p><mark>모든 데이터는 바이트 단위의 식별자, 즉 메모리 주소값(memory address)을 통해 서로 구분하고 연결할 수 있습니다.</mark></p>\n<hr>\n<h3 id=\"식별자와-변수\"><a href=\"#식별자와-변수\" class=\"headerlink\" title=\"식별자와 변수\"></a>식별자와 변수</h3><ul>\n<li><p><strong>변수</strong>는 “변할 수 있는 데이터” 입니다. (숫자,문자열,객체,배열 모두가 데이터 입니다.)</p>\n</li>\n<li><p><strong>식별자</strong>는 어떤 데이터를 식별하는데 사용하는 이름. 즉 <code>변수명</code> 입니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"1_3\">변수 선언과 데이터 할당</h2>\n\n<hr>\n<h3 id=\"변수-선언\"><a href=\"#변수-선언\" class=\"headerlink\" title=\"변수 선언\"></a>변수 선언</h3><p>변수 선언의 동작 원리를 알아봅니다.</p>\n<blockquote>\n<p>var a;</p>\n</blockquote>\n<p>위 코드를 말로 해석하자면 <strong>변할 수 있는 데이터를 만들고</strong>, <code>식별자 이름을 a</code>로 설정합니다.</p>\n<p>즉, 엔진에서는 <strong>메모리에서 비어있는 공간을 확보</strong>하고 이 <u>메모리 영역의 이름(식별자)을 a</u>로 설정합니다.</p>\n<p>여기까지가 변수 선언 과정입니다.<br>이후에 a에 접근하고자 하면 엔진은 메모리 영역에서 a라는 이름을 가진 주소를 검색해 해당 영역에 담긴 데이터를 반환합니다.</p>\n<hr>\n<h3 id=\"데이터-할당\"><a href=\"#데이터-할당\" class=\"headerlink\" title=\"데이터 할당\"></a>데이터 할당</h3><blockquote>\n<p>var a = ‘abc’;</p>\n</blockquote>\n<p>a라는 이름의 주소를 검색해서 그곳에 문자열 ‘abc’를 할당할 것 같지만,<br>실제로 <u>해당 위치에 문자열을 직접 저장하지는 않습니다.</u></p>\n<p>엔진에서는 데이터를 저장하기 위한 <strong>별도의 메모리 공간을 확보하여 문자열 ‘abc’를 저장</strong>하고,<br><mark>그 주소를 변수 영역에 저장하는 식으로 이뤄집니다.</mark><br><strong>메모리 공간</strong>은 <strong>변수영역</strong> 과 <strong>데이터 영역</strong>을 <u>구분지어 값을 저장</u>한다고 생각하면 됩니다.</p>\n<ul>\n<li>데이터 할당과 변수 선언 흐름</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'abc'</span>;  </span><br><span class=\"line\"><span class=\"comment\">// 위 코드는 아래 코드와 동일 합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a;  </span><br><span class=\"line\">a = <span class=\"string\">'abc'</span>;  </span><br><span class=\"line\"><span class=\"comment\">// 즉 엔진의 흐름은  </span></span><br><span class=\"line\"><span class=\"number\">1.</span> 변수 영역에서 빈 공간을 확보하고  </span><br><span class=\"line\"><span class=\"number\">2.</span> 확보한 공간의 식별자를 a로 지정합니다.  </span><br><span class=\"line\"><span class=\"number\">3.</span> 변수 영역이 아닌 데이터 영역의 빈 공간에 문자열 <span class=\"string\">'abc'</span>를 저장합니다.  </span><br><span class=\"line\"><span class=\"number\">4.</span> 변수 영역에서 a 식별자를 검색합니다.  </span><br><span class=\"line\"><span class=\"number\">5.</span> 데이터 영역에서 생성한 문자열의 주소를   </span><br><span class=\"line\"> a 식별자로 검색한 변수 영역에 대입합니다.</span><br></pre></td></tr></table></figure>\n\n<p>이러한 방식은 데이터를 변경(or 삭제/추가)등의 작업을 할때<br>변경된 데이터의 주소들을 다시 식별자에 연결하여 저장하지 않아도 됩니다.<br>(엔진이 처리할 연산을 최소한으로 해줍니다.)</p>\n<p>효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적입니다.</p>\n<p>예를 들어 다수의 변수를 생성하여 모든 변수에 숫자 5를 할당한다면,<br>변수의 개수만큼 변수의 메모리 공간마다 5를 할당해야 합니다.<br>하지만 5를 별도의 공간(메모리 공간 중 변수 영역이 아닌 데이터 영역)에 한 번만 저장하고 그 주소를 연결한다면? 엔진의 중복 연산 처리 효율이 높아집니다.</p>\n<hr>\n<h2 id=\"1_4\">기본형 데이터와 참조형 데이터</h2>\n\n<hr>\n<h3 id=\"불변값\"><a href=\"#불변값\" class=\"headerlink\" title=\"불변값\"></a>불변값</h3><p>변수 와 상수의 차이는 <code>“변경 가능성”</code>입니다.<br><strong>변수</strong>는 변할 수 있는 데이터,<br><strong>상수</strong>는 바뀌지 않습니다.  </p>\n<p>이 <code>“변경 가능성”</code>의 기준은 변수 영역의 메모리 입니다.<br><mark>한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건입니다.</mark></p>\n<p>반면 상수 와 불변값을 구분짓는 <code>“변경 가능성”</code>의 기준은 <strong>데이터 영역 메모리</strong> 입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> a = <span class=\"string\">'abc'</span>;  </span><br><span class=\"line\">a = a + <span class=\"string\">'def'</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">var</span> b = <span class=\"number\">5</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"number\">5</span>;  </span><br><span class=\"line\"><span class=\"number\">3.</span> b = <span class=\"number\">7</span>;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>변수 a</code> 에 문자열 <code>‘abc’</code>를 할당했다가 아래 코드로 <code>‘def’</code>를 추가하면<br>기존의 <code>‘abc’</code>가 <code>‘abcdef’</code>로 바뀌는 것이 아니라 <strong>새로운 문자열</strong> <code>‘abcdef’</code>를 만들어<br><strong>그 주소를 변수 a에 저장</strong>합니다. <code>‘abc’</code>와 <code>‘abcdef’</code>는 <strong>완전히 별개의 데이터</strong> 입니다.</li>\n</ol>\n<ol start=\"2\">\n<li><code>변수 b</code> 에 데이터 영역을 만들어 <strong>5를 설정하고 그 주소를 b에 저장</strong>합니다.<br>다음 코드에서 <code>c</code>에 5를 할당하려고 하면 <strong>엔진은 데이터 영역에서 5를 찾습니다.</strong><br>이미 만들어진 주소가 있으므로 그 주소를 <strong>재활용하여 c에 저장</strong>합니다.</li>\n</ol>\n<ol start=\"3\">\n<li><code>변수 b</code> 의 값을 7로 바꾸려고 합니다. <strong>기존에 저장된 5를 7로 바꾸는 것이 아니라</strong><br> <strong>데이터 영역에서 7을 찾아 있으면 그 주소를 재활용하고 없다면 새로 만들어 b에 저장합니다.</strong><br> <code>결국 5 와 7 모두 다른 값으로 변경할 수 없습니다.</code></li>\n</ol>\n<p>이처럼 문자열 값 과 숫자 값 모두 한 번 만든 값을 바꿀 수 없고, 다른 값으로 변경할 수 없습니다. 변경은 새로 만드는 동작을 통해서만 이뤄집니다. 한 번 만들어진 값은 <code>GC(Garbage Collection)</code> 당하지 않는 한 영원히 변하지 않습니다. 이것이 바로 <strong>불변값의 특징</strong>입니다.</p>\n<p><strong>기본형(원시값, <code>primitive</code>)데이터</strong>인 number, string, boolean, null, undefined, Symbol은 모두 불변값입니다.</p>\n<hr>\n<h3 id=\"가변값\"><a href=\"#가변값\" class=\"headerlink\" title=\"가변값\"></a>가변값</h3><p><strong>참조형(<code>reference</code>) 데이터</strong>의 기본적인 성질은 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용하는 방법도 있습니다.</p>\n<p>참조형 데이터를 변수에 할당하는 과정부터 확인해 봅니다.</p>\n<figure class=\"highlight js\"><figcaption><span>참조형 데이터의 할당</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 =&#123;  </span><br><span class=\"line\"> a: <span class=\"number\">1</span>,  </span><br><span class=\"line\"> b: <span class=\"string\">'bbb'</span>  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>엔진은 우선 변수 영역의 빈공간을 확보하고, 그 주소의 이름을 obj로 지정합니다.</p>\n</li>\n<li><p>{} 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 주소 이름으로 각각 a 와 b라는 프로퍼티 이름을 지정합니다.</p>\n</li>\n<li><p>데이터 영역에서 숫자 1을 검색합니다. 검색 결과가 없으므로 데이터 영역에 저장하고 이 주소를 a 주소에 저장합니다. 문자열 ‘bbb’역시 데이터 영역에 저장하고 이 주소를 b 주소에 저장합니다.</p>\n</li>\n</ol>\n<p><mark>기본형 데이터와의 차이는 “객체의 변수(프로퍼티) 영역”이 별도로 존재한다는 점입니다.</mark><br>객체가 별도로 할애한 영역은 변수 영역일 뿐 “데이터 영역”은 기존의 메모리 공간을 그대로 활용하고 있습니다.<br>데이터 영역에 저장된 값은 모두 불변값입니다. 그러나 변수에는 얼마든지 다른 값을 대입할 수 있습니다.<br>바로 <strong>이 부분 때문에 흔히 참조형(reference)데이터는 가변값이라고 하는 것</strong>입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>참조형 데이터의 프로퍼티 재할당</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 =&#123;  </span><br><span class=\"line\"> a: <span class=\"number\">1</span>,  </span><br><span class=\"line\"> b: <span class=\"string\">'bbb'</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">obj.a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>obj1</code>의 <code>a</code> 프로퍼티에 숫자 <code>2</code>를 할당하려고 합니다. 데이터 영역에서 숫자 <code>2</code>를 검색합니다.<br>존재하지 않으므로 데이터 영역을 새로만들어 <code>2</code>를 저장합니다. 이 주소를 프로퍼티 영역의 <code>a</code> 주소에 저장합니다.<br>변수 <code>obj1</code>이 <strong>바라보고 있는 주소는 데이터 영역으로 변하지 않았습니다. 즉 새로운 Object가 만들어진 것이 아니라</strong> <code>Object</code> 내부의 프로퍼티 영역 <code>a</code>의 값만 바뀐 것 입니다.</li>\n</ul>\n<p>다음은 <strong>참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우</strong> 입니다.<br>이러한 경우를 <code>중첩객체(nested object)</code>라고 합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>중첩된 참조형 데이터(객체)의 프로퍼티 할당</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;  </span><br><span class=\"line\"> x : <span class=\"number\">3</span>,  </span><br><span class=\"line\"> arr : [ <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> ]  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>엔진은 우선 <strong>변수 영역의 빈공간을 확보</strong>하고, 그 주소의 이름을 <code>obj</code>로 지정합니다.</li>\n</ol>\n<ol start=\"2\">\n<li>데이터 저장 공간에 데이터를 저장하려는데( {} ), 이 데이터는 여러개의 프로퍼티와 값들을 모아놓은 그룹(객체)입니다. <strong>각 프로퍼티들을 저장하기 위해 별도의 프로퍼티 영역을 마련하고 그 주소를 {}의 주소에 저장합니다.</strong></li>\n</ol>\n<ol start=\"3\">\n<li>각 프로퍼티 영역에 <code>x</code> 와 <code>arr</code> 를 주소 이름으로 지정합니다.</li>\n</ol>\n<ol start=\"4\">\n<li>데이터 영역에서 숫자 <code>3</code>을 검색합니다. 없으므로 새로 만들고 이 주소를 프로퍼티 영역 x의 주소에 저장합니다.</li>\n</ol>\n<ol start=\"5\">\n<li>데이터 영역에 <code>arr</code> 로 저장할 값은 <code>Array</code>로써 별도의 <code>Array</code> 영역을 만들어 저장하고 프로퍼티 영역 <code>arr</code>의 주소에 저장합니다.</li>\n</ol>\n<ol start=\"6\">\n<li>배열의 요소가 총 <code>3</code>개 이므로 <code>Array</code> 영역에 공간을 확보하고 각각 <strong>인덱스를 부여하고 주소이름으로 사용</strong>합니다.</li>\n</ol>\n<ol start=\"7\">\n<li>데이터 영역에서 숫자 <code>3</code>을 검색하여 그 주소를 <code>인덱스 0</code>의 주소에 저장합니다.</li>\n</ol>\n<ol start=\"8\">\n<li>데이터 영역에 숫자 <code>4</code>가 없으므로 <strong>새로운 데이터 영역을 만들고 그 주소를</strong> <code>인덱스 1</code>의 주소에 저장합니다.</li>\n</ol>\n<ol start=\"9\">\n<li>데이터 영역에 숫자 <code>5</code>도 없으므로 생성한 주소를 <code>인덱스 2</code>의 주소에 저장합니다.</li>\n</ol>\n<p><mark>이제 obj.arr[1]을 검색하고자 하면 엔진의 메모리에서는 다음과 같은 과정을 거칩니다.</mark></p>\n<pre><code>1. obj라는 식별자를 가진 주소를 찾습니다.\n2. obj 주소에 연결된 데이터 영역의 주소로 이동합니다.\n3. 데이터 영역에 연결된 프로퍼티 영역의 주소로 이동합니다.\n4. 프로퍼티 영역에서 arr이라는 식별자를 가진 주소를 찾습니다.\n5. arr 주소에 연결된 Array 영역의 주소로 이동합니다.\n6. Array 영역에서 인덱스 1(==식별자 이름)을 검색하여 해당하는 주소로 이동합니다.\n7. 해당하는 주소의 값 숫자형 데이터 4를 반환합니다.</code></pre><p><mark>만약 이 상태에서 다음과 같이 재할당을 하면 다음과 같은 과정을 거칩니다.</mark></p>\n<blockquote>\n<p>obj.arr = “str”;</p>\n</blockquote>\n<p>데이터 영역에 문자열 <code>“str”</code>을 저장하고, 그 주소를 프로퍼티 영역에 저장합니다.(재할당)  </p>\n<p>그러면 기존에 있던 <code>Array</code> 영역의 인덱스 주소를 저장하던 데이터 영역(공간)은 자신의 주소를 참조하는 변수가 하나도 없게 됩니다. (프로퍼티 영역인 arr 주소의 값이 재할당 되므로 데이터 영역의 str을 주소로 갖음)  </p>\n<p><code>참조 카운트</code>(자신을 참조하는 변수의 개수)가 <code>0</code>인 메모리는 <code>garbage collector</code>의 수거 대상이 됩니다.  </p>\n<p>즉, <strong>Array 영역의 주소를 저장하던 데이터 영역은</strong> <code>GC</code>의 수거 대상이며,  </p>\n<p><code>GC</code>가 처리되는 과정에서 연쇄적으로 <code>Array</code> 영역의 <code>참조 카운트</code>도 <code>0</code>이 되고 <code>GC</code>의 대상이되어 제거됩니다.</p>\n<p>제거된 메모리 영역은 다시 새로운 값을 할당할 수 있는 빈 공간이 됩니다.</p>\n<hr>\n<h3 id=\"변수-복사-비교\"><a href=\"#변수-복사-비교\" class=\"headerlink\" title=\"변수 복사 비교\"></a>변수 복사 비교</h3><p>변수를 복사할 때<br><code>기본형</code>(원시값, primitive) 데이터 와 <code>참조형</code>(reference) 데이터의 차이</p>\n<figure class=\"highlight js\"><figcaption><span>변수 복사</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// primitive  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;   </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// reference  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">10</span>, <span class=\"attr\">d</span>: <span class=\"string\">'ddd'</span> &#125;;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = obj1;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>변수 영역의 빈 공간을 확보하고 <code>식별자를 a</code>로 지정합니다.<br><code>숫자 10</code>을 데이터 영역에서 검색하여, 없으면 데이터 영역에 새로 만들어 저장하고 주소를 <code>a</code>의 주소에 저장합니다.</p>\n</li>\n<li><p>변수 영역의 빈 공간을 확보하고 <code>식별자를 b</code>로 지정합니다. 그 후에 변수 영역에서 <code>a</code>식별자를 검색해 <code>a</code>에 저장된 데이터 주소(10)를 <code>b 변수 영역</code>에 저장합니다.</p>\n</li>\n<li><p>변수 영역의 빈 공간을 확보하고 식별자를 <code>obj1</code>로 지정합니다. 데이터 영역을 새로 만들고 데이터 그룹을 담을 프로퍼티 영역을 만들어 이 주소를 데이터 영역에 저장합니다.<br>각각의 프로퍼티 영역에 식별자 이름으로 <code>c</code> , <code>d</code>으로 사용하고 각각의 값 <code>(10, ‘ddd’)</code>을 데이터 영역에서 검색합니다. <code>10</code>은 이미 있으므로 기존의 주소를 프로퍼티 영역에 연결하고, <code>‘ddd’</code>는 새로 만들어 프로퍼티 영역에 연결합니다.</p>\n</li>\n<li><p>변수 영역의 빈 공간을 확보하고 식별자를 <code>obj2</code>로 지정합니다. 그 후에 변수 영역에서 식별자 <code>obj1</code>을 검색해 <code>obj1</code>에 저장된 데이터 주소를 <code>obj2</code> 변수 영역에 저장합니다.</p>\n</li>\n</ol>\n<p><mark>변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일합니다. 복사 과정은 동일하지만 데이터 할당 과정에서 이미 차이가 있기 때문에 변수 복사 이후의 동작에서 큰 차이가 발생합니다.</mark></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 변수 복사이후 값 변경 결과 비교(1)  </span></span><br><span class=\"line\"><span class=\"comment\">// object 프로퍼티 변경 시  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// primitive  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;   </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// reference  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">10</span>, <span class=\"attr\">d</span>: <span class=\"string\">'ddd'</span> &#125;;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = obj1;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 프로퍼티 값 변경  </span></span><br><span class=\"line\">b = <span class=\"number\">15</span>;  </span><br><span class=\"line\">obj2.c = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>b = 15</code> 코드는 데이터 영역에 <code>15</code>가 없으므로 새로운 데이터 영역에 저장하고 그 주소를 변수 영역 식별자 <code>b</code>인 주소에 저장합니다.</p>\n</li>\n<li><p><code>obj.c = 20</code> 코드는 데이터 영역에 <code>20</code>이 없으므르 새로운 데이터 영역에 저장하고 그 주소를 변수 영역 식별자 <code>obj2</code>의 주소를 찾고 이어서 <code>obj2</code>에 저장되있는 프로퍼티 영역의 <code>c</code>주소를 찾아 그 곳에 주소를 저장합니다.</p>\n</li>\n</ul>\n<p><strong>기본형(원시값, primitive) 데이터를 복사한</strong> <code>변수b</code>의 값을 바꾸면 <code>데이터영역 b 주소</code>의 값이 달라집니다.  </p>\n<p><strong>참조형(reference) 데이터를 복사한</strong> <code>변수 obj2</code>의 프로퍼티 값을 바꾸면 바라보는 <code>obj2의 프로퍼티 주소</code>는 달라지지 않습니다. 값만 변합니다.</p>\n<p>즉, 변수 a와 b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1 과 obj2는 여전히 같은 객체를 바라보고 있는 상태입니다. (a !== b), (obj1 === obj2)</p>\n<p><mark>이 결과가 바로 기본형과 참조형 데이터의 가장 큰 차이점 입니다.</mark> <del>대부분의 자바스크립트 책에서 ‘기본형은 값을 복사하고 참조형은 주솟값을 복사한다’고 설명하고 있지만, 사실은 어떤 데이터 타입이든 변수에 할당하기 위해서는 주솟값을 복사해야 하기 때문에</del> <mark>엄밀히 따지면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수 밖에 없습니다. 다만 기본형은 주솟값 복사 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이가 있는 것입니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>Object 자체를 변경 시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 변수 복사이후 값 변경 결과 비교(2)  </span></span><br><span class=\"line\"><span class=\"comment\">// object 변경 시  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// primitive  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;   </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// reference  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">10</span>, <span class=\"attr\">d</span>: <span class=\"string\">'ddd'</span> &#125;;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = obj1;  </span><br><span class=\"line\">  </span><br><span class=\"line\">b = <span class=\"number\">15</span>;  </span><br><span class=\"line\">obj2 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">20</span>, <span class=\"attr\">d</span>: <span class=\"string\">'ddd'</span> &#125;; <span class=\"comment\">//object 자체를 변경</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>obj2에도 새로운 객체를 할당함으로써 값을 직접 변경했습니다.<br>데이터 영역에 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 주소에 저장하게 됩니다.<br>즉, 기본형 데이터의 값 변경처럼 참조형 데이터가 바라보는 주소가 달라지게 되는 것입니다.<br><mark>따라서 참조형 데이터가 “가변값”이라고 설명할 때의 “가변”은 참조형 데이터 내부의 프로퍼티 값을 변경할 때의 성질입니다. 참조형 데이터 자체를 변경하는 경우는 성립되지 않습니다.</mark></li>\n</ul>\n<hr>\n<h2 id=\"1_5\">불변 객체</h2>\n\n<hr>\n<h3 id=\"불변-객체를-만드는-간단한-방법\"><a href=\"#불변-객체를-만드는-간단한-방법\" class=\"headerlink\" title=\"불변 객체를 만드는 간단한 방법\"></a>불변 객체를 만드는 간단한 방법</h3><p>참조형 데이터의 “가변”은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때 성립되므로<br>내부 프로퍼티를 변경할 필요가 있을 때 마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하거나<br>자동으로 새로운 객체를 만드는 도구<em>를 활용하면 객체 역시 불변성을 확보할 수 있습니다.<br><sub></em>대표적으로 immutable.js, immer.js, immutability-helper 등의 라이브러리가 있고,<br>ES6의 spread operator, Object.assign 메서드 등도 새로운 객체를 만드는 도구 목적으로 활용할 수 있습니다.</sub></p>\n<p>ex)값으로 전달받은 객체를 변경하더라도 원본 객체는 변하지 않게 하고 싶을 경우 불변 객체가 필요합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>가변성의 문제점</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user = &#123;  </span><br><span class=\"line\"> name: <span class=\"string\">'Jaenam'</span>,  </span><br><span class=\"line\"> gender: <span class=\"string\">'male'</span>,  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> changeName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user, newName</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> newUser = user;  </span><br><span class=\"line\"> newUser.name = newName;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> newUser;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> user2 = changeName(user, <span class=\"string\">'Jung'</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">if</span> (user !== user2) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'유저 정보가 변경되었습니다.'</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name, user2.name); <span class=\"comment\">// Jung Jung  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user === user2); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>user</code> 객체의 <code>name</code> 프로퍼티를 <code>‘Jung’</code>으로 바꾸는 함수를 호출해 반환 값을 <code>user2</code> 변수에 담습니다.<br>그 결과 <code>user</code> 와 <code>user2</code>의 <code>name</code> 프로퍼티가 모두 <code>‘Jung’</code>으로 출력되고 (user === user2)가 true로 같다는 것을 알 수 있습니다.</li>\n</ul>\n<p>원본 데이터를 변경하고 싶지 않은 경우 각 변수마다 다른 객체를 바라보게 만들어야겠습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>서로 다른 객체를 바라보게</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user = &#123;  </span><br><span class=\"line\"> name: <span class=\"string\">'Jaenam'</span>,  </span><br><span class=\"line\"> gender: <span class=\"string\">'male'</span>,  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> changeName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user, newName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;  </span><br><span class=\"line\">        name: newName,  </span><br><span class=\"line\">        gender: user.gender,  </span><br><span class=\"line\">    &#125;;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> user2 = changeName(user, <span class=\"string\">'Jung'</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">if</span> (user !== user2) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'유저 정보가 변경되었습니다.'</span>); <span class=\"comment\">// 유저 정보가 변경되었습니다.  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name, user2.name); <span class=\"comment\">// Jaenam Jung  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user === user2); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>changeName() 함수가 새로운 Object를 반환하도록 한 간단한 예시 입니다.<br>user 와 user2는 서로 다른 Object가 됩니다.</li>\n</ul>\n<hr>\n<h3 id=\"얕은-복사와-깊은-복사\"><a href=\"#얕은-복사와-깊은-복사\" class=\"headerlink\" title=\"얕은 복사와 깊은 복사\"></a>얕은 복사와 깊은 복사</h3><p>얕은 복사(<code>shallow copy</code>)는 바로 아래 단계의 값만 복사하는 방법이고,<br>깊은 복사(<code>deep copy</code>)는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법입니다.</p>\n<p>얕은 복사는 중접된 <code>object</code>에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사합니다.<br>그러므로 해당 <u>프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터 주소</u>를 가리키게 됩니다.<br>즉, <mark>얕은 복사는 사본을 바꾸면 원본도 바뀌고, 원본을 바꾸면 사본도 바뀝니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>중첩된 객체에 대한 얕은 복사</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//복사해서 새로운 object를 반환하는 함수</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> copyObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">    result[prop] = target[prop];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> user = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Jaenam'</span>,</span><br><span class=\"line\">  urls: &#123;</span><br><span class=\"line\">    portfolio: <span class=\"string\">'http://github.com/abc'</span>,</span><br><span class=\"line\">    blog: <span class=\"string\">'http://blog.com'</span>,</span><br><span class=\"line\">    facebook: <span class=\"string\">'http://facebook.com/abc'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> user2 = copyObject(user);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span> user2.name = <span class=\"string\">'Jung'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name === user2.name); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> user.urls.portfolio = <span class=\"string\">'http://portfolio.com'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.urls.portfolio === user2.urls.portfolio); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span> user2.urls.blog = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.urls.blog === user2.urls.blog); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>사본인 <code>user2</code>의 <code>name</code> 프로퍼티 값을 바꿔도 원본 <code>user</code>의 <code>name</code> 프로퍼티 값은 바뀌지 않습니다.</p>\n</li>\n<li><p>2번 과 3번 코드는 원본과 사본 어느 쪽을 바꾸더라도 다른 한쪽의 값 역시 바뀐 것을 확인할 수 있습니다.</p>\n</li>\n</ol>\n<p>즉, <code>user</code> 객체에 직접 속한 프로퍼티에 대해서는 복사하여 새로운 데이터가 만들어진 반면,<br>한 단계 더 들어간 <code>urls object</code>의 내부 프로퍼티들은 기존 데이터를 참조합니다.</p>\n<p>이런 현상을 막기 위해서는 한 단계 더 들어가는 프로퍼티들도 불변 객체로 만들 필요가 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>중첩된 객체에 대한 깊은 복사</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//복사해서 새로운 object를 반환하는 함수</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> copyObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">    result[prop] = target[prop];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> user = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Jaenam'</span>,</span><br><span class=\"line\">  urls: &#123;</span><br><span class=\"line\">    portfolio: <span class=\"string\">'http://github.com/abc'</span>,</span><br><span class=\"line\">    blog: <span class=\"string\">'http://blog.com'</span>,</span><br><span class=\"line\">    facebook: <span class=\"string\">'http://facebook.com/abc'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> user2 = copyObject(user);</span><br><span class=\"line\"><span class=\"number\">1.</span> user2.urls = copyObject(user.urls);</span><br><span class=\"line\"></span><br><span class=\"line\">user.urls.portfolio = <span class=\"string\">'http://portfolio.com'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.urls.portfolio === user2.urls.portfolio); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">user2.urls.blog = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.urls.blog === user2.urls.blog); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>사본 <code>user2</code>의 <code>urls</code>프로퍼티에 <code>copyObject()</code> 함수를 실행하여 원본 <code>user</code>의 <code>urls</code>프로퍼티의 내부까지 복사하여 새로운 <code>object</code>를 만들어 할당했습니다. 그 결과 원본과 사본의 참조형 데이터 프로퍼티 값이 서로 다른 결과를 얻어냈습니다.</li>\n</ol>\n<hr>\n<h4 id=\"정리\"><a href=\"#정리\" class=\"headerlink\" title=\"정리\"></a>정리</h4><p>정리하자면 <u>객체를 복사할 때 객체 내부의 모든 값을 복사하여 새로운 객체를 만들고자 할때</u>.<br>객체의 프로퍼티가 <mark>기본형 데이터인 경우 그대로 복사하면 되지만,<br>참조형 데이터는 내부의 프로퍼티들을 다시 복사하는 과정을 거쳐야 깊은 복사가 되는 것입니다.</mark></p>\n<p>아래는 이 개념을 바탕으로 원본데이터를 깊은 복사 방식으로 새로운 객체를 반환하는 코드입니다.</p>\n<hr>\n<h4 id=\"깊은-복사로-복사하는-방법\"><a href=\"#깊은-복사로-복사하는-방법\" class=\"headerlink\" title=\"깊은 복사로 복사하는 방법\"></a>깊은 복사로 복사하는 방법</h4><figure class=\"highlight js\"><figcaption><span>객체의 깊은 복사를 도와주는 범용 함수</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> copyObjectDeep = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"comment\">/* target이 object인 경우 내부 프로퍼티들을 순회하여</span></span><br><span class=\"line\"><span class=\"comment\">    copyObjectDeep 함수를 재귀적으로 호출합니다.*/</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> target === <span class=\"string\">'object'</span> &amp;&amp; target !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">      result[prop] = copyObjectDeep(target[prop]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//object가 아닌 경우 target을 그대로 지정합니다. </span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    result = target;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>target === object</code> 뒤에 <code>target !== null</code> 조건이 붙은 이유는<br>typeof 메서드가 null 값에 대해 ‘object’를 반환하는 일종의 버그성? 때문입니다.</p>\n</li>\n<li><p>이 함수를 사용해 객체를 복사하면 원본과 사본이 서로 다른 주소를 참조하게 되어 한 쪽의 프로퍼티를 변경하더라도 다른 한 쪽에 영향을 주지 않습니다.</p>\n</li>\n</ul>\n<hr>\n<p>객체를 JSON 문법으로 표현된 문자열로 변환했다가 다시 JSON객체로 바꾸는 방법도 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>JSON을 이용한 간단한 깊은 복사</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> copyObjectViaJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(target));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: &#123;</span><br><span class=\"line\">    c: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    d: [<span class=\"number\">1</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">    func1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  func2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = copyObjectViaJSON(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">obj2.a = <span class=\"number\">3</span>;</span><br><span class=\"line\">obj2.b.c = <span class=\"number\">4</span>;</span><br><span class=\"line\">obj.b.d[<span class=\"number\">1</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123; a: 1. b: &#123; c: null, d: [1, 3], func1: f() &#125;, func2: f() &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2); <span class=\"comment\">// &#123; a: 3. b: &#123; c: 4,    d: [1, 2] &#125; &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>이 방법은 단순하고 잘 동작합니다. 하지만 <mark>메서드(함수)나 숨겨진 프로퍼티인 &#95;&#95;proto&#95;&#95;나 getter/setter 등과 같이 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시됩니다.</mark><br><u>httpReaquest로 받은 데이터를 저장한 object를 복사할 경우 등 순수한 정보만을 다루는 object 복사에 좋은 방법입니다.</u></p>\n<hr>\n<h2 id=\"1_6\">undefined 와 null</h2>\n\n<p>자바스크립트에 “없음”을 나타내는 두 값 <code>&quot;undefined&quot;</code> 와 <code>&quot;null&quot;</code><br>미세하게 다른 둘의 의미와 사용하는 목적을 살펴봅시다.</p>\n<hr>\n<h5 id=\"자바스크립트는-다음과-같은-경우-엔진에서-undefined-값을-자동으로-부여합니다\"><a href=\"#자바스크립트는-다음과-같은-경우-엔진에서-undefined-값을-자동으로-부여합니다\" class=\"headerlink\" title=\"자바스크립트는 다음과 같은 경우 엔진에서 undefined 값을 자동으로 부여합니다.\"></a>자바스크립트는 다음과 같은 경우 엔진에서 undefined 값을 자동으로 부여합니다.</h5><ol>\n<li><p>값을 대입하지 않은 변수,즉 데이터 영역에 메모리 주소를 지정하지 않은 식별자에 접근할 때</p>\n</li>\n<li><p>존재하지 않는 프로퍼티에 접근할 때</p>\n</li>\n<li><p>return 문이 없거나 호출되지 않는 함수의 실행 결과</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>엔진에서 undefined를 부여하는 경우 예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// (1) undefined. 값을 대입하지 않은 변수에 접근</span></span><br><span class=\"line\">                <span class=\"comment\">// a 는 데이터 영역의 메모리 주소가 지정되지 않은 식별자</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.a); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.b); <span class=\"comment\">// (2) 존재하지 않는 프로퍼티에 접근</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// c.f) ReferenceError: b is not defined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = func(); <span class=\"comment\">// (3) 반환(return)값이 없으면 undefined를 반환한 것으로 간주.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"값을-대입하지-않은-변수가-빈-배열일-경우\"><a href=\"#값을-대입하지-않은-변수가-빈-배열일-경우\" class=\"headerlink\" title=\"값을 대입하지 않은 변수가 빈 배열일 경우\"></a>값을 대입하지 않은 변수가 빈 배열일 경우</h5><p>값을 대입하지 않은 변수가 빈 배열일 경우 특이한 결과를 확인할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>undefined 와 빈 배열</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> arr1 = [];</span><br><span class=\"line\">arr1.length = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1); <span class=\"comment\">// [empty x 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">var</span> arr2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2); <span class=\"comment\">// [empty x 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">var</span> arr3 = [<span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3); <span class=\"comment\">// [undefined, undefined, undefined]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>빈 배열을 만들고 배열의 length 값을 3으로 지정하고 console에 찍으니 <code>[empty x 3]</code>이 출력됩니다.<br>이는 배열에 3개의 빈 배열 요소를 확보했지만 확보된 요소에 어떤 값도 할당되어 있지 않음을 의미합니다.<br>(undefined 조차 할당되어 있지 않습니다.)</li>\n</ol>\n<ol start=\"2\">\n<li>new 연산자를 사용해 Array 생성자 함수를 호출하고 length 값을 3으로 지정했습니다. 위에 1번과 같은 결과를 갖습니다.</li>\n</ol>\n<ol start=\"3\">\n<li><p>배열을 만들고 각 요소에 undefined 값을 지정했습니다. 출력시 <code>[undefined, undefined, undefined]</code>가 출력됩니다.</p>\n<p> <img src=\"/images/Array_empty.JPG\" alt=\"undefined 와 null\"></p>\n</li>\n</ol>\n<p>이처럼 “비어있는 요소”(<code>empty</code>)와 “<code>undefined</code>를 할당한 요소는” 출력 결과부터 다릅니다.</p>\n<blockquote>\n<p>empty !=== undefined</p>\n</blockquote>\n<p><code>&quot;비어있는 요소&quot;</code>는 이터러블과 관련된 많은 배열 메서드들의 대상에서 제외됩니다.</p>\n<p>사실은 <code>Array</code>도 <code>object</code>임을 생각해보면 자연스러운 현상입니다.</p>\n<p>존재하지 않는 프로퍼티를 이터러블 메서드로 순회할 수 없는 것이 당연합니다.</p>\n<p><del>배열은 length 프로퍼티의 개수만큼 빈 공간을 확보하고 각각의 인덱스를 이름으로 지정할 것이라고 생각할 수 있지만,</del></p>\n<p><mark>실제로는 object와 마찬가지로 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 동작을 합니다.</mark></p>\n<p>즉, 값이 지정되지 않은 인덱스는 프로퍼티값이 지정되지 않은 빈 공간입니다.</p>\n<p>위 처럼 <code>undefined</code>는 엔진이 부여하는 경우와 사용자가 값으로 할당한 실존하는 데이터인 경우로 나뉠수 있습니다.<br>이러한 방식은 혼란을 가져올 수 있습니다.<br>사용자가 “비어 있음”을 나타내고 싶어 할당한 값과, 엔진이 부여하는 “해당 값이 없음”<br>이 두가지를 확실히 구분하기 위해 사용하는 것이 바로 <code>null</code> 입니다.</p>\n<hr>\n<h5 id=\"null-사용-뜻\"><a href=\"#null-사용-뜻\" class=\"headerlink\" title=\"null 사용 뜻\"></a>null 사용 뜻</h5><p>사용자가 <code>&quot;비어있음&quot;</code>을 뜻하는 용도로 사용하고 싶을 때는 <code>null</code>을 사용하도록 합니다.<br><code>null</code>을 이런 용도에 사용하는 규칙을 지킨다면, <code>undefined</code>가 <strong>“값을 대입하지 않은 변수에 접근할 때” 엔진이 반환해 주는 값으로만 존재할 수 있습니다.</strong></p>\n<p><del>애초에 null이 이런 용도로 만들어진 데이터 타입입니다.</del></p>\n","site":{"data":{}},"excerpt":"<p>자바스크립트가 데이터를 처리하는 과정을 살펴봄으로써<br>기본형 타입과 참조형 타입이 서로 다르게 동작하는 이유를 이해하고<br>이를 적절히 활용할 수 있게 되는 것을 목표로 합니다.<br>나아가 데이터 타입과 관련된 중요한 개념 몇 가지를 추가로 살펴봅니다.</p>\n<ul>\n<li><a href=\"/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_1\">데이터 타입의 종류</a></li>\n<li><a href=\"/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_2\">데이터 타입에 관한 배경 지식</a><ul>\n<li>메모리와 데이터</li>\n<li>식별자와 변수</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_3\">변수 선언과 데이터 할당</a><ul>\n<li>변수 선언</li>\n<li>데이터 할당</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_4\">기본형 데이터와 참조형 데이터</a><ul>\n<li>불변값</li>\n<li>가변값</li>\n<li>변수 복사 비교</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_5\">불변 객체</a><ul>\n<li>불변 객체를 만드는 간단한 방법</li>\n<li>얕은 복사와 깊은 복사</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/16/데이터%20타입%20-Core%20JavaScript/#1_6\">undefined 와 null</a></li>\n</ul>","more":"<hr>\n<h2 id=\"1_1\">데이터 타입의 종류</h2>\n\n<p>자바스크립트의 데이터 타입에는 크게 두 가지가 있습니다. 바로 기본형과 참조형 입니다.</p>\n<ul>\n<li><p><strong>기본형</strong>(원시형, <code>primitive type</code>)<br>number, string, boolean, null, undefined, Symbol</p>\n</li>\n<li><p><strong>참조형</strong>(<code>reference type</code>)<br>object, Array, Function, Date, RegExp, Map, WeakMap, Set, WeakSet 등이 객체의 하위 분류에 속합니다.</p>\n</li>\n</ul>\n<img src=\"/images/JavaScript-Data-Types.PNG\">\n\n<p><a href=\"https://tutorial.eyehunts.com/js/javascript-data-types-and-examples\">https://tutorial.eyehunts.com/js/javascript-data-types-and-examples</a></p>\n<p>일반적으로 기본형은 할당이나 연산시 복제되고 참조형은 참조된다고 알려져 있습니다.<br>엄밀히 말하면 둘 모두 복제를 하긴 합니다.<br>다만 <u>기본형은 값이 담긴 주소값을 바로 복제하는 반면 참조형은 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제한다는 점이 다릅니다.</u></p>\n<ul>\n<li><p>기본형은 <code>불변성(immutability)</code>을 뜁니다.<br><del>언뜻 생각해 보면 혼란스러울 수 있습니다.</del>  </p>\n<p>불변성을 잘 이해하려면 메모리와 데이터에 대한 지식이 필요하고, 식별자와 변수의 개념을 구분할 수 있어야합니다.<br>메모리 영역에서 자바스크립트의 데이터가 처리되는 과정을 알아봅시다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"1_2\">데이터 타입에 관한 배경 지식</h2>\n\n<hr>\n<h3 id=\"메모리와-데이터\"><a href=\"#메모리와-데이터\" class=\"headerlink\" title=\"메모리와 데이터\"></a>메모리와 데이터</h3><p>컴퓨터는 모든 데이터를 <code>0 또는 1</code>로 기억합니다.<br><code>0 또는 1</code>만 표현할 수 있는 하나의 메모리 조각을 <code>비트(bit)</code>라고 합니다. 각 비트는 고유한 식별자(<code>unique identifier</code>)를 통해 위치를 확인할 수 있습니다.</p>\n<p>1byte = 8 bit 입니다.</p>\n<p>메모리 용량이 과거보다 월등히 커진 영향으로 자바스크립트에서는 숫자의 경우 정수형인지 부동소수형인지 구분하지 않고 64비트 (8바이트)를 확보합니다.</p>\n<p><mark>모든 데이터는 바이트 단위의 식별자, 즉 메모리 주소값(memory address)을 통해 서로 구분하고 연결할 수 있습니다.</mark></p>\n<hr>\n<h3 id=\"식별자와-변수\"><a href=\"#식별자와-변수\" class=\"headerlink\" title=\"식별자와 변수\"></a>식별자와 변수</h3><ul>\n<li><p><strong>변수</strong>는 “변할 수 있는 데이터” 입니다. (숫자,문자열,객체,배열 모두가 데이터 입니다.)</p>\n</li>\n<li><p><strong>식별자</strong>는 어떤 데이터를 식별하는데 사용하는 이름. 즉 <code>변수명</code> 입니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"1_3\">변수 선언과 데이터 할당</h2>\n\n<hr>\n<h3 id=\"변수-선언\"><a href=\"#변수-선언\" class=\"headerlink\" title=\"변수 선언\"></a>변수 선언</h3><p>변수 선언의 동작 원리를 알아봅니다.</p>\n<blockquote>\n<p>var a;</p>\n</blockquote>\n<p>위 코드를 말로 해석하자면 <strong>변할 수 있는 데이터를 만들고</strong>, <code>식별자 이름을 a</code>로 설정합니다.</p>\n<p>즉, 엔진에서는 <strong>메모리에서 비어있는 공간을 확보</strong>하고 이 <u>메모리 영역의 이름(식별자)을 a</u>로 설정합니다.</p>\n<p>여기까지가 변수 선언 과정입니다.<br>이후에 a에 접근하고자 하면 엔진은 메모리 영역에서 a라는 이름을 가진 주소를 검색해 해당 영역에 담긴 데이터를 반환합니다.</p>\n<hr>\n<h3 id=\"데이터-할당\"><a href=\"#데이터-할당\" class=\"headerlink\" title=\"데이터 할당\"></a>데이터 할당</h3><blockquote>\n<p>var a = ‘abc’;</p>\n</blockquote>\n<p>a라는 이름의 주소를 검색해서 그곳에 문자열 ‘abc’를 할당할 것 같지만,<br>실제로 <u>해당 위치에 문자열을 직접 저장하지는 않습니다.</u></p>\n<p>엔진에서는 데이터를 저장하기 위한 <strong>별도의 메모리 공간을 확보하여 문자열 ‘abc’를 저장</strong>하고,<br><mark>그 주소를 변수 영역에 저장하는 식으로 이뤄집니다.</mark><br><strong>메모리 공간</strong>은 <strong>변수영역</strong> 과 <strong>데이터 영역</strong>을 <u>구분지어 값을 저장</u>한다고 생각하면 됩니다.</p>\n<ul>\n<li>데이터 할당과 변수 선언 흐름</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'abc'</span>;  </span><br><span class=\"line\"><span class=\"comment\">// 위 코드는 아래 코드와 동일 합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a;  </span><br><span class=\"line\">a = <span class=\"string\">'abc'</span>;  </span><br><span class=\"line\"><span class=\"comment\">// 즉 엔진의 흐름은  </span></span><br><span class=\"line\"><span class=\"number\">1.</span> 변수 영역에서 빈 공간을 확보하고  </span><br><span class=\"line\"><span class=\"number\">2.</span> 확보한 공간의 식별자를 a로 지정합니다.  </span><br><span class=\"line\"><span class=\"number\">3.</span> 변수 영역이 아닌 데이터 영역의 빈 공간에 문자열 <span class=\"string\">'abc'</span>를 저장합니다.  </span><br><span class=\"line\"><span class=\"number\">4.</span> 변수 영역에서 a 식별자를 검색합니다.  </span><br><span class=\"line\"><span class=\"number\">5.</span> 데이터 영역에서 생성한 문자열의 주소를   </span><br><span class=\"line\"> a 식별자로 검색한 변수 영역에 대입합니다.</span><br></pre></td></tr></table></figure>\n\n<p>이러한 방식은 데이터를 변경(or 삭제/추가)등의 작업을 할때<br>변경된 데이터의 주소들을 다시 식별자에 연결하여 저장하지 않아도 됩니다.<br>(엔진이 처리할 연산을 최소한으로 해줍니다.)</p>\n<p>효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적입니다.</p>\n<p>예를 들어 다수의 변수를 생성하여 모든 변수에 숫자 5를 할당한다면,<br>변수의 개수만큼 변수의 메모리 공간마다 5를 할당해야 합니다.<br>하지만 5를 별도의 공간(메모리 공간 중 변수 영역이 아닌 데이터 영역)에 한 번만 저장하고 그 주소를 연결한다면? 엔진의 중복 연산 처리 효율이 높아집니다.</p>\n<hr>\n<h2 id=\"1_4\">기본형 데이터와 참조형 데이터</h2>\n\n<hr>\n<h3 id=\"불변값\"><a href=\"#불변값\" class=\"headerlink\" title=\"불변값\"></a>불변값</h3><p>변수 와 상수의 차이는 <code>“변경 가능성”</code>입니다.<br><strong>변수</strong>는 변할 수 있는 데이터,<br><strong>상수</strong>는 바뀌지 않습니다.  </p>\n<p>이 <code>“변경 가능성”</code>의 기준은 변수 영역의 메모리 입니다.<br><mark>한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건입니다.</mark></p>\n<p>반면 상수 와 불변값을 구분짓는 <code>“변경 가능성”</code>의 기준은 <strong>데이터 영역 메모리</strong> 입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> a = <span class=\"string\">'abc'</span>;  </span><br><span class=\"line\">a = a + <span class=\"string\">'def'</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">var</span> b = <span class=\"number\">5</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"number\">5</span>;  </span><br><span class=\"line\"><span class=\"number\">3.</span> b = <span class=\"number\">7</span>;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>변수 a</code> 에 문자열 <code>‘abc’</code>를 할당했다가 아래 코드로 <code>‘def’</code>를 추가하면<br>기존의 <code>‘abc’</code>가 <code>‘abcdef’</code>로 바뀌는 것이 아니라 <strong>새로운 문자열</strong> <code>‘abcdef’</code>를 만들어<br><strong>그 주소를 변수 a에 저장</strong>합니다. <code>‘abc’</code>와 <code>‘abcdef’</code>는 <strong>완전히 별개의 데이터</strong> 입니다.</li>\n</ol>\n<ol start=\"2\">\n<li><code>변수 b</code> 에 데이터 영역을 만들어 <strong>5를 설정하고 그 주소를 b에 저장</strong>합니다.<br>다음 코드에서 <code>c</code>에 5를 할당하려고 하면 <strong>엔진은 데이터 영역에서 5를 찾습니다.</strong><br>이미 만들어진 주소가 있으므로 그 주소를 <strong>재활용하여 c에 저장</strong>합니다.</li>\n</ol>\n<ol start=\"3\">\n<li><code>변수 b</code> 의 값을 7로 바꾸려고 합니다. <strong>기존에 저장된 5를 7로 바꾸는 것이 아니라</strong><br> <strong>데이터 영역에서 7을 찾아 있으면 그 주소를 재활용하고 없다면 새로 만들어 b에 저장합니다.</strong><br> <code>결국 5 와 7 모두 다른 값으로 변경할 수 없습니다.</code></li>\n</ol>\n<p>이처럼 문자열 값 과 숫자 값 모두 한 번 만든 값을 바꿀 수 없고, 다른 값으로 변경할 수 없습니다. 변경은 새로 만드는 동작을 통해서만 이뤄집니다. 한 번 만들어진 값은 <code>GC(Garbage Collection)</code> 당하지 않는 한 영원히 변하지 않습니다. 이것이 바로 <strong>불변값의 특징</strong>입니다.</p>\n<p><strong>기본형(원시값, <code>primitive</code>)데이터</strong>인 number, string, boolean, null, undefined, Symbol은 모두 불변값입니다.</p>\n<hr>\n<h3 id=\"가변값\"><a href=\"#가변값\" class=\"headerlink\" title=\"가변값\"></a>가변값</h3><p><strong>참조형(<code>reference</code>) 데이터</strong>의 기본적인 성질은 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용하는 방법도 있습니다.</p>\n<p>참조형 데이터를 변수에 할당하는 과정부터 확인해 봅니다.</p>\n<figure class=\"highlight js\"><figcaption><span>참조형 데이터의 할당</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 =&#123;  </span><br><span class=\"line\"> a: <span class=\"number\">1</span>,  </span><br><span class=\"line\"> b: <span class=\"string\">'bbb'</span>  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>엔진은 우선 변수 영역의 빈공간을 확보하고, 그 주소의 이름을 obj로 지정합니다.</p>\n</li>\n<li><p>{} 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 주소 이름으로 각각 a 와 b라는 프로퍼티 이름을 지정합니다.</p>\n</li>\n<li><p>데이터 영역에서 숫자 1을 검색합니다. 검색 결과가 없으므로 데이터 영역에 저장하고 이 주소를 a 주소에 저장합니다. 문자열 ‘bbb’역시 데이터 영역에 저장하고 이 주소를 b 주소에 저장합니다.</p>\n</li>\n</ol>\n<p><mark>기본형 데이터와의 차이는 “객체의 변수(프로퍼티) 영역”이 별도로 존재한다는 점입니다.</mark><br>객체가 별도로 할애한 영역은 변수 영역일 뿐 “데이터 영역”은 기존의 메모리 공간을 그대로 활용하고 있습니다.<br>데이터 영역에 저장된 값은 모두 불변값입니다. 그러나 변수에는 얼마든지 다른 값을 대입할 수 있습니다.<br>바로 <strong>이 부분 때문에 흔히 참조형(reference)데이터는 가변값이라고 하는 것</strong>입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>참조형 데이터의 프로퍼티 재할당</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 =&#123;  </span><br><span class=\"line\"> a: <span class=\"number\">1</span>,  </span><br><span class=\"line\"> b: <span class=\"string\">'bbb'</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">obj.a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>obj1</code>의 <code>a</code> 프로퍼티에 숫자 <code>2</code>를 할당하려고 합니다. 데이터 영역에서 숫자 <code>2</code>를 검색합니다.<br>존재하지 않으므로 데이터 영역을 새로만들어 <code>2</code>를 저장합니다. 이 주소를 프로퍼티 영역의 <code>a</code> 주소에 저장합니다.<br>변수 <code>obj1</code>이 <strong>바라보고 있는 주소는 데이터 영역으로 변하지 않았습니다. 즉 새로운 Object가 만들어진 것이 아니라</strong> <code>Object</code> 내부의 프로퍼티 영역 <code>a</code>의 값만 바뀐 것 입니다.</li>\n</ul>\n<p>다음은 <strong>참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우</strong> 입니다.<br>이러한 경우를 <code>중첩객체(nested object)</code>라고 합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>중첩된 참조형 데이터(객체)의 프로퍼티 할당</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;  </span><br><span class=\"line\"> x : <span class=\"number\">3</span>,  </span><br><span class=\"line\"> arr : [ <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> ]  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>엔진은 우선 <strong>변수 영역의 빈공간을 확보</strong>하고, 그 주소의 이름을 <code>obj</code>로 지정합니다.</li>\n</ol>\n<ol start=\"2\">\n<li>데이터 저장 공간에 데이터를 저장하려는데( {} ), 이 데이터는 여러개의 프로퍼티와 값들을 모아놓은 그룹(객체)입니다. <strong>각 프로퍼티들을 저장하기 위해 별도의 프로퍼티 영역을 마련하고 그 주소를 {}의 주소에 저장합니다.</strong></li>\n</ol>\n<ol start=\"3\">\n<li>각 프로퍼티 영역에 <code>x</code> 와 <code>arr</code> 를 주소 이름으로 지정합니다.</li>\n</ol>\n<ol start=\"4\">\n<li>데이터 영역에서 숫자 <code>3</code>을 검색합니다. 없으므로 새로 만들고 이 주소를 프로퍼티 영역 x의 주소에 저장합니다.</li>\n</ol>\n<ol start=\"5\">\n<li>데이터 영역에 <code>arr</code> 로 저장할 값은 <code>Array</code>로써 별도의 <code>Array</code> 영역을 만들어 저장하고 프로퍼티 영역 <code>arr</code>의 주소에 저장합니다.</li>\n</ol>\n<ol start=\"6\">\n<li>배열의 요소가 총 <code>3</code>개 이므로 <code>Array</code> 영역에 공간을 확보하고 각각 <strong>인덱스를 부여하고 주소이름으로 사용</strong>합니다.</li>\n</ol>\n<ol start=\"7\">\n<li>데이터 영역에서 숫자 <code>3</code>을 검색하여 그 주소를 <code>인덱스 0</code>의 주소에 저장합니다.</li>\n</ol>\n<ol start=\"8\">\n<li>데이터 영역에 숫자 <code>4</code>가 없으므로 <strong>새로운 데이터 영역을 만들고 그 주소를</strong> <code>인덱스 1</code>의 주소에 저장합니다.</li>\n</ol>\n<ol start=\"9\">\n<li>데이터 영역에 숫자 <code>5</code>도 없으므로 생성한 주소를 <code>인덱스 2</code>의 주소에 저장합니다.</li>\n</ol>\n<p><mark>이제 obj.arr[1]을 검색하고자 하면 엔진의 메모리에서는 다음과 같은 과정을 거칩니다.</mark></p>\n<pre><code>1. obj라는 식별자를 가진 주소를 찾습니다.\n2. obj 주소에 연결된 데이터 영역의 주소로 이동합니다.\n3. 데이터 영역에 연결된 프로퍼티 영역의 주소로 이동합니다.\n4. 프로퍼티 영역에서 arr이라는 식별자를 가진 주소를 찾습니다.\n5. arr 주소에 연결된 Array 영역의 주소로 이동합니다.\n6. Array 영역에서 인덱스 1(==식별자 이름)을 검색하여 해당하는 주소로 이동합니다.\n7. 해당하는 주소의 값 숫자형 데이터 4를 반환합니다.</code></pre><p><mark>만약 이 상태에서 다음과 같이 재할당을 하면 다음과 같은 과정을 거칩니다.</mark></p>\n<blockquote>\n<p>obj.arr = “str”;</p>\n</blockquote>\n<p>데이터 영역에 문자열 <code>“str”</code>을 저장하고, 그 주소를 프로퍼티 영역에 저장합니다.(재할당)  </p>\n<p>그러면 기존에 있던 <code>Array</code> 영역의 인덱스 주소를 저장하던 데이터 영역(공간)은 자신의 주소를 참조하는 변수가 하나도 없게 됩니다. (프로퍼티 영역인 arr 주소의 값이 재할당 되므로 데이터 영역의 str을 주소로 갖음)  </p>\n<p><code>참조 카운트</code>(자신을 참조하는 변수의 개수)가 <code>0</code>인 메모리는 <code>garbage collector</code>의 수거 대상이 됩니다.  </p>\n<p>즉, <strong>Array 영역의 주소를 저장하던 데이터 영역은</strong> <code>GC</code>의 수거 대상이며,  </p>\n<p><code>GC</code>가 처리되는 과정에서 연쇄적으로 <code>Array</code> 영역의 <code>참조 카운트</code>도 <code>0</code>이 되고 <code>GC</code>의 대상이되어 제거됩니다.</p>\n<p>제거된 메모리 영역은 다시 새로운 값을 할당할 수 있는 빈 공간이 됩니다.</p>\n<hr>\n<h3 id=\"변수-복사-비교\"><a href=\"#변수-복사-비교\" class=\"headerlink\" title=\"변수 복사 비교\"></a>변수 복사 비교</h3><p>변수를 복사할 때<br><code>기본형</code>(원시값, primitive) 데이터 와 <code>참조형</code>(reference) 데이터의 차이</p>\n<figure class=\"highlight js\"><figcaption><span>변수 복사</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// primitive  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;   </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// reference  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">10</span>, <span class=\"attr\">d</span>: <span class=\"string\">'ddd'</span> &#125;;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = obj1;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>변수 영역의 빈 공간을 확보하고 <code>식별자를 a</code>로 지정합니다.<br><code>숫자 10</code>을 데이터 영역에서 검색하여, 없으면 데이터 영역에 새로 만들어 저장하고 주소를 <code>a</code>의 주소에 저장합니다.</p>\n</li>\n<li><p>변수 영역의 빈 공간을 확보하고 <code>식별자를 b</code>로 지정합니다. 그 후에 변수 영역에서 <code>a</code>식별자를 검색해 <code>a</code>에 저장된 데이터 주소(10)를 <code>b 변수 영역</code>에 저장합니다.</p>\n</li>\n<li><p>변수 영역의 빈 공간을 확보하고 식별자를 <code>obj1</code>로 지정합니다. 데이터 영역을 새로 만들고 데이터 그룹을 담을 프로퍼티 영역을 만들어 이 주소를 데이터 영역에 저장합니다.<br>각각의 프로퍼티 영역에 식별자 이름으로 <code>c</code> , <code>d</code>으로 사용하고 각각의 값 <code>(10, ‘ddd’)</code>을 데이터 영역에서 검색합니다. <code>10</code>은 이미 있으므로 기존의 주소를 프로퍼티 영역에 연결하고, <code>‘ddd’</code>는 새로 만들어 프로퍼티 영역에 연결합니다.</p>\n</li>\n<li><p>변수 영역의 빈 공간을 확보하고 식별자를 <code>obj2</code>로 지정합니다. 그 후에 변수 영역에서 식별자 <code>obj1</code>을 검색해 <code>obj1</code>에 저장된 데이터 주소를 <code>obj2</code> 변수 영역에 저장합니다.</p>\n</li>\n</ol>\n<p><mark>변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일합니다. 복사 과정은 동일하지만 데이터 할당 과정에서 이미 차이가 있기 때문에 변수 복사 이후의 동작에서 큰 차이가 발생합니다.</mark></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 변수 복사이후 값 변경 결과 비교(1)  </span></span><br><span class=\"line\"><span class=\"comment\">// object 프로퍼티 변경 시  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// primitive  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;   </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// reference  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">10</span>, <span class=\"attr\">d</span>: <span class=\"string\">'ddd'</span> &#125;;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = obj1;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 프로퍼티 값 변경  </span></span><br><span class=\"line\">b = <span class=\"number\">15</span>;  </span><br><span class=\"line\">obj2.c = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>b = 15</code> 코드는 데이터 영역에 <code>15</code>가 없으므로 새로운 데이터 영역에 저장하고 그 주소를 변수 영역 식별자 <code>b</code>인 주소에 저장합니다.</p>\n</li>\n<li><p><code>obj.c = 20</code> 코드는 데이터 영역에 <code>20</code>이 없으므르 새로운 데이터 영역에 저장하고 그 주소를 변수 영역 식별자 <code>obj2</code>의 주소를 찾고 이어서 <code>obj2</code>에 저장되있는 프로퍼티 영역의 <code>c</code>주소를 찾아 그 곳에 주소를 저장합니다.</p>\n</li>\n</ul>\n<p><strong>기본형(원시값, primitive) 데이터를 복사한</strong> <code>변수b</code>의 값을 바꾸면 <code>데이터영역 b 주소</code>의 값이 달라집니다.  </p>\n<p><strong>참조형(reference) 데이터를 복사한</strong> <code>변수 obj2</code>의 프로퍼티 값을 바꾸면 바라보는 <code>obj2의 프로퍼티 주소</code>는 달라지지 않습니다. 값만 변합니다.</p>\n<p>즉, 변수 a와 b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1 과 obj2는 여전히 같은 객체를 바라보고 있는 상태입니다. (a !== b), (obj1 === obj2)</p>\n<p><mark>이 결과가 바로 기본형과 참조형 데이터의 가장 큰 차이점 입니다.</mark> <del>대부분의 자바스크립트 책에서 ‘기본형은 값을 복사하고 참조형은 주솟값을 복사한다’고 설명하고 있지만, 사실은 어떤 데이터 타입이든 변수에 할당하기 위해서는 주솟값을 복사해야 하기 때문에</del> <mark>엄밀히 따지면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수 밖에 없습니다. 다만 기본형은 주솟값 복사 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이가 있는 것입니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>Object 자체를 변경 시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 변수 복사이후 값 변경 결과 비교(2)  </span></span><br><span class=\"line\"><span class=\"comment\">// object 변경 시  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// primitive  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;   </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// reference  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">10</span>, <span class=\"attr\">d</span>: <span class=\"string\">'ddd'</span> &#125;;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = obj1;  </span><br><span class=\"line\">  </span><br><span class=\"line\">b = <span class=\"number\">15</span>;  </span><br><span class=\"line\">obj2 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">20</span>, <span class=\"attr\">d</span>: <span class=\"string\">'ddd'</span> &#125;; <span class=\"comment\">//object 자체를 변경</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>obj2에도 새로운 객체를 할당함으로써 값을 직접 변경했습니다.<br>데이터 영역에 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 주소에 저장하게 됩니다.<br>즉, 기본형 데이터의 값 변경처럼 참조형 데이터가 바라보는 주소가 달라지게 되는 것입니다.<br><mark>따라서 참조형 데이터가 “가변값”이라고 설명할 때의 “가변”은 참조형 데이터 내부의 프로퍼티 값을 변경할 때의 성질입니다. 참조형 데이터 자체를 변경하는 경우는 성립되지 않습니다.</mark></li>\n</ul>\n<hr>\n<h2 id=\"1_5\">불변 객체</h2>\n\n<hr>\n<h3 id=\"불변-객체를-만드는-간단한-방법\"><a href=\"#불변-객체를-만드는-간단한-방법\" class=\"headerlink\" title=\"불변 객체를 만드는 간단한 방법\"></a>불변 객체를 만드는 간단한 방법</h3><p>참조형 데이터의 “가변”은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때 성립되므로<br>내부 프로퍼티를 변경할 필요가 있을 때 마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하거나<br>자동으로 새로운 객체를 만드는 도구<em>를 활용하면 객체 역시 불변성을 확보할 수 있습니다.<br><sub></em>대표적으로 immutable.js, immer.js, immutability-helper 등의 라이브러리가 있고,<br>ES6의 spread operator, Object.assign 메서드 등도 새로운 객체를 만드는 도구 목적으로 활용할 수 있습니다.</sub></p>\n<p>ex)값으로 전달받은 객체를 변경하더라도 원본 객체는 변하지 않게 하고 싶을 경우 불변 객체가 필요합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>가변성의 문제점</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user = &#123;  </span><br><span class=\"line\"> name: <span class=\"string\">'Jaenam'</span>,  </span><br><span class=\"line\"> gender: <span class=\"string\">'male'</span>,  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> changeName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user, newName</span>) </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> newUser = user;  </span><br><span class=\"line\"> newUser.name = newName;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> newUser;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> user2 = changeName(user, <span class=\"string\">'Jung'</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">if</span> (user !== user2) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'유저 정보가 변경되었습니다.'</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name, user2.name); <span class=\"comment\">// Jung Jung  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user === user2); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>user</code> 객체의 <code>name</code> 프로퍼티를 <code>‘Jung’</code>으로 바꾸는 함수를 호출해 반환 값을 <code>user2</code> 변수에 담습니다.<br>그 결과 <code>user</code> 와 <code>user2</code>의 <code>name</code> 프로퍼티가 모두 <code>‘Jung’</code>으로 출력되고 (user === user2)가 true로 같다는 것을 알 수 있습니다.</li>\n</ul>\n<p>원본 데이터를 변경하고 싶지 않은 경우 각 변수마다 다른 객체를 바라보게 만들어야겠습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>서로 다른 객체를 바라보게</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user = &#123;  </span><br><span class=\"line\"> name: <span class=\"string\">'Jaenam'</span>,  </span><br><span class=\"line\"> gender: <span class=\"string\">'male'</span>,  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> changeName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user, newName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;  </span><br><span class=\"line\">        name: newName,  </span><br><span class=\"line\">        gender: user.gender,  </span><br><span class=\"line\">    &#125;;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> user2 = changeName(user, <span class=\"string\">'Jung'</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">if</span> (user !== user2) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'유저 정보가 변경되었습니다.'</span>); <span class=\"comment\">// 유저 정보가 변경되었습니다.  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name, user2.name); <span class=\"comment\">// Jaenam Jung  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user === user2); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>changeName() 함수가 새로운 Object를 반환하도록 한 간단한 예시 입니다.<br>user 와 user2는 서로 다른 Object가 됩니다.</li>\n</ul>\n<hr>\n<h3 id=\"얕은-복사와-깊은-복사\"><a href=\"#얕은-복사와-깊은-복사\" class=\"headerlink\" title=\"얕은 복사와 깊은 복사\"></a>얕은 복사와 깊은 복사</h3><p>얕은 복사(<code>shallow copy</code>)는 바로 아래 단계의 값만 복사하는 방법이고,<br>깊은 복사(<code>deep copy</code>)는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법입니다.</p>\n<p>얕은 복사는 중접된 <code>object</code>에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사합니다.<br>그러므로 해당 <u>프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터 주소</u>를 가리키게 됩니다.<br>즉, <mark>얕은 복사는 사본을 바꾸면 원본도 바뀌고, 원본을 바꾸면 사본도 바뀝니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>중첩된 객체에 대한 얕은 복사</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//복사해서 새로운 object를 반환하는 함수</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> copyObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">    result[prop] = target[prop];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> user = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Jaenam'</span>,</span><br><span class=\"line\">  urls: &#123;</span><br><span class=\"line\">    portfolio: <span class=\"string\">'http://github.com/abc'</span>,</span><br><span class=\"line\">    blog: <span class=\"string\">'http://blog.com'</span>,</span><br><span class=\"line\">    facebook: <span class=\"string\">'http://facebook.com/abc'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> user2 = copyObject(user);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span> user2.name = <span class=\"string\">'Jung'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name === user2.name); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> user.urls.portfolio = <span class=\"string\">'http://portfolio.com'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.urls.portfolio === user2.urls.portfolio); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span> user2.urls.blog = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.urls.blog === user2.urls.blog); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>사본인 <code>user2</code>의 <code>name</code> 프로퍼티 값을 바꿔도 원본 <code>user</code>의 <code>name</code> 프로퍼티 값은 바뀌지 않습니다.</p>\n</li>\n<li><p>2번 과 3번 코드는 원본과 사본 어느 쪽을 바꾸더라도 다른 한쪽의 값 역시 바뀐 것을 확인할 수 있습니다.</p>\n</li>\n</ol>\n<p>즉, <code>user</code> 객체에 직접 속한 프로퍼티에 대해서는 복사하여 새로운 데이터가 만들어진 반면,<br>한 단계 더 들어간 <code>urls object</code>의 내부 프로퍼티들은 기존 데이터를 참조합니다.</p>\n<p>이런 현상을 막기 위해서는 한 단계 더 들어가는 프로퍼티들도 불변 객체로 만들 필요가 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>중첩된 객체에 대한 깊은 복사</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//복사해서 새로운 object를 반환하는 함수</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> copyObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">    result[prop] = target[prop];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> user = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Jaenam'</span>,</span><br><span class=\"line\">  urls: &#123;</span><br><span class=\"line\">    portfolio: <span class=\"string\">'http://github.com/abc'</span>,</span><br><span class=\"line\">    blog: <span class=\"string\">'http://blog.com'</span>,</span><br><span class=\"line\">    facebook: <span class=\"string\">'http://facebook.com/abc'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> user2 = copyObject(user);</span><br><span class=\"line\"><span class=\"number\">1.</span> user2.urls = copyObject(user.urls);</span><br><span class=\"line\"></span><br><span class=\"line\">user.urls.portfolio = <span class=\"string\">'http://portfolio.com'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.urls.portfolio === user2.urls.portfolio); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">user2.urls.blog = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.urls.blog === user2.urls.blog); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>사본 <code>user2</code>의 <code>urls</code>프로퍼티에 <code>copyObject()</code> 함수를 실행하여 원본 <code>user</code>의 <code>urls</code>프로퍼티의 내부까지 복사하여 새로운 <code>object</code>를 만들어 할당했습니다. 그 결과 원본과 사본의 참조형 데이터 프로퍼티 값이 서로 다른 결과를 얻어냈습니다.</li>\n</ol>\n<hr>\n<h4 id=\"정리\"><a href=\"#정리\" class=\"headerlink\" title=\"정리\"></a>정리</h4><p>정리하자면 <u>객체를 복사할 때 객체 내부의 모든 값을 복사하여 새로운 객체를 만들고자 할때</u>.<br>객체의 프로퍼티가 <mark>기본형 데이터인 경우 그대로 복사하면 되지만,<br>참조형 데이터는 내부의 프로퍼티들을 다시 복사하는 과정을 거쳐야 깊은 복사가 되는 것입니다.</mark></p>\n<p>아래는 이 개념을 바탕으로 원본데이터를 깊은 복사 방식으로 새로운 객체를 반환하는 코드입니다.</p>\n<hr>\n<h4 id=\"깊은-복사로-복사하는-방법\"><a href=\"#깊은-복사로-복사하는-방법\" class=\"headerlink\" title=\"깊은 복사로 복사하는 방법\"></a>깊은 복사로 복사하는 방법</h4><figure class=\"highlight js\"><figcaption><span>객체의 깊은 복사를 도와주는 범용 함수</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> copyObjectDeep = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"comment\">/* target이 object인 경우 내부 프로퍼티들을 순회하여</span></span><br><span class=\"line\"><span class=\"comment\">    copyObjectDeep 함수를 재귀적으로 호출합니다.*/</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> target === <span class=\"string\">'object'</span> &amp;&amp; target !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">      result[prop] = copyObjectDeep(target[prop]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//object가 아닌 경우 target을 그대로 지정합니다. </span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    result = target;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>target === object</code> 뒤에 <code>target !== null</code> 조건이 붙은 이유는<br>typeof 메서드가 null 값에 대해 ‘object’를 반환하는 일종의 버그성? 때문입니다.</p>\n</li>\n<li><p>이 함수를 사용해 객체를 복사하면 원본과 사본이 서로 다른 주소를 참조하게 되어 한 쪽의 프로퍼티를 변경하더라도 다른 한 쪽에 영향을 주지 않습니다.</p>\n</li>\n</ul>\n<hr>\n<p>객체를 JSON 문법으로 표현된 문자열로 변환했다가 다시 JSON객체로 바꾸는 방법도 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>JSON을 이용한 간단한 깊은 복사</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> copyObjectViaJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(target));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: &#123;</span><br><span class=\"line\">    c: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    d: [<span class=\"number\">1</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">    func1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  func2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = copyObjectViaJSON(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">obj2.a = <span class=\"number\">3</span>;</span><br><span class=\"line\">obj2.b.c = <span class=\"number\">4</span>;</span><br><span class=\"line\">obj.b.d[<span class=\"number\">1</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123; a: 1. b: &#123; c: null, d: [1, 3], func1: f() &#125;, func2: f() &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2); <span class=\"comment\">// &#123; a: 3. b: &#123; c: 4,    d: [1, 2] &#125; &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>이 방법은 단순하고 잘 동작합니다. 하지만 <mark>메서드(함수)나 숨겨진 프로퍼티인 &#95;&#95;proto&#95;&#95;나 getter/setter 등과 같이 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시됩니다.</mark><br><u>httpReaquest로 받은 데이터를 저장한 object를 복사할 경우 등 순수한 정보만을 다루는 object 복사에 좋은 방법입니다.</u></p>\n<hr>\n<h2 id=\"1_6\">undefined 와 null</h2>\n\n<p>자바스크립트에 “없음”을 나타내는 두 값 <code>&quot;undefined&quot;</code> 와 <code>&quot;null&quot;</code><br>미세하게 다른 둘의 의미와 사용하는 목적을 살펴봅시다.</p>\n<hr>\n<h5 id=\"자바스크립트는-다음과-같은-경우-엔진에서-undefined-값을-자동으로-부여합니다\"><a href=\"#자바스크립트는-다음과-같은-경우-엔진에서-undefined-값을-자동으로-부여합니다\" class=\"headerlink\" title=\"자바스크립트는 다음과 같은 경우 엔진에서 undefined 값을 자동으로 부여합니다.\"></a>자바스크립트는 다음과 같은 경우 엔진에서 undefined 값을 자동으로 부여합니다.</h5><ol>\n<li><p>값을 대입하지 않은 변수,즉 데이터 영역에 메모리 주소를 지정하지 않은 식별자에 접근할 때</p>\n</li>\n<li><p>존재하지 않는 프로퍼티에 접근할 때</p>\n</li>\n<li><p>return 문이 없거나 호출되지 않는 함수의 실행 결과</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><figcaption><span>엔진에서 undefined를 부여하는 경우 예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// (1) undefined. 값을 대입하지 않은 변수에 접근</span></span><br><span class=\"line\">                <span class=\"comment\">// a 는 데이터 영역의 메모리 주소가 지정되지 않은 식별자</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.a); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.b); <span class=\"comment\">// (2) 존재하지 않는 프로퍼티에 접근</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// c.f) ReferenceError: b is not defined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = func(); <span class=\"comment\">// (3) 반환(return)값이 없으면 undefined를 반환한 것으로 간주.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"값을-대입하지-않은-변수가-빈-배열일-경우\"><a href=\"#값을-대입하지-않은-변수가-빈-배열일-경우\" class=\"headerlink\" title=\"값을 대입하지 않은 변수가 빈 배열일 경우\"></a>값을 대입하지 않은 변수가 빈 배열일 경우</h5><p>값을 대입하지 않은 변수가 빈 배열일 경우 특이한 결과를 확인할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>undefined 와 빈 배열</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> arr1 = [];</span><br><span class=\"line\">arr1.length = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1); <span class=\"comment\">// [empty x 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">var</span> arr2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2); <span class=\"comment\">// [empty x 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">var</span> arr3 = [<span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3); <span class=\"comment\">// [undefined, undefined, undefined]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>빈 배열을 만들고 배열의 length 값을 3으로 지정하고 console에 찍으니 <code>[empty x 3]</code>이 출력됩니다.<br>이는 배열에 3개의 빈 배열 요소를 확보했지만 확보된 요소에 어떤 값도 할당되어 있지 않음을 의미합니다.<br>(undefined 조차 할당되어 있지 않습니다.)</li>\n</ol>\n<ol start=\"2\">\n<li>new 연산자를 사용해 Array 생성자 함수를 호출하고 length 값을 3으로 지정했습니다. 위에 1번과 같은 결과를 갖습니다.</li>\n</ol>\n<ol start=\"3\">\n<li><p>배열을 만들고 각 요소에 undefined 값을 지정했습니다. 출력시 <code>[undefined, undefined, undefined]</code>가 출력됩니다.</p>\n<p> <img src=\"/images/Array_empty.JPG\" alt=\"undefined 와 null\"></p>\n</li>\n</ol>\n<p>이처럼 “비어있는 요소”(<code>empty</code>)와 “<code>undefined</code>를 할당한 요소는” 출력 결과부터 다릅니다.</p>\n<blockquote>\n<p>empty !=== undefined</p>\n</blockquote>\n<p><code>&quot;비어있는 요소&quot;</code>는 이터러블과 관련된 많은 배열 메서드들의 대상에서 제외됩니다.</p>\n<p>사실은 <code>Array</code>도 <code>object</code>임을 생각해보면 자연스러운 현상입니다.</p>\n<p>존재하지 않는 프로퍼티를 이터러블 메서드로 순회할 수 없는 것이 당연합니다.</p>\n<p><del>배열은 length 프로퍼티의 개수만큼 빈 공간을 확보하고 각각의 인덱스를 이름으로 지정할 것이라고 생각할 수 있지만,</del></p>\n<p><mark>실제로는 object와 마찬가지로 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 동작을 합니다.</mark></p>\n<p>즉, 값이 지정되지 않은 인덱스는 프로퍼티값이 지정되지 않은 빈 공간입니다.</p>\n<p>위 처럼 <code>undefined</code>는 엔진이 부여하는 경우와 사용자가 값으로 할당한 실존하는 데이터인 경우로 나뉠수 있습니다.<br>이러한 방식은 혼란을 가져올 수 있습니다.<br>사용자가 “비어 있음”을 나타내고 싶어 할당한 값과, 엔진이 부여하는 “해당 값이 없음”<br>이 두가지를 확실히 구분하기 위해 사용하는 것이 바로 <code>null</code> 입니다.</p>\n<hr>\n<h5 id=\"null-사용-뜻\"><a href=\"#null-사용-뜻\" class=\"headerlink\" title=\"null 사용 뜻\"></a>null 사용 뜻</h5><p>사용자가 <code>&quot;비어있음&quot;</code>을 뜻하는 용도로 사용하고 싶을 때는 <code>null</code>을 사용하도록 합니다.<br><code>null</code>을 이런 용도에 사용하는 규칙을 지킨다면, <code>undefined</code>가 <strong>“값을 대입하지 않은 변수에 접근할 때” 엔진이 반환해 주는 값으로만 존재할 수 있습니다.</strong></p>\n<p><del>애초에 null이 이런 용도로 만들어진 데이터 타입입니다.</del></p>"},{"title":"선택자 -jQuery","date":"2020-03-10T02:43:38.000Z","disqusId":"tunas-blog-1","_content":"\n* * *\n\n제이쿼리는 자바스크립트를 이용해 만든 라이브러리 언어입니다.  \n라이브러리 언어란 자바스크립트로 만들어진  \n다양한 함수들의 집합을 가르킵니다.\n\n제이쿼리는 모질라 사의 자바스크립트 개발자였던  \n존 레식(John Resig)이 창시 하였습니다.\n\n<!-- more -->\n\n* * *\n\n### 직접 선택자와 인접 관계 선택자\n\n\n>기본형\n$(\"wrap\").css(\"color\",\"green\");\n\n선택자()는 HTML 요쇼(“wrap”)를 선택해 오고  \n선택한 요소에 스타일(css) 또는 속성(Attribute)을 적용할 메서드를 작성합니다.\n\n* * *\n\n#### 직접 선택자\n\n*   $(“*”)  \n    전체 선택자  \n    모든 요소를 선택합니다. *는 root 즉 HTML 전체를 의미합니다.\n    \n*   $(“#.id”)  \n    아이디 선택자  \n    id 속성에 지정된 값을 가진 요소를 선택합니다.\n    \n*   $(“.class”)  \n    클래스 선택자  \n    class 속성에 지정된 값을 가진 요소를 선택합니다.\n    \n*   $(“element”)  \n    요소 선택자  \n    지정한 요소명과 일치하는 요소들만 선택합니다.\n    \n*   $(“선택1,선택2,선택3…선택n”)  \n    그룹 선택자  \n    ()안에 지정된 요소들을 한번에 선택합니다.\n    \n\n* * *\n\n#### 인접 관계 선택자\n\n*   $(“요소 선택”).parent()  \n    부모 요소 선택자  \n    선택한 요소의 부모 요소를 선택합니다.\n    \n*   $(“요소 선택”).parents()  \n    상위 요소 선택자  \n    선택한 요소의 상위 요소를 모두 선택합니다.\n    \n*   $(“요소 선택 하위 요소”)  \n    하위 요소 선택자  \n    선택한 요소에 지정한 하위 요소를 선택합니다.\n    \n*   $(“요소 선택>자식 요소”)  \n    자식 요소 선택자  \n    선택한 요소를 기준으로 자식 관계에 지정한 요소만 선택합니다.\n    \n*   $(“요소 선택”).children()  \n    자식 요소들 선택자  \n    선택한 요소의 모든 자식 요소를 선택합니다.\n    \n*   $(“요소 선택”).prev()  \n    이전 요소 선택자  \n    선택한 요소 바로 이전 요소를 선택합니다.\n    \n*   $(“요소 선택”).prevAll()  \n    이전 요소들 선택자  \n    선택한 요소 이전 요소를 모두 선택합니다.\n    \n*   $(“요소 선택”).prevUntil(“요소명”)  \n    이전 요소 지정 선택자  \n    선택한 요소부터 지정한 요소의 이전 요소까지 모두 선택합니다.\n    \n*   $(“요소 선택”).next()  \n    선택한 요소의 다음 요소를 선택합니다.\n    \n*   $(“요소 선택”).nextAll()  \n    선택한 요소의 다음 요소 모두를 선택합니다.\n    \n*   $(“요소 선택”).siblings();  \n    선택한 요소의 모든 형제 요소를 선택합니다.  \n    본인(선택한 요소)는 선택되지 않습니다.\n    \n\n* * *\n\n### 체이닝 기법 이란?\n\n> $(요소 선택).css(속성1, 값1).css(속성2, 값2).css(속성3, 값3);\n\n제이쿼리에서는 한 객체에 다양한 메서드를 줄줄이 이어서 사용 할 수 있습니다.  \n이를 마치 체인이 엮인 모양과 같다 하여 체이닝 기법 이라고 합니다.  \n메서드 사용이 완료 되었으면 ;(세미콜론)을 작성해줍니다.\n\n* * *\n\n### 속성 탐색 선택자\n\n\n속성 탐색 선택자는  \n선택해 온 요소를 기준으로 일치하는 속성의 포함 여부를 따져서  \n속성(값) 까지 일치할 시 가져오는 선택자 입니다.\n\n| 사용 예시               | 설명                                                      |\n|-------------------------|-----------------------------------------------------------|\n| $(“li[title]”)          | li 요소 중 title속성이 포함된 요소만 선택합니다.          |\n| $(“li[title=’리스트’]”) | li 요소 중 tilte 속성 값이 ‘리스트’인 요소만 선택         |\n| $(“a[href^=’http://‘]”) | a 요소 중 href 속성 값이 ‘http://‘로 시작하는 요소만 선택 |\n| $(“a[href$=’.com’]”)    | a 요소 중 href 값이 ‘.com’으로 끝나는 요소만 선택         |\n| $(“a[href*=’easypub’]”) | a 요소중 href 값이 ‘easyspub’를 포함하는 요소만 선택      |\n| $(“li:hidden”)          | li 요소 중 숨겨진 요소만 선택합니다.                      |\n| $(“li:visible”)         | li 요소 중 보이는 요소만 선택합니다.                      |\n| $(“:text”)              | type 속성값이 “text”인 요소만 선택합니다.                 |\n| $(“:selected”)          | selected 속성이 적용된 요소만 선택합니다.                 |\n| $(“:checked”)           | checked 속성이 적용된 요소만 선택합니다.                  |\n\n* * *\n\n### 선택자와 함께 사용하면 편리한 메서드\n\n\n#### is()\n\nis() 메서드는 선택한 요소의 상태가 지정한 속성과 일치하면 true,  \n그렇지 않으면 false를 반환합니다.\n\n> $(요소 선택).is(“:[checked | selected | visible | hidden]”)\n\n* * *\n\n#### each(), $.each()\n\neach(), $.each() 메서드는 선택한 여러 개의 요소들에 각각 순차적으로  \n하나씩 접근할 때 사용하는 메서드 입니다.\n\n    기본형\n    \n    $(요소 선택).each(function(매개 변수1, 매개 변수2){...});\n    또는\n    $.each(요소 선택,function(매개 변수1, 매개 변수2){...});\n\n```js\n$(function(){  \n $(\"#id li\").each(function(i,k){  \n //id요소 하위li 태그 만큼 아래 실행문을 반복 실행합니다.  \n console.log(\"index:\"+i);  \n //매개 변수 i에는 접근한<li>의 인덱스가 할당되어 있습니다.  \n console.log(k);  \n //매개 변수 k에는 접근한 <li> 태그가 할당됩니다.  \n });  \n});  \n```\n\n* * *\n\n#### get()\n\n제이쿼리로 선택한 요소에 get()메서드를 적용하면  \n자바스크립트에 DOM 선택자로 선택한 태그로 인식되어  \n자바스크립트 DOM 방식을 따릅니다.\n\n> $(“li”).get().style.color=”red”;\n","source":"_posts/선택자 -jQuery.md","raw":"---\ntitle: 선택자 -jQuery\ndate: 2020-03-10 11:43:38\ndisqusId: tunas-blog-1\ncategories: jQuery\ntag: \n- jQuery\n- JavaScript\n---\n\n* * *\n\n제이쿼리는 자바스크립트를 이용해 만든 라이브러리 언어입니다.  \n라이브러리 언어란 자바스크립트로 만들어진  \n다양한 함수들의 집합을 가르킵니다.\n\n제이쿼리는 모질라 사의 자바스크립트 개발자였던  \n존 레식(John Resig)이 창시 하였습니다.\n\n<!-- more -->\n\n* * *\n\n### 직접 선택자와 인접 관계 선택자\n\n\n>기본형\n$(\"wrap\").css(\"color\",\"green\");\n\n선택자()는 HTML 요쇼(“wrap”)를 선택해 오고  \n선택한 요소에 스타일(css) 또는 속성(Attribute)을 적용할 메서드를 작성합니다.\n\n* * *\n\n#### 직접 선택자\n\n*   $(“*”)  \n    전체 선택자  \n    모든 요소를 선택합니다. *는 root 즉 HTML 전체를 의미합니다.\n    \n*   $(“#.id”)  \n    아이디 선택자  \n    id 속성에 지정된 값을 가진 요소를 선택합니다.\n    \n*   $(“.class”)  \n    클래스 선택자  \n    class 속성에 지정된 값을 가진 요소를 선택합니다.\n    \n*   $(“element”)  \n    요소 선택자  \n    지정한 요소명과 일치하는 요소들만 선택합니다.\n    \n*   $(“선택1,선택2,선택3…선택n”)  \n    그룹 선택자  \n    ()안에 지정된 요소들을 한번에 선택합니다.\n    \n\n* * *\n\n#### 인접 관계 선택자\n\n*   $(“요소 선택”).parent()  \n    부모 요소 선택자  \n    선택한 요소의 부모 요소를 선택합니다.\n    \n*   $(“요소 선택”).parents()  \n    상위 요소 선택자  \n    선택한 요소의 상위 요소를 모두 선택합니다.\n    \n*   $(“요소 선택 하위 요소”)  \n    하위 요소 선택자  \n    선택한 요소에 지정한 하위 요소를 선택합니다.\n    \n*   $(“요소 선택>자식 요소”)  \n    자식 요소 선택자  \n    선택한 요소를 기준으로 자식 관계에 지정한 요소만 선택합니다.\n    \n*   $(“요소 선택”).children()  \n    자식 요소들 선택자  \n    선택한 요소의 모든 자식 요소를 선택합니다.\n    \n*   $(“요소 선택”).prev()  \n    이전 요소 선택자  \n    선택한 요소 바로 이전 요소를 선택합니다.\n    \n*   $(“요소 선택”).prevAll()  \n    이전 요소들 선택자  \n    선택한 요소 이전 요소를 모두 선택합니다.\n    \n*   $(“요소 선택”).prevUntil(“요소명”)  \n    이전 요소 지정 선택자  \n    선택한 요소부터 지정한 요소의 이전 요소까지 모두 선택합니다.\n    \n*   $(“요소 선택”).next()  \n    선택한 요소의 다음 요소를 선택합니다.\n    \n*   $(“요소 선택”).nextAll()  \n    선택한 요소의 다음 요소 모두를 선택합니다.\n    \n*   $(“요소 선택”).siblings();  \n    선택한 요소의 모든 형제 요소를 선택합니다.  \n    본인(선택한 요소)는 선택되지 않습니다.\n    \n\n* * *\n\n### 체이닝 기법 이란?\n\n> $(요소 선택).css(속성1, 값1).css(속성2, 값2).css(속성3, 값3);\n\n제이쿼리에서는 한 객체에 다양한 메서드를 줄줄이 이어서 사용 할 수 있습니다.  \n이를 마치 체인이 엮인 모양과 같다 하여 체이닝 기법 이라고 합니다.  \n메서드 사용이 완료 되었으면 ;(세미콜론)을 작성해줍니다.\n\n* * *\n\n### 속성 탐색 선택자\n\n\n속성 탐색 선택자는  \n선택해 온 요소를 기준으로 일치하는 속성의 포함 여부를 따져서  \n속성(값) 까지 일치할 시 가져오는 선택자 입니다.\n\n| 사용 예시               | 설명                                                      |\n|-------------------------|-----------------------------------------------------------|\n| $(“li[title]”)          | li 요소 중 title속성이 포함된 요소만 선택합니다.          |\n| $(“li[title=’리스트’]”) | li 요소 중 tilte 속성 값이 ‘리스트’인 요소만 선택         |\n| $(“a[href^=’http://‘]”) | a 요소 중 href 속성 값이 ‘http://‘로 시작하는 요소만 선택 |\n| $(“a[href$=’.com’]”)    | a 요소 중 href 값이 ‘.com’으로 끝나는 요소만 선택         |\n| $(“a[href*=’easypub’]”) | a 요소중 href 값이 ‘easyspub’를 포함하는 요소만 선택      |\n| $(“li:hidden”)          | li 요소 중 숨겨진 요소만 선택합니다.                      |\n| $(“li:visible”)         | li 요소 중 보이는 요소만 선택합니다.                      |\n| $(“:text”)              | type 속성값이 “text”인 요소만 선택합니다.                 |\n| $(“:selected”)          | selected 속성이 적용된 요소만 선택합니다.                 |\n| $(“:checked”)           | checked 속성이 적용된 요소만 선택합니다.                  |\n\n* * *\n\n### 선택자와 함께 사용하면 편리한 메서드\n\n\n#### is()\n\nis() 메서드는 선택한 요소의 상태가 지정한 속성과 일치하면 true,  \n그렇지 않으면 false를 반환합니다.\n\n> $(요소 선택).is(“:[checked | selected | visible | hidden]”)\n\n* * *\n\n#### each(), $.each()\n\neach(), $.each() 메서드는 선택한 여러 개의 요소들에 각각 순차적으로  \n하나씩 접근할 때 사용하는 메서드 입니다.\n\n    기본형\n    \n    $(요소 선택).each(function(매개 변수1, 매개 변수2){...});\n    또는\n    $.each(요소 선택,function(매개 변수1, 매개 변수2){...});\n\n```js\n$(function(){  \n $(\"#id li\").each(function(i,k){  \n //id요소 하위li 태그 만큼 아래 실행문을 반복 실행합니다.  \n console.log(\"index:\"+i);  \n //매개 변수 i에는 접근한<li>의 인덱스가 할당되어 있습니다.  \n console.log(k);  \n //매개 변수 k에는 접근한 <li> 태그가 할당됩니다.  \n });  \n});  \n```\n\n* * *\n\n#### get()\n\n제이쿼리로 선택한 요소에 get()메서드를 적용하면  \n자바스크립트에 DOM 선택자로 선택한 태그로 인식되어  \n자바스크립트 DOM 방식을 따릅니다.\n\n> $(“li”).get().style.color=”red”;\n","slug":"선택자 -jQuery","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrtc0030qgvq6gxo85k0","content":"<hr>\n<p>제이쿼리는 자바스크립트를 이용해 만든 라이브러리 언어입니다.<br>라이브러리 언어란 자바스크립트로 만들어진<br>다양한 함수들의 집합을 가르킵니다.</p>\n<p>제이쿼리는 모질라 사의 자바스크립트 개발자였던<br>존 레식(John Resig)이 창시 하였습니다.</p>\n<a id=\"more\"></a>\n\n<hr>\n<h3 id=\"직접-선택자와-인접-관계-선택자\"><a href=\"#직접-선택자와-인접-관계-선택자\" class=\"headerlink\" title=\"직접 선택자와 인접 관계 선택자\"></a>직접 선택자와 인접 관계 선택자</h3><blockquote>\n<p>기본형<br>$(“wrap”).css(“color”,”green”);</p>\n</blockquote>\n<p>선택자()는 HTML 요쇼(“wrap”)를 선택해 오고<br>선택한 요소에 스타일(css) 또는 속성(Attribute)을 적용할 메서드를 작성합니다.</p>\n<hr>\n<h4 id=\"직접-선택자\"><a href=\"#직접-선택자\" class=\"headerlink\" title=\"직접 선택자\"></a>직접 선택자</h4><ul>\n<li><p>$(“*”)<br>전체 선택자<br>모든 요소를 선택합니다. *는 root 즉 HTML 전체를 의미합니다.</p>\n</li>\n<li><p>$(“#.id”)<br>아이디 선택자<br>id 속성에 지정된 값을 가진 요소를 선택합니다.</p>\n</li>\n<li><p>$(“.class”)<br>클래스 선택자<br>class 속성에 지정된 값을 가진 요소를 선택합니다.</p>\n</li>\n<li><p>$(“element”)<br>요소 선택자<br>지정한 요소명과 일치하는 요소들만 선택합니다.</p>\n</li>\n<li><p>$(“선택1,선택2,선택3…선택n”)<br>그룹 선택자<br>()안에 지정된 요소들을 한번에 선택합니다.</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"인접-관계-선택자\"><a href=\"#인접-관계-선택자\" class=\"headerlink\" title=\"인접 관계 선택자\"></a>인접 관계 선택자</h4><ul>\n<li><p>$(“요소 선택”).parent()<br>부모 요소 선택자<br>선택한 요소의 부모 요소를 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).parents()<br>상위 요소 선택자<br>선택한 요소의 상위 요소를 모두 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택 하위 요소”)<br>하위 요소 선택자<br>선택한 요소에 지정한 하위 요소를 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택&gt;자식 요소”)<br>자식 요소 선택자<br>선택한 요소를 기준으로 자식 관계에 지정한 요소만 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).children()<br>자식 요소들 선택자<br>선택한 요소의 모든 자식 요소를 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).prev()<br>이전 요소 선택자<br>선택한 요소 바로 이전 요소를 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).prevAll()<br>이전 요소들 선택자<br>선택한 요소 이전 요소를 모두 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).prevUntil(“요소명”)<br>이전 요소 지정 선택자<br>선택한 요소부터 지정한 요소의 이전 요소까지 모두 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).next()<br>선택한 요소의 다음 요소를 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).nextAll()<br>선택한 요소의 다음 요소 모두를 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).siblings();<br>선택한 요소의 모든 형제 요소를 선택합니다.<br>본인(선택한 요소)는 선택되지 않습니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"체이닝-기법-이란\"><a href=\"#체이닝-기법-이란\" class=\"headerlink\" title=\"체이닝 기법 이란?\"></a>체이닝 기법 이란?</h3><blockquote>\n<p>$(요소 선택).css(속성1, 값1).css(속성2, 값2).css(속성3, 값3);</p>\n</blockquote>\n<p>제이쿼리에서는 한 객체에 다양한 메서드를 줄줄이 이어서 사용 할 수 있습니다.<br>이를 마치 체인이 엮인 모양과 같다 하여 체이닝 기법 이라고 합니다.<br>메서드 사용이 완료 되었으면 ;(세미콜론)을 작성해줍니다.</p>\n<hr>\n<h3 id=\"속성-탐색-선택자\"><a href=\"#속성-탐색-선택자\" class=\"headerlink\" title=\"속성 탐색 선택자\"></a>속성 탐색 선택자</h3><p>속성 탐색 선택자는<br>선택해 온 요소를 기준으로 일치하는 속성의 포함 여부를 따져서<br>속성(값) 까지 일치할 시 가져오는 선택자 입니다.</p>\n<table>\n<thead>\n<tr>\n<th>사용 예시</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$(“li[title]”)</td>\n<td>li 요소 중 title속성이 포함된 요소만 선택합니다.</td>\n</tr>\n<tr>\n<td>$(“li[title=’리스트’]”)</td>\n<td>li 요소 중 tilte 속성 값이 ‘리스트’인 요소만 선택</td>\n</tr>\n<tr>\n<td>$(“a[href^=’http://‘]”)</td>\n<td>a 요소 중 href 속성 값이 ‘http://‘로 시작하는 요소만 선택</td>\n</tr>\n<tr>\n<td>$(“a[href$=’.com’]”)</td>\n<td>a 요소 중 href 값이 ‘.com’으로 끝나는 요소만 선택</td>\n</tr>\n<tr>\n<td>$(“a[href*=’easypub’]”)</td>\n<td>a 요소중 href 값이 ‘easyspub’를 포함하는 요소만 선택</td>\n</tr>\n<tr>\n<td>$(“li:hidden”)</td>\n<td>li 요소 중 숨겨진 요소만 선택합니다.</td>\n</tr>\n<tr>\n<td>$(“li:visible”)</td>\n<td>li 요소 중 보이는 요소만 선택합니다.</td>\n</tr>\n<tr>\n<td>$(“:text”)</td>\n<td>type 속성값이 “text”인 요소만 선택합니다.</td>\n</tr>\n<tr>\n<td>$(“:selected”)</td>\n<td>selected 속성이 적용된 요소만 선택합니다.</td>\n</tr>\n<tr>\n<td>$(“:checked”)</td>\n<td>checked 속성이 적용된 요소만 선택합니다.</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"선택자와-함께-사용하면-편리한-메서드\"><a href=\"#선택자와-함께-사용하면-편리한-메서드\" class=\"headerlink\" title=\"선택자와 함께 사용하면 편리한 메서드\"></a>선택자와 함께 사용하면 편리한 메서드</h3><h4 id=\"is\"><a href=\"#is\" class=\"headerlink\" title=\"is()\"></a>is()</h4><p>is() 메서드는 선택한 요소의 상태가 지정한 속성과 일치하면 true,<br>그렇지 않으면 false를 반환합니다.</p>\n<blockquote>\n<p>$(요소 선택).is(“:[checked | selected | visible | hidden]”)</p>\n</blockquote>\n<hr>\n<h4 id=\"each-each\"><a href=\"#each-each\" class=\"headerlink\" title=\"each(), $.each()\"></a>each(), $.each()</h4><p>each(), $.each() 메서드는 선택한 여러 개의 요소들에 각각 순차적으로<br>하나씩 접근할 때 사용하는 메서드 입니다.</p>\n<pre><code>기본형\n\n$(요소 선택).each(function(매개 변수1, 매개 변수2){...});\n또는\n$.each(요소 선택,function(매개 변수1, 매개 변수2){...});</code></pre><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"#id li\"</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i,k</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"comment\">//id요소 하위li 태그 만큼 아래 실행문을 반복 실행합니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"index:\"</span>+i);  </span><br><span class=\"line\"> <span class=\"comment\">//매개 변수 i에는 접근한&lt;li&gt;의 인덱스가 할당되어 있습니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(k);  </span><br><span class=\"line\"> <span class=\"comment\">//매개 변수 k에는 접근한 &lt;li&gt; 태그가 할당됩니다.  </span></span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h4><p>제이쿼리로 선택한 요소에 get()메서드를 적용하면<br>자바스크립트에 DOM 선택자로 선택한 태그로 인식되어<br>자바스크립트 DOM 방식을 따릅니다.</p>\n<blockquote>\n<p>$(“li”).get().style.color=”red”;</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<hr>\n<p>제이쿼리는 자바스크립트를 이용해 만든 라이브러리 언어입니다.<br>라이브러리 언어란 자바스크립트로 만들어진<br>다양한 함수들의 집합을 가르킵니다.</p>\n<p>제이쿼리는 모질라 사의 자바스크립트 개발자였던<br>존 레식(John Resig)이 창시 하였습니다.</p>","more":"<hr>\n<h3 id=\"직접-선택자와-인접-관계-선택자\"><a href=\"#직접-선택자와-인접-관계-선택자\" class=\"headerlink\" title=\"직접 선택자와 인접 관계 선택자\"></a>직접 선택자와 인접 관계 선택자</h3><blockquote>\n<p>기본형<br>$(“wrap”).css(“color”,”green”);</p>\n</blockquote>\n<p>선택자()는 HTML 요쇼(“wrap”)를 선택해 오고<br>선택한 요소에 스타일(css) 또는 속성(Attribute)을 적용할 메서드를 작성합니다.</p>\n<hr>\n<h4 id=\"직접-선택자\"><a href=\"#직접-선택자\" class=\"headerlink\" title=\"직접 선택자\"></a>직접 선택자</h4><ul>\n<li><p>$(“*”)<br>전체 선택자<br>모든 요소를 선택합니다. *는 root 즉 HTML 전체를 의미합니다.</p>\n</li>\n<li><p>$(“#.id”)<br>아이디 선택자<br>id 속성에 지정된 값을 가진 요소를 선택합니다.</p>\n</li>\n<li><p>$(“.class”)<br>클래스 선택자<br>class 속성에 지정된 값을 가진 요소를 선택합니다.</p>\n</li>\n<li><p>$(“element”)<br>요소 선택자<br>지정한 요소명과 일치하는 요소들만 선택합니다.</p>\n</li>\n<li><p>$(“선택1,선택2,선택3…선택n”)<br>그룹 선택자<br>()안에 지정된 요소들을 한번에 선택합니다.</p>\n</li>\n</ul>\n<hr>\n<h4 id=\"인접-관계-선택자\"><a href=\"#인접-관계-선택자\" class=\"headerlink\" title=\"인접 관계 선택자\"></a>인접 관계 선택자</h4><ul>\n<li><p>$(“요소 선택”).parent()<br>부모 요소 선택자<br>선택한 요소의 부모 요소를 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).parents()<br>상위 요소 선택자<br>선택한 요소의 상위 요소를 모두 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택 하위 요소”)<br>하위 요소 선택자<br>선택한 요소에 지정한 하위 요소를 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택&gt;자식 요소”)<br>자식 요소 선택자<br>선택한 요소를 기준으로 자식 관계에 지정한 요소만 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).children()<br>자식 요소들 선택자<br>선택한 요소의 모든 자식 요소를 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).prev()<br>이전 요소 선택자<br>선택한 요소 바로 이전 요소를 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).prevAll()<br>이전 요소들 선택자<br>선택한 요소 이전 요소를 모두 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).prevUntil(“요소명”)<br>이전 요소 지정 선택자<br>선택한 요소부터 지정한 요소의 이전 요소까지 모두 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).next()<br>선택한 요소의 다음 요소를 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).nextAll()<br>선택한 요소의 다음 요소 모두를 선택합니다.</p>\n</li>\n<li><p>$(“요소 선택”).siblings();<br>선택한 요소의 모든 형제 요소를 선택합니다.<br>본인(선택한 요소)는 선택되지 않습니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"체이닝-기법-이란\"><a href=\"#체이닝-기법-이란\" class=\"headerlink\" title=\"체이닝 기법 이란?\"></a>체이닝 기법 이란?</h3><blockquote>\n<p>$(요소 선택).css(속성1, 값1).css(속성2, 값2).css(속성3, 값3);</p>\n</blockquote>\n<p>제이쿼리에서는 한 객체에 다양한 메서드를 줄줄이 이어서 사용 할 수 있습니다.<br>이를 마치 체인이 엮인 모양과 같다 하여 체이닝 기법 이라고 합니다.<br>메서드 사용이 완료 되었으면 ;(세미콜론)을 작성해줍니다.</p>\n<hr>\n<h3 id=\"속성-탐색-선택자\"><a href=\"#속성-탐색-선택자\" class=\"headerlink\" title=\"속성 탐색 선택자\"></a>속성 탐색 선택자</h3><p>속성 탐색 선택자는<br>선택해 온 요소를 기준으로 일치하는 속성의 포함 여부를 따져서<br>속성(값) 까지 일치할 시 가져오는 선택자 입니다.</p>\n<table>\n<thead>\n<tr>\n<th>사용 예시</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$(“li[title]”)</td>\n<td>li 요소 중 title속성이 포함된 요소만 선택합니다.</td>\n</tr>\n<tr>\n<td>$(“li[title=’리스트’]”)</td>\n<td>li 요소 중 tilte 속성 값이 ‘리스트’인 요소만 선택</td>\n</tr>\n<tr>\n<td>$(“a[href^=’http://‘]”)</td>\n<td>a 요소 중 href 속성 값이 ‘http://‘로 시작하는 요소만 선택</td>\n</tr>\n<tr>\n<td>$(“a[href$=’.com’]”)</td>\n<td>a 요소 중 href 값이 ‘.com’으로 끝나는 요소만 선택</td>\n</tr>\n<tr>\n<td>$(“a[href*=’easypub’]”)</td>\n<td>a 요소중 href 값이 ‘easyspub’를 포함하는 요소만 선택</td>\n</tr>\n<tr>\n<td>$(“li:hidden”)</td>\n<td>li 요소 중 숨겨진 요소만 선택합니다.</td>\n</tr>\n<tr>\n<td>$(“li:visible”)</td>\n<td>li 요소 중 보이는 요소만 선택합니다.</td>\n</tr>\n<tr>\n<td>$(“:text”)</td>\n<td>type 속성값이 “text”인 요소만 선택합니다.</td>\n</tr>\n<tr>\n<td>$(“:selected”)</td>\n<td>selected 속성이 적용된 요소만 선택합니다.</td>\n</tr>\n<tr>\n<td>$(“:checked”)</td>\n<td>checked 속성이 적용된 요소만 선택합니다.</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"선택자와-함께-사용하면-편리한-메서드\"><a href=\"#선택자와-함께-사용하면-편리한-메서드\" class=\"headerlink\" title=\"선택자와 함께 사용하면 편리한 메서드\"></a>선택자와 함께 사용하면 편리한 메서드</h3><h4 id=\"is\"><a href=\"#is\" class=\"headerlink\" title=\"is()\"></a>is()</h4><p>is() 메서드는 선택한 요소의 상태가 지정한 속성과 일치하면 true,<br>그렇지 않으면 false를 반환합니다.</p>\n<blockquote>\n<p>$(요소 선택).is(“:[checked | selected | visible | hidden]”)</p>\n</blockquote>\n<hr>\n<h4 id=\"each-each\"><a href=\"#each-each\" class=\"headerlink\" title=\"each(), $.each()\"></a>each(), $.each()</h4><p>each(), $.each() 메서드는 선택한 여러 개의 요소들에 각각 순차적으로<br>하나씩 접근할 때 사용하는 메서드 입니다.</p>\n<pre><code>기본형\n\n$(요소 선택).each(function(매개 변수1, 매개 변수2){...});\n또는\n$.each(요소 선택,function(매개 변수1, 매개 변수2){...});</code></pre><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"#id li\"</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i,k</span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"comment\">//id요소 하위li 태그 만큼 아래 실행문을 반복 실행합니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"index:\"</span>+i);  </span><br><span class=\"line\"> <span class=\"comment\">//매개 변수 i에는 접근한&lt;li&gt;의 인덱스가 할당되어 있습니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(k);  </span><br><span class=\"line\"> <span class=\"comment\">//매개 변수 k에는 접근한 &lt;li&gt; 태그가 할당됩니다.  </span></span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h4><p>제이쿼리로 선택한 요소에 get()메서드를 적용하면<br>자바스크립트에 DOM 선택자로 선택한 태그로 인식되어<br>자바스크립트 DOM 방식을 따릅니다.</p>\n<blockquote>\n<p>$(“li”).get().style.color=”red”;</p>\n</blockquote>"},{"title":"Math(수학) 객체 -JavaScript","date":"2020-03-02T01:38:36.000Z","disqusId":"tunas-blog-1","_content":"\nJavascript에서 더하기, 곱하기, 나누기 등등 은 산술연산자를 사용하면 됩니다.\n\n**하지만 최댓값, 최솟값, 반올림 값 등은 산술연산자로 구할수 없습니다**\n\n수학 객체는 이러한 수학과 관련한 작업을 처리할수 있게 해줍니다.\n\n<!-- more -->\n\n* * *\n\n#### 수학 객체의 메서드 및 상수\n\n| 종류                                     | 설명                                           |\n|------------------------------------------|------------------------------------------------|\n| Math.abs(숫자)                           | 숫자의 절댓값을 반환                           |\n| Math.max(숫자 1, 숫자 2, 숫자 3, 숫자 4) | 숫자 중 가장 큰 값을 반환                      |\n| Math.min(숫자 1, 숫자 2, 숫자 3, 숫자 4) | 숫자 중 가장 작은 값 반환                      |\n| Math.pow(숫자, 제곱값)                   | 숫자의 거듭제곱한 값을 반환                    |\n| Math.random()                            | 0~1 사이에 난수를 반환                         |\n| Math.round(숫자)                         | 소숫점 첫째 자리에서 반올림하여 정수 반환      |\n| Math.ceil(숫자)                          | 소숫점 첫째 자리에서 무조건 올림해서 정수 반환 |\n| Math.floor(숫자)                         | 소숫점 첫째 자리에서 무조건 내림해서 정수 반환 |\n| Math.sqrt(숫자)                          | 숫자의 제곱근 값을 반환                        |\n| Math.PI                                  | 원주율 상수를 반환                             |\n\n\n* * *\n\n사용 예제\n\n```js\nvar num=2.1234;  \n  \nvar maxNum=Math.max(10, 5, 8, 30); // 최댓값 반환 (30)  \nvar minNum=Math.min(10, 5, 8, 30); // 최솟값 반환 (5)  \nvar roundNum=Math.round(num); // num에 저장된 값에 반올림 하여 반환 (2)  \nvar floorNum=Math.floor(num); // num에 저장된 값에 소수점에서 무조건 버림 (2)  \nvar ceilNum=Math.ceil(num); // num에 저장된 값에 소수점에서 무조건 올림(3)  \nvar rndNum=Math.random(num); // 0~1 사이에 난수가 발생합니다.  \nvar piNum=Math.PI; // 원주율 상수를 반환  \n```\n","source":"_posts/수학 객체 -JavaScript.md","raw":"---\ntitle: Math(수학) 객체 -JavaScript\ndate: 2020-03-02 10:38:36\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\nJavascript에서 더하기, 곱하기, 나누기 등등 은 산술연산자를 사용하면 됩니다.\n\n**하지만 최댓값, 최솟값, 반올림 값 등은 산술연산자로 구할수 없습니다**\n\n수학 객체는 이러한 수학과 관련한 작업을 처리할수 있게 해줍니다.\n\n<!-- more -->\n\n* * *\n\n#### 수학 객체의 메서드 및 상수\n\n| 종류                                     | 설명                                           |\n|------------------------------------------|------------------------------------------------|\n| Math.abs(숫자)                           | 숫자의 절댓값을 반환                           |\n| Math.max(숫자 1, 숫자 2, 숫자 3, 숫자 4) | 숫자 중 가장 큰 값을 반환                      |\n| Math.min(숫자 1, 숫자 2, 숫자 3, 숫자 4) | 숫자 중 가장 작은 값 반환                      |\n| Math.pow(숫자, 제곱값)                   | 숫자의 거듭제곱한 값을 반환                    |\n| Math.random()                            | 0~1 사이에 난수를 반환                         |\n| Math.round(숫자)                         | 소숫점 첫째 자리에서 반올림하여 정수 반환      |\n| Math.ceil(숫자)                          | 소숫점 첫째 자리에서 무조건 올림해서 정수 반환 |\n| Math.floor(숫자)                         | 소숫점 첫째 자리에서 무조건 내림해서 정수 반환 |\n| Math.sqrt(숫자)                          | 숫자의 제곱근 값을 반환                        |\n| Math.PI                                  | 원주율 상수를 반환                             |\n\n\n* * *\n\n사용 예제\n\n```js\nvar num=2.1234;  \n  \nvar maxNum=Math.max(10, 5, 8, 30); // 최댓값 반환 (30)  \nvar minNum=Math.min(10, 5, 8, 30); // 최솟값 반환 (5)  \nvar roundNum=Math.round(num); // num에 저장된 값에 반올림 하여 반환 (2)  \nvar floorNum=Math.floor(num); // num에 저장된 값에 소수점에서 무조건 버림 (2)  \nvar ceilNum=Math.ceil(num); // num에 저장된 값에 소수점에서 무조건 올림(3)  \nvar rndNum=Math.random(num); // 0~1 사이에 난수가 발생합니다.  \nvar piNum=Math.PI; // 원주율 상수를 반환  \n```\n","slug":"수학 객체 -JavaScript","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrtd0033qgvq2mdgb6q4","content":"<p>Javascript에서 더하기, 곱하기, 나누기 등등 은 산술연산자를 사용하면 됩니다.</p>\n<p><strong>하지만 최댓값, 최솟값, 반올림 값 등은 산술연산자로 구할수 없습니다</strong></p>\n<p>수학 객체는 이러한 수학과 관련한 작업을 처리할수 있게 해줍니다.</p>\n<a id=\"more\"></a>\n\n<hr>\n<h4 id=\"수학-객체의-메서드-및-상수\"><a href=\"#수학-객체의-메서드-및-상수\" class=\"headerlink\" title=\"수학 객체의 메서드 및 상수\"></a>수학 객체의 메서드 및 상수</h4><table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Math.abs(숫자)</td>\n<td>숫자의 절댓값을 반환</td>\n</tr>\n<tr>\n<td>Math.max(숫자 1, 숫자 2, 숫자 3, 숫자 4)</td>\n<td>숫자 중 가장 큰 값을 반환</td>\n</tr>\n<tr>\n<td>Math.min(숫자 1, 숫자 2, 숫자 3, 숫자 4)</td>\n<td>숫자 중 가장 작은 값 반환</td>\n</tr>\n<tr>\n<td>Math.pow(숫자, 제곱값)</td>\n<td>숫자의 거듭제곱한 값을 반환</td>\n</tr>\n<tr>\n<td>Math.random()</td>\n<td>0~1 사이에 난수를 반환</td>\n</tr>\n<tr>\n<td>Math.round(숫자)</td>\n<td>소숫점 첫째 자리에서 반올림하여 정수 반환</td>\n</tr>\n<tr>\n<td>Math.ceil(숫자)</td>\n<td>소숫점 첫째 자리에서 무조건 올림해서 정수 반환</td>\n</tr>\n<tr>\n<td>Math.floor(숫자)</td>\n<td>소숫점 첫째 자리에서 무조건 내림해서 정수 반환</td>\n</tr>\n<tr>\n<td>Math.sqrt(숫자)</td>\n<td>숫자의 제곱근 값을 반환</td>\n</tr>\n<tr>\n<td>Math.PI</td>\n<td>원주율 상수를 반환</td>\n</tr>\n</tbody></table>\n<hr>\n<p>사용 예제</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num=<span class=\"number\">2.1234</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> maxNum=<span class=\"built_in\">Math</span>.max(<span class=\"number\">10</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">30</span>); <span class=\"comment\">// 최댓값 반환 (30)  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> minNum=<span class=\"built_in\">Math</span>.min(<span class=\"number\">10</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">30</span>); <span class=\"comment\">// 최솟값 반환 (5)  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> roundNum=<span class=\"built_in\">Math</span>.round(num); <span class=\"comment\">// num에 저장된 값에 반올림 하여 반환 (2)  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> floorNum=<span class=\"built_in\">Math</span>.floor(num); <span class=\"comment\">// num에 저장된 값에 소수점에서 무조건 버림 (2)  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ceilNum=<span class=\"built_in\">Math</span>.ceil(num); <span class=\"comment\">// num에 저장된 값에 소수점에서 무조건 올림(3)  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rndNum=<span class=\"built_in\">Math</span>.random(num); <span class=\"comment\">// 0~1 사이에 난수가 발생합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> piNum=<span class=\"built_in\">Math</span>.PI; <span class=\"comment\">// 원주율 상수를 반환</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Javascript에서 더하기, 곱하기, 나누기 등등 은 산술연산자를 사용하면 됩니다.</p>\n<p><strong>하지만 최댓값, 최솟값, 반올림 값 등은 산술연산자로 구할수 없습니다</strong></p>\n<p>수학 객체는 이러한 수학과 관련한 작업을 처리할수 있게 해줍니다.</p>","more":"<hr>\n<h4 id=\"수학-객체의-메서드-및-상수\"><a href=\"#수학-객체의-메서드-및-상수\" class=\"headerlink\" title=\"수학 객체의 메서드 및 상수\"></a>수학 객체의 메서드 및 상수</h4><table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Math.abs(숫자)</td>\n<td>숫자의 절댓값을 반환</td>\n</tr>\n<tr>\n<td>Math.max(숫자 1, 숫자 2, 숫자 3, 숫자 4)</td>\n<td>숫자 중 가장 큰 값을 반환</td>\n</tr>\n<tr>\n<td>Math.min(숫자 1, 숫자 2, 숫자 3, 숫자 4)</td>\n<td>숫자 중 가장 작은 값 반환</td>\n</tr>\n<tr>\n<td>Math.pow(숫자, 제곱값)</td>\n<td>숫자의 거듭제곱한 값을 반환</td>\n</tr>\n<tr>\n<td>Math.random()</td>\n<td>0~1 사이에 난수를 반환</td>\n</tr>\n<tr>\n<td>Math.round(숫자)</td>\n<td>소숫점 첫째 자리에서 반올림하여 정수 반환</td>\n</tr>\n<tr>\n<td>Math.ceil(숫자)</td>\n<td>소숫점 첫째 자리에서 무조건 올림해서 정수 반환</td>\n</tr>\n<tr>\n<td>Math.floor(숫자)</td>\n<td>소숫점 첫째 자리에서 무조건 내림해서 정수 반환</td>\n</tr>\n<tr>\n<td>Math.sqrt(숫자)</td>\n<td>숫자의 제곱근 값을 반환</td>\n</tr>\n<tr>\n<td>Math.PI</td>\n<td>원주율 상수를 반환</td>\n</tr>\n</tbody></table>\n<hr>\n<p>사용 예제</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num=<span class=\"number\">2.1234</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> maxNum=<span class=\"built_in\">Math</span>.max(<span class=\"number\">10</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">30</span>); <span class=\"comment\">// 최댓값 반환 (30)  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> minNum=<span class=\"built_in\">Math</span>.min(<span class=\"number\">10</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">30</span>); <span class=\"comment\">// 최솟값 반환 (5)  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> roundNum=<span class=\"built_in\">Math</span>.round(num); <span class=\"comment\">// num에 저장된 값에 반올림 하여 반환 (2)  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> floorNum=<span class=\"built_in\">Math</span>.floor(num); <span class=\"comment\">// num에 저장된 값에 소수점에서 무조건 버림 (2)  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ceilNum=<span class=\"built_in\">Math</span>.ceil(num); <span class=\"comment\">// num에 저장된 값에 소수점에서 무조건 올림(3)  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rndNum=<span class=\"built_in\">Math</span>.random(num); <span class=\"comment\">// 0~1 사이에 난수가 발생합니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> piNum=<span class=\"built_in\">Math</span>.PI; <span class=\"comment\">// 원주율 상수를 반환</span></span><br></pre></td></tr></table></figure>"},{"title":"Number(숫자) 객체 -JavaScript","date":"2020-03-02T00:47:09.000Z","disqusId":"tunas-blog-1","_content":"\n* * *\n\n    기본형 \n        var num1 = new Number(값);\n        또는 var num1 = 값;\n        //new 키워드 없이 값만 입력해도 객체 생성가능.\n\n* * *\n\n<!-- more -->\n\n### Number 객체의 속성\n\n| 속성               | 설명                     |\n|--------------------|--------------------------|\n| MAX_VALUE          | 표현 가능한 가장 큰수    |\n| MIN_VALUE          | 표현 가능한 가장 작은 수 |\n| POSITIVE_INFINITY | 무한대 수 표기           |\n| NEGATIVE_INFINITY | 음의 무한대 수 표기      |\n| NaN                | 숫자가 아닌 경우 표기    |\n\n* * *\n\n### Number 객체의 메서드\n\n| 속성             | 설명                                                   |\n|------------------|--------------------------------------------------------|\n| toExponential(n) | 지수 표기법으로 소수점 n자리만큼 문자형 데이터로 반환  |\n| toFixed(n)       | 소수점 n자리만큼 반올림하여 문자형 데이터로 반환       |\n| toPrecision(n)   | 유효 숫자 n의 개수만큼 반올림하여 문자형 데이터로 반환 |\n| toString()       | 숫자형 데이터를 문자형으로 반환                        |\n| valueOf()        | 객체의 원래 값을 반환                                  |\n| parselnt(값)     | 데이터를 정수로 변환하여 반환                          |\n| parseFloat(값)   | 데이터를 실수로 변환하여 반환                          |\n\n\n* * *\n\n**사용 예제**\n\n```js  \n// javascript로 표현가능한 최댓값을 지수 표기법으로 반환  \ndocument.write(\"표현 가능한 가장 큰 수:\"+Number.MAX_VALUE, \"<br />\");  \n  \n// javascript로 표현가능한 최솟값을 지수 표기법으로 반환  \ndocument.write(\"표현 가능한 가장 작은 수:\"+Number.MIN_VALUE, \"<br />\");  \n  \n// javascript로 숫자로 표기할 수 없을때 반환되는 값 (Not a Number)  \ndocument.write(\"숫자가 아닌경우의 표기:\"+Number.NaN, \"<br />\");  \n  \n// javascript로 반환되는 무한댓 값  \ndocument.write(\"무한대 수 표기:\"+Number.POSITIVE_INFINITY, \"<br />\");  \n  \n// javascript로 반환되는 음의 무한댓값  \ndocument.write(\"음의 무한대 수 표기:\"+Number.NEGATIVE_INFINITY, \"<br />\");  \n    \n  \nvar num1=3.456789;  \nvar num2=700000;  \nvar num3=\"30.5px\";  \nvar num4=40;  \n  \n// num2에 저장된 값에 지정된 소수점 자리만큼 지수표기법으로 반환  \ndocument.write(num2.toExponential(1), \"<br />\"); // = 7.0 * 100000 = 7.0e+5  \n  \n// num1에 저장된 값에 소수점 2째 자리까지 반올림하여 표기  \ndocument.write(num1.toFixed(2), \"<br />\"); // 3.46  \n  \n// num1에 저장된 값에 지정된 숫자 2개에 반올림하여 표기  \ndocument.write(num1. toPrecision(2), \"<br />\"); // (3.4)56789 > 3.5  \n  \n// num1에 저장된 값을 문자형 데이터로 반환 \"\"  \ndocument.write(num1.toString(), \"<br />\"); // \"3.456789\"  \n  \n// num4에 저장된 값 반환  \ndocument.write(num4.valueOf(), \"<br />\"); // 40  \n  \n// num3에 저장된 \"30.5px\"에 정수만 남겨 반환하고 num4를 더합니다  \ndocument.write(parseInt(num3)+num4, \"<br />\"); // 30 + 40 = 70  \n  \n// num3에 저장된 \"30.5px\"에 실수만 남겨 반환하고 num4를 더합니다  \ndocument.write(parseFloat(num3)+num4, \"<br />\"); // 30.5 + 40 = 70.5  \n```","source":"_posts/숫자 객체 -JavaScript.md","raw":"---\ntitle: Number(숫자) 객체 -JavaScript\ndate: 2020-03-02 09:47:09\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\n* * *\n\n    기본형 \n        var num1 = new Number(값);\n        또는 var num1 = 값;\n        //new 키워드 없이 값만 입력해도 객체 생성가능.\n\n* * *\n\n<!-- more -->\n\n### Number 객체의 속성\n\n| 속성               | 설명                     |\n|--------------------|--------------------------|\n| MAX_VALUE          | 표현 가능한 가장 큰수    |\n| MIN_VALUE          | 표현 가능한 가장 작은 수 |\n| POSITIVE_INFINITY | 무한대 수 표기           |\n| NEGATIVE_INFINITY | 음의 무한대 수 표기      |\n| NaN                | 숫자가 아닌 경우 표기    |\n\n* * *\n\n### Number 객체의 메서드\n\n| 속성             | 설명                                                   |\n|------------------|--------------------------------------------------------|\n| toExponential(n) | 지수 표기법으로 소수점 n자리만큼 문자형 데이터로 반환  |\n| toFixed(n)       | 소수점 n자리만큼 반올림하여 문자형 데이터로 반환       |\n| toPrecision(n)   | 유효 숫자 n의 개수만큼 반올림하여 문자형 데이터로 반환 |\n| toString()       | 숫자형 데이터를 문자형으로 반환                        |\n| valueOf()        | 객체의 원래 값을 반환                                  |\n| parselnt(값)     | 데이터를 정수로 변환하여 반환                          |\n| parseFloat(값)   | 데이터를 실수로 변환하여 반환                          |\n\n\n* * *\n\n**사용 예제**\n\n```js  \n// javascript로 표현가능한 최댓값을 지수 표기법으로 반환  \ndocument.write(\"표현 가능한 가장 큰 수:\"+Number.MAX_VALUE, \"<br />\");  \n  \n// javascript로 표현가능한 최솟값을 지수 표기법으로 반환  \ndocument.write(\"표현 가능한 가장 작은 수:\"+Number.MIN_VALUE, \"<br />\");  \n  \n// javascript로 숫자로 표기할 수 없을때 반환되는 값 (Not a Number)  \ndocument.write(\"숫자가 아닌경우의 표기:\"+Number.NaN, \"<br />\");  \n  \n// javascript로 반환되는 무한댓 값  \ndocument.write(\"무한대 수 표기:\"+Number.POSITIVE_INFINITY, \"<br />\");  \n  \n// javascript로 반환되는 음의 무한댓값  \ndocument.write(\"음의 무한대 수 표기:\"+Number.NEGATIVE_INFINITY, \"<br />\");  \n    \n  \nvar num1=3.456789;  \nvar num2=700000;  \nvar num3=\"30.5px\";  \nvar num4=40;  \n  \n// num2에 저장된 값에 지정된 소수점 자리만큼 지수표기법으로 반환  \ndocument.write(num2.toExponential(1), \"<br />\"); // = 7.0 * 100000 = 7.0e+5  \n  \n// num1에 저장된 값에 소수점 2째 자리까지 반올림하여 표기  \ndocument.write(num1.toFixed(2), \"<br />\"); // 3.46  \n  \n// num1에 저장된 값에 지정된 숫자 2개에 반올림하여 표기  \ndocument.write(num1. toPrecision(2), \"<br />\"); // (3.4)56789 > 3.5  \n  \n// num1에 저장된 값을 문자형 데이터로 반환 \"\"  \ndocument.write(num1.toString(), \"<br />\"); // \"3.456789\"  \n  \n// num4에 저장된 값 반환  \ndocument.write(num4.valueOf(), \"<br />\"); // 40  \n  \n// num3에 저장된 \"30.5px\"에 정수만 남겨 반환하고 num4를 더합니다  \ndocument.write(parseInt(num3)+num4, \"<br />\"); // 30 + 40 = 70  \n  \n// num3에 저장된 \"30.5px\"에 실수만 남겨 반환하고 num4를 더합니다  \ndocument.write(parseFloat(num3)+num4, \"<br />\"); // 30.5 + 40 = 70.5  \n```","slug":"숫자 객체 -JavaScript","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrte0036qgvq54uqcb2o","content":"<hr>\n<pre><code>기본형 \n    var num1 = new Number(값);\n    또는 var num1 = 값;\n    //new 키워드 없이 값만 입력해도 객체 생성가능.</code></pre><hr>\n<a id=\"more\"></a>\n\n<h3 id=\"Number-객체의-속성\"><a href=\"#Number-객체의-속성\" class=\"headerlink\" title=\"Number 객체의 속성\"></a>Number 객체의 속성</h3><table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MAX_VALUE</td>\n<td>표현 가능한 가장 큰수</td>\n</tr>\n<tr>\n<td>MIN_VALUE</td>\n<td>표현 가능한 가장 작은 수</td>\n</tr>\n<tr>\n<td>POSITIVE_INFINITY</td>\n<td>무한대 수 표기</td>\n</tr>\n<tr>\n<td>NEGATIVE_INFINITY</td>\n<td>음의 무한대 수 표기</td>\n</tr>\n<tr>\n<td>NaN</td>\n<td>숫자가 아닌 경우 표기</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"Number-객체의-메서드\"><a href=\"#Number-객체의-메서드\" class=\"headerlink\" title=\"Number 객체의 메서드\"></a>Number 객체의 메서드</h3><table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>toExponential(n)</td>\n<td>지수 표기법으로 소수점 n자리만큼 문자형 데이터로 반환</td>\n</tr>\n<tr>\n<td>toFixed(n)</td>\n<td>소수점 n자리만큼 반올림하여 문자형 데이터로 반환</td>\n</tr>\n<tr>\n<td>toPrecision(n)</td>\n<td>유효 숫자 n의 개수만큼 반올림하여 문자형 데이터로 반환</td>\n</tr>\n<tr>\n<td>toString()</td>\n<td>숫자형 데이터를 문자형으로 반환</td>\n</tr>\n<tr>\n<td>valueOf()</td>\n<td>객체의 원래 값을 반환</td>\n</tr>\n<tr>\n<td>parselnt(값)</td>\n<td>데이터를 정수로 변환하여 반환</td>\n</tr>\n<tr>\n<td>parseFloat(값)</td>\n<td>데이터를 실수로 변환하여 반환</td>\n</tr>\n</tbody></table>\n<hr>\n<p><strong>사용 예제</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javascript로 표현가능한 최댓값을 지수 표기법으로 반환  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"표현 가능한 가장 큰 수:\"</span>+<span class=\"built_in\">Number</span>.MAX_VALUE, <span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// javascript로 표현가능한 최솟값을 지수 표기법으로 반환  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"표현 가능한 가장 작은 수:\"</span>+<span class=\"built_in\">Number</span>.MIN_VALUE, <span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// javascript로 숫자로 표기할 수 없을때 반환되는 값 (Not a Number)  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"숫자가 아닌경우의 표기:\"</span>+<span class=\"built_in\">Number</span>.NaN, <span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// javascript로 반환되는 무한댓 값  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"무한대 수 표기:\"</span>+<span class=\"built_in\">Number</span>.POSITIVE_INFINITY, <span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// javascript로 반환되는 음의 무한댓값  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"음의 무한대 수 표기:\"</span>+<span class=\"built_in\">Number</span>.NEGATIVE_INFINITY, <span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">    </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> num1=<span class=\"number\">3.456789</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> num2=<span class=\"number\">700000</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> num3=<span class=\"string\">\"30.5px\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> num4=<span class=\"number\">40</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// num2에 저장된 값에 지정된 소수점 자리만큼 지수표기법으로 반환  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(num2.toExponential(<span class=\"number\">1</span>), <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// = 7.0 * 100000 = 7.0e+5  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// num1에 저장된 값에 소수점 2째 자리까지 반올림하여 표기  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(num1.toFixed(<span class=\"number\">2</span>), <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 3.46  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// num1에 저장된 값에 지정된 숫자 2개에 반올림하여 표기  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(num1. toPrecision(<span class=\"number\">2</span>), <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// (3.4)56789 &gt; 3.5  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// num1에 저장된 값을 문자형 데이터로 반환 \"\"  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(num1.toString(), <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// \"3.456789\"  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// num4에 저장된 값 반환  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(num4.valueOf(), <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 40  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// num3에 저장된 \"30.5px\"에 정수만 남겨 반환하고 num4를 더합니다  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"built_in\">parseInt</span>(num3)+num4, <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 30 + 40 = 70  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// num3에 저장된 \"30.5px\"에 실수만 남겨 반환하고 num4를 더합니다  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"built_in\">parseFloat</span>(num3)+num4, <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 30.5 + 40 = 70.5</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<hr>\n<pre><code>기본형 \n    var num1 = new Number(값);\n    또는 var num1 = 값;\n    //new 키워드 없이 값만 입력해도 객체 생성가능.</code></pre><hr>","more":"<h3 id=\"Number-객체의-속성\"><a href=\"#Number-객체의-속성\" class=\"headerlink\" title=\"Number 객체의 속성\"></a>Number 객체의 속성</h3><table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MAX_VALUE</td>\n<td>표현 가능한 가장 큰수</td>\n</tr>\n<tr>\n<td>MIN_VALUE</td>\n<td>표현 가능한 가장 작은 수</td>\n</tr>\n<tr>\n<td>POSITIVE_INFINITY</td>\n<td>무한대 수 표기</td>\n</tr>\n<tr>\n<td>NEGATIVE_INFINITY</td>\n<td>음의 무한대 수 표기</td>\n</tr>\n<tr>\n<td>NaN</td>\n<td>숫자가 아닌 경우 표기</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"Number-객체의-메서드\"><a href=\"#Number-객체의-메서드\" class=\"headerlink\" title=\"Number 객체의 메서드\"></a>Number 객체의 메서드</h3><table>\n<thead>\n<tr>\n<th>속성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>toExponential(n)</td>\n<td>지수 표기법으로 소수점 n자리만큼 문자형 데이터로 반환</td>\n</tr>\n<tr>\n<td>toFixed(n)</td>\n<td>소수점 n자리만큼 반올림하여 문자형 데이터로 반환</td>\n</tr>\n<tr>\n<td>toPrecision(n)</td>\n<td>유효 숫자 n의 개수만큼 반올림하여 문자형 데이터로 반환</td>\n</tr>\n<tr>\n<td>toString()</td>\n<td>숫자형 데이터를 문자형으로 반환</td>\n</tr>\n<tr>\n<td>valueOf()</td>\n<td>객체의 원래 값을 반환</td>\n</tr>\n<tr>\n<td>parselnt(값)</td>\n<td>데이터를 정수로 변환하여 반환</td>\n</tr>\n<tr>\n<td>parseFloat(값)</td>\n<td>데이터를 실수로 변환하여 반환</td>\n</tr>\n</tbody></table>\n<hr>\n<p><strong>사용 예제</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javascript로 표현가능한 최댓값을 지수 표기법으로 반환  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"표현 가능한 가장 큰 수:\"</span>+<span class=\"built_in\">Number</span>.MAX_VALUE, <span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// javascript로 표현가능한 최솟값을 지수 표기법으로 반환  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"표현 가능한 가장 작은 수:\"</span>+<span class=\"built_in\">Number</span>.MIN_VALUE, <span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// javascript로 숫자로 표기할 수 없을때 반환되는 값 (Not a Number)  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"숫자가 아닌경우의 표기:\"</span>+<span class=\"built_in\">Number</span>.NaN, <span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// javascript로 반환되는 무한댓 값  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"무한대 수 표기:\"</span>+<span class=\"built_in\">Number</span>.POSITIVE_INFINITY, <span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// javascript로 반환되는 음의 무한댓값  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"음의 무한대 수 표기:\"</span>+<span class=\"built_in\">Number</span>.NEGATIVE_INFINITY, <span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">    </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> num1=<span class=\"number\">3.456789</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> num2=<span class=\"number\">700000</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> num3=<span class=\"string\">\"30.5px\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> num4=<span class=\"number\">40</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// num2에 저장된 값에 지정된 소수점 자리만큼 지수표기법으로 반환  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(num2.toExponential(<span class=\"number\">1</span>), <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// = 7.0 * 100000 = 7.0e+5  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// num1에 저장된 값에 소수점 2째 자리까지 반올림하여 표기  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(num1.toFixed(<span class=\"number\">2</span>), <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 3.46  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// num1에 저장된 값에 지정된 숫자 2개에 반올림하여 표기  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(num1. toPrecision(<span class=\"number\">2</span>), <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// (3.4)56789 &gt; 3.5  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// num1에 저장된 값을 문자형 데이터로 반환 \"\"  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(num1.toString(), <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// \"3.456789\"  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// num4에 저장된 값 반환  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(num4.valueOf(), <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 40  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// num3에 저장된 \"30.5px\"에 정수만 남겨 반환하고 num4를 더합니다  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"built_in\">parseInt</span>(num3)+num4, <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 30 + 40 = 70  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// num3에 저장된 \"30.5px\"에 실수만 남겨 반환하고 num4를 더합니다  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"built_in\">parseFloat</span>(num3)+num4, <span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 30.5 + 40 = 70.5</span></span><br></pre></td></tr></table></figure>"},{"title":"실행 컨텍스트 -Core JavaScript","disqusId":"tunas-blog-1","date":"2020-04-26T08:50:25.000Z","_content":"\n실행 컨텍스트(`execution context`)는 실행할 코드에 제공할 환경 정보를 모아놓은 객체로,\n자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념입니다.\n자바스크립트는 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(`호이스팅`), 외부 환경 정보를 구성하고, `this` 값을 설정하는 등의 동작을 수행하는데, 이로 인해 다른 언어에서는 발견할 수 없는 특이한 현상들이 발생합니다.\n\n* 실행 컨텍스트\n  * [실행 컨텍스트란?](/2020/04/26/실행-컨텍스트-Core-JavaScript/#execution_context)\n    * 스택과 큐\n  * [VariableEnvironment](/2020/04/26/실행-컨텍스트-Core-JavaScript/#VariableEnvironment)\n  * [LexicalEnvironment](/2020/04/26/실행-컨텍스트-Core-JavaScript/#LexicalEnvironment)\n    * environmentRecord와 호이스팅\n      * 호이스팅 규칙\n      * 함수 선언문과 함수 표현식\n    * 스코프, 스코프 체인, outerEnvironmentReference\n      * 스코프 체인\n      * 전역변수 와 지역변수\n  * [this](/2020/04/26/실행-컨텍스트-Core-JavaScript/#thisBinding)\n\n<!-- more -->\n\n------\n<h2 id=\"execution_context\">실행 컨텍스트란?</h2>\n\n------\n### 스택(stack)과 큐(queue)\n\n* 스택 : 출입구가 하나뿐인 데이터 구조\n비어있는 스택에 순서대로 데이터 a,b,c,d를 저정했다면 꺼낼 때는 반대로 d,c,b,a의 순서대로 꺼낸다.\n저장할 수 있는 데이터 스택이 넘치면 엔진에서 `RangeError: Maximum call stack size exceeded` 에러를 던집니다.\n\n\n* 큐 : 한쪽은 입구, 한쪽은 출구를 담당하는 양쪽 데이터 구조\n비어있는 큐에 순서대로 데이터 a,b,c,d를 저정했다면 꺼낼 때도 a,b,c,d의 순서대로 꺼낸다.\n\n------\n\n#### 엔진이 동일한 환경에 있는 코드들을 실행할 때\n\n필요한 환경정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련된 코드들을 실행하므로 코드의 환경과 순서를 보장받을 수 있습니다.\n\n흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것입니다.\n```js 실행 컨텍스트와 콜 스택\n1. var a = 1;\nfunction outer() {\n  function inner() {\n    console.log(a); // undefined\n    var a = 3;\n  }\n  3. inner(); \n  console.log(a); // 1\n}\n2. outer(); \nconsole.log(a); // 1\n```\n\n1. 처음 자바스크립트 코드를 실행하는 순간 전역 컨텍스트가 콜 스택에 담깁니다.\n(~~코드 내부에서 별도의 실행 명령 없이 브라우저에서 자동으로 실행하므로 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화 된다고 이해~~)\n\n2. 전역 컨텍스트와 관련된 코드들을 순차적으로 진행하다가 `outer()`를 호출하면 엔진은 `outer`에 대한 환경 정보를 수집해 `outer` 실행 컨텍스트를 생성한 후 콜 스택에 담습니다.\n이때, 콜 스택 내부에서 전역 컨텍스트 위에 `outer` 실행 컨텍스트가 놓인 상태가 되어 `outer` 실행 컨텍스트 즉, `outer` 함수 내부 코드들을 순차적으로 실행합니다. (전역 컨텍스트 일시정지)\n\n3. 마찬가지로 `outer` 실행 컨텍스트를 진행하다 `inner()`함수의 실행 컨텍스트가 콜 스택의 가장 위에 담기면 `outer` 컨텍스트는 일시정지되고 `inner` 함수 내부 코드를 실행합니다.\n\n* 실행 컨텍스트와 콜 스택\n![실행 컨텍스트와 콜 스택](/images/context_callStack.PNG)\n\n<u>실행 컨텍스트가 콜 스택의 맨위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하는 시점.\n기존의 컨텍스트는 새로 쌓인 컨텍스트보다 아래에 위치할 수 밖에 없음</u>\n\n<mark>이렇게 어떤 컨텍스트가 활성화될 때 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는데 필요한 환경 정보들을 수집하여 실행 컨텍스트 객체에 저장함.</mark>\n\n이 객체는 엔진이 활용 목적으로 생성할 뿐 개발자 코드로 확인할 수는 없음\n이에 담기는 정보들은 다음과 같습니다.\n\n  * `VariableEnvironment` : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보.\n  선언 시점의 `LexicalEnvironment`의 스냅샷(`snapshot`)으로, 변경 사항은 반영되지 않음.\n\n  * `LexicalEnvironment` : 처음에는 `VariableEnvironment`와 같지만 변경 사항이 실시간으로 반영되는 점이 다름.\n\n  * `ThisBinding` : `this` 식별자가 바라봐야 할 대상 객체\n\n------\n<h2 id=\"VariableEnvironment\">VariableEnvironment</h2>\n\n`VariableEnvironment`에 담기는 내용은 `LexicalEnvironment`와 같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다릅니다.\n\n실행 컨텍스트를 생성할 때 `VariableEnvironment`에 정보를 먼저 담은 후\n이를 그대로 복사하여 `LexicalEnvironment`를 만들고, 생성된 `LexicalEnvironment`를 활용합니다.\n\n`VariableEnvironment`와 `LexicalEnvironment` 는 초기화 과정 중에는 사실상 완전히 동일하고 둘 다 내부에 `environmentRecord`와 `outer-EnvironmentReference`로 구성되어 있습니다. \n\n다음의 `LexicalEnvironment`를 살펴보며 자세한 내용과 둘의 코드 진행과정 차이를 알아봅시다.\n\n------\n<h2 id=\"LexicalEnvironment\">LexicalEnvironment</h2>\n\n`LexicalEnvironment`은 개발자 용어로 `정적 환경`으로 통하나 <u>실제 의미가 동일 하지는 않습니다.</u>\n커뮤니케이션을 위해 정적 환경으로 불리지만 `LexicalEnvironment`를 현재 컨텍스트의 내부에는 식별자들이 있고 그 외부 정보를 다른 객체가 참조하도록 구성되어 있다는 식의 <u>컨텍스트 구성 환경 정보들을 모아놓은</u> 느낌으로 이해합시다.\n\n------\n### environmentRecord와 호이스팅\n\n`environmentRecord`에는 현재 컨텍스트와 관련된 코드의 <mark>식별자 정보</mark>들이 저장됩니다.\n\n* 컨텍스트를 구성하는 함수에 지정된 <mark>매개변수 식별자</mark>\n\n* 선언한 함수가 있을 경우 <mark>그 함수 자체</mark>\n\n* var등으로 선언된 <mark>변수의 식별자 등</mark>\n\n**컨텍스트 내부 전체를 처음부터 끝까지 순서대로 수집합니다.**\n\n* 참고 :\n<mark>전역 실행 컨텍스트는 변수 객체를 생성하지 않습니다.</mark>\n자바스크립트 구동 환경이 별도로 제공하는 객체 즉, <mark>전역 객체를 활용합니다</mark>. (브라우저의 window, Node.js의 global 객체 등)\n이들은 자바스크립트 내장 객체가 아닌 호스트 객체로 분류됩니다.\n\n------\n#### 호이스팅 규칙\n\n`environmentRecord`가 현재 컨텍스트와 관련된 변수 정보를 수집한 상태는\n컨텍스트의 코드가 실행되기 전의 상태입니다. 코드가 실행되기 전에 엔진이 이미 해당 환경에 속한 코드의 변수명을 모두 알고 있는 상태가 되는 것 입니다.\n\n이 상태를 엔진이 식별자 정보들을 최상단으로 끌어올려놓고 순차적으로 코드를 실행하는 것처럼 보여\n<mark>변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념으로 등장한 개념이 호이스팅<mark> 입니다.\n\n엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주하는 개념입니다.\n\n```js 함수 선언의 호이스팅\nfunction a() {\n  1. console.log(b); // (1)\n  var b = 'bbb'; // 수집 대상 1(변수 선언)\n  2. console.log(b); // (2)\n  function b() {} // 수집 대상 2(함수 선언)\n  3. console.log(b); // (3)\n}\na();\n// function b(){}\n// bbb\n// bbb\n```\n\n* `environmentRecord`에는 매개변수의 이름, 함수 선언, 변수명 들이 담깁니다.\n엔진은 이러한 호이스팅으로 인해 코드 실행전 부터 컨텍스트 구성 정보를 가지고 있습니다.\n\n\n1. `environmentRecord`에 의해 `var b;` 와 `var b = function b (){}`가 최상단에 위치한다고 볼 수 있습니다. \n`function b(){}` 를 참조하여 출력됩니다.\n\n\n2. 3. `var b = 'bbb'` 으로 할당된 후 이므로 `bbb`가 출력됩니다.\n\n------\n#### 함수 선언문과 함수 표현식\n\n* 함수 선언문 : `function` 정의부만 존재하고 별도의 할당 명령이 없는 것\n<mark>반드시 함수명이 정의되어 있어야 함.</mark>\n\n* 함수 표현식 : 정의한 `function`을 별도의 변수에 할당하는 것\n<mark>함수명이 없어도 됨.</mark>\n\n```js 함수를 정의하는 세 가지 방식\nfunction a() {\n  /* ... */\n} // 함수 선언문. 함수명 a가 곧 변수명.\na(); // 실행 OK.\n\nvar b = function() {\n  /* ... */\n}; // (익명) 함수 표현식. 변수명 b가 곧 함수명.\nb(); // 실행 OK.\n\nvar c = function d() {\n  /* ... */\n}; // 기명 함수 표현식. 변수명은 c, 함수명은 d.\nc(); // 실행 OK.\nd(); // 에러!\n```\n\n* 함수 선언문과 함수 표현식 호이스팅 시 차이.\n\n```js 호이스팅 전 원본 코드\nconsole.log(sum(1, 2));\nconsole.log(multiply(3, 4));\n\nfunction sum(a, b) {\n  // 함수 선언문 sum\n  return a + b;\n}\n\nvar multiply = function(a, b) {\n  // 함수 표현식 multiply\n  return a * b;\n};\n```\n\n```js 호이스팅 후 함수 표현식과 선언문의 차이\nvar sum = function sum(a, b) {\n  // 함수 선언문은 전체를 호이스팅합니다.\n  return a + b;\n};\nvar multiply; // 변수는 선언부만 끌어올립니다.\nconsole.log(sum(1, 2));\nconsole.log(multiply(3, 4));\n\nmultiply = function(a, b) {\n  // 변수의 할당부는 원래 자리에 남겨둡니다.\n  return a * b;\n};\n```\n\n* 위에서 볼 수 있듯 함수 선언문은 함수 전체를 호이스팅\n\n* 함수 표현식은 변수 부분만 호이스팅, 할당하는 부분은 호이스팅 하지 않음.\n\n* `console.log(multiply(3,4))` 시점의 `multiply`에는 값이 할당돼 있지 않습니다.\n따라서 `multiply is not a function` 에러 메시지가 출력되고 , 에러로 인해 아래 할당부 코드는 실행되지 않고 종료됩니다.\n\n------\n### 스코프, 스코프 체인, outerEnvironmentReference\n\n* 스코프(scope) : 식별자에 대한 유효범위\n\n* 스코프 체인 : 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것\n\n* outerEnvironmentReference : 스코프 체인을 가능하게 하는 `LexicalEnvironment`의 두 번째 수집자료 `outerEnvironmentReference`\n\n------\n#### 스코프 체인\n\n`outerEnvironmentReference`는 현재 호출된 함수가 <mark>선언될 당시의 LexicalEnvironment</mark>를 참조합니다. (== 콜 스택 상에서 실행 컨텍스트가 활성화된 상태)\n\n```js outerEnvironmentReference 동작 예시\nfunction a (){\n  //(...) \n  function b (){\n    //(...)\n    function c (){\n      //(...)\n    }\n  }\n}\n```\n\na 함수 내부에 b 함수를 선언하고 다시 b 함수 내부에 c 함수를 선언했습니다.\n\n* 이 경우 `함수 c`의 `outerEnvironmentReference`는 `함수 b`의 `LexicalEnvironment`를 참조합니다.\n`함수 b`의 `LexicalEnvironment`에 있는 `outerEnvironmentReference`는 다시 `함수 a`의 `LexicalEnvironment`를 참조합니다.\n\n* 이처럼 `outerEnvironmentReference`는 연결리스트 형태를 가지고 있고 선언 시점의 `LexicalEnvironment`를 계속 찾아 올라가면 마지막에는 전역 컨텍스트의 `LexicalEnvironment`가 있을 것입니다.\n\n* `outerEnvironmentReference`는 <mark>자신이 선언된 시점의 LexicalEnvironment만 참조</mark>하고 있으므로 가장 가까운 요소부터 차례로 접근할 수 밖에 없습니다.\n\n이런 구조적 특성 덕분에 여러 스코프에서 동일한 스코프를 선언한 경우에는 <mark>무조건 스코프 체인 상에서 가장 먼저 발견된 식별자만 접근 가능</mark> 하게 됩니다.\n\n```js 개발자 도구로 스코프 체인 확인법 -크롬\nvar a = 1;\nvar outer = function() {\n  var b = 2;\n  var inner = function() {\n    console.dir(inner);\n  };\n  inner();\n};\nouter();\n```\n\n* 함수 내부에 함수를 출력하는 방법으로 현재 실행 컨텍스트를 제외한 상위 스코프 정보들을 개발자 도구에서 확인할 수 있습니다. (`debugger` 사용시 더욱 자세한 정보 확인 가능)\n\n------\n#### 전역변수와 지역변수\n\n* 전역변수 : 전역 스코프에서 선언한 변수\n\n* 지역변수 : 전역 스코프가 아닌 함수 스코프 또는 블록 스코프 내부에서 선언한 변수 \n지역 변수는 선언된 스코프 외부에서 접근할 수 없음.\n\n------\n<h2 id=\"thisBinding\">this</h2>\n\n실행 컨텍스트의 `thisBinding`에는 `this`로 지정된 객체가 저장됩니다.\n실행 컨텍스트 활성화 당시에 `this`가 지정되지 않으면 `this`는 전역 객체를 참조하게 됩니다.\n\n함수를 호출하는 방식 등 사용되는 방법에 따라 `this`가 참조하는 대상이 변하게 되므로\n`this`에 자세한 내용은 따로 다루도록 하겠습니다.","source":"_posts/실행-컨텍스트-Core-JavaScript.md","raw":"---\ntitle: 실행 컨텍스트 -Core JavaScript\ndisqusId: tunas-blog-1\ntags:\n  - Core JavaScript\n  - JavaScript\ndate: 2020-04-26 17:50:25\ncategories: Core JavaScript\n---\n\n실행 컨텍스트(`execution context`)는 실행할 코드에 제공할 환경 정보를 모아놓은 객체로,\n자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념입니다.\n자바스크립트는 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(`호이스팅`), 외부 환경 정보를 구성하고, `this` 값을 설정하는 등의 동작을 수행하는데, 이로 인해 다른 언어에서는 발견할 수 없는 특이한 현상들이 발생합니다.\n\n* 실행 컨텍스트\n  * [실행 컨텍스트란?](/2020/04/26/실행-컨텍스트-Core-JavaScript/#execution_context)\n    * 스택과 큐\n  * [VariableEnvironment](/2020/04/26/실행-컨텍스트-Core-JavaScript/#VariableEnvironment)\n  * [LexicalEnvironment](/2020/04/26/실행-컨텍스트-Core-JavaScript/#LexicalEnvironment)\n    * environmentRecord와 호이스팅\n      * 호이스팅 규칙\n      * 함수 선언문과 함수 표현식\n    * 스코프, 스코프 체인, outerEnvironmentReference\n      * 스코프 체인\n      * 전역변수 와 지역변수\n  * [this](/2020/04/26/실행-컨텍스트-Core-JavaScript/#thisBinding)\n\n<!-- more -->\n\n------\n<h2 id=\"execution_context\">실행 컨텍스트란?</h2>\n\n------\n### 스택(stack)과 큐(queue)\n\n* 스택 : 출입구가 하나뿐인 데이터 구조\n비어있는 스택에 순서대로 데이터 a,b,c,d를 저정했다면 꺼낼 때는 반대로 d,c,b,a의 순서대로 꺼낸다.\n저장할 수 있는 데이터 스택이 넘치면 엔진에서 `RangeError: Maximum call stack size exceeded` 에러를 던집니다.\n\n\n* 큐 : 한쪽은 입구, 한쪽은 출구를 담당하는 양쪽 데이터 구조\n비어있는 큐에 순서대로 데이터 a,b,c,d를 저정했다면 꺼낼 때도 a,b,c,d의 순서대로 꺼낸다.\n\n------\n\n#### 엔진이 동일한 환경에 있는 코드들을 실행할 때\n\n필요한 환경정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련된 코드들을 실행하므로 코드의 환경과 순서를 보장받을 수 있습니다.\n\n흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것입니다.\n```js 실행 컨텍스트와 콜 스택\n1. var a = 1;\nfunction outer() {\n  function inner() {\n    console.log(a); // undefined\n    var a = 3;\n  }\n  3. inner(); \n  console.log(a); // 1\n}\n2. outer(); \nconsole.log(a); // 1\n```\n\n1. 처음 자바스크립트 코드를 실행하는 순간 전역 컨텍스트가 콜 스택에 담깁니다.\n(~~코드 내부에서 별도의 실행 명령 없이 브라우저에서 자동으로 실행하므로 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화 된다고 이해~~)\n\n2. 전역 컨텍스트와 관련된 코드들을 순차적으로 진행하다가 `outer()`를 호출하면 엔진은 `outer`에 대한 환경 정보를 수집해 `outer` 실행 컨텍스트를 생성한 후 콜 스택에 담습니다.\n이때, 콜 스택 내부에서 전역 컨텍스트 위에 `outer` 실행 컨텍스트가 놓인 상태가 되어 `outer` 실행 컨텍스트 즉, `outer` 함수 내부 코드들을 순차적으로 실행합니다. (전역 컨텍스트 일시정지)\n\n3. 마찬가지로 `outer` 실행 컨텍스트를 진행하다 `inner()`함수의 실행 컨텍스트가 콜 스택의 가장 위에 담기면 `outer` 컨텍스트는 일시정지되고 `inner` 함수 내부 코드를 실행합니다.\n\n* 실행 컨텍스트와 콜 스택\n![실행 컨텍스트와 콜 스택](/images/context_callStack.PNG)\n\n<u>실행 컨텍스트가 콜 스택의 맨위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하는 시점.\n기존의 컨텍스트는 새로 쌓인 컨텍스트보다 아래에 위치할 수 밖에 없음</u>\n\n<mark>이렇게 어떤 컨텍스트가 활성화될 때 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는데 필요한 환경 정보들을 수집하여 실행 컨텍스트 객체에 저장함.</mark>\n\n이 객체는 엔진이 활용 목적으로 생성할 뿐 개발자 코드로 확인할 수는 없음\n이에 담기는 정보들은 다음과 같습니다.\n\n  * `VariableEnvironment` : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보.\n  선언 시점의 `LexicalEnvironment`의 스냅샷(`snapshot`)으로, 변경 사항은 반영되지 않음.\n\n  * `LexicalEnvironment` : 처음에는 `VariableEnvironment`와 같지만 변경 사항이 실시간으로 반영되는 점이 다름.\n\n  * `ThisBinding` : `this` 식별자가 바라봐야 할 대상 객체\n\n------\n<h2 id=\"VariableEnvironment\">VariableEnvironment</h2>\n\n`VariableEnvironment`에 담기는 내용은 `LexicalEnvironment`와 같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다릅니다.\n\n실행 컨텍스트를 생성할 때 `VariableEnvironment`에 정보를 먼저 담은 후\n이를 그대로 복사하여 `LexicalEnvironment`를 만들고, 생성된 `LexicalEnvironment`를 활용합니다.\n\n`VariableEnvironment`와 `LexicalEnvironment` 는 초기화 과정 중에는 사실상 완전히 동일하고 둘 다 내부에 `environmentRecord`와 `outer-EnvironmentReference`로 구성되어 있습니다. \n\n다음의 `LexicalEnvironment`를 살펴보며 자세한 내용과 둘의 코드 진행과정 차이를 알아봅시다.\n\n------\n<h2 id=\"LexicalEnvironment\">LexicalEnvironment</h2>\n\n`LexicalEnvironment`은 개발자 용어로 `정적 환경`으로 통하나 <u>실제 의미가 동일 하지는 않습니다.</u>\n커뮤니케이션을 위해 정적 환경으로 불리지만 `LexicalEnvironment`를 현재 컨텍스트의 내부에는 식별자들이 있고 그 외부 정보를 다른 객체가 참조하도록 구성되어 있다는 식의 <u>컨텍스트 구성 환경 정보들을 모아놓은</u> 느낌으로 이해합시다.\n\n------\n### environmentRecord와 호이스팅\n\n`environmentRecord`에는 현재 컨텍스트와 관련된 코드의 <mark>식별자 정보</mark>들이 저장됩니다.\n\n* 컨텍스트를 구성하는 함수에 지정된 <mark>매개변수 식별자</mark>\n\n* 선언한 함수가 있을 경우 <mark>그 함수 자체</mark>\n\n* var등으로 선언된 <mark>변수의 식별자 등</mark>\n\n**컨텍스트 내부 전체를 처음부터 끝까지 순서대로 수집합니다.**\n\n* 참고 :\n<mark>전역 실행 컨텍스트는 변수 객체를 생성하지 않습니다.</mark>\n자바스크립트 구동 환경이 별도로 제공하는 객체 즉, <mark>전역 객체를 활용합니다</mark>. (브라우저의 window, Node.js의 global 객체 등)\n이들은 자바스크립트 내장 객체가 아닌 호스트 객체로 분류됩니다.\n\n------\n#### 호이스팅 규칙\n\n`environmentRecord`가 현재 컨텍스트와 관련된 변수 정보를 수집한 상태는\n컨텍스트의 코드가 실행되기 전의 상태입니다. 코드가 실행되기 전에 엔진이 이미 해당 환경에 속한 코드의 변수명을 모두 알고 있는 상태가 되는 것 입니다.\n\n이 상태를 엔진이 식별자 정보들을 최상단으로 끌어올려놓고 순차적으로 코드를 실행하는 것처럼 보여\n<mark>변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념으로 등장한 개념이 호이스팅<mark> 입니다.\n\n엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주하는 개념입니다.\n\n```js 함수 선언의 호이스팅\nfunction a() {\n  1. console.log(b); // (1)\n  var b = 'bbb'; // 수집 대상 1(변수 선언)\n  2. console.log(b); // (2)\n  function b() {} // 수집 대상 2(함수 선언)\n  3. console.log(b); // (3)\n}\na();\n// function b(){}\n// bbb\n// bbb\n```\n\n* `environmentRecord`에는 매개변수의 이름, 함수 선언, 변수명 들이 담깁니다.\n엔진은 이러한 호이스팅으로 인해 코드 실행전 부터 컨텍스트 구성 정보를 가지고 있습니다.\n\n\n1. `environmentRecord`에 의해 `var b;` 와 `var b = function b (){}`가 최상단에 위치한다고 볼 수 있습니다. \n`function b(){}` 를 참조하여 출력됩니다.\n\n\n2. 3. `var b = 'bbb'` 으로 할당된 후 이므로 `bbb`가 출력됩니다.\n\n------\n#### 함수 선언문과 함수 표현식\n\n* 함수 선언문 : `function` 정의부만 존재하고 별도의 할당 명령이 없는 것\n<mark>반드시 함수명이 정의되어 있어야 함.</mark>\n\n* 함수 표현식 : 정의한 `function`을 별도의 변수에 할당하는 것\n<mark>함수명이 없어도 됨.</mark>\n\n```js 함수를 정의하는 세 가지 방식\nfunction a() {\n  /* ... */\n} // 함수 선언문. 함수명 a가 곧 변수명.\na(); // 실행 OK.\n\nvar b = function() {\n  /* ... */\n}; // (익명) 함수 표현식. 변수명 b가 곧 함수명.\nb(); // 실행 OK.\n\nvar c = function d() {\n  /* ... */\n}; // 기명 함수 표현식. 변수명은 c, 함수명은 d.\nc(); // 실행 OK.\nd(); // 에러!\n```\n\n* 함수 선언문과 함수 표현식 호이스팅 시 차이.\n\n```js 호이스팅 전 원본 코드\nconsole.log(sum(1, 2));\nconsole.log(multiply(3, 4));\n\nfunction sum(a, b) {\n  // 함수 선언문 sum\n  return a + b;\n}\n\nvar multiply = function(a, b) {\n  // 함수 표현식 multiply\n  return a * b;\n};\n```\n\n```js 호이스팅 후 함수 표현식과 선언문의 차이\nvar sum = function sum(a, b) {\n  // 함수 선언문은 전체를 호이스팅합니다.\n  return a + b;\n};\nvar multiply; // 변수는 선언부만 끌어올립니다.\nconsole.log(sum(1, 2));\nconsole.log(multiply(3, 4));\n\nmultiply = function(a, b) {\n  // 변수의 할당부는 원래 자리에 남겨둡니다.\n  return a * b;\n};\n```\n\n* 위에서 볼 수 있듯 함수 선언문은 함수 전체를 호이스팅\n\n* 함수 표현식은 변수 부분만 호이스팅, 할당하는 부분은 호이스팅 하지 않음.\n\n* `console.log(multiply(3,4))` 시점의 `multiply`에는 값이 할당돼 있지 않습니다.\n따라서 `multiply is not a function` 에러 메시지가 출력되고 , 에러로 인해 아래 할당부 코드는 실행되지 않고 종료됩니다.\n\n------\n### 스코프, 스코프 체인, outerEnvironmentReference\n\n* 스코프(scope) : 식별자에 대한 유효범위\n\n* 스코프 체인 : 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것\n\n* outerEnvironmentReference : 스코프 체인을 가능하게 하는 `LexicalEnvironment`의 두 번째 수집자료 `outerEnvironmentReference`\n\n------\n#### 스코프 체인\n\n`outerEnvironmentReference`는 현재 호출된 함수가 <mark>선언될 당시의 LexicalEnvironment</mark>를 참조합니다. (== 콜 스택 상에서 실행 컨텍스트가 활성화된 상태)\n\n```js outerEnvironmentReference 동작 예시\nfunction a (){\n  //(...) \n  function b (){\n    //(...)\n    function c (){\n      //(...)\n    }\n  }\n}\n```\n\na 함수 내부에 b 함수를 선언하고 다시 b 함수 내부에 c 함수를 선언했습니다.\n\n* 이 경우 `함수 c`의 `outerEnvironmentReference`는 `함수 b`의 `LexicalEnvironment`를 참조합니다.\n`함수 b`의 `LexicalEnvironment`에 있는 `outerEnvironmentReference`는 다시 `함수 a`의 `LexicalEnvironment`를 참조합니다.\n\n* 이처럼 `outerEnvironmentReference`는 연결리스트 형태를 가지고 있고 선언 시점의 `LexicalEnvironment`를 계속 찾아 올라가면 마지막에는 전역 컨텍스트의 `LexicalEnvironment`가 있을 것입니다.\n\n* `outerEnvironmentReference`는 <mark>자신이 선언된 시점의 LexicalEnvironment만 참조</mark>하고 있으므로 가장 가까운 요소부터 차례로 접근할 수 밖에 없습니다.\n\n이런 구조적 특성 덕분에 여러 스코프에서 동일한 스코프를 선언한 경우에는 <mark>무조건 스코프 체인 상에서 가장 먼저 발견된 식별자만 접근 가능</mark> 하게 됩니다.\n\n```js 개발자 도구로 스코프 체인 확인법 -크롬\nvar a = 1;\nvar outer = function() {\n  var b = 2;\n  var inner = function() {\n    console.dir(inner);\n  };\n  inner();\n};\nouter();\n```\n\n* 함수 내부에 함수를 출력하는 방법으로 현재 실행 컨텍스트를 제외한 상위 스코프 정보들을 개발자 도구에서 확인할 수 있습니다. (`debugger` 사용시 더욱 자세한 정보 확인 가능)\n\n------\n#### 전역변수와 지역변수\n\n* 전역변수 : 전역 스코프에서 선언한 변수\n\n* 지역변수 : 전역 스코프가 아닌 함수 스코프 또는 블록 스코프 내부에서 선언한 변수 \n지역 변수는 선언된 스코프 외부에서 접근할 수 없음.\n\n------\n<h2 id=\"thisBinding\">this</h2>\n\n실행 컨텍스트의 `thisBinding`에는 `this`로 지정된 객체가 저장됩니다.\n실행 컨텍스트 활성화 당시에 `this`가 지정되지 않으면 `this`는 전역 객체를 참조하게 됩니다.\n\n함수를 호출하는 방식 등 사용되는 방법에 따라 `this`가 참조하는 대상이 변하게 되므로\n`this`에 자세한 내용은 따로 다루도록 하겠습니다.","slug":"실행-컨텍스트-Core-JavaScript","published":1,"updated":"2020-05-08T11:32:22.204Z","_id":"ck9iqcrtf0039qgvq115a60v6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>실행 컨텍스트(<code>execution context</code>)는 실행할 코드에 제공할 환경 정보를 모아놓은 객체로,<br>자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념입니다.<br>자바스크립트는 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(<code>호이스팅</code>), 외부 환경 정보를 구성하고, <code>this</code> 값을 설정하는 등의 동작을 수행하는데, 이로 인해 다른 언어에서는 발견할 수 없는 특이한 현상들이 발생합니다.</p>\n<ul>\n<li>실행 컨텍스트<ul>\n<li><a href=\"/2020/04/26/실행-컨텍스트-Core-JavaScript/#execution_context\">실행 컨텍스트란?</a><ul>\n<li>스택과 큐</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/26/실행-컨텍스트-Core-JavaScript/#VariableEnvironment\">VariableEnvironment</a></li>\n<li><a href=\"/2020/04/26/실행-컨텍스트-Core-JavaScript/#LexicalEnvironment\">LexicalEnvironment</a><ul>\n<li>environmentRecord와 호이스팅<ul>\n<li>호이스팅 규칙</li>\n<li>함수 선언문과 함수 표현식</li>\n</ul>\n</li>\n<li>스코프, 스코프 체인, outerEnvironmentReference<ul>\n<li>스코프 체인</li>\n<li>전역변수 와 지역변수</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/26/실행-컨텍스트-Core-JavaScript/#thisBinding\">this</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"execution_context\">실행 컨텍스트란?</h2>\n\n<hr>\n<h3 id=\"스택-stack-과-큐-queue\"><a href=\"#스택-stack-과-큐-queue\" class=\"headerlink\" title=\"스택(stack)과 큐(queue)\"></a>스택(stack)과 큐(queue)</h3><ul>\n<li>스택 : 출입구가 하나뿐인 데이터 구조<br>비어있는 스택에 순서대로 데이터 a,b,c,d를 저정했다면 꺼낼 때는 반대로 d,c,b,a의 순서대로 꺼낸다.<br>저장할 수 있는 데이터 스택이 넘치면 엔진에서 <code>RangeError: Maximum call stack size exceeded</code> 에러를 던집니다.</li>\n</ul>\n<ul>\n<li>큐 : 한쪽은 입구, 한쪽은 출구를 담당하는 양쪽 데이터 구조<br>비어있는 큐에 순서대로 데이터 a,b,c,d를 저정했다면 꺼낼 때도 a,b,c,d의 순서대로 꺼낸다.</li>\n</ul>\n<hr>\n<h4 id=\"엔진이-동일한-환경에-있는-코드들을-실행할-때\"><a href=\"#엔진이-동일한-환경에-있는-코드들을-실행할-때\" class=\"headerlink\" title=\"엔진이 동일한 환경에 있는 코드들을 실행할 때\"></a>엔진이 동일한 환경에 있는 코드들을 실행할 때</h4><p>필요한 환경정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련된 코드들을 실행하므로 코드의 환경과 순서를 보장받을 수 있습니다.</p>\n<p>흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>실행 컨텍스트와 콜 스택</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"number\">3.</span> inner(); </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">2.</span> outer(); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>처음 자바스크립트 코드를 실행하는 순간 전역 컨텍스트가 콜 스택에 담깁니다.<br>(<del>코드 내부에서 별도의 실행 명령 없이 브라우저에서 자동으로 실행하므로 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화 된다고 이해</del>)</p>\n</li>\n<li><p>전역 컨텍스트와 관련된 코드들을 순차적으로 진행하다가 <code>outer()</code>를 호출하면 엔진은 <code>outer</code>에 대한 환경 정보를 수집해 <code>outer</code> 실행 컨텍스트를 생성한 후 콜 스택에 담습니다.<br>이때, 콜 스택 내부에서 전역 컨텍스트 위에 <code>outer</code> 실행 컨텍스트가 놓인 상태가 되어 <code>outer</code> 실행 컨텍스트 즉, <code>outer</code> 함수 내부 코드들을 순차적으로 실행합니다. (전역 컨텍스트 일시정지)</p>\n</li>\n<li><p>마찬가지로 <code>outer</code> 실행 컨텍스트를 진행하다 <code>inner()</code>함수의 실행 컨텍스트가 콜 스택의 가장 위에 담기면 <code>outer</code> 컨텍스트는 일시정지되고 <code>inner</code> 함수 내부 코드를 실행합니다.</p>\n</li>\n</ol>\n<ul>\n<li>실행 컨텍스트와 콜 스택<br><img src=\"/images/context_callStack.PNG\" alt=\"실행 컨텍스트와 콜 스택\"></li>\n</ul>\n<p><u>실행 컨텍스트가 콜 스택의 맨위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하는 시점.<br>기존의 컨텍스트는 새로 쌓인 컨텍스트보다 아래에 위치할 수 밖에 없음</u></p>\n<p><mark>이렇게 어떤 컨텍스트가 활성화될 때 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는데 필요한 환경 정보들을 수집하여 실행 컨텍스트 객체에 저장함.</mark></p>\n<p>이 객체는 엔진이 활용 목적으로 생성할 뿐 개발자 코드로 확인할 수는 없음<br>이에 담기는 정보들은 다음과 같습니다.</p>\n<ul>\n<li><p><code>VariableEnvironment</code> : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보.<br>선언 시점의 <code>LexicalEnvironment</code>의 스냅샷(<code>snapshot</code>)으로, 변경 사항은 반영되지 않음.</p>\n</li>\n<li><p><code>LexicalEnvironment</code> : 처음에는 <code>VariableEnvironment</code>와 같지만 변경 사항이 실시간으로 반영되는 점이 다름.</p>\n</li>\n<li><p><code>ThisBinding</code> : <code>this</code> 식별자가 바라봐야 할 대상 객체</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"VariableEnvironment\">VariableEnvironment</h2>\n\n<p><code>VariableEnvironment</code>에 담기는 내용은 <code>LexicalEnvironment</code>와 같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다릅니다.</p>\n<p>실행 컨텍스트를 생성할 때 <code>VariableEnvironment</code>에 정보를 먼저 담은 후<br>이를 그대로 복사하여 <code>LexicalEnvironment</code>를 만들고, 생성된 <code>LexicalEnvironment</code>를 활용합니다.</p>\n<p><code>VariableEnvironment</code>와 <code>LexicalEnvironment</code> 는 초기화 과정 중에는 사실상 완전히 동일하고 둘 다 내부에 <code>environmentRecord</code>와 <code>outer-EnvironmentReference</code>로 구성되어 있습니다. </p>\n<p>다음의 <code>LexicalEnvironment</code>를 살펴보며 자세한 내용과 둘의 코드 진행과정 차이를 알아봅시다.</p>\n<hr>\n<h2 id=\"LexicalEnvironment\">LexicalEnvironment</h2>\n\n<p><code>LexicalEnvironment</code>은 개발자 용어로 <code>정적 환경</code>으로 통하나 <u>실제 의미가 동일 하지는 않습니다.</u><br>커뮤니케이션을 위해 정적 환경으로 불리지만 <code>LexicalEnvironment</code>를 현재 컨텍스트의 내부에는 식별자들이 있고 그 외부 정보를 다른 객체가 참조하도록 구성되어 있다는 식의 <u>컨텍스트 구성 환경 정보들을 모아놓은</u> 느낌으로 이해합시다.</p>\n<hr>\n<h3 id=\"environmentRecord와-호이스팅\"><a href=\"#environmentRecord와-호이스팅\" class=\"headerlink\" title=\"environmentRecord와 호이스팅\"></a>environmentRecord와 호이스팅</h3><p><code>environmentRecord</code>에는 현재 컨텍스트와 관련된 코드의 <mark>식별자 정보</mark>들이 저장됩니다.</p>\n<ul>\n<li><p>컨텍스트를 구성하는 함수에 지정된 <mark>매개변수 식별자</mark></p>\n</li>\n<li><p>선언한 함수가 있을 경우 <mark>그 함수 자체</mark></p>\n</li>\n<li><p>var등으로 선언된 <mark>변수의 식별자 등</mark></p>\n</li>\n</ul>\n<p><strong>컨텍스트 내부 전체를 처음부터 끝까지 순서대로 수집합니다.</strong></p>\n<ul>\n<li>참고 :<br><mark>전역 실행 컨텍스트는 변수 객체를 생성하지 않습니다.</mark><br>자바스크립트 구동 환경이 별도로 제공하는 객체 즉, <mark>전역 객체를 활용합니다</mark>. (브라우저의 window, Node.js의 global 객체 등)<br>이들은 자바스크립트 내장 객체가 아닌 호스트 객체로 분류됩니다.</li>\n</ul>\n<hr>\n<h4 id=\"호이스팅-규칙\"><a href=\"#호이스팅-규칙\" class=\"headerlink\" title=\"호이스팅 규칙\"></a>호이스팅 규칙</h4><p><code>environmentRecord</code>가 현재 컨텍스트와 관련된 변수 정보를 수집한 상태는<br>컨텍스트의 코드가 실행되기 전의 상태입니다. 코드가 실행되기 전에 엔진이 이미 해당 환경에 속한 코드의 변수명을 모두 알고 있는 상태가 되는 것 입니다.</p>\n<p>이 상태를 엔진이 식별자 정보들을 최상단으로 끌어올려놓고 순차적으로 코드를 실행하는 것처럼 보여<br><mark>변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념으로 등장한 개념이 호이스팅<mark> 입니다.</p>\n<p>엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주하는 개념입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>함수 선언의 호이스팅</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// (1)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"string\">'bbb'</span>; <span class=\"comment\">// 수집 대상 1(변수 선언)</span></span><br><span class=\"line\">  <span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// (2)</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;&#125; <span class=\"comment\">// 수집 대상 2(함수 선언)</span></span><br><span class=\"line\">  <span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// (3)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a();</span><br><span class=\"line\"><span class=\"comment\">// function b()&#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// bbb</span></span><br><span class=\"line\"><span class=\"comment\">// bbb</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>environmentRecord</code>에는 매개변수의 이름, 함수 선언, 변수명 들이 담깁니다.<br>엔진은 이러한 호이스팅으로 인해 코드 실행전 부터 컨텍스트 구성 정보를 가지고 있습니다.</li>\n</ul>\n<ol>\n<li><code>environmentRecord</code>에 의해 <code>var b;</code> 와 <code>var b = function b (){}</code>가 최상단에 위치한다고 볼 수 있습니다.<br><code>function b(){}</code> 를 참조하여 출력됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li><ol start=\"3\">\n<li><code>var b = &#39;bbb&#39;</code> 으로 할당된 후 이므로 <code>bbb</code>가 출력됩니다.</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h4 id=\"함수-선언문과-함수-표현식\"><a href=\"#함수-선언문과-함수-표현식\" class=\"headerlink\" title=\"함수 선언문과 함수 표현식\"></a>함수 선언문과 함수 표현식</h4><ul>\n<li><p>함수 선언문 : <code>function</code> 정의부만 존재하고 별도의 할당 명령이 없는 것<br><mark>반드시 함수명이 정의되어 있어야 함.</mark></p>\n</li>\n<li><p>함수 표현식 : 정의한 <code>function</code>을 별도의 변수에 할당하는 것<br><mark>함수명이 없어도 됨.</mark></p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>함수를 정의하는 세 가지 방식</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 함수 선언문. 함수명 a가 곧 변수명.</span></span><br><span class=\"line\">a(); <span class=\"comment\">// 실행 OK.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;; <span class=\"comment\">// (익명) 함수 표현식. 변수명 b가 곧 함수명.</span></span><br><span class=\"line\">b(); <span class=\"comment\">// 실행 OK.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">d</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;; <span class=\"comment\">// 기명 함수 표현식. 변수명은 c, 함수명은 d.</span></span><br><span class=\"line\">c(); <span class=\"comment\">// 실행 OK.</span></span><br><span class=\"line\">d(); <span class=\"comment\">// 에러!</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>함수 선언문과 함수 표현식 호이스팅 시 차이.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>호이스팅 전 원본 코드</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(multiply(<span class=\"number\">3</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 함수 선언문 sum</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> multiply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 함수 표현식 multiply</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a * b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>호이스팅 후 함수 표현식과 선언문의 차이</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 함수 선언문은 전체를 호이스팅합니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> multiply; <span class=\"comment\">// 변수는 선언부만 끌어올립니다.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(multiply(<span class=\"number\">3</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">multiply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 변수의 할당부는 원래 자리에 남겨둡니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a * b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>위에서 볼 수 있듯 함수 선언문은 함수 전체를 호이스팅</p>\n</li>\n<li><p>함수 표현식은 변수 부분만 호이스팅, 할당하는 부분은 호이스팅 하지 않음.</p>\n</li>\n<li><p><code>console.log(multiply(3,4))</code> 시점의 <code>multiply</code>에는 값이 할당돼 있지 않습니다.<br>따라서 <code>multiply is not a function</code> 에러 메시지가 출력되고 , 에러로 인해 아래 할당부 코드는 실행되지 않고 종료됩니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"스코프-스코프-체인-outerEnvironmentReference\"><a href=\"#스코프-스코프-체인-outerEnvironmentReference\" class=\"headerlink\" title=\"스코프, 스코프 체인, outerEnvironmentReference\"></a>스코프, 스코프 체인, outerEnvironmentReference</h3><ul>\n<li><p>스코프(scope) : 식별자에 대한 유효범위</p>\n</li>\n<li><p>스코프 체인 : 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것</p>\n</li>\n<li><p>outerEnvironmentReference : 스코프 체인을 가능하게 하는 <code>LexicalEnvironment</code>의 두 번째 수집자료 <code>outerEnvironmentReference</code></p>\n</li>\n</ul>\n<hr>\n<h4 id=\"스코프-체인\"><a href=\"#스코프-체인\" class=\"headerlink\" title=\"스코프 체인\"></a>스코프 체인</h4><p><code>outerEnvironmentReference</code>는 현재 호출된 함수가 <mark>선언될 당시의 LexicalEnvironment</mark>를 참조합니다. (== 콜 스택 상에서 실행 컨텍스트가 활성화된 상태)</p>\n<figure class=\"highlight js\"><figcaption><span>outerEnvironmentReference 동작 예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//(...) </span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//(...)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//(...)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>a 함수 내부에 b 함수를 선언하고 다시 b 함수 내부에 c 함수를 선언했습니다.</p>\n<ul>\n<li><p>이 경우 <code>함수 c</code>의 <code>outerEnvironmentReference</code>는 <code>함수 b</code>의 <code>LexicalEnvironment</code>를 참조합니다.<br><code>함수 b</code>의 <code>LexicalEnvironment</code>에 있는 <code>outerEnvironmentReference</code>는 다시 <code>함수 a</code>의 <code>LexicalEnvironment</code>를 참조합니다.</p>\n</li>\n<li><p>이처럼 <code>outerEnvironmentReference</code>는 연결리스트 형태를 가지고 있고 선언 시점의 <code>LexicalEnvironment</code>를 계속 찾아 올라가면 마지막에는 전역 컨텍스트의 <code>LexicalEnvironment</code>가 있을 것입니다.</p>\n</li>\n<li><p><code>outerEnvironmentReference</code>는 <mark>자신이 선언된 시점의 LexicalEnvironment만 참조</mark>하고 있으므로 가장 가까운 요소부터 차례로 접근할 수 밖에 없습니다.</p>\n</li>\n</ul>\n<p>이런 구조적 특성 덕분에 여러 스코프에서 동일한 스코프를 선언한 경우에는 <mark>무조건 스코프 체인 상에서 가장 먼저 발견된 식별자만 접근 가능</mark> 하게 됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>개발자 도구로 스코프 체인 확인법 -크롬</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.dir(inner);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  inner();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">outer();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>함수 내부에 함수를 출력하는 방법으로 현재 실행 컨텍스트를 제외한 상위 스코프 정보들을 개발자 도구에서 확인할 수 있습니다. (<code>debugger</code> 사용시 더욱 자세한 정보 확인 가능)</li>\n</ul>\n<hr>\n<h4 id=\"전역변수와-지역변수\"><a href=\"#전역변수와-지역변수\" class=\"headerlink\" title=\"전역변수와 지역변수\"></a>전역변수와 지역변수</h4><ul>\n<li><p>전역변수 : 전역 스코프에서 선언한 변수</p>\n</li>\n<li><p>지역변수 : 전역 스코프가 아닌 함수 스코프 또는 블록 스코프 내부에서 선언한 변수<br>지역 변수는 선언된 스코프 외부에서 접근할 수 없음.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"thisBinding\">this</h2>\n\n<p>실행 컨텍스트의 <code>thisBinding</code>에는 <code>this</code>로 지정된 객체가 저장됩니다.<br>실행 컨텍스트 활성화 당시에 <code>this</code>가 지정되지 않으면 <code>this</code>는 전역 객체를 참조하게 됩니다.</p>\n<p>함수를 호출하는 방식 등 사용되는 방법에 따라 <code>this</code>가 참조하는 대상이 변하게 되므로<br><code>this</code>에 자세한 내용은 따로 다루도록 하겠습니다.</p>\n","site":{"data":{}},"excerpt":"<p>실행 컨텍스트(<code>execution context</code>)는 실행할 코드에 제공할 환경 정보를 모아놓은 객체로,<br>자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념입니다.<br>자바스크립트는 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(<code>호이스팅</code>), 외부 환경 정보를 구성하고, <code>this</code> 값을 설정하는 등의 동작을 수행하는데, 이로 인해 다른 언어에서는 발견할 수 없는 특이한 현상들이 발생합니다.</p>\n<ul>\n<li>실행 컨텍스트<ul>\n<li><a href=\"/2020/04/26/실행-컨텍스트-Core-JavaScript/#execution_context\">실행 컨텍스트란?</a><ul>\n<li>스택과 큐</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/26/실행-컨텍스트-Core-JavaScript/#VariableEnvironment\">VariableEnvironment</a></li>\n<li><a href=\"/2020/04/26/실행-컨텍스트-Core-JavaScript/#LexicalEnvironment\">LexicalEnvironment</a><ul>\n<li>environmentRecord와 호이스팅<ul>\n<li>호이스팅 규칙</li>\n<li>함수 선언문과 함수 표현식</li>\n</ul>\n</li>\n<li>스코프, 스코프 체인, outerEnvironmentReference<ul>\n<li>스코프 체인</li>\n<li>전역변수 와 지역변수</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/26/실행-컨텍스트-Core-JavaScript/#thisBinding\">this</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"execution_context\">실행 컨텍스트란?</h2>\n\n<hr>\n<h3 id=\"스택-stack-과-큐-queue\"><a href=\"#스택-stack-과-큐-queue\" class=\"headerlink\" title=\"스택(stack)과 큐(queue)\"></a>스택(stack)과 큐(queue)</h3><ul>\n<li>스택 : 출입구가 하나뿐인 데이터 구조<br>비어있는 스택에 순서대로 데이터 a,b,c,d를 저정했다면 꺼낼 때는 반대로 d,c,b,a의 순서대로 꺼낸다.<br>저장할 수 있는 데이터 스택이 넘치면 엔진에서 <code>RangeError: Maximum call stack size exceeded</code> 에러를 던집니다.</li>\n</ul>\n<ul>\n<li>큐 : 한쪽은 입구, 한쪽은 출구를 담당하는 양쪽 데이터 구조<br>비어있는 큐에 순서대로 데이터 a,b,c,d를 저정했다면 꺼낼 때도 a,b,c,d의 순서대로 꺼낸다.</li>\n</ul>\n<hr>\n<h4 id=\"엔진이-동일한-환경에-있는-코드들을-실행할-때\"><a href=\"#엔진이-동일한-환경에-있는-코드들을-실행할-때\" class=\"headerlink\" title=\"엔진이 동일한 환경에 있는 코드들을 실행할 때\"></a>엔진이 동일한 환경에 있는 코드들을 실행할 때</h4><p>필요한 환경정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련된 코드들을 실행하므로 코드의 환경과 순서를 보장받을 수 있습니다.</p>\n<p>흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>실행 컨텍스트와 콜 스택</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"number\">3.</span> inner(); </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">2.</span> outer(); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>처음 자바스크립트 코드를 실행하는 순간 전역 컨텍스트가 콜 스택에 담깁니다.<br>(<del>코드 내부에서 별도의 실행 명령 없이 브라우저에서 자동으로 실행하므로 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화 된다고 이해</del>)</p>\n</li>\n<li><p>전역 컨텍스트와 관련된 코드들을 순차적으로 진행하다가 <code>outer()</code>를 호출하면 엔진은 <code>outer</code>에 대한 환경 정보를 수집해 <code>outer</code> 실행 컨텍스트를 생성한 후 콜 스택에 담습니다.<br>이때, 콜 스택 내부에서 전역 컨텍스트 위에 <code>outer</code> 실행 컨텍스트가 놓인 상태가 되어 <code>outer</code> 실행 컨텍스트 즉, <code>outer</code> 함수 내부 코드들을 순차적으로 실행합니다. (전역 컨텍스트 일시정지)</p>\n</li>\n<li><p>마찬가지로 <code>outer</code> 실행 컨텍스트를 진행하다 <code>inner()</code>함수의 실행 컨텍스트가 콜 스택의 가장 위에 담기면 <code>outer</code> 컨텍스트는 일시정지되고 <code>inner</code> 함수 내부 코드를 실행합니다.</p>\n</li>\n</ol>\n<ul>\n<li>실행 컨텍스트와 콜 스택<br><img src=\"/images/context_callStack.PNG\" alt=\"실행 컨텍스트와 콜 스택\"></li>\n</ul>\n<p><u>실행 컨텍스트가 콜 스택의 맨위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하는 시점.<br>기존의 컨텍스트는 새로 쌓인 컨텍스트보다 아래에 위치할 수 밖에 없음</u></p>\n<p><mark>이렇게 어떤 컨텍스트가 활성화될 때 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는데 필요한 환경 정보들을 수집하여 실행 컨텍스트 객체에 저장함.</mark></p>\n<p>이 객체는 엔진이 활용 목적으로 생성할 뿐 개발자 코드로 확인할 수는 없음<br>이에 담기는 정보들은 다음과 같습니다.</p>\n<ul>\n<li><p><code>VariableEnvironment</code> : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보.<br>선언 시점의 <code>LexicalEnvironment</code>의 스냅샷(<code>snapshot</code>)으로, 변경 사항은 반영되지 않음.</p>\n</li>\n<li><p><code>LexicalEnvironment</code> : 처음에는 <code>VariableEnvironment</code>와 같지만 변경 사항이 실시간으로 반영되는 점이 다름.</p>\n</li>\n<li><p><code>ThisBinding</code> : <code>this</code> 식별자가 바라봐야 할 대상 객체</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"VariableEnvironment\">VariableEnvironment</h2>\n\n<p><code>VariableEnvironment</code>에 담기는 내용은 <code>LexicalEnvironment</code>와 같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다릅니다.</p>\n<p>실행 컨텍스트를 생성할 때 <code>VariableEnvironment</code>에 정보를 먼저 담은 후<br>이를 그대로 복사하여 <code>LexicalEnvironment</code>를 만들고, 생성된 <code>LexicalEnvironment</code>를 활용합니다.</p>\n<p><code>VariableEnvironment</code>와 <code>LexicalEnvironment</code> 는 초기화 과정 중에는 사실상 완전히 동일하고 둘 다 내부에 <code>environmentRecord</code>와 <code>outer-EnvironmentReference</code>로 구성되어 있습니다. </p>\n<p>다음의 <code>LexicalEnvironment</code>를 살펴보며 자세한 내용과 둘의 코드 진행과정 차이를 알아봅시다.</p>\n<hr>\n<h2 id=\"LexicalEnvironment\">LexicalEnvironment</h2>\n\n<p><code>LexicalEnvironment</code>은 개발자 용어로 <code>정적 환경</code>으로 통하나 <u>실제 의미가 동일 하지는 않습니다.</u><br>커뮤니케이션을 위해 정적 환경으로 불리지만 <code>LexicalEnvironment</code>를 현재 컨텍스트의 내부에는 식별자들이 있고 그 외부 정보를 다른 객체가 참조하도록 구성되어 있다는 식의 <u>컨텍스트 구성 환경 정보들을 모아놓은</u> 느낌으로 이해합시다.</p>\n<hr>\n<h3 id=\"environmentRecord와-호이스팅\"><a href=\"#environmentRecord와-호이스팅\" class=\"headerlink\" title=\"environmentRecord와 호이스팅\"></a>environmentRecord와 호이스팅</h3><p><code>environmentRecord</code>에는 현재 컨텍스트와 관련된 코드의 <mark>식별자 정보</mark>들이 저장됩니다.</p>\n<ul>\n<li><p>컨텍스트를 구성하는 함수에 지정된 <mark>매개변수 식별자</mark></p>\n</li>\n<li><p>선언한 함수가 있을 경우 <mark>그 함수 자체</mark></p>\n</li>\n<li><p>var등으로 선언된 <mark>변수의 식별자 등</mark></p>\n</li>\n</ul>\n<p><strong>컨텍스트 내부 전체를 처음부터 끝까지 순서대로 수집합니다.</strong></p>\n<ul>\n<li>참고 :<br><mark>전역 실행 컨텍스트는 변수 객체를 생성하지 않습니다.</mark><br>자바스크립트 구동 환경이 별도로 제공하는 객체 즉, <mark>전역 객체를 활용합니다</mark>. (브라우저의 window, Node.js의 global 객체 등)<br>이들은 자바스크립트 내장 객체가 아닌 호스트 객체로 분류됩니다.</li>\n</ul>\n<hr>\n<h4 id=\"호이스팅-규칙\"><a href=\"#호이스팅-규칙\" class=\"headerlink\" title=\"호이스팅 규칙\"></a>호이스팅 규칙</h4><p><code>environmentRecord</code>가 현재 컨텍스트와 관련된 변수 정보를 수집한 상태는<br>컨텍스트의 코드가 실행되기 전의 상태입니다. 코드가 실행되기 전에 엔진이 이미 해당 환경에 속한 코드의 변수명을 모두 알고 있는 상태가 되는 것 입니다.</p>\n<p>이 상태를 엔진이 식별자 정보들을 최상단으로 끌어올려놓고 순차적으로 코드를 실행하는 것처럼 보여<br><mark>변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념으로 등장한 개념이 호이스팅<mark> 입니다.</p>\n<p>엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주하는 개념입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>함수 선언의 호이스팅</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// (1)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"string\">'bbb'</span>; <span class=\"comment\">// 수집 대상 1(변수 선언)</span></span><br><span class=\"line\">  <span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// (2)</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;&#125; <span class=\"comment\">// 수집 대상 2(함수 선언)</span></span><br><span class=\"line\">  <span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// (3)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a();</span><br><span class=\"line\"><span class=\"comment\">// function b()&#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// bbb</span></span><br><span class=\"line\"><span class=\"comment\">// bbb</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>environmentRecord</code>에는 매개변수의 이름, 함수 선언, 변수명 들이 담깁니다.<br>엔진은 이러한 호이스팅으로 인해 코드 실행전 부터 컨텍스트 구성 정보를 가지고 있습니다.</li>\n</ul>\n<ol>\n<li><code>environmentRecord</code>에 의해 <code>var b;</code> 와 <code>var b = function b (){}</code>가 최상단에 위치한다고 볼 수 있습니다.<br><code>function b(){}</code> 를 참조하여 출력됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li><ol start=\"3\">\n<li><code>var b = &#39;bbb&#39;</code> 으로 할당된 후 이므로 <code>bbb</code>가 출력됩니다.</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h4 id=\"함수-선언문과-함수-표현식\"><a href=\"#함수-선언문과-함수-표현식\" class=\"headerlink\" title=\"함수 선언문과 함수 표현식\"></a>함수 선언문과 함수 표현식</h4><ul>\n<li><p>함수 선언문 : <code>function</code> 정의부만 존재하고 별도의 할당 명령이 없는 것<br><mark>반드시 함수명이 정의되어 있어야 함.</mark></p>\n</li>\n<li><p>함수 표현식 : 정의한 <code>function</code>을 별도의 변수에 할당하는 것<br><mark>함수명이 없어도 됨.</mark></p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>함수를 정의하는 세 가지 방식</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 함수 선언문. 함수명 a가 곧 변수명.</span></span><br><span class=\"line\">a(); <span class=\"comment\">// 실행 OK.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;; <span class=\"comment\">// (익명) 함수 표현식. 변수명 b가 곧 함수명.</span></span><br><span class=\"line\">b(); <span class=\"comment\">// 실행 OK.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">d</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;; <span class=\"comment\">// 기명 함수 표현식. 변수명은 c, 함수명은 d.</span></span><br><span class=\"line\">c(); <span class=\"comment\">// 실행 OK.</span></span><br><span class=\"line\">d(); <span class=\"comment\">// 에러!</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>함수 선언문과 함수 표현식 호이스팅 시 차이.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>호이스팅 전 원본 코드</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(multiply(<span class=\"number\">3</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 함수 선언문 sum</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> multiply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 함수 표현식 multiply</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a * b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>호이스팅 후 함수 표현식과 선언문의 차이</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 함수 선언문은 전체를 호이스팅합니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> multiply; <span class=\"comment\">// 변수는 선언부만 끌어올립니다.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(multiply(<span class=\"number\">3</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">multiply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 변수의 할당부는 원래 자리에 남겨둡니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a * b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>위에서 볼 수 있듯 함수 선언문은 함수 전체를 호이스팅</p>\n</li>\n<li><p>함수 표현식은 변수 부분만 호이스팅, 할당하는 부분은 호이스팅 하지 않음.</p>\n</li>\n<li><p><code>console.log(multiply(3,4))</code> 시점의 <code>multiply</code>에는 값이 할당돼 있지 않습니다.<br>따라서 <code>multiply is not a function</code> 에러 메시지가 출력되고 , 에러로 인해 아래 할당부 코드는 실행되지 않고 종료됩니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"스코프-스코프-체인-outerEnvironmentReference\"><a href=\"#스코프-스코프-체인-outerEnvironmentReference\" class=\"headerlink\" title=\"스코프, 스코프 체인, outerEnvironmentReference\"></a>스코프, 스코프 체인, outerEnvironmentReference</h3><ul>\n<li><p>스코프(scope) : 식별자에 대한 유효범위</p>\n</li>\n<li><p>스코프 체인 : 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것</p>\n</li>\n<li><p>outerEnvironmentReference : 스코프 체인을 가능하게 하는 <code>LexicalEnvironment</code>의 두 번째 수집자료 <code>outerEnvironmentReference</code></p>\n</li>\n</ul>\n<hr>\n<h4 id=\"스코프-체인\"><a href=\"#스코프-체인\" class=\"headerlink\" title=\"스코프 체인\"></a>스코프 체인</h4><p><code>outerEnvironmentReference</code>는 현재 호출된 함수가 <mark>선언될 당시의 LexicalEnvironment</mark>를 참조합니다. (== 콜 스택 상에서 실행 컨텍스트가 활성화된 상태)</p>\n<figure class=\"highlight js\"><figcaption><span>outerEnvironmentReference 동작 예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//(...) </span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//(...)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//(...)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>a 함수 내부에 b 함수를 선언하고 다시 b 함수 내부에 c 함수를 선언했습니다.</p>\n<ul>\n<li><p>이 경우 <code>함수 c</code>의 <code>outerEnvironmentReference</code>는 <code>함수 b</code>의 <code>LexicalEnvironment</code>를 참조합니다.<br><code>함수 b</code>의 <code>LexicalEnvironment</code>에 있는 <code>outerEnvironmentReference</code>는 다시 <code>함수 a</code>의 <code>LexicalEnvironment</code>를 참조합니다.</p>\n</li>\n<li><p>이처럼 <code>outerEnvironmentReference</code>는 연결리스트 형태를 가지고 있고 선언 시점의 <code>LexicalEnvironment</code>를 계속 찾아 올라가면 마지막에는 전역 컨텍스트의 <code>LexicalEnvironment</code>가 있을 것입니다.</p>\n</li>\n<li><p><code>outerEnvironmentReference</code>는 <mark>자신이 선언된 시점의 LexicalEnvironment만 참조</mark>하고 있으므로 가장 가까운 요소부터 차례로 접근할 수 밖에 없습니다.</p>\n</li>\n</ul>\n<p>이런 구조적 특성 덕분에 여러 스코프에서 동일한 스코프를 선언한 경우에는 <mark>무조건 스코프 체인 상에서 가장 먼저 발견된 식별자만 접근 가능</mark> 하게 됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>개발자 도구로 스코프 체인 확인법 -크롬</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.dir(inner);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  inner();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">outer();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>함수 내부에 함수를 출력하는 방법으로 현재 실행 컨텍스트를 제외한 상위 스코프 정보들을 개발자 도구에서 확인할 수 있습니다. (<code>debugger</code> 사용시 더욱 자세한 정보 확인 가능)</li>\n</ul>\n<hr>\n<h4 id=\"전역변수와-지역변수\"><a href=\"#전역변수와-지역변수\" class=\"headerlink\" title=\"전역변수와 지역변수\"></a>전역변수와 지역변수</h4><ul>\n<li><p>전역변수 : 전역 스코프에서 선언한 변수</p>\n</li>\n<li><p>지역변수 : 전역 스코프가 아닌 함수 스코프 또는 블록 스코프 내부에서 선언한 변수<br>지역 변수는 선언된 스코프 외부에서 접근할 수 없음.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"thisBinding\">this</h2>\n\n<p>실행 컨텍스트의 <code>thisBinding</code>에는 <code>this</code>로 지정된 객체가 저장됩니다.<br>실행 컨텍스트 활성화 당시에 <code>this</code>가 지정되지 않으면 <code>this</code>는 전역 객체를 참조하게 됩니다.</p>\n<p>함수를 호출하는 방식 등 사용되는 방법에 따라 <code>this</code>가 참조하는 대상이 변하게 되므로<br><code>this</code>에 자세한 내용은 따로 다루도록 하겠습니다.</p>"},{"title":"Symbol 프로퍼티 -ECMAScript","date":"2020-04-06T03:55:12.000Z","disqusId":"tunas-blog-1","_content":"\n\nSymbol 오브젝트에 프로퍼티들을 살펴봅니다.  \n이 프로퍼티들은 메서드로도 사용할 수 있습니다\n\n*   Symbol 프로퍼티\n    *   [Well-Known Symbol](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Well-Known_Symbol)\n    *   [toStringTag](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#toStringTag)\n        *   클래스의 메서드로 사용\n    *   [isConcatSpreadable](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#isConcatSpreadable)\n        *   Array-like 오브젝트에서 사용\n    *   [unscopable](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#unscopable)\n    *   [species 개념](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#species_개념)\n    *   [species](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#species)\n    *   [다른 Class 반환](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#return_other_Class)\n    *   [null 반환](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#return_null)\n    *   [toPrimitive](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#toPrimitive)\n        *   toPrimitive() 파라미터의 세가지 모드(mode)\n    *   [이터레이터](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_iterator)\n        *   Array.prototype[Symbol.iterator]\n        *   String.prototype[Symbol.iterator]\n        *   Object 이터레이션\n    *   [제너레이터](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_generator)\n    *   [asyncIterator(): 비동기 반복](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_asyncIterator)\n    *   [match(): match 결과 반환](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_match)\n    *   [matchAll()](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_matchAll)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Well-Known_Symbol\">Well-Known Symbol</h2>\n\n\n스펙에서 @@iterator 형태로 작성된 것을 볼 수 있으며  \n@@는 Symbol 대신 사용한 것입니다.  \n따라서 @@iterator는 Symbol.iterator와 같습니다.  \n@@iterator 형태는 스펙에서 사용하며 Symbol.iterator 형태는 내부 프로퍼티인  \n[[Description]]에 저장되는 형태입니다.  \n개발자 코드에서는 Symbol.iterator 형태를 사용합니다.\n\n | Spec name            | [[Description]]              |\n|----------------------|------------------------------|\n| @@asyncIterator      | Symbol.asyncIterator         |\n| @@hasInstance        | Symbol.hasInstance           |\n| @@isConcatSpreadable | Symbol.isConcatSpreadable    |\n| @@iterator           | Symbol.iterator              |\n| @@match              | Symbol.match                 |\n| @@matchAll           | Symbol.matchAll              |\n| 참고용 프로퍼티      | Symbol.prototype.description |\n| @@replace            | Symbol.replace               |\n| @@search             | Symbol.search                |\n| @@species            | Symbol.species               |\n| @@split              | Symbol.split                 |\n| @@toPrimitive        | Symbol.toPrimitive           |\n| @@toStringTag        | Symbol.toStringTag           |\n| @@unscopables        | Symbol.unscopables           |\n\n\n\n* Well-Known Symbol은 스펙에서 처리 알고리즘(Algorism)을 구분하기 위해 부여한 이름입니다. 즉, 자바스크립트 엔진이 디폴트로 처리하는 알고리즘 유형 이름입니다.\n    \n* <mark>자바스크립트 프로그램에 같은 이름의 Well-Known.Symbol을 작성하면  \n엔진의 디폴트 처리를 실행하지 않고 프로그램에 작성한 코드를 실행합니다(오버라이딩)  \nWell-Known Symbol이 오버라이드되는 것과 같으므로 프로그램에 같은 이름을작성하여  \nWell-Known Symbol기능을 대체할 수 있습니다.</makr>\n    \n\n**이런 가변성과 유용성을 제공하는 것이 Well-Known Symbol의 목적입니다.**\n\n* * *\n\n<h2 id=\"toStringTag\">toStringTag</h2>\n\n[object Object] 형태에서 Object를 Symbol.toStringTag 값으로 표시합니다.  \n객체의 기본 문자열 설명을 만드는 데 사용되는 문자열 값 속성입니다.  \n[Object.prototype.toString()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/toString) 메소드에 의해 내부적으로 액세스됩니다.\n\n### 설명\n\n**많은 자바스크립트 타입들은 기본적으로 tag를 가지고 있습니다.**\n\n```js tag default\nObject.prototype.toString.call('foo');     \n// \"[object String]\"  \nObject.prototype.toString.call([1, 2]);    \n// \"[object Array]\"  \nObject.prototype.toString.call(3);         \n// \"[object Number]\"  \nObject.prototype.toString.call(true);      \n// \"[object Boolean]\"  \nObject.prototype.toString.call(undefined); \n// \"[object Undefined]\"  \nObject.prototype.toString.call(null);      \n// \"[object Null]\"  \n\n// ... and more  \n```\n\n**기본적으로 toStringTag symbol이 정의되어 있는 것도 있습니다.**\n\n```js\nObject.prototype.toString.call(new Map());       \n// \"[object Map]\"  \nObject.prototype.toString.call(function* () {}); \n// \"[object GeneratorFunction]\"  \nObject.prototype.toString.call(Promise.resolve()); \n// \"[object Promise]\" \n\n// ... and more  \n```\n\n**class를 생성하면 자바스크립트는 기본값으로 Object tag를 설정합니다.**\n\n```js\nclass ValidatorClass {}  \n  \nObject.prototype.toString.call(new ValidatorClass()); \n// \"[object Object]\"  \n```\n\n**toStringTag를 이용하여 자신만의 맞춤 태그를 설정할 수 있습니다.**\n\n```js\nclass ValidatorClass {  \n get [Symbol.toStringTag]() {  \n return 'Validator';  \n }  \n}  \nObject.prototype.toString.call(new ValidatorClass()); \n// \"[object Validator]\"  \n```\n\n```js toStringTag 예제\nlet Sports = function(){};  \nlet sportsObj = new Sports;  \n1. console.log(sportsObj.toString());  \n  \n2. Sports.prototype[Symbol.toStringTag] = \"Sports-Function\";  \n3. console.log(sportsObj.toString());  \n// [object Object]  \n// [object Sports-Function]  \n```\n\n1.  new Sports로 생성한 인스턴스로 toString()을 실행하면 [object Object]가 반환됩니다.  \n    Object 오브젝트도 [object Object]를 반환하므로 구분이 어렵습니다.  \n    한편 new Sports()의 파라미터 값이 없을때 new sports; 로 사용할 수 있습니다.\n\n2.  Sports.prototype[Symbol.toStringTag] = “Sports-Function”;  \n    Sports.prototype[Symbol.toStringTag]에 [object Object] 의 Object에 표시할 문자열을 지정합니다.\n\n3.  sportsObj.toString()을 실행하면 엔진에서 디폴트 toStringTag 값을 반환하기 전에  \n    sportsObj에서 Symbol.toStringTag의 작성 여부를 체크합니다.  \n    값이 작성되어 있다면 디폴트 값이 아닌 작성된 값을 반환합니다.  \n    따라서 [object Sports-Function] 이 출력됩니다.  \n    [object Sports-Function]을 정규표현식으로 분리하면 Sports-Function을 구할 수 있습니다.\n\n### 클래스의 메서드로 사용\n\nSymbol.toStringTag를 클래스의 getter로 작성할 수 있습니다.\n\n```js\nclass Book {};  \nlet bookObj = new Book();  \n1. console.log(bookObj.toString());  \n  \n2. class Sports {  \n get [Symbol.toStringTag]() {  \n return \"Sports-class\";  \n }  \n};  \n3. let sportsObj = new Sports();  \nconsole.log(sportsObj.toString());  \n  \n4. console.log(Map.prototype[Symbol.toStringTag]);  \n//[object Object]  \n//[object Sports-class]  \n//Map  \n```\n\n1.  toString()을 실행하면 [object Object]가 반환됩니다.  \n    따라서 Function 오브젝트, Object 오브젝트와 구분할 수 없습니다.\n\n2.  클래스에 Symbol.toStringTag를 getter로 선언했습니다.  \n    return 문에 [object Object]에서 Object에 표시될 문자열을 작성했습니다.Sports-class가 반환됩니다.  \n    getter로 작성하지 않고 메서드로 작성하면 [object Object]가 반환되므로 getter로 작성해야 합니다.\n\n3.  인스턴스로 toString()을 호출하면 sportsObj 인스턴스에 작성된 getSymbol.toStringTag가 호출됩니다.  \n    호출된 메서드에서 “Sports-class”를 반환하므로 [object Sports-class]가 출력됩니다.\n\n4.  Map 같이 Symbol.toStringTag를 기본값(빌트인)으로 가지고 있는 것들이 있습니다.  \n    Map.prototype[Symbol.toStringTag]를 실행하면 “Map”이 출력됩니다.  \n    개발자 코드로 Symbol.toStringTag에 표시될 문자열을 작성하거나 getter를 사용하지 않아도 됩니다.\n\n* * *\n\n<h2 id=\"isConcatSpreadable\">isConcatSpreadable</h2>\n\nSymbol.isConcatSpreadable는  \n[Array.prototype.concat()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) 메서드를 사용할 때 객체를 배열 요소에 병합해야하는지 구성하는 데 사용됩니다.\n\n> [Symbol.isConcatSpreadable] = true / false\n\n*   프로퍼티의 기본값은 true 입니다.  \n    false로 설정시 배열을 펼처서 합치지 않고 배열의 끝에 배열을 추가합니다.  \n    사용시 true/false 에 따라 생성되는 배열의 length값이 달라집니다.\n\n```js\n1. let one = [11, 12], two = [21, 22];  \nlet result = one.concat(two);  \nconsole.log(result, result.length);  \n/*  \nArray(4)  \n 0: 11  \n 1: 12  \n 2: 21  \n 3: 22  \n length: 4  \n __proto__: Array(0)  \n4   \n*/  \n  \n2. two[Symbol.isConcatSpreadable] = false;  \nresult = one.concat(two);  \nconsole.log(result, result.length);  \n/*  \nArray(3)  \n 0: 11  \n 1: 12  \n 2: Array(2)  \n 0: 21  \n 1: 22  \n length: 2  \n Symbol(Symbol.isConcatSpreadable): true  \n __proto__: Array(0)  \n length: 3  \n __proto__: Array(0)  \n3  \n*/  \n  \n3. two[Symbol.isConcatSpreadable] = true;  \nresult = one.concat(two);  \nconsole.log(result, result.length);  \n/*  \nArray(4)  \n 0: 11  \n 1: 12  \n 2: 21  \n 3: 22  \n length: 4  \n __proto__: Array(0)  \n4  \n*/  \n```\n\n1.  one 배열의 [11, 12]에 concat()의 파라미터에 지정한 two 배열 [21, 22]를 결합하면,  \n    21 과 22가 각각 분리되어 one 배열 끝에 추가됩니다.  \n    [11, 12, 21, 22] length: 4 가 반환됩니다.  \n    Array.prototype에 [Symbol.isConcatSpreadable]을 작성하지 않았으므로 디폴트 true값 입니다.  \n    일반적인 concat()메서드 사용입니다.\n\n2.  two[Symbol.isConcatSpreadable]에 false 값을 할당했습니다.  \n    concat() 메서드로 one 배열과 two 배열을 결합하면 two 배열의 [21, 22]를 분리하지 않고  \n    배열 자체를 첨부합니다. [11, 12, Array[2]] 형태로 결합되어 length 값은 3을 갖습니다.  \n    개발자 도구에서 Array[2]를 살펴보면 [21, 22] length: 2 가 할당되어 있고  \n    Symbol(Symbol.isConcatSpreadable): true로 isConcatSpreadable = false 가 적용된 것을 볼 수 있습니다. 기본값 isConcatSpreadable = true 인 경우 프로퍼티에 나타나지 않습니다.\n\n3.  two[Symbol.isConcatSpreadable]에 true를 할당하였으며 디폴트 값 true와 같습니다.  \n    one 배열에 two 배열의 [21, 22]가 분리되어 끝에 첨부됩니다.  \n    [11, 12, 21, 22] 형태가 됩니다.\n\n### Array-like 오브젝트에서 사용\n\n<mark>유사 배열(Array-like) 오브젝트도 concat()을 사용할 수 있습니다. 하지만 유사 배열 오브젝트는 isConcatSpreadable = true 값을 가지지 않습니다.</mark> concat()으로 배열을 하나씩 분리하여 추가 병합하고 싶다면 isConcatSpreadable를 사용하여 true로 설정해줍니다.\n\n```js isConcatSpreadable > Array-like\nlet one = [11, 12];  \n1. let fiveSix = {  \n 0: \"five\",  \n 1: \"six\",  \n length: 2  \n};  \nlet result = one.concat(fiveSix);  \nconsole.log(result, result.length);  \n/*  \nArray(3)  \n 0: 11  \n 1: 12  \n 2: Object{  \n 0: \"five\",   \n 1: \"six\",   \n length: 2}   \n length: 3  \n __proto__: Array(0)  \n3  \n*/  \n  \n2. let arrayLike = {  \n [Symbol.isConcatSpreadable]: true,  \n 0: \"five\",  \n 1: \"six\",  \n length: 2  \n};  \nresult = one.concat(arrayLike);  \nconsole.log(result, result.length);  \n/*  \nArray(4)  \n 0: 11  \n 1: 12  \n 2: \"five\"  \n 3: \"six\"  \n length: 4  \n __proto__: Array(0)  \n4  \n*/  \n```\n\n1.  one은 배열 [11, 12]이고 fiveSix는 Array-like {0: “five”, 1” “six”, length:2}입니다.  \n    이 상태에서 concat()을 실행하면 [11, 12, Object] 형태가 됩니다.  \n    오브젝트 형태가 분리되어 첨부되지 않습니다.\n\n2.  Array-like 오브젝트에 [Symbol.isConcatSpreadable]: true를 작성하여,  \n    concat()을 실행하면 Array-like 오브젝트의 각 프로퍼티를 분리하여 배열 끝에 첨부합니다.\n\n* * *\n\n<h2 id=\"unscopable\">unscopable</h2>\n\n[with](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/with)문에서 사용하며 값이 true 이면 프로퍼티를 전개 하지 않습니다.\n\n> [Symbol.unscopables] = true/false\n\nSymbol.unscopables 값이 true일 때, with 문에서 프로퍼티를 전개하지 않으므로  \nObject 오브젝트의 프로퍼티 키를 사용하면 에러가 발생합니다.\n\nES5 에서 “use strict” 범위에 with 문을 사용하면 에러가 발생합니다.ES6도 마찬가지 입니다. ES6에서 stirct모드는 보편적인 환경이므로 Symbol.unscopables를 사용할 빈도가 그다지 높지 않습니다.\n\n```js Symbol.unscopables\n// \"use strict\" 를 선언하면 with 에서 에러 발생  \nlet sports = {  \n soccer: \"축구\",  \n baseball: \"야구\"  \n};  \n1. with(sports){  \n console.log(soccer, baseball);  \n};  \n  \n2. sports[Symbol.unscopables] = {  \n baseball: true  \n};  \n  \ntry {  \n 3. with (sports) {  \n console.log(soccer);  \n let value = baseball;  \n }  \n} catch (e) {  \n console.log(e.message);  \n};  \n// 축구 야구  \n// 축구  \n// baseball is not defined  \n```\n\n1.  with 문을 실행하면 파라미터에 작성한 sports 오브젝트의 프로퍼티가 펼쳐진(spread)형태가 됩니다.  \n    따라서 프로퍼티 값을 구할 때 sports[“soccer”]형태로 작성하지 않고 soccer만 작성합니다.  \n    soccer의 프로퍼티 값인 “축구”가 반환되고 baseball의 프로퍼티 값도 마찬가지로 반환되어  \n    “축구” “야구”가 출력됩니다.\n\n2.  with(sports)를 실행할 때 sports 오브젝트에서 전개하지 않을 프로퍼티를 작성합니다.  \n    baseball: true를 설정해줬으므로 with 문에서 baseball 프로퍼티가 전개되지 않습니다.  \n    그러므로 soccer의 프로퍼티 값인 “축구”만 출력됩니다.\n\n3.  with(sports) 문에서 baseball 프로퍼티가 전개되지 않으므로 baseball을 변수에 할당하면  \n    에러가 발생합니다.\n\n* * *\n\n<h2 id=\"species_개념\">species 개념</h2>\n\nSymbol.species는 constructor를 반환합니다.  \nconstructor를 반환한다는 것은 constructor로 인스턴스를 생성하여 반환하는 것과 같습니다.  \nSymbol.species를 오버라이드 할 수 있으며, 개발자 코드로 반환되는 인스턴스를 변경할 수 있습니다.\n\nspecies의 개념을 살펴 봅니다.\n\n```js species 개념\n1. let arrayObj = [1, 2, 3];  \n2. let sliceOne = arrayObj.slice(1, 3);  \n3. let sliceTwo = sliceOne.slice(1, 2);  \n```\n\n1.  let arrayObj = [1, 2, 3]을 실행하면 Array 오브젝트(인스턴스)를 생성하고 엘리먼트 값으로  \n    1, 2, 3을 설정합니다. 아래는 [1, 2, 3]이 할당된 arrayObj 인스턴스 구조입니다.\n    <img src=\"/images/speciesArrayObj.JPG\">    \n    \n    arrayObj 구성을 보면 prototype이 없으며 &#95;&#95;proto&#95;&#95;만 있습니다.  \n    &#95;&#95;proto&#95;&#95;에는 Array 오브젝트의 prototype에 연결된 프로퍼티가 첨부되어 있습니다.  \n    Array의 오브젝트 프로퍼티가 연결되어 있지만 arrayObj에는 연결된 프로퍼티가 없습니다.  \n    따라서 arrayObj는 Array 오브젝트가 아닌 Array 인스턴스입니다.\n    \n\n2.  arrayObj.slice(1, 3) 코드는 자바스크립트에서 일반적으로 사용하는 [1, 2, 3].slice(1, 3)형태와 다릅니다.[1, 2, 3]으로 Array 인스턴스를 생성하여 arrayObj에 할당하고, arrayObj에 있는 slice()를 호출하는 형태 입니다. 실행하면 [1, 2, 3]에서 2와 3이 반환되어 sliceOne 변수에 할당될 것으로 생각할 수 있습니다.  \n    하지만, sliceOne변수에 할당되는 것은 Array 인스턴스 입니다. 2 와 3이 인스턴스 값으로 설정됩니다.  \n    arrayObj 와 sliceOne 둘다 Array 오브젝트 인스턴스 입니다. 배열의 엘리먼트 값이 달라집니다.\n\n**여기서 중요한 점은 Array 인스턴스(arrayObj)의 slice()를 호출하면 slice()실행 결과가 반영된**  \n**Array 인스턴스가 반환된다는 점입니다. Array 인스턴스가 반환되므로 sliceOne 인스턴스를 지정하여 slice()를 호출할 수 있습니다.**\n\n3.  sliceOne 인스턴스를 지정하여 slice()를 호출하고 마찬가지로 Array 인스턴스가 반환됩니다.  \n    Symbol.species를 이해하려면 먼저 이에 대한 이해가 필요합니다.\n\n* * *\n\n<h2 id=\"species\">species</h2>\n\nSymbol.species는 constructor를 반환합니다.\n\nSymbol.species는 static 액세서 프로퍼티로 getter만 있고 setter는 없습니다.  \nArray, Map, Set, Promise, RegExp, ArrayBuffer, TypedArray 오브젝트에 Symbol.species가 빌트인으로 포함되어 있습니다.\n\n위에 거론된 빌트인 오브젝트를 상속받는 클래스에 Symbol.species를 작성하면, 빌트인 오브젝트의 Symbol.species가 오버라이드됩니다. 이를 통해 클래스의 Symbol.species에서 다른 오브젝트를 반환할 수 있습니다.\n\n*   예를 들어 인스턴스의 slice()를 호출하면 slice()를 호출한 인스턴스를 반환하지만, 클래스에 Symbol.species를 작성하여 인스턴스가 아닌 Array 오브젝트를 반환할 수 있습니다. **(인스턴스 대신 인스턴스의 부모 오브젝트 반환)**\n\n```js\n1. class ExtendArray extends Array {  \n static get [Symbol.species]() {  \n return Array;  \n }  \n};  \n2. let oneInstance = new ExtendArray(1, 2, 3);  \n  \n3. let twoInstance = oneInstance.slice(1, 2);  \n4. console.log(oneInstance instanceof ExtendArray);  \n  \n5. console.log(twoInstance instanceof Array);  \n  \n6. console.log(twoInstance instanceof ExtendArray);  \n//true  \n//true  \n//false  \n```\n\n[instanceof 연산자](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/instanceof)는 생성자의 프로토 타입 속성이 객체의 프로토 타입 체인에 나타나는지 테스트하여 true/false값을 반환합니다.\n\n1.  ExtendArray 클래스에서 Array 오브젝트를 상속받습니다. 클래스에 static 메서드이면서 getter를 사용하여 Symbol.species를 작성하였습니다. Array 오브젝트의 Symbol.species가 오버라이드 됩니다.  \n    인스턴스의 Array 오브젝트 메서드를 호출하면 오버라이드된 Symbol.species가 호출됩니다.  \n    그리고 return Array;를 하므로 메서드를 호출한 인스턴스가 반환되지 않고 Array 인스턴스가 반환됩니다.\n    *   return Array가 Array 오브젝트의 constructor를 반환하지만, return 문은 오른쪽의 표현식을 평가하고 평가 결과를 반환하므로 Array 오브젝트의 constructor를 호출하고 그 결과인 Array 인스턴스를 반환합니다.\n\n2.  new 연산자로 ExtendArray()룰 호출하면서 파라미터로 1, 2, 3을 넘겨줬습니다.  \n    ExtendArray 클래스에서 Array 오브젝트를 상속받았으므로 생성한 인스턴스는 Array 오브젝트 특성을 갖습니다.\n\n3.  oneInstance 인스턴스에 상속받은 Array 오브젝트가 존재하므로 slice()를 호출할 수 있습니다.  \n    slice()가 호출되면 ExtendArray 클래스에 getter로 작성된 Symbol.species()가 호출되며,  \n    oneInstance가 반환되지 않고 Array 인스턴스를 생성하여 반환합니다.\n\n4.  new ExtendArray(1, 2, 3)으로 생성한 인스턴스를 oneInstance에 할당했으므로 true가 출력됩니다.\n\n5.  oneInstance.sliceOne(1, 2)를 실행하면 클래스에 작성한 Symbol.species()가 호출됩니다.  \n    return Array로 생성한 인스턴스를 twoInstance에 할당했으므로 true가 출력됩니다.\n\n6.  new ExtendArray()로 생성한 인스턴스를 twoInstance에 할당한 것이 아니라, Array 오브젝트로 생성한 인스턴스(oneInstance)를 할당했으므로 false가 출력됩니다.  \n    이처럼 Symbol.species로 반환되는 인스턴스를 변경할 수 있습니다.\n\n* * *\n\n<h2 id=\"return_other_Class\">다른 Class 반환</h2>\n\n위 에서 return 문에서 상속받은 Array 오브젝트를 반환하는 형태를 살펴봤습니다.  \n여기서는 다른 클래스를 반환하는 형태를 살펴봅니다.\n\n```js other-Class\n1. class ExtendOne extends Array{  \n showOne(){  \n console.log(\"ExtendOne\");  \n    \n }  \n};  \n2. class ExtendTwo extends Array{  \n static get [Symbol.species]() {  \n return ExtendOne;  \n }  \n showTwo(){  \n console.log(\"ExtendTwo\");  \n }  \n};  \n3. let twoInst = new ExtendTwo(10, 20, 30);  \nlet threeInst = twoInst.filter(value => value > 10);  \nconsole.log(threeInst);  \n  \n4. threeInst.showOne();  \nconsole.log(threeInst.showTwo);  \n/*  \nExtendOne(2)  \n 0: 20  \n 1: 30  \n length: 2  \n __proto__: Array  \n*/  \n// ExtendOne  \n// undefined  \n```\n\n1.  ExtendOne 클래스에서 Array 오브젝트를 상속받습니다.  \n    이 클래스를 아래에 작성한 2. ExtendTwo 클래스의 [Symbol.species]에서 반환합니다.\n\n2.  [Symbol.species] ( )에서 ExtendOne을 return 하므로 클래스를 반환하는 것처럼 보입니다만,  \n    클래스의 constructor를 반환하므로 인스턴스로 생성하여 반환하게 됩니다.  \n    이와 같이 [Symbol.species] ( )를 호출한 인스턴스가 아닌 다른 인스턴스로 반환할 수 있습니다.\n\n3.  twoInst.filter()가 호출되면, 우선 twoInst 인스턴스를 생성한 ExtendTwo 클래스에서 [Symbol.species] 작성 여부를 체크합니다. 존재하면 클래스의 [Symbol.species] ()를 호출하고 존재하지 않으면 상속받은 Array 오브젝트의 [Symbol.species] ()를 호출합니다.\n\n4.  호출된 [Symbol.species] ()에서 ExtendOne 인스턴스를 반환하여 ExtendTwo 클래스에서 Array 오브젝트를 상속받았으므로 [filter()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) 메서드를 호출할 수 있습니다.  \n    ExtendOne 클래스에서 filter() 메서드를 지원하지 않는 오브젝트를 상속받으면 Error가 발생합니다.\n\nfilter() 실행 결과 twoInst에 설정하지 않고 반환할 인스턴스에 할당합니다. 즉 threeInst 인스턴스에 할당됩니다. 따라서 twoInst 인스턴스 값 [10, 20, 30]이고 threeInst 인스턴스 값은 [20, 30]입니다.\n\n5.  return ExtendOne으로 인해 ExtendOne 인스턴스가 threeInst에 설정되므로,  \n    threeInst 인스턴스의 showOne()을 호출할 수 있습니다. showTwo는 존재하지 않으므로 undefined가 출력됩니다.\n\n* * *\n\n<h2 id=\"return_null\">null 반환</h2>\n\n[Symbol.species] ()에서 null을 반환하면 디폴트[Symbol.species] ()가 호출됩니다.\n\n```js\nclass ExtendOne extends Array{  \n static get [Symbol.species]() {  \n return null;  \n }  \n};  \n1. let oneInst = new ExtendOne(10, 20, 30);  \nlet arrayInst = oneInst.filter(value => value > 10);  \n  \n2. console.log(arrayInst instanceof Array);  \n3. console.log(arrayInst instanceof ExtendOne);  \n// true  \n// false  \n```\n\n1.  oneInst.filter()를 호출하면 ExtendOne 클래스의 [Symbol.species] ()가 호출되며 null를 반환합니다.  \n    null이 반환되면 디폴트 [Symbol.species] ()가 호출됩니다.  \n    ExtendOne 클래스에 작성하지 않았지만 상속받은 Array 오브젝트에 있으므로 [Symbol.species] ()가 호출되며  \n    Array 인스턴스를 생성하여 반환합니다. 따라서 filter()를 실행할 수 있습니다.\n\n2.  oneInst.filter()를 실행하면 [Symbol.species] ()에서 Array 인스턴스를 반환하여 arrayInst에 할당하므로 true값이 출력됩니다.\n\n3.  [Symbol.species] ()에서 Array 인스턴스를 반환하므로 arrayInst는 ExtendOne 클래스의 인스턴스가 아닙니다.  \n    false\n\n* * *\n\n<h2 id=\"toPrimitive\">toPrimitive</h2>\n\n오브젝트를 프리미티브(원시값) 타입으로 변환합니다.\n\n자바스크립트의 프리미티브 값은 number, string, boolean, undefined, null 그리고 symbol입니다.  \n+연산자는 앞뒤의 값 타입에 따라 값을 더하거나 연결합니다. (1+2)는 3이되지만 (1+”2”)는 12가 됩니다.  \n반면 곱하기(*), 나누기(/), 빼기(-)는 연산만 하고 연결은 하지 않습니다.\n\n<mark>연산 대상이 Number 타입이 아닐 경우 엔진의 ToPrimitive 모듈을 기준으로 값을 변환합니다. 예를 들어, 숫자에 true를 더하면 1로 변환하여 더하고, 문자열에 true를 더하면 \"true\"로 변환하여 연결합니다. 이때 Symbol.toPrimitive()로 ToPrimitive를 오버라이드하여 엔진의 변환 기준을 변경할 수 있습니다.</mark>(엔진의 디폴트 변환 값을 개발자 코드로 변경)\n\n### 세 가지 모드\n\nSymbol.toPrimitive() 에서 값을 변환하는 기준은 이를 호출하는 형태에 따라 결정됩니다.\n\n엔진은 호출한 곳의 형태에 따라 Symbol.toPrimitive(hint) 파라미터에 세 가지 모드(Mode)를 설정합니다.  \n~~개발자가 작성하는 것이 아니라 엔진이 다음 기준으로 설정하는 것입니다.~~\n\n1.  Number 환경이면 “number”를 toPrimitive(hint) 파라미터에 설정합니다.\n    \n2.  String 환경이면 “string”을 toPrimitive(hint) 파라미터에 설정합니다.\n    \n3.  Number 와 String 환경이 아니면 toPrimitive(hint) 파라미터에 “default”를 설정합니다.\n    \n```js\nlet obj = {  \n [Symbol.toPrimitive](hint){  \n if (hint === \"number\"){  \n return 30;  \n };  \n if (hint === \"string\"){  \n return \"문자열\";  \n };  \n return \"디폴트\";  \n }  \n};  \n1. console.log(\"1:\", 20 + obj); // 1: 20디폴트  \n2. console.log(\"2:\", 20 * obj); // 2: 600  \n  \n3. console.log(\"3:\", obj + 50); // 3: 디폴트50  \n4. console.log(\"4:\", +obj + 50);// 4: 80  \n5. console.log(\"5:\", `${obj}` + 123); // 5: 문자열123  \n```\n\n1.  (20 + obj)와 같이 오브젝트가 연산 대상이면, 자동으로 obj 오브젝트의 [Symbol.toPrimitive] ()가 호출됩니다. 파라미터에 “default”가 설정됩니다. 함수에서 “디폴트”를 반환하여 문자열을 연결하는 형태가 되어 “20디폴트”가 출력됩니다.\n\n2.  곱하기(*)를 사용하였으므로 파라미터에 “number”가 설정됩니다. 함수에서 30을 반환하며 20을곱해 600이 출력됩니다.\n\n3.  (20 + obj)에서 파라미터에 “default”가 설정되듯이 마찬가지로 “default”가 설정됩니다.  \n    함수에서 “디폴트”를 반환하여 50을 연결하므로 “디폴트50”이 출력됩니다.\n\n4.  +obj 에서 +는 단항+연산자로 피연산자를 Number 타입으로 변환합니다.  \n    함수에서 30을 반환하며 50을더해 80이 출력됩니다.\n\n5.  템플릿을 사용한 형태로 파라미터에 “string”이 설정됩니다. 함수에서 “문자열”을 반환하여  \n    ${obj}가 “문자열”로 변환됩니다. 123을 연결하여 “문자열123”이 출력됩니다.\n\n* * *\n\n<h2 id=\"Symbol_iterator\">이터레이터</h2>\n\nSymbol.iterator()는 이터레이터 오브젝트를 생성하여 반환합니다.\n\nSymbol.iterator는 String, Array, Map, Set, TypedArray 오브젝트의 prototype에 연결되어 있습니다.  \n오브젝트의 [Symbol.iterator]를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.\n\nObject 오브젝트에는 Symbol.iterator가 없습니다만, 개발자 코드로 구현할 수 있습니다.\n\n### Array.prototype[Symbol.iterator]\n\n배열 처리를 위한 이터레이터 오브젝트를 생성하여 반환합니다. 배열 엘리먼트를 하나씩 처리할 수 있습니다.\n\n```js iterator-Array\nlet numberArray = [10, 20];  \nfor (let value of numberArray){  \n console.log(value);  \n};  \nlet iteratorObj = numberArray[Symbol.iterator]();  \n  \nconsole.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \n//10  \n//20  \n/*Object  \n value: 10  \n done: false  \n __proto__: Object*/  \n/*Object  \n value: 20  \n done: false  \n __proto__: Object*/  \n/*Object  \n value: undefined  \n done: true  \n __proto__: Object*/  \n```\n\n*   numberArray는 Array 오브젝트 인스턴스 구조입니다.  \n    Symbol.iterator()를 호출할 수 있습니다.\n    \n*   numberArray[Symbol.iterator] ()는 numberArray 인스턴스의 Symbol.iterator()를 호출하는 것으로 이터레이터 오브젝트를 생성하여 반환합니다. 이터레이터 오브젝트를 사용하여 배열 엘리먼트를 하나씩 처리할 수 있습니다.\n    \n*   next()를 호출할 때마다 배열 엘리먼트 값을 {value: 10, done:false} 형태로 반환합니다.\n    \n\n### String.prototype[Symbol.iterator]\n\n문자열 처리를 위한 이터레이터 오브젝트를 반환합니다.\n\n문자열을 문자 단위로 하나씩 처리할 수 있습니다.\n\n```js iterator-string\nlet stringValue = \"1A\";  \nfor (let value of stringValue) {  \n console.log(value);  \n}  \n  \nlet iterObj = stringValue[Symbol.iterator]();  \n  \nconsole.log(iterObj.next());  \nconsole.log(iterObj.next());  \nconsole.log(iterObj.next());  \n// 1  \n// A  \n  \n// Object {value: \"1\", done: false}  \n// Object {value: \"A\", done: false}  \n// Object {value: undefined, done: true}  \n```\n\n*   “1A”를 1과 A로 분리하여 for-of문을 실행합니다. 문자 단위로 반복할 수 있는 것은  \n    String.prototype에 Symbol.iterator가 있기 때문입니다.  \n    for-of문에서 stringValue를 String 오브젝트로 생성하고 그 안에 Symbol.iterator()를 사용합니다.\n    \n*   stringValue[Symbol.iterator] ();형태로 호출하면 이터레이터 오브젝트를 반환합니다.  \n    이터레이터 오브젝트를 사용하여 문자열을 문자 단위로 하나씩 처리할 수 있습니다.\n    \n*   next()를 호출할 때마다 문자열의 문자를 value 프로퍼티에 설정하고 {value: “1”, done: false}형태로 반환합니다.\n    \n\n### Object 이터레이션\n\nObject 오브젝트에는 기본적으로 Symbol.iterator를 갖고 있지 않습니다. (for-of 등 반복처리불가.)\n\n<mark>Object 오브젝트에 Symbol.iterator를 작성하면 반복 처리를 할 수 있습니다.</mark>\n\n```js iterator-Object\n1. let obj = {  \n [Symbol.iterator](){  \n    2. return {  \n        maxCount: 2,  \n        count: 0,  \n        next(){   \n            if (this.count < this.maxCount){  \n            return {value: this.count++, done: false};  \n            }  \n            return {value: undefined, done: true};  \n            }  \n        }  \n    }  \n};  \n  \n3. let iteratorObj = obj[Symbol.iterator]();  \nconsole.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \n```\n\n1.  Object 오브젝트를 반복처리 하기 위해서 [Symbol.iterator] ()를 obj prototype에 작성해줬습니다.\n\n2.  호출된 obj[Symbol.iterator] ()의 return으로 반환된 오브젝트를 iteratorObj에 할당합니다.\n\n3.  iteratorObj에 next()가 있으므로 iteratorObj.next() 형태로 호출할 수 있습니다.\n\n* * *\n\n<h2 id=\"Symbol_generator\">제너레이터</h2>\n\nObject 오브젝트에 Symbol.iterator를 제너레이터 함수로 작성하면, 이터레이터로 반복할 때 마다 yield를 수행합니다.\n\n```js\n1. obj[Symbol.iterator] = function*(){  \n yield 10;  \n yield 20;  \n yield 30;  \n};  \n2. let result = [...obj];  \nconsole.log(result);  \n//[10, 20, 30]  \n```\n\n1.  obj 오브젝트의 [Symbol.iterator]를 제너레이터 함수로 작성하였습니다.  \n    이터레이터로 반복할 때 마다 yield 표현식을 평가하여 값을 반환합니다.\n\n2.  대괄호 [] 안에 spread 연산자로 obj 오브젝트를 작성했습니다. […obj]를 시작하면  \n    엔진에서 obj에 [Symbol.iterator] 작성 여부를 체크합니다. 작성되있으므로  \n    [Symbol.iterator] ()가 호출되며 이터레이터 오브젝트를 생성하여 반환합니다.  \n    이터레이터가 반복될 때마다 yield에서 반환한 값을 배열에 첨부합니다.  \n    반복이 끝나면 생성된 배열을 반환합니다.\n\n* * *\n\n<h2 id=\"Symbol_asyncIterator\">asyncIterator(): 비동기 반복</h2>\n\nSymbol.asyncIterator는 오브젝트의 asyncIterator 기본 값을 지정합니다.  \nasyncIterator 프로퍼티가 오브젝트에 설정되면 await for of 루프(loop)에서 비동기 반복할 수 있습니다.\n\n오브젝트가 비동기 반복이 가능하려면 Symbol.asyncIterator 프로퍼티 키가 존재해야합니다.\n\n```js\nconst myAsyncIterable = {  \n    async* [Symbol.asyncIterator]() {  \n        yield \"hello\";  \n        yield \"async\";  \n        yield \"iteration!\";  \n    }  \n};  \n  \n(async () => {  \n    for await (const x of myAsyncIterable) {  \n    console.log(x);  \n        // \"hello\"  \n        // \"async\"  \n        // \"iteration!\"  \n }  \n})();  \n```\n\n*   오브젝트의 [Symbol.asyncIterator] 속성을 설정해줌으로써 비동기 이터러블을 커스텀하여 정의할 수 있습니다.\n\n<mark>현재 기본적으로 [Symbol.asyncIterator] 프로퍼티가 built-in 되어 있는 JavaScript 오브젝트는 없습니다.</mark>\n\n하지만 WHATWG(Web Hypertext Application Technology Working Group, WHATWG)에서는  \n최근에 [Symbol.asyncIterator]가 스펙에 기준에 도달함으로써 비동기 반복이 가능한 첫 번째 built-in 오브젝트로 설정되었습니다.\n\n[WHATWG 위키](https://ko.wikipedia.org/wiki/WHATWG)  \n[WHATWG 공식홈페이지](https://whatwg.org/)\n\n* * *\n\n<h2 id=\"Symbol_match\">match(): match 결과 반환</h2>\n\nString 오브젝트에서 정규 표현식을 사용할 수 있는 메서드  \nmatch(), replace(), search(), split() 에 대응하는\n\nSymbol 오브젝트 Symbol.match(), Symbol.replace(), Symbol.search(), Symbol.split()이 있습니다.\n\n*   String.prototype.match()가 호출되면 먼저 오브젝트에서 Symbol.match 작성 여부를 체크합니다.  \n    작성돼있다면 오브젝트의 Symbol.match()를 호출합니다. String.prototype.match()는 호출되지 않습니다.\n\n```js\n1. console.log(\"1\", \"Sports\".match(/s/));  \n// 1: [0: \"5\", index: 5, input: \"Sports\"]  \n  \nclass MatchCheck {  \n constructor(base) {  \n this.base = base;  \n }  \n 2. [Symbol.match](target) {  \n return this.base.indexOf(target) >= 0;  \n }  \n}  \n3. let instMatch = new MatchCheck(\"sports\");  \n4. console.log(\"2:\", \"po\".match(instMatch));  \n// 2: true  \n```\n\n1.  “Sports”에 패턴/s/를 매치하면 매치 결과를 배열로 반환합니다. “Sports”가 문자열이므로  \n    엔진이 String.prototype에 연결된 프로퍼티로 String 인스턴스를 생성합니다.  \n    생성한 인스턴스에 “Sports”를 설정한 후 match()를 호출하면서 /s/를 파라미터로 넘겨줍니다.\n\n2.  Symbol.match()의 target 파라미터에 설정된 문자열이 this.base에 포함되어 있으면 true를 반환하고, 아니면 false를 반환합니다.\n\n3.  new MatchCheck(“sports”);를 실행하면 constructor가 호출되고 파라미터로 넘겨 준 “sports”가 this.base에 설정됩니다.\n\n4.  “po”.match(instMatch)가 호출되면 파라미터에 작성한 instMatch 인스턴스에서 Symbol.match의 작성 여부를 체크합니다. 존재하므로 Symbol.match(target)을 호출하면서 “po”를 파라미터 값으로 넘겨줍니다.  \n    Symbol.match()에서 “sports” 와 “po”로 match를 행하며, “po”가 있으므로 true를 반환합니다.\n\n\n<h2 id=\"Symbol_matchAll\">matchAll()</h2>\n\nSymbol.matchAll 은 String 오브젝트를 정규표현식으로 평가하여  \n반환결과를 이터레이터 오브젝트로 반환합니다.\n\nSymbol.matchAll은 [String.prototype.matchAll()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll)메서드에 의해 호출 됩니다.\n\n+참고 [RegExp.prototype[@@matchAll] ( )](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@matchAll)\n\n```js\nlet re = /[0-9]+/g;  \nlet str = '2016-01-02|2019-03-07';  \nlet result = re[Symbol.matchAll](str);  \n  \nconsole.log(Array.from(result, x => x[0]));  \n// expected output: Array [\"2016\", \"01\", \"02\", \"2019\", \"03\", \"07\"]  \n```","source":"_posts/Symbol 프로퍼티 -ECMAScript.md","raw":"---\ntitle: Symbol 프로퍼티 -ECMAScript\ndate: 2020-04-06 12:55:12\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n\nSymbol 오브젝트에 프로퍼티들을 살펴봅니다.  \n이 프로퍼티들은 메서드로도 사용할 수 있습니다\n\n*   Symbol 프로퍼티\n    *   [Well-Known Symbol](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Well-Known_Symbol)\n    *   [toStringTag](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#toStringTag)\n        *   클래스의 메서드로 사용\n    *   [isConcatSpreadable](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#isConcatSpreadable)\n        *   Array-like 오브젝트에서 사용\n    *   [unscopable](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#unscopable)\n    *   [species 개념](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#species_개념)\n    *   [species](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#species)\n    *   [다른 Class 반환](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#return_other_Class)\n    *   [null 반환](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#return_null)\n    *   [toPrimitive](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#toPrimitive)\n        *   toPrimitive() 파라미터의 세가지 모드(mode)\n    *   [이터레이터](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_iterator)\n        *   Array.prototype[Symbol.iterator]\n        *   String.prototype[Symbol.iterator]\n        *   Object 이터레이션\n    *   [제너레이터](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_generator)\n    *   [asyncIterator(): 비동기 반복](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_asyncIterator)\n    *   [match(): match 결과 반환](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_match)\n    *   [matchAll()](/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_matchAll)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"Well-Known_Symbol\">Well-Known Symbol</h2>\n\n\n스펙에서 @@iterator 형태로 작성된 것을 볼 수 있으며  \n@@는 Symbol 대신 사용한 것입니다.  \n따라서 @@iterator는 Symbol.iterator와 같습니다.  \n@@iterator 형태는 스펙에서 사용하며 Symbol.iterator 형태는 내부 프로퍼티인  \n[[Description]]에 저장되는 형태입니다.  \n개발자 코드에서는 Symbol.iterator 형태를 사용합니다.\n\n | Spec name            | [[Description]]              |\n|----------------------|------------------------------|\n| @@asyncIterator      | Symbol.asyncIterator         |\n| @@hasInstance        | Symbol.hasInstance           |\n| @@isConcatSpreadable | Symbol.isConcatSpreadable    |\n| @@iterator           | Symbol.iterator              |\n| @@match              | Symbol.match                 |\n| @@matchAll           | Symbol.matchAll              |\n| 참고용 프로퍼티      | Symbol.prototype.description |\n| @@replace            | Symbol.replace               |\n| @@search             | Symbol.search                |\n| @@species            | Symbol.species               |\n| @@split              | Symbol.split                 |\n| @@toPrimitive        | Symbol.toPrimitive           |\n| @@toStringTag        | Symbol.toStringTag           |\n| @@unscopables        | Symbol.unscopables           |\n\n\n\n* Well-Known Symbol은 스펙에서 처리 알고리즘(Algorism)을 구분하기 위해 부여한 이름입니다. 즉, 자바스크립트 엔진이 디폴트로 처리하는 알고리즘 유형 이름입니다.\n    \n* <mark>자바스크립트 프로그램에 같은 이름의 Well-Known.Symbol을 작성하면  \n엔진의 디폴트 처리를 실행하지 않고 프로그램에 작성한 코드를 실행합니다(오버라이딩)  \nWell-Known Symbol이 오버라이드되는 것과 같으므로 프로그램에 같은 이름을작성하여  \nWell-Known Symbol기능을 대체할 수 있습니다.</makr>\n    \n\n**이런 가변성과 유용성을 제공하는 것이 Well-Known Symbol의 목적입니다.**\n\n* * *\n\n<h2 id=\"toStringTag\">toStringTag</h2>\n\n[object Object] 형태에서 Object를 Symbol.toStringTag 값으로 표시합니다.  \n객체의 기본 문자열 설명을 만드는 데 사용되는 문자열 값 속성입니다.  \n[Object.prototype.toString()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/toString) 메소드에 의해 내부적으로 액세스됩니다.\n\n### 설명\n\n**많은 자바스크립트 타입들은 기본적으로 tag를 가지고 있습니다.**\n\n```js tag default\nObject.prototype.toString.call('foo');     \n// \"[object String]\"  \nObject.prototype.toString.call([1, 2]);    \n// \"[object Array]\"  \nObject.prototype.toString.call(3);         \n// \"[object Number]\"  \nObject.prototype.toString.call(true);      \n// \"[object Boolean]\"  \nObject.prototype.toString.call(undefined); \n// \"[object Undefined]\"  \nObject.prototype.toString.call(null);      \n// \"[object Null]\"  \n\n// ... and more  \n```\n\n**기본적으로 toStringTag symbol이 정의되어 있는 것도 있습니다.**\n\n```js\nObject.prototype.toString.call(new Map());       \n// \"[object Map]\"  \nObject.prototype.toString.call(function* () {}); \n// \"[object GeneratorFunction]\"  \nObject.prototype.toString.call(Promise.resolve()); \n// \"[object Promise]\" \n\n// ... and more  \n```\n\n**class를 생성하면 자바스크립트는 기본값으로 Object tag를 설정합니다.**\n\n```js\nclass ValidatorClass {}  \n  \nObject.prototype.toString.call(new ValidatorClass()); \n// \"[object Object]\"  \n```\n\n**toStringTag를 이용하여 자신만의 맞춤 태그를 설정할 수 있습니다.**\n\n```js\nclass ValidatorClass {  \n get [Symbol.toStringTag]() {  \n return 'Validator';  \n }  \n}  \nObject.prototype.toString.call(new ValidatorClass()); \n// \"[object Validator]\"  \n```\n\n```js toStringTag 예제\nlet Sports = function(){};  \nlet sportsObj = new Sports;  \n1. console.log(sportsObj.toString());  \n  \n2. Sports.prototype[Symbol.toStringTag] = \"Sports-Function\";  \n3. console.log(sportsObj.toString());  \n// [object Object]  \n// [object Sports-Function]  \n```\n\n1.  new Sports로 생성한 인스턴스로 toString()을 실행하면 [object Object]가 반환됩니다.  \n    Object 오브젝트도 [object Object]를 반환하므로 구분이 어렵습니다.  \n    한편 new Sports()의 파라미터 값이 없을때 new sports; 로 사용할 수 있습니다.\n\n2.  Sports.prototype[Symbol.toStringTag] = “Sports-Function”;  \n    Sports.prototype[Symbol.toStringTag]에 [object Object] 의 Object에 표시할 문자열을 지정합니다.\n\n3.  sportsObj.toString()을 실행하면 엔진에서 디폴트 toStringTag 값을 반환하기 전에  \n    sportsObj에서 Symbol.toStringTag의 작성 여부를 체크합니다.  \n    값이 작성되어 있다면 디폴트 값이 아닌 작성된 값을 반환합니다.  \n    따라서 [object Sports-Function] 이 출력됩니다.  \n    [object Sports-Function]을 정규표현식으로 분리하면 Sports-Function을 구할 수 있습니다.\n\n### 클래스의 메서드로 사용\n\nSymbol.toStringTag를 클래스의 getter로 작성할 수 있습니다.\n\n```js\nclass Book {};  \nlet bookObj = new Book();  \n1. console.log(bookObj.toString());  \n  \n2. class Sports {  \n get [Symbol.toStringTag]() {  \n return \"Sports-class\";  \n }  \n};  \n3. let sportsObj = new Sports();  \nconsole.log(sportsObj.toString());  \n  \n4. console.log(Map.prototype[Symbol.toStringTag]);  \n//[object Object]  \n//[object Sports-class]  \n//Map  \n```\n\n1.  toString()을 실행하면 [object Object]가 반환됩니다.  \n    따라서 Function 오브젝트, Object 오브젝트와 구분할 수 없습니다.\n\n2.  클래스에 Symbol.toStringTag를 getter로 선언했습니다.  \n    return 문에 [object Object]에서 Object에 표시될 문자열을 작성했습니다.Sports-class가 반환됩니다.  \n    getter로 작성하지 않고 메서드로 작성하면 [object Object]가 반환되므로 getter로 작성해야 합니다.\n\n3.  인스턴스로 toString()을 호출하면 sportsObj 인스턴스에 작성된 getSymbol.toStringTag가 호출됩니다.  \n    호출된 메서드에서 “Sports-class”를 반환하므로 [object Sports-class]가 출력됩니다.\n\n4.  Map 같이 Symbol.toStringTag를 기본값(빌트인)으로 가지고 있는 것들이 있습니다.  \n    Map.prototype[Symbol.toStringTag]를 실행하면 “Map”이 출력됩니다.  \n    개발자 코드로 Symbol.toStringTag에 표시될 문자열을 작성하거나 getter를 사용하지 않아도 됩니다.\n\n* * *\n\n<h2 id=\"isConcatSpreadable\">isConcatSpreadable</h2>\n\nSymbol.isConcatSpreadable는  \n[Array.prototype.concat()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) 메서드를 사용할 때 객체를 배열 요소에 병합해야하는지 구성하는 데 사용됩니다.\n\n> [Symbol.isConcatSpreadable] = true / false\n\n*   프로퍼티의 기본값은 true 입니다.  \n    false로 설정시 배열을 펼처서 합치지 않고 배열의 끝에 배열을 추가합니다.  \n    사용시 true/false 에 따라 생성되는 배열의 length값이 달라집니다.\n\n```js\n1. let one = [11, 12], two = [21, 22];  \nlet result = one.concat(two);  \nconsole.log(result, result.length);  \n/*  \nArray(4)  \n 0: 11  \n 1: 12  \n 2: 21  \n 3: 22  \n length: 4  \n __proto__: Array(0)  \n4   \n*/  \n  \n2. two[Symbol.isConcatSpreadable] = false;  \nresult = one.concat(two);  \nconsole.log(result, result.length);  \n/*  \nArray(3)  \n 0: 11  \n 1: 12  \n 2: Array(2)  \n 0: 21  \n 1: 22  \n length: 2  \n Symbol(Symbol.isConcatSpreadable): true  \n __proto__: Array(0)  \n length: 3  \n __proto__: Array(0)  \n3  \n*/  \n  \n3. two[Symbol.isConcatSpreadable] = true;  \nresult = one.concat(two);  \nconsole.log(result, result.length);  \n/*  \nArray(4)  \n 0: 11  \n 1: 12  \n 2: 21  \n 3: 22  \n length: 4  \n __proto__: Array(0)  \n4  \n*/  \n```\n\n1.  one 배열의 [11, 12]에 concat()의 파라미터에 지정한 two 배열 [21, 22]를 결합하면,  \n    21 과 22가 각각 분리되어 one 배열 끝에 추가됩니다.  \n    [11, 12, 21, 22] length: 4 가 반환됩니다.  \n    Array.prototype에 [Symbol.isConcatSpreadable]을 작성하지 않았으므로 디폴트 true값 입니다.  \n    일반적인 concat()메서드 사용입니다.\n\n2.  two[Symbol.isConcatSpreadable]에 false 값을 할당했습니다.  \n    concat() 메서드로 one 배열과 two 배열을 결합하면 two 배열의 [21, 22]를 분리하지 않고  \n    배열 자체를 첨부합니다. [11, 12, Array[2]] 형태로 결합되어 length 값은 3을 갖습니다.  \n    개발자 도구에서 Array[2]를 살펴보면 [21, 22] length: 2 가 할당되어 있고  \n    Symbol(Symbol.isConcatSpreadable): true로 isConcatSpreadable = false 가 적용된 것을 볼 수 있습니다. 기본값 isConcatSpreadable = true 인 경우 프로퍼티에 나타나지 않습니다.\n\n3.  two[Symbol.isConcatSpreadable]에 true를 할당하였으며 디폴트 값 true와 같습니다.  \n    one 배열에 two 배열의 [21, 22]가 분리되어 끝에 첨부됩니다.  \n    [11, 12, 21, 22] 형태가 됩니다.\n\n### Array-like 오브젝트에서 사용\n\n<mark>유사 배열(Array-like) 오브젝트도 concat()을 사용할 수 있습니다. 하지만 유사 배열 오브젝트는 isConcatSpreadable = true 값을 가지지 않습니다.</mark> concat()으로 배열을 하나씩 분리하여 추가 병합하고 싶다면 isConcatSpreadable를 사용하여 true로 설정해줍니다.\n\n```js isConcatSpreadable > Array-like\nlet one = [11, 12];  \n1. let fiveSix = {  \n 0: \"five\",  \n 1: \"six\",  \n length: 2  \n};  \nlet result = one.concat(fiveSix);  \nconsole.log(result, result.length);  \n/*  \nArray(3)  \n 0: 11  \n 1: 12  \n 2: Object{  \n 0: \"five\",   \n 1: \"six\",   \n length: 2}   \n length: 3  \n __proto__: Array(0)  \n3  \n*/  \n  \n2. let arrayLike = {  \n [Symbol.isConcatSpreadable]: true,  \n 0: \"five\",  \n 1: \"six\",  \n length: 2  \n};  \nresult = one.concat(arrayLike);  \nconsole.log(result, result.length);  \n/*  \nArray(4)  \n 0: 11  \n 1: 12  \n 2: \"five\"  \n 3: \"six\"  \n length: 4  \n __proto__: Array(0)  \n4  \n*/  \n```\n\n1.  one은 배열 [11, 12]이고 fiveSix는 Array-like {0: “five”, 1” “six”, length:2}입니다.  \n    이 상태에서 concat()을 실행하면 [11, 12, Object] 형태가 됩니다.  \n    오브젝트 형태가 분리되어 첨부되지 않습니다.\n\n2.  Array-like 오브젝트에 [Symbol.isConcatSpreadable]: true를 작성하여,  \n    concat()을 실행하면 Array-like 오브젝트의 각 프로퍼티를 분리하여 배열 끝에 첨부합니다.\n\n* * *\n\n<h2 id=\"unscopable\">unscopable</h2>\n\n[with](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/with)문에서 사용하며 값이 true 이면 프로퍼티를 전개 하지 않습니다.\n\n> [Symbol.unscopables] = true/false\n\nSymbol.unscopables 값이 true일 때, with 문에서 프로퍼티를 전개하지 않으므로  \nObject 오브젝트의 프로퍼티 키를 사용하면 에러가 발생합니다.\n\nES5 에서 “use strict” 범위에 with 문을 사용하면 에러가 발생합니다.ES6도 마찬가지 입니다. ES6에서 stirct모드는 보편적인 환경이므로 Symbol.unscopables를 사용할 빈도가 그다지 높지 않습니다.\n\n```js Symbol.unscopables\n// \"use strict\" 를 선언하면 with 에서 에러 발생  \nlet sports = {  \n soccer: \"축구\",  \n baseball: \"야구\"  \n};  \n1. with(sports){  \n console.log(soccer, baseball);  \n};  \n  \n2. sports[Symbol.unscopables] = {  \n baseball: true  \n};  \n  \ntry {  \n 3. with (sports) {  \n console.log(soccer);  \n let value = baseball;  \n }  \n} catch (e) {  \n console.log(e.message);  \n};  \n// 축구 야구  \n// 축구  \n// baseball is not defined  \n```\n\n1.  with 문을 실행하면 파라미터에 작성한 sports 오브젝트의 프로퍼티가 펼쳐진(spread)형태가 됩니다.  \n    따라서 프로퍼티 값을 구할 때 sports[“soccer”]형태로 작성하지 않고 soccer만 작성합니다.  \n    soccer의 프로퍼티 값인 “축구”가 반환되고 baseball의 프로퍼티 값도 마찬가지로 반환되어  \n    “축구” “야구”가 출력됩니다.\n\n2.  with(sports)를 실행할 때 sports 오브젝트에서 전개하지 않을 프로퍼티를 작성합니다.  \n    baseball: true를 설정해줬으므로 with 문에서 baseball 프로퍼티가 전개되지 않습니다.  \n    그러므로 soccer의 프로퍼티 값인 “축구”만 출력됩니다.\n\n3.  with(sports) 문에서 baseball 프로퍼티가 전개되지 않으므로 baseball을 변수에 할당하면  \n    에러가 발생합니다.\n\n* * *\n\n<h2 id=\"species_개념\">species 개념</h2>\n\nSymbol.species는 constructor를 반환합니다.  \nconstructor를 반환한다는 것은 constructor로 인스턴스를 생성하여 반환하는 것과 같습니다.  \nSymbol.species를 오버라이드 할 수 있으며, 개발자 코드로 반환되는 인스턴스를 변경할 수 있습니다.\n\nspecies의 개념을 살펴 봅니다.\n\n```js species 개념\n1. let arrayObj = [1, 2, 3];  \n2. let sliceOne = arrayObj.slice(1, 3);  \n3. let sliceTwo = sliceOne.slice(1, 2);  \n```\n\n1.  let arrayObj = [1, 2, 3]을 실행하면 Array 오브젝트(인스턴스)를 생성하고 엘리먼트 값으로  \n    1, 2, 3을 설정합니다. 아래는 [1, 2, 3]이 할당된 arrayObj 인스턴스 구조입니다.\n    <img src=\"/images/speciesArrayObj.JPG\">    \n    \n    arrayObj 구성을 보면 prototype이 없으며 &#95;&#95;proto&#95;&#95;만 있습니다.  \n    &#95;&#95;proto&#95;&#95;에는 Array 오브젝트의 prototype에 연결된 프로퍼티가 첨부되어 있습니다.  \n    Array의 오브젝트 프로퍼티가 연결되어 있지만 arrayObj에는 연결된 프로퍼티가 없습니다.  \n    따라서 arrayObj는 Array 오브젝트가 아닌 Array 인스턴스입니다.\n    \n\n2.  arrayObj.slice(1, 3) 코드는 자바스크립트에서 일반적으로 사용하는 [1, 2, 3].slice(1, 3)형태와 다릅니다.[1, 2, 3]으로 Array 인스턴스를 생성하여 arrayObj에 할당하고, arrayObj에 있는 slice()를 호출하는 형태 입니다. 실행하면 [1, 2, 3]에서 2와 3이 반환되어 sliceOne 변수에 할당될 것으로 생각할 수 있습니다.  \n    하지만, sliceOne변수에 할당되는 것은 Array 인스턴스 입니다. 2 와 3이 인스턴스 값으로 설정됩니다.  \n    arrayObj 와 sliceOne 둘다 Array 오브젝트 인스턴스 입니다. 배열의 엘리먼트 값이 달라집니다.\n\n**여기서 중요한 점은 Array 인스턴스(arrayObj)의 slice()를 호출하면 slice()실행 결과가 반영된**  \n**Array 인스턴스가 반환된다는 점입니다. Array 인스턴스가 반환되므로 sliceOne 인스턴스를 지정하여 slice()를 호출할 수 있습니다.**\n\n3.  sliceOne 인스턴스를 지정하여 slice()를 호출하고 마찬가지로 Array 인스턴스가 반환됩니다.  \n    Symbol.species를 이해하려면 먼저 이에 대한 이해가 필요합니다.\n\n* * *\n\n<h2 id=\"species\">species</h2>\n\nSymbol.species는 constructor를 반환합니다.\n\nSymbol.species는 static 액세서 프로퍼티로 getter만 있고 setter는 없습니다.  \nArray, Map, Set, Promise, RegExp, ArrayBuffer, TypedArray 오브젝트에 Symbol.species가 빌트인으로 포함되어 있습니다.\n\n위에 거론된 빌트인 오브젝트를 상속받는 클래스에 Symbol.species를 작성하면, 빌트인 오브젝트의 Symbol.species가 오버라이드됩니다. 이를 통해 클래스의 Symbol.species에서 다른 오브젝트를 반환할 수 있습니다.\n\n*   예를 들어 인스턴스의 slice()를 호출하면 slice()를 호출한 인스턴스를 반환하지만, 클래스에 Symbol.species를 작성하여 인스턴스가 아닌 Array 오브젝트를 반환할 수 있습니다. **(인스턴스 대신 인스턴스의 부모 오브젝트 반환)**\n\n```js\n1. class ExtendArray extends Array {  \n static get [Symbol.species]() {  \n return Array;  \n }  \n};  \n2. let oneInstance = new ExtendArray(1, 2, 3);  \n  \n3. let twoInstance = oneInstance.slice(1, 2);  \n4. console.log(oneInstance instanceof ExtendArray);  \n  \n5. console.log(twoInstance instanceof Array);  \n  \n6. console.log(twoInstance instanceof ExtendArray);  \n//true  \n//true  \n//false  \n```\n\n[instanceof 연산자](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/instanceof)는 생성자의 프로토 타입 속성이 객체의 프로토 타입 체인에 나타나는지 테스트하여 true/false값을 반환합니다.\n\n1.  ExtendArray 클래스에서 Array 오브젝트를 상속받습니다. 클래스에 static 메서드이면서 getter를 사용하여 Symbol.species를 작성하였습니다. Array 오브젝트의 Symbol.species가 오버라이드 됩니다.  \n    인스턴스의 Array 오브젝트 메서드를 호출하면 오버라이드된 Symbol.species가 호출됩니다.  \n    그리고 return Array;를 하므로 메서드를 호출한 인스턴스가 반환되지 않고 Array 인스턴스가 반환됩니다.\n    *   return Array가 Array 오브젝트의 constructor를 반환하지만, return 문은 오른쪽의 표현식을 평가하고 평가 결과를 반환하므로 Array 오브젝트의 constructor를 호출하고 그 결과인 Array 인스턴스를 반환합니다.\n\n2.  new 연산자로 ExtendArray()룰 호출하면서 파라미터로 1, 2, 3을 넘겨줬습니다.  \n    ExtendArray 클래스에서 Array 오브젝트를 상속받았으므로 생성한 인스턴스는 Array 오브젝트 특성을 갖습니다.\n\n3.  oneInstance 인스턴스에 상속받은 Array 오브젝트가 존재하므로 slice()를 호출할 수 있습니다.  \n    slice()가 호출되면 ExtendArray 클래스에 getter로 작성된 Symbol.species()가 호출되며,  \n    oneInstance가 반환되지 않고 Array 인스턴스를 생성하여 반환합니다.\n\n4.  new ExtendArray(1, 2, 3)으로 생성한 인스턴스를 oneInstance에 할당했으므로 true가 출력됩니다.\n\n5.  oneInstance.sliceOne(1, 2)를 실행하면 클래스에 작성한 Symbol.species()가 호출됩니다.  \n    return Array로 생성한 인스턴스를 twoInstance에 할당했으므로 true가 출력됩니다.\n\n6.  new ExtendArray()로 생성한 인스턴스를 twoInstance에 할당한 것이 아니라, Array 오브젝트로 생성한 인스턴스(oneInstance)를 할당했으므로 false가 출력됩니다.  \n    이처럼 Symbol.species로 반환되는 인스턴스를 변경할 수 있습니다.\n\n* * *\n\n<h2 id=\"return_other_Class\">다른 Class 반환</h2>\n\n위 에서 return 문에서 상속받은 Array 오브젝트를 반환하는 형태를 살펴봤습니다.  \n여기서는 다른 클래스를 반환하는 형태를 살펴봅니다.\n\n```js other-Class\n1. class ExtendOne extends Array{  \n showOne(){  \n console.log(\"ExtendOne\");  \n    \n }  \n};  \n2. class ExtendTwo extends Array{  \n static get [Symbol.species]() {  \n return ExtendOne;  \n }  \n showTwo(){  \n console.log(\"ExtendTwo\");  \n }  \n};  \n3. let twoInst = new ExtendTwo(10, 20, 30);  \nlet threeInst = twoInst.filter(value => value > 10);  \nconsole.log(threeInst);  \n  \n4. threeInst.showOne();  \nconsole.log(threeInst.showTwo);  \n/*  \nExtendOne(2)  \n 0: 20  \n 1: 30  \n length: 2  \n __proto__: Array  \n*/  \n// ExtendOne  \n// undefined  \n```\n\n1.  ExtendOne 클래스에서 Array 오브젝트를 상속받습니다.  \n    이 클래스를 아래에 작성한 2. ExtendTwo 클래스의 [Symbol.species]에서 반환합니다.\n\n2.  [Symbol.species] ( )에서 ExtendOne을 return 하므로 클래스를 반환하는 것처럼 보입니다만,  \n    클래스의 constructor를 반환하므로 인스턴스로 생성하여 반환하게 됩니다.  \n    이와 같이 [Symbol.species] ( )를 호출한 인스턴스가 아닌 다른 인스턴스로 반환할 수 있습니다.\n\n3.  twoInst.filter()가 호출되면, 우선 twoInst 인스턴스를 생성한 ExtendTwo 클래스에서 [Symbol.species] 작성 여부를 체크합니다. 존재하면 클래스의 [Symbol.species] ()를 호출하고 존재하지 않으면 상속받은 Array 오브젝트의 [Symbol.species] ()를 호출합니다.\n\n4.  호출된 [Symbol.species] ()에서 ExtendOne 인스턴스를 반환하여 ExtendTwo 클래스에서 Array 오브젝트를 상속받았으므로 [filter()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) 메서드를 호출할 수 있습니다.  \n    ExtendOne 클래스에서 filter() 메서드를 지원하지 않는 오브젝트를 상속받으면 Error가 발생합니다.\n\nfilter() 실행 결과 twoInst에 설정하지 않고 반환할 인스턴스에 할당합니다. 즉 threeInst 인스턴스에 할당됩니다. 따라서 twoInst 인스턴스 값 [10, 20, 30]이고 threeInst 인스턴스 값은 [20, 30]입니다.\n\n5.  return ExtendOne으로 인해 ExtendOne 인스턴스가 threeInst에 설정되므로,  \n    threeInst 인스턴스의 showOne()을 호출할 수 있습니다. showTwo는 존재하지 않으므로 undefined가 출력됩니다.\n\n* * *\n\n<h2 id=\"return_null\">null 반환</h2>\n\n[Symbol.species] ()에서 null을 반환하면 디폴트[Symbol.species] ()가 호출됩니다.\n\n```js\nclass ExtendOne extends Array{  \n static get [Symbol.species]() {  \n return null;  \n }  \n};  \n1. let oneInst = new ExtendOne(10, 20, 30);  \nlet arrayInst = oneInst.filter(value => value > 10);  \n  \n2. console.log(arrayInst instanceof Array);  \n3. console.log(arrayInst instanceof ExtendOne);  \n// true  \n// false  \n```\n\n1.  oneInst.filter()를 호출하면 ExtendOne 클래스의 [Symbol.species] ()가 호출되며 null를 반환합니다.  \n    null이 반환되면 디폴트 [Symbol.species] ()가 호출됩니다.  \n    ExtendOne 클래스에 작성하지 않았지만 상속받은 Array 오브젝트에 있으므로 [Symbol.species] ()가 호출되며  \n    Array 인스턴스를 생성하여 반환합니다. 따라서 filter()를 실행할 수 있습니다.\n\n2.  oneInst.filter()를 실행하면 [Symbol.species] ()에서 Array 인스턴스를 반환하여 arrayInst에 할당하므로 true값이 출력됩니다.\n\n3.  [Symbol.species] ()에서 Array 인스턴스를 반환하므로 arrayInst는 ExtendOne 클래스의 인스턴스가 아닙니다.  \n    false\n\n* * *\n\n<h2 id=\"toPrimitive\">toPrimitive</h2>\n\n오브젝트를 프리미티브(원시값) 타입으로 변환합니다.\n\n자바스크립트의 프리미티브 값은 number, string, boolean, undefined, null 그리고 symbol입니다.  \n+연산자는 앞뒤의 값 타입에 따라 값을 더하거나 연결합니다. (1+2)는 3이되지만 (1+”2”)는 12가 됩니다.  \n반면 곱하기(*), 나누기(/), 빼기(-)는 연산만 하고 연결은 하지 않습니다.\n\n<mark>연산 대상이 Number 타입이 아닐 경우 엔진의 ToPrimitive 모듈을 기준으로 값을 변환합니다. 예를 들어, 숫자에 true를 더하면 1로 변환하여 더하고, 문자열에 true를 더하면 \"true\"로 변환하여 연결합니다. 이때 Symbol.toPrimitive()로 ToPrimitive를 오버라이드하여 엔진의 변환 기준을 변경할 수 있습니다.</mark>(엔진의 디폴트 변환 값을 개발자 코드로 변경)\n\n### 세 가지 모드\n\nSymbol.toPrimitive() 에서 값을 변환하는 기준은 이를 호출하는 형태에 따라 결정됩니다.\n\n엔진은 호출한 곳의 형태에 따라 Symbol.toPrimitive(hint) 파라미터에 세 가지 모드(Mode)를 설정합니다.  \n~~개발자가 작성하는 것이 아니라 엔진이 다음 기준으로 설정하는 것입니다.~~\n\n1.  Number 환경이면 “number”를 toPrimitive(hint) 파라미터에 설정합니다.\n    \n2.  String 환경이면 “string”을 toPrimitive(hint) 파라미터에 설정합니다.\n    \n3.  Number 와 String 환경이 아니면 toPrimitive(hint) 파라미터에 “default”를 설정합니다.\n    \n```js\nlet obj = {  \n [Symbol.toPrimitive](hint){  \n if (hint === \"number\"){  \n return 30;  \n };  \n if (hint === \"string\"){  \n return \"문자열\";  \n };  \n return \"디폴트\";  \n }  \n};  \n1. console.log(\"1:\", 20 + obj); // 1: 20디폴트  \n2. console.log(\"2:\", 20 * obj); // 2: 600  \n  \n3. console.log(\"3:\", obj + 50); // 3: 디폴트50  \n4. console.log(\"4:\", +obj + 50);// 4: 80  \n5. console.log(\"5:\", `${obj}` + 123); // 5: 문자열123  \n```\n\n1.  (20 + obj)와 같이 오브젝트가 연산 대상이면, 자동으로 obj 오브젝트의 [Symbol.toPrimitive] ()가 호출됩니다. 파라미터에 “default”가 설정됩니다. 함수에서 “디폴트”를 반환하여 문자열을 연결하는 형태가 되어 “20디폴트”가 출력됩니다.\n\n2.  곱하기(*)를 사용하였으므로 파라미터에 “number”가 설정됩니다. 함수에서 30을 반환하며 20을곱해 600이 출력됩니다.\n\n3.  (20 + obj)에서 파라미터에 “default”가 설정되듯이 마찬가지로 “default”가 설정됩니다.  \n    함수에서 “디폴트”를 반환하여 50을 연결하므로 “디폴트50”이 출력됩니다.\n\n4.  +obj 에서 +는 단항+연산자로 피연산자를 Number 타입으로 변환합니다.  \n    함수에서 30을 반환하며 50을더해 80이 출력됩니다.\n\n5.  템플릿을 사용한 형태로 파라미터에 “string”이 설정됩니다. 함수에서 “문자열”을 반환하여  \n    ${obj}가 “문자열”로 변환됩니다. 123을 연결하여 “문자열123”이 출력됩니다.\n\n* * *\n\n<h2 id=\"Symbol_iterator\">이터레이터</h2>\n\nSymbol.iterator()는 이터레이터 오브젝트를 생성하여 반환합니다.\n\nSymbol.iterator는 String, Array, Map, Set, TypedArray 오브젝트의 prototype에 연결되어 있습니다.  \n오브젝트의 [Symbol.iterator]를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.\n\nObject 오브젝트에는 Symbol.iterator가 없습니다만, 개발자 코드로 구현할 수 있습니다.\n\n### Array.prototype[Symbol.iterator]\n\n배열 처리를 위한 이터레이터 오브젝트를 생성하여 반환합니다. 배열 엘리먼트를 하나씩 처리할 수 있습니다.\n\n```js iterator-Array\nlet numberArray = [10, 20];  \nfor (let value of numberArray){  \n console.log(value);  \n};  \nlet iteratorObj = numberArray[Symbol.iterator]();  \n  \nconsole.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \n//10  \n//20  \n/*Object  \n value: 10  \n done: false  \n __proto__: Object*/  \n/*Object  \n value: 20  \n done: false  \n __proto__: Object*/  \n/*Object  \n value: undefined  \n done: true  \n __proto__: Object*/  \n```\n\n*   numberArray는 Array 오브젝트 인스턴스 구조입니다.  \n    Symbol.iterator()를 호출할 수 있습니다.\n    \n*   numberArray[Symbol.iterator] ()는 numberArray 인스턴스의 Symbol.iterator()를 호출하는 것으로 이터레이터 오브젝트를 생성하여 반환합니다. 이터레이터 오브젝트를 사용하여 배열 엘리먼트를 하나씩 처리할 수 있습니다.\n    \n*   next()를 호출할 때마다 배열 엘리먼트 값을 {value: 10, done:false} 형태로 반환합니다.\n    \n\n### String.prototype[Symbol.iterator]\n\n문자열 처리를 위한 이터레이터 오브젝트를 반환합니다.\n\n문자열을 문자 단위로 하나씩 처리할 수 있습니다.\n\n```js iterator-string\nlet stringValue = \"1A\";  \nfor (let value of stringValue) {  \n console.log(value);  \n}  \n  \nlet iterObj = stringValue[Symbol.iterator]();  \n  \nconsole.log(iterObj.next());  \nconsole.log(iterObj.next());  \nconsole.log(iterObj.next());  \n// 1  \n// A  \n  \n// Object {value: \"1\", done: false}  \n// Object {value: \"A\", done: false}  \n// Object {value: undefined, done: true}  \n```\n\n*   “1A”를 1과 A로 분리하여 for-of문을 실행합니다. 문자 단위로 반복할 수 있는 것은  \n    String.prototype에 Symbol.iterator가 있기 때문입니다.  \n    for-of문에서 stringValue를 String 오브젝트로 생성하고 그 안에 Symbol.iterator()를 사용합니다.\n    \n*   stringValue[Symbol.iterator] ();형태로 호출하면 이터레이터 오브젝트를 반환합니다.  \n    이터레이터 오브젝트를 사용하여 문자열을 문자 단위로 하나씩 처리할 수 있습니다.\n    \n*   next()를 호출할 때마다 문자열의 문자를 value 프로퍼티에 설정하고 {value: “1”, done: false}형태로 반환합니다.\n    \n\n### Object 이터레이션\n\nObject 오브젝트에는 기본적으로 Symbol.iterator를 갖고 있지 않습니다. (for-of 등 반복처리불가.)\n\n<mark>Object 오브젝트에 Symbol.iterator를 작성하면 반복 처리를 할 수 있습니다.</mark>\n\n```js iterator-Object\n1. let obj = {  \n [Symbol.iterator](){  \n    2. return {  \n        maxCount: 2,  \n        count: 0,  \n        next(){   \n            if (this.count < this.maxCount){  \n            return {value: this.count++, done: false};  \n            }  \n            return {value: undefined, done: true};  \n            }  \n        }  \n    }  \n};  \n  \n3. let iteratorObj = obj[Symbol.iterator]();  \nconsole.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \nconsole.log(iteratorObj.next());  \n```\n\n1.  Object 오브젝트를 반복처리 하기 위해서 [Symbol.iterator] ()를 obj prototype에 작성해줬습니다.\n\n2.  호출된 obj[Symbol.iterator] ()의 return으로 반환된 오브젝트를 iteratorObj에 할당합니다.\n\n3.  iteratorObj에 next()가 있으므로 iteratorObj.next() 형태로 호출할 수 있습니다.\n\n* * *\n\n<h2 id=\"Symbol_generator\">제너레이터</h2>\n\nObject 오브젝트에 Symbol.iterator를 제너레이터 함수로 작성하면, 이터레이터로 반복할 때 마다 yield를 수행합니다.\n\n```js\n1. obj[Symbol.iterator] = function*(){  \n yield 10;  \n yield 20;  \n yield 30;  \n};  \n2. let result = [...obj];  \nconsole.log(result);  \n//[10, 20, 30]  \n```\n\n1.  obj 오브젝트의 [Symbol.iterator]를 제너레이터 함수로 작성하였습니다.  \n    이터레이터로 반복할 때 마다 yield 표현식을 평가하여 값을 반환합니다.\n\n2.  대괄호 [] 안에 spread 연산자로 obj 오브젝트를 작성했습니다. […obj]를 시작하면  \n    엔진에서 obj에 [Symbol.iterator] 작성 여부를 체크합니다. 작성되있으므로  \n    [Symbol.iterator] ()가 호출되며 이터레이터 오브젝트를 생성하여 반환합니다.  \n    이터레이터가 반복될 때마다 yield에서 반환한 값을 배열에 첨부합니다.  \n    반복이 끝나면 생성된 배열을 반환합니다.\n\n* * *\n\n<h2 id=\"Symbol_asyncIterator\">asyncIterator(): 비동기 반복</h2>\n\nSymbol.asyncIterator는 오브젝트의 asyncIterator 기본 값을 지정합니다.  \nasyncIterator 프로퍼티가 오브젝트에 설정되면 await for of 루프(loop)에서 비동기 반복할 수 있습니다.\n\n오브젝트가 비동기 반복이 가능하려면 Symbol.asyncIterator 프로퍼티 키가 존재해야합니다.\n\n```js\nconst myAsyncIterable = {  \n    async* [Symbol.asyncIterator]() {  \n        yield \"hello\";  \n        yield \"async\";  \n        yield \"iteration!\";  \n    }  \n};  \n  \n(async () => {  \n    for await (const x of myAsyncIterable) {  \n    console.log(x);  \n        // \"hello\"  \n        // \"async\"  \n        // \"iteration!\"  \n }  \n})();  \n```\n\n*   오브젝트의 [Symbol.asyncIterator] 속성을 설정해줌으로써 비동기 이터러블을 커스텀하여 정의할 수 있습니다.\n\n<mark>현재 기본적으로 [Symbol.asyncIterator] 프로퍼티가 built-in 되어 있는 JavaScript 오브젝트는 없습니다.</mark>\n\n하지만 WHATWG(Web Hypertext Application Technology Working Group, WHATWG)에서는  \n최근에 [Symbol.asyncIterator]가 스펙에 기준에 도달함으로써 비동기 반복이 가능한 첫 번째 built-in 오브젝트로 설정되었습니다.\n\n[WHATWG 위키](https://ko.wikipedia.org/wiki/WHATWG)  \n[WHATWG 공식홈페이지](https://whatwg.org/)\n\n* * *\n\n<h2 id=\"Symbol_match\">match(): match 결과 반환</h2>\n\nString 오브젝트에서 정규 표현식을 사용할 수 있는 메서드  \nmatch(), replace(), search(), split() 에 대응하는\n\nSymbol 오브젝트 Symbol.match(), Symbol.replace(), Symbol.search(), Symbol.split()이 있습니다.\n\n*   String.prototype.match()가 호출되면 먼저 오브젝트에서 Symbol.match 작성 여부를 체크합니다.  \n    작성돼있다면 오브젝트의 Symbol.match()를 호출합니다. String.prototype.match()는 호출되지 않습니다.\n\n```js\n1. console.log(\"1\", \"Sports\".match(/s/));  \n// 1: [0: \"5\", index: 5, input: \"Sports\"]  \n  \nclass MatchCheck {  \n constructor(base) {  \n this.base = base;  \n }  \n 2. [Symbol.match](target) {  \n return this.base.indexOf(target) >= 0;  \n }  \n}  \n3. let instMatch = new MatchCheck(\"sports\");  \n4. console.log(\"2:\", \"po\".match(instMatch));  \n// 2: true  \n```\n\n1.  “Sports”에 패턴/s/를 매치하면 매치 결과를 배열로 반환합니다. “Sports”가 문자열이므로  \n    엔진이 String.prototype에 연결된 프로퍼티로 String 인스턴스를 생성합니다.  \n    생성한 인스턴스에 “Sports”를 설정한 후 match()를 호출하면서 /s/를 파라미터로 넘겨줍니다.\n\n2.  Symbol.match()의 target 파라미터에 설정된 문자열이 this.base에 포함되어 있으면 true를 반환하고, 아니면 false를 반환합니다.\n\n3.  new MatchCheck(“sports”);를 실행하면 constructor가 호출되고 파라미터로 넘겨 준 “sports”가 this.base에 설정됩니다.\n\n4.  “po”.match(instMatch)가 호출되면 파라미터에 작성한 instMatch 인스턴스에서 Symbol.match의 작성 여부를 체크합니다. 존재하므로 Symbol.match(target)을 호출하면서 “po”를 파라미터 값으로 넘겨줍니다.  \n    Symbol.match()에서 “sports” 와 “po”로 match를 행하며, “po”가 있으므로 true를 반환합니다.\n\n\n<h2 id=\"Symbol_matchAll\">matchAll()</h2>\n\nSymbol.matchAll 은 String 오브젝트를 정규표현식으로 평가하여  \n반환결과를 이터레이터 오브젝트로 반환합니다.\n\nSymbol.matchAll은 [String.prototype.matchAll()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll)메서드에 의해 호출 됩니다.\n\n+참고 [RegExp.prototype[@@matchAll] ( )](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@matchAll)\n\n```js\nlet re = /[0-9]+/g;  \nlet str = '2016-01-02|2019-03-07';  \nlet result = re[Symbol.matchAll](str);  \n  \nconsole.log(Array.from(result, x => x[0]));  \n// expected output: Array [\"2016\", \"01\", \"02\", \"2019\", \"03\", \"07\"]  \n```","slug":"Symbol 프로퍼티 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrtg003cqgvq3gv5a0g6","content":"<p>Symbol 오브젝트에 프로퍼티들을 살펴봅니다.<br>이 프로퍼티들은 메서드로도 사용할 수 있습니다</p>\n<ul>\n<li>Symbol 프로퍼티<ul>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Well-Known_Symbol\">Well-Known Symbol</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#toStringTag\">toStringTag</a><ul>\n<li>클래스의 메서드로 사용</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#isConcatSpreadable\">isConcatSpreadable</a><ul>\n<li>Array-like 오브젝트에서 사용</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#unscopable\">unscopable</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#species_개념\">species 개념</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#species\">species</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#return_other_Class\">다른 Class 반환</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#return_null\">null 반환</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#toPrimitive\">toPrimitive</a><ul>\n<li>toPrimitive() 파라미터의 세가지 모드(mode)</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_iterator\">이터레이터</a><ul>\n<li>Array.prototype[Symbol.iterator]</li>\n<li>String.prototype[Symbol.iterator]</li>\n<li>Object 이터레이션</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_generator\">제너레이터</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_asyncIterator\">asyncIterator(): 비동기 반복</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_match\">match(): match 결과 반환</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_matchAll\">matchAll()</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"Well-Known_Symbol\">Well-Known Symbol</h2>\n\n\n<p>스펙에서 @@iterator 형태로 작성된 것을 볼 수 있으며<br>@@는 Symbol 대신 사용한 것입니다.<br>따라서 @@iterator는 Symbol.iterator와 같습니다.<br>@@iterator 형태는 스펙에서 사용하며 Symbol.iterator 형태는 내부 프로퍼티인<br>[[Description]]에 저장되는 형태입니다.<br>개발자 코드에서는 Symbol.iterator 형태를 사용합니다.</p>\n<table>\n<thead>\n<tr>\n<th>Spec name</th>\n<th>[[Description]]</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@@asyncIterator</td>\n<td>Symbol.asyncIterator</td>\n</tr>\n<tr>\n<td>@@hasInstance</td>\n<td>Symbol.hasInstance</td>\n</tr>\n<tr>\n<td>@@isConcatSpreadable</td>\n<td>Symbol.isConcatSpreadable</td>\n</tr>\n<tr>\n<td>@@iterator</td>\n<td>Symbol.iterator</td>\n</tr>\n<tr>\n<td>@@match</td>\n<td>Symbol.match</td>\n</tr>\n<tr>\n<td>@@matchAll</td>\n<td>Symbol.matchAll</td>\n</tr>\n<tr>\n<td>참고용 프로퍼티</td>\n<td>Symbol.prototype.description</td>\n</tr>\n<tr>\n<td>@@replace</td>\n<td>Symbol.replace</td>\n</tr>\n<tr>\n<td>@@search</td>\n<td>Symbol.search</td>\n</tr>\n<tr>\n<td>@@species</td>\n<td>Symbol.species</td>\n</tr>\n<tr>\n<td>@@split</td>\n<td>Symbol.split</td>\n</tr>\n<tr>\n<td>@@toPrimitive</td>\n<td>Symbol.toPrimitive</td>\n</tr>\n<tr>\n<td>@@toStringTag</td>\n<td>Symbol.toStringTag</td>\n</tr>\n<tr>\n<td>@@unscopables</td>\n<td>Symbol.unscopables</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>Well-Known Symbol은 스펙에서 처리 알고리즘(Algorism)을 구분하기 위해 부여한 이름입니다. 즉, 자바스크립트 엔진이 디폴트로 처리하는 알고리즘 유형 이름입니다.</p>\n</li>\n<li><p><mark>자바스크립트 프로그램에 같은 이름의 Well-Known.Symbol을 작성하면<br>엔진의 디폴트 처리를 실행하지 않고 프로그램에 작성한 코드를 실행합니다(오버라이딩)<br>Well-Known Symbol이 오버라이드되는 것과 같으므로 프로그램에 같은 이름을작성하여<br>Well-Known Symbol기능을 대체할 수 있습니다.</makr></p>\n</li>\n</ul>\n<p><strong>이런 가변성과 유용성을 제공하는 것이 Well-Known Symbol의 목적입니다.</strong></p>\n<hr>\n<h2 id=\"toStringTag\">toStringTag</h2>\n\n<p>[object Object] 형태에서 Object를 Symbol.toStringTag 값으로 표시합니다.<br>객체의 기본 문자열 설명을 만드는 데 사용되는 문자열 값 속성입니다.<br><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\">Object.prototype.toString()</a> 메소드에 의해 내부적으로 액세스됩니다.</p>\n<h3 id=\"설명\"><a href=\"#설명\" class=\"headerlink\" title=\"설명\"></a>설명</h3><p><strong>많은 자바스크립트 타입들은 기본적으로 tag를 가지고 있습니다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>tag default</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"string\">'foo'</span>);     </span><br><span class=\"line\"><span class=\"comment\">// \"[object String]\"  </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call([<span class=\"number\">1</span>, <span class=\"number\">2</span>]);    </span><br><span class=\"line\"><span class=\"comment\">// \"[object Array]\"  </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"number\">3</span>);         </span><br><span class=\"line\"><span class=\"comment\">// \"[object Number]\"  </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">true</span>);      </span><br><span class=\"line\"><span class=\"comment\">// \"[object Boolean]\"  </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">undefined</span>); </span><br><span class=\"line\"><span class=\"comment\">// \"[object Undefined]\"  </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">null</span>);      </span><br><span class=\"line\"><span class=\"comment\">// \"[object Null]\"  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... and more</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>기본적으로 toStringTag symbol이 정의되어 있는 것도 있습니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>());       </span><br><span class=\"line\"><span class=\"comment\">// \"[object Map]\"  </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;&#125;); </span><br><span class=\"line\"><span class=\"comment\">// \"[object GeneratorFunction]\"  </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"built_in\">Promise</span>.resolve()); </span><br><span class=\"line\"><span class=\"comment\">// \"[object Promise]\" </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... and more</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>class를 생성하면 자바스크립트는 기본값으로 Object tag를 설정합니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValidatorClass</span> </span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"keyword\">new</span> ValidatorClass()); </span><br><span class=\"line\"><span class=\"comment\">// \"[object Object]\"</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>toStringTag를 이용하여 자신만의 맞춤 태그를 설정할 수 있습니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValidatorClass</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">get</span> [Symbol.toStringTag]() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">'Validator'</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"keyword\">new</span> ValidatorClass()); </span><br><span class=\"line\"><span class=\"comment\">// \"[object Validator]\"</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>toStringTag 예제</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> sportsObj = <span class=\"keyword\">new</span> Sports;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(sportsObj.toString());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> Sports.prototype[<span class=\"built_in\">Symbol</span>.toStringTag] = <span class=\"string\">\"Sports-Function\"</span>;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(sportsObj.toString());  </span><br><span class=\"line\"><span class=\"comment\">// [object Object]  </span></span><br><span class=\"line\"><span class=\"comment\">// [object Sports-Function]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>new Sports로 생성한 인스턴스로 toString()을 실행하면 [object Object]가 반환됩니다.<br>Object 오브젝트도 [object Object]를 반환하므로 구분이 어렵습니다.<br>한편 new Sports()의 파라미터 값이 없을때 new sports; 로 사용할 수 있습니다.</p>\n</li>\n<li><p>Sports.prototype[Symbol.toStringTag] = “Sports-Function”;<br>Sports.prototype[Symbol.toStringTag]에 [object Object] 의 Object에 표시할 문자열을 지정합니다.</p>\n</li>\n<li><p>sportsObj.toString()을 실행하면 엔진에서 디폴트 toStringTag 값을 반환하기 전에<br>sportsObj에서 Symbol.toStringTag의 작성 여부를 체크합니다.<br>값이 작성되어 있다면 디폴트 값이 아닌 작성된 값을 반환합니다.<br>따라서 [object Sports-Function] 이 출력됩니다.<br>[object Sports-Function]을 정규표현식으로 분리하면 Sports-Function을 구할 수 있습니다.</p>\n</li>\n</ol>\n<h3 id=\"클래스의-메서드로-사용\"><a href=\"#클래스의-메서드로-사용\" class=\"headerlink\" title=\"클래스의 메서드로 사용\"></a>클래스의 메서드로 사용</h3><p>Symbol.toStringTag를 클래스의 getter로 작성할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> </span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> bookObj = <span class=\"keyword\">new</span> Book();  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(bookObj.toString());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">get</span> [Symbol.toStringTag]() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"Sports-class\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> sportsObj = <span class=\"keyword\">new</span> Sports();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sportsObj.toString());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Map</span>.prototype[<span class=\"built_in\">Symbol</span>.toStringTag]);  </span><br><span class=\"line\"><span class=\"comment\">//[object Object]  </span></span><br><span class=\"line\"><span class=\"comment\">//[object Sports-class]  </span></span><br><span class=\"line\"><span class=\"comment\">//Map</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>toString()을 실행하면 [object Object]가 반환됩니다.<br>따라서 Function 오브젝트, Object 오브젝트와 구분할 수 없습니다.</p>\n</li>\n<li><p>클래스에 Symbol.toStringTag를 getter로 선언했습니다.<br>return 문에 [object Object]에서 Object에 표시될 문자열을 작성했습니다.Sports-class가 반환됩니다.<br>getter로 작성하지 않고 메서드로 작성하면 [object Object]가 반환되므로 getter로 작성해야 합니다.</p>\n</li>\n<li><p>인스턴스로 toString()을 호출하면 sportsObj 인스턴스에 작성된 getSymbol.toStringTag가 호출됩니다.<br>호출된 메서드에서 “Sports-class”를 반환하므로 [object Sports-class]가 출력됩니다.</p>\n</li>\n<li><p>Map 같이 Symbol.toStringTag를 기본값(빌트인)으로 가지고 있는 것들이 있습니다.<br>Map.prototype[Symbol.toStringTag]를 실행하면 “Map”이 출력됩니다.<br>개발자 코드로 Symbol.toStringTag에 표시될 문자열을 작성하거나 getter를 사용하지 않아도 됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"isConcatSpreadable\">isConcatSpreadable</h2>\n\n<p>Symbol.isConcatSpreadable는<br><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\">Array.prototype.concat()</a> 메서드를 사용할 때 객체를 배열 요소에 병합해야하는지 구성하는 데 사용됩니다.</p>\n<blockquote>\n<p>[Symbol.isConcatSpreadable] = true / false</p>\n</blockquote>\n<ul>\n<li>프로퍼티의 기본값은 true 입니다.<br>false로 설정시 배열을 펼처서 합치지 않고 배열의 끝에 배열을 추가합니다.<br>사용시 true/false 에 따라 생성되는 배열의 length값이 달라집니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> one = [<span class=\"number\">11</span>, <span class=\"number\">12</span>], two = [<span class=\"number\">21</span>, <span class=\"number\">22</span>];  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = one.concat(two);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result, result.length);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Array(4)  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: 11  </span></span><br><span class=\"line\"><span class=\"comment\"> 1: 12  </span></span><br><span class=\"line\"><span class=\"comment\"> 2: 21  </span></span><br><span class=\"line\"><span class=\"comment\"> 3: 22  </span></span><br><span class=\"line\"><span class=\"comment\"> length: 4  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Array(0)  </span></span><br><span class=\"line\"><span class=\"comment\">4   </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> two[<span class=\"built_in\">Symbol</span>.isConcatSpreadable] = <span class=\"literal\">false</span>;  </span><br><span class=\"line\">result = one.concat(two);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result, result.length);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Array(3)  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: 11  </span></span><br><span class=\"line\"><span class=\"comment\"> 1: 12  </span></span><br><span class=\"line\"><span class=\"comment\"> 2: Array(2)  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: 21  </span></span><br><span class=\"line\"><span class=\"comment\"> 1: 22  </span></span><br><span class=\"line\"><span class=\"comment\"> length: 2  </span></span><br><span class=\"line\"><span class=\"comment\"> Symbol(Symbol.isConcatSpreadable): true  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Array(0)  </span></span><br><span class=\"line\"><span class=\"comment\"> length: 3  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Array(0)  </span></span><br><span class=\"line\"><span class=\"comment\">3  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> two[<span class=\"built_in\">Symbol</span>.isConcatSpreadable] = <span class=\"literal\">true</span>;  </span><br><span class=\"line\">result = one.concat(two);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result, result.length);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Array(4)  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: 11  </span></span><br><span class=\"line\"><span class=\"comment\"> 1: 12  </span></span><br><span class=\"line\"><span class=\"comment\"> 2: 21  </span></span><br><span class=\"line\"><span class=\"comment\"> 3: 22  </span></span><br><span class=\"line\"><span class=\"comment\"> length: 4  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Array(0)  </span></span><br><span class=\"line\"><span class=\"comment\">4  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>one 배열의 [11, 12]에 concat()의 파라미터에 지정한 two 배열 [21, 22]를 결합하면,<br>21 과 22가 각각 분리되어 one 배열 끝에 추가됩니다.<br>[11, 12, 21, 22] length: 4 가 반환됩니다.<br>Array.prototype에 [Symbol.isConcatSpreadable]을 작성하지 않았으므로 디폴트 true값 입니다.<br>일반적인 concat()메서드 사용입니다.</p>\n</li>\n<li><p>two[Symbol.isConcatSpreadable]에 false 값을 할당했습니다.<br>concat() 메서드로 one 배열과 two 배열을 결합하면 two 배열의 [21, 22]를 분리하지 않고<br>배열 자체를 첨부합니다. [11, 12, Array[2]] 형태로 결합되어 length 값은 3을 갖습니다.<br>개발자 도구에서 Array[2]를 살펴보면 [21, 22] length: 2 가 할당되어 있고<br>Symbol(Symbol.isConcatSpreadable): true로 isConcatSpreadable = false 가 적용된 것을 볼 수 있습니다. 기본값 isConcatSpreadable = true 인 경우 프로퍼티에 나타나지 않습니다.</p>\n</li>\n<li><p>two[Symbol.isConcatSpreadable]에 true를 할당하였으며 디폴트 값 true와 같습니다.<br>one 배열에 two 배열의 [21, 22]가 분리되어 끝에 첨부됩니다.<br>[11, 12, 21, 22] 형태가 됩니다.</p>\n</li>\n</ol>\n<h3 id=\"Array-like-오브젝트에서-사용\"><a href=\"#Array-like-오브젝트에서-사용\" class=\"headerlink\" title=\"Array-like 오브젝트에서 사용\"></a>Array-like 오브젝트에서 사용</h3><p><mark>유사 배열(Array-like) 오브젝트도 concat()을 사용할 수 있습니다. 하지만 유사 배열 오브젝트는 isConcatSpreadable = true 값을 가지지 않습니다.</mark> concat()으로 배열을 하나씩 분리하여 추가 병합하고 싶다면 isConcatSpreadable를 사용하여 true로 설정해줍니다.</p>\n<figure class=\"highlight js\"><figcaption><span>isConcatSpreadable > Array-like</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = [<span class=\"number\">11</span>, <span class=\"number\">12</span>];  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> fiveSix = &#123;  </span><br><span class=\"line\"> <span class=\"number\">0</span>: <span class=\"string\">\"five\"</span>,  </span><br><span class=\"line\"> <span class=\"number\">1</span>: <span class=\"string\">\"six\"</span>,  </span><br><span class=\"line\"> length: <span class=\"number\">2</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = one.concat(fiveSix);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result, result.length);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Array(3)  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: 11  </span></span><br><span class=\"line\"><span class=\"comment\"> 1: 12  </span></span><br><span class=\"line\"><span class=\"comment\"> 2: Object&#123;  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: \"five\",   </span></span><br><span class=\"line\"><span class=\"comment\"> 1: \"six\",   </span></span><br><span class=\"line\"><span class=\"comment\"> length: 2&#125;   </span></span><br><span class=\"line\"><span class=\"comment\"> length: 3  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Array(0)  </span></span><br><span class=\"line\"><span class=\"comment\">3  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> arrayLike = &#123;  </span><br><span class=\"line\"> [<span class=\"built_in\">Symbol</span>.isConcatSpreadable]: <span class=\"literal\">true</span>,  </span><br><span class=\"line\"> <span class=\"number\">0</span>: <span class=\"string\">\"five\"</span>,  </span><br><span class=\"line\"> <span class=\"number\">1</span>: <span class=\"string\">\"six\"</span>,  </span><br><span class=\"line\"> length: <span class=\"number\">2</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">result = one.concat(arrayLike);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result, result.length);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Array(4)  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: 11  </span></span><br><span class=\"line\"><span class=\"comment\"> 1: 12  </span></span><br><span class=\"line\"><span class=\"comment\"> 2: \"five\"  </span></span><br><span class=\"line\"><span class=\"comment\"> 3: \"six\"  </span></span><br><span class=\"line\"><span class=\"comment\"> length: 4  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Array(0)  </span></span><br><span class=\"line\"><span class=\"comment\">4  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>one은 배열 [11, 12]이고 fiveSix는 Array-like {0: “five”, 1” “six”, length:2}입니다.<br>이 상태에서 concat()을 실행하면 [11, 12, Object] 형태가 됩니다.<br>오브젝트 형태가 분리되어 첨부되지 않습니다.</p>\n</li>\n<li><p>Array-like 오브젝트에 [Symbol.isConcatSpreadable]: true를 작성하여,<br>concat()을 실행하면 Array-like 오브젝트의 각 프로퍼티를 분리하여 배열 끝에 첨부합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"unscopable\">unscopable</h2>\n\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/with\">with</a>문에서 사용하며 값이 true 이면 프로퍼티를 전개 하지 않습니다.</p>\n<blockquote>\n<p>[Symbol.unscopables] = true/false</p>\n</blockquote>\n<p>Symbol.unscopables 값이 true일 때, with 문에서 프로퍼티를 전개하지 않으므로<br>Object 오브젝트의 프로퍼티 키를 사용하면 에러가 발생합니다.</p>\n<p>ES5 에서 “use strict” 범위에 with 문을 사용하면 에러가 발생합니다.ES6도 마찬가지 입니다. ES6에서 stirct모드는 보편적인 환경이므로 Symbol.unscopables를 사용할 빈도가 그다지 높지 않습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>Symbol.unscopables</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// \"use strict\" 를 선언하면 with 에서 에러 발생  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sports = &#123;  </span><br><span class=\"line\"> soccer: <span class=\"string\">\"축구\"</span>,  </span><br><span class=\"line\"> baseball: <span class=\"string\">\"야구\"</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">with</span>(sports)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(soccer, baseball);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> sports[<span class=\"built_in\">Symbol</span>.unscopables] = &#123;  </span><br><span class=\"line\"> baseball: <span class=\"literal\">true</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"keyword\">with</span> (sports) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(soccer);  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> value = baseball;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(e.message);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// 축구 야구  </span></span><br><span class=\"line\"><span class=\"comment\">// 축구  </span></span><br><span class=\"line\"><span class=\"comment\">// baseball is not defined</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>with 문을 실행하면 파라미터에 작성한 sports 오브젝트의 프로퍼티가 펼쳐진(spread)형태가 됩니다.<br>따라서 프로퍼티 값을 구할 때 sports[“soccer”]형태로 작성하지 않고 soccer만 작성합니다.<br>soccer의 프로퍼티 값인 “축구”가 반환되고 baseball의 프로퍼티 값도 마찬가지로 반환되어<br>“축구” “야구”가 출력됩니다.</p>\n</li>\n<li><p>with(sports)를 실행할 때 sports 오브젝트에서 전개하지 않을 프로퍼티를 작성합니다.<br>baseball: true를 설정해줬으므로 with 문에서 baseball 프로퍼티가 전개되지 않습니다.<br>그러므로 soccer의 프로퍼티 값인 “축구”만 출력됩니다.</p>\n</li>\n<li><p>with(sports) 문에서 baseball 프로퍼티가 전개되지 않으므로 baseball을 변수에 할당하면<br>에러가 발생합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"species_개념\">species 개념</h2>\n\n<p>Symbol.species는 constructor를 반환합니다.<br>constructor를 반환한다는 것은 constructor로 인스턴스를 생성하여 반환하는 것과 같습니다.<br>Symbol.species를 오버라이드 할 수 있으며, 개발자 코드로 반환되는 인스턴스를 변경할 수 있습니다.</p>\n<p>species의 개념을 살펴 봅니다.</p>\n<figure class=\"highlight js\"><figcaption><span>species 개념</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> arrayObj = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> sliceOne = arrayObj.slice(<span class=\"number\">1</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> sliceTwo = sliceOne.slice(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>let arrayObj = [1, 2, 3]을 실행하면 Array 오브젝트(인스턴스)를 생성하고 엘리먼트 값으로<br>1, 2, 3을 설정합니다. 아래는 [1, 2, 3]이 할당된 arrayObj 인스턴스 구조입니다.</p>\n<img src=\"/images/speciesArrayObj.JPG\">    \n\n<p>arrayObj 구성을 보면 prototype이 없으며 &#95;&#95;proto&#95;&#95;만 있습니다.<br>&#95;&#95;proto&#95;&#95;에는 Array 오브젝트의 prototype에 연결된 프로퍼티가 첨부되어 있습니다.<br>Array의 오브젝트 프로퍼티가 연결되어 있지만 arrayObj에는 연결된 프로퍼티가 없습니다.<br>따라서 arrayObj는 Array 오브젝트가 아닌 Array 인스턴스입니다.</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>arrayObj.slice(1, 3) 코드는 자바스크립트에서 일반적으로 사용하는 [1, 2, 3].slice(1, 3)형태와 다릅니다.[1, 2, 3]으로 Array 인스턴스를 생성하여 arrayObj에 할당하고, arrayObj에 있는 slice()를 호출하는 형태 입니다. 실행하면 [1, 2, 3]에서 2와 3이 반환되어 sliceOne 변수에 할당될 것으로 생각할 수 있습니다.<br>하지만, sliceOne변수에 할당되는 것은 Array 인스턴스 입니다. 2 와 3이 인스턴스 값으로 설정됩니다.<br>arrayObj 와 sliceOne 둘다 Array 오브젝트 인스턴스 입니다. 배열의 엘리먼트 값이 달라집니다.</li>\n</ol>\n<p><strong>여기서 중요한 점은 Array 인스턴스(arrayObj)의 slice()를 호출하면 slice()실행 결과가 반영된</strong><br><strong>Array 인스턴스가 반환된다는 점입니다. Array 인스턴스가 반환되므로 sliceOne 인스턴스를 지정하여 slice()를 호출할 수 있습니다.</strong></p>\n<ol start=\"3\">\n<li>sliceOne 인스턴스를 지정하여 slice()를 호출하고 마찬가지로 Array 인스턴스가 반환됩니다.<br>Symbol.species를 이해하려면 먼저 이에 대한 이해가 필요합니다.</li>\n</ol>\n<hr>\n<h2 id=\"species\">species</h2>\n\n<p>Symbol.species는 constructor를 반환합니다.</p>\n<p>Symbol.species는 static 액세서 프로퍼티로 getter만 있고 setter는 없습니다.<br>Array, Map, Set, Promise, RegExp, ArrayBuffer, TypedArray 오브젝트에 Symbol.species가 빌트인으로 포함되어 있습니다.</p>\n<p>위에 거론된 빌트인 오브젝트를 상속받는 클래스에 Symbol.species를 작성하면, 빌트인 오브젝트의 Symbol.species가 오버라이드됩니다. 이를 통해 클래스의 Symbol.species에서 다른 오브젝트를 반환할 수 있습니다.</p>\n<ul>\n<li>예를 들어 인스턴스의 slice()를 호출하면 slice()를 호출한 인스턴스를 반환하지만, 클래스에 Symbol.species를 작성하여 인스턴스가 아닌 Array 오브젝트를 반환할 수 있습니다. <strong>(인스턴스 대신 인스턴스의 부모 오브젝트 반환)</strong></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendArray</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> [Symbol.species]() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> oneInstance = <span class=\"keyword\">new</span> ExtendArray(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> twoInstance = oneInstance.slice(<span class=\"number\">1</span>, <span class=\"number\">2</span>);  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(oneInstance <span class=\"keyword\">instanceof</span> ExtendArray);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"built_in\">console</span>.log(twoInstance <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">6.</span> <span class=\"built_in\">console</span>.log(twoInstance <span class=\"keyword\">instanceof</span> ExtendArray);  </span><br><span class=\"line\"><span class=\"comment\">//true  </span></span><br><span class=\"line\"><span class=\"comment\">//true  </span></span><br><span class=\"line\"><span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/instanceof\">instanceof 연산자</a>는 생성자의 프로토 타입 속성이 객체의 프로토 타입 체인에 나타나는지 테스트하여 true/false값을 반환합니다.</p>\n<ol>\n<li><p>ExtendArray 클래스에서 Array 오브젝트를 상속받습니다. 클래스에 static 메서드이면서 getter를 사용하여 Symbol.species를 작성하였습니다. Array 오브젝트의 Symbol.species가 오버라이드 됩니다.<br>인스턴스의 Array 오브젝트 메서드를 호출하면 오버라이드된 Symbol.species가 호출됩니다.<br>그리고 return Array;를 하므로 메서드를 호출한 인스턴스가 반환되지 않고 Array 인스턴스가 반환됩니다.</p>\n<ul>\n<li>return Array가 Array 오브젝트의 constructor를 반환하지만, return 문은 오른쪽의 표현식을 평가하고 평가 결과를 반환하므로 Array 오브젝트의 constructor를 호출하고 그 결과인 Array 인스턴스를 반환합니다.</li>\n</ul>\n</li>\n<li><p>new 연산자로 ExtendArray()룰 호출하면서 파라미터로 1, 2, 3을 넘겨줬습니다.<br>ExtendArray 클래스에서 Array 오브젝트를 상속받았으므로 생성한 인스턴스는 Array 오브젝트 특성을 갖습니다.</p>\n</li>\n<li><p>oneInstance 인스턴스에 상속받은 Array 오브젝트가 존재하므로 slice()를 호출할 수 있습니다.<br>slice()가 호출되면 ExtendArray 클래스에 getter로 작성된 Symbol.species()가 호출되며,<br>oneInstance가 반환되지 않고 Array 인스턴스를 생성하여 반환합니다.</p>\n</li>\n<li><p>new ExtendArray(1, 2, 3)으로 생성한 인스턴스를 oneInstance에 할당했으므로 true가 출력됩니다.</p>\n</li>\n<li><p>oneInstance.sliceOne(1, 2)를 실행하면 클래스에 작성한 Symbol.species()가 호출됩니다.<br>return Array로 생성한 인스턴스를 twoInstance에 할당했으므로 true가 출력됩니다.</p>\n</li>\n<li><p>new ExtendArray()로 생성한 인스턴스를 twoInstance에 할당한 것이 아니라, Array 오브젝트로 생성한 인스턴스(oneInstance)를 할당했으므로 false가 출력됩니다.<br>이처럼 Symbol.species로 반환되는 인스턴스를 변경할 수 있습니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"return_other_Class\">다른 Class 반환</h2>\n\n<p>위 에서 return 문에서 상속받은 Array 오브젝트를 반환하는 형태를 살펴봤습니다.<br>여기서는 다른 클래스를 반환하는 형태를 살펴봅니다.</p>\n<figure class=\"highlight js\"><figcaption><span>other-Class</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendOne</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span></span>&#123;  </span><br><span class=\"line\"> showOne()&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"ExtendOne\"</span>);  </span><br><span class=\"line\">    </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendTwo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span></span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> [Symbol.species]() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> ExtendOne;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> showTwo()&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"ExtendTwo\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> twoInst = <span class=\"keyword\">new</span> ExtendTwo(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> threeInst = twoInst.filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value &gt; <span class=\"number\">10</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(threeInst);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> threeInst.showOne();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(threeInst.showTwo);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">ExtendOne(2)  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: 20  </span></span><br><span class=\"line\"><span class=\"comment\"> 1: 30  </span></span><br><span class=\"line\"><span class=\"comment\"> length: 2  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Array  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"><span class=\"comment\">// ExtendOne  </span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>ExtendOne 클래스에서 Array 오브젝트를 상속받습니다.<br>이 클래스를 아래에 작성한 2. ExtendTwo 클래스의 [Symbol.species]에서 반환합니다.</p>\n</li>\n<li><p>[Symbol.species] ( )에서 ExtendOne을 return 하므로 클래스를 반환하는 것처럼 보입니다만,<br>클래스의 constructor를 반환하므로 인스턴스로 생성하여 반환하게 됩니다.<br>이와 같이 [Symbol.species] ( )를 호출한 인스턴스가 아닌 다른 인스턴스로 반환할 수 있습니다.</p>\n</li>\n<li><p>twoInst.filter()가 호출되면, 우선 twoInst 인스턴스를 생성한 ExtendTwo 클래스에서 [Symbol.species] 작성 여부를 체크합니다. 존재하면 클래스의 [Symbol.species] ()를 호출하고 존재하지 않으면 상속받은 Array 오브젝트의 [Symbol.species] ()를 호출합니다.</p>\n</li>\n<li><p>호출된 [Symbol.species] ()에서 ExtendOne 인스턴스를 반환하여 ExtendTwo 클래스에서 Array 오브젝트를 상속받았으므로 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\">filter()</a> 메서드를 호출할 수 있습니다.<br>ExtendOne 클래스에서 filter() 메서드를 지원하지 않는 오브젝트를 상속받으면 Error가 발생합니다.</p>\n</li>\n</ol>\n<p>filter() 실행 결과 twoInst에 설정하지 않고 반환할 인스턴스에 할당합니다. 즉 threeInst 인스턴스에 할당됩니다. 따라서 twoInst 인스턴스 값 [10, 20, 30]이고 threeInst 인스턴스 값은 [20, 30]입니다.</p>\n<ol start=\"5\">\n<li>return ExtendOne으로 인해 ExtendOne 인스턴스가 threeInst에 설정되므로,<br>threeInst 인스턴스의 showOne()을 호출할 수 있습니다. showTwo는 존재하지 않으므로 undefined가 출력됩니다.</li>\n</ol>\n<hr>\n<h2 id=\"return_null\">null 반환</h2>\n\n<p>[Symbol.species] ()에서 null을 반환하면 디폴트[Symbol.species] ()가 호출됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendOne</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span></span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> [Symbol.species]() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> oneInst = <span class=\"keyword\">new</span> ExtendOne(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> arrayInst = oneInst.filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value &gt; <span class=\"number\">10</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(arrayInst <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>);  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(arrayInst <span class=\"keyword\">instanceof</span> ExtendOne);  </span><br><span class=\"line\"><span class=\"comment\">// true  </span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>oneInst.filter()를 호출하면 ExtendOne 클래스의 [Symbol.species] ()가 호출되며 null를 반환합니다.<br>null이 반환되면 디폴트 [Symbol.species] ()가 호출됩니다.<br>ExtendOne 클래스에 작성하지 않았지만 상속받은 Array 오브젝트에 있으므로 [Symbol.species] ()가 호출되며<br>Array 인스턴스를 생성하여 반환합니다. 따라서 filter()를 실행할 수 있습니다.</p>\n</li>\n<li><p>oneInst.filter()를 실행하면 [Symbol.species] ()에서 Array 인스턴스를 반환하여 arrayInst에 할당하므로 true값이 출력됩니다.</p>\n</li>\n<li><p>[Symbol.species] ()에서 Array 인스턴스를 반환하므로 arrayInst는 ExtendOne 클래스의 인스턴스가 아닙니다.<br>false</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"toPrimitive\">toPrimitive</h2>\n\n<p>오브젝트를 프리미티브(원시값) 타입으로 변환합니다.</p>\n<p>자바스크립트의 프리미티브 값은 number, string, boolean, undefined, null 그리고 symbol입니다.<br>+연산자는 앞뒤의 값 타입에 따라 값을 더하거나 연결합니다. (1+2)는 3이되지만 (1+”2”)는 12가 됩니다.<br>반면 곱하기(*), 나누기(/), 빼기(-)는 연산만 하고 연결은 하지 않습니다.</p>\n<p><mark>연산 대상이 Number 타입이 아닐 경우 엔진의 ToPrimitive 모듈을 기준으로 값을 변환합니다. 예를 들어, 숫자에 true를 더하면 1로 변환하여 더하고, 문자열에 true를 더하면 “true”로 변환하여 연결합니다. 이때 Symbol.toPrimitive()로 ToPrimitive를 오버라이드하여 엔진의 변환 기준을 변경할 수 있습니다.</mark>(엔진의 디폴트 변환 값을 개발자 코드로 변경)</p>\n<h3 id=\"세-가지-모드\"><a href=\"#세-가지-모드\" class=\"headerlink\" title=\"세 가지 모드\"></a>세 가지 모드</h3><p>Symbol.toPrimitive() 에서 값을 변환하는 기준은 이를 호출하는 형태에 따라 결정됩니다.</p>\n<p>엔진은 호출한 곳의 형태에 따라 Symbol.toPrimitive(hint) 파라미터에 세 가지 모드(Mode)를 설정합니다.<br><del>개발자가 작성하는 것이 아니라 엔진이 다음 기준으로 설정하는 것입니다.</del></p>\n<ol>\n<li><p>Number 환경이면 “number”를 toPrimitive(hint) 파라미터에 설정합니다.</p>\n</li>\n<li><p>String 환경이면 “string”을 toPrimitive(hint) 파라미터에 설정합니다.</p>\n</li>\n<li><p>Number 와 String 환경이 아니면 toPrimitive(hint) 파라미터에 “default”를 설정합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;  </span><br><span class=\"line\"> [<span class=\"built_in\">Symbol</span>.toPrimitive](hint)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (hint === <span class=\"string\">\"number\"</span>)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"number\">30</span>;  </span><br><span class=\"line\"> &#125;;  </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (hint === <span class=\"string\">\"string\"</span>)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"문자열\"</span>;  </span><br><span class=\"line\"> &#125;;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"디폴트\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"number\">20</span> + obj); <span class=\"comment\">// 1: 20디폴트  </span></span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"number\">20</span> * obj); <span class=\"comment\">// 2: 600  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, obj + <span class=\"number\">50</span>); <span class=\"comment\">// 3: 디폴트50  </span></span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, +obj + <span class=\"number\">50</span>);<span class=\"comment\">// 4: 80  </span></span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, <span class=\"string\">`<span class=\"subst\">$&#123;obj&#125;</span>`</span> + <span class=\"number\">123</span>); <span class=\"comment\">// 5: 문자열123</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>(20 + obj)와 같이 오브젝트가 연산 대상이면, 자동으로 obj 오브젝트의 [Symbol.toPrimitive] ()가 호출됩니다. 파라미터에 “default”가 설정됩니다. 함수에서 “디폴트”를 반환하여 문자열을 연결하는 형태가 되어 “20디폴트”가 출력됩니다.</p>\n</li>\n<li><p>곱하기(*)를 사용하였으므로 파라미터에 “number”가 설정됩니다. 함수에서 30을 반환하며 20을곱해 600이 출력됩니다.</p>\n</li>\n<li><p>(20 + obj)에서 파라미터에 “default”가 설정되듯이 마찬가지로 “default”가 설정됩니다.<br>함수에서 “디폴트”를 반환하여 50을 연결하므로 “디폴트50”이 출력됩니다.</p>\n</li>\n<li><p>+obj 에서 +는 단항+연산자로 피연산자를 Number 타입으로 변환합니다.<br>함수에서 30을 반환하며 50을더해 80이 출력됩니다.</p>\n</li>\n<li><p>템플릿을 사용한 형태로 파라미터에 “string”이 설정됩니다. 함수에서 “문자열”을 반환하여<br>${obj}가 “문자열”로 변환됩니다. 123을 연결하여 “문자열123”이 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Symbol_iterator\">이터레이터</h2>\n\n<p>Symbol.iterator()는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<p>Symbol.iterator는 String, Array, Map, Set, TypedArray 오브젝트의 prototype에 연결되어 있습니다.<br>오브젝트의 [Symbol.iterator]를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<p>Object 오브젝트에는 Symbol.iterator가 없습니다만, 개발자 코드로 구현할 수 있습니다.</p>\n<h3 id=\"Array-prototype-Symbol-iterator\"><a href=\"#Array-prototype-Symbol-iterator\" class=\"headerlink\" title=\"Array.prototype[Symbol.iterator]\"></a>Array.prototype[Symbol.iterator]</h3><p>배열 처리를 위한 이터레이터 오브젝트를 생성하여 반환합니다. 배열 엘리먼트를 하나씩 처리할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>iterator-Array</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numberArray = [<span class=\"number\">10</span>, <span class=\"number\">20</span>];  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> numberArray)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iteratorObj = numberArray[<span class=\"built_in\">Symbol</span>.iterator]();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">//10  </span></span><br><span class=\"line\"><span class=\"comment\">//20  </span></span><br><span class=\"line\"><span class=\"comment\">/*Object  </span></span><br><span class=\"line\"><span class=\"comment\"> value: 10  </span></span><br><span class=\"line\"><span class=\"comment\"> done: false  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Object*/</span>  </span><br><span class=\"line\"><span class=\"comment\">/*Object  </span></span><br><span class=\"line\"><span class=\"comment\"> value: 20  </span></span><br><span class=\"line\"><span class=\"comment\"> done: false  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Object*/</span>  </span><br><span class=\"line\"><span class=\"comment\">/*Object  </span></span><br><span class=\"line\"><span class=\"comment\"> value: undefined  </span></span><br><span class=\"line\"><span class=\"comment\"> done: true  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Object*/</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>numberArray는 Array 오브젝트 인스턴스 구조입니다.<br>Symbol.iterator()를 호출할 수 있습니다.</p>\n</li>\n<li><p>numberArray[Symbol.iterator] ()는 numberArray 인스턴스의 Symbol.iterator()를 호출하는 것으로 이터레이터 오브젝트를 생성하여 반환합니다. 이터레이터 오브젝트를 사용하여 배열 엘리먼트를 하나씩 처리할 수 있습니다.</p>\n</li>\n<li><p>next()를 호출할 때마다 배열 엘리먼트 값을 {value: 10, done:false} 형태로 반환합니다.</p>\n</li>\n</ul>\n<h3 id=\"String-prototype-Symbol-iterator\"><a href=\"#String-prototype-Symbol-iterator\" class=\"headerlink\" title=\"String.prototype[Symbol.iterator]\"></a>String.prototype[Symbol.iterator]</h3><p>문자열 처리를 위한 이터레이터 오브젝트를 반환합니다.</p>\n<p>문자열을 문자 단위로 하나씩 처리할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>iterator-string</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> stringValue = <span class=\"string\">\"1A\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> stringValue) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iterObj = stringValue[<span class=\"built_in\">Symbol</span>.iterator]();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// 1  </span></span><br><span class=\"line\"><span class=\"comment\">// A  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"1\", done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"A\", done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>“1A”를 1과 A로 분리하여 for-of문을 실행합니다. 문자 단위로 반복할 수 있는 것은<br>String.prototype에 Symbol.iterator가 있기 때문입니다.<br>for-of문에서 stringValue를 String 오브젝트로 생성하고 그 안에 Symbol.iterator()를 사용합니다.</p>\n</li>\n<li><p>stringValue[Symbol.iterator] ();형태로 호출하면 이터레이터 오브젝트를 반환합니다.<br>이터레이터 오브젝트를 사용하여 문자열을 문자 단위로 하나씩 처리할 수 있습니다.</p>\n</li>\n<li><p>next()를 호출할 때마다 문자열의 문자를 value 프로퍼티에 설정하고 {value: “1”, done: false}형태로 반환합니다.</p>\n</li>\n</ul>\n<h3 id=\"Object-이터레이션\"><a href=\"#Object-이터레이션\" class=\"headerlink\" title=\"Object 이터레이션\"></a>Object 이터레이션</h3><p>Object 오브젝트에는 기본적으로 Symbol.iterator를 갖고 있지 않습니다. (for-of 등 반복처리불가.)</p>\n<p><mark>Object 오브젝트에 Symbol.iterator를 작성하면 반복 처리를 할 수 있습니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>iterator-Object</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> obj = &#123;  </span><br><span class=\"line\"> [<span class=\"built_in\">Symbol</span>.iterator]()&#123;  </span><br><span class=\"line\">    <span class=\"number\">2.</span> <span class=\"keyword\">return</span> &#123;  </span><br><span class=\"line\">        maxCount: <span class=\"number\">2</span>,  </span><br><span class=\"line\">        count: <span class=\"number\">0</span>,  </span><br><span class=\"line\">        next()&#123;   </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.count &lt; <span class=\"keyword\">this</span>.maxCount)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;<span class=\"attr\">value</span>: <span class=\"keyword\">this</span>.count++, <span class=\"attr\">done</span>: <span class=\"literal\">false</span>&#125;;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;<span class=\"attr\">value</span>: <span class=\"literal\">undefined</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span>&#125;;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> iteratorObj = obj[<span class=\"built_in\">Symbol</span>.iterator]();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Object 오브젝트를 반복처리 하기 위해서 [Symbol.iterator] ()를 obj prototype에 작성해줬습니다.</p>\n</li>\n<li><p>호출된 obj[Symbol.iterator] ()의 return으로 반환된 오브젝트를 iteratorObj에 할당합니다.</p>\n</li>\n<li><p>iteratorObj에 next()가 있으므로 iteratorObj.next() 형태로 호출할 수 있습니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Symbol_generator\">제너레이터</h2>\n\n<p>Object 오브젝트에 Symbol.iterator를 제너레이터 함수로 작성하면, 이터레이터로 반복할 때 마다 yield를 수행합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> obj[<span class=\"built_in\">Symbol</span>.iterator] = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">10</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">20</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">30</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> result = [...obj];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\"><span class=\"comment\">//[10, 20, 30]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>obj 오브젝트의 [Symbol.iterator]를 제너레이터 함수로 작성하였습니다.<br>이터레이터로 반복할 때 마다 yield 표현식을 평가하여 값을 반환합니다.</p>\n</li>\n<li><p>대괄호 [] 안에 spread 연산자로 obj 오브젝트를 작성했습니다. […obj]를 시작하면<br>엔진에서 obj에 [Symbol.iterator] 작성 여부를 체크합니다. 작성되있으므로<br>[Symbol.iterator] ()가 호출되며 이터레이터 오브젝트를 생성하여 반환합니다.<br>이터레이터가 반복될 때마다 yield에서 반환한 값을 배열에 첨부합니다.<br>반복이 끝나면 생성된 배열을 반환합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Symbol_asyncIterator\">asyncIterator(): 비동기 반복</h2>\n\n<p>Symbol.asyncIterator는 오브젝트의 asyncIterator 기본 값을 지정합니다.<br>asyncIterator 프로퍼티가 오브젝트에 설정되면 await for of 루프(loop)에서 비동기 반복할 수 있습니다.</p>\n<p>오브젝트가 비동기 반복이 가능하려면 Symbol.asyncIterator 프로퍼티 키가 존재해야합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myAsyncIterable = &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">async</span>* [<span class=\"built_in\">Symbol</span>.asyncIterator]() &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"string\">\"hello\"</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"string\">\"async\"</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"string\">\"iteration!\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">(<span class=\"keyword\">async</span> () =&gt; &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> myAsyncIterable) &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);  </span><br><span class=\"line\">        <span class=\"comment\">// \"hello\"  </span></span><br><span class=\"line\">        <span class=\"comment\">// \"async\"  </span></span><br><span class=\"line\">        <span class=\"comment\">// \"iteration!\"  </span></span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>오브젝트의 [Symbol.asyncIterator] 속성을 설정해줌으로써 비동기 이터러블을 커스텀하여 정의할 수 있습니다.</li>\n</ul>\n<p><mark>현재 기본적으로 [Symbol.asyncIterator] 프로퍼티가 built-in 되어 있는 JavaScript 오브젝트는 없습니다.</mark></p>\n<p>하지만 WHATWG(Web Hypertext Application Technology Working Group, WHATWG)에서는<br>최근에 [Symbol.asyncIterator]가 스펙에 기준에 도달함으로써 비동기 반복이 가능한 첫 번째 built-in 오브젝트로 설정되었습니다.</p>\n<p><a href=\"https://ko.wikipedia.org/wiki/WHATWG\">WHATWG 위키</a><br><a href=\"https://whatwg.org/\">WHATWG 공식홈페이지</a></p>\n<hr>\n<h2 id=\"Symbol_match\">match(): match 결과 반환</h2>\n\n<p>String 오브젝트에서 정규 표현식을 사용할 수 있는 메서드<br>match(), replace(), search(), split() 에 대응하는</p>\n<p>Symbol 오브젝트 Symbol.match(), Symbol.replace(), Symbol.search(), Symbol.split()이 있습니다.</p>\n<ul>\n<li>String.prototype.match()가 호출되면 먼저 오브젝트에서 Symbol.match 작성 여부를 체크합니다.<br>작성돼있다면 오브젝트의 Symbol.match()를 호출합니다. String.prototype.match()는 호출되지 않습니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"Sports\"</span>.match(<span class=\"regexp\">/s/</span>));  </span><br><span class=\"line\"><span class=\"comment\">// 1: [0: \"5\", index: 5, input: \"Sports\"]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MatchCheck</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>(base) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.base = base;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"number\">2.</span> [<span class=\"built_in\">Symbol</span>.match](target) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.base.indexOf(target) &gt;= <span class=\"number\">0</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> instMatch = <span class=\"keyword\">new</span> MatchCheck(<span class=\"string\">\"sports\"</span>);  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"string\">\"po\"</span>.match(instMatch));  </span><br><span class=\"line\"><span class=\"comment\">// 2: true</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>“Sports”에 패턴/s/를 매치하면 매치 결과를 배열로 반환합니다. “Sports”가 문자열이므로<br>엔진이 String.prototype에 연결된 프로퍼티로 String 인스턴스를 생성합니다.<br>생성한 인스턴스에 “Sports”를 설정한 후 match()를 호출하면서 /s/를 파라미터로 넘겨줍니다.</p>\n</li>\n<li><p>Symbol.match()의 target 파라미터에 설정된 문자열이 this.base에 포함되어 있으면 true를 반환하고, 아니면 false를 반환합니다.</p>\n</li>\n<li><p>new MatchCheck(“sports”);를 실행하면 constructor가 호출되고 파라미터로 넘겨 준 “sports”가 this.base에 설정됩니다.</p>\n</li>\n<li><p>“po”.match(instMatch)가 호출되면 파라미터에 작성한 instMatch 인스턴스에서 Symbol.match의 작성 여부를 체크합니다. 존재하므로 Symbol.match(target)을 호출하면서 “po”를 파라미터 값으로 넘겨줍니다.<br>Symbol.match()에서 “sports” 와 “po”로 match를 행하며, “po”가 있으므로 true를 반환합니다.</p>\n</li>\n</ol>\n<h2 id=\"Symbol_matchAll\">matchAll()</h2>\n\n<p>Symbol.matchAll 은 String 오브젝트를 정규표현식으로 평가하여<br>반환결과를 이터레이터 오브젝트로 반환합니다.</p>\n<p>Symbol.matchAll은 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll\">String.prototype.matchAll()</a>메서드에 의해 호출 됩니다.</p>\n<p>+참고 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@matchAll\">RegExp.prototype[@@matchAll] ( )</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> re = <span class=\"regexp\">/[0-9]+/g</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'2016-01-02|2019-03-07'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = re[<span class=\"built_in\">Symbol</span>.matchAll](str);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.from(result, x =&gt; x[<span class=\"number\">0</span>]));  </span><br><span class=\"line\"><span class=\"comment\">// expected output: Array [\"2016\", \"01\", \"02\", \"2019\", \"03\", \"07\"]</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>Symbol 오브젝트에 프로퍼티들을 살펴봅니다.<br>이 프로퍼티들은 메서드로도 사용할 수 있습니다</p>\n<ul>\n<li>Symbol 프로퍼티<ul>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Well-Known_Symbol\">Well-Known Symbol</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#toStringTag\">toStringTag</a><ul>\n<li>클래스의 메서드로 사용</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#isConcatSpreadable\">isConcatSpreadable</a><ul>\n<li>Array-like 오브젝트에서 사용</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#unscopable\">unscopable</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#species_개념\">species 개념</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#species\">species</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#return_other_Class\">다른 Class 반환</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#return_null\">null 반환</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#toPrimitive\">toPrimitive</a><ul>\n<li>toPrimitive() 파라미터의 세가지 모드(mode)</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_iterator\">이터레이터</a><ul>\n<li>Array.prototype[Symbol.iterator]</li>\n<li>String.prototype[Symbol.iterator]</li>\n<li>Object 이터레이션</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_generator\">제너레이터</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_asyncIterator\">asyncIterator(): 비동기 반복</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_match\">match(): match 결과 반환</a></li>\n<li><a href=\"/2020/04/06/Symbol%20프로퍼티%20-ECMAScript/#Symbol_matchAll\">matchAll()</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"Well-Known_Symbol\">Well-Known Symbol</h2>\n\n\n<p>스펙에서 @@iterator 형태로 작성된 것을 볼 수 있으며<br>@@는 Symbol 대신 사용한 것입니다.<br>따라서 @@iterator는 Symbol.iterator와 같습니다.<br>@@iterator 형태는 스펙에서 사용하며 Symbol.iterator 형태는 내부 프로퍼티인<br>[[Description]]에 저장되는 형태입니다.<br>개발자 코드에서는 Symbol.iterator 형태를 사용합니다.</p>\n<table>\n<thead>\n<tr>\n<th>Spec name</th>\n<th>[[Description]]</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@@asyncIterator</td>\n<td>Symbol.asyncIterator</td>\n</tr>\n<tr>\n<td>@@hasInstance</td>\n<td>Symbol.hasInstance</td>\n</tr>\n<tr>\n<td>@@isConcatSpreadable</td>\n<td>Symbol.isConcatSpreadable</td>\n</tr>\n<tr>\n<td>@@iterator</td>\n<td>Symbol.iterator</td>\n</tr>\n<tr>\n<td>@@match</td>\n<td>Symbol.match</td>\n</tr>\n<tr>\n<td>@@matchAll</td>\n<td>Symbol.matchAll</td>\n</tr>\n<tr>\n<td>참고용 프로퍼티</td>\n<td>Symbol.prototype.description</td>\n</tr>\n<tr>\n<td>@@replace</td>\n<td>Symbol.replace</td>\n</tr>\n<tr>\n<td>@@search</td>\n<td>Symbol.search</td>\n</tr>\n<tr>\n<td>@@species</td>\n<td>Symbol.species</td>\n</tr>\n<tr>\n<td>@@split</td>\n<td>Symbol.split</td>\n</tr>\n<tr>\n<td>@@toPrimitive</td>\n<td>Symbol.toPrimitive</td>\n</tr>\n<tr>\n<td>@@toStringTag</td>\n<td>Symbol.toStringTag</td>\n</tr>\n<tr>\n<td>@@unscopables</td>\n<td>Symbol.unscopables</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>Well-Known Symbol은 스펙에서 처리 알고리즘(Algorism)을 구분하기 위해 부여한 이름입니다. 즉, 자바스크립트 엔진이 디폴트로 처리하는 알고리즘 유형 이름입니다.</p>\n</li>\n<li><p><mark>자바스크립트 프로그램에 같은 이름의 Well-Known.Symbol을 작성하면<br>엔진의 디폴트 처리를 실행하지 않고 프로그램에 작성한 코드를 실행합니다(오버라이딩)<br>Well-Known Symbol이 오버라이드되는 것과 같으므로 프로그램에 같은 이름을작성하여<br>Well-Known Symbol기능을 대체할 수 있습니다.</makr></p>\n</li>\n</ul>\n<p><strong>이런 가변성과 유용성을 제공하는 것이 Well-Known Symbol의 목적입니다.</strong></p>\n<hr>\n<h2 id=\"toStringTag\">toStringTag</h2>\n\n<p>[object Object] 형태에서 Object를 Symbol.toStringTag 값으로 표시합니다.<br>객체의 기본 문자열 설명을 만드는 데 사용되는 문자열 값 속성입니다.<br><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\">Object.prototype.toString()</a> 메소드에 의해 내부적으로 액세스됩니다.</p>\n<h3 id=\"설명\"><a href=\"#설명\" class=\"headerlink\" title=\"설명\"></a>설명</h3><p><strong>많은 자바스크립트 타입들은 기본적으로 tag를 가지고 있습니다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>tag default</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"string\">'foo'</span>);     </span><br><span class=\"line\"><span class=\"comment\">// \"[object String]\"  </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call([<span class=\"number\">1</span>, <span class=\"number\">2</span>]);    </span><br><span class=\"line\"><span class=\"comment\">// \"[object Array]\"  </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"number\">3</span>);         </span><br><span class=\"line\"><span class=\"comment\">// \"[object Number]\"  </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">true</span>);      </span><br><span class=\"line\"><span class=\"comment\">// \"[object Boolean]\"  </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">undefined</span>); </span><br><span class=\"line\"><span class=\"comment\">// \"[object Undefined]\"  </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">null</span>);      </span><br><span class=\"line\"><span class=\"comment\">// \"[object Null]\"  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... and more</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>기본적으로 toStringTag symbol이 정의되어 있는 것도 있습니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>());       </span><br><span class=\"line\"><span class=\"comment\">// \"[object Map]\"  </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;&#125;); </span><br><span class=\"line\"><span class=\"comment\">// \"[object GeneratorFunction]\"  </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"built_in\">Promise</span>.resolve()); </span><br><span class=\"line\"><span class=\"comment\">// \"[object Promise]\" </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... and more</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>class를 생성하면 자바스크립트는 기본값으로 Object tag를 설정합니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValidatorClass</span> </span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"keyword\">new</span> ValidatorClass()); </span><br><span class=\"line\"><span class=\"comment\">// \"[object Object]\"</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>toStringTag를 이용하여 자신만의 맞춤 태그를 설정할 수 있습니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValidatorClass</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">get</span> [Symbol.toStringTag]() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">'Validator'</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"keyword\">new</span> ValidatorClass()); </span><br><span class=\"line\"><span class=\"comment\">// \"[object Validator]\"</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>toStringTag 예제</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Sports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> sportsObj = <span class=\"keyword\">new</span> Sports;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(sportsObj.toString());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> Sports.prototype[<span class=\"built_in\">Symbol</span>.toStringTag] = <span class=\"string\">\"Sports-Function\"</span>;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(sportsObj.toString());  </span><br><span class=\"line\"><span class=\"comment\">// [object Object]  </span></span><br><span class=\"line\"><span class=\"comment\">// [object Sports-Function]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>new Sports로 생성한 인스턴스로 toString()을 실행하면 [object Object]가 반환됩니다.<br>Object 오브젝트도 [object Object]를 반환하므로 구분이 어렵습니다.<br>한편 new Sports()의 파라미터 값이 없을때 new sports; 로 사용할 수 있습니다.</p>\n</li>\n<li><p>Sports.prototype[Symbol.toStringTag] = “Sports-Function”;<br>Sports.prototype[Symbol.toStringTag]에 [object Object] 의 Object에 표시할 문자열을 지정합니다.</p>\n</li>\n<li><p>sportsObj.toString()을 실행하면 엔진에서 디폴트 toStringTag 값을 반환하기 전에<br>sportsObj에서 Symbol.toStringTag의 작성 여부를 체크합니다.<br>값이 작성되어 있다면 디폴트 값이 아닌 작성된 값을 반환합니다.<br>따라서 [object Sports-Function] 이 출력됩니다.<br>[object Sports-Function]을 정규표현식으로 분리하면 Sports-Function을 구할 수 있습니다.</p>\n</li>\n</ol>\n<h3 id=\"클래스의-메서드로-사용\"><a href=\"#클래스의-메서드로-사용\" class=\"headerlink\" title=\"클래스의 메서드로 사용\"></a>클래스의 메서드로 사용</h3><p>Symbol.toStringTag를 클래스의 getter로 작성할 수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> </span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> bookObj = <span class=\"keyword\">new</span> Book();  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(bookObj.toString());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">get</span> [Symbol.toStringTag]() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"Sports-class\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> sportsObj = <span class=\"keyword\">new</span> Sports();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sportsObj.toString());  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Map</span>.prototype[<span class=\"built_in\">Symbol</span>.toStringTag]);  </span><br><span class=\"line\"><span class=\"comment\">//[object Object]  </span></span><br><span class=\"line\"><span class=\"comment\">//[object Sports-class]  </span></span><br><span class=\"line\"><span class=\"comment\">//Map</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>toString()을 실행하면 [object Object]가 반환됩니다.<br>따라서 Function 오브젝트, Object 오브젝트와 구분할 수 없습니다.</p>\n</li>\n<li><p>클래스에 Symbol.toStringTag를 getter로 선언했습니다.<br>return 문에 [object Object]에서 Object에 표시될 문자열을 작성했습니다.Sports-class가 반환됩니다.<br>getter로 작성하지 않고 메서드로 작성하면 [object Object]가 반환되므로 getter로 작성해야 합니다.</p>\n</li>\n<li><p>인스턴스로 toString()을 호출하면 sportsObj 인스턴스에 작성된 getSymbol.toStringTag가 호출됩니다.<br>호출된 메서드에서 “Sports-class”를 반환하므로 [object Sports-class]가 출력됩니다.</p>\n</li>\n<li><p>Map 같이 Symbol.toStringTag를 기본값(빌트인)으로 가지고 있는 것들이 있습니다.<br>Map.prototype[Symbol.toStringTag]를 실행하면 “Map”이 출력됩니다.<br>개발자 코드로 Symbol.toStringTag에 표시될 문자열을 작성하거나 getter를 사용하지 않아도 됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"isConcatSpreadable\">isConcatSpreadable</h2>\n\n<p>Symbol.isConcatSpreadable는<br><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\">Array.prototype.concat()</a> 메서드를 사용할 때 객체를 배열 요소에 병합해야하는지 구성하는 데 사용됩니다.</p>\n<blockquote>\n<p>[Symbol.isConcatSpreadable] = true / false</p>\n</blockquote>\n<ul>\n<li>프로퍼티의 기본값은 true 입니다.<br>false로 설정시 배열을 펼처서 합치지 않고 배열의 끝에 배열을 추가합니다.<br>사용시 true/false 에 따라 생성되는 배열의 length값이 달라집니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> one = [<span class=\"number\">11</span>, <span class=\"number\">12</span>], two = [<span class=\"number\">21</span>, <span class=\"number\">22</span>];  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = one.concat(two);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result, result.length);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Array(4)  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: 11  </span></span><br><span class=\"line\"><span class=\"comment\"> 1: 12  </span></span><br><span class=\"line\"><span class=\"comment\"> 2: 21  </span></span><br><span class=\"line\"><span class=\"comment\"> 3: 22  </span></span><br><span class=\"line\"><span class=\"comment\"> length: 4  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Array(0)  </span></span><br><span class=\"line\"><span class=\"comment\">4   </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> two[<span class=\"built_in\">Symbol</span>.isConcatSpreadable] = <span class=\"literal\">false</span>;  </span><br><span class=\"line\">result = one.concat(two);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result, result.length);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Array(3)  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: 11  </span></span><br><span class=\"line\"><span class=\"comment\"> 1: 12  </span></span><br><span class=\"line\"><span class=\"comment\"> 2: Array(2)  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: 21  </span></span><br><span class=\"line\"><span class=\"comment\"> 1: 22  </span></span><br><span class=\"line\"><span class=\"comment\"> length: 2  </span></span><br><span class=\"line\"><span class=\"comment\"> Symbol(Symbol.isConcatSpreadable): true  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Array(0)  </span></span><br><span class=\"line\"><span class=\"comment\"> length: 3  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Array(0)  </span></span><br><span class=\"line\"><span class=\"comment\">3  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> two[<span class=\"built_in\">Symbol</span>.isConcatSpreadable] = <span class=\"literal\">true</span>;  </span><br><span class=\"line\">result = one.concat(two);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result, result.length);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Array(4)  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: 11  </span></span><br><span class=\"line\"><span class=\"comment\"> 1: 12  </span></span><br><span class=\"line\"><span class=\"comment\"> 2: 21  </span></span><br><span class=\"line\"><span class=\"comment\"> 3: 22  </span></span><br><span class=\"line\"><span class=\"comment\"> length: 4  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Array(0)  </span></span><br><span class=\"line\"><span class=\"comment\">4  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>one 배열의 [11, 12]에 concat()의 파라미터에 지정한 two 배열 [21, 22]를 결합하면,<br>21 과 22가 각각 분리되어 one 배열 끝에 추가됩니다.<br>[11, 12, 21, 22] length: 4 가 반환됩니다.<br>Array.prototype에 [Symbol.isConcatSpreadable]을 작성하지 않았으므로 디폴트 true값 입니다.<br>일반적인 concat()메서드 사용입니다.</p>\n</li>\n<li><p>two[Symbol.isConcatSpreadable]에 false 값을 할당했습니다.<br>concat() 메서드로 one 배열과 two 배열을 결합하면 two 배열의 [21, 22]를 분리하지 않고<br>배열 자체를 첨부합니다. [11, 12, Array[2]] 형태로 결합되어 length 값은 3을 갖습니다.<br>개발자 도구에서 Array[2]를 살펴보면 [21, 22] length: 2 가 할당되어 있고<br>Symbol(Symbol.isConcatSpreadable): true로 isConcatSpreadable = false 가 적용된 것을 볼 수 있습니다. 기본값 isConcatSpreadable = true 인 경우 프로퍼티에 나타나지 않습니다.</p>\n</li>\n<li><p>two[Symbol.isConcatSpreadable]에 true를 할당하였으며 디폴트 값 true와 같습니다.<br>one 배열에 two 배열의 [21, 22]가 분리되어 끝에 첨부됩니다.<br>[11, 12, 21, 22] 형태가 됩니다.</p>\n</li>\n</ol>\n<h3 id=\"Array-like-오브젝트에서-사용\"><a href=\"#Array-like-오브젝트에서-사용\" class=\"headerlink\" title=\"Array-like 오브젝트에서 사용\"></a>Array-like 오브젝트에서 사용</h3><p><mark>유사 배열(Array-like) 오브젝트도 concat()을 사용할 수 있습니다. 하지만 유사 배열 오브젝트는 isConcatSpreadable = true 값을 가지지 않습니다.</mark> concat()으로 배열을 하나씩 분리하여 추가 병합하고 싶다면 isConcatSpreadable를 사용하여 true로 설정해줍니다.</p>\n<figure class=\"highlight js\"><figcaption><span>isConcatSpreadable > Array-like</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> one = [<span class=\"number\">11</span>, <span class=\"number\">12</span>];  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> fiveSix = &#123;  </span><br><span class=\"line\"> <span class=\"number\">0</span>: <span class=\"string\">\"five\"</span>,  </span><br><span class=\"line\"> <span class=\"number\">1</span>: <span class=\"string\">\"six\"</span>,  </span><br><span class=\"line\"> length: <span class=\"number\">2</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = one.concat(fiveSix);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result, result.length);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Array(3)  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: 11  </span></span><br><span class=\"line\"><span class=\"comment\"> 1: 12  </span></span><br><span class=\"line\"><span class=\"comment\"> 2: Object&#123;  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: \"five\",   </span></span><br><span class=\"line\"><span class=\"comment\"> 1: \"six\",   </span></span><br><span class=\"line\"><span class=\"comment\"> length: 2&#125;   </span></span><br><span class=\"line\"><span class=\"comment\"> length: 3  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Array(0)  </span></span><br><span class=\"line\"><span class=\"comment\">3  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> arrayLike = &#123;  </span><br><span class=\"line\"> [<span class=\"built_in\">Symbol</span>.isConcatSpreadable]: <span class=\"literal\">true</span>,  </span><br><span class=\"line\"> <span class=\"number\">0</span>: <span class=\"string\">\"five\"</span>,  </span><br><span class=\"line\"> <span class=\"number\">1</span>: <span class=\"string\">\"six\"</span>,  </span><br><span class=\"line\"> length: <span class=\"number\">2</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">result = one.concat(arrayLike);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result, result.length);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">Array(4)  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: 11  </span></span><br><span class=\"line\"><span class=\"comment\"> 1: 12  </span></span><br><span class=\"line\"><span class=\"comment\"> 2: \"five\"  </span></span><br><span class=\"line\"><span class=\"comment\"> 3: \"six\"  </span></span><br><span class=\"line\"><span class=\"comment\"> length: 4  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Array(0)  </span></span><br><span class=\"line\"><span class=\"comment\">4  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>one은 배열 [11, 12]이고 fiveSix는 Array-like {0: “five”, 1” “six”, length:2}입니다.<br>이 상태에서 concat()을 실행하면 [11, 12, Object] 형태가 됩니다.<br>오브젝트 형태가 분리되어 첨부되지 않습니다.</p>\n</li>\n<li><p>Array-like 오브젝트에 [Symbol.isConcatSpreadable]: true를 작성하여,<br>concat()을 실행하면 Array-like 오브젝트의 각 프로퍼티를 분리하여 배열 끝에 첨부합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"unscopable\">unscopable</h2>\n\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/with\">with</a>문에서 사용하며 값이 true 이면 프로퍼티를 전개 하지 않습니다.</p>\n<blockquote>\n<p>[Symbol.unscopables] = true/false</p>\n</blockquote>\n<p>Symbol.unscopables 값이 true일 때, with 문에서 프로퍼티를 전개하지 않으므로<br>Object 오브젝트의 프로퍼티 키를 사용하면 에러가 발생합니다.</p>\n<p>ES5 에서 “use strict” 범위에 with 문을 사용하면 에러가 발생합니다.ES6도 마찬가지 입니다. ES6에서 stirct모드는 보편적인 환경이므로 Symbol.unscopables를 사용할 빈도가 그다지 높지 않습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>Symbol.unscopables</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// \"use strict\" 를 선언하면 with 에서 에러 발생  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sports = &#123;  </span><br><span class=\"line\"> soccer: <span class=\"string\">\"축구\"</span>,  </span><br><span class=\"line\"> baseball: <span class=\"string\">\"야구\"</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">with</span>(sports)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(soccer, baseball);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> sports[<span class=\"built_in\">Symbol</span>.unscopables] = &#123;  </span><br><span class=\"line\"> baseball: <span class=\"literal\">true</span>  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"keyword\">with</span> (sports) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(soccer);  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> value = baseball;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(e.message);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// 축구 야구  </span></span><br><span class=\"line\"><span class=\"comment\">// 축구  </span></span><br><span class=\"line\"><span class=\"comment\">// baseball is not defined</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>with 문을 실행하면 파라미터에 작성한 sports 오브젝트의 프로퍼티가 펼쳐진(spread)형태가 됩니다.<br>따라서 프로퍼티 값을 구할 때 sports[“soccer”]형태로 작성하지 않고 soccer만 작성합니다.<br>soccer의 프로퍼티 값인 “축구”가 반환되고 baseball의 프로퍼티 값도 마찬가지로 반환되어<br>“축구” “야구”가 출력됩니다.</p>\n</li>\n<li><p>with(sports)를 실행할 때 sports 오브젝트에서 전개하지 않을 프로퍼티를 작성합니다.<br>baseball: true를 설정해줬으므로 with 문에서 baseball 프로퍼티가 전개되지 않습니다.<br>그러므로 soccer의 프로퍼티 값인 “축구”만 출력됩니다.</p>\n</li>\n<li><p>with(sports) 문에서 baseball 프로퍼티가 전개되지 않으므로 baseball을 변수에 할당하면<br>에러가 발생합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"species_개념\">species 개념</h2>\n\n<p>Symbol.species는 constructor를 반환합니다.<br>constructor를 반환한다는 것은 constructor로 인스턴스를 생성하여 반환하는 것과 같습니다.<br>Symbol.species를 오버라이드 할 수 있으며, 개발자 코드로 반환되는 인스턴스를 변경할 수 있습니다.</p>\n<p>species의 개념을 살펴 봅니다.</p>\n<figure class=\"highlight js\"><figcaption><span>species 개념</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> arrayObj = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> sliceOne = arrayObj.slice(<span class=\"number\">1</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> sliceTwo = sliceOne.slice(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>let arrayObj = [1, 2, 3]을 실행하면 Array 오브젝트(인스턴스)를 생성하고 엘리먼트 값으로<br>1, 2, 3을 설정합니다. 아래는 [1, 2, 3]이 할당된 arrayObj 인스턴스 구조입니다.</p>\n<img src=\"/images/speciesArrayObj.JPG\">    \n\n<p>arrayObj 구성을 보면 prototype이 없으며 &#95;&#95;proto&#95;&#95;만 있습니다.<br>&#95;&#95;proto&#95;&#95;에는 Array 오브젝트의 prototype에 연결된 프로퍼티가 첨부되어 있습니다.<br>Array의 오브젝트 프로퍼티가 연결되어 있지만 arrayObj에는 연결된 프로퍼티가 없습니다.<br>따라서 arrayObj는 Array 오브젝트가 아닌 Array 인스턴스입니다.</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>arrayObj.slice(1, 3) 코드는 자바스크립트에서 일반적으로 사용하는 [1, 2, 3].slice(1, 3)형태와 다릅니다.[1, 2, 3]으로 Array 인스턴스를 생성하여 arrayObj에 할당하고, arrayObj에 있는 slice()를 호출하는 형태 입니다. 실행하면 [1, 2, 3]에서 2와 3이 반환되어 sliceOne 변수에 할당될 것으로 생각할 수 있습니다.<br>하지만, sliceOne변수에 할당되는 것은 Array 인스턴스 입니다. 2 와 3이 인스턴스 값으로 설정됩니다.<br>arrayObj 와 sliceOne 둘다 Array 오브젝트 인스턴스 입니다. 배열의 엘리먼트 값이 달라집니다.</li>\n</ol>\n<p><strong>여기서 중요한 점은 Array 인스턴스(arrayObj)의 slice()를 호출하면 slice()실행 결과가 반영된</strong><br><strong>Array 인스턴스가 반환된다는 점입니다. Array 인스턴스가 반환되므로 sliceOne 인스턴스를 지정하여 slice()를 호출할 수 있습니다.</strong></p>\n<ol start=\"3\">\n<li>sliceOne 인스턴스를 지정하여 slice()를 호출하고 마찬가지로 Array 인스턴스가 반환됩니다.<br>Symbol.species를 이해하려면 먼저 이에 대한 이해가 필요합니다.</li>\n</ol>\n<hr>\n<h2 id=\"species\">species</h2>\n\n<p>Symbol.species는 constructor를 반환합니다.</p>\n<p>Symbol.species는 static 액세서 프로퍼티로 getter만 있고 setter는 없습니다.<br>Array, Map, Set, Promise, RegExp, ArrayBuffer, TypedArray 오브젝트에 Symbol.species가 빌트인으로 포함되어 있습니다.</p>\n<p>위에 거론된 빌트인 오브젝트를 상속받는 클래스에 Symbol.species를 작성하면, 빌트인 오브젝트의 Symbol.species가 오버라이드됩니다. 이를 통해 클래스의 Symbol.species에서 다른 오브젝트를 반환할 수 있습니다.</p>\n<ul>\n<li>예를 들어 인스턴스의 slice()를 호출하면 slice()를 호출한 인스턴스를 반환하지만, 클래스에 Symbol.species를 작성하여 인스턴스가 아닌 Array 오브젝트를 반환할 수 있습니다. <strong>(인스턴스 대신 인스턴스의 부모 오브젝트 반환)</strong></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendArray</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> [Symbol.species]() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> oneInstance = <span class=\"keyword\">new</span> ExtendArray(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> twoInstance = oneInstance.slice(<span class=\"number\">1</span>, <span class=\"number\">2</span>);  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(oneInstance <span class=\"keyword\">instanceof</span> ExtendArray);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"built_in\">console</span>.log(twoInstance <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">6.</span> <span class=\"built_in\">console</span>.log(twoInstance <span class=\"keyword\">instanceof</span> ExtendArray);  </span><br><span class=\"line\"><span class=\"comment\">//true  </span></span><br><span class=\"line\"><span class=\"comment\">//true  </span></span><br><span class=\"line\"><span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/instanceof\">instanceof 연산자</a>는 생성자의 프로토 타입 속성이 객체의 프로토 타입 체인에 나타나는지 테스트하여 true/false값을 반환합니다.</p>\n<ol>\n<li><p>ExtendArray 클래스에서 Array 오브젝트를 상속받습니다. 클래스에 static 메서드이면서 getter를 사용하여 Symbol.species를 작성하였습니다. Array 오브젝트의 Symbol.species가 오버라이드 됩니다.<br>인스턴스의 Array 오브젝트 메서드를 호출하면 오버라이드된 Symbol.species가 호출됩니다.<br>그리고 return Array;를 하므로 메서드를 호출한 인스턴스가 반환되지 않고 Array 인스턴스가 반환됩니다.</p>\n<ul>\n<li>return Array가 Array 오브젝트의 constructor를 반환하지만, return 문은 오른쪽의 표현식을 평가하고 평가 결과를 반환하므로 Array 오브젝트의 constructor를 호출하고 그 결과인 Array 인스턴스를 반환합니다.</li>\n</ul>\n</li>\n<li><p>new 연산자로 ExtendArray()룰 호출하면서 파라미터로 1, 2, 3을 넘겨줬습니다.<br>ExtendArray 클래스에서 Array 오브젝트를 상속받았으므로 생성한 인스턴스는 Array 오브젝트 특성을 갖습니다.</p>\n</li>\n<li><p>oneInstance 인스턴스에 상속받은 Array 오브젝트가 존재하므로 slice()를 호출할 수 있습니다.<br>slice()가 호출되면 ExtendArray 클래스에 getter로 작성된 Symbol.species()가 호출되며,<br>oneInstance가 반환되지 않고 Array 인스턴스를 생성하여 반환합니다.</p>\n</li>\n<li><p>new ExtendArray(1, 2, 3)으로 생성한 인스턴스를 oneInstance에 할당했으므로 true가 출력됩니다.</p>\n</li>\n<li><p>oneInstance.sliceOne(1, 2)를 실행하면 클래스에 작성한 Symbol.species()가 호출됩니다.<br>return Array로 생성한 인스턴스를 twoInstance에 할당했으므로 true가 출력됩니다.</p>\n</li>\n<li><p>new ExtendArray()로 생성한 인스턴스를 twoInstance에 할당한 것이 아니라, Array 오브젝트로 생성한 인스턴스(oneInstance)를 할당했으므로 false가 출력됩니다.<br>이처럼 Symbol.species로 반환되는 인스턴스를 변경할 수 있습니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"return_other_Class\">다른 Class 반환</h2>\n\n<p>위 에서 return 문에서 상속받은 Array 오브젝트를 반환하는 형태를 살펴봤습니다.<br>여기서는 다른 클래스를 반환하는 형태를 살펴봅니다.</p>\n<figure class=\"highlight js\"><figcaption><span>other-Class</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendOne</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span></span>&#123;  </span><br><span class=\"line\"> showOne()&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"ExtendOne\"</span>);  </span><br><span class=\"line\">    </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendTwo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span></span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> [Symbol.species]() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> ExtendOne;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> showTwo()&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"ExtendTwo\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> twoInst = <span class=\"keyword\">new</span> ExtendTwo(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> threeInst = twoInst.filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value &gt; <span class=\"number\">10</span>);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(threeInst);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> threeInst.showOne();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(threeInst.showTwo);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">ExtendOne(2)  </span></span><br><span class=\"line\"><span class=\"comment\"> 0: 20  </span></span><br><span class=\"line\"><span class=\"comment\"> 1: 30  </span></span><br><span class=\"line\"><span class=\"comment\"> length: 2  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Array  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"><span class=\"comment\">// ExtendOne  </span></span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>ExtendOne 클래스에서 Array 오브젝트를 상속받습니다.<br>이 클래스를 아래에 작성한 2. ExtendTwo 클래스의 [Symbol.species]에서 반환합니다.</p>\n</li>\n<li><p>[Symbol.species] ( )에서 ExtendOne을 return 하므로 클래스를 반환하는 것처럼 보입니다만,<br>클래스의 constructor를 반환하므로 인스턴스로 생성하여 반환하게 됩니다.<br>이와 같이 [Symbol.species] ( )를 호출한 인스턴스가 아닌 다른 인스턴스로 반환할 수 있습니다.</p>\n</li>\n<li><p>twoInst.filter()가 호출되면, 우선 twoInst 인스턴스를 생성한 ExtendTwo 클래스에서 [Symbol.species] 작성 여부를 체크합니다. 존재하면 클래스의 [Symbol.species] ()를 호출하고 존재하지 않으면 상속받은 Array 오브젝트의 [Symbol.species] ()를 호출합니다.</p>\n</li>\n<li><p>호출된 [Symbol.species] ()에서 ExtendOne 인스턴스를 반환하여 ExtendTwo 클래스에서 Array 오브젝트를 상속받았으므로 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\">filter()</a> 메서드를 호출할 수 있습니다.<br>ExtendOne 클래스에서 filter() 메서드를 지원하지 않는 오브젝트를 상속받으면 Error가 발생합니다.</p>\n</li>\n</ol>\n<p>filter() 실행 결과 twoInst에 설정하지 않고 반환할 인스턴스에 할당합니다. 즉 threeInst 인스턴스에 할당됩니다. 따라서 twoInst 인스턴스 값 [10, 20, 30]이고 threeInst 인스턴스 값은 [20, 30]입니다.</p>\n<ol start=\"5\">\n<li>return ExtendOne으로 인해 ExtendOne 인스턴스가 threeInst에 설정되므로,<br>threeInst 인스턴스의 showOne()을 호출할 수 있습니다. showTwo는 존재하지 않으므로 undefined가 출력됩니다.</li>\n</ol>\n<hr>\n<h2 id=\"return_null\">null 반환</h2>\n\n<p>[Symbol.species] ()에서 null을 반환하면 디폴트[Symbol.species] ()가 호출됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendOne</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span></span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> [Symbol.species]() &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> oneInst = <span class=\"keyword\">new</span> ExtendOne(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> arrayInst = oneInst.filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value &gt; <span class=\"number\">10</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(arrayInst <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>);  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(arrayInst <span class=\"keyword\">instanceof</span> ExtendOne);  </span><br><span class=\"line\"><span class=\"comment\">// true  </span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>oneInst.filter()를 호출하면 ExtendOne 클래스의 [Symbol.species] ()가 호출되며 null를 반환합니다.<br>null이 반환되면 디폴트 [Symbol.species] ()가 호출됩니다.<br>ExtendOne 클래스에 작성하지 않았지만 상속받은 Array 오브젝트에 있으므로 [Symbol.species] ()가 호출되며<br>Array 인스턴스를 생성하여 반환합니다. 따라서 filter()를 실행할 수 있습니다.</p>\n</li>\n<li><p>oneInst.filter()를 실행하면 [Symbol.species] ()에서 Array 인스턴스를 반환하여 arrayInst에 할당하므로 true값이 출력됩니다.</p>\n</li>\n<li><p>[Symbol.species] ()에서 Array 인스턴스를 반환하므로 arrayInst는 ExtendOne 클래스의 인스턴스가 아닙니다.<br>false</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"toPrimitive\">toPrimitive</h2>\n\n<p>오브젝트를 프리미티브(원시값) 타입으로 변환합니다.</p>\n<p>자바스크립트의 프리미티브 값은 number, string, boolean, undefined, null 그리고 symbol입니다.<br>+연산자는 앞뒤의 값 타입에 따라 값을 더하거나 연결합니다. (1+2)는 3이되지만 (1+”2”)는 12가 됩니다.<br>반면 곱하기(*), 나누기(/), 빼기(-)는 연산만 하고 연결은 하지 않습니다.</p>\n<p><mark>연산 대상이 Number 타입이 아닐 경우 엔진의 ToPrimitive 모듈을 기준으로 값을 변환합니다. 예를 들어, 숫자에 true를 더하면 1로 변환하여 더하고, 문자열에 true를 더하면 “true”로 변환하여 연결합니다. 이때 Symbol.toPrimitive()로 ToPrimitive를 오버라이드하여 엔진의 변환 기준을 변경할 수 있습니다.</mark>(엔진의 디폴트 변환 값을 개발자 코드로 변경)</p>\n<h3 id=\"세-가지-모드\"><a href=\"#세-가지-모드\" class=\"headerlink\" title=\"세 가지 모드\"></a>세 가지 모드</h3><p>Symbol.toPrimitive() 에서 값을 변환하는 기준은 이를 호출하는 형태에 따라 결정됩니다.</p>\n<p>엔진은 호출한 곳의 형태에 따라 Symbol.toPrimitive(hint) 파라미터에 세 가지 모드(Mode)를 설정합니다.<br><del>개발자가 작성하는 것이 아니라 엔진이 다음 기준으로 설정하는 것입니다.</del></p>\n<ol>\n<li><p>Number 환경이면 “number”를 toPrimitive(hint) 파라미터에 설정합니다.</p>\n</li>\n<li><p>String 환경이면 “string”을 toPrimitive(hint) 파라미터에 설정합니다.</p>\n</li>\n<li><p>Number 와 String 환경이 아니면 toPrimitive(hint) 파라미터에 “default”를 설정합니다.</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;  </span><br><span class=\"line\"> [<span class=\"built_in\">Symbol</span>.toPrimitive](hint)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (hint === <span class=\"string\">\"number\"</span>)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"number\">30</span>;  </span><br><span class=\"line\"> &#125;;  </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (hint === <span class=\"string\">\"string\"</span>)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"문자열\"</span>;  </span><br><span class=\"line\"> &#125;;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"string\">\"디폴트\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, <span class=\"number\">20</span> + obj); <span class=\"comment\">// 1: 20디폴트  </span></span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"number\">20</span> * obj); <span class=\"comment\">// 2: 600  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"3:\"</span>, obj + <span class=\"number\">50</span>); <span class=\"comment\">// 3: 디폴트50  </span></span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"4:\"</span>, +obj + <span class=\"number\">50</span>);<span class=\"comment\">// 4: 80  </span></span><br><span class=\"line\"><span class=\"number\">5.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"5:\"</span>, <span class=\"string\">`<span class=\"subst\">$&#123;obj&#125;</span>`</span> + <span class=\"number\">123</span>); <span class=\"comment\">// 5: 문자열123</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>(20 + obj)와 같이 오브젝트가 연산 대상이면, 자동으로 obj 오브젝트의 [Symbol.toPrimitive] ()가 호출됩니다. 파라미터에 “default”가 설정됩니다. 함수에서 “디폴트”를 반환하여 문자열을 연결하는 형태가 되어 “20디폴트”가 출력됩니다.</p>\n</li>\n<li><p>곱하기(*)를 사용하였으므로 파라미터에 “number”가 설정됩니다. 함수에서 30을 반환하며 20을곱해 600이 출력됩니다.</p>\n</li>\n<li><p>(20 + obj)에서 파라미터에 “default”가 설정되듯이 마찬가지로 “default”가 설정됩니다.<br>함수에서 “디폴트”를 반환하여 50을 연결하므로 “디폴트50”이 출력됩니다.</p>\n</li>\n<li><p>+obj 에서 +는 단항+연산자로 피연산자를 Number 타입으로 변환합니다.<br>함수에서 30을 반환하며 50을더해 80이 출력됩니다.</p>\n</li>\n<li><p>템플릿을 사용한 형태로 파라미터에 “string”이 설정됩니다. 함수에서 “문자열”을 반환하여<br>${obj}가 “문자열”로 변환됩니다. 123을 연결하여 “문자열123”이 출력됩니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Symbol_iterator\">이터레이터</h2>\n\n<p>Symbol.iterator()는 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<p>Symbol.iterator는 String, Array, Map, Set, TypedArray 오브젝트의 prototype에 연결되어 있습니다.<br>오브젝트의 [Symbol.iterator]를 호출하면 이터레이터 오브젝트를 생성하여 반환합니다.</p>\n<p>Object 오브젝트에는 Symbol.iterator가 없습니다만, 개발자 코드로 구현할 수 있습니다.</p>\n<h3 id=\"Array-prototype-Symbol-iterator\"><a href=\"#Array-prototype-Symbol-iterator\" class=\"headerlink\" title=\"Array.prototype[Symbol.iterator]\"></a>Array.prototype[Symbol.iterator]</h3><p>배열 처리를 위한 이터레이터 오브젝트를 생성하여 반환합니다. 배열 엘리먼트를 하나씩 처리할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>iterator-Array</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numberArray = [<span class=\"number\">10</span>, <span class=\"number\">20</span>];  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> numberArray)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iteratorObj = numberArray[<span class=\"built_in\">Symbol</span>.iterator]();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"comment\">//10  </span></span><br><span class=\"line\"><span class=\"comment\">//20  </span></span><br><span class=\"line\"><span class=\"comment\">/*Object  </span></span><br><span class=\"line\"><span class=\"comment\"> value: 10  </span></span><br><span class=\"line\"><span class=\"comment\"> done: false  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Object*/</span>  </span><br><span class=\"line\"><span class=\"comment\">/*Object  </span></span><br><span class=\"line\"><span class=\"comment\"> value: 20  </span></span><br><span class=\"line\"><span class=\"comment\"> done: false  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Object*/</span>  </span><br><span class=\"line\"><span class=\"comment\">/*Object  </span></span><br><span class=\"line\"><span class=\"comment\"> value: undefined  </span></span><br><span class=\"line\"><span class=\"comment\"> done: true  </span></span><br><span class=\"line\"><span class=\"comment\"> __proto__: Object*/</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>numberArray는 Array 오브젝트 인스턴스 구조입니다.<br>Symbol.iterator()를 호출할 수 있습니다.</p>\n</li>\n<li><p>numberArray[Symbol.iterator] ()는 numberArray 인스턴스의 Symbol.iterator()를 호출하는 것으로 이터레이터 오브젝트를 생성하여 반환합니다. 이터레이터 오브젝트를 사용하여 배열 엘리먼트를 하나씩 처리할 수 있습니다.</p>\n</li>\n<li><p>next()를 호출할 때마다 배열 엘리먼트 값을 {value: 10, done:false} 형태로 반환합니다.</p>\n</li>\n</ul>\n<h3 id=\"String-prototype-Symbol-iterator\"><a href=\"#String-prototype-Symbol-iterator\" class=\"headerlink\" title=\"String.prototype[Symbol.iterator]\"></a>String.prototype[Symbol.iterator]</h3><p>문자열 처리를 위한 이터레이터 오브젝트를 반환합니다.</p>\n<p>문자열을 문자 단위로 하나씩 처리할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>iterator-string</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> stringValue = <span class=\"string\">\"1A\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> stringValue) &#123;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> iterObj = stringValue[<span class=\"built_in\">Symbol</span>.iterator]();  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterObj.next());  </span><br><span class=\"line\"><span class=\"comment\">// 1  </span></span><br><span class=\"line\"><span class=\"comment\">// A  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"1\", done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: \"A\", done: false&#125;  </span></span><br><span class=\"line\"><span class=\"comment\">// Object &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>“1A”를 1과 A로 분리하여 for-of문을 실행합니다. 문자 단위로 반복할 수 있는 것은<br>String.prototype에 Symbol.iterator가 있기 때문입니다.<br>for-of문에서 stringValue를 String 오브젝트로 생성하고 그 안에 Symbol.iterator()를 사용합니다.</p>\n</li>\n<li><p>stringValue[Symbol.iterator] ();형태로 호출하면 이터레이터 오브젝트를 반환합니다.<br>이터레이터 오브젝트를 사용하여 문자열을 문자 단위로 하나씩 처리할 수 있습니다.</p>\n</li>\n<li><p>next()를 호출할 때마다 문자열의 문자를 value 프로퍼티에 설정하고 {value: “1”, done: false}형태로 반환합니다.</p>\n</li>\n</ul>\n<h3 id=\"Object-이터레이션\"><a href=\"#Object-이터레이션\" class=\"headerlink\" title=\"Object 이터레이션\"></a>Object 이터레이션</h3><p>Object 오브젝트에는 기본적으로 Symbol.iterator를 갖고 있지 않습니다. (for-of 등 반복처리불가.)</p>\n<p><mark>Object 오브젝트에 Symbol.iterator를 작성하면 반복 처리를 할 수 있습니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>iterator-Object</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> obj = &#123;  </span><br><span class=\"line\"> [<span class=\"built_in\">Symbol</span>.iterator]()&#123;  </span><br><span class=\"line\">    <span class=\"number\">2.</span> <span class=\"keyword\">return</span> &#123;  </span><br><span class=\"line\">        maxCount: <span class=\"number\">2</span>,  </span><br><span class=\"line\">        count: <span class=\"number\">0</span>,  </span><br><span class=\"line\">        next()&#123;   </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.count &lt; <span class=\"keyword\">this</span>.maxCount)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;<span class=\"attr\">value</span>: <span class=\"keyword\">this</span>.count++, <span class=\"attr\">done</span>: <span class=\"literal\">false</span>&#125;;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;<span class=\"attr\">value</span>: <span class=\"literal\">undefined</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span>&#125;;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> iteratorObj = obj[<span class=\"built_in\">Symbol</span>.iterator]();  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iteratorObj.next());</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Object 오브젝트를 반복처리 하기 위해서 [Symbol.iterator] ()를 obj prototype에 작성해줬습니다.</p>\n</li>\n<li><p>호출된 obj[Symbol.iterator] ()의 return으로 반환된 오브젝트를 iteratorObj에 할당합니다.</p>\n</li>\n<li><p>iteratorObj에 next()가 있으므로 iteratorObj.next() 형태로 호출할 수 있습니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Symbol_generator\">제너레이터</h2>\n\n<p>Object 오브젝트에 Symbol.iterator를 제너레이터 함수로 작성하면, 이터레이터로 반복할 때 마다 yield를 수행합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> obj[<span class=\"built_in\">Symbol</span>.iterator] = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">10</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">20</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">yield</span> <span class=\"number\">30</span>;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> result = [...obj];  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);  </span><br><span class=\"line\"><span class=\"comment\">//[10, 20, 30]</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>obj 오브젝트의 [Symbol.iterator]를 제너레이터 함수로 작성하였습니다.<br>이터레이터로 반복할 때 마다 yield 표현식을 평가하여 값을 반환합니다.</p>\n</li>\n<li><p>대괄호 [] 안에 spread 연산자로 obj 오브젝트를 작성했습니다. […obj]를 시작하면<br>엔진에서 obj에 [Symbol.iterator] 작성 여부를 체크합니다. 작성되있으므로<br>[Symbol.iterator] ()가 호출되며 이터레이터 오브젝트를 생성하여 반환합니다.<br>이터레이터가 반복될 때마다 yield에서 반환한 값을 배열에 첨부합니다.<br>반복이 끝나면 생성된 배열을 반환합니다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"Symbol_asyncIterator\">asyncIterator(): 비동기 반복</h2>\n\n<p>Symbol.asyncIterator는 오브젝트의 asyncIterator 기본 값을 지정합니다.<br>asyncIterator 프로퍼티가 오브젝트에 설정되면 await for of 루프(loop)에서 비동기 반복할 수 있습니다.</p>\n<p>오브젝트가 비동기 반복이 가능하려면 Symbol.asyncIterator 프로퍼티 키가 존재해야합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myAsyncIterable = &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">async</span>* [<span class=\"built_in\">Symbol</span>.asyncIterator]() &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"string\">\"hello\"</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"string\">\"async\"</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"string\">\"iteration!\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">(<span class=\"keyword\">async</span> () =&gt; &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> myAsyncIterable) &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);  </span><br><span class=\"line\">        <span class=\"comment\">// \"hello\"  </span></span><br><span class=\"line\">        <span class=\"comment\">// \"async\"  </span></span><br><span class=\"line\">        <span class=\"comment\">// \"iteration!\"  </span></span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>오브젝트의 [Symbol.asyncIterator] 속성을 설정해줌으로써 비동기 이터러블을 커스텀하여 정의할 수 있습니다.</li>\n</ul>\n<p><mark>현재 기본적으로 [Symbol.asyncIterator] 프로퍼티가 built-in 되어 있는 JavaScript 오브젝트는 없습니다.</mark></p>\n<p>하지만 WHATWG(Web Hypertext Application Technology Working Group, WHATWG)에서는<br>최근에 [Symbol.asyncIterator]가 스펙에 기준에 도달함으로써 비동기 반복이 가능한 첫 번째 built-in 오브젝트로 설정되었습니다.</p>\n<p><a href=\"https://ko.wikipedia.org/wiki/WHATWG\">WHATWG 위키</a><br><a href=\"https://whatwg.org/\">WHATWG 공식홈페이지</a></p>\n<hr>\n<h2 id=\"Symbol_match\">match(): match 결과 반환</h2>\n\n<p>String 오브젝트에서 정규 표현식을 사용할 수 있는 메서드<br>match(), replace(), search(), split() 에 대응하는</p>\n<p>Symbol 오브젝트 Symbol.match(), Symbol.replace(), Symbol.search(), Symbol.split()이 있습니다.</p>\n<ul>\n<li>String.prototype.match()가 호출되면 먼저 오브젝트에서 Symbol.match 작성 여부를 체크합니다.<br>작성돼있다면 오브젝트의 Symbol.match()를 호출합니다. String.prototype.match()는 호출되지 않습니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"Sports\"</span>.match(<span class=\"regexp\">/s/</span>));  </span><br><span class=\"line\"><span class=\"comment\">// 1: [0: \"5\", index: 5, input: \"Sports\"]  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MatchCheck</span> </span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">constructor</span>(base) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">this</span>.base = base;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"number\">2.</span> [<span class=\"built_in\">Symbol</span>.match](target) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.base.indexOf(target) &gt;= <span class=\"number\">0</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"keyword\">let</span> instMatch = <span class=\"keyword\">new</span> MatchCheck(<span class=\"string\">\"sports\"</span>);  </span><br><span class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"string\">\"po\"</span>.match(instMatch));  </span><br><span class=\"line\"><span class=\"comment\">// 2: true</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>“Sports”에 패턴/s/를 매치하면 매치 결과를 배열로 반환합니다. “Sports”가 문자열이므로<br>엔진이 String.prototype에 연결된 프로퍼티로 String 인스턴스를 생성합니다.<br>생성한 인스턴스에 “Sports”를 설정한 후 match()를 호출하면서 /s/를 파라미터로 넘겨줍니다.</p>\n</li>\n<li><p>Symbol.match()의 target 파라미터에 설정된 문자열이 this.base에 포함되어 있으면 true를 반환하고, 아니면 false를 반환합니다.</p>\n</li>\n<li><p>new MatchCheck(“sports”);를 실행하면 constructor가 호출되고 파라미터로 넘겨 준 “sports”가 this.base에 설정됩니다.</p>\n</li>\n<li><p>“po”.match(instMatch)가 호출되면 파라미터에 작성한 instMatch 인스턴스에서 Symbol.match의 작성 여부를 체크합니다. 존재하므로 Symbol.match(target)을 호출하면서 “po”를 파라미터 값으로 넘겨줍니다.<br>Symbol.match()에서 “sports” 와 “po”로 match를 행하며, “po”가 있으므로 true를 반환합니다.</p>\n</li>\n</ol>\n<h2 id=\"Symbol_matchAll\">matchAll()</h2>\n\n<p>Symbol.matchAll 은 String 오브젝트를 정규표현식으로 평가하여<br>반환결과를 이터레이터 오브젝트로 반환합니다.</p>\n<p>Symbol.matchAll은 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll\">String.prototype.matchAll()</a>메서드에 의해 호출 됩니다.</p>\n<p>+참고 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@matchAll\">RegExp.prototype[@@matchAll] ( )</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> re = <span class=\"regexp\">/[0-9]+/g</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'2016-01-02|2019-03-07'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result = re[<span class=\"built_in\">Symbol</span>.matchAll](str);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.from(result, x =&gt; x[<span class=\"number\">0</span>]));  </span><br><span class=\"line\"><span class=\"comment\">// expected output: Array [\"2016\", \"01\", \"02\", \"2019\", \"03\", \"07\"]</span></span><br></pre></td></tr></table></figure>"},{"title":"이벤트 -JavaScript","date":"2020-03-09T03:33:55.000Z","disqusId":"tunas-blog-1","_content":"\n* * *\n\n브라우저에서 유저가 취하는 모든 동작을 이벤트라 합니다.  \n이벤트가 발생했을 때 자바스크립트 실행문을 실행하는 것을  \n이벤트 핸들러라 합니다.\n\n<!-- more -->\n\n* * *\n\n### 마우스 이벤트\n\n*   onmouseover  \n    마우스가 지정한 요소에 올라갔을 때 발생합니다.\n    \n*   onmouseout  \n    마우스가 지정한 요소를 벗어났을 때 발생합니다.\n    \n*   onmousemove  \n    마우스가 지정한 요소 영역에서 움직일 때 발생합니다.\n    \n*   onclick  \n    마우스가 지정한 요소를 클릭했을 때 발생합니다.\n    \n*   ondbclick  \n    마우스가 지정한 요소를 더블 클릭 했을 때 발생합니다.\n    \n\n* * *\n\n### 키보드 이벤트\n\n*   onkeypress  \n    지정한 요소에서 키보드가 눌렸을 때 발생합니다.\n    \n*   onkeydown  \n    지정한 요소에서 키보드를 눌렀을 때 발생합니다.\n    \n*   onkeyup  \n    지정한 요소에서 키보드를 눌렀다 떼었을 때 발생합니다.\n    \n\n* * *\n\n### 기타 이벤트\n\n*   onfocus  \n    지정한 요소에 focus 되면 발생합니다.\n    \n*   onblur  \n    지정한 요소에 focus가 다른 요소로 이동되어 focus를 잃으면 발생합니다.\n    \n*   onchange  \n    지정한 요소에 value 속성값이 바뀌고 focus가 이동되었을 때 발생합니다.\n    \n*   onload  \n    지정한 요소의 하위 요소를 모두 로딩 했을 때 발생합니다.\n    \n*   onunload  \n    문서를 닫거나 다른 문서로 이동했을 때 발생합니다.\n    \n*   onsubmit  \n    폼 요소에 전송 버튼을 눌렀을 때 발생합니다.\n    \n*   onreset  \n    폼 요소에 취소 버튼을 눌렀을 때 발생합니다.\n    \n*   onresize  \n    지정된 요소의 크기가 변경되었을 때 발생합니다.\n    \n*   onerror  \n    문서 객체가 로드되는 동안 문제가 발생되었을 때 발생합니다.\n    \n\n더 많은 이벤트 정보:  \n[https://www.w3schools.com/jsref/dom_obj_event.asp](https://www.w3schools.com/jsref/dom_obj_event.asp)\n\n* * *\n\n지정한 요소에 이벤트를 적용하는 방법에는  \n요소에 직접 이벤트를 등록하는 방법과,  \nDOM을 이용하여 지정된 요소에 이벤트를 등록하는 방법이 있습니다.\n\n**직접 요소 이벤트 등록 방식**\n\nhtml 태그에 직접 등록합니다\n\n```html\n<button id= \"btn\" onclick=\"alert('Event')\">버튼</button>  \n```\n\n**DOM을 이용한 이벤트 등록 방식**\n\n스크립트 선언문 영역에 작성하여 등록합니다.\n\n```js\n<button id=\"btn\">버튼</button>  \n<script>  \n document.getElementByid(\"btn\").onclick=function(){  \n alert('Event');  \n }  \n</script>  \n```\n\n* * *\n\n### 키보드 접근성\n\n마우스 이벤트를 등록할 경우에는 마우스가 없어도\n\n접근(작동)할 수 있도록 해야 하는데,\n\n이것을 키보드 접근성 이라고 합니다.\n\n마우스 이벤트가 등록되었을 때는 반드시 키보드로 작동할 수 있게  \n대응 이벤트를 함께 작성해야 합니다.\n\n| 마우스 이벤트 | 키보드 대응 이벤트 |\n|---------------|--------------------|\n| onmouseover   | onfocus            |\n| onmouseout    | onblur             |\n\n\n```js 예시\n/* 마우스가 없을 경우 키보드 [tab]키를 사용해 이용할  \n 수 있도록 키보드 대응하는 이벤트 onfocus를 추가하였습니다.*/  \n var btn=document.getElementById(\"btn\");  \n btn.onmouseover=btn.onfocus=function(){ colorBg(); }  \n  \n/* 마우스가 없을 경우 키보드 [tab]키를 사용해 이용할  \n 수 있도록 키보드 대응하는 이벤트 onfocus를 추가하였습니다.*/  \n <button onmouseover=\"colorBg();\" onfocus=\"colorBg();\">  \n 버튼3</button>  \n```\n\n* * *\n\n### 한 요소에 이벤트 중복 등록\n\n잘못된 사례:\n\n```html\n<button id=”btn” onclick=”alert(‘실행문1’);” onclick=”alert(‘실행문2’)”;>버튼  \n//두번째 경고 창인 실행문2만 실행됩니다.\n\ndocument.getElementById(“btn”).onclick=function(){  \nalert(‘실행문1’); //실행 안됨  \n}  \ndocument.getElementById(“btn”).onclick=function(){  \nalert(‘실행문2’); // 실행 됨  \n}\n```\n\n* * *\n\n**한 요소에 중복으로 이벤트 등록 하는 방법**\n\n*   IE 8 이하 이외에 브라우저 (파이어폭스,크롬,사파리 등)\n\n**addEventListener**\n\n    document.getElementById(\"myBtn\").addEventListener(\"click\", myFunction);\n    document.getElementById(\"myBtn\").addEventListener(\"click\", someOtherFunction);\n\n기존 이벤트를 덮어 쓰지 않고  \n동일한 요소에 많은 이벤트를 추가 할 수 있습니다.\n\n이 예제는 동일한 < button> 요소에  \n두 개의 클릭 이벤트를 추가하는 방법을 보여줍니다.\n\n잘못된 예시 처럼 function에 alert 실행문 1,2 가 있더라도  \n경고문(실행문1)이 뜨고 난뒤 두번째 경고문 (실행문2)가 나타나게 합니다.\n\n*   IE 8 이하 브라우저에서는 **attachEvent**를 사용합니다.\n\n조건문을 이용하여 (크로스 브라우징 검사)  \n사용자 브라우저에 맞는 실행문을 나눠 사용 할수 있습니다.\n\n```js\nvar x = document.getElementById(\"myBtn\");  \nif (x.addEventListener) {  // IE8 이전버젼을 제외한 브라우저  \n x.addEventListener(\"click\", myFunction);  \n} else if (x.attachEvent) { // IE8 혹은 그 이전 버젼의 IE브라우저  \n x.attachEvent(\"onclick\", myFunction);  \n}  \n```","source":"_posts/이벤트 -JavaScript.md","raw":"---\ntitle: 이벤트 -JavaScript\ndate: 2020-03-09 12:33:55\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\n* * *\n\n브라우저에서 유저가 취하는 모든 동작을 이벤트라 합니다.  \n이벤트가 발생했을 때 자바스크립트 실행문을 실행하는 것을  \n이벤트 핸들러라 합니다.\n\n<!-- more -->\n\n* * *\n\n### 마우스 이벤트\n\n*   onmouseover  \n    마우스가 지정한 요소에 올라갔을 때 발생합니다.\n    \n*   onmouseout  \n    마우스가 지정한 요소를 벗어났을 때 발생합니다.\n    \n*   onmousemove  \n    마우스가 지정한 요소 영역에서 움직일 때 발생합니다.\n    \n*   onclick  \n    마우스가 지정한 요소를 클릭했을 때 발생합니다.\n    \n*   ondbclick  \n    마우스가 지정한 요소를 더블 클릭 했을 때 발생합니다.\n    \n\n* * *\n\n### 키보드 이벤트\n\n*   onkeypress  \n    지정한 요소에서 키보드가 눌렸을 때 발생합니다.\n    \n*   onkeydown  \n    지정한 요소에서 키보드를 눌렀을 때 발생합니다.\n    \n*   onkeyup  \n    지정한 요소에서 키보드를 눌렀다 떼었을 때 발생합니다.\n    \n\n* * *\n\n### 기타 이벤트\n\n*   onfocus  \n    지정한 요소에 focus 되면 발생합니다.\n    \n*   onblur  \n    지정한 요소에 focus가 다른 요소로 이동되어 focus를 잃으면 발생합니다.\n    \n*   onchange  \n    지정한 요소에 value 속성값이 바뀌고 focus가 이동되었을 때 발생합니다.\n    \n*   onload  \n    지정한 요소의 하위 요소를 모두 로딩 했을 때 발생합니다.\n    \n*   onunload  \n    문서를 닫거나 다른 문서로 이동했을 때 발생합니다.\n    \n*   onsubmit  \n    폼 요소에 전송 버튼을 눌렀을 때 발생합니다.\n    \n*   onreset  \n    폼 요소에 취소 버튼을 눌렀을 때 발생합니다.\n    \n*   onresize  \n    지정된 요소의 크기가 변경되었을 때 발생합니다.\n    \n*   onerror  \n    문서 객체가 로드되는 동안 문제가 발생되었을 때 발생합니다.\n    \n\n더 많은 이벤트 정보:  \n[https://www.w3schools.com/jsref/dom_obj_event.asp](https://www.w3schools.com/jsref/dom_obj_event.asp)\n\n* * *\n\n지정한 요소에 이벤트를 적용하는 방법에는  \n요소에 직접 이벤트를 등록하는 방법과,  \nDOM을 이용하여 지정된 요소에 이벤트를 등록하는 방법이 있습니다.\n\n**직접 요소 이벤트 등록 방식**\n\nhtml 태그에 직접 등록합니다\n\n```html\n<button id= \"btn\" onclick=\"alert('Event')\">버튼</button>  \n```\n\n**DOM을 이용한 이벤트 등록 방식**\n\n스크립트 선언문 영역에 작성하여 등록합니다.\n\n```js\n<button id=\"btn\">버튼</button>  \n<script>  \n document.getElementByid(\"btn\").onclick=function(){  \n alert('Event');  \n }  \n</script>  \n```\n\n* * *\n\n### 키보드 접근성\n\n마우스 이벤트를 등록할 경우에는 마우스가 없어도\n\n접근(작동)할 수 있도록 해야 하는데,\n\n이것을 키보드 접근성 이라고 합니다.\n\n마우스 이벤트가 등록되었을 때는 반드시 키보드로 작동할 수 있게  \n대응 이벤트를 함께 작성해야 합니다.\n\n| 마우스 이벤트 | 키보드 대응 이벤트 |\n|---------------|--------------------|\n| onmouseover   | onfocus            |\n| onmouseout    | onblur             |\n\n\n```js 예시\n/* 마우스가 없을 경우 키보드 [tab]키를 사용해 이용할  \n 수 있도록 키보드 대응하는 이벤트 onfocus를 추가하였습니다.*/  \n var btn=document.getElementById(\"btn\");  \n btn.onmouseover=btn.onfocus=function(){ colorBg(); }  \n  \n/* 마우스가 없을 경우 키보드 [tab]키를 사용해 이용할  \n 수 있도록 키보드 대응하는 이벤트 onfocus를 추가하였습니다.*/  \n <button onmouseover=\"colorBg();\" onfocus=\"colorBg();\">  \n 버튼3</button>  \n```\n\n* * *\n\n### 한 요소에 이벤트 중복 등록\n\n잘못된 사례:\n\n```html\n<button id=”btn” onclick=”alert(‘실행문1’);” onclick=”alert(‘실행문2’)”;>버튼  \n//두번째 경고 창인 실행문2만 실행됩니다.\n\ndocument.getElementById(“btn”).onclick=function(){  \nalert(‘실행문1’); //실행 안됨  \n}  \ndocument.getElementById(“btn”).onclick=function(){  \nalert(‘실행문2’); // 실행 됨  \n}\n```\n\n* * *\n\n**한 요소에 중복으로 이벤트 등록 하는 방법**\n\n*   IE 8 이하 이외에 브라우저 (파이어폭스,크롬,사파리 등)\n\n**addEventListener**\n\n    document.getElementById(\"myBtn\").addEventListener(\"click\", myFunction);\n    document.getElementById(\"myBtn\").addEventListener(\"click\", someOtherFunction);\n\n기존 이벤트를 덮어 쓰지 않고  \n동일한 요소에 많은 이벤트를 추가 할 수 있습니다.\n\n이 예제는 동일한 < button> 요소에  \n두 개의 클릭 이벤트를 추가하는 방법을 보여줍니다.\n\n잘못된 예시 처럼 function에 alert 실행문 1,2 가 있더라도  \n경고문(실행문1)이 뜨고 난뒤 두번째 경고문 (실행문2)가 나타나게 합니다.\n\n*   IE 8 이하 브라우저에서는 **attachEvent**를 사용합니다.\n\n조건문을 이용하여 (크로스 브라우징 검사)  \n사용자 브라우저에 맞는 실행문을 나눠 사용 할수 있습니다.\n\n```js\nvar x = document.getElementById(\"myBtn\");  \nif (x.addEventListener) {  // IE8 이전버젼을 제외한 브라우저  \n x.addEventListener(\"click\", myFunction);  \n} else if (x.attachEvent) { // IE8 혹은 그 이전 버젼의 IE브라우저  \n x.attachEvent(\"onclick\", myFunction);  \n}  \n```","slug":"이벤트 -JavaScript","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrtg003fqgvq35oofyh0","content":"<hr>\n<p>브라우저에서 유저가 취하는 모든 동작을 이벤트라 합니다.<br>이벤트가 발생했을 때 자바스크립트 실행문을 실행하는 것을<br>이벤트 핸들러라 합니다.</p>\n<a id=\"more\"></a>\n\n<hr>\n<h3 id=\"마우스-이벤트\"><a href=\"#마우스-이벤트\" class=\"headerlink\" title=\"마우스 이벤트\"></a>마우스 이벤트</h3><ul>\n<li><p>onmouseover<br>마우스가 지정한 요소에 올라갔을 때 발생합니다.</p>\n</li>\n<li><p>onmouseout<br>마우스가 지정한 요소를 벗어났을 때 발생합니다.</p>\n</li>\n<li><p>onmousemove<br>마우스가 지정한 요소 영역에서 움직일 때 발생합니다.</p>\n</li>\n<li><p>onclick<br>마우스가 지정한 요소를 클릭했을 때 발생합니다.</p>\n</li>\n<li><p>ondbclick<br>마우스가 지정한 요소를 더블 클릭 했을 때 발생합니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"키보드-이벤트\"><a href=\"#키보드-이벤트\" class=\"headerlink\" title=\"키보드 이벤트\"></a>키보드 이벤트</h3><ul>\n<li><p>onkeypress<br>지정한 요소에서 키보드가 눌렸을 때 발생합니다.</p>\n</li>\n<li><p>onkeydown<br>지정한 요소에서 키보드를 눌렀을 때 발생합니다.</p>\n</li>\n<li><p>onkeyup<br>지정한 요소에서 키보드를 눌렀다 떼었을 때 발생합니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"기타-이벤트\"><a href=\"#기타-이벤트\" class=\"headerlink\" title=\"기타 이벤트\"></a>기타 이벤트</h3><ul>\n<li><p>onfocus<br>지정한 요소에 focus 되면 발생합니다.</p>\n</li>\n<li><p>onblur<br>지정한 요소에 focus가 다른 요소로 이동되어 focus를 잃으면 발생합니다.</p>\n</li>\n<li><p>onchange<br>지정한 요소에 value 속성값이 바뀌고 focus가 이동되었을 때 발생합니다.</p>\n</li>\n<li><p>onload<br>지정한 요소의 하위 요소를 모두 로딩 했을 때 발생합니다.</p>\n</li>\n<li><p>onunload<br>문서를 닫거나 다른 문서로 이동했을 때 발생합니다.</p>\n</li>\n<li><p>onsubmit<br>폼 요소에 전송 버튼을 눌렀을 때 발생합니다.</p>\n</li>\n<li><p>onreset<br>폼 요소에 취소 버튼을 눌렀을 때 발생합니다.</p>\n</li>\n<li><p>onresize<br>지정된 요소의 크기가 변경되었을 때 발생합니다.</p>\n</li>\n<li><p>onerror<br>문서 객체가 로드되는 동안 문제가 발생되었을 때 발생합니다.</p>\n</li>\n</ul>\n<p>더 많은 이벤트 정보:<br><a href=\"https://www.w3schools.com/jsref/dom_obj_event.asp\">https://www.w3schools.com/jsref/dom_obj_event.asp</a></p>\n<hr>\n<p>지정한 요소에 이벤트를 적용하는 방법에는<br>요소에 직접 이벤트를 등록하는 방법과,<br>DOM을 이용하여 지정된 요소에 이벤트를 등록하는 방법이 있습니다.</p>\n<p><strong>직접 요소 이벤트 등록 방식</strong></p>\n<p>html 태그에 직접 등록합니다</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>= <span class=\"string\">\"btn\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"alert('Event')\"</span>&gt;</span>버튼<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>DOM을 이용한 이벤트 등록 방식</strong></p>\n<p>스크립트 선언문 영역에 작성하여 등록합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button id=<span class=\"string\">\"btn\"</span>&gt;버튼&lt;<span class=\"regexp\">/button&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\"> document.getElementByid(\"btn\").onclick=function()&#123;  </span></span><br><span class=\"line\"><span class=\"regexp\"> alert('Event');  </span></span><br><span class=\"line\"><span class=\"regexp\"> &#125;  </span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"키보드-접근성\"><a href=\"#키보드-접근성\" class=\"headerlink\" title=\"키보드 접근성\"></a>키보드 접근성</h3><p>마우스 이벤트를 등록할 경우에는 마우스가 없어도</p>\n<p>접근(작동)할 수 있도록 해야 하는데,</p>\n<p>이것을 키보드 접근성 이라고 합니다.</p>\n<p>마우스 이벤트가 등록되었을 때는 반드시 키보드로 작동할 수 있게<br>대응 이벤트를 함께 작성해야 합니다.</p>\n<table>\n<thead>\n<tr>\n<th>마우스 이벤트</th>\n<th>키보드 대응 이벤트</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onmouseover</td>\n<td>onfocus</td>\n</tr>\n<tr>\n<td>onmouseout</td>\n<td>onblur</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight js\"><figcaption><span>예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 마우스가 없을 경우 키보드 [tab]키를 사용해 이용할  </span></span><br><span class=\"line\"><span class=\"comment\"> 수 있도록 키보드 대응하는 이벤트 onfocus를 추가하였습니다.*/</span>  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> btn=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"btn\"</span>);  </span><br><span class=\"line\"> btn.onmouseover=btn.onfocus=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; colorBg(); &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/* 마우스가 없을 경우 키보드 [tab]키를 사용해 이용할  </span></span><br><span class=\"line\"><span class=\"comment\"> 수 있도록 키보드 대응하는 이벤트 onfocus를 추가하였습니다.*/</span>  </span><br><span class=\"line\"> &lt;button onmouseover=<span class=\"string\">\"colorBg();\"</span> onfocus=<span class=\"string\">\"colorBg();\"</span>&gt;  </span><br><span class=\"line\"> 버튼<span class=\"number\">3</span>&lt;<span class=\"regexp\">/button&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"한-요소에-이벤트-중복-등록\"><a href=\"#한-요소에-이벤트-중복-등록\" class=\"headerlink\" title=\"한 요소에 이벤트 중복 등록\"></a>한 요소에 이벤트 중복 등록</h3><p>잘못된 사례:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">”btn”</span> <span class=\"attr\">onclick</span>=<span class=\"string\">”alert(‘실행문1’);”</span> <span class=\"attr\">onclick</span>=<span class=\"string\">”alert(‘실행문2’)”;</span>&gt;</span>버튼  </span><br><span class=\"line\">//두번째 경고 창인 실행문2만 실행됩니다.</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById(“btn”).onclick=function()&#123;  </span><br><span class=\"line\">alert(‘실행문1’); //실행 안됨  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">document.getElementById(“btn”).onclick=function()&#123;  </span><br><span class=\"line\">alert(‘실행문2’); // 실행 됨  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>한 요소에 중복으로 이벤트 등록 하는 방법</strong></p>\n<ul>\n<li>IE 8 이하 이외에 브라우저 (파이어폭스,크롬,사파리 등)</li>\n</ul>\n<p><strong>addEventListener</strong></p>\n<pre><code>document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, myFunction);\ndocument.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, someOtherFunction);</code></pre><p>기존 이벤트를 덮어 쓰지 않고<br>동일한 요소에 많은 이벤트를 추가 할 수 있습니다.</p>\n<p>이 예제는 동일한 &lt; button&gt; 요소에<br>두 개의 클릭 이벤트를 추가하는 방법을 보여줍니다.</p>\n<p>잘못된 예시 처럼 function에 alert 실행문 1,2 가 있더라도<br>경고문(실행문1)이 뜨고 난뒤 두번째 경고문 (실행문2)가 나타나게 합니다.</p>\n<ul>\n<li>IE 8 이하 브라우저에서는 <strong>attachEvent</strong>를 사용합니다.</li>\n</ul>\n<p>조건문을 이용하여 (크로스 브라우징 검사)<br>사용자 브라우저에 맞는 실행문을 나눠 사용 할수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">if</span> (x.addEventListener) &#123;  <span class=\"comment\">// IE8 이전버젼을 제외한 브라우저  </span></span><br><span class=\"line\"> x.addEventListener(<span class=\"string\">\"click\"</span>, myFunction);  </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x.attachEvent) &#123; <span class=\"comment\">// IE8 혹은 그 이전 버젼의 IE브라우저  </span></span><br><span class=\"line\"> x.attachEvent(<span class=\"string\">\"onclick\"</span>, myFunction);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<hr>\n<p>브라우저에서 유저가 취하는 모든 동작을 이벤트라 합니다.<br>이벤트가 발생했을 때 자바스크립트 실행문을 실행하는 것을<br>이벤트 핸들러라 합니다.</p>","more":"<hr>\n<h3 id=\"마우스-이벤트\"><a href=\"#마우스-이벤트\" class=\"headerlink\" title=\"마우스 이벤트\"></a>마우스 이벤트</h3><ul>\n<li><p>onmouseover<br>마우스가 지정한 요소에 올라갔을 때 발생합니다.</p>\n</li>\n<li><p>onmouseout<br>마우스가 지정한 요소를 벗어났을 때 발생합니다.</p>\n</li>\n<li><p>onmousemove<br>마우스가 지정한 요소 영역에서 움직일 때 발생합니다.</p>\n</li>\n<li><p>onclick<br>마우스가 지정한 요소를 클릭했을 때 발생합니다.</p>\n</li>\n<li><p>ondbclick<br>마우스가 지정한 요소를 더블 클릭 했을 때 발생합니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"키보드-이벤트\"><a href=\"#키보드-이벤트\" class=\"headerlink\" title=\"키보드 이벤트\"></a>키보드 이벤트</h3><ul>\n<li><p>onkeypress<br>지정한 요소에서 키보드가 눌렸을 때 발생합니다.</p>\n</li>\n<li><p>onkeydown<br>지정한 요소에서 키보드를 눌렀을 때 발생합니다.</p>\n</li>\n<li><p>onkeyup<br>지정한 요소에서 키보드를 눌렀다 떼었을 때 발생합니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"기타-이벤트\"><a href=\"#기타-이벤트\" class=\"headerlink\" title=\"기타 이벤트\"></a>기타 이벤트</h3><ul>\n<li><p>onfocus<br>지정한 요소에 focus 되면 발생합니다.</p>\n</li>\n<li><p>onblur<br>지정한 요소에 focus가 다른 요소로 이동되어 focus를 잃으면 발생합니다.</p>\n</li>\n<li><p>onchange<br>지정한 요소에 value 속성값이 바뀌고 focus가 이동되었을 때 발생합니다.</p>\n</li>\n<li><p>onload<br>지정한 요소의 하위 요소를 모두 로딩 했을 때 발생합니다.</p>\n</li>\n<li><p>onunload<br>문서를 닫거나 다른 문서로 이동했을 때 발생합니다.</p>\n</li>\n<li><p>onsubmit<br>폼 요소에 전송 버튼을 눌렀을 때 발생합니다.</p>\n</li>\n<li><p>onreset<br>폼 요소에 취소 버튼을 눌렀을 때 발생합니다.</p>\n</li>\n<li><p>onresize<br>지정된 요소의 크기가 변경되었을 때 발생합니다.</p>\n</li>\n<li><p>onerror<br>문서 객체가 로드되는 동안 문제가 발생되었을 때 발생합니다.</p>\n</li>\n</ul>\n<p>더 많은 이벤트 정보:<br><a href=\"https://www.w3schools.com/jsref/dom_obj_event.asp\">https://www.w3schools.com/jsref/dom_obj_event.asp</a></p>\n<hr>\n<p>지정한 요소에 이벤트를 적용하는 방법에는<br>요소에 직접 이벤트를 등록하는 방법과,<br>DOM을 이용하여 지정된 요소에 이벤트를 등록하는 방법이 있습니다.</p>\n<p><strong>직접 요소 이벤트 등록 방식</strong></p>\n<p>html 태그에 직접 등록합니다</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>= <span class=\"string\">\"btn\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"alert('Event')\"</span>&gt;</span>버튼<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>DOM을 이용한 이벤트 등록 방식</strong></p>\n<p>스크립트 선언문 영역에 작성하여 등록합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button id=<span class=\"string\">\"btn\"</span>&gt;버튼&lt;<span class=\"regexp\">/button&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script&gt;  </span></span><br><span class=\"line\"><span class=\"regexp\"> document.getElementByid(\"btn\").onclick=function()&#123;  </span></span><br><span class=\"line\"><span class=\"regexp\"> alert('Event');  </span></span><br><span class=\"line\"><span class=\"regexp\"> &#125;  </span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"키보드-접근성\"><a href=\"#키보드-접근성\" class=\"headerlink\" title=\"키보드 접근성\"></a>키보드 접근성</h3><p>마우스 이벤트를 등록할 경우에는 마우스가 없어도</p>\n<p>접근(작동)할 수 있도록 해야 하는데,</p>\n<p>이것을 키보드 접근성 이라고 합니다.</p>\n<p>마우스 이벤트가 등록되었을 때는 반드시 키보드로 작동할 수 있게<br>대응 이벤트를 함께 작성해야 합니다.</p>\n<table>\n<thead>\n<tr>\n<th>마우스 이벤트</th>\n<th>키보드 대응 이벤트</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onmouseover</td>\n<td>onfocus</td>\n</tr>\n<tr>\n<td>onmouseout</td>\n<td>onblur</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight js\"><figcaption><span>예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 마우스가 없을 경우 키보드 [tab]키를 사용해 이용할  </span></span><br><span class=\"line\"><span class=\"comment\"> 수 있도록 키보드 대응하는 이벤트 onfocus를 추가하였습니다.*/</span>  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> btn=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"btn\"</span>);  </span><br><span class=\"line\"> btn.onmouseover=btn.onfocus=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; colorBg(); &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/* 마우스가 없을 경우 키보드 [tab]키를 사용해 이용할  </span></span><br><span class=\"line\"><span class=\"comment\"> 수 있도록 키보드 대응하는 이벤트 onfocus를 추가하였습니다.*/</span>  </span><br><span class=\"line\"> &lt;button onmouseover=<span class=\"string\">\"colorBg();\"</span> onfocus=<span class=\"string\">\"colorBg();\"</span>&gt;  </span><br><span class=\"line\"> 버튼<span class=\"number\">3</span>&lt;<span class=\"regexp\">/button&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"한-요소에-이벤트-중복-등록\"><a href=\"#한-요소에-이벤트-중복-등록\" class=\"headerlink\" title=\"한 요소에 이벤트 중복 등록\"></a>한 요소에 이벤트 중복 등록</h3><p>잘못된 사례:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">”btn”</span> <span class=\"attr\">onclick</span>=<span class=\"string\">”alert(‘실행문1’);”</span> <span class=\"attr\">onclick</span>=<span class=\"string\">”alert(‘실행문2’)”;</span>&gt;</span>버튼  </span><br><span class=\"line\">//두번째 경고 창인 실행문2만 실행됩니다.</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById(“btn”).onclick=function()&#123;  </span><br><span class=\"line\">alert(‘실행문1’); //실행 안됨  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">document.getElementById(“btn”).onclick=function()&#123;  </span><br><span class=\"line\">alert(‘실행문2’); // 실행 됨  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>한 요소에 중복으로 이벤트 등록 하는 방법</strong></p>\n<ul>\n<li>IE 8 이하 이외에 브라우저 (파이어폭스,크롬,사파리 등)</li>\n</ul>\n<p><strong>addEventListener</strong></p>\n<pre><code>document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, myFunction);\ndocument.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, someOtherFunction);</code></pre><p>기존 이벤트를 덮어 쓰지 않고<br>동일한 요소에 많은 이벤트를 추가 할 수 있습니다.</p>\n<p>이 예제는 동일한 &lt; button&gt; 요소에<br>두 개의 클릭 이벤트를 추가하는 방법을 보여줍니다.</p>\n<p>잘못된 예시 처럼 function에 alert 실행문 1,2 가 있더라도<br>경고문(실행문1)이 뜨고 난뒤 두번째 경고문 (실행문2)가 나타나게 합니다.</p>\n<ul>\n<li>IE 8 이하 브라우저에서는 <strong>attachEvent</strong>를 사용합니다.</li>\n</ul>\n<p>조건문을 이용하여 (크로스 브라우징 검사)<br>사용자 브라우저에 맞는 실행문을 나눠 사용 할수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">if</span> (x.addEventListener) &#123;  <span class=\"comment\">// IE8 이전버젼을 제외한 브라우저  </span></span><br><span class=\"line\"> x.addEventListener(<span class=\"string\">\"click\"</span>, myFunction);  </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x.attachEvent) &#123; <span class=\"comment\">// IE8 혹은 그 이전 버젼의 IE브라우저  </span></span><br><span class=\"line\"> x.attachEvent(<span class=\"string\">\"onclick\"</span>, myFunction);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"자바스크립트 기초 문법","date":"2020-02-23T06:00:00.000Z","disqusId":"tunas-blog-1","_content":"\n\n### 1. 자바스크립트 선언문\n\n----------\n\n#### 1. type 속성\n\n\n```js\n<script type=\"text/javascript\">  \n</script>\n```\n\n\n옛날 표준인 HTML4 에는  \ntype=”text/javascript”라는 속성이 필요했습니다.  \nHTML5부터는 사용하지 않아도 됩니다.\n\nHTML5 에선 불필요한 MIME 유형을 제공하기보다는 속성을 생략할 것을 권장합니다.\n\n<!-- more -->\n\n-------------------\n\n#### 2. language 속성\n\n```js\n<script language=\"javascript\">  \n</script>  \n```\n\n스크립트 언어를 표시하기위한 속성.  \n이속성은 표준화되지 않았습니다.\n\n* * *\n\n#### 3. 생략\n\n```js\n<script>  \n</script>  \n```\n\nhtml5 부터는 디폴트로 script 는 js로 쓰기때문에  \ntype값을 생략한 script 로만 사용하셔도 무방합니다.\n\n* * *\n\n#### 4. 외부에서 불러오기\n\n```js\n<script src=\"소스경로\"></script>  \n```\n\n* * *\n\n### 2. 자바스크립트 선언문은 HTML문서 어디에 작성하나요?\n\n자바스크립트는 < head>태그 영역 또는 < body>태그 영역에 선언하면 됩니다.\n\nHTML의 < head> 섹션이 아니라 < /body> 태그 바로 앞에 두는 것이 가장 좋습니다.\n\n그 이유는 **HTML이 웹에서 로딩되는 순서가 위에서 아래로 로드되기 때문입니다.**  \nhead를 먼저 로드 한 다음 body를 로드합니다.  \nJavaScript을 헤드 영역에 넣으면 HTML을 로드하기 전에  \n전체 JavaScript 파일이 로드되므로 몇 가지 문제가 발생할 수 있습니다.\n\n#### 1. HTML을 변경하는 코드가 JavaScript에있는 경우\n\n실제로 영향을 줄 수있는 HTML 요소가 없으므로 JavaScript 코드가 작동하지 않는 것처럼 보입니다. 오류가 발생할 수 있습니다.\n\n#### 2. JavaScript가 많은 경우\n\nHTML을 로드하기 전에 모든 JavaScript를 로드하기 때문에 페이지 로딩이 눈에 띄게 느려질 수 있습니다.\n\n자바 스크립트 링크를 HTML </ body>태그 앞에 배치하면  \n자바 스크립트가 로드되기 전에 HTML을 로드 할수 있게 하여 오류를 방지하고  \n**웹 사이트 응답 시간을 단축 할 수 있습니다.**\n\n* * *\n\n### 3. 자바스크립트 주석 처리\n\n```js\n//한 줄 설명글인 경우  \n  \n/*  \n 설명글이 여러줄 인 경우  \n    \n 설명글이 여러줄 인 경우  \n*/  \n```\n\n* * *\n\n### 4. 자바스크립트 코드 입력시 주의할 점\n\n* * *\n\n#### 1. 자바스크립트는 대·소문자를 가려서 씁니다.\n\n    날짜 객체 생성:New date(); (X)\n    날짜 객체 생성:New Date(); (O)\n\n\n#### 2. 실행문을 작성할 때는 한줄에 한 문장만 작성하는 것이 가독성을 위해 좋습니다.\n\n\n#### 3. 문자형 데이터를 작성할 때는 큰 따옴표(“”)와 작은따옴표(‘’)을 주의\n\n```js\n\"\"겹침 오류  \ndocument.write(\"문자형 데이터 \"작성시 따옴표 겹침을\" 주의 합니다.\") (X)  \n  \ndocument.write('문자형 데이터 \"작성시 따옴표 겹침을\" 주의 합니다.') (O)  \ndocument.write(\"문자형 데이터 \"작성시 따옴표 겹침을\" 주의 합니다.\") (O)  \n```\n\n* * *\n\n### 5. 자바스크립트 data types\n\n```js\n1. String (문자형 데이터 타입)  \n    \n const what = \"JS Study\"  \n  \n2. Boolean (논리형 데이터 타입 true or false)  \n    \n const what = true;  \n  \n3. Number (숫자형 데이터 타입)  \n  \n const what = 123;  \n  \n4. Float (소숫점 데이터 타입)  \n  \n const what = 123.4;  \n  \n5. Null (값이 없는 = 데이터를 비우고자 할때 사용)  \n  \n const what = null;  \n  \n6. Undefined (값이 없는 = 지정 되지않음)  \n  \n const what;  \n```\n\n* * *\n\n### 6. 자바스크립트 변수 선언\n\n* * *\n\n#### 1. ES6 이전 - var\n\nES6 이전 사용하던 변수 선언 방식으로  \n변수 선언 방식에 있어서 큰 단점을 가지고있어  \nES6 이후 잘 사용되지 않는다.\n\n```js\nvar name = \"first\";  \nconsole.log(name); // first  \n  \nvar name = \"second\";  \nconsole.log(name); // second  \n```\n\n이런식으로 변수를 한 번 더 선언하게 되는 실수를 하는 경우  \n에러가 나오지 않고 각기 다른 값이 출력 된다.  \n이는 어디에서 어떻게 사용 될지도 파악하기 힘들뿐더러 값이 바뀔 우려가 있다.\n\n* * *\n\n#### 2. ES6 이후, 이를 보완하기 위해 추가 된 변수 선언 방식 let 과 const\n\n```js\nlet name = \"first\";  \nconsole.log(name); // first  \n \nlet name = \"second\";  \nconsole.log(name);   \n// Uncaught SyntaxError: Identifier 'name' has already been declared  \n```\n\nname이 이미 선언 되었다는 에러 메세지가 나온다.  \nconst를 사용해도 마찬가지로 변수 재선언이 되지 않는다.\n\n* * *\n\n##### [](#let은-변수에-재할당이-가능 \"let은 변수에 재할당이 가능\")let은 변수에 재할당이 가능\n\n```js\nlet name = \"first\";  \nconsole.log(name); // first  \n  \nlet name = \"second\";  \nconsole.log(name);  \n// Uncaught SyntaxError: Identifier 'name' has already been declared  \n  \nname = \"third\";  \nconsol.log(name); // third  \n```\n\n* * *\n\n##### const는 변수 재선언, 변수 재할당 모두 불가능 (상수)\n \n```js\nconst name = \"first\";  \nconsole.log(name) // first;  \n  \nconst name = \"second\";  \nconsole.log(name);  \n// Uncaught SyntaxError: Identifier 'name' has already been declared  \n  \nname = \"third\";  \nconsol.log(name);  \n//Uncaught TypeError: Assignment to constant variable.  \n```\n\n* * *\n\n*   참고:  \n    [https://www.daleseo.com/js-var-issues/](https://www.daleseo.com/js-var-issues/)  \n    [https://www.daleseo.com/js-es2015-let/](https://www.daleseo.com/js-es2015-let/)  \n    [https://gist.github.com/LeoHeo/7c2a2a6dbcf80becaaa1e61e90091e5d](https://gist.github.com/LeoHeo/7c2a2a6dbcf80becaaa1e61e90091e5d)\n    \n    [https://happycording.tistory.com/entry/let-const-%EB%9E%80-%EC%99%9C-%EC%8D%A8%EC%95%BC%EB%A7%8C-%ED%95%98%EB%8A%94%EA%B0%80-ES6](https://happycording.tistory.com/entry/let-const-%EB%9E%80-%EC%99%9C-%EC%8D%A8%EC%95%BC%EB%A7%8C-%ED%95%98%EB%8A%94%EA%B0%80-ES6)\n    \n\n","source":"_posts/자바스크립트 기초 문법.md","raw":"---\ntitle: 자바스크립트 기초 문법\ndate: 2020-02-23 15:00:00\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\n\n### 1. 자바스크립트 선언문\n\n----------\n\n#### 1. type 속성\n\n\n```js\n<script type=\"text/javascript\">  \n</script>\n```\n\n\n옛날 표준인 HTML4 에는  \ntype=”text/javascript”라는 속성이 필요했습니다.  \nHTML5부터는 사용하지 않아도 됩니다.\n\nHTML5 에선 불필요한 MIME 유형을 제공하기보다는 속성을 생략할 것을 권장합니다.\n\n<!-- more -->\n\n-------------------\n\n#### 2. language 속성\n\n```js\n<script language=\"javascript\">  \n</script>  \n```\n\n스크립트 언어를 표시하기위한 속성.  \n이속성은 표준화되지 않았습니다.\n\n* * *\n\n#### 3. 생략\n\n```js\n<script>  \n</script>  \n```\n\nhtml5 부터는 디폴트로 script 는 js로 쓰기때문에  \ntype값을 생략한 script 로만 사용하셔도 무방합니다.\n\n* * *\n\n#### 4. 외부에서 불러오기\n\n```js\n<script src=\"소스경로\"></script>  \n```\n\n* * *\n\n### 2. 자바스크립트 선언문은 HTML문서 어디에 작성하나요?\n\n자바스크립트는 < head>태그 영역 또는 < body>태그 영역에 선언하면 됩니다.\n\nHTML의 < head> 섹션이 아니라 < /body> 태그 바로 앞에 두는 것이 가장 좋습니다.\n\n그 이유는 **HTML이 웹에서 로딩되는 순서가 위에서 아래로 로드되기 때문입니다.**  \nhead를 먼저 로드 한 다음 body를 로드합니다.  \nJavaScript을 헤드 영역에 넣으면 HTML을 로드하기 전에  \n전체 JavaScript 파일이 로드되므로 몇 가지 문제가 발생할 수 있습니다.\n\n#### 1. HTML을 변경하는 코드가 JavaScript에있는 경우\n\n실제로 영향을 줄 수있는 HTML 요소가 없으므로 JavaScript 코드가 작동하지 않는 것처럼 보입니다. 오류가 발생할 수 있습니다.\n\n#### 2. JavaScript가 많은 경우\n\nHTML을 로드하기 전에 모든 JavaScript를 로드하기 때문에 페이지 로딩이 눈에 띄게 느려질 수 있습니다.\n\n자바 스크립트 링크를 HTML </ body>태그 앞에 배치하면  \n자바 스크립트가 로드되기 전에 HTML을 로드 할수 있게 하여 오류를 방지하고  \n**웹 사이트 응답 시간을 단축 할 수 있습니다.**\n\n* * *\n\n### 3. 자바스크립트 주석 처리\n\n```js\n//한 줄 설명글인 경우  \n  \n/*  \n 설명글이 여러줄 인 경우  \n    \n 설명글이 여러줄 인 경우  \n*/  \n```\n\n* * *\n\n### 4. 자바스크립트 코드 입력시 주의할 점\n\n* * *\n\n#### 1. 자바스크립트는 대·소문자를 가려서 씁니다.\n\n    날짜 객체 생성:New date(); (X)\n    날짜 객체 생성:New Date(); (O)\n\n\n#### 2. 실행문을 작성할 때는 한줄에 한 문장만 작성하는 것이 가독성을 위해 좋습니다.\n\n\n#### 3. 문자형 데이터를 작성할 때는 큰 따옴표(“”)와 작은따옴표(‘’)을 주의\n\n```js\n\"\"겹침 오류  \ndocument.write(\"문자형 데이터 \"작성시 따옴표 겹침을\" 주의 합니다.\") (X)  \n  \ndocument.write('문자형 데이터 \"작성시 따옴표 겹침을\" 주의 합니다.') (O)  \ndocument.write(\"문자형 데이터 \"작성시 따옴표 겹침을\" 주의 합니다.\") (O)  \n```\n\n* * *\n\n### 5. 자바스크립트 data types\n\n```js\n1. String (문자형 데이터 타입)  \n    \n const what = \"JS Study\"  \n  \n2. Boolean (논리형 데이터 타입 true or false)  \n    \n const what = true;  \n  \n3. Number (숫자형 데이터 타입)  \n  \n const what = 123;  \n  \n4. Float (소숫점 데이터 타입)  \n  \n const what = 123.4;  \n  \n5. Null (값이 없는 = 데이터를 비우고자 할때 사용)  \n  \n const what = null;  \n  \n6. Undefined (값이 없는 = 지정 되지않음)  \n  \n const what;  \n```\n\n* * *\n\n### 6. 자바스크립트 변수 선언\n\n* * *\n\n#### 1. ES6 이전 - var\n\nES6 이전 사용하던 변수 선언 방식으로  \n변수 선언 방식에 있어서 큰 단점을 가지고있어  \nES6 이후 잘 사용되지 않는다.\n\n```js\nvar name = \"first\";  \nconsole.log(name); // first  \n  \nvar name = \"second\";  \nconsole.log(name); // second  \n```\n\n이런식으로 변수를 한 번 더 선언하게 되는 실수를 하는 경우  \n에러가 나오지 않고 각기 다른 값이 출력 된다.  \n이는 어디에서 어떻게 사용 될지도 파악하기 힘들뿐더러 값이 바뀔 우려가 있다.\n\n* * *\n\n#### 2. ES6 이후, 이를 보완하기 위해 추가 된 변수 선언 방식 let 과 const\n\n```js\nlet name = \"first\";  \nconsole.log(name); // first  \n \nlet name = \"second\";  \nconsole.log(name);   \n// Uncaught SyntaxError: Identifier 'name' has already been declared  \n```\n\nname이 이미 선언 되었다는 에러 메세지가 나온다.  \nconst를 사용해도 마찬가지로 변수 재선언이 되지 않는다.\n\n* * *\n\n##### [](#let은-변수에-재할당이-가능 \"let은 변수에 재할당이 가능\")let은 변수에 재할당이 가능\n\n```js\nlet name = \"first\";  \nconsole.log(name); // first  \n  \nlet name = \"second\";  \nconsole.log(name);  \n// Uncaught SyntaxError: Identifier 'name' has already been declared  \n  \nname = \"third\";  \nconsol.log(name); // third  \n```\n\n* * *\n\n##### const는 변수 재선언, 변수 재할당 모두 불가능 (상수)\n \n```js\nconst name = \"first\";  \nconsole.log(name) // first;  \n  \nconst name = \"second\";  \nconsole.log(name);  \n// Uncaught SyntaxError: Identifier 'name' has already been declared  \n  \nname = \"third\";  \nconsol.log(name);  \n//Uncaught TypeError: Assignment to constant variable.  \n```\n\n* * *\n\n*   참고:  \n    [https://www.daleseo.com/js-var-issues/](https://www.daleseo.com/js-var-issues/)  \n    [https://www.daleseo.com/js-es2015-let/](https://www.daleseo.com/js-es2015-let/)  \n    [https://gist.github.com/LeoHeo/7c2a2a6dbcf80becaaa1e61e90091e5d](https://gist.github.com/LeoHeo/7c2a2a6dbcf80becaaa1e61e90091e5d)\n    \n    [https://happycording.tistory.com/entry/let-const-%EB%9E%80-%EC%99%9C-%EC%8D%A8%EC%95%BC%EB%A7%8C-%ED%95%98%EB%8A%94%EA%B0%80-ES6](https://happycording.tistory.com/entry/let-const-%EB%9E%80-%EC%99%9C-%EC%8D%A8%EC%95%BC%EB%A7%8C-%ED%95%98%EB%8A%94%EA%B0%80-ES6)\n    \n\n","slug":"자바스크립트 기초 문법","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrth003iqgvqg393cxl9","content":"<h3 id=\"1-자바스크립트-선언문\"><a href=\"#1-자바스크립트-선언문\" class=\"headerlink\" title=\"1. 자바스크립트 선언문\"></a>1. 자바스크립트 선언문</h3><hr>\n<h4 id=\"1-type-속성\"><a href=\"#1-type-속성\" class=\"headerlink\" title=\"1. type 속성\"></a>1. type 속성</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;  </span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>옛날 표준인 HTML4 에는<br>type=”text/javascript”라는 속성이 필요했습니다.<br>HTML5부터는 사용하지 않아도 됩니다.</p>\n<p>HTML5 에선 불필요한 MIME 유형을 제공하기보다는 속성을 생략할 것을 권장합니다.</p>\n<a id=\"more\"></a>\n\n<hr>\n<h4 id=\"2-language-속성\"><a href=\"#2-language-속성\" class=\"headerlink\" title=\"2. language 속성\"></a>2. language 속성</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script language=<span class=\"string\">\"javascript\"</span>&gt;  </span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>스크립트 언어를 표시하기위한 속성.<br>이속성은 표준화되지 않았습니다.</p>\n<hr>\n<h4 id=\"3-생략\"><a href=\"#3-생략\" class=\"headerlink\" title=\"3. 생략\"></a>3. 생략</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;  </span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>html5 부터는 디폴트로 script 는 js로 쓰기때문에<br>type값을 생략한 script 로만 사용하셔도 무방합니다.</p>\n<hr>\n<h4 id=\"4-외부에서-불러오기\"><a href=\"#4-외부에서-불러오기\" class=\"headerlink\" title=\"4. 외부에서 불러오기\"></a>4. 외부에서 불러오기</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"소스경로\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"2-자바스크립트-선언문은-HTML문서-어디에-작성하나요\"><a href=\"#2-자바스크립트-선언문은-HTML문서-어디에-작성하나요\" class=\"headerlink\" title=\"2. 자바스크립트 선언문은 HTML문서 어디에 작성하나요?\"></a>2. 자바스크립트 선언문은 HTML문서 어디에 작성하나요?</h3><p>자바스크립트는 &lt; head&gt;태그 영역 또는 &lt; body&gt;태그 영역에 선언하면 됩니다.</p>\n<p>HTML의 &lt; head&gt; 섹션이 아니라 &lt; /body&gt; 태그 바로 앞에 두는 것이 가장 좋습니다.</p>\n<p>그 이유는 <strong>HTML이 웹에서 로딩되는 순서가 위에서 아래로 로드되기 때문입니다.</strong><br>head를 먼저 로드 한 다음 body를 로드합니다.<br>JavaScript을 헤드 영역에 넣으면 HTML을 로드하기 전에<br>전체 JavaScript 파일이 로드되므로 몇 가지 문제가 발생할 수 있습니다.</p>\n<h4 id=\"1-HTML을-변경하는-코드가-JavaScript에있는-경우\"><a href=\"#1-HTML을-변경하는-코드가-JavaScript에있는-경우\" class=\"headerlink\" title=\"1. HTML을 변경하는 코드가 JavaScript에있는 경우\"></a>1. HTML을 변경하는 코드가 JavaScript에있는 경우</h4><p>실제로 영향을 줄 수있는 HTML 요소가 없으므로 JavaScript 코드가 작동하지 않는 것처럼 보입니다. 오류가 발생할 수 있습니다.</p>\n<h4 id=\"2-JavaScript가-많은-경우\"><a href=\"#2-JavaScript가-많은-경우\" class=\"headerlink\" title=\"2. JavaScript가 많은 경우\"></a>2. JavaScript가 많은 경우</h4><p>HTML을 로드하기 전에 모든 JavaScript를 로드하기 때문에 페이지 로딩이 눈에 띄게 느려질 수 있습니다.</p>\n<p>자바 스크립트 링크를 HTML &lt;/ body&gt;태그 앞에 배치하면<br>자바 스크립트가 로드되기 전에 HTML을 로드 할수 있게 하여 오류를 방지하고<br><strong>웹 사이트 응답 시간을 단축 할 수 있습니다.</strong></p>\n<hr>\n<h3 id=\"3-자바스크립트-주석-처리\"><a href=\"#3-자바스크립트-주석-처리\" class=\"headerlink\" title=\"3. 자바스크립트 주석 처리\"></a>3. 자바스크립트 주석 처리</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//한 줄 설명글인 경우  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\"> 설명글이 여러줄 인 경우  </span></span><br><span class=\"line\"><span class=\"comment\">    </span></span><br><span class=\"line\"><span class=\"comment\"> 설명글이 여러줄 인 경우  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"4-자바스크립트-코드-입력시-주의할-점\"><a href=\"#4-자바스크립트-코드-입력시-주의할-점\" class=\"headerlink\" title=\"4. 자바스크립트 코드 입력시 주의할 점\"></a>4. 자바스크립트 코드 입력시 주의할 점</h3><hr>\n<h4 id=\"1-자바스크립트는-대·소문자를-가려서-씁니다\"><a href=\"#1-자바스크립트는-대·소문자를-가려서-씁니다\" class=\"headerlink\" title=\"1. 자바스크립트는 대·소문자를 가려서 씁니다.\"></a>1. 자바스크립트는 대·소문자를 가려서 씁니다.</h4><pre><code>날짜 객체 생성:New date(); (X)\n날짜 객체 생성:New Date(); (O)</code></pre><h4 id=\"2-실행문을-작성할-때는-한줄에-한-문장만-작성하는-것이-가독성을-위해-좋습니다\"><a href=\"#2-실행문을-작성할-때는-한줄에-한-문장만-작성하는-것이-가독성을-위해-좋습니다\" class=\"headerlink\" title=\"2. 실행문을 작성할 때는 한줄에 한 문장만 작성하는 것이 가독성을 위해 좋습니다.\"></a>2. 실행문을 작성할 때는 한줄에 한 문장만 작성하는 것이 가독성을 위해 좋습니다.</h4><h4 id=\"3-문자형-데이터를-작성할-때는-큰-따옴표-“”-와-작은따옴표-‘’-을-주의\"><a href=\"#3-문자형-데이터를-작성할-때는-큰-따옴표-“”-와-작은따옴표-‘’-을-주의\" class=\"headerlink\" title=\"3. 문자형 데이터를 작성할 때는 큰 따옴표(“”)와 작은따옴표(‘’)을 주의\"></a>3. 문자형 데이터를 작성할 때는 큰 따옴표(“”)와 작은따옴표(‘’)을 주의</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"</span>겹침 오류  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"문자형 데이터 \"</span>작성시 따옴표 겹침을<span class=\"string\">\" 주의 합니다.\"</span>) (X)  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">'문자형 데이터 \"작성시 따옴표 겹침을\" 주의 합니다.'</span>) (O)  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"문자형 데이터 \"</span>작성시 따옴표 겹침을<span class=\"string\">\" 주의 합니다.\"</span>) (O)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"5-자바스크립트-data-types\"><a href=\"#5-자바스크립트-data-types\" class=\"headerlink\" title=\"5. 자바스크립트 data types\"></a>5. 자바스크립트 data types</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">String</span> (문자형 데이터 타입)  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">const</span> what = <span class=\"string\">\"JS Study\"</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">Boolean</span> (논리형 데이터 타입 <span class=\"literal\">true</span> or <span class=\"literal\">false</span>)  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">const</span> what = <span class=\"literal\">true</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">Number</span> (숫자형 데이터 타입)  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">const</span> what = <span class=\"number\">123</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> Float (소숫점 데이터 타입)  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">const</span> what = <span class=\"number\">123.4</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">5.</span> Null (값이 없는 = 데이터를 비우고자 할때 사용)  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">const</span> what = <span class=\"literal\">null</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">6.</span> Undefined (값이 없는 = 지정 되지않음)  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">const</span> what;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"6-자바스크립트-변수-선언\"><a href=\"#6-자바스크립트-변수-선언\" class=\"headerlink\" title=\"6. 자바스크립트 변수 선언\"></a>6. 자바스크립트 변수 선언</h3><hr>\n<h4 id=\"1-ES6-이전-var\"><a href=\"#1-ES6-이전-var\" class=\"headerlink\" title=\"1. ES6 이전 - var\"></a>1. ES6 이전 - var</h4><p>ES6 이전 사용하던 변수 선언 방식으로<br>변수 선언 방식에 있어서 큰 단점을 가지고있어<br>ES6 이후 잘 사용되지 않는다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"first\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// first  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"second\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// second</span></span><br></pre></td></tr></table></figure>\n\n<p>이런식으로 변수를 한 번 더 선언하게 되는 실수를 하는 경우<br>에러가 나오지 않고 각기 다른 값이 출력 된다.<br>이는 어디에서 어떻게 사용 될지도 파악하기 힘들뿐더러 값이 바뀔 우려가 있다.</p>\n<hr>\n<h4 id=\"2-ES6-이후-이를-보완하기-위해-추가-된-변수-선언-방식-let-과-const\"><a href=\"#2-ES6-이후-이를-보완하기-위해-추가-된-변수-선언-방식-let-과-const\" class=\"headerlink\" title=\"2. ES6 이후, 이를 보완하기 위해 추가 된 변수 선언 방식 let 과 const\"></a>2. ES6 이후, 이를 보완하기 위해 추가 된 변수 선언 방식 let 과 const</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">\"first\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// first  </span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">\"second\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name);   </span><br><span class=\"line\"><span class=\"comment\">// Uncaught SyntaxError: Identifier 'name' has already been declared</span></span><br></pre></td></tr></table></figure>\n\n<p>name이 이미 선언 되었다는 에러 메세지가 나온다.<br>const를 사용해도 마찬가지로 변수 재선언이 되지 않는다.</p>\n<hr>\n<h5 id=\"let은-변수에-재할당이-가능\"><a href=\"#let은-변수에-재할당이-가능\" class=\"headerlink\" title=\"let은 변수에 재할당이 가능\"></a><a href=\"#let은-변수에-재할당이-가능\" title=\"let은 변수에 재할당이 가능\"></a>let은 변수에 재할당이 가능</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">\"first\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// first  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">\"second\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name);  </span><br><span class=\"line\"><span class=\"comment\">// Uncaught SyntaxError: Identifier 'name' has already been declared  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">name = <span class=\"string\">\"third\"</span>;  </span><br><span class=\"line\">consol.log(name); <span class=\"comment\">// third</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"const는-변수-재선언-변수-재할당-모두-불가능-상수\"><a href=\"#const는-변수-재선언-변수-재할당-모두-불가능-상수\" class=\"headerlink\" title=\"const는 변수 재선언, 변수 재할당 모두 불가능 (상수)\"></a>const는 변수 재선언, 변수 재할당 모두 불가능 (상수)</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">\"first\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name) <span class=\"comment\">// first;  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">\"second\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name);  </span><br><span class=\"line\"><span class=\"comment\">// Uncaught SyntaxError: Identifier 'name' has already been declared  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">name = <span class=\"string\">\"third\"</span>;  </span><br><span class=\"line\">consol.log(name);  </span><br><span class=\"line\"><span class=\"comment\">//Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<ul>\n<li><p>참고:<br><a href=\"https://www.daleseo.com/js-var-issues/\">https://www.daleseo.com/js-var-issues/</a><br><a href=\"https://www.daleseo.com/js-es2015-let/\">https://www.daleseo.com/js-es2015-let/</a><br><a href=\"https://gist.github.com/LeoHeo/7c2a2a6dbcf80becaaa1e61e90091e5d\">https://gist.github.com/LeoHeo/7c2a2a6dbcf80becaaa1e61e90091e5d</a></p>\n<p><a href=\"https://happycording.tistory.com/entry/let-const-%EB%9E%80-%EC%99%9C-%EC%8D%A8%EC%95%BC%EB%A7%8C-%ED%95%98%EB%8A%94%EA%B0%80-ES6\">https://happycording.tistory.com/entry/let-const-%EB%9E%80-%EC%99%9C-%EC%8D%A8%EC%95%BC%EB%A7%8C-%ED%95%98%EB%8A%94%EA%B0%80-ES6</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-자바스크립트-선언문\"><a href=\"#1-자바스크립트-선언문\" class=\"headerlink\" title=\"1. 자바스크립트 선언문\"></a>1. 자바스크립트 선언문</h3><hr>\n<h4 id=\"1-type-속성\"><a href=\"#1-type-속성\" class=\"headerlink\" title=\"1. type 속성\"></a>1. type 속성</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;  </span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>옛날 표준인 HTML4 에는<br>type=”text/javascript”라는 속성이 필요했습니다.<br>HTML5부터는 사용하지 않아도 됩니다.</p>\n<p>HTML5 에선 불필요한 MIME 유형을 제공하기보다는 속성을 생략할 것을 권장합니다.</p>","more":"<hr>\n<h4 id=\"2-language-속성\"><a href=\"#2-language-속성\" class=\"headerlink\" title=\"2. language 속성\"></a>2. language 속성</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script language=<span class=\"string\">\"javascript\"</span>&gt;  </span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>스크립트 언어를 표시하기위한 속성.<br>이속성은 표준화되지 않았습니다.</p>\n<hr>\n<h4 id=\"3-생략\"><a href=\"#3-생략\" class=\"headerlink\" title=\"3. 생략\"></a>3. 생략</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;  </span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>html5 부터는 디폴트로 script 는 js로 쓰기때문에<br>type값을 생략한 script 로만 사용하셔도 무방합니다.</p>\n<hr>\n<h4 id=\"4-외부에서-불러오기\"><a href=\"#4-외부에서-불러오기\" class=\"headerlink\" title=\"4. 외부에서 불러오기\"></a>4. 외부에서 불러오기</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"소스경로\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"2-자바스크립트-선언문은-HTML문서-어디에-작성하나요\"><a href=\"#2-자바스크립트-선언문은-HTML문서-어디에-작성하나요\" class=\"headerlink\" title=\"2. 자바스크립트 선언문은 HTML문서 어디에 작성하나요?\"></a>2. 자바스크립트 선언문은 HTML문서 어디에 작성하나요?</h3><p>자바스크립트는 &lt; head&gt;태그 영역 또는 &lt; body&gt;태그 영역에 선언하면 됩니다.</p>\n<p>HTML의 &lt; head&gt; 섹션이 아니라 &lt; /body&gt; 태그 바로 앞에 두는 것이 가장 좋습니다.</p>\n<p>그 이유는 <strong>HTML이 웹에서 로딩되는 순서가 위에서 아래로 로드되기 때문입니다.</strong><br>head를 먼저 로드 한 다음 body를 로드합니다.<br>JavaScript을 헤드 영역에 넣으면 HTML을 로드하기 전에<br>전체 JavaScript 파일이 로드되므로 몇 가지 문제가 발생할 수 있습니다.</p>\n<h4 id=\"1-HTML을-변경하는-코드가-JavaScript에있는-경우\"><a href=\"#1-HTML을-변경하는-코드가-JavaScript에있는-경우\" class=\"headerlink\" title=\"1. HTML을 변경하는 코드가 JavaScript에있는 경우\"></a>1. HTML을 변경하는 코드가 JavaScript에있는 경우</h4><p>실제로 영향을 줄 수있는 HTML 요소가 없으므로 JavaScript 코드가 작동하지 않는 것처럼 보입니다. 오류가 발생할 수 있습니다.</p>\n<h4 id=\"2-JavaScript가-많은-경우\"><a href=\"#2-JavaScript가-많은-경우\" class=\"headerlink\" title=\"2. JavaScript가 많은 경우\"></a>2. JavaScript가 많은 경우</h4><p>HTML을 로드하기 전에 모든 JavaScript를 로드하기 때문에 페이지 로딩이 눈에 띄게 느려질 수 있습니다.</p>\n<p>자바 스크립트 링크를 HTML &lt;/ body&gt;태그 앞에 배치하면<br>자바 스크립트가 로드되기 전에 HTML을 로드 할수 있게 하여 오류를 방지하고<br><strong>웹 사이트 응답 시간을 단축 할 수 있습니다.</strong></p>\n<hr>\n<h3 id=\"3-자바스크립트-주석-처리\"><a href=\"#3-자바스크립트-주석-처리\" class=\"headerlink\" title=\"3. 자바스크립트 주석 처리\"></a>3. 자바스크립트 주석 처리</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//한 줄 설명글인 경우  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\"> 설명글이 여러줄 인 경우  </span></span><br><span class=\"line\"><span class=\"comment\">    </span></span><br><span class=\"line\"><span class=\"comment\"> 설명글이 여러줄 인 경우  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"4-자바스크립트-코드-입력시-주의할-점\"><a href=\"#4-자바스크립트-코드-입력시-주의할-점\" class=\"headerlink\" title=\"4. 자바스크립트 코드 입력시 주의할 점\"></a>4. 자바스크립트 코드 입력시 주의할 점</h3><hr>\n<h4 id=\"1-자바스크립트는-대·소문자를-가려서-씁니다\"><a href=\"#1-자바스크립트는-대·소문자를-가려서-씁니다\" class=\"headerlink\" title=\"1. 자바스크립트는 대·소문자를 가려서 씁니다.\"></a>1. 자바스크립트는 대·소문자를 가려서 씁니다.</h4><pre><code>날짜 객체 생성:New date(); (X)\n날짜 객체 생성:New Date(); (O)</code></pre><h4 id=\"2-실행문을-작성할-때는-한줄에-한-문장만-작성하는-것이-가독성을-위해-좋습니다\"><a href=\"#2-실행문을-작성할-때는-한줄에-한-문장만-작성하는-것이-가독성을-위해-좋습니다\" class=\"headerlink\" title=\"2. 실행문을 작성할 때는 한줄에 한 문장만 작성하는 것이 가독성을 위해 좋습니다.\"></a>2. 실행문을 작성할 때는 한줄에 한 문장만 작성하는 것이 가독성을 위해 좋습니다.</h4><h4 id=\"3-문자형-데이터를-작성할-때는-큰-따옴표-“”-와-작은따옴표-‘’-을-주의\"><a href=\"#3-문자형-데이터를-작성할-때는-큰-따옴표-“”-와-작은따옴표-‘’-을-주의\" class=\"headerlink\" title=\"3. 문자형 데이터를 작성할 때는 큰 따옴표(“”)와 작은따옴표(‘’)을 주의\"></a>3. 문자형 데이터를 작성할 때는 큰 따옴표(“”)와 작은따옴표(‘’)을 주의</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"</span>겹침 오류  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"문자형 데이터 \"</span>작성시 따옴표 겹침을<span class=\"string\">\" 주의 합니다.\"</span>) (X)  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">'문자형 데이터 \"작성시 따옴표 겹침을\" 주의 합니다.'</span>) (O)  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"문자형 데이터 \"</span>작성시 따옴표 겹침을<span class=\"string\">\" 주의 합니다.\"</span>) (O)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"5-자바스크립트-data-types\"><a href=\"#5-자바스크립트-data-types\" class=\"headerlink\" title=\"5. 자바스크립트 data types\"></a>5. 자바스크립트 data types</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">String</span> (문자형 데이터 타입)  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">const</span> what = <span class=\"string\">\"JS Study\"</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">Boolean</span> (논리형 데이터 타입 <span class=\"literal\">true</span> or <span class=\"literal\">false</span>)  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">const</span> what = <span class=\"literal\">true</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">Number</span> (숫자형 데이터 타입)  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">const</span> what = <span class=\"number\">123</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">4.</span> Float (소숫점 데이터 타입)  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">const</span> what = <span class=\"number\">123.4</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">5.</span> Null (값이 없는 = 데이터를 비우고자 할때 사용)  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">const</span> what = <span class=\"literal\">null</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">6.</span> Undefined (값이 없는 = 지정 되지않음)  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">const</span> what;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"6-자바스크립트-변수-선언\"><a href=\"#6-자바스크립트-변수-선언\" class=\"headerlink\" title=\"6. 자바스크립트 변수 선언\"></a>6. 자바스크립트 변수 선언</h3><hr>\n<h4 id=\"1-ES6-이전-var\"><a href=\"#1-ES6-이전-var\" class=\"headerlink\" title=\"1. ES6 이전 - var\"></a>1. ES6 이전 - var</h4><p>ES6 이전 사용하던 변수 선언 방식으로<br>변수 선언 방식에 있어서 큰 단점을 가지고있어<br>ES6 이후 잘 사용되지 않는다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"first\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// first  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"second\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// second</span></span><br></pre></td></tr></table></figure>\n\n<p>이런식으로 변수를 한 번 더 선언하게 되는 실수를 하는 경우<br>에러가 나오지 않고 각기 다른 값이 출력 된다.<br>이는 어디에서 어떻게 사용 될지도 파악하기 힘들뿐더러 값이 바뀔 우려가 있다.</p>\n<hr>\n<h4 id=\"2-ES6-이후-이를-보완하기-위해-추가-된-변수-선언-방식-let-과-const\"><a href=\"#2-ES6-이후-이를-보완하기-위해-추가-된-변수-선언-방식-let-과-const\" class=\"headerlink\" title=\"2. ES6 이후, 이를 보완하기 위해 추가 된 변수 선언 방식 let 과 const\"></a>2. ES6 이후, 이를 보완하기 위해 추가 된 변수 선언 방식 let 과 const</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">\"first\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// first  </span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">\"second\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name);   </span><br><span class=\"line\"><span class=\"comment\">// Uncaught SyntaxError: Identifier 'name' has already been declared</span></span><br></pre></td></tr></table></figure>\n\n<p>name이 이미 선언 되었다는 에러 메세지가 나온다.<br>const를 사용해도 마찬가지로 변수 재선언이 되지 않는다.</p>\n<hr>\n<h5 id=\"let은-변수에-재할당이-가능\"><a href=\"#let은-변수에-재할당이-가능\" class=\"headerlink\" title=\"let은 변수에 재할당이 가능\"></a><a href=\"#let은-변수에-재할당이-가능\" title=\"let은 변수에 재할당이 가능\"></a>let은 변수에 재할당이 가능</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">\"first\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// first  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">\"second\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name);  </span><br><span class=\"line\"><span class=\"comment\">// Uncaught SyntaxError: Identifier 'name' has already been declared  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">name = <span class=\"string\">\"third\"</span>;  </span><br><span class=\"line\">consol.log(name); <span class=\"comment\">// third</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"const는-변수-재선언-변수-재할당-모두-불가능-상수\"><a href=\"#const는-변수-재선언-변수-재할당-모두-불가능-상수\" class=\"headerlink\" title=\"const는 변수 재선언, 변수 재할당 모두 불가능 (상수)\"></a>const는 변수 재선언, 변수 재할당 모두 불가능 (상수)</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">\"first\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name) <span class=\"comment\">// first;  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">\"second\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name);  </span><br><span class=\"line\"><span class=\"comment\">// Uncaught SyntaxError: Identifier 'name' has already been declared  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">name = <span class=\"string\">\"third\"</span>;  </span><br><span class=\"line\">consol.log(name);  </span><br><span class=\"line\"><span class=\"comment\">//Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<ul>\n<li><p>참고:<br><a href=\"https://www.daleseo.com/js-var-issues/\">https://www.daleseo.com/js-var-issues/</a><br><a href=\"https://www.daleseo.com/js-es2015-let/\">https://www.daleseo.com/js-es2015-let/</a><br><a href=\"https://gist.github.com/LeoHeo/7c2a2a6dbcf80becaaa1e61e90091e5d\">https://gist.github.com/LeoHeo/7c2a2a6dbcf80becaaa1e61e90091e5d</a></p>\n<p><a href=\"https://happycording.tistory.com/entry/let-const-%EB%9E%80-%EC%99%9C-%EC%8D%A8%EC%95%BC%EB%A7%8C-%ED%95%98%EB%8A%94%EA%B0%80-ES6\">https://happycording.tistory.com/entry/let-const-%EB%9E%80-%EC%99%9C-%EC%8D%A8%EC%95%BC%EB%A7%8C-%ED%95%98%EB%8A%94%EA%B0%80-ES6</a></p>\n</li>\n</ul>"},{"title":"자바스크립트 선택문,반복문","date":"2020-02-24T22:00:00.000Z","disqusId":"tunas-blog-1","_content":"\n자바스크립트의 선택문(switch)와 반복문(while,for)\n\n<!-- more -->\n\n* * *\n\n### 선택문 switch\n\n변수에 저장된 값과 switch 문에 있는 경우(case) 값을 검사하여,\n\n일치하는 값이 있을때 해당하는 실행문을 실행합니다.\n\n```js\nswitch (변수){  \n case 1값: 실행문1;   \n /*변수값이 case값에 일치하는 데이터가 있으면,  \n 해당하는 실행문 실행*/  \n break; //반복문을 강제로 끝내는 break;  \n  \n case 2값: 실행문2;  \n break;  \n    \n case 3값: 실행문3;  \n break;  \n  \n default: 실행문4; //일치하는 값이 없을경우에 실행  \n```\n\n* * *\n\n### if 와 switch 차이점\n\n\nif문은 조건이 만족할 때 와 만족하지 않을때를 확인하기 위한 작업이 필요합니다.\n\n조건식이 많아 질수록 느려 질수 있습니다.\n\n```js\n    if(){\n        document.write();\n    }else if(){\n        document.write();\n    }else if(){ \n        document.write();\n    }else{\n        document.write();\n    }\n```\n\n* * *\n\nswitch문은 조건의 수를 따지지 않고\n\n입력된 변수 값을 보고 해당하는 특정 위치로 점프합니다.\n\n\n사실 조건식이 3개 이상일시 if보다 switch 빠르다라는 효율적 측면보다.  \n**가독성과 코드의 의미를 생각하며 사용하는게 옳다고 합니다.**\n\n* * *\n\n### 반복문 while\n\nwhile문은 조건식을 만족(true)할 때까지 실행문을 여러 번 반복하여 실행시킬 수 있습니다.\n\n`조건식을 만족할때 까지 {} 내에 실행문을 반복 실행 시킵니다.`\n\n    while문의 실행 순서는 \n    1.조건식을 검사.\n    2.조건식 만족시 {}내에 실행문과 증감식을 실행.\n    3.증감식 실행후 조건식을 다시 검사.\n    --반복\n    4.조건식이 거짓(false)값 이면 종료됩니다.\n\n```js\nlet i=1; // 초기값 선언  \nwhile(i<=10){ // i 값이 10보다 작거나 같을때(true) 까지 반복  \ndocument.write(\"안녕하세요\"+i,\"<br />\"); // 실행문  \ni++; // 증감식  \n}  \n\n/*   \n 안녕하세요1  \n 안녕하세요2  \n 안녕하세요3  \n 안녕하세요4  \n 안녕하세요5  \n 안녕하세요6  \n 안녕하세요7  \n 안녕하세요8  \n 안녕하세요9  \n 안녕하세요10  \n*/\n```  \n\n* * *\n\n20부터 10까지 숫자 중 짝수을 경우 에는 파란색으로 출력,\n\n홀수일 경우에는 빨간색으로 출력되도록 한 예제.\n\n```js\nlet i=20;  \n  \nwhile(i>=10){   \n // i의 값이 10보다 클 때까지 반복문을 실행.  \n  \n if(i%2==0){   \n // i의 값을 2로 나눠서 나머지가 0일 경우 (2의 배수)  \n document.write(\"<font color='blue'>\"+i+\"</font>\", \"<br/>\");  \n } else{   \n // 2로 나눠서 나머지가 0이 아닐 경우  \n document.write(\"<font color='red'>\"+i+\"</font>\", \"<br/>\");  \n }  \n  \n i--;   \n // 감소 연산자 (i값을 1씩 감소 시킴.)  \n}  \n```\n\n* * *\n\n### for 문\n\nfor 문은 조건식을 만족할 때까지 실행문을 반복하여 실행합니다.\n\nwhile 문보다 편리해 사용 빈도가 높은 편입니다.\n\n    for(초기값;조건식;증감식){\n        실행문;\n    }\n\n```js\nfor (let i=1; i<=10; i++){ // i=1 , i값이 10까지 1씩 증가하며 반복합니다.  \n    \n document.write(\"반복\"+i,\"<br/>\");  \n /*  \n 반복1  \n 반복2  \n 반복3  \n 반복4  \n 반복5  \n 반복6  \n 반복7  \n 반복8  \n 반복9  \n 반복10  \n */  \n}  \n```\n\nfor 문을 이용하여 1~100까지 숫자에서 5의 배수일 경우 빨간색,\n\n7의 배수일 경우 초록색,\n\n5의 배수이며 7의 배수일 경우 아쿠아색으로 출력한 예제\n\n```js\nfor(let a=1; a<=100; a++){  //변수 i가 100이 될 때까지 반복 실행합니다.  \n    if(a%7==0 && a%5==0){   //5의 배수이고 7의 배수가 인 경우  \n    document.write(\"<font color='aqua'>\"+a+\"</font>\",\"<br />\");  \n    }else if(a%5==0){       //5의 배수인 경우  \n    document.write(\"<font color='red'>\"+a+\"</font>\",\"<br />\");  \n    }else if(a%7==0){       //7의 배수인 경우  \n    document.write(\"<font color='green'>\"+a+\"</font>\",\"<br />\");  \n    }  \n}   \n```\n\n* * *\n\n### continue 문\n\ncontinue 문은 반복문에서만 사용할 수 있습니다.\n\n`continue 문 다음에 오는 실행문은 무시하고 실행해`라는 뜻입니다.\n\n```js\n// for 예시  \nfor(초깃값; 조건식; 증감식){  \n continue;   \n //다음에 오는 실행문은 무시하고 증감식으로 이동되 실행됩니다.  \n 실행문;  \n}  \n// while 예시  \nlet 변수=초깃값;  \nwhile(조건식){  \n    증감식;  \n    continue;  \n//다음에 오는 실행은 무시하고 조건식으로 이동합니다.  \n    실행문;  \n}  \n```\ncountinue 실행문 무시 예제\n\n```js\nfor(let i=1; i<=10; i++){  \n  \n if(i%2==0) continue;   \n // i가 2의 배수일때의 실행문은 무시하고 증감식으로 넘어갑니다.  \n document.write(i,\"<br />\");  \n // i값이 2의 배수가 아닌경우에만 실행됩니다.  \n  \n //1 3 5 7 9  \n}  \n```\n\n* * *\n\n### 중첩 for문으로 구구단 만들기\n\n```js\nfor(let i=2; i<=9; i++){  \n// i는 2부터 9까지 1씩 커지게 반복시킵니다.   \n document.write(\"<h1>\"+i+\"단</h1>\");  \n // i값+\"단\" 을 h1태그로 묶어 표시합니다.  \n  \n for(let k=1; k<=9; k++){  \n // k는 1부터 9까지 1씩 커지게 반복시킵니다.  \n document.write(i+\"X\"+K+\"=\"+i*K,\"<br/>\");  \n/*   \ni값 2부터  \nk값 1부터 9까지  \ni값 9까지 반복 실행되어  \n   \ni값+\"X\"+K값+\"=\" 이   \n2X1 부터 순차적으로 실행되며  \n \n+i*k 는 각 값의 곱셈이 실행됩니다.  \n   \n*/  \n }  \n}\n```  \n\n* * *\n\n### 현재 연도와 월에 맞는 전체 일자 출력하기\n\n```js\n//현재 년도와 월을 입력받습니다.  \nconst year=prompt(\"현재 몇 년 입니까?\",\"0000\");   \nconst mon=prompt(\"현재 몇 월 입니까?\",\"0\");  \nlet last_day;  \n/*현재 월이 몇일까지 있는지 선택문을  \n이용해 구합니다.*/  \nswitch (mon){  \n case \"1\" : last_day=31;  \n break;  \n case \"2\" : last_day=28;  \n    \n /*현재 년도가 4년주기이고 100년 주기는 아닌경우  \n 또는 400년 주기로 윤년이므로 2월은 29일까지 있습니다.*/  \n if(year % 4==0 && year % 100 !=0 || year % 400 ==0){  \n last_day=29;  \n }  \n break;  \n case \"3\": last_day=31;  \n break;  \n case \"4\": last_day=30;  \n break;  \n case \"5\": last_day=31;  \n break;  \n    \n case \"6\": last_day=30;  \n break;  \n    \n case \"7\": last_day=31;  \n break;  \n    \n case \"8\": last_day=31;  \n break;  \n    \n case \"9\": last_day=30;  \n break;  \n    \n case \"10\": last_day=31;  \n break;  \n    \n case \"11\": last_day=30;  \n break;  \n    \n case \"12\": last_day=31;  \n break;  \n}  \n  \nfor(let i=1; i<=last_day; i++){  \n document.write(i+\" \");  \n}  \n```\n\n* * *\n\n### 자바스크립트 for 이용한 별 찍기\n\n직각삼각형 만들기\n\n```js\nlet star=\"\";  \n  \nfor(let i=1; i<=5; i++){  \n  \n star +=\"*\";  \n console.log(star);  \n}  \n/* \n    * \n    **  \n    *** \n    ****  \n    *****  \n*/  \n```\n\n역 직각 삼각형 만들기\n\n```js\nlet star = \"\";  \n  \nfor (let i = 0; i < 5; i++) {  \n for (let j = 0; j < i; j++){  \n star += \" \";  \n }  \n for (let k = 1; k <= 5 - i; k++){   \n star += \"*\";  \n }  \n star += \"n\";  \n}  \nconsole.log(star);  \n/*  \n    *****  \n    **** \n    ***  \n    ** \n    * \n*/  \n```\n\n정삼각형 만들기\n\n```js\nlet star = \"\";  \n  \nfor (let i = 1; i <= 5; i++) {  \n for (let k = 5; k >i; k--) {  \n star += \" \";  \n }  \n for (let j =1; j<(i*2); j++) {  \n  \n star += \"*\";  \n }  \n star+=\"n\";  \n}  \nconsole.log(star);  \n  \n/* \n        * \n       *** \n      *****  \n     *******  \n    *********  \n*/  \n```\n\n마름모 만들기 - 1\n\n```js\nlet star = \"\";  \n  \nfor (let i = 1; i <= 5; i++) {  \n for (let k = 5; k >i; k--) {  \n star += \" \";  \n }  \n for (let j =1; j<(i*2); j++) {  \n  \n star += \"*\";  \n }  \n star+=\"n\";  \n}  \nfor (let s = 1; s <= 4; s++){  \n for(let x= 0; x <s; x++){  \n star+=\" \";  \n }  \n for(let q=9; q>s*2; q--){  \n star+=\"*\";  \n }  \n star +=\"n\";  \n}  \n  \nconsole.log(star);  \n/*   \n     *  \n    *** \n   ***** \n  *******  \n *********  \n  *******  \n   ***** \n    *** \n     *  \n*/  \n```\n\n마름모 만들기 - 2\n\n```js  \nlet star=\"\"; // 공백과 별이 들어갈 변수입니다.  \nlet count = 9; // 반복문을 실행시킬 총 값 입니다.  \nlet halfNum = Math.round(count/2);   \n/* count/2 소수점 값 반올림하여 절반 값을 구합니다.  \n(count 값에 홀수,짝수,소수점 값이 와도 일정하게 절반 값을 구합니다.)  \n*/  \nlet space=0;  \n for (let i = 1; i <= count; i++) { // count 값 만큼 반복문을 실행합니다.  \n    \n for(let k=1; k<=halfNum+space; k++){   \n /* 행값입니다 1부터 (halfNum+space)와 같거나 작은 값까지 반복하고.  \n 열(i) 값에 따라 행 값을 1씩 늘리거나 줄일 것입니다.  \n */  \n    \n /*  \n k<= 5(halfNUm) + 0 (space) // k<= 5  \n k<= 5(halfNUm) + 1 (space) // k<= 6  \n k<= 5(halfNUm) + 2 (space) // k<= 7  \n k<= 5(halfNUm) + 3 (space) // k<= 8  \n k<= 5(halfNUm) + 4 (space) // k<= 9  \n k<= 5(halfNum) + 3 (space) // k<= 8  \n k<= 5(halfNum) + 2 (space) // k<= 7  \n k<= 5(halfNum) + 1 (space) // k<= 6  \n k<= 5(halfNum) + 0 (space) // k<= 5  \n */  \n  \n /* k 가 halfNum-spcae값 보다 작을때 true값 \" \"; false값 \"*\"을  \n star값에 저장합니다.  \n */  \n star+= k<halfNum-space ? \" \" : \"*\";  \n /*  \n k< 5(halfNum)-0(space) // k<5 \\\\\\\\F  \n k< 5(halfNum)-1(space) // k<4 \\\\\\FFF  \n k< 5(halfNum)-2(space) // k<3 \\\\FFFFF  \n k< 5(halfNum)-3(space) // k<2 \\FFFFFFF  \n k< 5(halfNum)-4(space) // k<1 FFFFFFFFF  \n k< 5(halfNum)-3(space) // k<2 \\FFFFFFF  \n k< 5(halfNum)-2(space) // k<3 \\\\FFFFF  \n k< 5(halfNum)-1(space) // k<4 \\\\\\FFF  \n k< 5(halfNum)-0(space) // k<5 \\\\\\\\F  \n */  \n }  \n if(i<halfNum){ //i값이 halfNum 값보다 작다면 space++;  \n space++;  \n }else{ // 아닌 경우 space--;  \n space--;  \n }   \n star+=\"n\";  \n}  \nconsole.log(star);  \n```","source":"_posts/자바스크립트 선택문.md","raw":"---\ntitle: 자바스크립트 선택문,반복문\ndate: 2020-02-25 07:00:00.000\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\n자바스크립트의 선택문(switch)와 반복문(while,for)\n\n<!-- more -->\n\n* * *\n\n### 선택문 switch\n\n변수에 저장된 값과 switch 문에 있는 경우(case) 값을 검사하여,\n\n일치하는 값이 있을때 해당하는 실행문을 실행합니다.\n\n```js\nswitch (변수){  \n case 1값: 실행문1;   \n /*변수값이 case값에 일치하는 데이터가 있으면,  \n 해당하는 실행문 실행*/  \n break; //반복문을 강제로 끝내는 break;  \n  \n case 2값: 실행문2;  \n break;  \n    \n case 3값: 실행문3;  \n break;  \n  \n default: 실행문4; //일치하는 값이 없을경우에 실행  \n```\n\n* * *\n\n### if 와 switch 차이점\n\n\nif문은 조건이 만족할 때 와 만족하지 않을때를 확인하기 위한 작업이 필요합니다.\n\n조건식이 많아 질수록 느려 질수 있습니다.\n\n```js\n    if(){\n        document.write();\n    }else if(){\n        document.write();\n    }else if(){ \n        document.write();\n    }else{\n        document.write();\n    }\n```\n\n* * *\n\nswitch문은 조건의 수를 따지지 않고\n\n입력된 변수 값을 보고 해당하는 특정 위치로 점프합니다.\n\n\n사실 조건식이 3개 이상일시 if보다 switch 빠르다라는 효율적 측면보다.  \n**가독성과 코드의 의미를 생각하며 사용하는게 옳다고 합니다.**\n\n* * *\n\n### 반복문 while\n\nwhile문은 조건식을 만족(true)할 때까지 실행문을 여러 번 반복하여 실행시킬 수 있습니다.\n\n`조건식을 만족할때 까지 {} 내에 실행문을 반복 실행 시킵니다.`\n\n    while문의 실행 순서는 \n    1.조건식을 검사.\n    2.조건식 만족시 {}내에 실행문과 증감식을 실행.\n    3.증감식 실행후 조건식을 다시 검사.\n    --반복\n    4.조건식이 거짓(false)값 이면 종료됩니다.\n\n```js\nlet i=1; // 초기값 선언  \nwhile(i<=10){ // i 값이 10보다 작거나 같을때(true) 까지 반복  \ndocument.write(\"안녕하세요\"+i,\"<br />\"); // 실행문  \ni++; // 증감식  \n}  \n\n/*   \n 안녕하세요1  \n 안녕하세요2  \n 안녕하세요3  \n 안녕하세요4  \n 안녕하세요5  \n 안녕하세요6  \n 안녕하세요7  \n 안녕하세요8  \n 안녕하세요9  \n 안녕하세요10  \n*/\n```  \n\n* * *\n\n20부터 10까지 숫자 중 짝수을 경우 에는 파란색으로 출력,\n\n홀수일 경우에는 빨간색으로 출력되도록 한 예제.\n\n```js\nlet i=20;  \n  \nwhile(i>=10){   \n // i의 값이 10보다 클 때까지 반복문을 실행.  \n  \n if(i%2==0){   \n // i의 값을 2로 나눠서 나머지가 0일 경우 (2의 배수)  \n document.write(\"<font color='blue'>\"+i+\"</font>\", \"<br/>\");  \n } else{   \n // 2로 나눠서 나머지가 0이 아닐 경우  \n document.write(\"<font color='red'>\"+i+\"</font>\", \"<br/>\");  \n }  \n  \n i--;   \n // 감소 연산자 (i값을 1씩 감소 시킴.)  \n}  \n```\n\n* * *\n\n### for 문\n\nfor 문은 조건식을 만족할 때까지 실행문을 반복하여 실행합니다.\n\nwhile 문보다 편리해 사용 빈도가 높은 편입니다.\n\n    for(초기값;조건식;증감식){\n        실행문;\n    }\n\n```js\nfor (let i=1; i<=10; i++){ // i=1 , i값이 10까지 1씩 증가하며 반복합니다.  \n    \n document.write(\"반복\"+i,\"<br/>\");  \n /*  \n 반복1  \n 반복2  \n 반복3  \n 반복4  \n 반복5  \n 반복6  \n 반복7  \n 반복8  \n 반복9  \n 반복10  \n */  \n}  \n```\n\nfor 문을 이용하여 1~100까지 숫자에서 5의 배수일 경우 빨간색,\n\n7의 배수일 경우 초록색,\n\n5의 배수이며 7의 배수일 경우 아쿠아색으로 출력한 예제\n\n```js\nfor(let a=1; a<=100; a++){  //변수 i가 100이 될 때까지 반복 실행합니다.  \n    if(a%7==0 && a%5==0){   //5의 배수이고 7의 배수가 인 경우  \n    document.write(\"<font color='aqua'>\"+a+\"</font>\",\"<br />\");  \n    }else if(a%5==0){       //5의 배수인 경우  \n    document.write(\"<font color='red'>\"+a+\"</font>\",\"<br />\");  \n    }else if(a%7==0){       //7의 배수인 경우  \n    document.write(\"<font color='green'>\"+a+\"</font>\",\"<br />\");  \n    }  \n}   \n```\n\n* * *\n\n### continue 문\n\ncontinue 문은 반복문에서만 사용할 수 있습니다.\n\n`continue 문 다음에 오는 실행문은 무시하고 실행해`라는 뜻입니다.\n\n```js\n// for 예시  \nfor(초깃값; 조건식; 증감식){  \n continue;   \n //다음에 오는 실행문은 무시하고 증감식으로 이동되 실행됩니다.  \n 실행문;  \n}  \n// while 예시  \nlet 변수=초깃값;  \nwhile(조건식){  \n    증감식;  \n    continue;  \n//다음에 오는 실행은 무시하고 조건식으로 이동합니다.  \n    실행문;  \n}  \n```\ncountinue 실행문 무시 예제\n\n```js\nfor(let i=1; i<=10; i++){  \n  \n if(i%2==0) continue;   \n // i가 2의 배수일때의 실행문은 무시하고 증감식으로 넘어갑니다.  \n document.write(i,\"<br />\");  \n // i값이 2의 배수가 아닌경우에만 실행됩니다.  \n  \n //1 3 5 7 9  \n}  \n```\n\n* * *\n\n### 중첩 for문으로 구구단 만들기\n\n```js\nfor(let i=2; i<=9; i++){  \n// i는 2부터 9까지 1씩 커지게 반복시킵니다.   \n document.write(\"<h1>\"+i+\"단</h1>\");  \n // i값+\"단\" 을 h1태그로 묶어 표시합니다.  \n  \n for(let k=1; k<=9; k++){  \n // k는 1부터 9까지 1씩 커지게 반복시킵니다.  \n document.write(i+\"X\"+K+\"=\"+i*K,\"<br/>\");  \n/*   \ni값 2부터  \nk값 1부터 9까지  \ni값 9까지 반복 실행되어  \n   \ni값+\"X\"+K값+\"=\" 이   \n2X1 부터 순차적으로 실행되며  \n \n+i*k 는 각 값의 곱셈이 실행됩니다.  \n   \n*/  \n }  \n}\n```  \n\n* * *\n\n### 현재 연도와 월에 맞는 전체 일자 출력하기\n\n```js\n//현재 년도와 월을 입력받습니다.  \nconst year=prompt(\"현재 몇 년 입니까?\",\"0000\");   \nconst mon=prompt(\"현재 몇 월 입니까?\",\"0\");  \nlet last_day;  \n/*현재 월이 몇일까지 있는지 선택문을  \n이용해 구합니다.*/  \nswitch (mon){  \n case \"1\" : last_day=31;  \n break;  \n case \"2\" : last_day=28;  \n    \n /*현재 년도가 4년주기이고 100년 주기는 아닌경우  \n 또는 400년 주기로 윤년이므로 2월은 29일까지 있습니다.*/  \n if(year % 4==0 && year % 100 !=0 || year % 400 ==0){  \n last_day=29;  \n }  \n break;  \n case \"3\": last_day=31;  \n break;  \n case \"4\": last_day=30;  \n break;  \n case \"5\": last_day=31;  \n break;  \n    \n case \"6\": last_day=30;  \n break;  \n    \n case \"7\": last_day=31;  \n break;  \n    \n case \"8\": last_day=31;  \n break;  \n    \n case \"9\": last_day=30;  \n break;  \n    \n case \"10\": last_day=31;  \n break;  \n    \n case \"11\": last_day=30;  \n break;  \n    \n case \"12\": last_day=31;  \n break;  \n}  \n  \nfor(let i=1; i<=last_day; i++){  \n document.write(i+\" \");  \n}  \n```\n\n* * *\n\n### 자바스크립트 for 이용한 별 찍기\n\n직각삼각형 만들기\n\n```js\nlet star=\"\";  \n  \nfor(let i=1; i<=5; i++){  \n  \n star +=\"*\";  \n console.log(star);  \n}  \n/* \n    * \n    **  \n    *** \n    ****  \n    *****  \n*/  \n```\n\n역 직각 삼각형 만들기\n\n```js\nlet star = \"\";  \n  \nfor (let i = 0; i < 5; i++) {  \n for (let j = 0; j < i; j++){  \n star += \" \";  \n }  \n for (let k = 1; k <= 5 - i; k++){   \n star += \"*\";  \n }  \n star += \"n\";  \n}  \nconsole.log(star);  \n/*  \n    *****  \n    **** \n    ***  \n    ** \n    * \n*/  \n```\n\n정삼각형 만들기\n\n```js\nlet star = \"\";  \n  \nfor (let i = 1; i <= 5; i++) {  \n for (let k = 5; k >i; k--) {  \n star += \" \";  \n }  \n for (let j =1; j<(i*2); j++) {  \n  \n star += \"*\";  \n }  \n star+=\"n\";  \n}  \nconsole.log(star);  \n  \n/* \n        * \n       *** \n      *****  \n     *******  \n    *********  \n*/  \n```\n\n마름모 만들기 - 1\n\n```js\nlet star = \"\";  \n  \nfor (let i = 1; i <= 5; i++) {  \n for (let k = 5; k >i; k--) {  \n star += \" \";  \n }  \n for (let j =1; j<(i*2); j++) {  \n  \n star += \"*\";  \n }  \n star+=\"n\";  \n}  \nfor (let s = 1; s <= 4; s++){  \n for(let x= 0; x <s; x++){  \n star+=\" \";  \n }  \n for(let q=9; q>s*2; q--){  \n star+=\"*\";  \n }  \n star +=\"n\";  \n}  \n  \nconsole.log(star);  \n/*   \n     *  \n    *** \n   ***** \n  *******  \n *********  \n  *******  \n   ***** \n    *** \n     *  \n*/  \n```\n\n마름모 만들기 - 2\n\n```js  \nlet star=\"\"; // 공백과 별이 들어갈 변수입니다.  \nlet count = 9; // 반복문을 실행시킬 총 값 입니다.  \nlet halfNum = Math.round(count/2);   \n/* count/2 소수점 값 반올림하여 절반 값을 구합니다.  \n(count 값에 홀수,짝수,소수점 값이 와도 일정하게 절반 값을 구합니다.)  \n*/  \nlet space=0;  \n for (let i = 1; i <= count; i++) { // count 값 만큼 반복문을 실행합니다.  \n    \n for(let k=1; k<=halfNum+space; k++){   \n /* 행값입니다 1부터 (halfNum+space)와 같거나 작은 값까지 반복하고.  \n 열(i) 값에 따라 행 값을 1씩 늘리거나 줄일 것입니다.  \n */  \n    \n /*  \n k<= 5(halfNUm) + 0 (space) // k<= 5  \n k<= 5(halfNUm) + 1 (space) // k<= 6  \n k<= 5(halfNUm) + 2 (space) // k<= 7  \n k<= 5(halfNUm) + 3 (space) // k<= 8  \n k<= 5(halfNUm) + 4 (space) // k<= 9  \n k<= 5(halfNum) + 3 (space) // k<= 8  \n k<= 5(halfNum) + 2 (space) // k<= 7  \n k<= 5(halfNum) + 1 (space) // k<= 6  \n k<= 5(halfNum) + 0 (space) // k<= 5  \n */  \n  \n /* k 가 halfNum-spcae값 보다 작을때 true값 \" \"; false값 \"*\"을  \n star값에 저장합니다.  \n */  \n star+= k<halfNum-space ? \" \" : \"*\";  \n /*  \n k< 5(halfNum)-0(space) // k<5 \\\\\\\\F  \n k< 5(halfNum)-1(space) // k<4 \\\\\\FFF  \n k< 5(halfNum)-2(space) // k<3 \\\\FFFFF  \n k< 5(halfNum)-3(space) // k<2 \\FFFFFFF  \n k< 5(halfNum)-4(space) // k<1 FFFFFFFFF  \n k< 5(halfNum)-3(space) // k<2 \\FFFFFFF  \n k< 5(halfNum)-2(space) // k<3 \\\\FFFFF  \n k< 5(halfNum)-1(space) // k<4 \\\\\\FFF  \n k< 5(halfNum)-0(space) // k<5 \\\\\\\\F  \n */  \n }  \n if(i<halfNum){ //i값이 halfNum 값보다 작다면 space++;  \n space++;  \n }else{ // 아닌 경우 space--;  \n space--;  \n }   \n star+=\"n\";  \n}  \nconsole.log(star);  \n```","slug":"자바스크립트 선택문","published":1,"updated":"2020-04-25T09:57:08.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrti003lqgvqhmf54wov","content":"<p>자바스크립트의 선택문(switch)와 반복문(while,for)</p>\n<a id=\"more\"></a>\n\n<hr>\n<h3 id=\"선택문-switch\"><a href=\"#선택문-switch\" class=\"headerlink\" title=\"선택문 switch\"></a>선택문 switch</h3><p>변수에 저장된 값과 switch 문에 있는 경우(case) 값을 검사하여,</p>\n<p>일치하는 값이 있을때 해당하는 실행문을 실행합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (변수)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"number\">1</span>값: 실행문<span class=\"number\">1</span>;   </span><br><span class=\"line\"> <span class=\"comment\">/*변수값이 case값에 일치하는 데이터가 있으면,  </span></span><br><span class=\"line\"><span class=\"comment\"> 해당하는 실행문 실행*/</span>  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>; <span class=\"comment\">//반복문을 강제로 끝내는 break;  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"number\">2</span>값: 실행문<span class=\"number\">2</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"number\">3</span>값: 실행문<span class=\"number\">3</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">default</span>: 실행문<span class=\"number\">4</span>; <span class=\"comment\">//일치하는 값이 없을경우에 실행</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"if-와-switch-차이점\"><a href=\"#if-와-switch-차이점\" class=\"headerlink\" title=\"if 와 switch 차이점\"></a>if 와 switch 차이점</h3><p>if문은 조건이 만족할 때 와 만족하지 않을때를 확인하기 위한 작업이 필요합니다.</p>\n<p>조건식이 많아 질수록 느려 질수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>()&#123; </span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>switch문은 조건의 수를 따지지 않고</p>\n<p>입력된 변수 값을 보고 해당하는 특정 위치로 점프합니다.</p>\n<p>사실 조건식이 3개 이상일시 if보다 switch 빠르다라는 효율적 측면보다.<br><strong>가독성과 코드의 의미를 생각하며 사용하는게 옳다고 합니다.</strong></p>\n<hr>\n<h3 id=\"반복문-while\"><a href=\"#반복문-while\" class=\"headerlink\" title=\"반복문 while\"></a>반복문 while</h3><p>while문은 조건식을 만족(true)할 때까지 실행문을 여러 번 반복하여 실행시킬 수 있습니다.</p>\n<p><code>조건식을 만족할때 까지 {} 내에 실행문을 반복 실행 시킵니다.</code></p>\n<pre><code>while문의 실행 순서는 \n1.조건식을 검사.\n2.조건식 만족시 {}내에 실행문과 증감식을 실행.\n3.증감식 실행후 조건식을 다시 검사.\n--반복\n4.조건식이 거짓(false)값 이면 종료됩니다.</code></pre><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; <span class=\"comment\">// 초기값 선언  </span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(i&lt;=<span class=\"number\">10</span>)&#123; <span class=\"comment\">// i 값이 10보다 작거나 같을때(true) 까지 반복  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"안녕하세요\"</span>+i,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 실행문  </span></span><br><span class=\"line\">i++; <span class=\"comment\">// 증감식  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*   </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요1  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요2  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요3  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요4  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요5  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요6  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요7  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요8  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요9  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요10  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* * *</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">20부터 10까지 숫자 중 짝수을 경우 에는 파란색으로 출력,</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">홀수일 경우에는 빨간색으로 출력되도록 한 예제.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">let</span> i=<span class=\"number\">20</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">while</span>(i&gt;=<span class=\"number\">10</span>)&#123;   </span><br><span class=\"line\"> <span class=\"comment\">// i의 값이 10보다 클 때까지 반복문을 실행.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;   </span><br><span class=\"line\"> <span class=\"comment\">// i의 값을 2로 나눠서 나머지가 0일 경우 (2의 배수)  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"string\">\"&lt;font color='blue'&gt;\"</span>+i+<span class=\"string\">\"&lt;/font&gt;\"</span>, <span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span>&#123;   </span><br><span class=\"line\"> <span class=\"comment\">// 2로 나눠서 나머지가 0이 아닐 경우  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"string\">\"&lt;font color='red'&gt;\"</span>+i+<span class=\"string\">\"&lt;/font&gt;\"</span>, <span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"> i--;   </span><br><span class=\"line\"> <span class=\"comment\">// 감소 연산자 (i값을 1씩 감소 시킴.)  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"for-문\"><a href=\"#for-문\" class=\"headerlink\" title=\"for 문\"></a>for 문</h3><p>for 문은 조건식을 만족할 때까지 실행문을 반복하여 실행합니다.</p>\n<p>while 문보다 편리해 사용 빈도가 높은 편입니다.</p>\n<pre><code>for(초기값;조건식;증감식){\n    실행문;\n}</code></pre><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">10</span>; i++)&#123; <span class=\"comment\">// i=1 , i값이 10까지 1씩 증가하며 반복합니다.  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"string\">\"반복\"</span>+i,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복1  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복2  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복3  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복4  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복5  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복6  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복7  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복8  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복9  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복10  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>for 문을 이용하여 1~100까지 숫자에서 5의 배수일 경우 빨간색,</p>\n<p>7의 배수일 경우 초록색,</p>\n<p>5의 배수이며 7의 배수일 경우 아쿠아색으로 출력한 예제</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> a=<span class=\"number\">1</span>; a&lt;=<span class=\"number\">100</span>; a++)&#123;  <span class=\"comment\">//변수 i가 100이 될 때까지 반복 실행합니다.  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a%<span class=\"number\">7</span>==<span class=\"number\">0</span> &amp;&amp; a%<span class=\"number\">5</span>==<span class=\"number\">0</span>)&#123;   <span class=\"comment\">//5의 배수이고 7의 배수가 인 경우  </span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(<span class=\"string\">\"&lt;font color='aqua'&gt;\"</span>+a+<span class=\"string\">\"&lt;/font&gt;\"</span>,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a%<span class=\"number\">5</span>==<span class=\"number\">0</span>)&#123;       <span class=\"comment\">//5의 배수인 경우  </span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(<span class=\"string\">\"&lt;font color='red'&gt;\"</span>+a+<span class=\"string\">\"&lt;/font&gt;\"</span>,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a%<span class=\"number\">7</span>==<span class=\"number\">0</span>)&#123;       <span class=\"comment\">//7의 배수인 경우  </span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(<span class=\"string\">\"&lt;font color='green'&gt;\"</span>+a+<span class=\"string\">\"&lt;/font&gt;\"</span>,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"continue-문\"><a href=\"#continue-문\" class=\"headerlink\" title=\"continue 문\"></a>continue 문</h3><p>continue 문은 반복문에서만 사용할 수 있습니다.</p>\n<p><code>continue 문 다음에 오는 실행문은 무시하고 실행해</code>라는 뜻입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// for 예시  </span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(초깃값; 조건식; 증감식)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">continue</span>;   </span><br><span class=\"line\"> <span class=\"comment\">//다음에 오는 실행문은 무시하고 증감식으로 이동되 실행됩니다.  </span></span><br><span class=\"line\"> 실행문;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// while 예시  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> 변수=초깃값;  </span><br><span class=\"line\"><span class=\"keyword\">while</span>(조건식)&#123;  </span><br><span class=\"line\">    증감식;  </span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\"><span class=\"comment\">//다음에 오는 실행은 무시하고 조건식으로 이동합니다.  </span></span><br><span class=\"line\">    실행문;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>countinue 실행문 무시 예제</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">10</span>; i++)&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>==<span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;   </span><br><span class=\"line\"> <span class=\"comment\">// i가 2의 배수일때의 실행문은 무시하고 증감식으로 넘어갑니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(i,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">// i값이 2의 배수가 아닌경우에만 실행됩니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"comment\">//1 3 5 7 9  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"중첩-for문으로-구구단-만들기\"><a href=\"#중첩-for문으로-구구단-만들기\" class=\"headerlink\" title=\"중첩 for문으로 구구단 만들기\"></a>중첩 for문으로 구구단 만들기</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">2</span>; i&lt;=<span class=\"number\">9</span>; i++)&#123;  </span><br><span class=\"line\"><span class=\"comment\">// i는 2부터 9까지 1씩 커지게 반복시킵니다.   </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"string\">\"&lt;h1&gt;\"</span>+i+<span class=\"string\">\"단&lt;/h1&gt;\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">// i값+\"단\" 을 h1태그로 묶어 표시합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k=<span class=\"number\">1</span>; k&lt;=<span class=\"number\">9</span>; k++)&#123;  </span><br><span class=\"line\"> <span class=\"comment\">// k는 1부터 9까지 1씩 커지게 반복시킵니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(i+<span class=\"string\">\"X\"</span>+K+<span class=\"string\">\"=\"</span>+i*K,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">/*   </span></span><br><span class=\"line\"><span class=\"comment\">i값 2부터  </span></span><br><span class=\"line\"><span class=\"comment\">k값 1부터 9까지  </span></span><br><span class=\"line\"><span class=\"comment\">i값 9까지 반복 실행되어  </span></span><br><span class=\"line\"><span class=\"comment\">   </span></span><br><span class=\"line\"><span class=\"comment\">i값+\"X\"+K값+\"=\" 이   </span></span><br><span class=\"line\"><span class=\"comment\">2X1 부터 순차적으로 실행되며  </span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\">+i*k 는 각 값의 곱셈이 실행됩니다.  </span></span><br><span class=\"line\"><span class=\"comment\">   </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* * *</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 현재 연도와 월에 맞는 전체 일자 출력하기</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"comment\">//현재 년도와 월을 입력받습니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> year=prompt(<span class=\"string\">\"현재 몇 년 입니까?\"</span>,<span class=\"string\">\"0000\"</span>);   </span><br><span class=\"line\"><span class=\"keyword\">const</span> mon=prompt(<span class=\"string\">\"현재 몇 월 입니까?\"</span>,<span class=\"string\">\"0\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> last_day;  </span><br><span class=\"line\"><span class=\"comment\">/*현재 월이 몇일까지 있는지 선택문을  </span></span><br><span class=\"line\"><span class=\"comment\">이용해 구합니다.*/</span>  </span><br><span class=\"line\"><span class=\"keyword\">switch</span> (mon)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"1\"</span> : last_day=<span class=\"number\">31</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"2\"</span> : last_day=<span class=\"number\">28</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">/*현재 년도가 4년주기이고 100년 주기는 아닌경우  </span></span><br><span class=\"line\"><span class=\"comment\"> 또는 400년 주기로 윤년이므로 2월은 29일까지 있습니다.*/</span>  </span><br><span class=\"line\"> <span class=\"keyword\">if</span>(year % <span class=\"number\">4</span>==<span class=\"number\">0</span> &amp;&amp; year % <span class=\"number\">100</span> !=<span class=\"number\">0</span> || year % <span class=\"number\">400</span> ==<span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\"> last_day=<span class=\"number\">29</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"3\"</span>: last_day=<span class=\"number\">31</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"4\"</span>: last_day=<span class=\"number\">30</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"5\"</span>: last_day=<span class=\"number\">31</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"6\"</span>: last_day=<span class=\"number\">30</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"7\"</span>: last_day=<span class=\"number\">31</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"8\"</span>: last_day=<span class=\"number\">31</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"9\"</span>: last_day=<span class=\"number\">30</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"10\"</span>: last_day=<span class=\"number\">31</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"11\"</span>: last_day=<span class=\"number\">30</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"12\"</span>: last_day=<span class=\"number\">31</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=last_day; i++)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(i+<span class=\"string\">\" \"</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"자바스크립트-for-이용한-별-찍기\"><a href=\"#자바스크립트-for-이용한-별-찍기\" class=\"headerlink\" title=\"자바스크립트 for 이용한 별 찍기\"></a>자바스크립트 for 이용한 별 찍기</h3><p>직각삼각형 만들기</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> star=<span class=\"string\">\"\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++)&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\"> star +=<span class=\"string\">\"*\"</span>;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(star);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">    * </span></span><br><span class=\"line\"><span class=\"comment\">    **  </span></span><br><span class=\"line\"><span class=\"comment\">    *** </span></span><br><span class=\"line\"><span class=\"comment\">    ****  </span></span><br><span class=\"line\"><span class=\"comment\">    *****  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>역 직각 삼각형 만들기</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> star = <span class=\"string\">\"\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; i; j++)&#123;  </span><br><span class=\"line\"> star += <span class=\"string\">\" \"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">1</span>; k &lt;= <span class=\"number\">5</span> - i; k++)&#123;   </span><br><span class=\"line\"> star += <span class=\"string\">\"*\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> star += <span class=\"string\">\"n\"</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(star);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">    *****  </span></span><br><span class=\"line\"><span class=\"comment\">    **** </span></span><br><span class=\"line\"><span class=\"comment\">    ***  </span></span><br><span class=\"line\"><span class=\"comment\">    ** </span></span><br><span class=\"line\"><span class=\"comment\">    * </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>정삼각형 만들기</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> star = <span class=\"string\">\"\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">5</span>; k &gt;i; k--) &#123;  </span><br><span class=\"line\"> star += <span class=\"string\">\" \"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j =<span class=\"number\">1</span>; j&lt;(i*<span class=\"number\">2</span>); j++) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\"> star += <span class=\"string\">\"*\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> star+=<span class=\"string\">\"n\"</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(star);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">        * </span></span><br><span class=\"line\"><span class=\"comment\">       *** </span></span><br><span class=\"line\"><span class=\"comment\">      *****  </span></span><br><span class=\"line\"><span class=\"comment\">     *******  </span></span><br><span class=\"line\"><span class=\"comment\">    *********  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>마름모 만들기 - 1</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> star = <span class=\"string\">\"\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">5</span>; k &gt;i; k--) &#123;  </span><br><span class=\"line\"> star += <span class=\"string\">\" \"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j =<span class=\"number\">1</span>; j&lt;(i*<span class=\"number\">2</span>); j++) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\"> star += <span class=\"string\">\"*\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> star+=<span class=\"string\">\"n\"</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> s = <span class=\"number\">1</span>; s &lt;= <span class=\"number\">4</span>; s++)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> x= <span class=\"number\">0</span>; x &lt;s; x++)&#123;  </span><br><span class=\"line\"> star+=<span class=\"string\">\" \"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> q=<span class=\"number\">9</span>; q&gt;s*<span class=\"number\">2</span>; q--)&#123;  </span><br><span class=\"line\"> star+=<span class=\"string\">\"*\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> star +=<span class=\"string\">\"n\"</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(star);  </span><br><span class=\"line\"><span class=\"comment\">/*   </span></span><br><span class=\"line\"><span class=\"comment\">     *  </span></span><br><span class=\"line\"><span class=\"comment\">    *** </span></span><br><span class=\"line\"><span class=\"comment\">   ***** </span></span><br><span class=\"line\"><span class=\"comment\">  *******  </span></span><br><span class=\"line\"><span class=\"comment\"> *********  </span></span><br><span class=\"line\"><span class=\"comment\">  *******  </span></span><br><span class=\"line\"><span class=\"comment\">   ***** </span></span><br><span class=\"line\"><span class=\"comment\">    *** </span></span><br><span class=\"line\"><span class=\"comment\">     *  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>마름모 만들기 - 2</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> star=<span class=\"string\">\"\"</span>; <span class=\"comment\">// 공백과 별이 들어갈 변수입니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> count = <span class=\"number\">9</span>; <span class=\"comment\">// 반복문을 실행시킬 총 값 입니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> halfNum = <span class=\"built_in\">Math</span>.round(count/<span class=\"number\">2</span>);   </span><br><span class=\"line\"><span class=\"comment\">/* count/2 소수점 값 반올림하여 절반 값을 구합니다.  </span></span><br><span class=\"line\"><span class=\"comment\">(count 값에 홀수,짝수,소수점 값이 와도 일정하게 절반 값을 구합니다.)  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"><span class=\"keyword\">let</span> space=<span class=\"number\">0</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= count; i++) &#123; <span class=\"comment\">// count 값 만큼 반복문을 실행합니다.  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k=<span class=\"number\">1</span>; k&lt;=halfNum+space; k++)&#123;   </span><br><span class=\"line\"> <span class=\"comment\">/* 행값입니다 1부터 (halfNum+space)와 같거나 작은 값까지 반복하고.  </span></span><br><span class=\"line\"><span class=\"comment\"> 열(i) 값에 따라 행 값을 1씩 늘리거나 줄일 것입니다.  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNUm) + 0 (space) // k&lt;= 5  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNUm) + 1 (space) // k&lt;= 6  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNUm) + 2 (space) // k&lt;= 7  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNUm) + 3 (space) // k&lt;= 8  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNUm) + 4 (space) // k&lt;= 9  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNum) + 3 (space) // k&lt;= 8  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNum) + 2 (space) // k&lt;= 7  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNum) + 1 (space) // k&lt;= 6  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNum) + 0 (space) // k&lt;= 5  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"comment\">/* k 가 halfNum-spcae값 보다 작을때 true값 \" \"; false값 \"*\"을  </span></span><br><span class=\"line\"><span class=\"comment\"> star값에 저장합니다.  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"> star+= k&lt;halfNum-space ? <span class=\"string\">\" \"</span> : <span class=\"string\">\"*\"</span>;  </span><br><span class=\"line\"> <span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-0(space) // k&lt;5 \\\\\\\\F  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-1(space) // k&lt;4 \\\\\\FFF  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-2(space) // k&lt;3 \\\\FFFFF  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-3(space) // k&lt;2 \\FFFFFFF  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-4(space) // k&lt;1 FFFFFFFFF  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-3(space) // k&lt;2 \\FFFFFFF  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-2(space) // k&lt;3 \\\\FFFFF  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-1(space) // k&lt;4 \\\\\\FFF  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-0(space) // k&lt;5 \\\\\\\\F  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">if</span>(i&lt;halfNum)&#123; <span class=\"comment\">//i값이 halfNum 값보다 작다면 space++;  </span></span><br><span class=\"line\"> space++;  </span><br><span class=\"line\"> &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 아닌 경우 space--;  </span></span><br><span class=\"line\"> space--;  </span><br><span class=\"line\"> &#125;   </span><br><span class=\"line\"> star+=<span class=\"string\">\"n\"</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(star);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>자바스크립트의 선택문(switch)와 반복문(while,for)</p>","more":"<hr>\n<h3 id=\"선택문-switch\"><a href=\"#선택문-switch\" class=\"headerlink\" title=\"선택문 switch\"></a>선택문 switch</h3><p>변수에 저장된 값과 switch 문에 있는 경우(case) 값을 검사하여,</p>\n<p>일치하는 값이 있을때 해당하는 실행문을 실행합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (변수)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"number\">1</span>값: 실행문<span class=\"number\">1</span>;   </span><br><span class=\"line\"> <span class=\"comment\">/*변수값이 case값에 일치하는 데이터가 있으면,  </span></span><br><span class=\"line\"><span class=\"comment\"> 해당하는 실행문 실행*/</span>  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>; <span class=\"comment\">//반복문을 강제로 끝내는 break;  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"number\">2</span>값: 실행문<span class=\"number\">2</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"number\">3</span>값: 실행문<span class=\"number\">3</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">default</span>: 실행문<span class=\"number\">4</span>; <span class=\"comment\">//일치하는 값이 없을경우에 실행</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"if-와-switch-차이점\"><a href=\"#if-와-switch-차이점\" class=\"headerlink\" title=\"if 와 switch 차이점\"></a>if 와 switch 차이점</h3><p>if문은 조건이 만족할 때 와 만족하지 않을때를 확인하기 위한 작업이 필요합니다.</p>\n<p>조건식이 많아 질수록 느려 질수 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>()&#123; </span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>switch문은 조건의 수를 따지지 않고</p>\n<p>입력된 변수 값을 보고 해당하는 특정 위치로 점프합니다.</p>\n<p>사실 조건식이 3개 이상일시 if보다 switch 빠르다라는 효율적 측면보다.<br><strong>가독성과 코드의 의미를 생각하며 사용하는게 옳다고 합니다.</strong></p>\n<hr>\n<h3 id=\"반복문-while\"><a href=\"#반복문-while\" class=\"headerlink\" title=\"반복문 while\"></a>반복문 while</h3><p>while문은 조건식을 만족(true)할 때까지 실행문을 여러 번 반복하여 실행시킬 수 있습니다.</p>\n<p><code>조건식을 만족할때 까지 {} 내에 실행문을 반복 실행 시킵니다.</code></p>\n<pre><code>while문의 실행 순서는 \n1.조건식을 검사.\n2.조건식 만족시 {}내에 실행문과 증감식을 실행.\n3.증감식 실행후 조건식을 다시 검사.\n--반복\n4.조건식이 거짓(false)값 이면 종료됩니다.</code></pre><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; <span class=\"comment\">// 초기값 선언  </span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(i&lt;=<span class=\"number\">10</span>)&#123; <span class=\"comment\">// i 값이 10보다 작거나 같을때(true) 까지 반복  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"안녕하세요\"</span>+i,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 실행문  </span></span><br><span class=\"line\">i++; <span class=\"comment\">// 증감식  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*   </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요1  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요2  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요3  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요4  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요5  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요6  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요7  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요8  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요9  </span></span><br><span class=\"line\"><span class=\"comment\"> 안녕하세요10  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* * *</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">20부터 10까지 숫자 중 짝수을 경우 에는 파란색으로 출력,</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">홀수일 경우에는 빨간색으로 출력되도록 한 예제.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">let</span> i=<span class=\"number\">20</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">while</span>(i&gt;=<span class=\"number\">10</span>)&#123;   </span><br><span class=\"line\"> <span class=\"comment\">// i의 값이 10보다 클 때까지 반복문을 실행.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;   </span><br><span class=\"line\"> <span class=\"comment\">// i의 값을 2로 나눠서 나머지가 0일 경우 (2의 배수)  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"string\">\"&lt;font color='blue'&gt;\"</span>+i+<span class=\"string\">\"&lt;/font&gt;\"</span>, <span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span>&#123;   </span><br><span class=\"line\"> <span class=\"comment\">// 2로 나눠서 나머지가 0이 아닐 경우  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"string\">\"&lt;font color='red'&gt;\"</span>+i+<span class=\"string\">\"&lt;/font&gt;\"</span>, <span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"> i--;   </span><br><span class=\"line\"> <span class=\"comment\">// 감소 연산자 (i값을 1씩 감소 시킴.)  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"for-문\"><a href=\"#for-문\" class=\"headerlink\" title=\"for 문\"></a>for 문</h3><p>for 문은 조건식을 만족할 때까지 실행문을 반복하여 실행합니다.</p>\n<p>while 문보다 편리해 사용 빈도가 높은 편입니다.</p>\n<pre><code>for(초기값;조건식;증감식){\n    실행문;\n}</code></pre><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">10</span>; i++)&#123; <span class=\"comment\">// i=1 , i값이 10까지 1씩 증가하며 반복합니다.  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"string\">\"반복\"</span>+i,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복1  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복2  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복3  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복4  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복5  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복6  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복7  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복8  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복9  </span></span><br><span class=\"line\"><span class=\"comment\"> 반복10  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>for 문을 이용하여 1~100까지 숫자에서 5의 배수일 경우 빨간색,</p>\n<p>7의 배수일 경우 초록색,</p>\n<p>5의 배수이며 7의 배수일 경우 아쿠아색으로 출력한 예제</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> a=<span class=\"number\">1</span>; a&lt;=<span class=\"number\">100</span>; a++)&#123;  <span class=\"comment\">//변수 i가 100이 될 때까지 반복 실행합니다.  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a%<span class=\"number\">7</span>==<span class=\"number\">0</span> &amp;&amp; a%<span class=\"number\">5</span>==<span class=\"number\">0</span>)&#123;   <span class=\"comment\">//5의 배수이고 7의 배수가 인 경우  </span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(<span class=\"string\">\"&lt;font color='aqua'&gt;\"</span>+a+<span class=\"string\">\"&lt;/font&gt;\"</span>,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a%<span class=\"number\">5</span>==<span class=\"number\">0</span>)&#123;       <span class=\"comment\">//5의 배수인 경우  </span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(<span class=\"string\">\"&lt;font color='red'&gt;\"</span>+a+<span class=\"string\">\"&lt;/font&gt;\"</span>,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a%<span class=\"number\">7</span>==<span class=\"number\">0</span>)&#123;       <span class=\"comment\">//7의 배수인 경우  </span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(<span class=\"string\">\"&lt;font color='green'&gt;\"</span>+a+<span class=\"string\">\"&lt;/font&gt;\"</span>,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"continue-문\"><a href=\"#continue-문\" class=\"headerlink\" title=\"continue 문\"></a>continue 문</h3><p>continue 문은 반복문에서만 사용할 수 있습니다.</p>\n<p><code>continue 문 다음에 오는 실행문은 무시하고 실행해</code>라는 뜻입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// for 예시  </span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(초깃값; 조건식; 증감식)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">continue</span>;   </span><br><span class=\"line\"> <span class=\"comment\">//다음에 오는 실행문은 무시하고 증감식으로 이동되 실행됩니다.  </span></span><br><span class=\"line\"> 실행문;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">// while 예시  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> 변수=초깃값;  </span><br><span class=\"line\"><span class=\"keyword\">while</span>(조건식)&#123;  </span><br><span class=\"line\">    증감식;  </span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\"><span class=\"comment\">//다음에 오는 실행은 무시하고 조건식으로 이동합니다.  </span></span><br><span class=\"line\">    실행문;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>countinue 실행문 무시 예제</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">10</span>; i++)&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>==<span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;   </span><br><span class=\"line\"> <span class=\"comment\">// i가 2의 배수일때의 실행문은 무시하고 증감식으로 넘어갑니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(i,<span class=\"string\">\"&lt;br /&gt;\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">// i값이 2의 배수가 아닌경우에만 실행됩니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"comment\">//1 3 5 7 9  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"중첩-for문으로-구구단-만들기\"><a href=\"#중첩-for문으로-구구단-만들기\" class=\"headerlink\" title=\"중첩 for문으로 구구단 만들기\"></a>중첩 for문으로 구구단 만들기</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">2</span>; i&lt;=<span class=\"number\">9</span>; i++)&#123;  </span><br><span class=\"line\"><span class=\"comment\">// i는 2부터 9까지 1씩 커지게 반복시킵니다.   </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(<span class=\"string\">\"&lt;h1&gt;\"</span>+i+<span class=\"string\">\"단&lt;/h1&gt;\"</span>);  </span><br><span class=\"line\"> <span class=\"comment\">// i값+\"단\" 을 h1태그로 묶어 표시합니다.  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k=<span class=\"number\">1</span>; k&lt;=<span class=\"number\">9</span>; k++)&#123;  </span><br><span class=\"line\"> <span class=\"comment\">// k는 1부터 9까지 1씩 커지게 반복시킵니다.  </span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(i+<span class=\"string\">\"X\"</span>+K+<span class=\"string\">\"=\"</span>+i*K,<span class=\"string\">\"&lt;br/&gt;\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">/*   </span></span><br><span class=\"line\"><span class=\"comment\">i값 2부터  </span></span><br><span class=\"line\"><span class=\"comment\">k값 1부터 9까지  </span></span><br><span class=\"line\"><span class=\"comment\">i값 9까지 반복 실행되어  </span></span><br><span class=\"line\"><span class=\"comment\">   </span></span><br><span class=\"line\"><span class=\"comment\">i값+\"X\"+K값+\"=\" 이   </span></span><br><span class=\"line\"><span class=\"comment\">2X1 부터 순차적으로 실행되며  </span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\">+i*k 는 각 값의 곱셈이 실행됩니다.  </span></span><br><span class=\"line\"><span class=\"comment\">   </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* * *</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 현재 연도와 월에 맞는 전체 일자 출력하기</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"comment\">//현재 년도와 월을 입력받습니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> year=prompt(<span class=\"string\">\"현재 몇 년 입니까?\"</span>,<span class=\"string\">\"0000\"</span>);   </span><br><span class=\"line\"><span class=\"keyword\">const</span> mon=prompt(<span class=\"string\">\"현재 몇 월 입니까?\"</span>,<span class=\"string\">\"0\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">let</span> last_day;  </span><br><span class=\"line\"><span class=\"comment\">/*현재 월이 몇일까지 있는지 선택문을  </span></span><br><span class=\"line\"><span class=\"comment\">이용해 구합니다.*/</span>  </span><br><span class=\"line\"><span class=\"keyword\">switch</span> (mon)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"1\"</span> : last_day=<span class=\"number\">31</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"2\"</span> : last_day=<span class=\"number\">28</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">/*현재 년도가 4년주기이고 100년 주기는 아닌경우  </span></span><br><span class=\"line\"><span class=\"comment\"> 또는 400년 주기로 윤년이므로 2월은 29일까지 있습니다.*/</span>  </span><br><span class=\"line\"> <span class=\"keyword\">if</span>(year % <span class=\"number\">4</span>==<span class=\"number\">0</span> &amp;&amp; year % <span class=\"number\">100</span> !=<span class=\"number\">0</span> || year % <span class=\"number\">400</span> ==<span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\"> last_day=<span class=\"number\">29</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"3\"</span>: last_day=<span class=\"number\">31</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"4\"</span>: last_day=<span class=\"number\">30</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"5\"</span>: last_day=<span class=\"number\">31</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"6\"</span>: last_day=<span class=\"number\">30</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"7\"</span>: last_day=<span class=\"number\">31</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"8\"</span>: last_day=<span class=\"number\">31</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"9\"</span>: last_day=<span class=\"number\">30</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"10\"</span>: last_day=<span class=\"number\">31</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"11\"</span>: last_day=<span class=\"number\">30</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"string\">\"12\"</span>: last_day=<span class=\"number\">31</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=last_day; i++)&#123;  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(i+<span class=\"string\">\" \"</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"자바스크립트-for-이용한-별-찍기\"><a href=\"#자바스크립트-for-이용한-별-찍기\" class=\"headerlink\" title=\"자바스크립트 for 이용한 별 찍기\"></a>자바스크립트 for 이용한 별 찍기</h3><p>직각삼각형 만들기</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> star=<span class=\"string\">\"\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++)&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\"> star +=<span class=\"string\">\"*\"</span>;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(star);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">    * </span></span><br><span class=\"line\"><span class=\"comment\">    **  </span></span><br><span class=\"line\"><span class=\"comment\">    *** </span></span><br><span class=\"line\"><span class=\"comment\">    ****  </span></span><br><span class=\"line\"><span class=\"comment\">    *****  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>역 직각 삼각형 만들기</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> star = <span class=\"string\">\"\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; i; j++)&#123;  </span><br><span class=\"line\"> star += <span class=\"string\">\" \"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">1</span>; k &lt;= <span class=\"number\">5</span> - i; k++)&#123;   </span><br><span class=\"line\"> star += <span class=\"string\">\"*\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> star += <span class=\"string\">\"n\"</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(star);  </span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">    *****  </span></span><br><span class=\"line\"><span class=\"comment\">    **** </span></span><br><span class=\"line\"><span class=\"comment\">    ***  </span></span><br><span class=\"line\"><span class=\"comment\">    ** </span></span><br><span class=\"line\"><span class=\"comment\">    * </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>정삼각형 만들기</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> star = <span class=\"string\">\"\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">5</span>; k &gt;i; k--) &#123;  </span><br><span class=\"line\"> star += <span class=\"string\">\" \"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j =<span class=\"number\">1</span>; j&lt;(i*<span class=\"number\">2</span>); j++) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\"> star += <span class=\"string\">\"*\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> star+=<span class=\"string\">\"n\"</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(star);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">        * </span></span><br><span class=\"line\"><span class=\"comment\">       *** </span></span><br><span class=\"line\"><span class=\"comment\">      *****  </span></span><br><span class=\"line\"><span class=\"comment\">     *******  </span></span><br><span class=\"line\"><span class=\"comment\">    *********  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>마름모 만들기 - 1</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> star = <span class=\"string\">\"\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">5</span>; k &gt;i; k--) &#123;  </span><br><span class=\"line\"> star += <span class=\"string\">\" \"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j =<span class=\"number\">1</span>; j&lt;(i*<span class=\"number\">2</span>); j++) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\"> star += <span class=\"string\">\"*\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> star+=<span class=\"string\">\"n\"</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> s = <span class=\"number\">1</span>; s &lt;= <span class=\"number\">4</span>; s++)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> x= <span class=\"number\">0</span>; x &lt;s; x++)&#123;  </span><br><span class=\"line\"> star+=<span class=\"string\">\" \"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> q=<span class=\"number\">9</span>; q&gt;s*<span class=\"number\">2</span>; q--)&#123;  </span><br><span class=\"line\"> star+=<span class=\"string\">\"*\"</span>;  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> star +=<span class=\"string\">\"n\"</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(star);  </span><br><span class=\"line\"><span class=\"comment\">/*   </span></span><br><span class=\"line\"><span class=\"comment\">     *  </span></span><br><span class=\"line\"><span class=\"comment\">    *** </span></span><br><span class=\"line\"><span class=\"comment\">   ***** </span></span><br><span class=\"line\"><span class=\"comment\">  *******  </span></span><br><span class=\"line\"><span class=\"comment\"> *********  </span></span><br><span class=\"line\"><span class=\"comment\">  *******  </span></span><br><span class=\"line\"><span class=\"comment\">   ***** </span></span><br><span class=\"line\"><span class=\"comment\">    *** </span></span><br><span class=\"line\"><span class=\"comment\">     *  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>마름모 만들기 - 2</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> star=<span class=\"string\">\"\"</span>; <span class=\"comment\">// 공백과 별이 들어갈 변수입니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> count = <span class=\"number\">9</span>; <span class=\"comment\">// 반복문을 실행시킬 총 값 입니다.  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> halfNum = <span class=\"built_in\">Math</span>.round(count/<span class=\"number\">2</span>);   </span><br><span class=\"line\"><span class=\"comment\">/* count/2 소수점 값 반올림하여 절반 값을 구합니다.  </span></span><br><span class=\"line\"><span class=\"comment\">(count 값에 홀수,짝수,소수점 값이 와도 일정하게 절반 값을 구합니다.)  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"><span class=\"keyword\">let</span> space=<span class=\"number\">0</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= count; i++) &#123; <span class=\"comment\">// count 값 만큼 반복문을 실행합니다.  </span></span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k=<span class=\"number\">1</span>; k&lt;=halfNum+space; k++)&#123;   </span><br><span class=\"line\"> <span class=\"comment\">/* 행값입니다 1부터 (halfNum+space)와 같거나 작은 값까지 반복하고.  </span></span><br><span class=\"line\"><span class=\"comment\"> 열(i) 값에 따라 행 값을 1씩 늘리거나 줄일 것입니다.  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNUm) + 0 (space) // k&lt;= 5  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNUm) + 1 (space) // k&lt;= 6  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNUm) + 2 (space) // k&lt;= 7  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNUm) + 3 (space) // k&lt;= 8  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNUm) + 4 (space) // k&lt;= 9  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNum) + 3 (space) // k&lt;= 8  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNum) + 2 (space) // k&lt;= 7  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNum) + 1 (space) // k&lt;= 6  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt;= 5(halfNum) + 0 (space) // k&lt;= 5  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"comment\">/* k 가 halfNum-spcae값 보다 작을때 true값 \" \"; false값 \"*\"을  </span></span><br><span class=\"line\"><span class=\"comment\"> star값에 저장합니다.  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"> star+= k&lt;halfNum-space ? <span class=\"string\">\" \"</span> : <span class=\"string\">\"*\"</span>;  </span><br><span class=\"line\"> <span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-0(space) // k&lt;5 \\\\\\\\F  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-1(space) // k&lt;4 \\\\\\FFF  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-2(space) // k&lt;3 \\\\FFFFF  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-3(space) // k&lt;2 \\FFFFFFF  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-4(space) // k&lt;1 FFFFFFFFF  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-3(space) // k&lt;2 \\FFFFFFF  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-2(space) // k&lt;3 \\\\FFFFF  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-1(space) // k&lt;4 \\\\\\FFF  </span></span><br><span class=\"line\"><span class=\"comment\"> k&lt; 5(halfNum)-0(space) // k&lt;5 \\\\\\\\F  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\"> <span class=\"keyword\">if</span>(i&lt;halfNum)&#123; <span class=\"comment\">//i값이 halfNum 값보다 작다면 space++;  </span></span><br><span class=\"line\"> space++;  </span><br><span class=\"line\"> &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 아닌 경우 space--;  </span></span><br><span class=\"line\"> space--;  </span><br><span class=\"line\"> &#125;   </span><br><span class=\"line\"> star+=<span class=\"string\">\"n\"</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(star);</span><br></pre></td></tr></table></figure>"},{"title":"자바스크립트 연산자","date":"2020-02-24T02:15:36.000Z","disqusId":"tunas-blog-1","_content":"\n* * *\n\n### 1. 산술 연산자\n\n\n##### + , - , * , / , %\n\n```js\nlet num1 = 15;  \nlet num2 = 2;  \n  \nlet result;  \nresult=num+num2; // 더하기  \ndocument.write(result,\"<br />\"); // 17  \n  \nresult=num-num2; // 빼기  \ndocument.write(result,\"<br />\"); // 13  \n  \nresult=num*num2; // 곱하기  \ndocument.write(result,\"<br />\"); // 30  \n  \nresult=num/num2; // 나누기  \ndocument.write(result,\"<br />\"); // 7.5  \n  \nresult=num%num2; // 나머지  \ndocument.write(result,\"<br />\"); // 1  \n```\n\n<!-- more -->\n\n* * *\n\n### 2. 문자 결합 연산자\n\n\n    문자형데이터+문자형데이터 = 문자형데이터\n    문자형데이터+숫자형데이터 = 문자형데이터\n\n```js\nlet t1=\"학교종이\"; //문자형 데이터 저장  \nlet t2=\"떙떙땡\"; //문자형 데이터 저장  \nlet t3=8282; //숫자형 데이터 저장  \nlet t4=\"어서 모이자\"; //문자형 데이터 저장  \nlet result;  \n  \nresult=t1+t2+t3+t4;  \ndocument.write(result);  \n//학교종이땡땡땡8282어서 모이자  \n```\n\n* * *\n\n### 3. 대입 연산자\n\n\n    대입 연사자의 종류\n    A = B  (A = B)\n    A += B (A = A+B)\n    A *+ B (A = A*B)\n    A / B  (A = A/B)\n    A %= B (A = A%B)\n\n#### 예시\n\n```\nlet num1=10;  \nlet num2=3;  \n  \nnum1+=num2; // num1= num1(10) + num2(3) =13; num1에 저장  \ndocument.write(num1,\"<br/>\"); //num1에 저장된 값 출력  \nnum1-=num2; // num1= num1(13) - num2(3) =10; num1에 저장  \ndocument.write(num1,\"<br/>\");  \nnum1*=num2; // num1= num1(10) * num2(3) =30; num1에 저장  \ndocument.write(num1,\"<br/>\");  \nnum1%=num2; // num1= num1(30) % num2(3) =0 num1에 저장  \ndocument.write(num1,\"<br/>\");  \n```\n\n* * *\n\n#### 문자형 데이터로 저장된 HTML태그 연산자로 결합하기\n\n```js\nlet t =\"<table border='1'>\";  \n t+=\"<tr>\";  \n t+=\"<td>1</td><td>2</td><td>3</td>\";  \n t+=\"</tr>\";  \n t+=\"</table>\";  \n document.write(t);  \n  \n//t=\"<table border='1'>\"<tr><td>1</td><td>2</td><td>3</td></tr></table>  \n```\n\n* * *\n\n### 4. 증감 연산자\n\n\n증감 연산자에는  \n숫자형 데이터를 1씩 증가시키는 ++연산자가 있고  \n1씩 감소시키는 –연산자가 있습니다.\n\n```js\nlet a=++b // 변수 b의 값을 1 증가 시킨후 a에 저장합니다. (증가가 먼저)  \nlet a=b++ // 변수 a에 변수b값을 저장한후 변수b의 데이터를 1 증가시킵니다. (대입이먼저)  \n```\n\n* * *\n\n### 5. 비교 연산자\n\n\n    A>B  A는B보다 크다.\n    A<B  A는B보디 작다.\n    A>=B A는B보다 크거나 같다.\n    A<=B A는B보다 작거나 같다.\n    \n    A==B  A와B는 같다.   (데이터 형과 문자형을 상관X, A=10 B=\"10\" 이라면 true값)\n    A!=B  A와B는 다르다. (데이터 형과 문자형을 상관X, A=10 B=\"10\" 이라면 false값)\n    \n    A===B A와B는 같다.   (데이터 형과 문자형을 구분, A=10 B=\"10\" 이라면 false값)\n    A!==B A와B는 다르다. (데이터 형과 문자형을 구분, A=10 B=\"10\" 이라면 true값)\n\n```js\nlet a =10; //a값 10  \nlet b =20; //b값 20  \nlet c =10; //c값 10  \nlet f =\"20\"; //d값 문자형\"20\"  \nlet result;  \n  \nresult=a>b;   //false  \nresult=a<b;   //true  \nresult=a<=b;  //true  \nresult=b==f;  //true  \nresult=a!=b;  //true  \nresult=b===f; //false  \n```\n\n* * *\n\n### 6. 논리 연산자\n\n* * *\n\n#### 논리 연산자에는 ||(or), &&(and) , !(not)가 있습니다.\n\n* * *\n\n##### 1. ||\n\nor 연산자라고 부르며, 피연산자 중 값이 하나라도 true이면 true값 반환.\n\n* * *\n\n##### 2. &&\n\nand 연산자라고 부르며, 피연산자 중 값이 하나라도 false이면 false값 반환.\n\n* * *\n\n##### 3. !\n\nnot 연산자라고 부르며, 단항 연산자입니다. 피연산자의 값이 true이면 반대로 false값 반환.\n\n* * *\n\n### 7. 삼향 조건 연산자\n\n조건식(true,false) 데이터 결과값에 따라 스크립트 코드를 다르게 실행할때 사용.\n\n    기본형\n    조건식? 실행문1 : 실행문2;\n    true값일 시 실행문1 실행, false값일 시 실행문2 실행\n\n```js\nconst a=10;  \nconst b=3;  \n  \nconst result=a>b? \"javascript\" : \"hello\";  \ndocument.write(result);  \n//10>3=true 값 이므로 실행문 1인 \"javascript\"를 훌력  \n```\n\n* * *\n\n### 연산자 우선순위\n\n1.  ()\n2.  단항 연산자(–,++,!)\n3.  산술 연산자(*,/,%,+,-)\n4.  비교 연산자(>,>=,<,<=,==,===,!==)\n5.  논리 연산자(&&,||)\n6.  대입(복합 대입) 연산자(=,+=,-=,*=,/=,%=)","source":"_posts/자바스크립트 연산자.md","raw":"---\ntitle: 자바스크립트 연산자\ndate: 2020-02-24 11:15:36\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\n* * *\n\n### 1. 산술 연산자\n\n\n##### + , - , * , / , %\n\n```js\nlet num1 = 15;  \nlet num2 = 2;  \n  \nlet result;  \nresult=num+num2; // 더하기  \ndocument.write(result,\"<br />\"); // 17  \n  \nresult=num-num2; // 빼기  \ndocument.write(result,\"<br />\"); // 13  \n  \nresult=num*num2; // 곱하기  \ndocument.write(result,\"<br />\"); // 30  \n  \nresult=num/num2; // 나누기  \ndocument.write(result,\"<br />\"); // 7.5  \n  \nresult=num%num2; // 나머지  \ndocument.write(result,\"<br />\"); // 1  \n```\n\n<!-- more -->\n\n* * *\n\n### 2. 문자 결합 연산자\n\n\n    문자형데이터+문자형데이터 = 문자형데이터\n    문자형데이터+숫자형데이터 = 문자형데이터\n\n```js\nlet t1=\"학교종이\"; //문자형 데이터 저장  \nlet t2=\"떙떙땡\"; //문자형 데이터 저장  \nlet t3=8282; //숫자형 데이터 저장  \nlet t4=\"어서 모이자\"; //문자형 데이터 저장  \nlet result;  \n  \nresult=t1+t2+t3+t4;  \ndocument.write(result);  \n//학교종이땡땡땡8282어서 모이자  \n```\n\n* * *\n\n### 3. 대입 연산자\n\n\n    대입 연사자의 종류\n    A = B  (A = B)\n    A += B (A = A+B)\n    A *+ B (A = A*B)\n    A / B  (A = A/B)\n    A %= B (A = A%B)\n\n#### 예시\n\n```\nlet num1=10;  \nlet num2=3;  \n  \nnum1+=num2; // num1= num1(10) + num2(3) =13; num1에 저장  \ndocument.write(num1,\"<br/>\"); //num1에 저장된 값 출력  \nnum1-=num2; // num1= num1(13) - num2(3) =10; num1에 저장  \ndocument.write(num1,\"<br/>\");  \nnum1*=num2; // num1= num1(10) * num2(3) =30; num1에 저장  \ndocument.write(num1,\"<br/>\");  \nnum1%=num2; // num1= num1(30) % num2(3) =0 num1에 저장  \ndocument.write(num1,\"<br/>\");  \n```\n\n* * *\n\n#### 문자형 데이터로 저장된 HTML태그 연산자로 결합하기\n\n```js\nlet t =\"<table border='1'>\";  \n t+=\"<tr>\";  \n t+=\"<td>1</td><td>2</td><td>3</td>\";  \n t+=\"</tr>\";  \n t+=\"</table>\";  \n document.write(t);  \n  \n//t=\"<table border='1'>\"<tr><td>1</td><td>2</td><td>3</td></tr></table>  \n```\n\n* * *\n\n### 4. 증감 연산자\n\n\n증감 연산자에는  \n숫자형 데이터를 1씩 증가시키는 ++연산자가 있고  \n1씩 감소시키는 –연산자가 있습니다.\n\n```js\nlet a=++b // 변수 b의 값을 1 증가 시킨후 a에 저장합니다. (증가가 먼저)  \nlet a=b++ // 변수 a에 변수b값을 저장한후 변수b의 데이터를 1 증가시킵니다. (대입이먼저)  \n```\n\n* * *\n\n### 5. 비교 연산자\n\n\n    A>B  A는B보다 크다.\n    A<B  A는B보디 작다.\n    A>=B A는B보다 크거나 같다.\n    A<=B A는B보다 작거나 같다.\n    \n    A==B  A와B는 같다.   (데이터 형과 문자형을 상관X, A=10 B=\"10\" 이라면 true값)\n    A!=B  A와B는 다르다. (데이터 형과 문자형을 상관X, A=10 B=\"10\" 이라면 false값)\n    \n    A===B A와B는 같다.   (데이터 형과 문자형을 구분, A=10 B=\"10\" 이라면 false값)\n    A!==B A와B는 다르다. (데이터 형과 문자형을 구분, A=10 B=\"10\" 이라면 true값)\n\n```js\nlet a =10; //a값 10  \nlet b =20; //b값 20  \nlet c =10; //c값 10  \nlet f =\"20\"; //d값 문자형\"20\"  \nlet result;  \n  \nresult=a>b;   //false  \nresult=a<b;   //true  \nresult=a<=b;  //true  \nresult=b==f;  //true  \nresult=a!=b;  //true  \nresult=b===f; //false  \n```\n\n* * *\n\n### 6. 논리 연산자\n\n* * *\n\n#### 논리 연산자에는 ||(or), &&(and) , !(not)가 있습니다.\n\n* * *\n\n##### 1. ||\n\nor 연산자라고 부르며, 피연산자 중 값이 하나라도 true이면 true값 반환.\n\n* * *\n\n##### 2. &&\n\nand 연산자라고 부르며, 피연산자 중 값이 하나라도 false이면 false값 반환.\n\n* * *\n\n##### 3. !\n\nnot 연산자라고 부르며, 단항 연산자입니다. 피연산자의 값이 true이면 반대로 false값 반환.\n\n* * *\n\n### 7. 삼향 조건 연산자\n\n조건식(true,false) 데이터 결과값에 따라 스크립트 코드를 다르게 실행할때 사용.\n\n    기본형\n    조건식? 실행문1 : 실행문2;\n    true값일 시 실행문1 실행, false값일 시 실행문2 실행\n\n```js\nconst a=10;  \nconst b=3;  \n  \nconst result=a>b? \"javascript\" : \"hello\";  \ndocument.write(result);  \n//10>3=true 값 이므로 실행문 1인 \"javascript\"를 훌력  \n```\n\n* * *\n\n### 연산자 우선순위\n\n1.  ()\n2.  단항 연산자(–,++,!)\n3.  산술 연산자(*,/,%,+,-)\n4.  비교 연산자(>,>=,<,<=,==,===,!==)\n5.  논리 연산자(&&,||)\n6.  대입(복합 대입) 연산자(=,+=,-=,*=,/=,%=)","slug":"자바스크립트 연산자","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrtj003oqgvqfhx2ff3l","content":"<hr>\n<h3 id=\"1-산술-연산자\"><a href=\"#1-산술-연산자\" class=\"headerlink\" title=\"1. 산술 연산자\"></a>1. 산술 연산자</h3><h5 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"+ , - , * , / , %\"></a>+ , - , * , / , %</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num1 = <span class=\"number\">15</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> num2 = <span class=\"number\">2</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result;  </span><br><span class=\"line\">result=num+num2; <span class=\"comment\">// 더하기  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(result,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 17  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">result=num-num2; <span class=\"comment\">// 빼기  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(result,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 13  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">result=num*num2; <span class=\"comment\">// 곱하기  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(result,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 30  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">result=num/num2; <span class=\"comment\">// 나누기  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(result,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 7.5  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">result=num%num2; <span class=\"comment\">// 나머지  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(result,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<hr>\n<h3 id=\"2-문자-결합-연산자\"><a href=\"#2-문자-결합-연산자\" class=\"headerlink\" title=\"2. 문자 결합 연산자\"></a>2. 문자 결합 연산자</h3><pre><code>문자형데이터+문자형데이터 = 문자형데이터\n문자형데이터+숫자형데이터 = 문자형데이터</code></pre><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> t1=<span class=\"string\">\"학교종이\"</span>; <span class=\"comment\">//문자형 데이터 저장  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> t2=<span class=\"string\">\"떙떙땡\"</span>; <span class=\"comment\">//문자형 데이터 저장  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> t3=<span class=\"number\">8282</span>; <span class=\"comment\">//숫자형 데이터 저장  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> t4=<span class=\"string\">\"어서 모이자\"</span>; <span class=\"comment\">//문자형 데이터 저장  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result;  </span><br><span class=\"line\">  </span><br><span class=\"line\">result=t1+t2+t3+t4;  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(result);  </span><br><span class=\"line\"><span class=\"comment\">//학교종이땡땡땡8282어서 모이자</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"3-대입-연산자\"><a href=\"#3-대입-연산자\" class=\"headerlink\" title=\"3. 대입 연산자\"></a>3. 대입 연산자</h3><pre><code>대입 연사자의 종류\nA = B  (A = B)\nA += B (A = A+B)\nA *+ B (A = A*B)\nA / B  (A = A/B)\nA %= B (A = A%B)</code></pre><h4 id=\"예시\"><a href=\"#예시\" class=\"headerlink\" title=\"예시\"></a>예시</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let num1&#x3D;10;  </span><br><span class=\"line\">let num2&#x3D;3;  </span><br><span class=\"line\">  </span><br><span class=\"line\">num1+&#x3D;num2; &#x2F;&#x2F; num1&#x3D; num1(10) + num2(3) &#x3D;13; num1에 저장  </span><br><span class=\"line\">document.write(num1,&quot;&lt;br&#x2F;&gt;&quot;); &#x2F;&#x2F;num1에 저장된 값 출력  </span><br><span class=\"line\">num1-&#x3D;num2; &#x2F;&#x2F; num1&#x3D; num1(13) - num2(3) &#x3D;10; num1에 저장  </span><br><span class=\"line\">document.write(num1,&quot;&lt;br&#x2F;&gt;&quot;);  </span><br><span class=\"line\">num1*&#x3D;num2; &#x2F;&#x2F; num1&#x3D; num1(10) * num2(3) &#x3D;30; num1에 저장  </span><br><span class=\"line\">document.write(num1,&quot;&lt;br&#x2F;&gt;&quot;);  </span><br><span class=\"line\">num1%&#x3D;num2; &#x2F;&#x2F; num1&#x3D; num1(30) % num2(3) &#x3D;0 num1에 저장  </span><br><span class=\"line\">document.write(num1,&quot;&lt;br&#x2F;&gt;&quot;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"문자형-데이터로-저장된-HTML태그-연산자로-결합하기\"><a href=\"#문자형-데이터로-저장된-HTML태그-연산자로-결합하기\" class=\"headerlink\" title=\"문자형 데이터로 저장된 HTML태그 연산자로 결합하기\"></a>문자형 데이터로 저장된 HTML태그 연산자로 결합하기</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> t =<span class=\"string\">\"&lt;table border='1'&gt;\"</span>;  </span><br><span class=\"line\"> t+=<span class=\"string\">\"&lt;tr&gt;\"</span>;  </span><br><span class=\"line\"> t+=<span class=\"string\">\"&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;\"</span>;  </span><br><span class=\"line\"> t+=<span class=\"string\">\"&lt;/tr&gt;\"</span>;  </span><br><span class=\"line\"> t+=<span class=\"string\">\"&lt;/table&gt;\"</span>;  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(t);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//t=\"&lt;table border='1'&gt;\"&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"4-증감-연산자\"><a href=\"#4-증감-연산자\" class=\"headerlink\" title=\"4. 증감 연산자\"></a>4. 증감 연산자</h3><p>증감 연산자에는<br>숫자형 데이터를 1씩 증가시키는 ++연산자가 있고<br>1씩 감소시키는 –연산자가 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a=++b <span class=\"comment\">// 변수 b의 값을 1 증가 시킨후 a에 저장합니다. (증가가 먼저)  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a=b++ <span class=\"comment\">// 변수 a에 변수b값을 저장한후 변수b의 데이터를 1 증가시킵니다. (대입이먼저)</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"5-비교-연산자\"><a href=\"#5-비교-연산자\" class=\"headerlink\" title=\"5. 비교 연산자\"></a>5. 비교 연산자</h3><pre><code>A&gt;B  A는B보다 크다.\nA&lt;B  A는B보디 작다.\nA&gt;=B A는B보다 크거나 같다.\nA&lt;=B A는B보다 작거나 같다.\n\nA==B  A와B는 같다.   (데이터 형과 문자형을 상관X, A=10 B=&quot;10&quot; 이라면 true값)\nA!=B  A와B는 다르다. (데이터 형과 문자형을 상관X, A=10 B=&quot;10&quot; 이라면 false값)\n\nA===B A와B는 같다.   (데이터 형과 문자형을 구분, A=10 B=&quot;10&quot; 이라면 false값)\nA!==B A와B는 다르다. (데이터 형과 문자형을 구분, A=10 B=&quot;10&quot; 이라면 true값)</code></pre><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a =<span class=\"number\">10</span>; <span class=\"comment\">//a값 10  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b =<span class=\"number\">20</span>; <span class=\"comment\">//b값 20  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> c =<span class=\"number\">10</span>; <span class=\"comment\">//c값 10  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> f =<span class=\"string\">\"20\"</span>; <span class=\"comment\">//d값 문자형\"20\"  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result;  </span><br><span class=\"line\">  </span><br><span class=\"line\">result=a&gt;b;   <span class=\"comment\">//false  </span></span><br><span class=\"line\">result=a&lt;b;   <span class=\"comment\">//true  </span></span><br><span class=\"line\">result=a&lt;=b;  <span class=\"comment\">//true  </span></span><br><span class=\"line\">result=b==f;  <span class=\"comment\">//true  </span></span><br><span class=\"line\">result=a!=b;  <span class=\"comment\">//true  </span></span><br><span class=\"line\">result=b===f; <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"6-논리-연산자\"><a href=\"#6-논리-연산자\" class=\"headerlink\" title=\"6. 논리 연산자\"></a>6. 논리 연산자</h3><hr>\n<h4 id=\"논리-연산자에는-or-amp-amp-and-not-가-있습니다\"><a href=\"#논리-연산자에는-or-amp-amp-and-not-가-있습니다\" class=\"headerlink\" title=\"논리 연산자에는 ||(or), &amp;&amp;(and) , !(not)가 있습니다.\"></a>논리 연산자에는 ||(or), &amp;&amp;(and) , !(not)가 있습니다.</h4><hr>\n<h5 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1. ||\"></a>1. ||</h5><p>or 연산자라고 부르며, 피연산자 중 값이 하나라도 true이면 true값 반환.</p>\n<hr>\n<h5 id=\"2-amp-amp\"><a href=\"#2-amp-amp\" class=\"headerlink\" title=\"2. &amp;&amp;\"></a>2. &amp;&amp;</h5><p>and 연산자라고 부르며, 피연산자 중 값이 하나라도 false이면 false값 반환.</p>\n<hr>\n<h5 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3. !\"></a>3. !</h5><p>not 연산자라고 부르며, 단항 연산자입니다. 피연산자의 값이 true이면 반대로 false값 반환.</p>\n<hr>\n<h3 id=\"7-삼향-조건-연산자\"><a href=\"#7-삼향-조건-연산자\" class=\"headerlink\" title=\"7. 삼향 조건 연산자\"></a>7. 삼향 조건 연산자</h3><p>조건식(true,false) 데이터 결과값에 따라 스크립트 코드를 다르게 실행할때 사용.</p>\n<pre><code>기본형\n조건식? 실행문1 : 실행문2;\ntrue값일 시 실행문1 실행, false값일 시 실행문2 실행</code></pre><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a=<span class=\"number\">10</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> b=<span class=\"number\">3</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> result=a&gt;b? <span class=\"string\">\"javascript\"</span> : <span class=\"string\">\"hello\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(result);  </span><br><span class=\"line\"><span class=\"comment\">//10&gt;3=true 값 이므로 실행문 1인 \"javascript\"를 훌력</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"연산자-우선순위\"><a href=\"#연산자-우선순위\" class=\"headerlink\" title=\"연산자 우선순위\"></a>연산자 우선순위</h3><ol>\n<li>()</li>\n<li>단항 연산자(–,++,!)</li>\n<li>산술 연산자(*,/,%,+,-)</li>\n<li>비교 연산자(&gt;,&gt;=,&lt;,&lt;=,==,===,!==)</li>\n<li>논리 연산자(&amp;&amp;,||)</li>\n<li>대입(복합 대입) 연산자(=,+=,-=,*=,/=,%=)</li>\n</ol>\n","site":{"data":{}},"excerpt":"<hr>\n<h3 id=\"1-산술-연산자\"><a href=\"#1-산술-연산자\" class=\"headerlink\" title=\"1. 산술 연산자\"></a>1. 산술 연산자</h3><h5 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"+ , - , * , / , %\"></a>+ , - , * , / , %</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num1 = <span class=\"number\">15</span>;  </span><br><span class=\"line\"><span class=\"keyword\">let</span> num2 = <span class=\"number\">2</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">let</span> result;  </span><br><span class=\"line\">result=num+num2; <span class=\"comment\">// 더하기  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(result,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 17  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">result=num-num2; <span class=\"comment\">// 빼기  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(result,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 13  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">result=num*num2; <span class=\"comment\">// 곱하기  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(result,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 30  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">result=num/num2; <span class=\"comment\">// 나누기  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(result,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 7.5  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">result=num%num2; <span class=\"comment\">// 나머지  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(result,<span class=\"string\">\"&lt;br /&gt;\"</span>); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>","more":"<hr>\n<h3 id=\"2-문자-결합-연산자\"><a href=\"#2-문자-결합-연산자\" class=\"headerlink\" title=\"2. 문자 결합 연산자\"></a>2. 문자 결합 연산자</h3><pre><code>문자형데이터+문자형데이터 = 문자형데이터\n문자형데이터+숫자형데이터 = 문자형데이터</code></pre><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> t1=<span class=\"string\">\"학교종이\"</span>; <span class=\"comment\">//문자형 데이터 저장  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> t2=<span class=\"string\">\"떙떙땡\"</span>; <span class=\"comment\">//문자형 데이터 저장  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> t3=<span class=\"number\">8282</span>; <span class=\"comment\">//숫자형 데이터 저장  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> t4=<span class=\"string\">\"어서 모이자\"</span>; <span class=\"comment\">//문자형 데이터 저장  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result;  </span><br><span class=\"line\">  </span><br><span class=\"line\">result=t1+t2+t3+t4;  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(result);  </span><br><span class=\"line\"><span class=\"comment\">//학교종이땡땡땡8282어서 모이자</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"3-대입-연산자\"><a href=\"#3-대입-연산자\" class=\"headerlink\" title=\"3. 대입 연산자\"></a>3. 대입 연산자</h3><pre><code>대입 연사자의 종류\nA = B  (A = B)\nA += B (A = A+B)\nA *+ B (A = A*B)\nA / B  (A = A/B)\nA %= B (A = A%B)</code></pre><h4 id=\"예시\"><a href=\"#예시\" class=\"headerlink\" title=\"예시\"></a>예시</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let num1&#x3D;10;  </span><br><span class=\"line\">let num2&#x3D;3;  </span><br><span class=\"line\">  </span><br><span class=\"line\">num1+&#x3D;num2; &#x2F;&#x2F; num1&#x3D; num1(10) + num2(3) &#x3D;13; num1에 저장  </span><br><span class=\"line\">document.write(num1,&quot;&lt;br&#x2F;&gt;&quot;); &#x2F;&#x2F;num1에 저장된 값 출력  </span><br><span class=\"line\">num1-&#x3D;num2; &#x2F;&#x2F; num1&#x3D; num1(13) - num2(3) &#x3D;10; num1에 저장  </span><br><span class=\"line\">document.write(num1,&quot;&lt;br&#x2F;&gt;&quot;);  </span><br><span class=\"line\">num1*&#x3D;num2; &#x2F;&#x2F; num1&#x3D; num1(10) * num2(3) &#x3D;30; num1에 저장  </span><br><span class=\"line\">document.write(num1,&quot;&lt;br&#x2F;&gt;&quot;);  </span><br><span class=\"line\">num1%&#x3D;num2; &#x2F;&#x2F; num1&#x3D; num1(30) % num2(3) &#x3D;0 num1에 저장  </span><br><span class=\"line\">document.write(num1,&quot;&lt;br&#x2F;&gt;&quot;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"문자형-데이터로-저장된-HTML태그-연산자로-결합하기\"><a href=\"#문자형-데이터로-저장된-HTML태그-연산자로-결합하기\" class=\"headerlink\" title=\"문자형 데이터로 저장된 HTML태그 연산자로 결합하기\"></a>문자형 데이터로 저장된 HTML태그 연산자로 결합하기</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> t =<span class=\"string\">\"&lt;table border='1'&gt;\"</span>;  </span><br><span class=\"line\"> t+=<span class=\"string\">\"&lt;tr&gt;\"</span>;  </span><br><span class=\"line\"> t+=<span class=\"string\">\"&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;\"</span>;  </span><br><span class=\"line\"> t+=<span class=\"string\">\"&lt;/tr&gt;\"</span>;  </span><br><span class=\"line\"> t+=<span class=\"string\">\"&lt;/table&gt;\"</span>;  </span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(t);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//t=\"&lt;table border='1'&gt;\"&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"4-증감-연산자\"><a href=\"#4-증감-연산자\" class=\"headerlink\" title=\"4. 증감 연산자\"></a>4. 증감 연산자</h3><p>증감 연산자에는<br>숫자형 데이터를 1씩 증가시키는 ++연산자가 있고<br>1씩 감소시키는 –연산자가 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a=++b <span class=\"comment\">// 변수 b의 값을 1 증가 시킨후 a에 저장합니다. (증가가 먼저)  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a=b++ <span class=\"comment\">// 변수 a에 변수b값을 저장한후 변수b의 데이터를 1 증가시킵니다. (대입이먼저)</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"5-비교-연산자\"><a href=\"#5-비교-연산자\" class=\"headerlink\" title=\"5. 비교 연산자\"></a>5. 비교 연산자</h3><pre><code>A&gt;B  A는B보다 크다.\nA&lt;B  A는B보디 작다.\nA&gt;=B A는B보다 크거나 같다.\nA&lt;=B A는B보다 작거나 같다.\n\nA==B  A와B는 같다.   (데이터 형과 문자형을 상관X, A=10 B=&quot;10&quot; 이라면 true값)\nA!=B  A와B는 다르다. (데이터 형과 문자형을 상관X, A=10 B=&quot;10&quot; 이라면 false값)\n\nA===B A와B는 같다.   (데이터 형과 문자형을 구분, A=10 B=&quot;10&quot; 이라면 false값)\nA!==B A와B는 다르다. (데이터 형과 문자형을 구분, A=10 B=&quot;10&quot; 이라면 true값)</code></pre><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a =<span class=\"number\">10</span>; <span class=\"comment\">//a값 10  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b =<span class=\"number\">20</span>; <span class=\"comment\">//b값 20  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> c =<span class=\"number\">10</span>; <span class=\"comment\">//c값 10  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> f =<span class=\"string\">\"20\"</span>; <span class=\"comment\">//d값 문자형\"20\"  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result;  </span><br><span class=\"line\">  </span><br><span class=\"line\">result=a&gt;b;   <span class=\"comment\">//false  </span></span><br><span class=\"line\">result=a&lt;b;   <span class=\"comment\">//true  </span></span><br><span class=\"line\">result=a&lt;=b;  <span class=\"comment\">//true  </span></span><br><span class=\"line\">result=b==f;  <span class=\"comment\">//true  </span></span><br><span class=\"line\">result=a!=b;  <span class=\"comment\">//true  </span></span><br><span class=\"line\">result=b===f; <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"6-논리-연산자\"><a href=\"#6-논리-연산자\" class=\"headerlink\" title=\"6. 논리 연산자\"></a>6. 논리 연산자</h3><hr>\n<h4 id=\"논리-연산자에는-or-amp-amp-and-not-가-있습니다\"><a href=\"#논리-연산자에는-or-amp-amp-and-not-가-있습니다\" class=\"headerlink\" title=\"논리 연산자에는 ||(or), &amp;&amp;(and) , !(not)가 있습니다.\"></a>논리 연산자에는 ||(or), &amp;&amp;(and) , !(not)가 있습니다.</h4><hr>\n<h5 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1. ||\"></a>1. ||</h5><p>or 연산자라고 부르며, 피연산자 중 값이 하나라도 true이면 true값 반환.</p>\n<hr>\n<h5 id=\"2-amp-amp\"><a href=\"#2-amp-amp\" class=\"headerlink\" title=\"2. &amp;&amp;\"></a>2. &amp;&amp;</h5><p>and 연산자라고 부르며, 피연산자 중 값이 하나라도 false이면 false값 반환.</p>\n<hr>\n<h5 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3. !\"></a>3. !</h5><p>not 연산자라고 부르며, 단항 연산자입니다. 피연산자의 값이 true이면 반대로 false값 반환.</p>\n<hr>\n<h3 id=\"7-삼향-조건-연산자\"><a href=\"#7-삼향-조건-연산자\" class=\"headerlink\" title=\"7. 삼향 조건 연산자\"></a>7. 삼향 조건 연산자</h3><p>조건식(true,false) 데이터 결과값에 따라 스크립트 코드를 다르게 실행할때 사용.</p>\n<pre><code>기본형\n조건식? 실행문1 : 실행문2;\ntrue값일 시 실행문1 실행, false값일 시 실행문2 실행</code></pre><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a=<span class=\"number\">10</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> b=<span class=\"number\">3</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> result=a&gt;b? <span class=\"string\">\"javascript\"</span> : <span class=\"string\">\"hello\"</span>;  </span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(result);  </span><br><span class=\"line\"><span class=\"comment\">//10&gt;3=true 값 이므로 실행문 1인 \"javascript\"를 훌력</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"연산자-우선순위\"><a href=\"#연산자-우선순위\" class=\"headerlink\" title=\"연산자 우선순위\"></a>연산자 우선순위</h3><ol>\n<li>()</li>\n<li>단항 연산자(–,++,!)</li>\n<li>산술 연산자(*,/,%,+,-)</li>\n<li>비교 연산자(&gt;,&gt;=,&lt;,&lt;=,==,===,!==)</li>\n<li>논리 연산자(&amp;&amp;,||)</li>\n<li>대입(복합 대입) 연산자(=,+=,-=,*=,/=,%=)</li>\n</ol>"},{"title":"자바스크립트 조건문","date":"2020-02-24T08:56:16.000Z","disqusId":"tunas-blog-1","_content":"\n* * *\n\n### if 와 else\n\nif문은 조건식을 만족하는(true) 경우에만 실행문을 실행합니다.\n\n 기본형\n     if(조건식){\n         실행문;\n     }\n\n<!-- more -->\n\n```js\nlet num=10;  \n\nif(num<500){ //조건식을 만족하면 실행문을 실행합니다.  \ndocument.write(\"hello\");  \n// hello  \n}  \n```\n\n\n* * *\n\n#### 조건식에 논리형 데이터가 아닌 다른 형이 오는 경우\n\n논리형 데이터 (true,false)값이 아닌 다른 형의 데이터가 입력되더라도\n\ntrue 또는 false로 인식됩니다.\n\n**다음값이 조건식에 입력되면 false를 반환하지만, 그 밖에 모든값은 true로 인식됩니다.**\n\n 0, null, \"\"(빈 문자), undefined\n\n* * *\n\nelse 문은 조건식이 true일 경우와 false일 경우에 따라 실행되는 실행문이 달라집니다.\n\nprompt 사용 예 (사용자로 부터 값을 입력받는 메서드) `질의응답`\n\n```js\nconst num=prompt(\"당신이 좋아하는 숫자는?\",\"0\");  \n\nif (num%2)==0{ //짝수일 경우  \ndocument.write(\"당신이 좋아하는 숫자는 짝수입니다.\");  \n}else{//홀수일 경우  \ndocument.write(\"당신이 좋아하는 숫자는 홀수입니다.\");  \n}  \n```\n\nconfirm 사용 예 (확인/취소 창)\n\n```js\nconst result=confirm(\"정말로 회원을 탈퇴하시겠습니까?\");  \n//확인 버튼시 true, 취소 버튼시 false  \n\nif(result){ //true값일 때 실행문 실행  \ndocument.write(\"탈퇴 처리되었습니다.\");  \n}else{ //false값일 때 실행문 실행  \ndocument.write(\"탈퇴 취소되었습니다.\");  \n}  \n```\n\n* * *\n\n#### else if\n\nelse if 문은 **두 가지 이상의 조건식과 조건을 만족하지 않은 경우 실행되는문**으로 이루어져 있습니다.\n\n```js\nconst mon=prompt(\"현재는 몇 월입니까?\",\"0\");  \n\nif(mon>=3 && mon<=5){ //3월~5월 이라면,  \ndocument.write(\"봄이네요\");  \n}else if(mon>=6 && mon<=8){ //6월~8월 이라면  \ndocument.write(\"여름이군요\");  \n}else if(mon>=9 && mon<=11){ //9월~11월 이라면  \ndocument.write(\"가을이네요\");  \n}else{ //그 밖에 값이라면  \ndocument.write(\"겨울인가요?\");  \n}  \n```\n\n* * *\n\n#### 중첩 if 문\n\n조건문 안에 조건문이 오는 것을 중첩if 문이라고 합니다.\n\n일반적으로 바깥쪽 조건문 조건식1을 만족해야만\n\n안쪽에 있는 조건문인 조건식2를 검사합니다.\n\n**조건식2를 만족하지 않는다면, 조건식1의 실행문만 실행하고 종료됩니다.**\n\n```js\nconst id=\"hdw0903\";  \nconst pw=\"1004\";  \n\nvar id = \"1\"  \nconst user_id=prompt(\"아이디를 입력하세요\",\"\");  \n\nif(id==user_id){ //id가 일치했을 경우 안쪽 if문 실행  \n\nconst user_pw=prompt(\"비밀번호를 입력하세요\",\"\");  \nif(pw==user_pw){ //pw도 일치했을 경우 실행문 실행  \ndocument.write(user_id+\"님 로그인 되었습니다\");  \n} else{ //pw 일치하지 않는경우  \nalert(\"비밀번호가 일치하지 않습니다.\");  \nlocation.reload(); //페이지 새로고침  \n}// 안쪽 if문 종료  \n\n} else{ //아이디가 일치하지 않는 경우  \nalert(\"아이디가 일치하지 않습니다.\");  \nlocation.reload(); // 안쪽 if문 실행되지 않음, 페이지 새로고침  \n}// 종료  \n```\n","source":"_posts/자바스크립트 조건문.md","raw":"---\ntitle: 자바스크립트 조건문\ndate: 2020-02-24 17:56:16.000\ndisqusId: tunas-blog-1\ncategories: JavaScript\ntag: \n- JavaScript\n---\n\n* * *\n\n### if 와 else\n\nif문은 조건식을 만족하는(true) 경우에만 실행문을 실행합니다.\n\n 기본형\n     if(조건식){\n         실행문;\n     }\n\n<!-- more -->\n\n```js\nlet num=10;  \n\nif(num<500){ //조건식을 만족하면 실행문을 실행합니다.  \ndocument.write(\"hello\");  \n// hello  \n}  \n```\n\n\n* * *\n\n#### 조건식에 논리형 데이터가 아닌 다른 형이 오는 경우\n\n논리형 데이터 (true,false)값이 아닌 다른 형의 데이터가 입력되더라도\n\ntrue 또는 false로 인식됩니다.\n\n**다음값이 조건식에 입력되면 false를 반환하지만, 그 밖에 모든값은 true로 인식됩니다.**\n\n 0, null, \"\"(빈 문자), undefined\n\n* * *\n\nelse 문은 조건식이 true일 경우와 false일 경우에 따라 실행되는 실행문이 달라집니다.\n\nprompt 사용 예 (사용자로 부터 값을 입력받는 메서드) `질의응답`\n\n```js\nconst num=prompt(\"당신이 좋아하는 숫자는?\",\"0\");  \n\nif (num%2)==0{ //짝수일 경우  \ndocument.write(\"당신이 좋아하는 숫자는 짝수입니다.\");  \n}else{//홀수일 경우  \ndocument.write(\"당신이 좋아하는 숫자는 홀수입니다.\");  \n}  \n```\n\nconfirm 사용 예 (확인/취소 창)\n\n```js\nconst result=confirm(\"정말로 회원을 탈퇴하시겠습니까?\");  \n//확인 버튼시 true, 취소 버튼시 false  \n\nif(result){ //true값일 때 실행문 실행  \ndocument.write(\"탈퇴 처리되었습니다.\");  \n}else{ //false값일 때 실행문 실행  \ndocument.write(\"탈퇴 취소되었습니다.\");  \n}  \n```\n\n* * *\n\n#### else if\n\nelse if 문은 **두 가지 이상의 조건식과 조건을 만족하지 않은 경우 실행되는문**으로 이루어져 있습니다.\n\n```js\nconst mon=prompt(\"현재는 몇 월입니까?\",\"0\");  \n\nif(mon>=3 && mon<=5){ //3월~5월 이라면,  \ndocument.write(\"봄이네요\");  \n}else if(mon>=6 && mon<=8){ //6월~8월 이라면  \ndocument.write(\"여름이군요\");  \n}else if(mon>=9 && mon<=11){ //9월~11월 이라면  \ndocument.write(\"가을이네요\");  \n}else{ //그 밖에 값이라면  \ndocument.write(\"겨울인가요?\");  \n}  \n```\n\n* * *\n\n#### 중첩 if 문\n\n조건문 안에 조건문이 오는 것을 중첩if 문이라고 합니다.\n\n일반적으로 바깥쪽 조건문 조건식1을 만족해야만\n\n안쪽에 있는 조건문인 조건식2를 검사합니다.\n\n**조건식2를 만족하지 않는다면, 조건식1의 실행문만 실행하고 종료됩니다.**\n\n```js\nconst id=\"hdw0903\";  \nconst pw=\"1004\";  \n\nvar id = \"1\"  \nconst user_id=prompt(\"아이디를 입력하세요\",\"\");  \n\nif(id==user_id){ //id가 일치했을 경우 안쪽 if문 실행  \n\nconst user_pw=prompt(\"비밀번호를 입력하세요\",\"\");  \nif(pw==user_pw){ //pw도 일치했을 경우 실행문 실행  \ndocument.write(user_id+\"님 로그인 되었습니다\");  \n} else{ //pw 일치하지 않는경우  \nalert(\"비밀번호가 일치하지 않습니다.\");  \nlocation.reload(); //페이지 새로고침  \n}// 안쪽 if문 종료  \n\n} else{ //아이디가 일치하지 않는 경우  \nalert(\"아이디가 일치하지 않습니다.\");  \nlocation.reload(); // 안쪽 if문 실행되지 않음, 페이지 새로고침  \n}// 종료  \n```\n","slug":"자바스크립트 조건문","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrtj003rqgvq01mc8t1s","content":"<hr>\n<h3 id=\"if-와-else\"><a href=\"#if-와-else\" class=\"headerlink\" title=\"if 와 else\"></a>if 와 else</h3><p>if문은 조건식을 만족하는(true) 경우에만 실행문을 실행합니다.</p>\n<p> 기본형<br>     if(조건식){<br>         실행문;<br>     }</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num=<span class=\"number\">10</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(num&lt;<span class=\"number\">500</span>)&#123; <span class=\"comment\">//조건식을 만족하면 실행문을 실행합니다.  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"hello\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// hello  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h4 id=\"조건식에-논리형-데이터가-아닌-다른-형이-오는-경우\"><a href=\"#조건식에-논리형-데이터가-아닌-다른-형이-오는-경우\" class=\"headerlink\" title=\"조건식에 논리형 데이터가 아닌 다른 형이 오는 경우\"></a>조건식에 논리형 데이터가 아닌 다른 형이 오는 경우</h4><p>논리형 데이터 (true,false)값이 아닌 다른 형의 데이터가 입력되더라도</p>\n<p>true 또는 false로 인식됩니다.</p>\n<p><strong>다음값이 조건식에 입력되면 false를 반환하지만, 그 밖에 모든값은 true로 인식됩니다.</strong></p>\n<p> 0, null, “”(빈 문자), undefined</p>\n<hr>\n<p>else 문은 조건식이 true일 경우와 false일 경우에 따라 실행되는 실행문이 달라집니다.</p>\n<p>prompt 사용 예 (사용자로 부터 값을 입력받는 메서드) <code>질의응답</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> num=prompt(<span class=\"string\">\"당신이 좋아하는 숫자는?\"</span>,<span class=\"string\">\"0\"</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (num%<span class=\"number\">2</span>)==<span class=\"number\">0</span>&#123; <span class=\"comment\">//짝수일 경우  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"당신이 좋아하는 숫자는 짝수입니다.\"</span>);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;<span class=\"comment\">//홀수일 경우  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"당신이 좋아하는 숫자는 홀수입니다.\"</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>confirm 사용 예 (확인/취소 창)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> result=confirm(<span class=\"string\">\"정말로 회원을 탈퇴하시겠습니까?\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">//확인 버튼시 true, 취소 버튼시 false  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(result)&#123; <span class=\"comment\">//true값일 때 실행문 실행  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"탈퇴 처리되었습니다.\"</span>);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">//false값일 때 실행문 실행  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"탈퇴 취소되었습니다.\"</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"else-if\"><a href=\"#else-if\" class=\"headerlink\" title=\"else if\"></a>else if</h4><p>else if 문은 <strong>두 가지 이상의 조건식과 조건을 만족하지 않은 경우 실행되는문</strong>으로 이루어져 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mon=prompt(<span class=\"string\">\"현재는 몇 월입니까?\"</span>,<span class=\"string\">\"0\"</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(mon&gt;=<span class=\"number\">3</span> &amp;&amp; mon&lt;=<span class=\"number\">5</span>)&#123; <span class=\"comment\">//3월~5월 이라면,  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"봄이네요\"</span>);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mon&gt;=<span class=\"number\">6</span> &amp;&amp; mon&lt;=<span class=\"number\">8</span>)&#123; <span class=\"comment\">//6월~8월 이라면  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"여름이군요\"</span>);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mon&gt;=<span class=\"number\">9</span> &amp;&amp; mon&lt;=<span class=\"number\">11</span>)&#123; <span class=\"comment\">//9월~11월 이라면  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"가을이네요\"</span>);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">//그 밖에 값이라면  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"겨울인가요?\"</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"중첩-if-문\"><a href=\"#중첩-if-문\" class=\"headerlink\" title=\"중첩 if 문\"></a>중첩 if 문</h4><p>조건문 안에 조건문이 오는 것을 중첩if 문이라고 합니다.</p>\n<p>일반적으로 바깥쪽 조건문 조건식1을 만족해야만</p>\n<p>안쪽에 있는 조건문인 조건식2를 검사합니다.</p>\n<p><strong>조건식2를 만족하지 않는다면, 조건식1의 실행문만 실행하고 종료됩니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> id=<span class=\"string\">\"hdw0903\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> pw=<span class=\"string\">\"1004\"</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> id = <span class=\"string\">\"1\"</span>  </span><br><span class=\"line\"><span class=\"keyword\">const</span> user_id=prompt(<span class=\"string\">\"아이디를 입력하세요\"</span>,<span class=\"string\">\"\"</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(id==user_id)&#123; <span class=\"comment\">//id가 일치했을 경우 안쪽 if문 실행  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user_pw=prompt(<span class=\"string\">\"비밀번호를 입력하세요\"</span>,<span class=\"string\">\"\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">if</span>(pw==user_pw)&#123; <span class=\"comment\">//pw도 일치했을 경우 실행문 실행  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(user_id+<span class=\"string\">\"님 로그인 되었습니다\"</span>);  </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span>&#123; <span class=\"comment\">//pw 일치하지 않는경우  </span></span><br><span class=\"line\">alert(<span class=\"string\">\"비밀번호가 일치하지 않습니다.\"</span>);  </span><br><span class=\"line\">location.reload(); <span class=\"comment\">//페이지 새로고침  </span></span><br><span class=\"line\">&#125;<span class=\"comment\">// 안쪽 if문 종료  </span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span>&#123; <span class=\"comment\">//아이디가 일치하지 않는 경우  </span></span><br><span class=\"line\">alert(<span class=\"string\">\"아이디가 일치하지 않습니다.\"</span>);  </span><br><span class=\"line\">location.reload(); <span class=\"comment\">// 안쪽 if문 실행되지 않음, 페이지 새로고침  </span></span><br><span class=\"line\">&#125;<span class=\"comment\">// 종료</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<hr>\n<h3 id=\"if-와-else\"><a href=\"#if-와-else\" class=\"headerlink\" title=\"if 와 else\"></a>if 와 else</h3><p>if문은 조건식을 만족하는(true) 경우에만 실행문을 실행합니다.</p>\n<p> 기본형<br>     if(조건식){<br>         실행문;<br>     }</p>","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num=<span class=\"number\">10</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(num&lt;<span class=\"number\">500</span>)&#123; <span class=\"comment\">//조건식을 만족하면 실행문을 실행합니다.  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"hello\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">// hello  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h4 id=\"조건식에-논리형-데이터가-아닌-다른-형이-오는-경우\"><a href=\"#조건식에-논리형-데이터가-아닌-다른-형이-오는-경우\" class=\"headerlink\" title=\"조건식에 논리형 데이터가 아닌 다른 형이 오는 경우\"></a>조건식에 논리형 데이터가 아닌 다른 형이 오는 경우</h4><p>논리형 데이터 (true,false)값이 아닌 다른 형의 데이터가 입력되더라도</p>\n<p>true 또는 false로 인식됩니다.</p>\n<p><strong>다음값이 조건식에 입력되면 false를 반환하지만, 그 밖에 모든값은 true로 인식됩니다.</strong></p>\n<p> 0, null, “”(빈 문자), undefined</p>\n<hr>\n<p>else 문은 조건식이 true일 경우와 false일 경우에 따라 실행되는 실행문이 달라집니다.</p>\n<p>prompt 사용 예 (사용자로 부터 값을 입력받는 메서드) <code>질의응답</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> num=prompt(<span class=\"string\">\"당신이 좋아하는 숫자는?\"</span>,<span class=\"string\">\"0\"</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (num%<span class=\"number\">2</span>)==<span class=\"number\">0</span>&#123; <span class=\"comment\">//짝수일 경우  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"당신이 좋아하는 숫자는 짝수입니다.\"</span>);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;<span class=\"comment\">//홀수일 경우  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"당신이 좋아하는 숫자는 홀수입니다.\"</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>confirm 사용 예 (확인/취소 창)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> result=confirm(<span class=\"string\">\"정말로 회원을 탈퇴하시겠습니까?\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">//확인 버튼시 true, 취소 버튼시 false  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(result)&#123; <span class=\"comment\">//true값일 때 실행문 실행  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"탈퇴 처리되었습니다.\"</span>);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">//false값일 때 실행문 실행  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"탈퇴 취소되었습니다.\"</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"else-if\"><a href=\"#else-if\" class=\"headerlink\" title=\"else if\"></a>else if</h4><p>else if 문은 <strong>두 가지 이상의 조건식과 조건을 만족하지 않은 경우 실행되는문</strong>으로 이루어져 있습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mon=prompt(<span class=\"string\">\"현재는 몇 월입니까?\"</span>,<span class=\"string\">\"0\"</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(mon&gt;=<span class=\"number\">3</span> &amp;&amp; mon&lt;=<span class=\"number\">5</span>)&#123; <span class=\"comment\">//3월~5월 이라면,  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"봄이네요\"</span>);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mon&gt;=<span class=\"number\">6</span> &amp;&amp; mon&lt;=<span class=\"number\">8</span>)&#123; <span class=\"comment\">//6월~8월 이라면  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"여름이군요\"</span>);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mon&gt;=<span class=\"number\">9</span> &amp;&amp; mon&lt;=<span class=\"number\">11</span>)&#123; <span class=\"comment\">//9월~11월 이라면  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"가을이네요\"</span>);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">//그 밖에 값이라면  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(<span class=\"string\">\"겨울인가요?\"</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"중첩-if-문\"><a href=\"#중첩-if-문\" class=\"headerlink\" title=\"중첩 if 문\"></a>중첩 if 문</h4><p>조건문 안에 조건문이 오는 것을 중첩if 문이라고 합니다.</p>\n<p>일반적으로 바깥쪽 조건문 조건식1을 만족해야만</p>\n<p>안쪽에 있는 조건문인 조건식2를 검사합니다.</p>\n<p><strong>조건식2를 만족하지 않는다면, 조건식1의 실행문만 실행하고 종료됩니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> id=<span class=\"string\">\"hdw0903\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">const</span> pw=<span class=\"string\">\"1004\"</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> id = <span class=\"string\">\"1\"</span>  </span><br><span class=\"line\"><span class=\"keyword\">const</span> user_id=prompt(<span class=\"string\">\"아이디를 입력하세요\"</span>,<span class=\"string\">\"\"</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(id==user_id)&#123; <span class=\"comment\">//id가 일치했을 경우 안쪽 if문 실행  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user_pw=prompt(<span class=\"string\">\"비밀번호를 입력하세요\"</span>,<span class=\"string\">\"\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">if</span>(pw==user_pw)&#123; <span class=\"comment\">//pw도 일치했을 경우 실행문 실행  </span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(user_id+<span class=\"string\">\"님 로그인 되었습니다\"</span>);  </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span>&#123; <span class=\"comment\">//pw 일치하지 않는경우  </span></span><br><span class=\"line\">alert(<span class=\"string\">\"비밀번호가 일치하지 않습니다.\"</span>);  </span><br><span class=\"line\">location.reload(); <span class=\"comment\">//페이지 새로고침  </span></span><br><span class=\"line\">&#125;<span class=\"comment\">// 안쪽 if문 종료  </span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span>&#123; <span class=\"comment\">//아이디가 일치하지 않는 경우  </span></span><br><span class=\"line\">alert(<span class=\"string\">\"아이디가 일치하지 않습니다.\"</span>);  </span><br><span class=\"line\">location.reload(); <span class=\"comment\">// 안쪽 if문 실행되지 않음, 페이지 새로고침  </span></span><br><span class=\"line\">&#125;<span class=\"comment\">// 종료</span></span><br></pre></td></tr></table></figure>"},{"title":"키워드, 블록 스코프 -ECMAScript","date":"2020-03-16T04:13:42.000Z","disqusId":"tunas-blog-1","_content":"\n## 글로벌 변수 오해\n\n글로벌 오브젝트에 작성한 변수는 **글로벌 오브젝트가 스코프**입니다.  \n글로벌 오브젝트에 작성하여 글로벌 변수라고 부르는 것이지,  \n**글로벌 오브젝트에서 보면 로컬 변수입니다.**\n\nvar 키워드를 작성하지 않으면 글로벌 변수로 간주한다는 점으로 인해  \nvar키워드를 작성하지 않을 뿐이지 글로벌 변수는 var 키워드를 사용하지 않는다는것이 아닙니다.\n\n글로벌 변수도 var 키워드를 사용하여\n\n> var global = “”;\n\n형식으로 작성하는 것이 정확한 작성법입니다.\n\n글로벌 변수는 객체지향 관점에서 보면 단점이라고 할 수 있습니다.  \nfunction 안에서 글로벌 오브젝트에 작성된 글로벌 변수를 사용할 수는 있지만,  \n다른 프로그램에서 글로벌 변수 값을 변경 하거나 재사용 할 수도 있는  \n위험이 있습니다.  \n이러한 경우는 자칫 오류를 만들게 되어 객체 지향 기본에서 어긋나는 행동입니다.\n\n<!-- more -->\n\n* * *\n\n## let 키워드\n\nlet 키워드 변수 선언 형태\n\n> let sports = “축구”;\n\nlet 키워드는 var 키워드의 문제점을 해결하기 위한 것으로  \n다음과 같은 특징이 있습니다.\n\n1.  함수 안에 작성한 let 변수는 함수가 스코프 입니다.\n2.  함수 안에 if(a=b) {let sports = “축구”} 형태의 코드를 작성했을 때,  \n    sports 변수는 함수가 스코프가 아니라 if문의 블록{}이 스코프입니다.\n3.  블록{} 밖에 같은 이름의 변수가 있어도 스코프가 다르므로 변수 각각에 값을 설정할 수 있고 그 변수 값이 유지됩니다.\n4.  블록{} 안에 블록{}을 계층적으로 작성하면 각각의 블록이 스코프입니다.\n5.  같은 스코프 안에서 같은 이름의 let 변수는 허용되지 않습니다.\n\n* * *\n\n## 블록 스코프\n\nlet 변수를 선언하는 가장 큰 목적은 스코프이며 그중에서도 블록 스코프가 돋보입니다.  \n블록{} 안과 밖에 변수 이름이 같더라도 스코프가 다르므로  \n변수가 선언되고 각 변수에 할당된 값이 대체되지 않고 유지됩니다.\n\n```js\nlet sports = \"축구\";  \nif (sports){  \n let sports = \"농구\";  \n 1. console.log(\"블록: \", sports); // 농구  \n}  \n2. console.log(\"글로벌: \", sports); // 축구  \n```\n\n*   if문 앞에 같은 이름의 sports 변수가 있지만 블록{}을 기준으로  \n    스코프가 다르므로 각 sports 변수에 값이 할당되어  \n    “축구”가 “농구”로 대체되지 않고 각 값이 유지됩니다.\n\n* * *\n\n## let과 this 키워드\n\n```js\n1. var music = \"음악\"; //var (this)  \nconsole.log(this.music);  \n  \n2. let sports = \"축구\"; //let (this)  \nconsole.log(this.sports);  \n```\n\n1.  var 키워드는 현재 글로벌 오브젝트의 상태이고  \n    this는 글로벌 오브젝트를 참조하게 되어  \n    music 변수 값인 “음악”이 출력됩니다.\n    \n\n2.  let 키워드로 선언,할당한 후  \n    this로 sports값을 출력하면 undefined가 출력됩니다.  \n    this가 글로벌 오브젝트를 의미하여 window 오브젝트를 참조하는데  \n    window 오브젝트에 let 변수가 없다는 것은  \n    window 오브젝트에 let 변수가 설정되지 않는다는 의미 입니다.  \n    이점이 var변수와 let변수의 차이입니다.\n\n\n* * *\n\n## function\n\nfunction도 스코프를 가지므로 하나의 블록 스코프입니다.  \nfunction 안에 선언된 모든 변수가 function내의 스코프에 속하고  \nfunction안에 if 블록{}은 스코프 안에 스코프를 가지는 계층 구조의 형성입니다.\n\n```js\nlet sports = \"축구\", music = \"재즈\";  \n// get 함수 밖에 sports 와 music을 선언하고 값을 설정했습니다.  \nfunction get(){  \n let music = \"클래식\"; //get 함수안에 music을 선언,할당했습니다.  \n 1. console.log(music);  \n 2. console.log(sports);  \n}  \nget();  \n```\n\n1.  var 변수와 마찬가지로 함수안에서 music 변수를 검색하고,없으면  \n    함수 밖으로 나가 검색합니다. 함수안에 music변수가 있으므로  \n    “클래식”이 출력됩니다.\n    \n\n2.  함수안에 sports변수가 없으므로 함수 밖의 sports값인 “축구”를 출력합니다.\n    \n\n<mark>이와 같이 let 변수도 가장 가까운 스코프에 있는 변수를 먼저 사용합니다.</mark>\n\n```js 예시2\nvar sports = \"축구\"; // var sports  \nlet music = \"재즈\"; // let music  \n  \nfunction get(){  \n var sports = \"농구\";  \n let music = \"클래식\";  \n  \n 1. console.log(\"1:\", sports);  \n 2. console.log(\"2:\", this.sports);  \n 3 .console.log(\"3:\", this.music);  \n};  \n// 1번째 호출   \nwindow.get();  \n// 2번째 호출  \nget();  \n```\n\n1.  **strict 모드에서 window.get과 같이 get() 앞의 오브젝트 위치에**  \n    **window를 작성하면 function get() 내의 this가 window 오브젝트를 참조합니다.**\n\n    1.  함수 안에 sport 변수가 있으므로 그 값인 “농구”를 출력합니다.\n \n    2.  window.get()형태로 호출했으므로 this가 window 오브젝트를 참조하여  \n     get()함수 밖의 var 변수 sports의 값 “축구”를 출력합니다.\n \n    3.  undefined  \n     this가 window 오브젝트를 참조하여 get()함수 밖의 music 변수를 찾지만  \n     music 변수가 let으로 선언되어 있어 this(window 오브젝트)로 참조할 수 없어 undefined가 출력됩니다.\n\n2.  **get()과 같이 오브젝트를 지정하지 않고 호출하면 this가 window 오브젝트를 참조하지 않습니다.**\n\n    1.  sports는 var 변수입니다.  \n     var변수는 window 오브젝트 지정과 관계없이 함수 안의 변수를 참조하여  \n     “농구”가 출력됩니다.\n     \n    2.  ,3. 에러  \n     window 오브젝트를 작성하지 않고 호출하여 this가 window 오브젝트를 참조 >하지못하고 엔진은 참조할 오브젝트 위치에 undefined를 설정합니다.  \n     this는 참조할 오브젝트 위치에 있는 undefined를 참조하게 되고  \n     TypeError가 발생합니다.\n     \n* * *\n\n## try-catch\n\n**try-catch문에서 try 블록{}기준으로 블록 스코프를 갖습니다.**  \n**catch 블록은 스코프를 가지지 않으며 try 블록 스코프에 속합니다.**\n\n```js\nlet sports = \"축구\"; //try문 밖의 let sports   \ntry {  \n let sports = \"농구\"; //try문 안에 let sports  \n 1. console.log(sports);  \n} catch (e) {};  \n  \n2. console.log(sports);  \n\n1.  try문 블록{} 스코프의 sports 값 출력 “농구”\n2.  try문 밖의 sports 값 출력 “축구”\n```\n\n* * *\n\n## switch-case\n\n**switch-case 문에서 switch 블록이 블록 스코프입니다.**  \n**switch 안에 case는 별도의 스코프를 갖지 않으며 switch 스코프에 속합니다.**\n\n```js\nvar count = 1; // switch문의 case1:을 실행하기 위해 count에 1할당  \nlet sports = \"축구\"; //switch문 밖의 let sports  \nswitch (count) {  \n case 1:  \n let sports = \"농구\"; //switch문 내의 let sports  \n console.log(sports); // \"농구\"가 출력됩니다.  \n};  \nconsole.log(sports); //\"축구\"가 출력됩니다.  \n```\n\n* * *\n\n## for()\n\nfor()문에서 var변수로 작성하는 것과 let변수로 작성하는 것에는  \n큰 차이가 있습니다.  \n<mark>let 변수는 반복할 때 마다 스코프를 갖는 반면,\nvar 변수는 스코프를 갖지 않습니다.</mark>\n\n```html\n<ul>  \n <li>1~10</li>  \n <li>11~20</li>  \n <li>21~30</li>  \n</ul>  \n```\n```js var\nvar nodes = document.querySelector(\"ul\");  \nfor (var k = 0; k < nodes.children.length; k++){  \n var el = nodes.children[k];  \n el.onclick = function(event){  \n event.target.style.backgroundColor = \"yellow\";  \n console.log(k);  \n }  \n};  \n```\n\nquerySelector(“ul”)으로 html에 작성된 li 요소 3개를 nodes 변수에 할당합니다.  \nnodes.childern.length는 NodeList의 요소 수로 3입니다.  \nfor문을 반복하면서 각 li 요소마다 onclick 이벤트를 설정합니다.  \n클릭시 배경색을 변경하고 for문의 K 변수 값을 출력합니다.  \n어떤 li요소를 클릭하더라도 콘솔에 K값 3이 출력되며 3이 K의 최종값 입니다.\n\n클릭한 li 요소에 해당하는 K변수 값을 출력하고 싶다면  \nlet변수를 사용하면 됩니다.\n\n```js let\nvar nodes = document.querySelector(\"ul\");  \nfor (let k = 0; k < nodes.children.length; k++){  \n var el = nodes.children[k];  \n el.onclick = function(event){  \n event.target.style.backgroundColor = \"yellow\";  \n console.log(k);  \n }  \n}  \n```\n\nli요소를 클릭하면 onclick이벤트를 설정했을 때  \n사용한 K변수 값을 출력합니다. 0,1,2  \n이는 let변수가 스코프를 갖기 때문입니다.\n\n* * *\n\n## const\n\nconst 변수에 할당된 값은 상수가 됩니다.  \n상수는 재할당 할 수 없으며 재선언 할 수도 없습니다.\n\nconst 변수는 선언-초기화-할당을 한번에 합니다.  \n즉, const a; 처럼 선언만 해놓을 수 없습니다.  \n반드시 const a = 0; 처럼 초기값을 할당해 줘야 합니다.\n\n상수 선언에는 대소문자 모두 사용할 수 있지만,  \n일반적인 관습은 모두 대문자를 사용하는 것입니다.\n","source":"_posts/키워드, 블록 스코프 -ECMAScript.md","raw":"---\ntitle: 키워드, 블록 스코프 -ECMAScript\ndate: 2020-03-16 13:13:42\ndisqusId: tunas-blog-1\ncategories: ECMAScript6\ntag: \n- ECMAScript6\n- JavaScript\n---\n\n## 글로벌 변수 오해\n\n글로벌 오브젝트에 작성한 변수는 **글로벌 오브젝트가 스코프**입니다.  \n글로벌 오브젝트에 작성하여 글로벌 변수라고 부르는 것이지,  \n**글로벌 오브젝트에서 보면 로컬 변수입니다.**\n\nvar 키워드를 작성하지 않으면 글로벌 변수로 간주한다는 점으로 인해  \nvar키워드를 작성하지 않을 뿐이지 글로벌 변수는 var 키워드를 사용하지 않는다는것이 아닙니다.\n\n글로벌 변수도 var 키워드를 사용하여\n\n> var global = “”;\n\n형식으로 작성하는 것이 정확한 작성법입니다.\n\n글로벌 변수는 객체지향 관점에서 보면 단점이라고 할 수 있습니다.  \nfunction 안에서 글로벌 오브젝트에 작성된 글로벌 변수를 사용할 수는 있지만,  \n다른 프로그램에서 글로벌 변수 값을 변경 하거나 재사용 할 수도 있는  \n위험이 있습니다.  \n이러한 경우는 자칫 오류를 만들게 되어 객체 지향 기본에서 어긋나는 행동입니다.\n\n<!-- more -->\n\n* * *\n\n## let 키워드\n\nlet 키워드 변수 선언 형태\n\n> let sports = “축구”;\n\nlet 키워드는 var 키워드의 문제점을 해결하기 위한 것으로  \n다음과 같은 특징이 있습니다.\n\n1.  함수 안에 작성한 let 변수는 함수가 스코프 입니다.\n2.  함수 안에 if(a=b) {let sports = “축구”} 형태의 코드를 작성했을 때,  \n    sports 변수는 함수가 스코프가 아니라 if문의 블록{}이 스코프입니다.\n3.  블록{} 밖에 같은 이름의 변수가 있어도 스코프가 다르므로 변수 각각에 값을 설정할 수 있고 그 변수 값이 유지됩니다.\n4.  블록{} 안에 블록{}을 계층적으로 작성하면 각각의 블록이 스코프입니다.\n5.  같은 스코프 안에서 같은 이름의 let 변수는 허용되지 않습니다.\n\n* * *\n\n## 블록 스코프\n\nlet 변수를 선언하는 가장 큰 목적은 스코프이며 그중에서도 블록 스코프가 돋보입니다.  \n블록{} 안과 밖에 변수 이름이 같더라도 스코프가 다르므로  \n변수가 선언되고 각 변수에 할당된 값이 대체되지 않고 유지됩니다.\n\n```js\nlet sports = \"축구\";  \nif (sports){  \n let sports = \"농구\";  \n 1. console.log(\"블록: \", sports); // 농구  \n}  \n2. console.log(\"글로벌: \", sports); // 축구  \n```\n\n*   if문 앞에 같은 이름의 sports 변수가 있지만 블록{}을 기준으로  \n    스코프가 다르므로 각 sports 변수에 값이 할당되어  \n    “축구”가 “농구”로 대체되지 않고 각 값이 유지됩니다.\n\n* * *\n\n## let과 this 키워드\n\n```js\n1. var music = \"음악\"; //var (this)  \nconsole.log(this.music);  \n  \n2. let sports = \"축구\"; //let (this)  \nconsole.log(this.sports);  \n```\n\n1.  var 키워드는 현재 글로벌 오브젝트의 상태이고  \n    this는 글로벌 오브젝트를 참조하게 되어  \n    music 변수 값인 “음악”이 출력됩니다.\n    \n\n2.  let 키워드로 선언,할당한 후  \n    this로 sports값을 출력하면 undefined가 출력됩니다.  \n    this가 글로벌 오브젝트를 의미하여 window 오브젝트를 참조하는데  \n    window 오브젝트에 let 변수가 없다는 것은  \n    window 오브젝트에 let 변수가 설정되지 않는다는 의미 입니다.  \n    이점이 var변수와 let변수의 차이입니다.\n\n\n* * *\n\n## function\n\nfunction도 스코프를 가지므로 하나의 블록 스코프입니다.  \nfunction 안에 선언된 모든 변수가 function내의 스코프에 속하고  \nfunction안에 if 블록{}은 스코프 안에 스코프를 가지는 계층 구조의 형성입니다.\n\n```js\nlet sports = \"축구\", music = \"재즈\";  \n// get 함수 밖에 sports 와 music을 선언하고 값을 설정했습니다.  \nfunction get(){  \n let music = \"클래식\"; //get 함수안에 music을 선언,할당했습니다.  \n 1. console.log(music);  \n 2. console.log(sports);  \n}  \nget();  \n```\n\n1.  var 변수와 마찬가지로 함수안에서 music 변수를 검색하고,없으면  \n    함수 밖으로 나가 검색합니다. 함수안에 music변수가 있으므로  \n    “클래식”이 출력됩니다.\n    \n\n2.  함수안에 sports변수가 없으므로 함수 밖의 sports값인 “축구”를 출력합니다.\n    \n\n<mark>이와 같이 let 변수도 가장 가까운 스코프에 있는 변수를 먼저 사용합니다.</mark>\n\n```js 예시2\nvar sports = \"축구\"; // var sports  \nlet music = \"재즈\"; // let music  \n  \nfunction get(){  \n var sports = \"농구\";  \n let music = \"클래식\";  \n  \n 1. console.log(\"1:\", sports);  \n 2. console.log(\"2:\", this.sports);  \n 3 .console.log(\"3:\", this.music);  \n};  \n// 1번째 호출   \nwindow.get();  \n// 2번째 호출  \nget();  \n```\n\n1.  **strict 모드에서 window.get과 같이 get() 앞의 오브젝트 위치에**  \n    **window를 작성하면 function get() 내의 this가 window 오브젝트를 참조합니다.**\n\n    1.  함수 안에 sport 변수가 있으므로 그 값인 “농구”를 출력합니다.\n \n    2.  window.get()형태로 호출했으므로 this가 window 오브젝트를 참조하여  \n     get()함수 밖의 var 변수 sports의 값 “축구”를 출력합니다.\n \n    3.  undefined  \n     this가 window 오브젝트를 참조하여 get()함수 밖의 music 변수를 찾지만  \n     music 변수가 let으로 선언되어 있어 this(window 오브젝트)로 참조할 수 없어 undefined가 출력됩니다.\n\n2.  **get()과 같이 오브젝트를 지정하지 않고 호출하면 this가 window 오브젝트를 참조하지 않습니다.**\n\n    1.  sports는 var 변수입니다.  \n     var변수는 window 오브젝트 지정과 관계없이 함수 안의 변수를 참조하여  \n     “농구”가 출력됩니다.\n     \n    2.  ,3. 에러  \n     window 오브젝트를 작성하지 않고 호출하여 this가 window 오브젝트를 참조 >하지못하고 엔진은 참조할 오브젝트 위치에 undefined를 설정합니다.  \n     this는 참조할 오브젝트 위치에 있는 undefined를 참조하게 되고  \n     TypeError가 발생합니다.\n     \n* * *\n\n## try-catch\n\n**try-catch문에서 try 블록{}기준으로 블록 스코프를 갖습니다.**  \n**catch 블록은 스코프를 가지지 않으며 try 블록 스코프에 속합니다.**\n\n```js\nlet sports = \"축구\"; //try문 밖의 let sports   \ntry {  \n let sports = \"농구\"; //try문 안에 let sports  \n 1. console.log(sports);  \n} catch (e) {};  \n  \n2. console.log(sports);  \n\n1.  try문 블록{} 스코프의 sports 값 출력 “농구”\n2.  try문 밖의 sports 값 출력 “축구”\n```\n\n* * *\n\n## switch-case\n\n**switch-case 문에서 switch 블록이 블록 스코프입니다.**  \n**switch 안에 case는 별도의 스코프를 갖지 않으며 switch 스코프에 속합니다.**\n\n```js\nvar count = 1; // switch문의 case1:을 실행하기 위해 count에 1할당  \nlet sports = \"축구\"; //switch문 밖의 let sports  \nswitch (count) {  \n case 1:  \n let sports = \"농구\"; //switch문 내의 let sports  \n console.log(sports); // \"농구\"가 출력됩니다.  \n};  \nconsole.log(sports); //\"축구\"가 출력됩니다.  \n```\n\n* * *\n\n## for()\n\nfor()문에서 var변수로 작성하는 것과 let변수로 작성하는 것에는  \n큰 차이가 있습니다.  \n<mark>let 변수는 반복할 때 마다 스코프를 갖는 반면,\nvar 변수는 스코프를 갖지 않습니다.</mark>\n\n```html\n<ul>  \n <li>1~10</li>  \n <li>11~20</li>  \n <li>21~30</li>  \n</ul>  \n```\n```js var\nvar nodes = document.querySelector(\"ul\");  \nfor (var k = 0; k < nodes.children.length; k++){  \n var el = nodes.children[k];  \n el.onclick = function(event){  \n event.target.style.backgroundColor = \"yellow\";  \n console.log(k);  \n }  \n};  \n```\n\nquerySelector(“ul”)으로 html에 작성된 li 요소 3개를 nodes 변수에 할당합니다.  \nnodes.childern.length는 NodeList의 요소 수로 3입니다.  \nfor문을 반복하면서 각 li 요소마다 onclick 이벤트를 설정합니다.  \n클릭시 배경색을 변경하고 for문의 K 변수 값을 출력합니다.  \n어떤 li요소를 클릭하더라도 콘솔에 K값 3이 출력되며 3이 K의 최종값 입니다.\n\n클릭한 li 요소에 해당하는 K변수 값을 출력하고 싶다면  \nlet변수를 사용하면 됩니다.\n\n```js let\nvar nodes = document.querySelector(\"ul\");  \nfor (let k = 0; k < nodes.children.length; k++){  \n var el = nodes.children[k];  \n el.onclick = function(event){  \n event.target.style.backgroundColor = \"yellow\";  \n console.log(k);  \n }  \n}  \n```\n\nli요소를 클릭하면 onclick이벤트를 설정했을 때  \n사용한 K변수 값을 출력합니다. 0,1,2  \n이는 let변수가 스코프를 갖기 때문입니다.\n\n* * *\n\n## const\n\nconst 변수에 할당된 값은 상수가 됩니다.  \n상수는 재할당 할 수 없으며 재선언 할 수도 없습니다.\n\nconst 변수는 선언-초기화-할당을 한번에 합니다.  \n즉, const a; 처럼 선언만 해놓을 수 없습니다.  \n반드시 const a = 0; 처럼 초기값을 할당해 줘야 합니다.\n\n상수 선언에는 대소문자 모두 사용할 수 있지만,  \n일반적인 관습은 모두 대문자를 사용하는 것입니다.\n","slug":"키워드, 블록 스코프 -ECMAScript","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrtl003uqgvqe9r6ay45","content":"<h2 id=\"글로벌-변수-오해\"><a href=\"#글로벌-변수-오해\" class=\"headerlink\" title=\"글로벌 변수 오해\"></a>글로벌 변수 오해</h2><p>글로벌 오브젝트에 작성한 변수는 <strong>글로벌 오브젝트가 스코프</strong>입니다.<br>글로벌 오브젝트에 작성하여 글로벌 변수라고 부르는 것이지,<br><strong>글로벌 오브젝트에서 보면 로컬 변수입니다.</strong></p>\n<p>var 키워드를 작성하지 않으면 글로벌 변수로 간주한다는 점으로 인해<br>var키워드를 작성하지 않을 뿐이지 글로벌 변수는 var 키워드를 사용하지 않는다는것이 아닙니다.</p>\n<p>글로벌 변수도 var 키워드를 사용하여</p>\n<blockquote>\n<p>var global = “”;</p>\n</blockquote>\n<p>형식으로 작성하는 것이 정확한 작성법입니다.</p>\n<p>글로벌 변수는 객체지향 관점에서 보면 단점이라고 할 수 있습니다.<br>function 안에서 글로벌 오브젝트에 작성된 글로벌 변수를 사용할 수는 있지만,<br>다른 프로그램에서 글로벌 변수 값을 변경 하거나 재사용 할 수도 있는<br>위험이 있습니다.<br>이러한 경우는 자칫 오류를 만들게 되어 객체 지향 기본에서 어긋나는 행동입니다.</p>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"let-키워드\"><a href=\"#let-키워드\" class=\"headerlink\" title=\"let 키워드\"></a>let 키워드</h2><p>let 키워드 변수 선언 형태</p>\n<blockquote>\n<p>let sports = “축구”;</p>\n</blockquote>\n<p>let 키워드는 var 키워드의 문제점을 해결하기 위한 것으로<br>다음과 같은 특징이 있습니다.</p>\n<ol>\n<li>함수 안에 작성한 let 변수는 함수가 스코프 입니다.</li>\n<li>함수 안에 if(a=b) {let sports = “축구”} 형태의 코드를 작성했을 때,<br>sports 변수는 함수가 스코프가 아니라 if문의 블록{}이 스코프입니다.</li>\n<li>블록{} 밖에 같은 이름의 변수가 있어도 스코프가 다르므로 변수 각각에 값을 설정할 수 있고 그 변수 값이 유지됩니다.</li>\n<li>블록{} 안에 블록{}을 계층적으로 작성하면 각각의 블록이 스코프입니다.</li>\n<li>같은 스코프 안에서 같은 이름의 let 변수는 허용되지 않습니다.</li>\n</ol>\n<hr>\n<h2 id=\"블록-스코프\"><a href=\"#블록-스코프\" class=\"headerlink\" title=\"블록 스코프\"></a>블록 스코프</h2><p>let 변수를 선언하는 가장 큰 목적은 스코프이며 그중에서도 블록 스코프가 돋보입니다.<br>블록{} 안과 밖에 변수 이름이 같더라도 스코프가 다르므로<br>변수가 선언되고 각 변수에 할당된 값이 대체되지 않고 유지됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = <span class=\"string\">\"축구\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">if</span> (sports)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> sports = <span class=\"string\">\"농구\"</span>;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"블록: \"</span>, sports); <span class=\"comment\">// 농구  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"글로벌: \"</span>, sports); <span class=\"comment\">// 축구</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>if문 앞에 같은 이름의 sports 변수가 있지만 블록{}을 기준으로<br>스코프가 다르므로 각 sports 변수에 값이 할당되어<br>“축구”가 “농구”로 대체되지 않고 각 값이 유지됩니다.</li>\n</ul>\n<hr>\n<h2 id=\"let과-this-키워드\"><a href=\"#let과-this-키워드\" class=\"headerlink\" title=\"let과 this 키워드\"></a>let과 this 키워드</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> music = <span class=\"string\">\"음악\"</span>; <span class=\"comment\">//var (this)  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.music);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> sports = <span class=\"string\">\"축구\"</span>; <span class=\"comment\">//let (this)  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.sports);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>var 키워드는 현재 글로벌 오브젝트의 상태이고<br>this는 글로벌 오브젝트를 참조하게 되어<br>music 변수 값인 “음악”이 출력됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li>let 키워드로 선언,할당한 후<br>this로 sports값을 출력하면 undefined가 출력됩니다.<br>this가 글로벌 오브젝트를 의미하여 window 오브젝트를 참조하는데<br>window 오브젝트에 let 변수가 없다는 것은<br>window 오브젝트에 let 변수가 설정되지 않는다는 의미 입니다.<br>이점이 var변수와 let변수의 차이입니다.</li>\n</ol>\n<hr>\n<h2 id=\"function\"><a href=\"#function\" class=\"headerlink\" title=\"function\"></a>function</h2><p>function도 스코프를 가지므로 하나의 블록 스코프입니다.<br>function 안에 선언된 모든 변수가 function내의 스코프에 속하고<br>function안에 if 블록{}은 스코프 안에 스코프를 가지는 계층 구조의 형성입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = <span class=\"string\">\"축구\"</span>, music = <span class=\"string\">\"재즈\"</span>;  </span><br><span class=\"line\"><span class=\"comment\">// get 함수 밖에 sports 와 music을 선언하고 값을 설정했습니다.  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> music = <span class=\"string\">\"클래식\"</span>; <span class=\"comment\">//get 함수안에 music을 선언,할당했습니다.  </span></span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(music);  </span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(sports);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">get</span>();</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>var 변수와 마찬가지로 함수안에서 music 변수를 검색하고,없으면<br>함수 밖으로 나가 검색합니다. 함수안에 music변수가 있으므로<br>“클래식”이 출력됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li>함수안에 sports변수가 없으므로 함수 밖의 sports값인 “축구”를 출력합니다.</li>\n</ol>\n<p><mark>이와 같이 let 변수도 가장 가까운 스코프에 있는 변수를 먼저 사용합니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>예시2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sports = <span class=\"string\">\"축구\"</span>; <span class=\"comment\">// var sports  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> music = <span class=\"string\">\"재즈\"</span>; <span class=\"comment\">// let music  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> sports = <span class=\"string\">\"농구\"</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> music = <span class=\"string\">\"클래식\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, sports);  </span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"keyword\">this</span>.sports);  </span><br><span class=\"line\"> <span class=\"number\">3</span> .console.log(<span class=\"string\">\"3:\"</span>, <span class=\"keyword\">this</span>.music);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// 1번째 호출   </span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.get();  </span><br><span class=\"line\"><span class=\"comment\">// 2번째 호출  </span></span><br><span class=\"line\"><span class=\"keyword\">get</span>();</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><strong>strict 모드에서 window.get과 같이 get() 앞의 오브젝트 위치에</strong><br><strong>window를 작성하면 function get() 내의 this가 window 오브젝트를 참조합니다.</strong></p>\n<ol>\n<li><p>함수 안에 sport 변수가 있으므로 그 값인 “농구”를 출력합니다.</p>\n</li>\n<li><p>window.get()형태로 호출했으므로 this가 window 오브젝트를 참조하여<br>get()함수 밖의 var 변수 sports의 값 “축구”를 출력합니다.</p>\n</li>\n<li><p>undefined<br>this가 window 오브젝트를 참조하여 get()함수 밖의 music 변수를 찾지만<br>music 변수가 let으로 선언되어 있어 this(window 오브젝트)로 참조할 수 없어 undefined가 출력됩니다.</p>\n</li>\n</ol>\n</li>\n<li><p><strong>get()과 같이 오브젝트를 지정하지 않고 호출하면 this가 window 오브젝트를 참조하지 않습니다.</strong></p>\n<ol>\n<li><p>sports는 var 변수입니다.<br>var변수는 window 오브젝트 지정과 관계없이 함수 안의 변수를 참조하여<br>“농구”가 출력됩니다.</p>\n</li>\n<li><p>,3. 에러<br>window 오브젝트를 작성하지 않고 호출하여 this가 window 오브젝트를 참조 &gt;하지못하고 엔진은 참조할 오브젝트 위치에 undefined를 설정합니다.<br>this는 참조할 오브젝트 위치에 있는 undefined를 참조하게 되고<br>TypeError가 발생합니다.</p>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"try-catch\"><a href=\"#try-catch\" class=\"headerlink\" title=\"try-catch\"></a>try-catch</h2><p><strong>try-catch문에서 try 블록{}기준으로 블록 스코프를 갖습니다.</strong><br><strong>catch 블록은 스코프를 가지지 않으며 try 블록 스코프에 속합니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = <span class=\"string\">\"축구\"</span>; <span class=\"comment\">//try문 밖의 let sports   </span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> sports = <span class=\"string\">\"농구\"</span>; <span class=\"comment\">//try문 안에 let sports  </span></span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(sports);  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(sports);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>  <span class=\"keyword\">try</span>문 블록&#123;&#125; 스코프의 sports 값 출력 “농구”</span><br><span class=\"line\"><span class=\"number\">2.</span>  <span class=\"keyword\">try</span>문 밖의 sports 값 출력 “축구”</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"switch-case\"><a href=\"#switch-case\" class=\"headerlink\" title=\"switch-case\"></a>switch-case</h2><p><strong>switch-case 문에서 switch 블록이 블록 스코프입니다.</strong><br><strong>switch 안에 case는 별도의 스코프를 갖지 않으며 switch 스코프에 속합니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">1</span>; <span class=\"comment\">// switch문의 case1:을 실행하기 위해 count에 1할당  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sports = <span class=\"string\">\"축구\"</span>; <span class=\"comment\">//switch문 밖의 let sports  </span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> (count) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"number\">1</span>:  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> sports = <span class=\"string\">\"농구\"</span>; <span class=\"comment\">//switch문 내의 let sports  </span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(sports); <span class=\"comment\">// \"농구\"가 출력됩니다.  </span></span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sports); <span class=\"comment\">//\"축구\"가 출력됩니다.</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for()\"></a>for()</h2><p>for()문에서 var변수로 작성하는 것과 let변수로 작성하는 것에는<br>큰 차이가 있습니다.<br><mark>let 변수는 반복할 때 마다 스코프를 갖는 반면,<br>var 변수는 스코프를 갖지 않습니다.</mark></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span>  </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>1~10<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>11~20<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>21~30<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>var</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nodes = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"ul\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k = <span class=\"number\">0</span>; k &lt; nodes.children.length; k++)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> el = nodes.children[k];  </span><br><span class=\"line\"> el.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;  </span><br><span class=\"line\"> event.target.style.backgroundColor = <span class=\"string\">\"yellow\"</span>;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(k);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>querySelector(“ul”)으로 html에 작성된 li 요소 3개를 nodes 변수에 할당합니다.<br>nodes.childern.length는 NodeList의 요소 수로 3입니다.<br>for문을 반복하면서 각 li 요소마다 onclick 이벤트를 설정합니다.<br>클릭시 배경색을 변경하고 for문의 K 변수 값을 출력합니다.<br>어떤 li요소를 클릭하더라도 콘솔에 K값 3이 출력되며 3이 K의 최종값 입니다.</p>\n<p>클릭한 li 요소에 해당하는 K변수 값을 출력하고 싶다면<br>let변수를 사용하면 됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>let</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nodes = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"ul\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">0</span>; k &lt; nodes.children.length; k++)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> el = nodes.children[k];  </span><br><span class=\"line\"> el.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;  </span><br><span class=\"line\"> event.target.style.backgroundColor = <span class=\"string\">\"yellow\"</span>;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(k);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>li요소를 클릭하면 onclick이벤트를 설정했을 때<br>사용한 K변수 값을 출력합니다. 0,1,2<br>이는 let변수가 스코프를 갖기 때문입니다.</p>\n<hr>\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><p>const 변수에 할당된 값은 상수가 됩니다.<br>상수는 재할당 할 수 없으며 재선언 할 수도 없습니다.</p>\n<p>const 변수는 선언-초기화-할당을 한번에 합니다.<br>즉, const a; 처럼 선언만 해놓을 수 없습니다.<br>반드시 const a = 0; 처럼 초기값을 할당해 줘야 합니다.</p>\n<p>상수 선언에는 대소문자 모두 사용할 수 있지만,<br>일반적인 관습은 모두 대문자를 사용하는 것입니다.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"글로벌-변수-오해\"><a href=\"#글로벌-변수-오해\" class=\"headerlink\" title=\"글로벌 변수 오해\"></a>글로벌 변수 오해</h2><p>글로벌 오브젝트에 작성한 변수는 <strong>글로벌 오브젝트가 스코프</strong>입니다.<br>글로벌 오브젝트에 작성하여 글로벌 변수라고 부르는 것이지,<br><strong>글로벌 오브젝트에서 보면 로컬 변수입니다.</strong></p>\n<p>var 키워드를 작성하지 않으면 글로벌 변수로 간주한다는 점으로 인해<br>var키워드를 작성하지 않을 뿐이지 글로벌 변수는 var 키워드를 사용하지 않는다는것이 아닙니다.</p>\n<p>글로벌 변수도 var 키워드를 사용하여</p>\n<blockquote>\n<p>var global = “”;</p>\n</blockquote>\n<p>형식으로 작성하는 것이 정확한 작성법입니다.</p>\n<p>글로벌 변수는 객체지향 관점에서 보면 단점이라고 할 수 있습니다.<br>function 안에서 글로벌 오브젝트에 작성된 글로벌 변수를 사용할 수는 있지만,<br>다른 프로그램에서 글로벌 변수 값을 변경 하거나 재사용 할 수도 있는<br>위험이 있습니다.<br>이러한 경우는 자칫 오류를 만들게 되어 객체 지향 기본에서 어긋나는 행동입니다.</p>","more":"<hr>\n<h2 id=\"let-키워드\"><a href=\"#let-키워드\" class=\"headerlink\" title=\"let 키워드\"></a>let 키워드</h2><p>let 키워드 변수 선언 형태</p>\n<blockquote>\n<p>let sports = “축구”;</p>\n</blockquote>\n<p>let 키워드는 var 키워드의 문제점을 해결하기 위한 것으로<br>다음과 같은 특징이 있습니다.</p>\n<ol>\n<li>함수 안에 작성한 let 변수는 함수가 스코프 입니다.</li>\n<li>함수 안에 if(a=b) {let sports = “축구”} 형태의 코드를 작성했을 때,<br>sports 변수는 함수가 스코프가 아니라 if문의 블록{}이 스코프입니다.</li>\n<li>블록{} 밖에 같은 이름의 변수가 있어도 스코프가 다르므로 변수 각각에 값을 설정할 수 있고 그 변수 값이 유지됩니다.</li>\n<li>블록{} 안에 블록{}을 계층적으로 작성하면 각각의 블록이 스코프입니다.</li>\n<li>같은 스코프 안에서 같은 이름의 let 변수는 허용되지 않습니다.</li>\n</ol>\n<hr>\n<h2 id=\"블록-스코프\"><a href=\"#블록-스코프\" class=\"headerlink\" title=\"블록 스코프\"></a>블록 스코프</h2><p>let 변수를 선언하는 가장 큰 목적은 스코프이며 그중에서도 블록 스코프가 돋보입니다.<br>블록{} 안과 밖에 변수 이름이 같더라도 스코프가 다르므로<br>변수가 선언되고 각 변수에 할당된 값이 대체되지 않고 유지됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = <span class=\"string\">\"축구\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">if</span> (sports)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> sports = <span class=\"string\">\"농구\"</span>;  </span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"블록: \"</span>, sports); <span class=\"comment\">// 농구  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"글로벌: \"</span>, sports); <span class=\"comment\">// 축구</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>if문 앞에 같은 이름의 sports 변수가 있지만 블록{}을 기준으로<br>스코프가 다르므로 각 sports 변수에 값이 할당되어<br>“축구”가 “농구”로 대체되지 않고 각 값이 유지됩니다.</li>\n</ul>\n<hr>\n<h2 id=\"let과-this-키워드\"><a href=\"#let과-this-키워드\" class=\"headerlink\" title=\"let과 this 키워드\"></a>let과 this 키워드</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> music = <span class=\"string\">\"음악\"</span>; <span class=\"comment\">//var (this)  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.music);  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> sports = <span class=\"string\">\"축구\"</span>; <span class=\"comment\">//let (this)  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.sports);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>var 키워드는 현재 글로벌 오브젝트의 상태이고<br>this는 글로벌 오브젝트를 참조하게 되어<br>music 변수 값인 “음악”이 출력됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li>let 키워드로 선언,할당한 후<br>this로 sports값을 출력하면 undefined가 출력됩니다.<br>this가 글로벌 오브젝트를 의미하여 window 오브젝트를 참조하는데<br>window 오브젝트에 let 변수가 없다는 것은<br>window 오브젝트에 let 변수가 설정되지 않는다는 의미 입니다.<br>이점이 var변수와 let변수의 차이입니다.</li>\n</ol>\n<hr>\n<h2 id=\"function\"><a href=\"#function\" class=\"headerlink\" title=\"function\"></a>function</h2><p>function도 스코프를 가지므로 하나의 블록 스코프입니다.<br>function 안에 선언된 모든 변수가 function내의 스코프에 속하고<br>function안에 if 블록{}은 스코프 안에 스코프를 가지는 계층 구조의 형성입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = <span class=\"string\">\"축구\"</span>, music = <span class=\"string\">\"재즈\"</span>;  </span><br><span class=\"line\"><span class=\"comment\">// get 함수 밖에 sports 와 music을 선언하고 값을 설정했습니다.  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> music = <span class=\"string\">\"클래식\"</span>; <span class=\"comment\">//get 함수안에 music을 선언,할당했습니다.  </span></span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(music);  </span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(sports);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"keyword\">get</span>();</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>var 변수와 마찬가지로 함수안에서 music 변수를 검색하고,없으면<br>함수 밖으로 나가 검색합니다. 함수안에 music변수가 있으므로<br>“클래식”이 출력됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li>함수안에 sports변수가 없으므로 함수 밖의 sports값인 “축구”를 출력합니다.</li>\n</ol>\n<p><mark>이와 같이 let 변수도 가장 가까운 스코프에 있는 변수를 먼저 사용합니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>예시2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sports = <span class=\"string\">\"축구\"</span>; <span class=\"comment\">// var sports  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> music = <span class=\"string\">\"재즈\"</span>; <span class=\"comment\">// let music  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> sports = <span class=\"string\">\"농구\"</span>;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> music = <span class=\"string\">\"클래식\"</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"1:\"</span>, sports);  </span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"2:\"</span>, <span class=\"keyword\">this</span>.sports);  </span><br><span class=\"line\"> <span class=\"number\">3</span> .console.log(<span class=\"string\">\"3:\"</span>, <span class=\"keyword\">this</span>.music);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"comment\">// 1번째 호출   </span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.get();  </span><br><span class=\"line\"><span class=\"comment\">// 2번째 호출  </span></span><br><span class=\"line\"><span class=\"keyword\">get</span>();</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><strong>strict 모드에서 window.get과 같이 get() 앞의 오브젝트 위치에</strong><br><strong>window를 작성하면 function get() 내의 this가 window 오브젝트를 참조합니다.</strong></p>\n<ol>\n<li><p>함수 안에 sport 변수가 있으므로 그 값인 “농구”를 출력합니다.</p>\n</li>\n<li><p>window.get()형태로 호출했으므로 this가 window 오브젝트를 참조하여<br>get()함수 밖의 var 변수 sports의 값 “축구”를 출력합니다.</p>\n</li>\n<li><p>undefined<br>this가 window 오브젝트를 참조하여 get()함수 밖의 music 변수를 찾지만<br>music 변수가 let으로 선언되어 있어 this(window 오브젝트)로 참조할 수 없어 undefined가 출력됩니다.</p>\n</li>\n</ol>\n</li>\n<li><p><strong>get()과 같이 오브젝트를 지정하지 않고 호출하면 this가 window 오브젝트를 참조하지 않습니다.</strong></p>\n<ol>\n<li><p>sports는 var 변수입니다.<br>var변수는 window 오브젝트 지정과 관계없이 함수 안의 변수를 참조하여<br>“농구”가 출력됩니다.</p>\n</li>\n<li><p>,3. 에러<br>window 오브젝트를 작성하지 않고 호출하여 this가 window 오브젝트를 참조 &gt;하지못하고 엔진은 참조할 오브젝트 위치에 undefined를 설정합니다.<br>this는 참조할 오브젝트 위치에 있는 undefined를 참조하게 되고<br>TypeError가 발생합니다.</p>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"try-catch\"><a href=\"#try-catch\" class=\"headerlink\" title=\"try-catch\"></a>try-catch</h2><p><strong>try-catch문에서 try 블록{}기준으로 블록 스코프를 갖습니다.</strong><br><strong>catch 블록은 스코프를 가지지 않으며 try 블록 스코프에 속합니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sports = <span class=\"string\">\"축구\"</span>; <span class=\"comment\">//try문 밖의 let sports   </span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> sports = <span class=\"string\">\"농구\"</span>; <span class=\"comment\">//try문 안에 let sports  </span></span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"built_in\">console</span>.log(sports);  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">console</span>.log(sports);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>  <span class=\"keyword\">try</span>문 블록&#123;&#125; 스코프의 sports 값 출력 “농구”</span><br><span class=\"line\"><span class=\"number\">2.</span>  <span class=\"keyword\">try</span>문 밖의 sports 값 출력 “축구”</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"switch-case\"><a href=\"#switch-case\" class=\"headerlink\" title=\"switch-case\"></a>switch-case</h2><p><strong>switch-case 문에서 switch 블록이 블록 스코프입니다.</strong><br><strong>switch 안에 case는 별도의 스코프를 갖지 않으며 switch 스코프에 속합니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">1</span>; <span class=\"comment\">// switch문의 case1:을 실행하기 위해 count에 1할당  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sports = <span class=\"string\">\"축구\"</span>; <span class=\"comment\">//switch문 밖의 let sports  </span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> (count) &#123;  </span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"number\">1</span>:  </span><br><span class=\"line\"> <span class=\"keyword\">let</span> sports = <span class=\"string\">\"농구\"</span>; <span class=\"comment\">//switch문 내의 let sports  </span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(sports); <span class=\"comment\">// \"농구\"가 출력됩니다.  </span></span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sports); <span class=\"comment\">//\"축구\"가 출력됩니다.</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for()\"></a>for()</h2><p>for()문에서 var변수로 작성하는 것과 let변수로 작성하는 것에는<br>큰 차이가 있습니다.<br><mark>let 변수는 반복할 때 마다 스코프를 갖는 반면,<br>var 변수는 스코프를 갖지 않습니다.</mark></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span>  </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>1~10<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>11~20<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>21~30<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><figcaption><span>var</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nodes = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"ul\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k = <span class=\"number\">0</span>; k &lt; nodes.children.length; k++)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> el = nodes.children[k];  </span><br><span class=\"line\"> el.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;  </span><br><span class=\"line\"> event.target.style.backgroundColor = <span class=\"string\">\"yellow\"</span>;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(k);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>querySelector(“ul”)으로 html에 작성된 li 요소 3개를 nodes 변수에 할당합니다.<br>nodes.childern.length는 NodeList의 요소 수로 3입니다.<br>for문을 반복하면서 각 li 요소마다 onclick 이벤트를 설정합니다.<br>클릭시 배경색을 변경하고 for문의 K 변수 값을 출력합니다.<br>어떤 li요소를 클릭하더라도 콘솔에 K값 3이 출력되며 3이 K의 최종값 입니다.</p>\n<p>클릭한 li 요소에 해당하는 K변수 값을 출력하고 싶다면<br>let변수를 사용하면 됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>let</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nodes = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"ul\"</span>);  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">0</span>; k &lt; nodes.children.length; k++)&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> el = nodes.children[k];  </span><br><span class=\"line\"> el.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;  </span><br><span class=\"line\"> event.target.style.backgroundColor = <span class=\"string\">\"yellow\"</span>;  </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(k);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>li요소를 클릭하면 onclick이벤트를 설정했을 때<br>사용한 K변수 값을 출력합니다. 0,1,2<br>이는 let변수가 스코프를 갖기 때문입니다.</p>\n<hr>\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><p>const 변수에 할당된 값은 상수가 됩니다.<br>상수는 재할당 할 수 없으며 재선언 할 수도 없습니다.</p>\n<p>const 변수는 선언-초기화-할당을 한번에 합니다.<br>즉, const a; 처럼 선언만 해놓을 수 없습니다.<br>반드시 const a = 0; 처럼 초기값을 할당해 줘야 합니다.</p>\n<p>상수 선언에는 대소문자 모두 사용할 수 있지만,<br>일반적인 관습은 모두 대문자를 사용하는 것입니다.</p>"},{"title":"효과 및 애니메이션 -jQuery","date":"2020-03-12T04:21:33.000Z","disqusId":"tunas-blog-1","_content":"\n*   jQuery Effects\n    *   [jQuery Hide/Show](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Hide_Show)\n    *   [jQuery Fade](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Fade)\n    *   [jQuery Slide](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Slide)\n    *   [jQuery Animate](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Animate)\n    *   [jQuery stop()](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_stop)\n    *   [jQuery delay()](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_delay)\n    *   [jQuery queue()](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_queue)\n    *   [jQuery finish()](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_finish)\n    *   [jQuery Callback](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Callback)\n    *   [jQuery Chaining](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Chaining)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"jQuery_Hide_Show\">hide() / show() / toggle()</h2>\n--------------------------\n\n> 1.  $(selector).hide(speed,callback);\n> 2.  $(selector).show(speed,callback);\n\n*   speed : 효과속도 vlaue:[ “fast” | “normarl” | “slow” | (milliseconds) ]\n*   callback : 콜백 함수 실행문 (콜백 매개 변수는 hide () 또는 show () 메소드가 완료된 후 실행될 함수입니다)\n\n1.  선택 요소를 효과 속도에 맞춰 숨긴 후 콜백 실행\n2.  선택 요소가 숨겨져 있는 경우 속도에 맞춰 노출시키고 콜백 실행\n\n```js\n$(\"#hide\").click(function(){  \n $(\"p\").hide();  \n});  \n  \n$(\"#show\").click(function(){  \n $(\"p\").show();  \n});  \n```\n\n**toggle() 메서드로 요소를 숨기거나 보여지게 할 수 있습니다.**\n\n```js\n$(\"button\").click(function(){  \n $(\"p\").toggle();  \n});  \n```\n\n*   speed : normarl 값을 제외한 “fast”, “slow” ,milliseconds 값을 사용할 수 있습니다.\n\n* * *\n\n<h2 id=\"jQuery_Fade\">fadeIn() / fadeOut() / fadeToggle() / fadeTo()</h2>\n----------------------------------------------\n\n* * *\n\n*   fadeIn() 메소드는 숨겨진 요소를 서서히 보여지게 합니다.\n\n```js\n$(\"button\").click(function(){  \n $(\"#div1\").fadeIn();  \n $(\"#div2\").fadeIn(\"slow\");  \n $(\"#div3\").fadeIn(3000);  \n});  \n```\n\n* * *\n\n*   fadeOut() 메소드는 보여지는 요소를 서서히 감춥니다.\n\n* * *\n\n*   fadeToggle() 메소드는  \n    요소가 숨겨져 있다면 서서히 보여지게,  \n    보여지고 있는 요소라면 서서히 감추게 해줍니다.\n\n* * *\n\n*   fadeTo() 메소드를 사용하면  \n    opacity (0~1사이) 값을 지정해서 요소를 사라지게 할 수 있습니다.\n\n```js\n$(\"button\").click(function(){  \n $(\"#div1\").fadeTo(\"slow\", 0.15);  \n $(\"#div2\").fadeTo(\"slow\", 0.4);  \n $(\"#div3\").fadeTo(\"slow\", 0.7);  \n});  \n```\n\n* * *\n\n<h2 id=\"jQuery_Slide\">slideDown() / slideUp() / slideToggle()</h2>\n---------------------------------------\n\n    $(selector).slide메소드(speed,callback);\n\nspeed: “slow”, “fast”, or milliseconds  \ncallback: 콜백 함수는 슬라이딩이 완료된 후 실행될 함수 입니다.\n\n* * *\n\n*   slideDown() 메소드는 요소를 슬라이드-다운(펼침) 하게 해줍니다.\n\n* * *\n\n*   slideUp() 메소드는  \n    slideDown되어 펼쳐져 있는 요소를 슬라이드-업(닫음) 하게 해줍니다.\n\n* * *\n\n*   slideToggle() 메소드는  \n    요소가 슬라이드 닫혀 있다면 펼쳐주고,  \n    펼쳐 있다면 닫아줍니다.\n\n```js\n$(\"#flip\").click(function(){ // 클릭 했을 때 실행됩니다.  \n $(\"#panel\").slideToggle();   \n // 클릭 이벤트가 발생한 요소 아래에 slide이벤트를 발생 시킵니다.  \n});  \n```\n\n* * *\n\n<h2 id=\"jQuery_Animate\">animate</h2>\n-------\n\nanimate() 메소드를 사용하여 animation을 커스텀 할 수 있습니다.\n\n> 기본형  \n$(selector).animate({params},speed,callback);\n\n*   params 매개 변수는 애니메이션효과를 줄 CSS 특성을 말합니다.\n\n```js 사용 예시\n$(\"button\").click(function(){  \n $(\"div\").animate({left: '250px'});  \n});  \n```\n\n`기본적으로 HTML 요소들은 정적위치를 가지기에 이동할 수 없습니다.`  \n`위치를 이동시키려면 우선 이동시킬 요소의 CSS 속성 position 값을`  \n`position: relative, fixed, or absolute으로 설정해 줘야 합니다.`\n\n* * *\n\n**animate() 메소드를 이용하여 여러CSS속성을 한번에 조작 할 수도 있습니다.**\n\n```js\n$(\"button\").click(function(){  \n $(\"div\").animate({  \n left: '250px',  \n opacity: '0.5',  \n height: '150px',  \n width: '150px'  \n });  \n});  \n```\n\n`animate() 메소드를 사용할 때 camel 네이밍 문법으로 사용했는지 유의하며 사용해야합니다.`\n\n> padding-left (x) : paddingLeft (o)  \n> margin-right (x) : marginRight (o)\n\n또한 색상 애니메이션은 jQuery핵심 파일에 포함되어 있지 않습니다.  \n색상에 애니메이션을 주고 싶다면  \nColor Animations plugin from [https://jQuery.com](https://jQuery.com)  \n다운받아야 합니다.\n\n* * *\n\n**애니메이션 효과를 현재 값을 기준으로 상대적으로 줄 수 있습니다.**\n\n단지 값앞에 += 또는 -= 을 넣어주는 것 만으로 됩니다.\n\n```js\n$(\"button\").click(function(){  \n $(\"div\").animate({  \n left: '250px',  \n height: '+=150px',  \n width: '+=150px'   \n });  \n});  \n```\n\n* * *\n\n**사전 정의된 값(Pre-defined Values)을 사용 할 수 있습니다.**\n\n예를 들어 animate()값을 hide,show,toggle 으로 줄 수 있습니다.\n\n```js toggle\n$(\"button\").click(function(){  \n $(\"div\").animate({  \n height: 'toggle'  \n //버튼이 클릭될 때 마다 height 속성이  \n //사라지거나 보여집니다.  \n });  \n});  \n```\n\n* * *\n\n**Uses Queue Functionality**\n\n기본적으로 jQuery에는 애니메이션 대기열 기능이 포함되어있습니다.\n\n이 말은 jQuery animate()메소드를 여러 줄로 작성했을 때  \njQuery 자체적으로 애니메이션들의 대기열을 만들어  \nanimate()메소드 들을 한번에 실행시키는 것이 아니라  \n한개씩 불러와 순차적으로 실행 시키는 기능을 말합니다.\n\n따라서, animate()끼리의 순차적으로 다른 애니메이션효과를 원할때 사용합니다.\n\n```js\n$(\"button\").click(function(){  \n var div = $(\"div\");  \n 1. div.animate({height: '300px', opacity: '0.4'}, \"slow\");  \n 2. div.animate({width: '300px', opacity: '0.8'}, \"slow\");  \n 3. div.animate({height: '100px', opacity: '0.4'}, \"slow\");  \n 4 .div.animate({width: '100px', opacity: '0.8'}, \"slow\");  \n});  \n```\n\nanimate가 동시에 실행 되는 것이 아니라\n\n1.animate 효과가 끝난 후  \n2.animate가 실행 / 3,4번까지  \n순차적으로 실행됩니다.\n\n* * *\n\n<h2 id=\"jQuery_stop\">stop()</h2>\n------\n\njQuery stop () 메서드는 애니메이션이나 효과가 끝나기 전에 중지하는 데 사용됩니다.\n\nstop () 메소드는 슬라이딩, 페이딩 및 사용자 정의 애니메이션을 포함한 모든 jQuery 효과 함수에 작동합니다.\n\n> $(selector).stop(stopAll,goToEnd);\n\n*   stopAll 선택적 매개 변수입니다.  \n    애니메이션 큐도 지워야하는지 여부를 지정합니다.  \n    기본값은 false입니다. 즉, 활성 애니메이션 만 중지되어  \n    대기중인 애니메이션을 나중에 수행 할 수 있습니다.\n    \n*   goToEnd 선택적 매개 변수입니다.  \n    현재 애니메이션을 즉시 완료할지 여부를 지정합니다.  \n    기본값은 false입니다.\n    \n\n따라서 기본적으로 stop() 메서드는  \n선택한 요소에서 수행중인 현재 애니메이션만 종료합니다.\n\n```js\n$(\"#stop\").click(function(){  \n $(\"#panel\").stop();  \n});  \n```\n\n* * *\n\n<h2 id=\"jQuery_delay\">delay()</h2>\n-------\n\ndelay() 메소드는 queue에서 다음 항목의 실행을 지연시킵니다.\n\n대기중인 effect가 지정된 시간만큼 지연된 후 발생합니다.\n\n> $(selector).delay(speed,queueName)\n\n*   queueName : queue이름을 직접 지정해 줄 수있습니다.  \n    기본값은 effect queue의 표준인 “fx”입니다.\n\n```js\n$(\"button\").click(function(){  \n $(\"#div1\").delay(\"slow\").fadeIn();  \n $(\"#div2\").delay(\"fast\").fadeIn();  \n $(\"#div3\").delay(1000).fadeIn();  \n});  \n```\n\n* * *\n\n<h2 id=\"jQuery_queue\">queue() / clearQueue() / dequeue()</h2>\n\nqueue란 특정 요소에 실행 대기 중인  \nmethod 또는 function의 저장소를 말합니다.\n\n    1. $(\"요소 선택\").queue();\n    2. $(\"요소 선택\").queue(function(){...});\n\n1.  선택한 요소의 queue에 대기중인 메서드를 반환합니다.\n2.  선택한 요소의 queue에 function을 저장합니다.  \n    저장된 이후에 대기중인 메서드는 모두 제거합니다.\n\n*   clearQueue() 메서드는  \n    요소의 queue에서 가장 앞에 있는 메서드만 뺴고  \n    나머지 queue에서 대기중인 모든 메서드를 제거합니다.\n    \n*   dequeue() 메서드는  \n    선택한 요소 큐에 대기중인 모든 메서드를 제거합니다.\n    \n\n* * *\n\n<h2 id=\"jQuery_finish\">finish()</h2>\n\nfinish()메소드는  \nanimation의 현재 동작상태를 모두 무시하고  \n완료 시켜버립니다. (최종 완료 시점만 보여줌)\n\n```js\n$(\"#complete\").click(function(){  \n $(\"div\").finish();  \n});  \n```\n\n구동 원리: 현재 실행중인 애니메이션을 중지하고  \nqueue에 대기중인 모든 애니메이션을 제거하고  \n선택한 요소에 대한 모든 애니메이션을 완료합니다.\n\n* * *\n\n<h2 id=\"jQuery_Callback\">Callback</h2>\n\ncallback() function은 현재 실행중인 효과가  \n완전히 끝난후 실행될 function을 의미합니다.\n\nJavascript문은 기본적으로 한줄씩 실행됩니다.  \n그러나 코드 내에 effect 들이 있다면  \n첫 줄 effect가 완료되기 전에 다음 코드 줄에 있는 effect가 실행되어  \n오류가 발생할 수 있습니다.\n\n이를 방지하기 위해 callback function을 만드는 것 입니다.\n\ncallback function 없이 사용했을 때\n\n```js\n$(\"button\").click(function(){  \n $(\"p\").hide(1000);  \n alert(\"The paragraph is now hidden\");  \n});  \n```\n\n위에 코드는 button요소를 클릭 했을 때 실행되지만  \np요소가 완전히 숨겨지고 나서  \n경고창이 나오지 않습니다.  \n숨겨지기전에 경고창이 나오게 될 것입니다.\n\n```js callback function 이용한 바른 예\n$(\"button\").click(function(){  \n $(\"p\").hide(1000, function(){  \n alert(\"The paragraph is now hidden\");  \n });  \n});  \n```\n\n먼저 실행될 hide메소드에 callback function을 넣어줘  \n정상적으로 p 요소가 완전히 hide 된 후  \n경고창이 표시됩니다.\n\n* * *\n\n<h2 id=\"jQuery_Chaining\">chaining</h2>\n\njQuery를 사용하면 액션 / 메소드를 함께 연결할 수 있습니다.  \n체인을 사용하면 단일 명령문 내에서 **동일한 요소를**  \n여러 jQuery 메소드로 실행할 수 있습니다.\n\n`이 방법으로 브라우저는 동일한 요소를 두 번 이상 찾을 필요가 없습니다.`\n\n```js\n$(\"#p1\").css(\"color\", \"red\").slideUp(2000).slideDown(2000);  \n===  \n$(\"#p1\").css(\"color\", \"red\")  \n .slideUp(2000)  \n .slideDown(2000);  \n```\n\n첫번째로 p요소의 색상이 변하고  \n두번째로 슬라이드가 닫히고,  \n세번째로 슬라이드가 펼쳐집니다.\n\n체인 방식으로 작성하다보면 코드줄이 길어질 수있습니다.\n\njQuery는 구문에 엄격하지 않으므로  \n가독성을 위해 줄 바꿈 및 들여쓰기를 사용하여 써도 잘 작동 합니다.\n","source":"_posts/효과 및 애니메이션 -jQuery.md","raw":"---\ntitle: 효과 및 애니메이션 -jQuery\ndate: 2020-03-12 13:21:33\ndisqusId: tunas-blog-1\ncategories: jQuery\ntag: \n- jQuery\n- JavaScript\n---\n\n*   jQuery Effects\n    *   [jQuery Hide/Show](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Hide_Show)\n    *   [jQuery Fade](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Fade)\n    *   [jQuery Slide](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Slide)\n    *   [jQuery Animate](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Animate)\n    *   [jQuery stop()](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_stop)\n    *   [jQuery delay()](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_delay)\n    *   [jQuery queue()](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_queue)\n    *   [jQuery finish()](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_finish)\n    *   [jQuery Callback](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Callback)\n    *   [jQuery Chaining](/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Chaining)\n\n<!-- more -->\n\n* * *\n\n<h2 id=\"jQuery_Hide_Show\">hide() / show() / toggle()</h2>\n--------------------------\n\n> 1.  $(selector).hide(speed,callback);\n> 2.  $(selector).show(speed,callback);\n\n*   speed : 효과속도 vlaue:[ “fast” | “normarl” | “slow” | (milliseconds) ]\n*   callback : 콜백 함수 실행문 (콜백 매개 변수는 hide () 또는 show () 메소드가 완료된 후 실행될 함수입니다)\n\n1.  선택 요소를 효과 속도에 맞춰 숨긴 후 콜백 실행\n2.  선택 요소가 숨겨져 있는 경우 속도에 맞춰 노출시키고 콜백 실행\n\n```js\n$(\"#hide\").click(function(){  \n $(\"p\").hide();  \n});  \n  \n$(\"#show\").click(function(){  \n $(\"p\").show();  \n});  \n```\n\n**toggle() 메서드로 요소를 숨기거나 보여지게 할 수 있습니다.**\n\n```js\n$(\"button\").click(function(){  \n $(\"p\").toggle();  \n});  \n```\n\n*   speed : normarl 값을 제외한 “fast”, “slow” ,milliseconds 값을 사용할 수 있습니다.\n\n* * *\n\n<h2 id=\"jQuery_Fade\">fadeIn() / fadeOut() / fadeToggle() / fadeTo()</h2>\n----------------------------------------------\n\n* * *\n\n*   fadeIn() 메소드는 숨겨진 요소를 서서히 보여지게 합니다.\n\n```js\n$(\"button\").click(function(){  \n $(\"#div1\").fadeIn();  \n $(\"#div2\").fadeIn(\"slow\");  \n $(\"#div3\").fadeIn(3000);  \n});  \n```\n\n* * *\n\n*   fadeOut() 메소드는 보여지는 요소를 서서히 감춥니다.\n\n* * *\n\n*   fadeToggle() 메소드는  \n    요소가 숨겨져 있다면 서서히 보여지게,  \n    보여지고 있는 요소라면 서서히 감추게 해줍니다.\n\n* * *\n\n*   fadeTo() 메소드를 사용하면  \n    opacity (0~1사이) 값을 지정해서 요소를 사라지게 할 수 있습니다.\n\n```js\n$(\"button\").click(function(){  \n $(\"#div1\").fadeTo(\"slow\", 0.15);  \n $(\"#div2\").fadeTo(\"slow\", 0.4);  \n $(\"#div3\").fadeTo(\"slow\", 0.7);  \n});  \n```\n\n* * *\n\n<h2 id=\"jQuery_Slide\">slideDown() / slideUp() / slideToggle()</h2>\n---------------------------------------\n\n    $(selector).slide메소드(speed,callback);\n\nspeed: “slow”, “fast”, or milliseconds  \ncallback: 콜백 함수는 슬라이딩이 완료된 후 실행될 함수 입니다.\n\n* * *\n\n*   slideDown() 메소드는 요소를 슬라이드-다운(펼침) 하게 해줍니다.\n\n* * *\n\n*   slideUp() 메소드는  \n    slideDown되어 펼쳐져 있는 요소를 슬라이드-업(닫음) 하게 해줍니다.\n\n* * *\n\n*   slideToggle() 메소드는  \n    요소가 슬라이드 닫혀 있다면 펼쳐주고,  \n    펼쳐 있다면 닫아줍니다.\n\n```js\n$(\"#flip\").click(function(){ // 클릭 했을 때 실행됩니다.  \n $(\"#panel\").slideToggle();   \n // 클릭 이벤트가 발생한 요소 아래에 slide이벤트를 발생 시킵니다.  \n});  \n```\n\n* * *\n\n<h2 id=\"jQuery_Animate\">animate</h2>\n-------\n\nanimate() 메소드를 사용하여 animation을 커스텀 할 수 있습니다.\n\n> 기본형  \n$(selector).animate({params},speed,callback);\n\n*   params 매개 변수는 애니메이션효과를 줄 CSS 특성을 말합니다.\n\n```js 사용 예시\n$(\"button\").click(function(){  \n $(\"div\").animate({left: '250px'});  \n});  \n```\n\n`기본적으로 HTML 요소들은 정적위치를 가지기에 이동할 수 없습니다.`  \n`위치를 이동시키려면 우선 이동시킬 요소의 CSS 속성 position 값을`  \n`position: relative, fixed, or absolute으로 설정해 줘야 합니다.`\n\n* * *\n\n**animate() 메소드를 이용하여 여러CSS속성을 한번에 조작 할 수도 있습니다.**\n\n```js\n$(\"button\").click(function(){  \n $(\"div\").animate({  \n left: '250px',  \n opacity: '0.5',  \n height: '150px',  \n width: '150px'  \n });  \n});  \n```\n\n`animate() 메소드를 사용할 때 camel 네이밍 문법으로 사용했는지 유의하며 사용해야합니다.`\n\n> padding-left (x) : paddingLeft (o)  \n> margin-right (x) : marginRight (o)\n\n또한 색상 애니메이션은 jQuery핵심 파일에 포함되어 있지 않습니다.  \n색상에 애니메이션을 주고 싶다면  \nColor Animations plugin from [https://jQuery.com](https://jQuery.com)  \n다운받아야 합니다.\n\n* * *\n\n**애니메이션 효과를 현재 값을 기준으로 상대적으로 줄 수 있습니다.**\n\n단지 값앞에 += 또는 -= 을 넣어주는 것 만으로 됩니다.\n\n```js\n$(\"button\").click(function(){  \n $(\"div\").animate({  \n left: '250px',  \n height: '+=150px',  \n width: '+=150px'   \n });  \n});  \n```\n\n* * *\n\n**사전 정의된 값(Pre-defined Values)을 사용 할 수 있습니다.**\n\n예를 들어 animate()값을 hide,show,toggle 으로 줄 수 있습니다.\n\n```js toggle\n$(\"button\").click(function(){  \n $(\"div\").animate({  \n height: 'toggle'  \n //버튼이 클릭될 때 마다 height 속성이  \n //사라지거나 보여집니다.  \n });  \n});  \n```\n\n* * *\n\n**Uses Queue Functionality**\n\n기본적으로 jQuery에는 애니메이션 대기열 기능이 포함되어있습니다.\n\n이 말은 jQuery animate()메소드를 여러 줄로 작성했을 때  \njQuery 자체적으로 애니메이션들의 대기열을 만들어  \nanimate()메소드 들을 한번에 실행시키는 것이 아니라  \n한개씩 불러와 순차적으로 실행 시키는 기능을 말합니다.\n\n따라서, animate()끼리의 순차적으로 다른 애니메이션효과를 원할때 사용합니다.\n\n```js\n$(\"button\").click(function(){  \n var div = $(\"div\");  \n 1. div.animate({height: '300px', opacity: '0.4'}, \"slow\");  \n 2. div.animate({width: '300px', opacity: '0.8'}, \"slow\");  \n 3. div.animate({height: '100px', opacity: '0.4'}, \"slow\");  \n 4 .div.animate({width: '100px', opacity: '0.8'}, \"slow\");  \n});  \n```\n\nanimate가 동시에 실행 되는 것이 아니라\n\n1.animate 효과가 끝난 후  \n2.animate가 실행 / 3,4번까지  \n순차적으로 실행됩니다.\n\n* * *\n\n<h2 id=\"jQuery_stop\">stop()</h2>\n------\n\njQuery stop () 메서드는 애니메이션이나 효과가 끝나기 전에 중지하는 데 사용됩니다.\n\nstop () 메소드는 슬라이딩, 페이딩 및 사용자 정의 애니메이션을 포함한 모든 jQuery 효과 함수에 작동합니다.\n\n> $(selector).stop(stopAll,goToEnd);\n\n*   stopAll 선택적 매개 변수입니다.  \n    애니메이션 큐도 지워야하는지 여부를 지정합니다.  \n    기본값은 false입니다. 즉, 활성 애니메이션 만 중지되어  \n    대기중인 애니메이션을 나중에 수행 할 수 있습니다.\n    \n*   goToEnd 선택적 매개 변수입니다.  \n    현재 애니메이션을 즉시 완료할지 여부를 지정합니다.  \n    기본값은 false입니다.\n    \n\n따라서 기본적으로 stop() 메서드는  \n선택한 요소에서 수행중인 현재 애니메이션만 종료합니다.\n\n```js\n$(\"#stop\").click(function(){  \n $(\"#panel\").stop();  \n});  \n```\n\n* * *\n\n<h2 id=\"jQuery_delay\">delay()</h2>\n-------\n\ndelay() 메소드는 queue에서 다음 항목의 실행을 지연시킵니다.\n\n대기중인 effect가 지정된 시간만큼 지연된 후 발생합니다.\n\n> $(selector).delay(speed,queueName)\n\n*   queueName : queue이름을 직접 지정해 줄 수있습니다.  \n    기본값은 effect queue의 표준인 “fx”입니다.\n\n```js\n$(\"button\").click(function(){  \n $(\"#div1\").delay(\"slow\").fadeIn();  \n $(\"#div2\").delay(\"fast\").fadeIn();  \n $(\"#div3\").delay(1000).fadeIn();  \n});  \n```\n\n* * *\n\n<h2 id=\"jQuery_queue\">queue() / clearQueue() / dequeue()</h2>\n\nqueue란 특정 요소에 실행 대기 중인  \nmethod 또는 function의 저장소를 말합니다.\n\n    1. $(\"요소 선택\").queue();\n    2. $(\"요소 선택\").queue(function(){...});\n\n1.  선택한 요소의 queue에 대기중인 메서드를 반환합니다.\n2.  선택한 요소의 queue에 function을 저장합니다.  \n    저장된 이후에 대기중인 메서드는 모두 제거합니다.\n\n*   clearQueue() 메서드는  \n    요소의 queue에서 가장 앞에 있는 메서드만 뺴고  \n    나머지 queue에서 대기중인 모든 메서드를 제거합니다.\n    \n*   dequeue() 메서드는  \n    선택한 요소 큐에 대기중인 모든 메서드를 제거합니다.\n    \n\n* * *\n\n<h2 id=\"jQuery_finish\">finish()</h2>\n\nfinish()메소드는  \nanimation의 현재 동작상태를 모두 무시하고  \n완료 시켜버립니다. (최종 완료 시점만 보여줌)\n\n```js\n$(\"#complete\").click(function(){  \n $(\"div\").finish();  \n});  \n```\n\n구동 원리: 현재 실행중인 애니메이션을 중지하고  \nqueue에 대기중인 모든 애니메이션을 제거하고  \n선택한 요소에 대한 모든 애니메이션을 완료합니다.\n\n* * *\n\n<h2 id=\"jQuery_Callback\">Callback</h2>\n\ncallback() function은 현재 실행중인 효과가  \n완전히 끝난후 실행될 function을 의미합니다.\n\nJavascript문은 기본적으로 한줄씩 실행됩니다.  \n그러나 코드 내에 effect 들이 있다면  \n첫 줄 effect가 완료되기 전에 다음 코드 줄에 있는 effect가 실행되어  \n오류가 발생할 수 있습니다.\n\n이를 방지하기 위해 callback function을 만드는 것 입니다.\n\ncallback function 없이 사용했을 때\n\n```js\n$(\"button\").click(function(){  \n $(\"p\").hide(1000);  \n alert(\"The paragraph is now hidden\");  \n});  \n```\n\n위에 코드는 button요소를 클릭 했을 때 실행되지만  \np요소가 완전히 숨겨지고 나서  \n경고창이 나오지 않습니다.  \n숨겨지기전에 경고창이 나오게 될 것입니다.\n\n```js callback function 이용한 바른 예\n$(\"button\").click(function(){  \n $(\"p\").hide(1000, function(){  \n alert(\"The paragraph is now hidden\");  \n });  \n});  \n```\n\n먼저 실행될 hide메소드에 callback function을 넣어줘  \n정상적으로 p 요소가 완전히 hide 된 후  \n경고창이 표시됩니다.\n\n* * *\n\n<h2 id=\"jQuery_Chaining\">chaining</h2>\n\njQuery를 사용하면 액션 / 메소드를 함께 연결할 수 있습니다.  \n체인을 사용하면 단일 명령문 내에서 **동일한 요소를**  \n여러 jQuery 메소드로 실행할 수 있습니다.\n\n`이 방법으로 브라우저는 동일한 요소를 두 번 이상 찾을 필요가 없습니다.`\n\n```js\n$(\"#p1\").css(\"color\", \"red\").slideUp(2000).slideDown(2000);  \n===  \n$(\"#p1\").css(\"color\", \"red\")  \n .slideUp(2000)  \n .slideDown(2000);  \n```\n\n첫번째로 p요소의 색상이 변하고  \n두번째로 슬라이드가 닫히고,  \n세번째로 슬라이드가 펼쳐집니다.\n\n체인 방식으로 작성하다보면 코드줄이 길어질 수있습니다.\n\njQuery는 구문에 엄격하지 않으므로  \n가독성을 위해 줄 바꿈 및 들여쓰기를 사용하여 써도 잘 작동 합니다.\n","slug":"효과 및 애니메이션 -jQuery","published":1,"updated":"2020-04-25T09:57:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9iqcrtm003xqgvqcptg1syi","content":"<ul>\n<li>jQuery Effects<ul>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Hide_Show\">jQuery Hide/Show</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Fade\">jQuery Fade</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Slide\">jQuery Slide</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Animate\">jQuery Animate</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_stop\">jQuery stop()</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_delay\">jQuery delay()</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_queue\">jQuery queue()</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_finish\">jQuery finish()</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Callback\">jQuery Callback</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Chaining\">jQuery Chaining</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"jQuery_Hide_Show\">hide() / show() / toggle()</h2>\n--------------------------\n\n<blockquote>\n<ol>\n<li>$(selector).hide(speed,callback);</li>\n<li>$(selector).show(speed,callback);</li>\n</ol>\n</blockquote>\n<ul>\n<li>speed : 효과속도 vlaue:[ “fast” | “normarl” | “slow” | (milliseconds) ]</li>\n<li>callback : 콜백 함수 실행문 (콜백 매개 변수는 hide () 또는 show () 메소드가 완료된 후 실행될 함수입니다)</li>\n</ul>\n<ol>\n<li>선택 요소를 효과 속도에 맞춰 숨긴 후 콜백 실행</li>\n<li>선택 요소가 숨겨져 있는 경우 속도에 맞춰 노출시키고 콜백 실행</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#hide\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"p\"</span>).hide();  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">$(<span class=\"string\">\"#show\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"p\"</span>).show();  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>toggle() 메서드로 요소를 숨기거나 보여지게 할 수 있습니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"p\"</span>).toggle();  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>speed : normarl 값을 제외한 “fast”, “slow” ,milliseconds 값을 사용할 수 있습니다.</li>\n</ul>\n<hr>\n<h2 id=\"jQuery_Fade\">fadeIn() / fadeOut() / fadeToggle() / fadeTo()</h2>\n----------------------------------------------\n\n<hr>\n<ul>\n<li>fadeIn() 메소드는 숨겨진 요소를 서서히 보여지게 합니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div1\"</span>).fadeIn();  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div2\"</span>).fadeIn(<span class=\"string\">\"slow\"</span>);  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div3\"</span>).fadeIn(<span class=\"number\">3000</span>);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<ul>\n<li>fadeOut() 메소드는 보여지는 요소를 서서히 감춥니다.</li>\n</ul>\n<hr>\n<ul>\n<li>fadeToggle() 메소드는<br>요소가 숨겨져 있다면 서서히 보여지게,<br>보여지고 있는 요소라면 서서히 감추게 해줍니다.</li>\n</ul>\n<hr>\n<ul>\n<li>fadeTo() 메소드를 사용하면<br>opacity (0~1사이) 값을 지정해서 요소를 사라지게 할 수 있습니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div1\"</span>).fadeTo(<span class=\"string\">\"slow\"</span>, <span class=\"number\">0.15</span>);  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div2\"</span>).fadeTo(<span class=\"string\">\"slow\"</span>, <span class=\"number\">0.4</span>);  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div3\"</span>).fadeTo(<span class=\"string\">\"slow\"</span>, <span class=\"number\">0.7</span>);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"jQuery_Slide\">slideDown() / slideUp() / slideToggle()</h2>\n---------------------------------------\n\n<pre><code>$(selector).slide메소드(speed,callback);</code></pre><p>speed: “slow”, “fast”, or milliseconds<br>callback: 콜백 함수는 슬라이딩이 완료된 후 실행될 함수 입니다.</p>\n<hr>\n<ul>\n<li>slideDown() 메소드는 요소를 슬라이드-다운(펼침) 하게 해줍니다.</li>\n</ul>\n<hr>\n<ul>\n<li>slideUp() 메소드는<br>slideDown되어 펼쳐져 있는 요소를 슬라이드-업(닫음) 하게 해줍니다.</li>\n</ul>\n<hr>\n<ul>\n<li>slideToggle() 메소드는<br>요소가 슬라이드 닫혀 있다면 펼쳐주고,<br>펼쳐 있다면 닫아줍니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#flip\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// 클릭 했을 때 실행됩니다.  </span></span><br><span class=\"line\"> $(<span class=\"string\">\"#panel\"</span>).slideToggle();   </span><br><span class=\"line\"> <span class=\"comment\">// 클릭 이벤트가 발생한 요소 아래에 slide이벤트를 발생 시킵니다.  </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"jQuery_Animate\">animate</h2>\n-------\n\n<p>animate() 메소드를 사용하여 animation을 커스텀 할 수 있습니다.</p>\n<blockquote>\n<p>기본형<br>$(selector).animate({params},speed,callback);</p>\n</blockquote>\n<ul>\n<li>params 매개 변수는 애니메이션효과를 줄 CSS 특성을 말합니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>사용 예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"div\"</span>).animate(&#123;<span class=\"attr\">left</span>: <span class=\"string\">'250px'</span>&#125;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>기본적으로 HTML 요소들은 정적위치를 가지기에 이동할 수 없습니다.</code><br><code>위치를 이동시키려면 우선 이동시킬 요소의 CSS 속성 position 값을</code><br><code>position: relative, fixed, or absolute으로 설정해 줘야 합니다.</code></p>\n<hr>\n<p><strong>animate() 메소드를 이용하여 여러CSS속성을 한번에 조작 할 수도 있습니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"div\"</span>).animate(&#123;  </span><br><span class=\"line\"> left: <span class=\"string\">'250px'</span>,  </span><br><span class=\"line\"> opacity: <span class=\"string\">'0.5'</span>,  </span><br><span class=\"line\"> height: <span class=\"string\">'150px'</span>,  </span><br><span class=\"line\"> width: <span class=\"string\">'150px'</span>  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>animate() 메소드를 사용할 때 camel 네이밍 문법으로 사용했는지 유의하며 사용해야합니다.</code></p>\n<blockquote>\n<p>padding-left (x) : paddingLeft (o)<br>margin-right (x) : marginRight (o)</p>\n</blockquote>\n<p>또한 색상 애니메이션은 jQuery핵심 파일에 포함되어 있지 않습니다.<br>색상에 애니메이션을 주고 싶다면<br>Color Animations plugin from <a href=\"https://jQuery.com\">https://jQuery.com</a><br>다운받아야 합니다.</p>\n<hr>\n<p><strong>애니메이션 효과를 현재 값을 기준으로 상대적으로 줄 수 있습니다.</strong></p>\n<p>단지 값앞에 += 또는 -= 을 넣어주는 것 만으로 됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"div\"</span>).animate(&#123;  </span><br><span class=\"line\"> left: <span class=\"string\">'250px'</span>,  </span><br><span class=\"line\"> height: <span class=\"string\">'+=150px'</span>,  </span><br><span class=\"line\"> width: <span class=\"string\">'+=150px'</span>   </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>사전 정의된 값(Pre-defined Values)을 사용 할 수 있습니다.</strong></p>\n<p>예를 들어 animate()값을 hide,show,toggle 으로 줄 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>toggle</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"div\"</span>).animate(&#123;  </span><br><span class=\"line\"> height: <span class=\"string\">'toggle'</span>  </span><br><span class=\"line\"> <span class=\"comment\">//버튼이 클릭될 때 마다 height 속성이  </span></span><br><span class=\"line\"> <span class=\"comment\">//사라지거나 보여집니다.  </span></span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>Uses Queue Functionality</strong></p>\n<p>기본적으로 jQuery에는 애니메이션 대기열 기능이 포함되어있습니다.</p>\n<p>이 말은 jQuery animate()메소드를 여러 줄로 작성했을 때<br>jQuery 자체적으로 애니메이션들의 대기열을 만들어<br>animate()메소드 들을 한번에 실행시키는 것이 아니라<br>한개씩 불러와 순차적으로 실행 시키는 기능을 말합니다.</p>\n<p>따라서, animate()끼리의 순차적으로 다른 애니메이션효과를 원할때 사용합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> div = $(<span class=\"string\">\"div\"</span>);  </span><br><span class=\"line\"> <span class=\"number\">1.</span> div.animate(&#123;<span class=\"attr\">height</span>: <span class=\"string\">'300px'</span>, <span class=\"attr\">opacity</span>: <span class=\"string\">'0.4'</span>&#125;, <span class=\"string\">\"slow\"</span>);  </span><br><span class=\"line\"> <span class=\"number\">2.</span> div.animate(&#123;<span class=\"attr\">width</span>: <span class=\"string\">'300px'</span>, <span class=\"attr\">opacity</span>: <span class=\"string\">'0.8'</span>&#125;, <span class=\"string\">\"slow\"</span>);  </span><br><span class=\"line\"> <span class=\"number\">3.</span> div.animate(&#123;<span class=\"attr\">height</span>: <span class=\"string\">'100px'</span>, <span class=\"attr\">opacity</span>: <span class=\"string\">'0.4'</span>&#125;, <span class=\"string\">\"slow\"</span>);  </span><br><span class=\"line\"> <span class=\"number\">4</span> .div.animate(&#123;<span class=\"attr\">width</span>: <span class=\"string\">'100px'</span>, <span class=\"attr\">opacity</span>: <span class=\"string\">'0.8'</span>&#125;, <span class=\"string\">\"slow\"</span>);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>animate가 동시에 실행 되는 것이 아니라</p>\n<p>1.animate 효과가 끝난 후<br>2.animate가 실행 / 3,4번까지<br>순차적으로 실행됩니다.</p>\n<hr>\n<h2 id=\"jQuery_stop\">stop()</h2>\n------\n\n<p>jQuery stop () 메서드는 애니메이션이나 효과가 끝나기 전에 중지하는 데 사용됩니다.</p>\n<p>stop () 메소드는 슬라이딩, 페이딩 및 사용자 정의 애니메이션을 포함한 모든 jQuery 효과 함수에 작동합니다.</p>\n<blockquote>\n<p>$(selector).stop(stopAll,goToEnd);</p>\n</blockquote>\n<ul>\n<li><p>stopAll 선택적 매개 변수입니다.<br>애니메이션 큐도 지워야하는지 여부를 지정합니다.<br>기본값은 false입니다. 즉, 활성 애니메이션 만 중지되어<br>대기중인 애니메이션을 나중에 수행 할 수 있습니다.</p>\n</li>\n<li><p>goToEnd 선택적 매개 변수입니다.<br>현재 애니메이션을 즉시 완료할지 여부를 지정합니다.<br>기본값은 false입니다.</p>\n</li>\n</ul>\n<p>따라서 기본적으로 stop() 메서드는<br>선택한 요소에서 수행중인 현재 애니메이션만 종료합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#stop\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"#panel\"</span>).stop();  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"jQuery_delay\">delay()</h2>\n-------\n\n<p>delay() 메소드는 queue에서 다음 항목의 실행을 지연시킵니다.</p>\n<p>대기중인 effect가 지정된 시간만큼 지연된 후 발생합니다.</p>\n<blockquote>\n<p>$(selector).delay(speed,queueName)</p>\n</blockquote>\n<ul>\n<li>queueName : queue이름을 직접 지정해 줄 수있습니다.<br>기본값은 effect queue의 표준인 “fx”입니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div1\"</span>).delay(<span class=\"string\">\"slow\"</span>).fadeIn();  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div2\"</span>).delay(<span class=\"string\">\"fast\"</span>).fadeIn();  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div3\"</span>).delay(<span class=\"number\">1000</span>).fadeIn();  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"jQuery_queue\">queue() / clearQueue() / dequeue()</h2>\n\n<p>queue란 특정 요소에 실행 대기 중인<br>method 또는 function의 저장소를 말합니다.</p>\n<pre><code>1. $(&quot;요소 선택&quot;).queue();\n2. $(&quot;요소 선택&quot;).queue(function(){...});</code></pre><ol>\n<li>선택한 요소의 queue에 대기중인 메서드를 반환합니다.</li>\n<li>선택한 요소의 queue에 function을 저장합니다.<br>저장된 이후에 대기중인 메서드는 모두 제거합니다.</li>\n</ol>\n<ul>\n<li><p>clearQueue() 메서드는<br>요소의 queue에서 가장 앞에 있는 메서드만 뺴고<br>나머지 queue에서 대기중인 모든 메서드를 제거합니다.</p>\n</li>\n<li><p>dequeue() 메서드는<br>선택한 요소 큐에 대기중인 모든 메서드를 제거합니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"jQuery_finish\">finish()</h2>\n\n<p>finish()메소드는<br>animation의 현재 동작상태를 모두 무시하고<br>완료 시켜버립니다. (최종 완료 시점만 보여줌)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#complete\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"div\"</span>).finish();  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>구동 원리: 현재 실행중인 애니메이션을 중지하고<br>queue에 대기중인 모든 애니메이션을 제거하고<br>선택한 요소에 대한 모든 애니메이션을 완료합니다.</p>\n<hr>\n<h2 id=\"jQuery_Callback\">Callback</h2>\n\n<p>callback() function은 현재 실행중인 효과가<br>완전히 끝난후 실행될 function을 의미합니다.</p>\n<p>Javascript문은 기본적으로 한줄씩 실행됩니다.<br>그러나 코드 내에 effect 들이 있다면<br>첫 줄 effect가 완료되기 전에 다음 코드 줄에 있는 effect가 실행되어<br>오류가 발생할 수 있습니다.</p>\n<p>이를 방지하기 위해 callback function을 만드는 것 입니다.</p>\n<p>callback function 없이 사용했을 때</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"p\"</span>).hide(<span class=\"number\">1000</span>);  </span><br><span class=\"line\"> alert(<span class=\"string\">\"The paragraph is now hidden\"</span>);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>위에 코드는 button요소를 클릭 했을 때 실행되지만<br>p요소가 완전히 숨겨지고 나서<br>경고창이 나오지 않습니다.<br>숨겨지기전에 경고창이 나오게 될 것입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>callback function 이용한 바른 예</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"p\"</span>).hide(<span class=\"number\">1000</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> alert(<span class=\"string\">\"The paragraph is now hidden\"</span>);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>먼저 실행될 hide메소드에 callback function을 넣어줘<br>정상적으로 p 요소가 완전히 hide 된 후<br>경고창이 표시됩니다.</p>\n<hr>\n<h2 id=\"jQuery_Chaining\">chaining</h2>\n\n<p>jQuery를 사용하면 액션 / 메소드를 함께 연결할 수 있습니다.<br>체인을 사용하면 단일 명령문 내에서 <strong>동일한 요소를</strong><br>여러 jQuery 메소드로 실행할 수 있습니다.</p>\n<p><code>이 방법으로 브라우저는 동일한 요소를 두 번 이상 찾을 필요가 없습니다.</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#p1\"</span>).css(<span class=\"string\">\"color\"</span>, <span class=\"string\">\"red\"</span>).slideUp(<span class=\"number\">2000</span>).slideDown(<span class=\"number\">2000</span>);  </span><br><span class=\"line\">===  </span><br><span class=\"line\">$(<span class=\"string\">\"#p1\"</span>).css(<span class=\"string\">\"color\"</span>, <span class=\"string\">\"red\"</span>)  </span><br><span class=\"line\"> .slideUp(<span class=\"number\">2000</span>)  </span><br><span class=\"line\"> .slideDown(<span class=\"number\">2000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>첫번째로 p요소의 색상이 변하고<br>두번째로 슬라이드가 닫히고,<br>세번째로 슬라이드가 펼쳐집니다.</p>\n<p>체인 방식으로 작성하다보면 코드줄이 길어질 수있습니다.</p>\n<p>jQuery는 구문에 엄격하지 않으므로<br>가독성을 위해 줄 바꿈 및 들여쓰기를 사용하여 써도 잘 작동 합니다.</p>\n","site":{"data":{}},"excerpt":"<ul>\n<li>jQuery Effects<ul>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Hide_Show\">jQuery Hide/Show</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Fade\">jQuery Fade</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Slide\">jQuery Slide</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Animate\">jQuery Animate</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_stop\">jQuery stop()</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_delay\">jQuery delay()</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_queue\">jQuery queue()</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_finish\">jQuery finish()</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Callback\">jQuery Callback</a></li>\n<li><a href=\"/2020/03/12/효과%20및%20애니메이션%20-jQuery/#jQuery_Chaining\">jQuery Chaining</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"jQuery_Hide_Show\">hide() / show() / toggle()</h2>\n--------------------------\n\n<blockquote>\n<ol>\n<li>$(selector).hide(speed,callback);</li>\n<li>$(selector).show(speed,callback);</li>\n</ol>\n</blockquote>\n<ul>\n<li>speed : 효과속도 vlaue:[ “fast” | “normarl” | “slow” | (milliseconds) ]</li>\n<li>callback : 콜백 함수 실행문 (콜백 매개 변수는 hide () 또는 show () 메소드가 완료된 후 실행될 함수입니다)</li>\n</ul>\n<ol>\n<li>선택 요소를 효과 속도에 맞춰 숨긴 후 콜백 실행</li>\n<li>선택 요소가 숨겨져 있는 경우 속도에 맞춰 노출시키고 콜백 실행</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#hide\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"p\"</span>).hide();  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">$(<span class=\"string\">\"#show\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"p\"</span>).show();  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>toggle() 메서드로 요소를 숨기거나 보여지게 할 수 있습니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"p\"</span>).toggle();  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>speed : normarl 값을 제외한 “fast”, “slow” ,milliseconds 값을 사용할 수 있습니다.</li>\n</ul>\n<hr>\n<h2 id=\"jQuery_Fade\">fadeIn() / fadeOut() / fadeToggle() / fadeTo()</h2>\n----------------------------------------------\n\n<hr>\n<ul>\n<li>fadeIn() 메소드는 숨겨진 요소를 서서히 보여지게 합니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div1\"</span>).fadeIn();  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div2\"</span>).fadeIn(<span class=\"string\">\"slow\"</span>);  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div3\"</span>).fadeIn(<span class=\"number\">3000</span>);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<ul>\n<li>fadeOut() 메소드는 보여지는 요소를 서서히 감춥니다.</li>\n</ul>\n<hr>\n<ul>\n<li>fadeToggle() 메소드는<br>요소가 숨겨져 있다면 서서히 보여지게,<br>보여지고 있는 요소라면 서서히 감추게 해줍니다.</li>\n</ul>\n<hr>\n<ul>\n<li>fadeTo() 메소드를 사용하면<br>opacity (0~1사이) 값을 지정해서 요소를 사라지게 할 수 있습니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div1\"</span>).fadeTo(<span class=\"string\">\"slow\"</span>, <span class=\"number\">0.15</span>);  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div2\"</span>).fadeTo(<span class=\"string\">\"slow\"</span>, <span class=\"number\">0.4</span>);  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div3\"</span>).fadeTo(<span class=\"string\">\"slow\"</span>, <span class=\"number\">0.7</span>);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"jQuery_Slide\">slideDown() / slideUp() / slideToggle()</h2>\n---------------------------------------\n\n<pre><code>$(selector).slide메소드(speed,callback);</code></pre><p>speed: “slow”, “fast”, or milliseconds<br>callback: 콜백 함수는 슬라이딩이 완료된 후 실행될 함수 입니다.</p>\n<hr>\n<ul>\n<li>slideDown() 메소드는 요소를 슬라이드-다운(펼침) 하게 해줍니다.</li>\n</ul>\n<hr>\n<ul>\n<li>slideUp() 메소드는<br>slideDown되어 펼쳐져 있는 요소를 슬라이드-업(닫음) 하게 해줍니다.</li>\n</ul>\n<hr>\n<ul>\n<li>slideToggle() 메소드는<br>요소가 슬라이드 닫혀 있다면 펼쳐주고,<br>펼쳐 있다면 닫아줍니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#flip\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// 클릭 했을 때 실행됩니다.  </span></span><br><span class=\"line\"> $(<span class=\"string\">\"#panel\"</span>).slideToggle();   </span><br><span class=\"line\"> <span class=\"comment\">// 클릭 이벤트가 발생한 요소 아래에 slide이벤트를 발생 시킵니다.  </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"jQuery_Animate\">animate</h2>\n-------\n\n<p>animate() 메소드를 사용하여 animation을 커스텀 할 수 있습니다.</p>\n<blockquote>\n<p>기본형<br>$(selector).animate({params},speed,callback);</p>\n</blockquote>\n<ul>\n<li>params 매개 변수는 애니메이션효과를 줄 CSS 특성을 말합니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>사용 예시</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"div\"</span>).animate(&#123;<span class=\"attr\">left</span>: <span class=\"string\">'250px'</span>&#125;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>기본적으로 HTML 요소들은 정적위치를 가지기에 이동할 수 없습니다.</code><br><code>위치를 이동시키려면 우선 이동시킬 요소의 CSS 속성 position 값을</code><br><code>position: relative, fixed, or absolute으로 설정해 줘야 합니다.</code></p>\n<hr>\n<p><strong>animate() 메소드를 이용하여 여러CSS속성을 한번에 조작 할 수도 있습니다.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"div\"</span>).animate(&#123;  </span><br><span class=\"line\"> left: <span class=\"string\">'250px'</span>,  </span><br><span class=\"line\"> opacity: <span class=\"string\">'0.5'</span>,  </span><br><span class=\"line\"> height: <span class=\"string\">'150px'</span>,  </span><br><span class=\"line\"> width: <span class=\"string\">'150px'</span>  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>animate() 메소드를 사용할 때 camel 네이밍 문법으로 사용했는지 유의하며 사용해야합니다.</code></p>\n<blockquote>\n<p>padding-left (x) : paddingLeft (o)<br>margin-right (x) : marginRight (o)</p>\n</blockquote>\n<p>또한 색상 애니메이션은 jQuery핵심 파일에 포함되어 있지 않습니다.<br>색상에 애니메이션을 주고 싶다면<br>Color Animations plugin from <a href=\"https://jQuery.com\">https://jQuery.com</a><br>다운받아야 합니다.</p>\n<hr>\n<p><strong>애니메이션 효과를 현재 값을 기준으로 상대적으로 줄 수 있습니다.</strong></p>\n<p>단지 값앞에 += 또는 -= 을 넣어주는 것 만으로 됩니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"div\"</span>).animate(&#123;  </span><br><span class=\"line\"> left: <span class=\"string\">'250px'</span>,  </span><br><span class=\"line\"> height: <span class=\"string\">'+=150px'</span>,  </span><br><span class=\"line\"> width: <span class=\"string\">'+=150px'</span>   </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>사전 정의된 값(Pre-defined Values)을 사용 할 수 있습니다.</strong></p>\n<p>예를 들어 animate()값을 hide,show,toggle 으로 줄 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>toggle</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"div\"</span>).animate(&#123;  </span><br><span class=\"line\"> height: <span class=\"string\">'toggle'</span>  </span><br><span class=\"line\"> <span class=\"comment\">//버튼이 클릭될 때 마다 height 속성이  </span></span><br><span class=\"line\"> <span class=\"comment\">//사라지거나 보여집니다.  </span></span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>Uses Queue Functionality</strong></p>\n<p>기본적으로 jQuery에는 애니메이션 대기열 기능이 포함되어있습니다.</p>\n<p>이 말은 jQuery animate()메소드를 여러 줄로 작성했을 때<br>jQuery 자체적으로 애니메이션들의 대기열을 만들어<br>animate()메소드 들을 한번에 실행시키는 것이 아니라<br>한개씩 불러와 순차적으로 실행 시키는 기능을 말합니다.</p>\n<p>따라서, animate()끼리의 순차적으로 다른 애니메이션효과를 원할때 사용합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> <span class=\"keyword\">var</span> div = $(<span class=\"string\">\"div\"</span>);  </span><br><span class=\"line\"> <span class=\"number\">1.</span> div.animate(&#123;<span class=\"attr\">height</span>: <span class=\"string\">'300px'</span>, <span class=\"attr\">opacity</span>: <span class=\"string\">'0.4'</span>&#125;, <span class=\"string\">\"slow\"</span>);  </span><br><span class=\"line\"> <span class=\"number\">2.</span> div.animate(&#123;<span class=\"attr\">width</span>: <span class=\"string\">'300px'</span>, <span class=\"attr\">opacity</span>: <span class=\"string\">'0.8'</span>&#125;, <span class=\"string\">\"slow\"</span>);  </span><br><span class=\"line\"> <span class=\"number\">3.</span> div.animate(&#123;<span class=\"attr\">height</span>: <span class=\"string\">'100px'</span>, <span class=\"attr\">opacity</span>: <span class=\"string\">'0.4'</span>&#125;, <span class=\"string\">\"slow\"</span>);  </span><br><span class=\"line\"> <span class=\"number\">4</span> .div.animate(&#123;<span class=\"attr\">width</span>: <span class=\"string\">'100px'</span>, <span class=\"attr\">opacity</span>: <span class=\"string\">'0.8'</span>&#125;, <span class=\"string\">\"slow\"</span>);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>animate가 동시에 실행 되는 것이 아니라</p>\n<p>1.animate 효과가 끝난 후<br>2.animate가 실행 / 3,4번까지<br>순차적으로 실행됩니다.</p>\n<hr>\n<h2 id=\"jQuery_stop\">stop()</h2>\n------\n\n<p>jQuery stop () 메서드는 애니메이션이나 효과가 끝나기 전에 중지하는 데 사용됩니다.</p>\n<p>stop () 메소드는 슬라이딩, 페이딩 및 사용자 정의 애니메이션을 포함한 모든 jQuery 효과 함수에 작동합니다.</p>\n<blockquote>\n<p>$(selector).stop(stopAll,goToEnd);</p>\n</blockquote>\n<ul>\n<li><p>stopAll 선택적 매개 변수입니다.<br>애니메이션 큐도 지워야하는지 여부를 지정합니다.<br>기본값은 false입니다. 즉, 활성 애니메이션 만 중지되어<br>대기중인 애니메이션을 나중에 수행 할 수 있습니다.</p>\n</li>\n<li><p>goToEnd 선택적 매개 변수입니다.<br>현재 애니메이션을 즉시 완료할지 여부를 지정합니다.<br>기본값은 false입니다.</p>\n</li>\n</ul>\n<p>따라서 기본적으로 stop() 메서드는<br>선택한 요소에서 수행중인 현재 애니메이션만 종료합니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#stop\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"#panel\"</span>).stop();  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"jQuery_delay\">delay()</h2>\n-------\n\n<p>delay() 메소드는 queue에서 다음 항목의 실행을 지연시킵니다.</p>\n<p>대기중인 effect가 지정된 시간만큼 지연된 후 발생합니다.</p>\n<blockquote>\n<p>$(selector).delay(speed,queueName)</p>\n</blockquote>\n<ul>\n<li>queueName : queue이름을 직접 지정해 줄 수있습니다.<br>기본값은 effect queue의 표준인 “fx”입니다.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div1\"</span>).delay(<span class=\"string\">\"slow\"</span>).fadeIn();  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div2\"</span>).delay(<span class=\"string\">\"fast\"</span>).fadeIn();  </span><br><span class=\"line\"> $(<span class=\"string\">\"#div3\"</span>).delay(<span class=\"number\">1000</span>).fadeIn();  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"jQuery_queue\">queue() / clearQueue() / dequeue()</h2>\n\n<p>queue란 특정 요소에 실행 대기 중인<br>method 또는 function의 저장소를 말합니다.</p>\n<pre><code>1. $(&quot;요소 선택&quot;).queue();\n2. $(&quot;요소 선택&quot;).queue(function(){...});</code></pre><ol>\n<li>선택한 요소의 queue에 대기중인 메서드를 반환합니다.</li>\n<li>선택한 요소의 queue에 function을 저장합니다.<br>저장된 이후에 대기중인 메서드는 모두 제거합니다.</li>\n</ol>\n<ul>\n<li><p>clearQueue() 메서드는<br>요소의 queue에서 가장 앞에 있는 메서드만 뺴고<br>나머지 queue에서 대기중인 모든 메서드를 제거합니다.</p>\n</li>\n<li><p>dequeue() 메서드는<br>선택한 요소 큐에 대기중인 모든 메서드를 제거합니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"jQuery_finish\">finish()</h2>\n\n<p>finish()메소드는<br>animation의 현재 동작상태를 모두 무시하고<br>완료 시켜버립니다. (최종 완료 시점만 보여줌)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#complete\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"div\"</span>).finish();  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>구동 원리: 현재 실행중인 애니메이션을 중지하고<br>queue에 대기중인 모든 애니메이션을 제거하고<br>선택한 요소에 대한 모든 애니메이션을 완료합니다.</p>\n<hr>\n<h2 id=\"jQuery_Callback\">Callback</h2>\n\n<p>callback() function은 현재 실행중인 효과가<br>완전히 끝난후 실행될 function을 의미합니다.</p>\n<p>Javascript문은 기본적으로 한줄씩 실행됩니다.<br>그러나 코드 내에 effect 들이 있다면<br>첫 줄 effect가 완료되기 전에 다음 코드 줄에 있는 effect가 실행되어<br>오류가 발생할 수 있습니다.</p>\n<p>이를 방지하기 위해 callback function을 만드는 것 입니다.</p>\n<p>callback function 없이 사용했을 때</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"p\"</span>).hide(<span class=\"number\">1000</span>);  </span><br><span class=\"line\"> alert(<span class=\"string\">\"The paragraph is now hidden\"</span>);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>위에 코드는 button요소를 클릭 했을 때 실행되지만<br>p요소가 완전히 숨겨지고 나서<br>경고창이 나오지 않습니다.<br>숨겨지기전에 경고창이 나오게 될 것입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>callback function 이용한 바른 예</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"button\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> $(<span class=\"string\">\"p\"</span>).hide(<span class=\"number\">1000</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\"> alert(<span class=\"string\">\"The paragraph is now hidden\"</span>);  </span><br><span class=\"line\"> &#125;);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>먼저 실행될 hide메소드에 callback function을 넣어줘<br>정상적으로 p 요소가 완전히 hide 된 후<br>경고창이 표시됩니다.</p>\n<hr>\n<h2 id=\"jQuery_Chaining\">chaining</h2>\n\n<p>jQuery를 사용하면 액션 / 메소드를 함께 연결할 수 있습니다.<br>체인을 사용하면 단일 명령문 내에서 <strong>동일한 요소를</strong><br>여러 jQuery 메소드로 실행할 수 있습니다.</p>\n<p><code>이 방법으로 브라우저는 동일한 요소를 두 번 이상 찾을 필요가 없습니다.</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#p1\"</span>).css(<span class=\"string\">\"color\"</span>, <span class=\"string\">\"red\"</span>).slideUp(<span class=\"number\">2000</span>).slideDown(<span class=\"number\">2000</span>);  </span><br><span class=\"line\">===  </span><br><span class=\"line\">$(<span class=\"string\">\"#p1\"</span>).css(<span class=\"string\">\"color\"</span>, <span class=\"string\">\"red\"</span>)  </span><br><span class=\"line\"> .slideUp(<span class=\"number\">2000</span>)  </span><br><span class=\"line\"> .slideDown(<span class=\"number\">2000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>첫번째로 p요소의 색상이 변하고<br>두번째로 슬라이드가 닫히고,<br>세번째로 슬라이드가 펼쳐집니다.</p>\n<p>체인 방식으로 작성하다보면 코드줄이 길어질 수있습니다.</p>\n<p>jQuery는 구문에 엄격하지 않으므로<br>가독성을 위해 줄 바꿈 및 들여쓰기를 사용하여 써도 잘 작동 합니다.</p>"},{"title":"콜백 함수 -Core JavaScript","disqusId":"tunas-blog-1","date":"2020-04-30T11:03:50.000Z","_content":"\n* 콜백 함수\n  * [콜백 함수란?](/2020/04/30/콜백-함수-Core-JavaScript/#callback)\n  * [제어권](/2020/04/30/콜백-함수-Core-JavaScript/#callback_제어권)\n    * 인자\n    * this\n  * [콜백 함수는 함수다.](/2020/04/30/콜백-함수-Core-JavaScript/#callback_function)\n  * [콜백 함수 내부의 this에 다른 값 바인딩하기](/2020/04/30/콜백-함수-Core-JavaScript/#callback_this_binding)\n  * [콜백 지옥과 비동기 제어](/2020/04/30/콜백-함수-Core-JavaScript/#callback_hell)\n\n<!-- more -->\n\n------\n<h2 id=\"callback\">콜백 함수란?</h2>\n\n콜백 함수(`callback function`)는 다른 코드의 인자로 넘겨주는 함수 입니다.\n\n`callback`은 부르다, 호출하다, 실행하다의 의미인 call 과 되돌아오다 back의 합성어로,\n되돌아 호출하다라는 의미로 이해할 수 있습니다.\n\n특정 `함수a`를 호출하면서 '특정 조건일때 `함수b`를 실행해서 알려달라는'요청을 보내는 것입니다.\n`함수a`의 입장에서는 해당 조건이 갖춰졌는지 여부를 스스로 판단하고 `함수b`를 직접 호출합니다.\n\n이처럼 콜백 함수는 다른 코드(함수 또는 메서드)에게 인자를 넘겨줌으로써 그 <mark>제어권도 함께 위임한 함수</mark>입니다. (콜백 함수를 위임받은 코드는 자체적인 내부 로직에 의해 이 콜백 함수를 적절한 시점에 실행합니다.)\n\n------\n<h2 id=\"callback_제어권\">제어권</h2>\n\n몇 가지 예제\n\n------\n### 호출 시점\n\n```js setInterval\n1. var count = 0;\n2. var timer = setInterval(function() {\n  console.log(count);\n  if (++count > 4) clearInterval(timer);\n}, 300);\n```\n\n우선 `setInterval` 메서드의 형태를 살펴보면 다음과 같습니다.\n> var 참조변수(interval ID) = scope.setInterval(func, delay[, param1, param2, ...]);\n\n* socpe :\n  `Window` 객체 또는 `Worker`의 인스턴스가 들어올 수 있습니다. 두 객체 모두 `setInterval` 메서드를 제공하기 때문입니다. 일반적인 브라우저 환경에서는 `window`를 생략하고 함수처럼 사용할 수 있습니다.\n\n\n* 매개변수\n  `func`, `delay` 값을 반드시 전달해야 합니다.\n  세 번째 매개변수 부터는 선택적 파라미터로 `func` 함수를 실행할때 전달할 파라미터입니다.\n  `func`에 넘겨준 함수는 매 `delay(ms)`마다 실행되며, 그 결과로 어떤 값도 반환하지 않습니다.\n\n\n* `setInterval`을 실행하면 반복적으로 실행되는 내용 자체를 특정할 수 있는 고유 ID 값이 반환됩니다.\n이를 변수에 담는 이유는 반복 실행되는 중간에 종료(`clearInterval`)할 수 있게 하기 위해서 입니다.\n\n1. `count` 변수를 선언하고 0을 할당합니다.\n\n2. `timer` 변수를 선언하고 setInterval 결과를 할당했습니다.\n\n**위에 코드를 콜백 함수를 확인하기 쉽게 수정했습니다.**\n\n```js callback - setInterval\nvar count = 0;\nvar cbFunc = function() {\n  console.log(count);\n  if (++count > 4) clearInterval(timer);\n};\nvar timer = setInterval(cbFunc, 300);\n\n// -- 실행 결과 --\n// 0  (0.3초)\n// 1  (0.6초)\n// 2  (0.9초)\n// 3  (1.2초)\n// 4  (1.5초)\n```\n\n*  `timer`변수에는 `setInterval`의 ID 값이 담기게 됩니다.\n\n\n* `setInterval`에 전달한 첫 번째 인자인 `cbFunc`함수(이 함수가 곧 콜백함수입니다.)는 0.3초마다 자동으로 실행될 것입니다. \n\n\n* 콜백 함수 내부에서는 `count` 값을 출력하고 1씩 증가시키며, `count`값이 4보다 크면 반복 실행이 종료됩니다.\n\n\n* 제어권\n`setInterval` 메서드에 첫 번째 인자로 `cbFunc` 함수를 넘겨주자 제어권을 넘겨받은 `setInterval` 메서드는 0.3초마다 (지정된 시점) 이 익명 함수를 실행했습니다. 이처럼 <u>콜백 함수의 제어권을 넘겨받은 코드</u>는 <mark>콜백 함수 호출 시점에 대한 제어권</mark>을 가집니다.\n\n### 인자 (파라미터)\n\n```js\nvar newArr = [10, 20, 30].map(function(currentValue, index) {\n  console.log(currentValue, index);\n  return currentValue + 5;\n});\nconsole.log(newArr);\n\n// -- 실행 결과 --\n// 10 0\n// 20 1\n// 30 2\n// [15, 25, 35]\n```\n1. `newArr` 변수를 선언하고 오른쪽에 배열 `[10, 20, 30]`에 `map` 메서드를 호출하고 그 결과를 할당합니다.\n\n  `map`메서드의 동작 방식부터 살펴보도록 하겠습니다.\n  > Array.prototype.map(callback[, thisArg])\ncallback : function(currentValue, index, array)\n\n  `map` 메서드는 Array.prototype에 담긴 메서드입니다.\n\n  * 파라미터\n    * 첫 번째 인자: `callback` 함수를 받습니다\n    * 두 번째 인자: 생략가능한 파라미터이며, 콜백 함수 내부에서 `this`로 인식할 대상을 지정합니다. 생략시 일반적인 함수와 마찬가지로 전역객체를 참조하게 됩니다.\n\n  * 반환 값\n    * `map`메서드는 메서드의 대상이 되는 배열의 모든 요소들을 차례대로 불러와 콜백 함수를 반복 호출하고, <u>콜백 함수의 실행 결과를 모아 새로운 배열</u>을 반환합니다.\n\n  * `callback`함수\n  콜백 함수의 첫 번째 인자에는 배열의 요소중 `현재값`, 두 번째 인자에는 `현재값의 index`, 세 번째 인자에는 `map`메서드의 `대상이 되는 배열`이 담깁니다.\n\n\n2. `map` 메서드는 배열`[10, 20, 30]`의 각 요소를 차례대로 꺼내어 콜백 함수를 실행합니다.\n\n\n3. 첫 번째 요소에 대한 콜백 함수는 `currentValue`에 10이, `index`에는 index 0이 담긴 채 실행됩니다 `return currentValue + 5;` 코드를 실행하여 `(10 + 5)` 값인 `15`가 반환됩니다.\n\n\n4. 두 번째 요소에 대한 콜백 함수는 `currentValue`에 20이, `index`에는 index 1이 담긴 채 실행됩니다 `return currentValue + 5;` 코드를 실행하여 `(20 + 5)` 값인 `25`가 반환됩니다.\n\n\n5. 세 번째 요소에 대한 콜백 함수는 `currentValue`에 30이, `index`에는 index 2이 담긴 채 실행됩니다 `return currentValue + 5;` 코드를 실행하여 `(30 + 5)` 값인 `35`가 반환됩니다.\n\n\n6. 모든 요소에 대한 콜백 함수를 마치고 나면 `[15, 25, 35]`라는 새로운 배열이 만들어져 `newArr`변수에 할당됩니다.\n\n\n7. `console.log(newArr)` 코드에서 `newArr`변수에 할당된 새로운 배열이 출력됩니다.\n\n\n**중요 포인트**\n\n`콜백 함수`의 파라미터 순서를 바꾸면 안됩니다. `currentValue`, `index`순 이어야하며\n바뀐다면 전혀 다른 값을 반환할 것입니다.\n\n~~엔진은 파라미터로 받은 값의 단어(name)를 인식하는 것이 아니라 순서(첫 번째, 두 번째)에 의해서만 각각을 구분하고 인식합니다.~~ \n\n-------\n### this\n\n콜백 함수 내부에서의 this\n\n```js\n1. setTimeout(function() {\n  console.log(this);\n}, 300); // (1) Window { ... }\n\n2. [1, 2, 3, 4, 5].forEach(function(x) {\n  console.log(this); // (2) Window { ... }\n});\n\ndocument.body.innerHTML += '<button id=\"a\">클릭</button>';\n3. document.body.querySelector('#a').addEventListener(\n  'click',\n  function(e) {\n    console.log(this, e); // (3) <button id=\"a\">클릭</button>\n  } // MouseEvent { isTrusted: true, ... }\n);\n```\n\n1. `setTimeout`은 내부에서 콜백 함수를 호출할 때 `call`메서드의 첫 번째 인자로 전역객체를 넘기게 됩니다. 콜백 함수 내부에서 `this`가 전역객체를 가리키게됩니다. \n\n\n2. `forEach`는 '별도의 인자로 this를 받는 경우'에 해당하지만 별도로 `this`를 지정해주지 않았기 때문에 전역객체를 가리키게됩니다.\n\n\n3. `addEventListener`는 내부에서 콜백 함수를 호출할 때 `call`메서드의 첫 번째 인자에 `addEventListener`메서드의 `this`를 넘기도록 정의되어 있습니다. 때문에 콜백 함수 내부에서의 `this`는 `addEventListener`를 호출한 주체 `HTML` 엘리먼트를 가리키게 됩니다. \n\n------\n<h2 id=\"callback_function\">콜백 함수는 함수다.</h2>\n\n콜백 함수로 객체의 메서드를 전달하더라도 그 메서드는 메서드가 아닌 함수로 호출됩니다.\n\n```js 메서드를 콜백 함수로 전달한 경우\n1. var obj = {\n  vals: [1, 2, 3],\n  logValues: function(v, i) {\n    console.log(this, v, i);\n  },\n};\n2. obj.logValues(1, 2); // { vals: [1, 2, 3], logValues: f } 1 2\n3. [4, 5, 6].forEach(obj.logValues); // Window { ... } 4 0\n// Window { ... } 5 1\n// Window { ... } 6 2\n```\n\n1. `obj` 객체의 `logValues`는 메서드로 정의됐습니다.\n\n\n2. 메서드의 이름 앞에 점(.)이 있으니 메서드로서 호출한 것 입니다. `this`는 `obj`를 가리키고 파라미터로 넘겨준 1, 2와 함께 출력됩니다.\n\n\n3. `obj.logValues`메서드를 `forEach` 함수의 콜백 함수로서 지정했습니다.\n`obj`를 `this`로 하는 메서드를 그대로 전달한 것이 아니라, `obj.logValues`가 가리키는 함수만 전달한 것입니다.\n이 함수는 메서드로서 호출할 때가 아닌 한 `obj`와의 직접적인 연관이 없어집니다.\n`forEach`에 의해 콜백이 함수로서 호출되고, 별도로 `this`를 지정하지 않았으므로 `this`는 전역객체를 참조합니다.\n\n**중요 포인트**\n\n어떤 함수의 인자(파라미터)에 객체의 메서드를 전달하더라도 메서드가 아닌 함수일 뿐입니다.\n이 차이를 정확히 이해하는 것이 중요합니다.\n\n------\n<h2 id=\"callback_this_binding\">콜백 함수 내부의 this에 다른 값 바인딩 하기</h2>\n\n콜백 함수에서 `this`를 지정하지 않으면 전역객체를 참조하게 되므로\n객체의 메서드를 콜백 함수로 전달하면 해당 객체를 `this`로 참조할 수 없게됩니다.\n\n별도의 인자(`thisArg`)로 `this`를 받는 함수의 경우에는 원하는 값을 넘겨주면 되지만 그렇지 않은 경우에는 `this`의 제어권도 넘겨주게 되므로 사용자가 임의로 값을 변경할 수 없습니다.\n\n그래서 <makr>전통적으로는 `this`를 다른 변수에 담아 콜백 함수로 활용할 함수에서는 `this`대신 그 변수를 사용하게 하고, 이를 클로저로 만드는 방식이 많이 쓰였습니다.</mark>\n\n```js 콜백 함수 내부의 this에 다른 값을 바인딩 - 전통적인 방법(변수 사용)\nvar obj1 = {\n  name: 'obj1',\n  func: function() {\n    var self = this;\n    return function() {\n      console.log(self.name);\n    };\n  },\n};\nvar callback = obj1.func();\nsetTimeout(callback, 1000);\n```\n\n1. `obj1.func` 메서드 내부에서 `self` 변수에 `this`를 담고, 익명 함수를 선언하고 반환했습니다.\n\n\n2. `obj1.func`를 호출하면 앞서 선언한 내부함수가 반환되어 `callback` 변수에 할당됩니다.\n\n\n3. 이 `callback`변수를 `setTimeout` 함수에 인자로 전달하면 1초(1000ms) 뒤 `callback`이 실행되면서 `\"obj1\"`을 반환할 것입니다.\n\n**중요 포인트**\n이 방식은 `this`를 다른 변수에 담아 함수내에서 `this` 대신 그 변수를 사용하게하여 실제로는 `this`를 사용하지 않을뿐더러 번거롭습니다.\n\n* ES5에 등장한 `bind`메서드를 사용하면 더욱 간편히 `this`를 바인딩할 수 있습니다.\n```js 콜백 함수 내부의 this에 다른 값 바인딩 - bind 메서드 사용\nvar obj1 = {\n  name: 'obj1',\n  func: function() {\n    console.log(this.name);\n  },\n};\nsetTimeout(obj1.func.bind(obj1), 1000);\n\nvar obj2 = { name: 'obj2' };\nsetTimeout(obj1.func.bind(obj2), 1500);\n```\n\n* `bind` 메서드의 첫 번째 인자(`thisArg`)로 `this`로 지정할 값을 전달합니다.\n함수가 실행될때 `this`는 `thisArg`로 전달받은 값을 참조하게 됩니다.\n\n------\n<h2 id=\"callback_hell\">콜백 지옥과 비동기 제어</h2>\n\n* 콜백 지옥(`callback hell`)이란?\n\n  콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상.\n  주로 이벤트 처리나 서버 통신과 같이 비동기적인 작업을 수행하기 위해 이런 형태가 자주 등장하곤 하는데, 가독성이 떨어질 뿐더러 코드를 수정하기도 힘들다.\n\n\n* 비동기(`asynchronous`)란?\n  \n  동기(`synchronous`)의 반대말로 <mark>동기적인 코드는 현재 실행 중인 코드가 완료된 후에야 다음 코드를 실행하는 방식</mark>\n  비동기적 코드는 <mark>현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어갑니다.</mark>\n  \n\n  1. 사용자의 요청에 의해 특정 시간이 경과되기 전까지 어떤 함수의 실행을 보류한다거나 -`setTimeout`\n\n  2. 사용자의 직접적인 개입이 있을 때 어떤 함수를 실행하도록 대기한다거나 -`addEventListener`\n\n  3. 웹브라우저 자체가 아닌 별도의 대상에 무언가를 요청하고 그에 대한 응답이 왔을 때 어떤 함수를 실행하도록 대기하는 등 -`XMLHttpRequest`\n\n  ~~CPU의 계산에 의해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드입니다.~~\n  <mark>별도의 요청, 실행 대기, 보류 등과 관련된 코드는 비동기적인 코드입니다.</mark>\n\n* 현대의 자바스크립트는 웹의 복잡도가 높아진 만큼 비동기적인 코드의 비중이 예전보다 훨씬 높아진 상황입니다. (콜백 지옥에 빠지기도 훨씬 쉬워졌습니다.)\n\n------\n**간단한 콜백 지옥 예시를 살펴봅시다.**\n\n```js callback-hell\nsetTimeout(function(name) {\n    var coffeeList = name;\n    console.log(coffeeList);\n\n    setTimeout(function(name) {\n        coffeeList += ', ' + name;\n        console.log(coffeeList);\n\n        setTimeout(function(name) {\n            coffeeList += ', ' + name;\n            console.log(coffeeList);\n\n            setTimeout(function(name) {\n                coffeeList += ', ' + name;\n                console.log(coffeeList);\n              }, 500, '카페라떼');\n          }, 500, '카페모카');\n      }, 500, '아메리카노');\n  }, 500, '에스프레소');\n```\n\n* 0.5 초마다 커피 목록을 수집하고 출력합니다. 각 콜백은 커피 이름을 전달하고 `coffeeList`에 추가합니다. \n\n* 실행에는 지장이 없는 코드입니다만, 들여쓰기 수준이 과도하게 깊어졌을 뿐더러 수정하기도 불편하고 값이 전달되는 순서가 아래에서 위로 향하고 있어 어색하게도 느껴집니다.\n\n가독성 문제와 어색함을 동시에 해결하는 방법은 익명 콜백함수를 모두 기명함수로 전환하는 방법이 있습니다...?!\n\n------\n```js 기명함수로 변환\nvar coffeeList = '';\n\nvar addEspresso = function(name) {\n  coffeeList = name;\n  console.log(coffeeList);\n  setTimeout(addAmericano, 500, '아메리카노');\n};\nvar addAmericano = function(name) {\n  coffeeList += ', ' + name;\n  console.log(coffeeList);\n  setTimeout(addMocha, 500, '카페모카');\n};\nvar addMocha = function(name) {\n  coffeeList += ', ' + name;\n  console.log(coffeeList);\n  setTimeout(addLatte, 500, '카페라떼');\n};\nvar addLatte = function(name) {\n  coffeeList += ', ' + name;\n  console.log(coffeeList);\n};\n\nsetTimeout(addEspresso, 500, '에스프레소');\n```\n\n* 익명함수를 기명함수로 변환하므로서 콜백 지옥을 해결한 예시입니다.\n\n함수 선언과 함수 호출을 구분한다면 코드의 가독성을 높여 코드를 위에서 아래로 읽어내려가는데 어려움이 없습니다. 변수가 전역으로 전개되긴 했지만 즉시 실행 함수 등으로 감싸면 해결할 수 있는 문제입니다.\n\n하지만 코드명을 일일이 따라다녀야 하므로 오히려 헷갈릴 여지도 있습니다.\n\n* 자바스크립트는 비동기적인 작업들을 동기적으로(혹은 동기적인 것처럼 보이도록) 처리해주는 방법을 고안했고, 그 결과 `ES6`에서 `Promise`, `Generator`등이 도입됐으며, `ES8(ES2017)`에서는 `async`, `wait`가 도입됐습니다.\n\n------\n**이들을 활용한 표현법도 알아봅시다.**\n\n```js 비동기 작업의 동기적 표현 -Promise\nnew Promise(function(resolve) {\n  setTimeout(function() {\n    var name = '에스프레소';\n    console.log(name);\n    resolve(name);\n  }, 500);\n})\n  .then(function(prevName) {\n    return new Promise(function(resolve) {\n      setTimeout(function() {\n        var name = prevName + ', 아메리카노';\n        console.log(name);\n        resolve(name);\n      }, 500);\n    });\n  })\n  .then(function(prevName) {\n    return new Promise(function(resolve) {\n      setTimeout(function() {\n        var name = prevName + ', 카페모카';\n        console.log(name);\n        resolve(name);\n      }, 500);\n    });\n  })\n  .then(function(prevName) {\n    return new Promise(function(resolve) {\n      setTimeout(function() {\n        var name = prevName + ', 카페라떼';\n        console.log(name);\n        resolve(name);\n      }, 500);\n    });\n  });\n```\n\n`ES6`의 `Promise`를 이용한 방법입니다. `new`연산자와 함께 호출한 `Promise`의 인자로 넘겨주는 콜백 함수는 호출할 때 바로 실행되지만 내부에 `resolve` 또는 `reject` 함수를 호출하는 구문이 있을 경우 둘 중하나가 충족되어 실행되기 전까지는 `.then` 또는 `.catch` 구문으로 넘어가지 않습니다.\n\n따라서 비동기 작업이 완료될 때 `resolve` 또는 `reject`를 호출하는 방법으로 비동기 작업의 동기적 표현이 가능합니다.\n\n------\n다음은 위에 코드의 반복적인 내용을 함수화 하여 더욱 짧게 표현한 것입니다.\n\n```js Promise 동기적표현 함수화\nvar addCoffee = function(name) {\n  return function(prevName) {\n    return new Promise(function(resolve) {\n      setTimeout(function() {\n        var newName = prevName ? prevName + ', ' + name : name;\n        console.log(newName);\n        resolve(newName);\n      }, 500);\n    });\n  };\n};\naddCoffee('에스프레소')()\n  .then(addCoffee('아메리카노'))\n  .then(addCoffee('카페모카'))\n  .then(addCoffee('카페라떼'));\n```\n\n------\n* Generator 활용\n\n```js 비동기 작업의 동기적 표현 -Generator\nvar addCoffee = function(prevName, name) {\n  setTimeout(function() {\n    coffeeMaker.next(prevName ? prevName + ', ' + name : name);\n  }, 500);\n};\nvar coffeeGenerator = function*() {\n  var espresso = yield addCoffee('', '에스프레소');\n  console.log(espresso);\n  var americano = yield addCoffee(espresso, '아메리카노');\n  console.log(americano);\n  var mocha = yield addCoffee(americano, '카페모카');\n  console.log(mocha);\n  var latte = yield addCoffee(mocha, '카페라떼');\n  console.log(latte);\n};\nvar coffeeMaker = coffeeGenerator();\ncoffeeMaker.next();\n```\n\n`ES6`의 `Generator`를 이용한 방법입니다.\n`Generator` 함수를 실행하여 `Iterator`을 반환받고 `Iterator`의 메서드 `next`를 사용할 수 있습니다\n\n`next` 메서드를 호출하면 `Generator` 함수 내부에서 첫 번째 `yield`를 만나면 함수 실행을 멈추게 되고 다시 `next`를 호출하면 멈춘 부분부터 그 다음에 등장하는 `yield`에서 함수 실행을 멈추게 됩니다.\n\n즉, 비동기 작업이 완료되는 시점마다 `next` 메서드를 호출해준다면 `Generator` 함수 내부의 소스가 순차적으로 진행되게 합니다.\n\n------\n* Promise + async/await\n\n```js\nvar addCoffee = function(name) {\n  return new Promise(function(resolve) {\n    setTimeout(function() {\n      resolve(name);\n    }, 500);\n  });\n};\nvar coffeeMaker = async function() {\n  var coffeeList = '';\n  var _addCoffee = async function(name) {\n    coffeeList += (coffeeList ? ',' : '') + (await addCoffee(name));\n  };\n  await _addCoffee('에스프레소');\n  console.log(coffeeList);\n  await _addCoffee('아메리카노');\n  console.log(coffeeList);\n  await _addCoffee('카페모카');\n  console.log(coffeeList);\n  await _addCoffee('카페라떼');\n  console.log(coffeeList);\n};\ncoffeeMaker();\n```\n\n`ES8(ES2017)`에서 추가된 `async/await`는 비동기 작업을 수행하고자 하는 함수 앞에 `async`를 표기하고, 함수 내부에서 비동기 작업이 필요한 위치마다 `await`를 표기하는 것만으로 뒤의 내용을 `Promise`로 자동 전환하고, 해당 내용이 `resolve`된 이후에야 다음으로 진행합니다.\n\n`Promise`의 `then`과 비슷한 효과를 얻을 수 있습니다.\n\n------\n<h2 id=\"callback\">정리</h2>\n\n* 콜백 함수는 다른 코드에 인자를 넘겨줌으로써 <mark>제어권도 함께 위임</mark>.\n\n\n* 제어권을 넘겨받은 코드는 \n  1. 콜백 함수를 호출하는 시점을 지정.\n\n  2. 콜백 함수를 호출할 때 <mark>인자로 넘겨줄 값의 순서를 변경하지 말 것.</mark>\n\n  3. 콜백 함수는 `this`를 지정하여 사용할 수 있는 함수가 존재, 지정하지 않을 경우 전역객체를 참조\n  사용자 임의로 `this`를 변경하고 싶은 경우 `bind` 메서드 활용\n\n\n* 함수에 인자로 메서드를 전달하더라도 이는 <mark>함수로서 실행됨</mark>.\n\n\n* 비동기 제어를 위해 콜백 함수를 사용하다 보면 콜백 지옥에 빠지기 쉬움.\n최근의 자바스크립트에서는 <mark>Promise, Generator, async/await</mark> 등 콜백 지옥을 벗어날 수 있는 방법들이 등장함.","source":"_posts/콜백-함수-Core-JavaScript.md","raw":"---\ntitle: 콜백 함수 -Core JavaScript\ndisqusId: tunas-blog-1\ntags:\n  - Core JavaScript\n  - JavaScript\ndate: 2020-04-30 20:03:50\ncategories: Core JavaScript\n---\n\n* 콜백 함수\n  * [콜백 함수란?](/2020/04/30/콜백-함수-Core-JavaScript/#callback)\n  * [제어권](/2020/04/30/콜백-함수-Core-JavaScript/#callback_제어권)\n    * 인자\n    * this\n  * [콜백 함수는 함수다.](/2020/04/30/콜백-함수-Core-JavaScript/#callback_function)\n  * [콜백 함수 내부의 this에 다른 값 바인딩하기](/2020/04/30/콜백-함수-Core-JavaScript/#callback_this_binding)\n  * [콜백 지옥과 비동기 제어](/2020/04/30/콜백-함수-Core-JavaScript/#callback_hell)\n\n<!-- more -->\n\n------\n<h2 id=\"callback\">콜백 함수란?</h2>\n\n콜백 함수(`callback function`)는 다른 코드의 인자로 넘겨주는 함수 입니다.\n\n`callback`은 부르다, 호출하다, 실행하다의 의미인 call 과 되돌아오다 back의 합성어로,\n되돌아 호출하다라는 의미로 이해할 수 있습니다.\n\n특정 `함수a`를 호출하면서 '특정 조건일때 `함수b`를 실행해서 알려달라는'요청을 보내는 것입니다.\n`함수a`의 입장에서는 해당 조건이 갖춰졌는지 여부를 스스로 판단하고 `함수b`를 직접 호출합니다.\n\n이처럼 콜백 함수는 다른 코드(함수 또는 메서드)에게 인자를 넘겨줌으로써 그 <mark>제어권도 함께 위임한 함수</mark>입니다. (콜백 함수를 위임받은 코드는 자체적인 내부 로직에 의해 이 콜백 함수를 적절한 시점에 실행합니다.)\n\n------\n<h2 id=\"callback_제어권\">제어권</h2>\n\n몇 가지 예제\n\n------\n### 호출 시점\n\n```js setInterval\n1. var count = 0;\n2. var timer = setInterval(function() {\n  console.log(count);\n  if (++count > 4) clearInterval(timer);\n}, 300);\n```\n\n우선 `setInterval` 메서드의 형태를 살펴보면 다음과 같습니다.\n> var 참조변수(interval ID) = scope.setInterval(func, delay[, param1, param2, ...]);\n\n* socpe :\n  `Window` 객체 또는 `Worker`의 인스턴스가 들어올 수 있습니다. 두 객체 모두 `setInterval` 메서드를 제공하기 때문입니다. 일반적인 브라우저 환경에서는 `window`를 생략하고 함수처럼 사용할 수 있습니다.\n\n\n* 매개변수\n  `func`, `delay` 값을 반드시 전달해야 합니다.\n  세 번째 매개변수 부터는 선택적 파라미터로 `func` 함수를 실행할때 전달할 파라미터입니다.\n  `func`에 넘겨준 함수는 매 `delay(ms)`마다 실행되며, 그 결과로 어떤 값도 반환하지 않습니다.\n\n\n* `setInterval`을 실행하면 반복적으로 실행되는 내용 자체를 특정할 수 있는 고유 ID 값이 반환됩니다.\n이를 변수에 담는 이유는 반복 실행되는 중간에 종료(`clearInterval`)할 수 있게 하기 위해서 입니다.\n\n1. `count` 변수를 선언하고 0을 할당합니다.\n\n2. `timer` 변수를 선언하고 setInterval 결과를 할당했습니다.\n\n**위에 코드를 콜백 함수를 확인하기 쉽게 수정했습니다.**\n\n```js callback - setInterval\nvar count = 0;\nvar cbFunc = function() {\n  console.log(count);\n  if (++count > 4) clearInterval(timer);\n};\nvar timer = setInterval(cbFunc, 300);\n\n// -- 실행 결과 --\n// 0  (0.3초)\n// 1  (0.6초)\n// 2  (0.9초)\n// 3  (1.2초)\n// 4  (1.5초)\n```\n\n*  `timer`변수에는 `setInterval`의 ID 값이 담기게 됩니다.\n\n\n* `setInterval`에 전달한 첫 번째 인자인 `cbFunc`함수(이 함수가 곧 콜백함수입니다.)는 0.3초마다 자동으로 실행될 것입니다. \n\n\n* 콜백 함수 내부에서는 `count` 값을 출력하고 1씩 증가시키며, `count`값이 4보다 크면 반복 실행이 종료됩니다.\n\n\n* 제어권\n`setInterval` 메서드에 첫 번째 인자로 `cbFunc` 함수를 넘겨주자 제어권을 넘겨받은 `setInterval` 메서드는 0.3초마다 (지정된 시점) 이 익명 함수를 실행했습니다. 이처럼 <u>콜백 함수의 제어권을 넘겨받은 코드</u>는 <mark>콜백 함수 호출 시점에 대한 제어권</mark>을 가집니다.\n\n### 인자 (파라미터)\n\n```js\nvar newArr = [10, 20, 30].map(function(currentValue, index) {\n  console.log(currentValue, index);\n  return currentValue + 5;\n});\nconsole.log(newArr);\n\n// -- 실행 결과 --\n// 10 0\n// 20 1\n// 30 2\n// [15, 25, 35]\n```\n1. `newArr` 변수를 선언하고 오른쪽에 배열 `[10, 20, 30]`에 `map` 메서드를 호출하고 그 결과를 할당합니다.\n\n  `map`메서드의 동작 방식부터 살펴보도록 하겠습니다.\n  > Array.prototype.map(callback[, thisArg])\ncallback : function(currentValue, index, array)\n\n  `map` 메서드는 Array.prototype에 담긴 메서드입니다.\n\n  * 파라미터\n    * 첫 번째 인자: `callback` 함수를 받습니다\n    * 두 번째 인자: 생략가능한 파라미터이며, 콜백 함수 내부에서 `this`로 인식할 대상을 지정합니다. 생략시 일반적인 함수와 마찬가지로 전역객체를 참조하게 됩니다.\n\n  * 반환 값\n    * `map`메서드는 메서드의 대상이 되는 배열의 모든 요소들을 차례대로 불러와 콜백 함수를 반복 호출하고, <u>콜백 함수의 실행 결과를 모아 새로운 배열</u>을 반환합니다.\n\n  * `callback`함수\n  콜백 함수의 첫 번째 인자에는 배열의 요소중 `현재값`, 두 번째 인자에는 `현재값의 index`, 세 번째 인자에는 `map`메서드의 `대상이 되는 배열`이 담깁니다.\n\n\n2. `map` 메서드는 배열`[10, 20, 30]`의 각 요소를 차례대로 꺼내어 콜백 함수를 실행합니다.\n\n\n3. 첫 번째 요소에 대한 콜백 함수는 `currentValue`에 10이, `index`에는 index 0이 담긴 채 실행됩니다 `return currentValue + 5;` 코드를 실행하여 `(10 + 5)` 값인 `15`가 반환됩니다.\n\n\n4. 두 번째 요소에 대한 콜백 함수는 `currentValue`에 20이, `index`에는 index 1이 담긴 채 실행됩니다 `return currentValue + 5;` 코드를 실행하여 `(20 + 5)` 값인 `25`가 반환됩니다.\n\n\n5. 세 번째 요소에 대한 콜백 함수는 `currentValue`에 30이, `index`에는 index 2이 담긴 채 실행됩니다 `return currentValue + 5;` 코드를 실행하여 `(30 + 5)` 값인 `35`가 반환됩니다.\n\n\n6. 모든 요소에 대한 콜백 함수를 마치고 나면 `[15, 25, 35]`라는 새로운 배열이 만들어져 `newArr`변수에 할당됩니다.\n\n\n7. `console.log(newArr)` 코드에서 `newArr`변수에 할당된 새로운 배열이 출력됩니다.\n\n\n**중요 포인트**\n\n`콜백 함수`의 파라미터 순서를 바꾸면 안됩니다. `currentValue`, `index`순 이어야하며\n바뀐다면 전혀 다른 값을 반환할 것입니다.\n\n~~엔진은 파라미터로 받은 값의 단어(name)를 인식하는 것이 아니라 순서(첫 번째, 두 번째)에 의해서만 각각을 구분하고 인식합니다.~~ \n\n-------\n### this\n\n콜백 함수 내부에서의 this\n\n```js\n1. setTimeout(function() {\n  console.log(this);\n}, 300); // (1) Window { ... }\n\n2. [1, 2, 3, 4, 5].forEach(function(x) {\n  console.log(this); // (2) Window { ... }\n});\n\ndocument.body.innerHTML += '<button id=\"a\">클릭</button>';\n3. document.body.querySelector('#a').addEventListener(\n  'click',\n  function(e) {\n    console.log(this, e); // (3) <button id=\"a\">클릭</button>\n  } // MouseEvent { isTrusted: true, ... }\n);\n```\n\n1. `setTimeout`은 내부에서 콜백 함수를 호출할 때 `call`메서드의 첫 번째 인자로 전역객체를 넘기게 됩니다. 콜백 함수 내부에서 `this`가 전역객체를 가리키게됩니다. \n\n\n2. `forEach`는 '별도의 인자로 this를 받는 경우'에 해당하지만 별도로 `this`를 지정해주지 않았기 때문에 전역객체를 가리키게됩니다.\n\n\n3. `addEventListener`는 내부에서 콜백 함수를 호출할 때 `call`메서드의 첫 번째 인자에 `addEventListener`메서드의 `this`를 넘기도록 정의되어 있습니다. 때문에 콜백 함수 내부에서의 `this`는 `addEventListener`를 호출한 주체 `HTML` 엘리먼트를 가리키게 됩니다. \n\n------\n<h2 id=\"callback_function\">콜백 함수는 함수다.</h2>\n\n콜백 함수로 객체의 메서드를 전달하더라도 그 메서드는 메서드가 아닌 함수로 호출됩니다.\n\n```js 메서드를 콜백 함수로 전달한 경우\n1. var obj = {\n  vals: [1, 2, 3],\n  logValues: function(v, i) {\n    console.log(this, v, i);\n  },\n};\n2. obj.logValues(1, 2); // { vals: [1, 2, 3], logValues: f } 1 2\n3. [4, 5, 6].forEach(obj.logValues); // Window { ... } 4 0\n// Window { ... } 5 1\n// Window { ... } 6 2\n```\n\n1. `obj` 객체의 `logValues`는 메서드로 정의됐습니다.\n\n\n2. 메서드의 이름 앞에 점(.)이 있으니 메서드로서 호출한 것 입니다. `this`는 `obj`를 가리키고 파라미터로 넘겨준 1, 2와 함께 출력됩니다.\n\n\n3. `obj.logValues`메서드를 `forEach` 함수의 콜백 함수로서 지정했습니다.\n`obj`를 `this`로 하는 메서드를 그대로 전달한 것이 아니라, `obj.logValues`가 가리키는 함수만 전달한 것입니다.\n이 함수는 메서드로서 호출할 때가 아닌 한 `obj`와의 직접적인 연관이 없어집니다.\n`forEach`에 의해 콜백이 함수로서 호출되고, 별도로 `this`를 지정하지 않았으므로 `this`는 전역객체를 참조합니다.\n\n**중요 포인트**\n\n어떤 함수의 인자(파라미터)에 객체의 메서드를 전달하더라도 메서드가 아닌 함수일 뿐입니다.\n이 차이를 정확히 이해하는 것이 중요합니다.\n\n------\n<h2 id=\"callback_this_binding\">콜백 함수 내부의 this에 다른 값 바인딩 하기</h2>\n\n콜백 함수에서 `this`를 지정하지 않으면 전역객체를 참조하게 되므로\n객체의 메서드를 콜백 함수로 전달하면 해당 객체를 `this`로 참조할 수 없게됩니다.\n\n별도의 인자(`thisArg`)로 `this`를 받는 함수의 경우에는 원하는 값을 넘겨주면 되지만 그렇지 않은 경우에는 `this`의 제어권도 넘겨주게 되므로 사용자가 임의로 값을 변경할 수 없습니다.\n\n그래서 <makr>전통적으로는 `this`를 다른 변수에 담아 콜백 함수로 활용할 함수에서는 `this`대신 그 변수를 사용하게 하고, 이를 클로저로 만드는 방식이 많이 쓰였습니다.</mark>\n\n```js 콜백 함수 내부의 this에 다른 값을 바인딩 - 전통적인 방법(변수 사용)\nvar obj1 = {\n  name: 'obj1',\n  func: function() {\n    var self = this;\n    return function() {\n      console.log(self.name);\n    };\n  },\n};\nvar callback = obj1.func();\nsetTimeout(callback, 1000);\n```\n\n1. `obj1.func` 메서드 내부에서 `self` 변수에 `this`를 담고, 익명 함수를 선언하고 반환했습니다.\n\n\n2. `obj1.func`를 호출하면 앞서 선언한 내부함수가 반환되어 `callback` 변수에 할당됩니다.\n\n\n3. 이 `callback`변수를 `setTimeout` 함수에 인자로 전달하면 1초(1000ms) 뒤 `callback`이 실행되면서 `\"obj1\"`을 반환할 것입니다.\n\n**중요 포인트**\n이 방식은 `this`를 다른 변수에 담아 함수내에서 `this` 대신 그 변수를 사용하게하여 실제로는 `this`를 사용하지 않을뿐더러 번거롭습니다.\n\n* ES5에 등장한 `bind`메서드를 사용하면 더욱 간편히 `this`를 바인딩할 수 있습니다.\n```js 콜백 함수 내부의 this에 다른 값 바인딩 - bind 메서드 사용\nvar obj1 = {\n  name: 'obj1',\n  func: function() {\n    console.log(this.name);\n  },\n};\nsetTimeout(obj1.func.bind(obj1), 1000);\n\nvar obj2 = { name: 'obj2' };\nsetTimeout(obj1.func.bind(obj2), 1500);\n```\n\n* `bind` 메서드의 첫 번째 인자(`thisArg`)로 `this`로 지정할 값을 전달합니다.\n함수가 실행될때 `this`는 `thisArg`로 전달받은 값을 참조하게 됩니다.\n\n------\n<h2 id=\"callback_hell\">콜백 지옥과 비동기 제어</h2>\n\n* 콜백 지옥(`callback hell`)이란?\n\n  콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상.\n  주로 이벤트 처리나 서버 통신과 같이 비동기적인 작업을 수행하기 위해 이런 형태가 자주 등장하곤 하는데, 가독성이 떨어질 뿐더러 코드를 수정하기도 힘들다.\n\n\n* 비동기(`asynchronous`)란?\n  \n  동기(`synchronous`)의 반대말로 <mark>동기적인 코드는 현재 실행 중인 코드가 완료된 후에야 다음 코드를 실행하는 방식</mark>\n  비동기적 코드는 <mark>현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어갑니다.</mark>\n  \n\n  1. 사용자의 요청에 의해 특정 시간이 경과되기 전까지 어떤 함수의 실행을 보류한다거나 -`setTimeout`\n\n  2. 사용자의 직접적인 개입이 있을 때 어떤 함수를 실행하도록 대기한다거나 -`addEventListener`\n\n  3. 웹브라우저 자체가 아닌 별도의 대상에 무언가를 요청하고 그에 대한 응답이 왔을 때 어떤 함수를 실행하도록 대기하는 등 -`XMLHttpRequest`\n\n  ~~CPU의 계산에 의해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드입니다.~~\n  <mark>별도의 요청, 실행 대기, 보류 등과 관련된 코드는 비동기적인 코드입니다.</mark>\n\n* 현대의 자바스크립트는 웹의 복잡도가 높아진 만큼 비동기적인 코드의 비중이 예전보다 훨씬 높아진 상황입니다. (콜백 지옥에 빠지기도 훨씬 쉬워졌습니다.)\n\n------\n**간단한 콜백 지옥 예시를 살펴봅시다.**\n\n```js callback-hell\nsetTimeout(function(name) {\n    var coffeeList = name;\n    console.log(coffeeList);\n\n    setTimeout(function(name) {\n        coffeeList += ', ' + name;\n        console.log(coffeeList);\n\n        setTimeout(function(name) {\n            coffeeList += ', ' + name;\n            console.log(coffeeList);\n\n            setTimeout(function(name) {\n                coffeeList += ', ' + name;\n                console.log(coffeeList);\n              }, 500, '카페라떼');\n          }, 500, '카페모카');\n      }, 500, '아메리카노');\n  }, 500, '에스프레소');\n```\n\n* 0.5 초마다 커피 목록을 수집하고 출력합니다. 각 콜백은 커피 이름을 전달하고 `coffeeList`에 추가합니다. \n\n* 실행에는 지장이 없는 코드입니다만, 들여쓰기 수준이 과도하게 깊어졌을 뿐더러 수정하기도 불편하고 값이 전달되는 순서가 아래에서 위로 향하고 있어 어색하게도 느껴집니다.\n\n가독성 문제와 어색함을 동시에 해결하는 방법은 익명 콜백함수를 모두 기명함수로 전환하는 방법이 있습니다...?!\n\n------\n```js 기명함수로 변환\nvar coffeeList = '';\n\nvar addEspresso = function(name) {\n  coffeeList = name;\n  console.log(coffeeList);\n  setTimeout(addAmericano, 500, '아메리카노');\n};\nvar addAmericano = function(name) {\n  coffeeList += ', ' + name;\n  console.log(coffeeList);\n  setTimeout(addMocha, 500, '카페모카');\n};\nvar addMocha = function(name) {\n  coffeeList += ', ' + name;\n  console.log(coffeeList);\n  setTimeout(addLatte, 500, '카페라떼');\n};\nvar addLatte = function(name) {\n  coffeeList += ', ' + name;\n  console.log(coffeeList);\n};\n\nsetTimeout(addEspresso, 500, '에스프레소');\n```\n\n* 익명함수를 기명함수로 변환하므로서 콜백 지옥을 해결한 예시입니다.\n\n함수 선언과 함수 호출을 구분한다면 코드의 가독성을 높여 코드를 위에서 아래로 읽어내려가는데 어려움이 없습니다. 변수가 전역으로 전개되긴 했지만 즉시 실행 함수 등으로 감싸면 해결할 수 있는 문제입니다.\n\n하지만 코드명을 일일이 따라다녀야 하므로 오히려 헷갈릴 여지도 있습니다.\n\n* 자바스크립트는 비동기적인 작업들을 동기적으로(혹은 동기적인 것처럼 보이도록) 처리해주는 방법을 고안했고, 그 결과 `ES6`에서 `Promise`, `Generator`등이 도입됐으며, `ES8(ES2017)`에서는 `async`, `wait`가 도입됐습니다.\n\n------\n**이들을 활용한 표현법도 알아봅시다.**\n\n```js 비동기 작업의 동기적 표현 -Promise\nnew Promise(function(resolve) {\n  setTimeout(function() {\n    var name = '에스프레소';\n    console.log(name);\n    resolve(name);\n  }, 500);\n})\n  .then(function(prevName) {\n    return new Promise(function(resolve) {\n      setTimeout(function() {\n        var name = prevName + ', 아메리카노';\n        console.log(name);\n        resolve(name);\n      }, 500);\n    });\n  })\n  .then(function(prevName) {\n    return new Promise(function(resolve) {\n      setTimeout(function() {\n        var name = prevName + ', 카페모카';\n        console.log(name);\n        resolve(name);\n      }, 500);\n    });\n  })\n  .then(function(prevName) {\n    return new Promise(function(resolve) {\n      setTimeout(function() {\n        var name = prevName + ', 카페라떼';\n        console.log(name);\n        resolve(name);\n      }, 500);\n    });\n  });\n```\n\n`ES6`의 `Promise`를 이용한 방법입니다. `new`연산자와 함께 호출한 `Promise`의 인자로 넘겨주는 콜백 함수는 호출할 때 바로 실행되지만 내부에 `resolve` 또는 `reject` 함수를 호출하는 구문이 있을 경우 둘 중하나가 충족되어 실행되기 전까지는 `.then` 또는 `.catch` 구문으로 넘어가지 않습니다.\n\n따라서 비동기 작업이 완료될 때 `resolve` 또는 `reject`를 호출하는 방법으로 비동기 작업의 동기적 표현이 가능합니다.\n\n------\n다음은 위에 코드의 반복적인 내용을 함수화 하여 더욱 짧게 표현한 것입니다.\n\n```js Promise 동기적표현 함수화\nvar addCoffee = function(name) {\n  return function(prevName) {\n    return new Promise(function(resolve) {\n      setTimeout(function() {\n        var newName = prevName ? prevName + ', ' + name : name;\n        console.log(newName);\n        resolve(newName);\n      }, 500);\n    });\n  };\n};\naddCoffee('에스프레소')()\n  .then(addCoffee('아메리카노'))\n  .then(addCoffee('카페모카'))\n  .then(addCoffee('카페라떼'));\n```\n\n------\n* Generator 활용\n\n```js 비동기 작업의 동기적 표현 -Generator\nvar addCoffee = function(prevName, name) {\n  setTimeout(function() {\n    coffeeMaker.next(prevName ? prevName + ', ' + name : name);\n  }, 500);\n};\nvar coffeeGenerator = function*() {\n  var espresso = yield addCoffee('', '에스프레소');\n  console.log(espresso);\n  var americano = yield addCoffee(espresso, '아메리카노');\n  console.log(americano);\n  var mocha = yield addCoffee(americano, '카페모카');\n  console.log(mocha);\n  var latte = yield addCoffee(mocha, '카페라떼');\n  console.log(latte);\n};\nvar coffeeMaker = coffeeGenerator();\ncoffeeMaker.next();\n```\n\n`ES6`의 `Generator`를 이용한 방법입니다.\n`Generator` 함수를 실행하여 `Iterator`을 반환받고 `Iterator`의 메서드 `next`를 사용할 수 있습니다\n\n`next` 메서드를 호출하면 `Generator` 함수 내부에서 첫 번째 `yield`를 만나면 함수 실행을 멈추게 되고 다시 `next`를 호출하면 멈춘 부분부터 그 다음에 등장하는 `yield`에서 함수 실행을 멈추게 됩니다.\n\n즉, 비동기 작업이 완료되는 시점마다 `next` 메서드를 호출해준다면 `Generator` 함수 내부의 소스가 순차적으로 진행되게 합니다.\n\n------\n* Promise + async/await\n\n```js\nvar addCoffee = function(name) {\n  return new Promise(function(resolve) {\n    setTimeout(function() {\n      resolve(name);\n    }, 500);\n  });\n};\nvar coffeeMaker = async function() {\n  var coffeeList = '';\n  var _addCoffee = async function(name) {\n    coffeeList += (coffeeList ? ',' : '') + (await addCoffee(name));\n  };\n  await _addCoffee('에스프레소');\n  console.log(coffeeList);\n  await _addCoffee('아메리카노');\n  console.log(coffeeList);\n  await _addCoffee('카페모카');\n  console.log(coffeeList);\n  await _addCoffee('카페라떼');\n  console.log(coffeeList);\n};\ncoffeeMaker();\n```\n\n`ES8(ES2017)`에서 추가된 `async/await`는 비동기 작업을 수행하고자 하는 함수 앞에 `async`를 표기하고, 함수 내부에서 비동기 작업이 필요한 위치마다 `await`를 표기하는 것만으로 뒤의 내용을 `Promise`로 자동 전환하고, 해당 내용이 `resolve`된 이후에야 다음으로 진행합니다.\n\n`Promise`의 `then`과 비슷한 효과를 얻을 수 있습니다.\n\n------\n<h2 id=\"callback\">정리</h2>\n\n* 콜백 함수는 다른 코드에 인자를 넘겨줌으로써 <mark>제어권도 함께 위임</mark>.\n\n\n* 제어권을 넘겨받은 코드는 \n  1. 콜백 함수를 호출하는 시점을 지정.\n\n  2. 콜백 함수를 호출할 때 <mark>인자로 넘겨줄 값의 순서를 변경하지 말 것.</mark>\n\n  3. 콜백 함수는 `this`를 지정하여 사용할 수 있는 함수가 존재, 지정하지 않을 경우 전역객체를 참조\n  사용자 임의로 `this`를 변경하고 싶은 경우 `bind` 메서드 활용\n\n\n* 함수에 인자로 메서드를 전달하더라도 이는 <mark>함수로서 실행됨</mark>.\n\n\n* 비동기 제어를 위해 콜백 함수를 사용하다 보면 콜백 지옥에 빠지기 쉬움.\n최근의 자바스크립트에서는 <mark>Promise, Generator, async/await</mark> 등 콜백 지옥을 벗어날 수 있는 방법들이 등장함.","slug":"콜백-함수-Core-JavaScript","published":1,"updated":"2020-05-01T12:50:34.807Z","_id":"ck9mnug4x0006hkvq9p47ftcc","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>콜백 함수<ul>\n<li><a href=\"/2020/04/30/콜백-함수-Core-JavaScript/#callback\">콜백 함수란?</a></li>\n<li><a href=\"/2020/04/30/콜백-함수-Core-JavaScript/#callback_제어권\">제어권</a><ul>\n<li>인자</li>\n<li>this</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/30/콜백-함수-Core-JavaScript/#callback_function\">콜백 함수는 함수다.</a></li>\n<li><a href=\"/2020/04/30/콜백-함수-Core-JavaScript/#callback_this_binding\">콜백 함수 내부의 this에 다른 값 바인딩하기</a></li>\n<li><a href=\"/2020/04/30/콜백-함수-Core-JavaScript/#callback_hell\">콜백 지옥과 비동기 제어</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"callback\">콜백 함수란?</h2>\n\n<p>콜백 함수(<code>callback function</code>)는 다른 코드의 인자로 넘겨주는 함수 입니다.</p>\n<p><code>callback</code>은 부르다, 호출하다, 실행하다의 의미인 call 과 되돌아오다 back의 합성어로,<br>되돌아 호출하다라는 의미로 이해할 수 있습니다.</p>\n<p>특정 <code>함수a</code>를 호출하면서 ‘특정 조건일때 <code>함수b</code>를 실행해서 알려달라는’요청을 보내는 것입니다.<br><code>함수a</code>의 입장에서는 해당 조건이 갖춰졌는지 여부를 스스로 판단하고 <code>함수b</code>를 직접 호출합니다.</p>\n<p>이처럼 콜백 함수는 다른 코드(함수 또는 메서드)에게 인자를 넘겨줌으로써 그 <mark>제어권도 함께 위임한 함수</mark>입니다. (콜백 함수를 위임받은 코드는 자체적인 내부 로직에 의해 이 콜백 함수를 적절한 시점에 실행합니다.)</p>\n<hr>\n<h2 id=\"callback_제어권\">제어권</h2>\n\n<p>몇 가지 예제</p>\n<hr>\n<h3 id=\"호출-시점\"><a href=\"#호출-시점\" class=\"headerlink\" title=\"호출 시점\"></a>호출 시점</h3><figure class=\"highlight js\"><figcaption><span>setInterval</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">var</span> timer = setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(count);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (++count &gt; <span class=\"number\">4</span>) clearInterval(timer);</span><br><span class=\"line\">&#125;, <span class=\"number\">300</span>);</span><br></pre></td></tr></table></figure>\n\n<p>우선 <code>setInterval</code> 메서드의 형태를 살펴보면 다음과 같습니다.</p>\n<blockquote>\n<p>var 참조변수(interval ID) = scope.setInterval(func, delay[, param1, param2, …]);</p>\n</blockquote>\n<ul>\n<li>socpe :<br><code>Window</code> 객체 또는 <code>Worker</code>의 인스턴스가 들어올 수 있습니다. 두 객체 모두 <code>setInterval</code> 메서드를 제공하기 때문입니다. 일반적인 브라우저 환경에서는 <code>window</code>를 생략하고 함수처럼 사용할 수 있습니다.</li>\n</ul>\n<ul>\n<li>매개변수<br><code>func</code>, <code>delay</code> 값을 반드시 전달해야 합니다.<br>세 번째 매개변수 부터는 선택적 파라미터로 <code>func</code> 함수를 실행할때 전달할 파라미터입니다.<br><code>func</code>에 넘겨준 함수는 매 <code>delay(ms)</code>마다 실행되며, 그 결과로 어떤 값도 반환하지 않습니다.</li>\n</ul>\n<ul>\n<li><code>setInterval</code>을 실행하면 반복적으로 실행되는 내용 자체를 특정할 수 있는 고유 ID 값이 반환됩니다.<br>이를 변수에 담는 이유는 반복 실행되는 중간에 종료(<code>clearInterval</code>)할 수 있게 하기 위해서 입니다.</li>\n</ul>\n<ol>\n<li><p><code>count</code> 변수를 선언하고 0을 할당합니다.</p>\n</li>\n<li><p><code>timer</code> 변수를 선언하고 setInterval 결과를 할당했습니다.</p>\n</li>\n</ol>\n<p><strong>위에 코드를 콜백 함수를 확인하기 쉽게 수정했습니다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>callback - setInterval</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cbFunc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(count);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (++count &gt; <span class=\"number\">4</span>) clearInterval(timer);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> timer = setInterval(cbFunc, <span class=\"number\">300</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- 실행 결과 --</span></span><br><span class=\"line\"><span class=\"comment\">// 0  (0.3초)</span></span><br><span class=\"line\"><span class=\"comment\">// 1  (0.6초)</span></span><br><span class=\"line\"><span class=\"comment\">// 2  (0.9초)</span></span><br><span class=\"line\"><span class=\"comment\">// 3  (1.2초)</span></span><br><span class=\"line\"><span class=\"comment\">// 4  (1.5초)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>timer</code>변수에는 <code>setInterval</code>의 ID 값이 담기게 됩니다.</li>\n</ul>\n<ul>\n<li><code>setInterval</code>에 전달한 첫 번째 인자인 <code>cbFunc</code>함수(이 함수가 곧 콜백함수입니다.)는 0.3초마다 자동으로 실행될 것입니다. </li>\n</ul>\n<ul>\n<li>콜백 함수 내부에서는 <code>count</code> 값을 출력하고 1씩 증가시키며, <code>count</code>값이 4보다 크면 반복 실행이 종료됩니다.</li>\n</ul>\n<ul>\n<li>제어권<br><code>setInterval</code> 메서드에 첫 번째 인자로 <code>cbFunc</code> 함수를 넘겨주자 제어권을 넘겨받은 <code>setInterval</code> 메서드는 0.3초마다 (지정된 시점) 이 익명 함수를 실행했습니다. 이처럼 <u>콜백 함수의 제어권을 넘겨받은 코드</u>는 <mark>콜백 함수 호출 시점에 대한 제어권</mark>을 가집니다.</li>\n</ul>\n<h3 id=\"인자-파라미터\"><a href=\"#인자-파라미터\" class=\"headerlink\" title=\"인자 (파라미터)\"></a>인자 (파라미터)</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> newArr = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>].map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentValue, index</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(currentValue, index);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> currentValue + <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- 실행 결과 --</span></span><br><span class=\"line\"><span class=\"comment\">// 10 0</span></span><br><span class=\"line\"><span class=\"comment\">// 20 1</span></span><br><span class=\"line\"><span class=\"comment\">// 30 2</span></span><br><span class=\"line\"><span class=\"comment\">// [15, 25, 35]</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li><p><code>newArr</code> 변수를 선언하고 오른쪽에 배열 <code>[10, 20, 30]</code>에 <code>map</code> 메서드를 호출하고 그 결과를 할당합니다.</p>\n<p><code>map</code>메서드의 동작 방식부터 살펴보도록 하겠습니다.</p>\n<blockquote>\n<p>Array.prototype.map(callback[, thisArg])<br>callback : function(currentValue, index, array)</p>\n</blockquote>\n<p><code>map</code> 메서드는 Array.prototype에 담긴 메서드입니다.</p>\n<ul>\n<li><p>파라미터</p>\n<ul>\n<li>첫 번째 인자: <code>callback</code> 함수를 받습니다</li>\n<li>두 번째 인자: 생략가능한 파라미터이며, 콜백 함수 내부에서 <code>this</code>로 인식할 대상을 지정합니다. 생략시 일반적인 함수와 마찬가지로 전역객체를 참조하게 됩니다.</li>\n</ul>\n</li>\n<li><p>반환 값</p>\n<ul>\n<li><code>map</code>메서드는 메서드의 대상이 되는 배열의 모든 요소들을 차례대로 불러와 콜백 함수를 반복 호출하고, <u>콜백 함수의 실행 결과를 모아 새로운 배열</u>을 반환합니다.</li>\n</ul>\n</li>\n<li><p><code>callback</code>함수<br>콜백 함수의 첫 번째 인자에는 배열의 요소중 <code>현재값</code>, 두 번째 인자에는 <code>현재값의 index</code>, 세 번째 인자에는 <code>map</code>메서드의 <code>대상이 되는 배열</code>이 담깁니다.</p>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li><code>map</code> 메서드는 배열<code>[10, 20, 30]</code>의 각 요소를 차례대로 꺼내어 콜백 함수를 실행합니다.</li>\n</ol>\n<ol start=\"3\">\n<li>첫 번째 요소에 대한 콜백 함수는 <code>currentValue</code>에 10이, <code>index</code>에는 index 0이 담긴 채 실행됩니다 <code>return currentValue + 5;</code> 코드를 실행하여 <code>(10 + 5)</code> 값인 <code>15</code>가 반환됩니다.</li>\n</ol>\n<ol start=\"4\">\n<li>두 번째 요소에 대한 콜백 함수는 <code>currentValue</code>에 20이, <code>index</code>에는 index 1이 담긴 채 실행됩니다 <code>return currentValue + 5;</code> 코드를 실행하여 <code>(20 + 5)</code> 값인 <code>25</code>가 반환됩니다.</li>\n</ol>\n<ol start=\"5\">\n<li>세 번째 요소에 대한 콜백 함수는 <code>currentValue</code>에 30이, <code>index</code>에는 index 2이 담긴 채 실행됩니다 <code>return currentValue + 5;</code> 코드를 실행하여 <code>(30 + 5)</code> 값인 <code>35</code>가 반환됩니다.</li>\n</ol>\n<ol start=\"6\">\n<li>모든 요소에 대한 콜백 함수를 마치고 나면 <code>[15, 25, 35]</code>라는 새로운 배열이 만들어져 <code>newArr</code>변수에 할당됩니다.</li>\n</ol>\n<ol start=\"7\">\n<li><code>console.log(newArr)</code> 코드에서 <code>newArr</code>변수에 할당된 새로운 배열이 출력됩니다.</li>\n</ol>\n<p><strong>중요 포인트</strong></p>\n<p><code>콜백 함수</code>의 파라미터 순서를 바꾸면 안됩니다. <code>currentValue</code>, <code>index</code>순 이어야하며<br>바뀐다면 전혀 다른 값을 반환할 것입니다.</p>\n<p><del>엔진은 파라미터로 받은 값의 단어(name)를 인식하는 것이 아니라 순서(첫 번째, 두 번째)에 의해서만 각각을 구분하고 인식합니다.</del> </p>\n<hr>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h3><p>콜백 함수 내부에서의 this</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">300</span>); <span class=\"comment\">// (1) Window &#123; ... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// (2) Window &#123; ... &#125;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.innerHTML += <span class=\"string\">'&lt;button id=\"a\"&gt;클릭&lt;/button&gt;'</span>;</span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">document</span>.body.querySelector(<span class=\"string\">'#a'</span>).addEventListener(</span><br><span class=\"line\">  <span class=\"string\">'click'</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, e); <span class=\"comment\">// (3) &lt;button id=\"a\"&gt;클릭&lt;/button&gt;</span></span><br><span class=\"line\">  &#125; <span class=\"comment\">// MouseEvent &#123; isTrusted: true, ... &#125;</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>setTimeout</code>은 내부에서 콜백 함수를 호출할 때 <code>call</code>메서드의 첫 번째 인자로 전역객체를 넘기게 됩니다. 콜백 함수 내부에서 <code>this</code>가 전역객체를 가리키게됩니다. </li>\n</ol>\n<ol start=\"2\">\n<li><code>forEach</code>는 ‘별도의 인자로 this를 받는 경우’에 해당하지만 별도로 <code>this</code>를 지정해주지 않았기 때문에 전역객체를 가리키게됩니다.</li>\n</ol>\n<ol start=\"3\">\n<li><code>addEventListener</code>는 내부에서 콜백 함수를 호출할 때 <code>call</code>메서드의 첫 번째 인자에 <code>addEventListener</code>메서드의 <code>this</code>를 넘기도록 정의되어 있습니다. 때문에 콜백 함수 내부에서의 <code>this</code>는 <code>addEventListener</code>를 호출한 주체 <code>HTML</code> 엘리먼트를 가리키게 됩니다. </li>\n</ol>\n<hr>\n<h2 id=\"callback_function\">콜백 함수는 함수다.</h2>\n\n<p>콜백 함수로 객체의 메서드를 전달하더라도 그 메서드는 메서드가 아닌 함수로 호출됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>메서드를 콜백 함수로 전달한 경우</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  vals: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  logValues: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v, i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, v, i);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"number\">2.</span> obj.logValues(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// &#123; vals: [1, 2, 3], logValues: f &#125; 1 2</span></span><br><span class=\"line\"><span class=\"number\">3.</span> [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>].forEach(obj.logValues); <span class=\"comment\">// Window &#123; ... &#125; 4 0</span></span><br><span class=\"line\"><span class=\"comment\">// Window &#123; ... &#125; 5 1</span></span><br><span class=\"line\"><span class=\"comment\">// Window &#123; ... &#125; 6 2</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>obj</code> 객체의 <code>logValues</code>는 메서드로 정의됐습니다.</li>\n</ol>\n<ol start=\"2\">\n<li>메서드의 이름 앞에 점(.)이 있으니 메서드로서 호출한 것 입니다. <code>this</code>는 <code>obj</code>를 가리키고 파라미터로 넘겨준 1, 2와 함께 출력됩니다.</li>\n</ol>\n<ol start=\"3\">\n<li><code>obj.logValues</code>메서드를 <code>forEach</code> 함수의 콜백 함수로서 지정했습니다.<br><code>obj</code>를 <code>this</code>로 하는 메서드를 그대로 전달한 것이 아니라, <code>obj.logValues</code>가 가리키는 함수만 전달한 것입니다.<br>이 함수는 메서드로서 호출할 때가 아닌 한 <code>obj</code>와의 직접적인 연관이 없어집니다.<br><code>forEach</code>에 의해 콜백이 함수로서 호출되고, 별도로 <code>this</code>를 지정하지 않았으므로 <code>this</code>는 전역객체를 참조합니다.</li>\n</ol>\n<p><strong>중요 포인트</strong></p>\n<p>어떤 함수의 인자(파라미터)에 객체의 메서드를 전달하더라도 메서드가 아닌 함수일 뿐입니다.<br>이 차이를 정확히 이해하는 것이 중요합니다.</p>\n<hr>\n<h2 id=\"callback_this_binding\">콜백 함수 내부의 this에 다른 값 바인딩 하기</h2>\n\n<p>콜백 함수에서 <code>this</code>를 지정하지 않으면 전역객체를 참조하게 되므로<br>객체의 메서드를 콜백 함수로 전달하면 해당 객체를 <code>this</code>로 참조할 수 없게됩니다.</p>\n<p>별도의 인자(<code>thisArg</code>)로 <code>this</code>를 받는 함수의 경우에는 원하는 값을 넘겨주면 되지만 그렇지 않은 경우에는 <code>this</code>의 제어권도 넘겨주게 되므로 사용자가 임의로 값을 변경할 수 없습니다.</p>\n<p>그래서 <makr>전통적으로는 <code>this</code>를 다른 변수에 담아 콜백 함수로 활용할 함수에서는 <code>this</code>대신 그 변수를 사용하게 하고, 이를 클로저로 만드는 방식이 많이 쓰였습니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>콜백 함수 내부의 this에 다른 값을 바인딩 - 전통적인 방법(변수 사용)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj1'</span>,</span><br><span class=\"line\">  func: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(self.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> callback = obj1.func();</span><br><span class=\"line\">setTimeout(callback, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>obj1.func</code> 메서드 내부에서 <code>self</code> 변수에 <code>this</code>를 담고, 익명 함수를 선언하고 반환했습니다.</li>\n</ol>\n<ol start=\"2\">\n<li><code>obj1.func</code>를 호출하면 앞서 선언한 내부함수가 반환되어 <code>callback</code> 변수에 할당됩니다.</li>\n</ol>\n<ol start=\"3\">\n<li>이 <code>callback</code>변수를 <code>setTimeout</code> 함수에 인자로 전달하면 1초(1000ms) 뒤 <code>callback</code>이 실행되면서 <code>&quot;obj1&quot;</code>을 반환할 것입니다.</li>\n</ol>\n<p><strong>중요 포인트</strong><br>이 방식은 <code>this</code>를 다른 변수에 담아 함수내에서 <code>this</code> 대신 그 변수를 사용하게하여 실제로는 <code>this</code>를 사용하지 않을뿐더러 번거롭습니다.</p>\n<ul>\n<li><p>ES5에 등장한 <code>bind</code>메서드를 사용하면 더욱 간편히 <code>this</code>를 바인딩할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>콜백 함수 내부의 this에 다른 값 바인딩 - bind 메서드 사용</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj1'</span>,</span><br><span class=\"line\">  func: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">setTimeout(obj1.func.bind(obj1), <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'obj2'</span> &#125;;</span><br><span class=\"line\">setTimeout(obj1.func.bind(obj2), <span class=\"number\">1500</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>bind</code> 메서드의 첫 번째 인자(<code>thisArg</code>)로 <code>this</code>로 지정할 값을 전달합니다.<br>함수가 실행될때 <code>this</code>는 <code>thisArg</code>로 전달받은 값을 참조하게 됩니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"callback_hell\">콜백 지옥과 비동기 제어</h2>\n\n<ul>\n<li><p>콜백 지옥(<code>callback hell</code>)이란?</p>\n<p>콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상.<br>주로 이벤트 처리나 서버 통신과 같이 비동기적인 작업을 수행하기 위해 이런 형태가 자주 등장하곤 하는데, 가독성이 떨어질 뿐더러 코드를 수정하기도 힘들다.</p>\n</li>\n</ul>\n<ul>\n<li><p>비동기(<code>asynchronous</code>)란?</p>\n<p>동기(<code>synchronous</code>)의 반대말로 <mark>동기적인 코드는 현재 실행 중인 코드가 완료된 후에야 다음 코드를 실행하는 방식</mark><br>비동기적 코드는 <mark>현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어갑니다.</mark></p>\n</li>\n</ul>\n<ol>\n<li><p>사용자의 요청에 의해 특정 시간이 경과되기 전까지 어떤 함수의 실행을 보류한다거나 -<code>setTimeout</code></p>\n</li>\n<li><p>사용자의 직접적인 개입이 있을 때 어떤 함수를 실행하도록 대기한다거나 -<code>addEventListener</code></p>\n</li>\n<li><p>웹브라우저 자체가 아닌 별도의 대상에 무언가를 요청하고 그에 대한 응답이 왔을 때 어떤 함수를 실행하도록 대기하는 등 -<code>XMLHttpRequest</code></p>\n<p><del>CPU의 계산에 의해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드입니다.</del><br><mark>별도의 요청, 실행 대기, 보류 등과 관련된 코드는 비동기적인 코드입니다.</mark></p>\n</li>\n</ol>\n<ul>\n<li>현대의 자바스크립트는 웹의 복잡도가 높아진 만큼 비동기적인 코드의 비중이 예전보다 훨씬 높아진 상황입니다. (콜백 지옥에 빠지기도 훨씬 쉬워졌습니다.)</li>\n</ul>\n<hr>\n<p><strong>간단한 콜백 지옥 예시를 살펴봅시다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>callback-hell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> coffeeList = name;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">        coffeeList += <span class=\"string\">', '</span> + name;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\"></span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">            coffeeList += <span class=\"string\">', '</span> + name;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\"></span><br><span class=\"line\">            setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">                coffeeList += <span class=\"string\">', '</span> + name;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">              &#125;, <span class=\"number\">500</span>, <span class=\"string\">'카페라떼'</span>);</span><br><span class=\"line\">          &#125;, <span class=\"number\">500</span>, <span class=\"string\">'카페모카'</span>);</span><br><span class=\"line\">      &#125;, <span class=\"number\">500</span>, <span class=\"string\">'아메리카노'</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">500</span>, <span class=\"string\">'에스프레소'</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>0.5 초마다 커피 목록을 수집하고 출력합니다. 각 콜백은 커피 이름을 전달하고 <code>coffeeList</code>에 추가합니다. </p>\n</li>\n<li><p>실행에는 지장이 없는 코드입니다만, 들여쓰기 수준이 과도하게 깊어졌을 뿐더러 수정하기도 불편하고 값이 전달되는 순서가 아래에서 위로 향하고 있어 어색하게도 느껴집니다.</p>\n</li>\n</ul>\n<p>가독성 문제와 어색함을 동시에 해결하는 방법은 익명 콜백함수를 모두 기명함수로 전환하는 방법이 있습니다…?!</p>\n<hr>\n<figure class=\"highlight js\"><figcaption><span>기명함수로 변환</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> coffeeList = <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> addEspresso = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  coffeeList = name;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">  setTimeout(addAmericano, <span class=\"number\">500</span>, <span class=\"string\">'아메리카노'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> addAmericano = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  coffeeList += <span class=\"string\">', '</span> + name;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">  setTimeout(addMocha, <span class=\"number\">500</span>, <span class=\"string\">'카페모카'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> addMocha = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  coffeeList += <span class=\"string\">', '</span> + name;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">  setTimeout(addLatte, <span class=\"number\">500</span>, <span class=\"string\">'카페라떼'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> addLatte = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  coffeeList += <span class=\"string\">', '</span> + name;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(addEspresso, <span class=\"number\">500</span>, <span class=\"string\">'에스프레소'</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>익명함수를 기명함수로 변환하므로서 콜백 지옥을 해결한 예시입니다.</li>\n</ul>\n<p>함수 선언과 함수 호출을 구분한다면 코드의 가독성을 높여 코드를 위에서 아래로 읽어내려가는데 어려움이 없습니다. 변수가 전역으로 전개되긴 했지만 즉시 실행 함수 등으로 감싸면 해결할 수 있는 문제입니다.</p>\n<p>하지만 코드명을 일일이 따라다녀야 하므로 오히려 헷갈릴 여지도 있습니다.</p>\n<ul>\n<li>자바스크립트는 비동기적인 작업들을 동기적으로(혹은 동기적인 것처럼 보이도록) 처리해주는 방법을 고안했고, 그 결과 <code>ES6</code>에서 <code>Promise</code>, <code>Generator</code>등이 도입됐으며, <code>ES8(ES2017)</code>에서는 <code>async</code>, <code>wait</code>가 도입됐습니다.</li>\n</ul>\n<hr>\n<p><strong>이들을 활용한 표현법도 알아봅시다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>비동기 작업의 동기적 표현 -Promise</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'에스프레소'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    resolve(name);</span><br><span class=\"line\">  &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> name = prevName + <span class=\"string\">', 아메리카노'</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">        resolve(name);</span><br><span class=\"line\">      &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> name = prevName + <span class=\"string\">', 카페모카'</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">        resolve(name);</span><br><span class=\"line\">      &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> name = prevName + <span class=\"string\">', 카페라떼'</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">        resolve(name);</span><br><span class=\"line\">      &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>ES6</code>의 <code>Promise</code>를 이용한 방법입니다. <code>new</code>연산자와 함께 호출한 <code>Promise</code>의 인자로 넘겨주는 콜백 함수는 호출할 때 바로 실행되지만 내부에 <code>resolve</code> 또는 <code>reject</code> 함수를 호출하는 구문이 있을 경우 둘 중하나가 충족되어 실행되기 전까지는 <code>.then</code> 또는 <code>.catch</code> 구문으로 넘어가지 않습니다.</p>\n<p>따라서 비동기 작업이 완료될 때 <code>resolve</code> 또는 <code>reject</code>를 호출하는 방법으로 비동기 작업의 동기적 표현이 가능합니다.</p>\n<hr>\n<p>다음은 위에 코드의 반복적인 내용을 함수화 하여 더욱 짧게 표현한 것입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>Promise 동기적표현 함수화</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addCoffee = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> newName = prevName ? prevName + <span class=\"string\">', '</span> + name : name;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(newName);</span><br><span class=\"line\">        resolve(newName);</span><br><span class=\"line\">      &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">addCoffee(<span class=\"string\">'에스프레소'</span>)()</span><br><span class=\"line\">  .then(addCoffee(<span class=\"string\">'아메리카노'</span>))</span><br><span class=\"line\">  .then(addCoffee(<span class=\"string\">'카페모카'</span>))</span><br><span class=\"line\">  .then(addCoffee(<span class=\"string\">'카페라떼'</span>));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<ul>\n<li>Generator 활용</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>비동기 작업의 동기적 표현 -Generator</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addCoffee = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevName, name</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    coffeeMaker.next(prevName ? prevName + <span class=\"string\">', '</span> + name : name);</span><br><span class=\"line\">  &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> coffeeGenerator = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> espresso = <span class=\"keyword\">yield</span> addCoffee(<span class=\"string\">''</span>, <span class=\"string\">'에스프레소'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(espresso);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> americano = <span class=\"keyword\">yield</span> addCoffee(espresso, <span class=\"string\">'아메리카노'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(americano);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> mocha = <span class=\"keyword\">yield</span> addCoffee(americano, <span class=\"string\">'카페모카'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mocha);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> latte = <span class=\"keyword\">yield</span> addCoffee(mocha, <span class=\"string\">'카페라떼'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(latte);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> coffeeMaker = coffeeGenerator();</span><br><span class=\"line\">coffeeMaker.next();</span><br></pre></td></tr></table></figure>\n\n<p><code>ES6</code>의 <code>Generator</code>를 이용한 방법입니다.<br><code>Generator</code> 함수를 실행하여 <code>Iterator</code>을 반환받고 <code>Iterator</code>의 메서드 <code>next</code>를 사용할 수 있습니다</p>\n<p><code>next</code> 메서드를 호출하면 <code>Generator</code> 함수 내부에서 첫 번째 <code>yield</code>를 만나면 함수 실행을 멈추게 되고 다시 <code>next</code>를 호출하면 멈춘 부분부터 그 다음에 등장하는 <code>yield</code>에서 함수 실행을 멈추게 됩니다.</p>\n<p>즉, 비동기 작업이 완료되는 시점마다 <code>next</code> 메서드를 호출해준다면 <code>Generator</code> 함수 내부의 소스가 순차적으로 진행되게 합니다.</p>\n<hr>\n<ul>\n<li>Promise + async/await</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addCoffee = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      resolve(name);</span><br><span class=\"line\">    &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> coffeeMaker = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> coffeeList = <span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _addCoffee = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    coffeeList += (coffeeList ? <span class=\"string\">','</span> : <span class=\"string\">''</span>) + (<span class=\"keyword\">await</span> addCoffee(name));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> _addCoffee(<span class=\"string\">'에스프레소'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> _addCoffee(<span class=\"string\">'아메리카노'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> _addCoffee(<span class=\"string\">'카페모카'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> _addCoffee(<span class=\"string\">'카페라떼'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">coffeeMaker();</span><br></pre></td></tr></table></figure>\n\n<p><code>ES8(ES2017)</code>에서 추가된 <code>async/await</code>는 비동기 작업을 수행하고자 하는 함수 앞에 <code>async</code>를 표기하고, 함수 내부에서 비동기 작업이 필요한 위치마다 <code>await</code>를 표기하는 것만으로 뒤의 내용을 <code>Promise</code>로 자동 전환하고, 해당 내용이 <code>resolve</code>된 이후에야 다음으로 진행합니다.</p>\n<p><code>Promise</code>의 <code>then</code>과 비슷한 효과를 얻을 수 있습니다.</p>\n<hr>\n<h2 id=\"callback\">정리</h2>\n\n<ul>\n<li>콜백 함수는 다른 코드에 인자를 넘겨줌으로써 <mark>제어권도 함께 위임</mark>.</li>\n</ul>\n<ul>\n<li><p>제어권을 넘겨받은 코드는 </p>\n<ol>\n<li><p>콜백 함수를 호출하는 시점을 지정.</p>\n</li>\n<li><p>콜백 함수를 호출할 때 <mark>인자로 넘겨줄 값의 순서를 변경하지 말 것.</mark></p>\n</li>\n<li><p>콜백 함수는 <code>this</code>를 지정하여 사용할 수 있는 함수가 존재, 지정하지 않을 경우 전역객체를 참조<br>사용자 임의로 <code>this</code>를 변경하고 싶은 경우 <code>bind</code> 메서드 활용</p>\n</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>함수에 인자로 메서드를 전달하더라도 이는 <mark>함수로서 실행됨</mark>.</li>\n</ul>\n<ul>\n<li>비동기 제어를 위해 콜백 함수를 사용하다 보면 콜백 지옥에 빠지기 쉬움.<br>최근의 자바스크립트에서는 <mark>Promise, Generator, async/await</mark> 등 콜백 지옥을 벗어날 수 있는 방법들이 등장함.</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li>콜백 함수<ul>\n<li><a href=\"/2020/04/30/콜백-함수-Core-JavaScript/#callback\">콜백 함수란?</a></li>\n<li><a href=\"/2020/04/30/콜백-함수-Core-JavaScript/#callback_제어권\">제어권</a><ul>\n<li>인자</li>\n<li>this</li>\n</ul>\n</li>\n<li><a href=\"/2020/04/30/콜백-함수-Core-JavaScript/#callback_function\">콜백 함수는 함수다.</a></li>\n<li><a href=\"/2020/04/30/콜백-함수-Core-JavaScript/#callback_this_binding\">콜백 함수 내부의 this에 다른 값 바인딩하기</a></li>\n<li><a href=\"/2020/04/30/콜백-함수-Core-JavaScript/#callback_hell\">콜백 지옥과 비동기 제어</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"callback\">콜백 함수란?</h2>\n\n<p>콜백 함수(<code>callback function</code>)는 다른 코드의 인자로 넘겨주는 함수 입니다.</p>\n<p><code>callback</code>은 부르다, 호출하다, 실행하다의 의미인 call 과 되돌아오다 back의 합성어로,<br>되돌아 호출하다라는 의미로 이해할 수 있습니다.</p>\n<p>특정 <code>함수a</code>를 호출하면서 ‘특정 조건일때 <code>함수b</code>를 실행해서 알려달라는’요청을 보내는 것입니다.<br><code>함수a</code>의 입장에서는 해당 조건이 갖춰졌는지 여부를 스스로 판단하고 <code>함수b</code>를 직접 호출합니다.</p>\n<p>이처럼 콜백 함수는 다른 코드(함수 또는 메서드)에게 인자를 넘겨줌으로써 그 <mark>제어권도 함께 위임한 함수</mark>입니다. (콜백 함수를 위임받은 코드는 자체적인 내부 로직에 의해 이 콜백 함수를 적절한 시점에 실행합니다.)</p>\n<hr>\n<h2 id=\"callback_제어권\">제어권</h2>\n\n<p>몇 가지 예제</p>\n<hr>\n<h3 id=\"호출-시점\"><a href=\"#호출-시점\" class=\"headerlink\" title=\"호출 시점\"></a>호출 시점</h3><figure class=\"highlight js\"><figcaption><span>setInterval</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">var</span> timer = setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(count);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (++count &gt; <span class=\"number\">4</span>) clearInterval(timer);</span><br><span class=\"line\">&#125;, <span class=\"number\">300</span>);</span><br></pre></td></tr></table></figure>\n\n<p>우선 <code>setInterval</code> 메서드의 형태를 살펴보면 다음과 같습니다.</p>\n<blockquote>\n<p>var 참조변수(interval ID) = scope.setInterval(func, delay[, param1, param2, …]);</p>\n</blockquote>\n<ul>\n<li>socpe :<br><code>Window</code> 객체 또는 <code>Worker</code>의 인스턴스가 들어올 수 있습니다. 두 객체 모두 <code>setInterval</code> 메서드를 제공하기 때문입니다. 일반적인 브라우저 환경에서는 <code>window</code>를 생략하고 함수처럼 사용할 수 있습니다.</li>\n</ul>\n<ul>\n<li>매개변수<br><code>func</code>, <code>delay</code> 값을 반드시 전달해야 합니다.<br>세 번째 매개변수 부터는 선택적 파라미터로 <code>func</code> 함수를 실행할때 전달할 파라미터입니다.<br><code>func</code>에 넘겨준 함수는 매 <code>delay(ms)</code>마다 실행되며, 그 결과로 어떤 값도 반환하지 않습니다.</li>\n</ul>\n<ul>\n<li><code>setInterval</code>을 실행하면 반복적으로 실행되는 내용 자체를 특정할 수 있는 고유 ID 값이 반환됩니다.<br>이를 변수에 담는 이유는 반복 실행되는 중간에 종료(<code>clearInterval</code>)할 수 있게 하기 위해서 입니다.</li>\n</ul>\n<ol>\n<li><p><code>count</code> 변수를 선언하고 0을 할당합니다.</p>\n</li>\n<li><p><code>timer</code> 변수를 선언하고 setInterval 결과를 할당했습니다.</p>\n</li>\n</ol>\n<p><strong>위에 코드를 콜백 함수를 확인하기 쉽게 수정했습니다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>callback - setInterval</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cbFunc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(count);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (++count &gt; <span class=\"number\">4</span>) clearInterval(timer);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> timer = setInterval(cbFunc, <span class=\"number\">300</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- 실행 결과 --</span></span><br><span class=\"line\"><span class=\"comment\">// 0  (0.3초)</span></span><br><span class=\"line\"><span class=\"comment\">// 1  (0.6초)</span></span><br><span class=\"line\"><span class=\"comment\">// 2  (0.9초)</span></span><br><span class=\"line\"><span class=\"comment\">// 3  (1.2초)</span></span><br><span class=\"line\"><span class=\"comment\">// 4  (1.5초)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>timer</code>변수에는 <code>setInterval</code>의 ID 값이 담기게 됩니다.</li>\n</ul>\n<ul>\n<li><code>setInterval</code>에 전달한 첫 번째 인자인 <code>cbFunc</code>함수(이 함수가 곧 콜백함수입니다.)는 0.3초마다 자동으로 실행될 것입니다. </li>\n</ul>\n<ul>\n<li>콜백 함수 내부에서는 <code>count</code> 값을 출력하고 1씩 증가시키며, <code>count</code>값이 4보다 크면 반복 실행이 종료됩니다.</li>\n</ul>\n<ul>\n<li>제어권<br><code>setInterval</code> 메서드에 첫 번째 인자로 <code>cbFunc</code> 함수를 넘겨주자 제어권을 넘겨받은 <code>setInterval</code> 메서드는 0.3초마다 (지정된 시점) 이 익명 함수를 실행했습니다. 이처럼 <u>콜백 함수의 제어권을 넘겨받은 코드</u>는 <mark>콜백 함수 호출 시점에 대한 제어권</mark>을 가집니다.</li>\n</ul>\n<h3 id=\"인자-파라미터\"><a href=\"#인자-파라미터\" class=\"headerlink\" title=\"인자 (파라미터)\"></a>인자 (파라미터)</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> newArr = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>].map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentValue, index</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(currentValue, index);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> currentValue + <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- 실행 결과 --</span></span><br><span class=\"line\"><span class=\"comment\">// 10 0</span></span><br><span class=\"line\"><span class=\"comment\">// 20 1</span></span><br><span class=\"line\"><span class=\"comment\">// 30 2</span></span><br><span class=\"line\"><span class=\"comment\">// [15, 25, 35]</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li><p><code>newArr</code> 변수를 선언하고 오른쪽에 배열 <code>[10, 20, 30]</code>에 <code>map</code> 메서드를 호출하고 그 결과를 할당합니다.</p>\n<p><code>map</code>메서드의 동작 방식부터 살펴보도록 하겠습니다.</p>\n<blockquote>\n<p>Array.prototype.map(callback[, thisArg])<br>callback : function(currentValue, index, array)</p>\n</blockquote>\n<p><code>map</code> 메서드는 Array.prototype에 담긴 메서드입니다.</p>\n<ul>\n<li><p>파라미터</p>\n<ul>\n<li>첫 번째 인자: <code>callback</code> 함수를 받습니다</li>\n<li>두 번째 인자: 생략가능한 파라미터이며, 콜백 함수 내부에서 <code>this</code>로 인식할 대상을 지정합니다. 생략시 일반적인 함수와 마찬가지로 전역객체를 참조하게 됩니다.</li>\n</ul>\n</li>\n<li><p>반환 값</p>\n<ul>\n<li><code>map</code>메서드는 메서드의 대상이 되는 배열의 모든 요소들을 차례대로 불러와 콜백 함수를 반복 호출하고, <u>콜백 함수의 실행 결과를 모아 새로운 배열</u>을 반환합니다.</li>\n</ul>\n</li>\n<li><p><code>callback</code>함수<br>콜백 함수의 첫 번째 인자에는 배열의 요소중 <code>현재값</code>, 두 번째 인자에는 <code>현재값의 index</code>, 세 번째 인자에는 <code>map</code>메서드의 <code>대상이 되는 배열</code>이 담깁니다.</p>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li><code>map</code> 메서드는 배열<code>[10, 20, 30]</code>의 각 요소를 차례대로 꺼내어 콜백 함수를 실행합니다.</li>\n</ol>\n<ol start=\"3\">\n<li>첫 번째 요소에 대한 콜백 함수는 <code>currentValue</code>에 10이, <code>index</code>에는 index 0이 담긴 채 실행됩니다 <code>return currentValue + 5;</code> 코드를 실행하여 <code>(10 + 5)</code> 값인 <code>15</code>가 반환됩니다.</li>\n</ol>\n<ol start=\"4\">\n<li>두 번째 요소에 대한 콜백 함수는 <code>currentValue</code>에 20이, <code>index</code>에는 index 1이 담긴 채 실행됩니다 <code>return currentValue + 5;</code> 코드를 실행하여 <code>(20 + 5)</code> 값인 <code>25</code>가 반환됩니다.</li>\n</ol>\n<ol start=\"5\">\n<li>세 번째 요소에 대한 콜백 함수는 <code>currentValue</code>에 30이, <code>index</code>에는 index 2이 담긴 채 실행됩니다 <code>return currentValue + 5;</code> 코드를 실행하여 <code>(30 + 5)</code> 값인 <code>35</code>가 반환됩니다.</li>\n</ol>\n<ol start=\"6\">\n<li>모든 요소에 대한 콜백 함수를 마치고 나면 <code>[15, 25, 35]</code>라는 새로운 배열이 만들어져 <code>newArr</code>변수에 할당됩니다.</li>\n</ol>\n<ol start=\"7\">\n<li><code>console.log(newArr)</code> 코드에서 <code>newArr</code>변수에 할당된 새로운 배열이 출력됩니다.</li>\n</ol>\n<p><strong>중요 포인트</strong></p>\n<p><code>콜백 함수</code>의 파라미터 순서를 바꾸면 안됩니다. <code>currentValue</code>, <code>index</code>순 이어야하며<br>바뀐다면 전혀 다른 값을 반환할 것입니다.</p>\n<p><del>엔진은 파라미터로 받은 값의 단어(name)를 인식하는 것이 아니라 순서(첫 번째, 두 번째)에 의해서만 각각을 구분하고 인식합니다.</del> </p>\n<hr>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h3><p>콜백 함수 내부에서의 this</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">300</span>); <span class=\"comment\">// (1) Window &#123; ... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// (2) Window &#123; ... &#125;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.innerHTML += <span class=\"string\">'&lt;button id=\"a\"&gt;클릭&lt;/button&gt;'</span>;</span><br><span class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">document</span>.body.querySelector(<span class=\"string\">'#a'</span>).addEventListener(</span><br><span class=\"line\">  <span class=\"string\">'click'</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, e); <span class=\"comment\">// (3) &lt;button id=\"a\"&gt;클릭&lt;/button&gt;</span></span><br><span class=\"line\">  &#125; <span class=\"comment\">// MouseEvent &#123; isTrusted: true, ... &#125;</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>setTimeout</code>은 내부에서 콜백 함수를 호출할 때 <code>call</code>메서드의 첫 번째 인자로 전역객체를 넘기게 됩니다. 콜백 함수 내부에서 <code>this</code>가 전역객체를 가리키게됩니다. </li>\n</ol>\n<ol start=\"2\">\n<li><code>forEach</code>는 ‘별도의 인자로 this를 받는 경우’에 해당하지만 별도로 <code>this</code>를 지정해주지 않았기 때문에 전역객체를 가리키게됩니다.</li>\n</ol>\n<ol start=\"3\">\n<li><code>addEventListener</code>는 내부에서 콜백 함수를 호출할 때 <code>call</code>메서드의 첫 번째 인자에 <code>addEventListener</code>메서드의 <code>this</code>를 넘기도록 정의되어 있습니다. 때문에 콜백 함수 내부에서의 <code>this</code>는 <code>addEventListener</code>를 호출한 주체 <code>HTML</code> 엘리먼트를 가리키게 됩니다. </li>\n</ol>\n<hr>\n<h2 id=\"callback_function\">콜백 함수는 함수다.</h2>\n\n<p>콜백 함수로 객체의 메서드를 전달하더라도 그 메서드는 메서드가 아닌 함수로 호출됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>메서드를 콜백 함수로 전달한 경우</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  vals: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  logValues: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v, i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, v, i);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"number\">2.</span> obj.logValues(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// &#123; vals: [1, 2, 3], logValues: f &#125; 1 2</span></span><br><span class=\"line\"><span class=\"number\">3.</span> [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>].forEach(obj.logValues); <span class=\"comment\">// Window &#123; ... &#125; 4 0</span></span><br><span class=\"line\"><span class=\"comment\">// Window &#123; ... &#125; 5 1</span></span><br><span class=\"line\"><span class=\"comment\">// Window &#123; ... &#125; 6 2</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>obj</code> 객체의 <code>logValues</code>는 메서드로 정의됐습니다.</li>\n</ol>\n<ol start=\"2\">\n<li>메서드의 이름 앞에 점(.)이 있으니 메서드로서 호출한 것 입니다. <code>this</code>는 <code>obj</code>를 가리키고 파라미터로 넘겨준 1, 2와 함께 출력됩니다.</li>\n</ol>\n<ol start=\"3\">\n<li><code>obj.logValues</code>메서드를 <code>forEach</code> 함수의 콜백 함수로서 지정했습니다.<br><code>obj</code>를 <code>this</code>로 하는 메서드를 그대로 전달한 것이 아니라, <code>obj.logValues</code>가 가리키는 함수만 전달한 것입니다.<br>이 함수는 메서드로서 호출할 때가 아닌 한 <code>obj</code>와의 직접적인 연관이 없어집니다.<br><code>forEach</code>에 의해 콜백이 함수로서 호출되고, 별도로 <code>this</code>를 지정하지 않았으므로 <code>this</code>는 전역객체를 참조합니다.</li>\n</ol>\n<p><strong>중요 포인트</strong></p>\n<p>어떤 함수의 인자(파라미터)에 객체의 메서드를 전달하더라도 메서드가 아닌 함수일 뿐입니다.<br>이 차이를 정확히 이해하는 것이 중요합니다.</p>\n<hr>\n<h2 id=\"callback_this_binding\">콜백 함수 내부의 this에 다른 값 바인딩 하기</h2>\n\n<p>콜백 함수에서 <code>this</code>를 지정하지 않으면 전역객체를 참조하게 되므로<br>객체의 메서드를 콜백 함수로 전달하면 해당 객체를 <code>this</code>로 참조할 수 없게됩니다.</p>\n<p>별도의 인자(<code>thisArg</code>)로 <code>this</code>를 받는 함수의 경우에는 원하는 값을 넘겨주면 되지만 그렇지 않은 경우에는 <code>this</code>의 제어권도 넘겨주게 되므로 사용자가 임의로 값을 변경할 수 없습니다.</p>\n<p>그래서 <makr>전통적으로는 <code>this</code>를 다른 변수에 담아 콜백 함수로 활용할 함수에서는 <code>this</code>대신 그 변수를 사용하게 하고, 이를 클로저로 만드는 방식이 많이 쓰였습니다.</mark></p>\n<figure class=\"highlight js\"><figcaption><span>콜백 함수 내부의 this에 다른 값을 바인딩 - 전통적인 방법(변수 사용)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj1'</span>,</span><br><span class=\"line\">  func: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(self.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> callback = obj1.func();</span><br><span class=\"line\">setTimeout(callback, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>obj1.func</code> 메서드 내부에서 <code>self</code> 변수에 <code>this</code>를 담고, 익명 함수를 선언하고 반환했습니다.</li>\n</ol>\n<ol start=\"2\">\n<li><code>obj1.func</code>를 호출하면 앞서 선언한 내부함수가 반환되어 <code>callback</code> 변수에 할당됩니다.</li>\n</ol>\n<ol start=\"3\">\n<li>이 <code>callback</code>변수를 <code>setTimeout</code> 함수에 인자로 전달하면 1초(1000ms) 뒤 <code>callback</code>이 실행되면서 <code>&quot;obj1&quot;</code>을 반환할 것입니다.</li>\n</ol>\n<p><strong>중요 포인트</strong><br>이 방식은 <code>this</code>를 다른 변수에 담아 함수내에서 <code>this</code> 대신 그 변수를 사용하게하여 실제로는 <code>this</code>를 사용하지 않을뿐더러 번거롭습니다.</p>\n<ul>\n<li><p>ES5에 등장한 <code>bind</code>메서드를 사용하면 더욱 간편히 <code>this</code>를 바인딩할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>콜백 함수 내부의 this에 다른 값 바인딩 - bind 메서드 사용</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj1'</span>,</span><br><span class=\"line\">  func: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">setTimeout(obj1.func.bind(obj1), <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'obj2'</span> &#125;;</span><br><span class=\"line\">setTimeout(obj1.func.bind(obj2), <span class=\"number\">1500</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>bind</code> 메서드의 첫 번째 인자(<code>thisArg</code>)로 <code>this</code>로 지정할 값을 전달합니다.<br>함수가 실행될때 <code>this</code>는 <code>thisArg</code>로 전달받은 값을 참조하게 됩니다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"callback_hell\">콜백 지옥과 비동기 제어</h2>\n\n<ul>\n<li><p>콜백 지옥(<code>callback hell</code>)이란?</p>\n<p>콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상.<br>주로 이벤트 처리나 서버 통신과 같이 비동기적인 작업을 수행하기 위해 이런 형태가 자주 등장하곤 하는데, 가독성이 떨어질 뿐더러 코드를 수정하기도 힘들다.</p>\n</li>\n</ul>\n<ul>\n<li><p>비동기(<code>asynchronous</code>)란?</p>\n<p>동기(<code>synchronous</code>)의 반대말로 <mark>동기적인 코드는 현재 실행 중인 코드가 완료된 후에야 다음 코드를 실행하는 방식</mark><br>비동기적 코드는 <mark>현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어갑니다.</mark></p>\n</li>\n</ul>\n<ol>\n<li><p>사용자의 요청에 의해 특정 시간이 경과되기 전까지 어떤 함수의 실행을 보류한다거나 -<code>setTimeout</code></p>\n</li>\n<li><p>사용자의 직접적인 개입이 있을 때 어떤 함수를 실행하도록 대기한다거나 -<code>addEventListener</code></p>\n</li>\n<li><p>웹브라우저 자체가 아닌 별도의 대상에 무언가를 요청하고 그에 대한 응답이 왔을 때 어떤 함수를 실행하도록 대기하는 등 -<code>XMLHttpRequest</code></p>\n<p><del>CPU의 계산에 의해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드입니다.</del><br><mark>별도의 요청, 실행 대기, 보류 등과 관련된 코드는 비동기적인 코드입니다.</mark></p>\n</li>\n</ol>\n<ul>\n<li>현대의 자바스크립트는 웹의 복잡도가 높아진 만큼 비동기적인 코드의 비중이 예전보다 훨씬 높아진 상황입니다. (콜백 지옥에 빠지기도 훨씬 쉬워졌습니다.)</li>\n</ul>\n<hr>\n<p><strong>간단한 콜백 지옥 예시를 살펴봅시다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>callback-hell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> coffeeList = name;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">        coffeeList += <span class=\"string\">', '</span> + name;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\"></span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">            coffeeList += <span class=\"string\">', '</span> + name;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\"></span><br><span class=\"line\">            setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">                coffeeList += <span class=\"string\">', '</span> + name;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">              &#125;, <span class=\"number\">500</span>, <span class=\"string\">'카페라떼'</span>);</span><br><span class=\"line\">          &#125;, <span class=\"number\">500</span>, <span class=\"string\">'카페모카'</span>);</span><br><span class=\"line\">      &#125;, <span class=\"number\">500</span>, <span class=\"string\">'아메리카노'</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">500</span>, <span class=\"string\">'에스프레소'</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>0.5 초마다 커피 목록을 수집하고 출력합니다. 각 콜백은 커피 이름을 전달하고 <code>coffeeList</code>에 추가합니다. </p>\n</li>\n<li><p>실행에는 지장이 없는 코드입니다만, 들여쓰기 수준이 과도하게 깊어졌을 뿐더러 수정하기도 불편하고 값이 전달되는 순서가 아래에서 위로 향하고 있어 어색하게도 느껴집니다.</p>\n</li>\n</ul>\n<p>가독성 문제와 어색함을 동시에 해결하는 방법은 익명 콜백함수를 모두 기명함수로 전환하는 방법이 있습니다…?!</p>\n<hr>\n<figure class=\"highlight js\"><figcaption><span>기명함수로 변환</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> coffeeList = <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> addEspresso = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  coffeeList = name;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">  setTimeout(addAmericano, <span class=\"number\">500</span>, <span class=\"string\">'아메리카노'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> addAmericano = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  coffeeList += <span class=\"string\">', '</span> + name;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">  setTimeout(addMocha, <span class=\"number\">500</span>, <span class=\"string\">'카페모카'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> addMocha = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  coffeeList += <span class=\"string\">', '</span> + name;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">  setTimeout(addLatte, <span class=\"number\">500</span>, <span class=\"string\">'카페라떼'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> addLatte = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  coffeeList += <span class=\"string\">', '</span> + name;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(addEspresso, <span class=\"number\">500</span>, <span class=\"string\">'에스프레소'</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>익명함수를 기명함수로 변환하므로서 콜백 지옥을 해결한 예시입니다.</li>\n</ul>\n<p>함수 선언과 함수 호출을 구분한다면 코드의 가독성을 높여 코드를 위에서 아래로 읽어내려가는데 어려움이 없습니다. 변수가 전역으로 전개되긴 했지만 즉시 실행 함수 등으로 감싸면 해결할 수 있는 문제입니다.</p>\n<p>하지만 코드명을 일일이 따라다녀야 하므로 오히려 헷갈릴 여지도 있습니다.</p>\n<ul>\n<li>자바스크립트는 비동기적인 작업들을 동기적으로(혹은 동기적인 것처럼 보이도록) 처리해주는 방법을 고안했고, 그 결과 <code>ES6</code>에서 <code>Promise</code>, <code>Generator</code>등이 도입됐으며, <code>ES8(ES2017)</code>에서는 <code>async</code>, <code>wait</code>가 도입됐습니다.</li>\n</ul>\n<hr>\n<p><strong>이들을 활용한 표현법도 알아봅시다.</strong></p>\n<figure class=\"highlight js\"><figcaption><span>비동기 작업의 동기적 표현 -Promise</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'에스프레소'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    resolve(name);</span><br><span class=\"line\">  &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> name = prevName + <span class=\"string\">', 아메리카노'</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">        resolve(name);</span><br><span class=\"line\">      &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> name = prevName + <span class=\"string\">', 카페모카'</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">        resolve(name);</span><br><span class=\"line\">      &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> name = prevName + <span class=\"string\">', 카페라떼'</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">        resolve(name);</span><br><span class=\"line\">      &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>ES6</code>의 <code>Promise</code>를 이용한 방법입니다. <code>new</code>연산자와 함께 호출한 <code>Promise</code>의 인자로 넘겨주는 콜백 함수는 호출할 때 바로 실행되지만 내부에 <code>resolve</code> 또는 <code>reject</code> 함수를 호출하는 구문이 있을 경우 둘 중하나가 충족되어 실행되기 전까지는 <code>.then</code> 또는 <code>.catch</code> 구문으로 넘어가지 않습니다.</p>\n<p>따라서 비동기 작업이 완료될 때 <code>resolve</code> 또는 <code>reject</code>를 호출하는 방법으로 비동기 작업의 동기적 표현이 가능합니다.</p>\n<hr>\n<p>다음은 위에 코드의 반복적인 내용을 함수화 하여 더욱 짧게 표현한 것입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>Promise 동기적표현 함수화</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addCoffee = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> newName = prevName ? prevName + <span class=\"string\">', '</span> + name : name;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(newName);</span><br><span class=\"line\">        resolve(newName);</span><br><span class=\"line\">      &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">addCoffee(<span class=\"string\">'에스프레소'</span>)()</span><br><span class=\"line\">  .then(addCoffee(<span class=\"string\">'아메리카노'</span>))</span><br><span class=\"line\">  .then(addCoffee(<span class=\"string\">'카페모카'</span>))</span><br><span class=\"line\">  .then(addCoffee(<span class=\"string\">'카페라떼'</span>));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<ul>\n<li>Generator 활용</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>비동기 작업의 동기적 표현 -Generator</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addCoffee = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevName, name</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    coffeeMaker.next(prevName ? prevName + <span class=\"string\">', '</span> + name : name);</span><br><span class=\"line\">  &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> coffeeGenerator = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> espresso = <span class=\"keyword\">yield</span> addCoffee(<span class=\"string\">''</span>, <span class=\"string\">'에스프레소'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(espresso);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> americano = <span class=\"keyword\">yield</span> addCoffee(espresso, <span class=\"string\">'아메리카노'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(americano);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> mocha = <span class=\"keyword\">yield</span> addCoffee(americano, <span class=\"string\">'카페모카'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mocha);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> latte = <span class=\"keyword\">yield</span> addCoffee(mocha, <span class=\"string\">'카페라떼'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(latte);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> coffeeMaker = coffeeGenerator();</span><br><span class=\"line\">coffeeMaker.next();</span><br></pre></td></tr></table></figure>\n\n<p><code>ES6</code>의 <code>Generator</code>를 이용한 방법입니다.<br><code>Generator</code> 함수를 실행하여 <code>Iterator</code>을 반환받고 <code>Iterator</code>의 메서드 <code>next</code>를 사용할 수 있습니다</p>\n<p><code>next</code> 메서드를 호출하면 <code>Generator</code> 함수 내부에서 첫 번째 <code>yield</code>를 만나면 함수 실행을 멈추게 되고 다시 <code>next</code>를 호출하면 멈춘 부분부터 그 다음에 등장하는 <code>yield</code>에서 함수 실행을 멈추게 됩니다.</p>\n<p>즉, 비동기 작업이 완료되는 시점마다 <code>next</code> 메서드를 호출해준다면 <code>Generator</code> 함수 내부의 소스가 순차적으로 진행되게 합니다.</p>\n<hr>\n<ul>\n<li>Promise + async/await</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addCoffee = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      resolve(name);</span><br><span class=\"line\">    &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> coffeeMaker = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> coffeeList = <span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _addCoffee = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    coffeeList += (coffeeList ? <span class=\"string\">','</span> : <span class=\"string\">''</span>) + (<span class=\"keyword\">await</span> addCoffee(name));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> _addCoffee(<span class=\"string\">'에스프레소'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> _addCoffee(<span class=\"string\">'아메리카노'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> _addCoffee(<span class=\"string\">'카페모카'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> _addCoffee(<span class=\"string\">'카페라떼'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(coffeeList);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">coffeeMaker();</span><br></pre></td></tr></table></figure>\n\n<p><code>ES8(ES2017)</code>에서 추가된 <code>async/await</code>는 비동기 작업을 수행하고자 하는 함수 앞에 <code>async</code>를 표기하고, 함수 내부에서 비동기 작업이 필요한 위치마다 <code>await</code>를 표기하는 것만으로 뒤의 내용을 <code>Promise</code>로 자동 전환하고, 해당 내용이 <code>resolve</code>된 이후에야 다음으로 진행합니다.</p>\n<p><code>Promise</code>의 <code>then</code>과 비슷한 효과를 얻을 수 있습니다.</p>\n<hr>\n<h2 id=\"callback\">정리</h2>\n\n<ul>\n<li>콜백 함수는 다른 코드에 인자를 넘겨줌으로써 <mark>제어권도 함께 위임</mark>.</li>\n</ul>\n<ul>\n<li><p>제어권을 넘겨받은 코드는 </p>\n<ol>\n<li><p>콜백 함수를 호출하는 시점을 지정.</p>\n</li>\n<li><p>콜백 함수를 호출할 때 <mark>인자로 넘겨줄 값의 순서를 변경하지 말 것.</mark></p>\n</li>\n<li><p>콜백 함수는 <code>this</code>를 지정하여 사용할 수 있는 함수가 존재, 지정하지 않을 경우 전역객체를 참조<br>사용자 임의로 <code>this</code>를 변경하고 싶은 경우 <code>bind</code> 메서드 활용</p>\n</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>함수에 인자로 메서드를 전달하더라도 이는 <mark>함수로서 실행됨</mark>.</li>\n</ul>\n<ul>\n<li>비동기 제어를 위해 콜백 함수를 사용하다 보면 콜백 지옥에 빠지기 쉬움.<br>최근의 자바스크립트에서는 <mark>Promise, Generator, async/await</mark> 등 콜백 지옥을 벗어날 수 있는 방법들이 등장함.</li>\n</ul>"},{"title":"클로저 -Core JavaScript","disqusId":"tunas-blog-1","date":"2020-05-03T06:56:17.000Z","_content":"\n* 클로저 (Closure)\n  * [클로저의 의미 및 원리 이해](/2020/05/03/클로저-Core-JavaScript/#closure)\n  * [클로저와 메모리 관리](/2020/05/03/클로저-Core-JavaScript/#closure_memory)\n  * [클로저 활용 사례](/2020/05/03/클로저-Core-JavaScript/#closure_ex)\n    * 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때\n    * 접근 권한 제어 (정보 은닉)\n    * 부분 적용 함수\n    * 커링 함수\n  * [정리](/2020/05/03/클로저-Core-JavaScript/#)\n\n<!-- more -->\n\n------\n<h2 id=\"closure\">클로저의 의미 및 원리 이해</h2>\n\n클로저(`Closure`)는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성입니다.\n자바스크립트 고유의 개념이 아니라서 ECMAScript 명세에서도 클로저의 정의를 다루지 않고 있고, 다양한 문헌에서 제각각 클로저를 다르게 정의 또는 설명하고 있습니다.\n\n다양한 서적에서 클로저를 한 문장으로 요약해서 설명하는 부분들을 소개하면 다음과 같습니다.\n    * 자신을 내포하는 함수의 컨텍스트에 접근할 수 있는 함수\n    \n    * 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 것\n    \n    * 함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수\n    \n    * 이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수\n    \n    * 자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합\n    \n    * 로컬 변수를 참조하고 있는 함수 내의 함수\n    \n    * 자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수\n\n\n**MDN** 에서는 클로저를 함수와 그 함수가 선언될 당시의 `LexicalEnvironment`의 조합이라고 소개하고,\n다른 말로 클로저는 내부 함수에서 외부 함수의 범위로 접근할 수 있게 해주는 함수라고 합니다.\n\n\n선언될 당시의 `LexicalEnvironment`는 실행 컨텍스트의 구성 요소 중 하나인 `outerEnvironmentReference`에 해당합니다. \n`LexicalEnvironment`의 `environmentRecord`와 `outerEnvironmentReference`에 의해 변수의 유효범위인 스코프가 결정되고 스코프 체인이 가능해집니다.\n\n\n* `컨텍스트 A`에서 선언한 `내부 함수B`의 실행 컨텍스트가 활성화된 시점에서는 B의 `outerEnvironmentReference`가 참조하는 대상인 A의 `LexicalEnvironment`에도 접근이 가능해 집니다. A에서는 B에서 선언한 변수에 접근할 수 없지만 B에서는 A에 선언한 변수에 접근이 가능해집니다.\n\n\n* 이런 내부함수에서 외부 변수를 참조하게 되는 경우가, 선언될 당시의 `LexicalEnvironment`와의 상호관계(조합)의 의미가 됩니다.\n\n```js 외부 함수의 변수를 참조하는 내부 함수 -1\nvar outer = function() {\n  var a = 1;\n  var inner = function() {\n    console.log(++a);\n  };\n  inner();\n};\nouter();\n```\n\n1. `outer` 함수에 변수 a를 선언했고 1을 할당했습니다.\n\n\n2. `outer`의 내부함수인 `inner` 함수에서 a의 값을 1 증가시키고 출력합니다.\n\n\n* `inner`함수 내부에서는 a를 선언하지 않았기 때문에 `environmentRecord`에서 값을 찾지 못하므로 `outerEnvironmentReference`에 지정된 상위 컨텍스트인 `outer`의 `LexicalEnvironment`에 접근하여 다시 a를 찾습니다.\n\n\n* `outer` 함수의 실행 컨텍스트가 종료되면 `LexicalEnvironment`에 저장된 식별자들(a,inner)에 대한 참조를 지웁니다. 그러면 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 `가비지컬렉터(GC)`의 수집 대상이 됩니다.\n\n```js 외부 함수의 변수를 참조하는 내부 함수 -2\nvar outer = function() {\n  var a = 1;\n  var inner = function() {\n    return ++a;\n  };\n  return inner();\n};\nvar outer2 = outer();\nconsole.log(outer2); // 2\n```\n\n* 이 예제 역시 `inner`함수 내부에서 외부변수인 a를 사용했습니다.\n`inner` 함수를 실행한 결과를 `return` 하고 나면 `outer`함수의 실행 컨텍스트가 종료된 시점에는 a변수를 참조하는 대상이 없어집니다. 그러므로 예제1과 마찬가지로 식별자들의(a,inner) 값들은 `가비지컬렉터(GC)`에 의해 소멸됩니다.\n\n\n* 예제1과 예제2는 `outer`함수의 실행 컨텍스트가 종료되기 이전에 `inner` 함수의 실행 컨텍스트가 종료돼 있으며, 이후 별도로 `inner` 함수를 호출할 수 없다는 공통점을 가지고 있습니다.\n\n<mark>그렇다면 outer의 실행 컨텍스트가 종료된 후에도 inner 함수를 호출할 수 있게 만들면 어떨까요?</mark>\n\n```js 외부 함수의 변수를 참조하는 내부 함수 -3\nvar outer = function() {\n  var a = 1;\n  var inner = function() {\n    return ++a;\n  };\n  return inner;\n};\nvar outer2 = outer();\nconsole.log(outer2()); // 2\nconsole.log(outer2()); // 3\n```\n\n1. `return inner()` 함수의 실행 결과가 아닌 `return inner` 함수 자체를 반환했습니다.\n\n\n2. `outer2` 변수는 `outer`함수의 실행 결과인 `inner`함수 자체를 참조하게 됩니다.\n`outer2` 호출시 `inner` 함수가 실행됨.\n\n\n3. `inner` 함수의 실행 컨텍스트의 `environmentRecord`에는 수집할 정보가 없습니다. `outerEnvironmentReference`에는 `inner` 함수가 선언된 위치의 `LexicalEnvironment`가 참조복사 됩니다. `inner`함수는 `outer` 함수 내부에서 선언됐으므로, `outer` 함수의 `LexicalEnvironment`가 담깁니다.\n\n\n4. 스코프체이닝에 따라 `outer`에서 선언한 변수 a에 접근해 1만큼 증가시킨후 결과 값인 2를 반환하고, `inner`함수의 실행 컨텍스트가 종료됩니다.\n\n\n5. `outer2`<u>를 다시 호출하면 같은 방식으로 a의 값을 2에서 1만큼 증가시켜 그 결과 값인 3을 반환합니다.</u>\n \n\n**중요 포인트**\n\n* `outer`함수의 실행 컨텍스트는 종료된 상태인데 어떻게 외부 함수의 변수(`outer` 함수의 `LexicalEnvironment`)에 접근할 수 있는 걸까?\n\n\n* 이는 가비지컬렉터의 동작 방식 때문입니다.\n\n\n* <mark>어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 가비지컬렉터(GC)의 대상이 되지 않습니다.</mark>\n\n\n* `outer` 함수는 실행 종료 시점에 `inner` 함수를 반환했습니다. `outer` 함수는 `inner`함수를 참조하게 되고 외부함수인 `outer`의 실행이 종료되었지만 내부함수인 `inner`함수는 언젠가 `outer()`형식 (변수 outer2와 같은)으로 호출될 수 있습니다.\n\n\n* `inner` 함수 역시 `outer`의 변수를 참조하므로 실행 컨텍스트가 활성화 되면 `outerEnvironmentReference`가 `outer` 함수의 `LexicalEnvironment`를 필요로 하게되므로 `가비지컬렉터(GC)`의 대상에서 제외됩니다. 그 덕에 `inner`함수가 외부함수의 변수에 접근할 수 있는 것입니다.\n\n\n* 클로저란 :\n  <mark>외부 함수에서 선언한 변수를 참조하는 내부 함수를 외부로 전달할 경우 외부 함수의 실행 컨텍스트가 종료된 이후에도 변수가 사라지지 않는 현상</mark>\n\n\n* \"내부함수를 외부로 전달\"이 return만을 의미하는 것은 아님. 다른 경우도 존재\n\n```js return 없이 클로저가 발생하는 경우\n// (1) setInterval/setTimeout\n(function() {\n  var a = 0; // 외부 함수의 변수를 내부 함수에서\n  var intervalId = null; // 참조하고 있으므로 GC의 대상이 되지 않음. \n  var inner = function() {\n    if (++a >= 10) { // 외부 함수의 변수a 참조\n      clearInterval(intervalId); // 외부 함수의 변수 intervalId 참조\n    }\n    console.log(a);\n  };\n  intervalId = setInterval(inner, 1000);\n})();\n```\n\n별도의 외부객체인 window의 메서드(setTimeout 또는 setInterval)에 전달할 콜백 함수 내부에서 지역변수를 참조합니다.\n\n```js return 없이 클로저가 발생하는 경우\n// (2) eventListener\n(function() {\n  var count = 0;\n  var button = document.createElement('button');\n  button.innerText = 'click';\n  button.addEventListener('click', function() {\n    console.log(++count, 'times clicked');\n  });\n  document.body.appendChild(button);\n})();\n```\n\n별도의 외부 객체인 DOM의 메서드 (addEventListener)에 등록할 handler 함수 내부에서 지역변수를 참조합니다.\n\n<mark>두 상황 모두 두 지역변수를 참조하는 내부함수를 외부에 전달했기 때문에 클로저(closure)입니다.</mark>\n\n------\n<h2 id=\"closure_memory\">클로저와 메모리 관리</h2>\n\n* <mark>클로저는 객체지향과 함수형 모두를 아우르는 매우 중요한 개념입니다.</mark>\n\n* 메모리 누수:\n개발자의 의도와 달리 어떤 값의 참조 카운트가 0이 되지 않아 GC의 수거 대상이 되지 않는 경우 발생할 수 있습니다.\n(개발자가 의도적으로 참조 카운트가 0이 되지 않게 설계한 경우는 '누수'라는 표현은 맞지 않습니다.)\n\n* <mark>클로저는 의도대로 설계한 \"메모리 소모\"에 대한 관리법을 잘 파악해서 적용하는 것이 중요합니다.</mark>\n\n------\n### 메모리 관리 방법\n\n클로저는 필요에 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생합니다.\n그렇다면 <u>필요성이 사라진 시점</u>에는 더는 메모리를 소모하지 않게 해주면 됩니다.\n\n참조 카운트를 0으로 만들면(GC의 작동원리) GC가 수거해 갈것이고, 이때 소모됐던 메모리가 회수됩니다.\n\n* 참조 카운트를 0으로 만드는 방법 ?\n식별자에 참조형이 아닌 기본형 데이터(보통 `null`이나 `undefined`)를 할당하면 됩니다.\n\n```js 클로저의 메모리 관리 - return\n// (1) return에 의한 클로저의 메모리 해제\nvar outer = (function() {\n  var a = 1;\n  var inner = function() {\n    return ++a;\n  };\n  return inner;\n})();\nconsole.log(outer());\nconsole.log(outer());\nouter = null; // outer 식별자의 inner 함수 참조를 끊음\n```\n\n```js 클로저의 메모리 관리 - setInterval\n// (2) setInterval에 의한 클로저의 메모리 해제\n(function() {\n  var a = 0;\n  var intervalId = null;\n  var inner = function() {\n    if (++a >= 10) {\n      clearInterval(intervalId);\n      inner = null; // inner 식별자의 함수 참조를 끊음\n    }\n    console.log(a);\n  };\n  intervalId = setInterval(inner, 1000);\n})();\n```\n\n```js 클로저의 메모리 관리 - eventListener\n// (3) eventListener에 의한 클로저의 메모리 해제\n(function() {\n  var count = 0;\n  var button = document.createElement('button');\n  button.innerText = 'click';\n\n  var clickHandler = function() {\n    console.log(++count, 'times clicked');\n    if (count >= 10) {\n      button.removeEventListener('click', clickHandler);\n      clickHandler = null; // clickHandler 식별자의 함수 참조를 끊음\n    }\n  };\n  button.addEventListener('click', clickHandler);\n  document.body.appendChild(button);\n})();\n```\n\n------\n<h2 id=\"closure_ex\">클로저 활용 사례</h2>\n\n클로저가 실제로 등장하는 활용 사례\n\n### 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때\n\n대표적인 콜백 함수 중 하나인 이벤트 리스너에 관한 예시\n\n```js\nvar fruits = ['apple', 'banana', 'peach'];\nvar $ul = document.createElement('ul'); // (공통 코드)\n\nfruits.forEach(function(fruit) {\n  // (A)\n  var $li = document.createElement('li');\n  $li.innerText = fruit;\n  $li.addEventListener('click', function() {\n    // (B)\n    alert('your choice is ' + fruit);\n  });\n  $ul.appendChild($li);\n});\ndocument.body.appendChild($ul);\n```\n\n1. `fruits` 변수를 순회하며 `li`를 생성하고 각 `li`를 클릭하면 해당 리스너의 콜백 함수가 실행됩니다.\n\n\n2. `forEach`메서드에 넘겨준 익명의 콜백 함수(A)는 내부에서 외부 변수를 사용하지 않으므로 클로저가 없습니다.\n\n\n3. `addEventListener`에 넘겨준 콜백 함수(B)에는 함수내의 `fruit`라는 외부 변수를 참조하고 있으므로 클로저가 있습니다.\n\n\n4. (A)는 `fruits`의 개수만큼 실행되며, 그때마다 새로운 실행 컨텍스트가 생성됩니다.\n\n\n5. (A)의 실행 종료 여부와 무관하게 클릭 이벤트에 의해 각 컨텍스트의 (B)가 실행될 때는 (B)의 `outerEnvironmentReference`가 (A)의 `LexicalEnvironment`를 참조하게 됩니다.\n\n\n6. 따라서 (B)함수가 참조할 예정인 변수 `fruit`에 대해서는 (A)함수가 종료된 후에도 `CG` 대상에서 제외되어 계속 참조 가능하게 됩니다.\n\n그런데 (B)함수의 쓰임이 콜백 함수에 국한되지 않는 경우라면 반복을 줄이기 위해 (B)함수를 외부로 분리하는 편이 나을 수 있습니다.\n\n따라서 다음은 `fruit`을 인자로 받아 출력하는 형태입니다.\n\n```js 콜백 함수 외부로꺼내어 공통 함수로 사용\nvar fruits = ['apple', 'banana', 'peach'];\nvar $ul = document.createElement('ul');\n\nvar alertFruit = function(fruit) {\n  alert('your choice is ' + fruit);\n};\nfruits.forEach(function(fruit) {\n  var $li = document.createElement('li');\n  $li.innerText = fruit;\n  $li.addEventListener('click', alertFruit);\n  $ul.appendChild($li);\n});\ndocument.body.appendChild($ul);\nalertFruit(fruits[1]);\n```\n\n* 공통 함수로 사용하고자 콜백 함수를 외부로 꺼내어 `alertFruit`라는 변수에 담았습니다.\n`alertFruit`를 직접 실행할 수 있게 되었습니다.\n\n* 하지만 각 `li`를 클릭하면 클릭한 대상의 과일명이 아닌 `[object MouseEvent]`라는 값이 출력됩니다.\n이는 콜백 함수의 인자에 대한 제어권을 `addEventListener`가 가진 상태이며, `addEventListener`는 콜백 함수를 호출할 때 첫 번째 인자에 \"이벤트 객체\"를 주입하기 때문입니다.\n\n이 문제는 `bind`메서드를 활용하면 해결할 수 있습니다.\n\n```js bind 메서드 사용\nvar fruits = ['apple', 'banana', 'peach'];\nvar $ul = document.createElement('ul');\n\nvar alertFruit = function(fruit) {\n  alert('your choice is ' + fruit);\n};\nfruits.forEach(function(fruit) {\n  var $li = document.createElement('li');\n  $li.innerText = fruit;\n  $li.addEventListener('click', alertFruit.bind(null, fruit));\n  $ul.appendChild($li);\n});\ndocument.body.appendChild($ul);\n```\n\n* 하지만 `bind`를 활용하면 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점과,\n함수 내부에서 `this`가 참조하는 값이 달라지는점을 감안해야 합니다.\n\n* 이러한 변경사항 마저 발생하지 않게 만들려면 `bind`메서드가 아닌 다른 방식으로 만들어야 합니다.\n\n```js 고차함수를 사용하여 클로저를 적극적으로 활용\nvar fruits = ['apple', 'banana', 'peach'];\nvar $ul = document.createElement('ul');\n\nvar alertFruitBuilder = function(fruit) {\n  return function() {\n    alert('your choice is ' + fruit);\n  };\n};\nfruits.forEach(function(fruit) {\n  var $li = document.createElement('li');\n  $li.innerText = fruit;\n  $li.addEventListener('click', alertFruitBuilder(fruit));\n  $ul.appendChild($li);\n});\ndocument.body.appendChild($ul);\n```\n\n* 고차함수란 함수를 인자로 받거나 함수를 리턴하는 함수입니다.\n\n1. `alertFruit` 함수 대신 `alertFruitBuilder`라는 이름의 함수를 작성했습니다.\n`alertFruitBuilder` 함수 내부에서는 다시 익명함수를 반환합니다.\n\n\n2. 이 익명함수 내부의 코드가 기존의 `alertFruit` 함수의 코드입니다. \n\n\n3. `alertFruitBuilder` 함수를 실행하면서 `fruit` 값을 인자로 전달하면, 함수의 실행 결과가\n다시 함수(`return function`)가 되며, 이렇게 반환된 함수를 리스너의 콜백 함수로써 전달할 것입니다.\n\n\n4. 클릭 이벤트가 발생하면 이 함수의 실행 컨텍스트가 열리면서 `alertFruitBuilder`의 파라미터로 넘어온 `fruit`를 `outerEnvironmentReference`에 의해 참조할 수 있게됩니다. \n즉, `alertFruitBuilder`의 실행 결과로 반환된 함수에는 클로저가 존재합니다.\n\n------\n#### 콜백 함수 내부에서 외부변수를 참조하기 위한 방법 정리.\n\n1. 콜백 함수를 내부함수로 선언하여 외부변수를 직접 참조하는 방법.(`GC의 참조카운트` 이용)\n\n\n2. `bind`메서드를 활용하여 값을 직접넘겨주는 방법. 클로저는 발생하지 않지만 몇가지 제약이 생김\n\n\n3. 콜백 함수를 고차함수로 바꿔서 클로저를 적극적으로 활용하는 방법. \n\n------\n### 접근 권한 제어(은닉)\n\n정보은닉(information hiding)은 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈간의 결합도를 낮추고 유연성을 높이고자 하는 현대 프로그래밍 언어의 중요한 개념 중 하나입니다.\n\n흔히 접근 권한에는 `public`, `private`, `protected` 세 종류가 있습니다.\n\n* `public` : 외부에서 접근 가능한 것\n\n* `private` : 내부에서만 사용하며 외부에 노출되지 않는 것\n\n자바스크립트는 기본적으로 변수 자체에 이러한 접근 권한을 직접 부여하도록 설계돼 있지 않습니다. 하지만 접근 권한 제어가 불가능한 것은 아닙니다. 클로저를 이용하면 함수 차원에서 `public`한 값과 `private`한 값을 구분하는 것이 가능합니다.\n\n```js public/private -return\nvar outer = function() {\n  var a = 1;\n  var inner = function() {\n    return ++a;\n  };\n  return inner;\n};\nvar outer2 = outer();\nconsole.log(outer2());\nconsole.log(outer2());\n```\n\n이전에 본 클로저 예제 입니다.\n\n* `outer`함수를 종료할 때 `inner` 함수를 반환함으로써 `outer`함수의 지역변수 a의 값을 외부에서도 읽을 수 있게 되었습니다.\n\n\n* 이처럼 클로저를 활용하면 외부 스코프에서 함수 내부의 변수들 중 선택적으로 일부 변수에 대한 접근 권환을 부여할 수 있습니다. (`return`을 활용하여)\n\n\n* `outer`함수는 외부(전역 스코프)로 부터 철저하게 격리된 닫힌 공간입니다.\n외부에서는 외부 공간에 노출돼 있는 `outer`라는 변수를 통해 `outer`함수를 실행할 수는 있지만, `outer`함수 내부에는 어떠한 개입도 할 수 없습니다. \n외부에는 오직 `outer`함수가 `return`한 정보에만 접근할 수 있습니다.\n`return`값이 외부에 정보를 제공하는 유일한 수단이 됩니다.\n\n\n* 외부에 제공하고자 하는 정보들을 모아서 `return`하고, 내부에서만 사용할 정보들은 `return`하지 않는 것으로 접근 권한 제어가 가능한 것입니다.\n\n\n* `return`한 변수들은 공개 맴버(`public member`)가 되고, 그렇지 않은 변수들은 비공개 맴버(`private member`)가 되는 것입니다.\n\n\n------\n#### 접근 권한 제어를 통한 보드 게임 예시\n\n자동차 경주 보드 게임.\n\n규칙\n\n    1. 각 턴마다 주사위를 굴려 나온 숫자(km)만큼 이동.\n    \n    2. 차량별로 연료량(fuel)과 연비(power)는 무작위로 생성.\n    \n    3. 남은 연료가 이동할 거리에 필요한 연료보다 부족하면 이동 불가.\n    \n    4. 모든 유저가 이동할 수 없는 턴에 게임이 종료됨.\n    \n    5. 게임 종료 시 가장 멀리 이동해 있는 사람이 승리.\n\n```js 규칙에 따른 간단한 자동차 객체\nvar car = {\n  fuel: Math.ceil(Math.random() * 10 + 10), // 연료(L)\n  power: Math.ceil(Math.random() * 3 + 2), // 연비(km/L)\n  moved: 0, // 총 이동거리\n  run: function() {\n    var km = Math.ceil(Math.random() * 6);\n    var wasteFuel = km / this.power;\n    if (this.fuel < wasteFuel) {\n      console.log('이동불가');\n      return;\n    }\n    this.fuel -= wasteFuel;\n    this.moved += km;\n    console.log(km + 'km 이동 (총 ' + this.moved + 'km)');\n  },\n};\n```\n\n위 코드는 `run` 메서드를 실행할 때마다 `car`객체의 `fuel`, `moved` 값이 변합니다.\n\n하지만 자바스크립트를 아는사람이 `car`객체의 `fuel`, `power`, `moved`값을 직접 지정해 버린다면 공평한 게임이 되지 못합니다. \n* 이렇게 값을 바꾸지 못하도록 객체가 아닌 함수로 만들고, 필요한 맴버만을 `return`할 필요가 있습니다.\n\n```js 함수를 실행함으로써 객체 생성\nvar createCar = function() {\n  var fuel = Math.ceil(Math.random() * 10 + 10); // 연료(L)\n  var power = Math.ceil(Math.random() * 3 + 2); // 연비(km / L)\n  var moved = 0; // 총 이동거리\n  return {\n    get moved() {\n      return moved;\n    },\n    run: function() {\n      var km = Math.ceil(Math.random() * 6);\n      var wasteFuel = km / power;\n      if (fuel < wasteFuel) {\n        console.log('이동불가');\n        return;\n      }\n      fuel -= wasteFuel;\n      moved += km;\n      console.log(km + 'km 이동 (총 ' + moved + 'km). 남은 연료: ' + fuel);\n    },\n  };\n};\nvar car = createCar();\n```\n\n* `createCar`라는 함수를 실행함으로써 객체를 생성하게 했습니다. `fuel`, `power` 변수는 비공개 맴버로 지정해 외부에서의 접근을 제한했고, `moved`변수는 `getter`만을 부여함으로써 \"읽기전용\" 속성을 부여했습니다.\n\n* 이제 외부에서는 오직 `run`메서드를 실행하는 것과 현재의 `moved`값을 확인하는 두 가지 동작만 할 수 있습니다.\n\n* `run`메서드를 다른 내용으로 덮어씌우는 어뷰징은 여전히 가능한 상태이긴 하지만 앞서의 코드보다 훨씬 안전한 코드가 됐습니다. 이런 어뷰징까지 막기 위해서는 객체를 `return`하기 전에 미리 변경할 수 없게끔 조치를 취해야 합니다.\n\n```js Object.freeze\nvar createCar = function() {\n  var fuel = Math.ceil(Math.random() * 10 + 10); // 연료(L)\n  var power = Math.ceil(Math.random() * 3 + 2); // 연비(km / L)\n  var moved = 0; // 총 이동거리\n  var publicMembers = {\n    get moved() {\n      return moved;\n    },\n    run: function() {\n      var km = Math.ceil(Math.random() * 6);\n      var wasteFuel = km / power;\n      if (fuel < wasteFuel) {\n        console.log('이동불가');\n        return;\n      }\n      fuel -= wasteFuel;\n      moved += km;\n      console.log(km + 'km 이동 (총 ' + moved + 'km). 남은 연료: ' + fuel);\n    },\n  };\n  Object.freeze(publicMembers);\n  return publicMembers;\n};\nvar car = createCar();\n```\n\n* [Object.freeze](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)를 사용하여 `publicMembers`객체를 동결객체로 만들었습니다.\n\n\n* `Object.freeze`메서드는 호출된 객체의 직속 속성만 동결하며 내부의 속성 값이 객체라면 그 객체는 동결되지 않아 추가/제거/재할당의 대상이 될 수 있으므로 (얕은동결) 주의하여야 합니다.\n\n------\n#### 클로저를 활용해 접근권한 제어 방법 정리\n\n1. 함수에서 지역변수 및 내부함수 등을 생성\n\n2. 외부에 접근권한을 주고자 하는 대상들로 구성된 참조형 데이터(대상이 여럿일 경우 객체 또는 배열, 하나일 경우 함수)를 return 합니다.\n\n3. return한 변수들은 공개 맴버가 되고, 그렇지 않은 변수들은 비공개 맴버가 됩니다.\n\n------\n### 부분 적용 함수\n\n부분 적용 함수(`partially applied function`)란 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가. 나중에 나머지 인자를 넘길 때 원래 함수의 실행 결과를 얻을 수 있게 하는 함수입니다.\n\n`this`를 바인딩해야 하는 점을 제외하면 `bind`메서드의 실행 결과가 바로 부분 적용 함수입니다.\n\n```js bind - 부분 적용 함수\nvar add = function() {\n  var result = 0;\n  for (var i = 0; i < arguments.length; i++) {\n    result += arguments[i];\n  }\n  return result;\n};\nvar addPartial = add.bind(null, 1, 2, 3, 4, 5);\nconsole.log(addPartial(6, 7, 8, 9, 10)); // 55\n```\n\n`addPartial` 함수에 `this`값 `null`과 인자 5개를 미리 적용하고, 대기합니다.\n추후에 추가적으로 인자들을 전달하며 호출하면 대기중이던 인자들과 차례대로 적용되어 실행합니다.\n\n`add`함수는 `this`값을 사용하지 않지만, `bind`메서드는 `this`값을 변경할 수 밖에 없기 때문에 `this`에 관여하지 않는 다른 방법의 부분 적용 함수가 필요합니다.\n\n// p 135 ~ 137 보류\n\n디바운스(`debounce`)는 짧은 시간 동안 동일한 이벤트가 많이 발생한 경우 이를 전부 처리하지 않고 처음 또는 마지막에 발생한 이벤트에 대해 한 번만 처리하는 것으로, `scroll`, `wheel`, `mousemove`, `resize`등에 적용하기 좋습니다.\n\n```js 부분 적용 함수 - 디바운스\nvar debounce = function(eventName, func, wait) {\n  var timeoutId = null;\n  return function(event) {\n    var self = this;\n    console.log(eventName, 'event 발생');\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(func.bind(self, event), wait);\n  };\n};\nvar moveHandler = function(e) {\n  console.log('move event 처리'); };\nvar wheelHandler = function(e) {\n  console.log('wheel event 처리'); };\n\ndocument.body.addEventListener(\n  'mousemove',\n  debounce('move', moveHandler, 500));\ndocument.body.addEventListener(\n  'mousewheel',\n  debounce('wheel', wheelHandler, 700));\n```\n\n* `debounce` 함수는 출력 용도로 지정한 `eventName`과 실행할 함수(`func`),마지막으로 발생한 이벤트인지 여부를 판단하기 위한 대기시간 (`wait(`(ms))을 받습니다.\n\n\n* 내부에서는 `timeoutId` 변수를 생성하고, 클로저로 `EventListener`에 의해 호출될 함수를 반환합니다. 반환될 함수 내부에서는 `setTimeout`을 사용하기 위해 `this`를 별도의 변수에 담고 `clearTimeout`으로 대기큐를 초기화하게 했습니다.\n\n\n* 마지막으로 `setTimeout`으로 `wait` 시간만큼 지연시킨 다음, 원래의 `func`를 호출하는 형태입니다.\n\n\n* 최초의 event가 발생하면 `timeoutId = setTimeout(func,bind(self,event),wait)`에 의해 timeout의 대기열에 'wait 시간 뒤에 func를 실행 함'이라는 내용이 담깁니다. 그런데 `wait`시간이 경과하기 전에 동일한 event가 발생하게 되면 앞의 `clearTimeout(timeoutId)`에 의해 앞에 저장했던 대기열을 초기화하고, 다시 `timeoutId = setTimeout(func,bind(self,event),wait)`에서 새로운 대기열을 등록합니다.\n\n\n* 결국 각 동일한 이벤트가 이전 이벤트로 부터 `wait`시간 내에 다시 발생하는 한 마지막에 발생한 이벤트만이 초기화되지 않고 실행됩니다.\n\n\n* `debounce`함수에서 클로저로 처리되는 변수는 `eventName`, `func`, `wait`, `timeoutId`입니다.\n\n-------\n### 커링 함수\n\n------\n<h2 id=\"closure\">정리</h2>\n\n* 클로저란 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상입니다.\n\n\n* 내부 함수를 외부로 전달하는 방법에는 함수를 return하는 경우뿐아니라 콜백으로 전달하는 경우도 포함됩니다.\n\n\n* 클로저는 그 본질이 메모리를 계속 차지하는 개념이므로 더는 사용하지 않게 된 클로저에 대해서는 메모리를 차지하지 않도록 관리해줄 필요가 있습니다.\n","source":"_posts/클로저-Core-JavaScript.md","raw":"---\ntitle: 클로저 -Core JavaScript\ndisqusId: tunas-blog-1\ntags:\n  - Core JavaScript\n  - JavaScript\ndate: 2020-05-03 15:56:17\ncategories: Core JavaScript\n---\n\n* 클로저 (Closure)\n  * [클로저의 의미 및 원리 이해](/2020/05/03/클로저-Core-JavaScript/#closure)\n  * [클로저와 메모리 관리](/2020/05/03/클로저-Core-JavaScript/#closure_memory)\n  * [클로저 활용 사례](/2020/05/03/클로저-Core-JavaScript/#closure_ex)\n    * 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때\n    * 접근 권한 제어 (정보 은닉)\n    * 부분 적용 함수\n    * 커링 함수\n  * [정리](/2020/05/03/클로저-Core-JavaScript/#)\n\n<!-- more -->\n\n------\n<h2 id=\"closure\">클로저의 의미 및 원리 이해</h2>\n\n클로저(`Closure`)는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성입니다.\n자바스크립트 고유의 개념이 아니라서 ECMAScript 명세에서도 클로저의 정의를 다루지 않고 있고, 다양한 문헌에서 제각각 클로저를 다르게 정의 또는 설명하고 있습니다.\n\n다양한 서적에서 클로저를 한 문장으로 요약해서 설명하는 부분들을 소개하면 다음과 같습니다.\n    * 자신을 내포하는 함수의 컨텍스트에 접근할 수 있는 함수\n    \n    * 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 것\n    \n    * 함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수\n    \n    * 이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수\n    \n    * 자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합\n    \n    * 로컬 변수를 참조하고 있는 함수 내의 함수\n    \n    * 자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수\n\n\n**MDN** 에서는 클로저를 함수와 그 함수가 선언될 당시의 `LexicalEnvironment`의 조합이라고 소개하고,\n다른 말로 클로저는 내부 함수에서 외부 함수의 범위로 접근할 수 있게 해주는 함수라고 합니다.\n\n\n선언될 당시의 `LexicalEnvironment`는 실행 컨텍스트의 구성 요소 중 하나인 `outerEnvironmentReference`에 해당합니다. \n`LexicalEnvironment`의 `environmentRecord`와 `outerEnvironmentReference`에 의해 변수의 유효범위인 스코프가 결정되고 스코프 체인이 가능해집니다.\n\n\n* `컨텍스트 A`에서 선언한 `내부 함수B`의 실행 컨텍스트가 활성화된 시점에서는 B의 `outerEnvironmentReference`가 참조하는 대상인 A의 `LexicalEnvironment`에도 접근이 가능해 집니다. A에서는 B에서 선언한 변수에 접근할 수 없지만 B에서는 A에 선언한 변수에 접근이 가능해집니다.\n\n\n* 이런 내부함수에서 외부 변수를 참조하게 되는 경우가, 선언될 당시의 `LexicalEnvironment`와의 상호관계(조합)의 의미가 됩니다.\n\n```js 외부 함수의 변수를 참조하는 내부 함수 -1\nvar outer = function() {\n  var a = 1;\n  var inner = function() {\n    console.log(++a);\n  };\n  inner();\n};\nouter();\n```\n\n1. `outer` 함수에 변수 a를 선언했고 1을 할당했습니다.\n\n\n2. `outer`의 내부함수인 `inner` 함수에서 a의 값을 1 증가시키고 출력합니다.\n\n\n* `inner`함수 내부에서는 a를 선언하지 않았기 때문에 `environmentRecord`에서 값을 찾지 못하므로 `outerEnvironmentReference`에 지정된 상위 컨텍스트인 `outer`의 `LexicalEnvironment`에 접근하여 다시 a를 찾습니다.\n\n\n* `outer` 함수의 실행 컨텍스트가 종료되면 `LexicalEnvironment`에 저장된 식별자들(a,inner)에 대한 참조를 지웁니다. 그러면 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 `가비지컬렉터(GC)`의 수집 대상이 됩니다.\n\n```js 외부 함수의 변수를 참조하는 내부 함수 -2\nvar outer = function() {\n  var a = 1;\n  var inner = function() {\n    return ++a;\n  };\n  return inner();\n};\nvar outer2 = outer();\nconsole.log(outer2); // 2\n```\n\n* 이 예제 역시 `inner`함수 내부에서 외부변수인 a를 사용했습니다.\n`inner` 함수를 실행한 결과를 `return` 하고 나면 `outer`함수의 실행 컨텍스트가 종료된 시점에는 a변수를 참조하는 대상이 없어집니다. 그러므로 예제1과 마찬가지로 식별자들의(a,inner) 값들은 `가비지컬렉터(GC)`에 의해 소멸됩니다.\n\n\n* 예제1과 예제2는 `outer`함수의 실행 컨텍스트가 종료되기 이전에 `inner` 함수의 실행 컨텍스트가 종료돼 있으며, 이후 별도로 `inner` 함수를 호출할 수 없다는 공통점을 가지고 있습니다.\n\n<mark>그렇다면 outer의 실행 컨텍스트가 종료된 후에도 inner 함수를 호출할 수 있게 만들면 어떨까요?</mark>\n\n```js 외부 함수의 변수를 참조하는 내부 함수 -3\nvar outer = function() {\n  var a = 1;\n  var inner = function() {\n    return ++a;\n  };\n  return inner;\n};\nvar outer2 = outer();\nconsole.log(outer2()); // 2\nconsole.log(outer2()); // 3\n```\n\n1. `return inner()` 함수의 실행 결과가 아닌 `return inner` 함수 자체를 반환했습니다.\n\n\n2. `outer2` 변수는 `outer`함수의 실행 결과인 `inner`함수 자체를 참조하게 됩니다.\n`outer2` 호출시 `inner` 함수가 실행됨.\n\n\n3. `inner` 함수의 실행 컨텍스트의 `environmentRecord`에는 수집할 정보가 없습니다. `outerEnvironmentReference`에는 `inner` 함수가 선언된 위치의 `LexicalEnvironment`가 참조복사 됩니다. `inner`함수는 `outer` 함수 내부에서 선언됐으므로, `outer` 함수의 `LexicalEnvironment`가 담깁니다.\n\n\n4. 스코프체이닝에 따라 `outer`에서 선언한 변수 a에 접근해 1만큼 증가시킨후 결과 값인 2를 반환하고, `inner`함수의 실행 컨텍스트가 종료됩니다.\n\n\n5. `outer2`<u>를 다시 호출하면 같은 방식으로 a의 값을 2에서 1만큼 증가시켜 그 결과 값인 3을 반환합니다.</u>\n \n\n**중요 포인트**\n\n* `outer`함수의 실행 컨텍스트는 종료된 상태인데 어떻게 외부 함수의 변수(`outer` 함수의 `LexicalEnvironment`)에 접근할 수 있는 걸까?\n\n\n* 이는 가비지컬렉터의 동작 방식 때문입니다.\n\n\n* <mark>어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 가비지컬렉터(GC)의 대상이 되지 않습니다.</mark>\n\n\n* `outer` 함수는 실행 종료 시점에 `inner` 함수를 반환했습니다. `outer` 함수는 `inner`함수를 참조하게 되고 외부함수인 `outer`의 실행이 종료되었지만 내부함수인 `inner`함수는 언젠가 `outer()`형식 (변수 outer2와 같은)으로 호출될 수 있습니다.\n\n\n* `inner` 함수 역시 `outer`의 변수를 참조하므로 실행 컨텍스트가 활성화 되면 `outerEnvironmentReference`가 `outer` 함수의 `LexicalEnvironment`를 필요로 하게되므로 `가비지컬렉터(GC)`의 대상에서 제외됩니다. 그 덕에 `inner`함수가 외부함수의 변수에 접근할 수 있는 것입니다.\n\n\n* 클로저란 :\n  <mark>외부 함수에서 선언한 변수를 참조하는 내부 함수를 외부로 전달할 경우 외부 함수의 실행 컨텍스트가 종료된 이후에도 변수가 사라지지 않는 현상</mark>\n\n\n* \"내부함수를 외부로 전달\"이 return만을 의미하는 것은 아님. 다른 경우도 존재\n\n```js return 없이 클로저가 발생하는 경우\n// (1) setInterval/setTimeout\n(function() {\n  var a = 0; // 외부 함수의 변수를 내부 함수에서\n  var intervalId = null; // 참조하고 있으므로 GC의 대상이 되지 않음. \n  var inner = function() {\n    if (++a >= 10) { // 외부 함수의 변수a 참조\n      clearInterval(intervalId); // 외부 함수의 변수 intervalId 참조\n    }\n    console.log(a);\n  };\n  intervalId = setInterval(inner, 1000);\n})();\n```\n\n별도의 외부객체인 window의 메서드(setTimeout 또는 setInterval)에 전달할 콜백 함수 내부에서 지역변수를 참조합니다.\n\n```js return 없이 클로저가 발생하는 경우\n// (2) eventListener\n(function() {\n  var count = 0;\n  var button = document.createElement('button');\n  button.innerText = 'click';\n  button.addEventListener('click', function() {\n    console.log(++count, 'times clicked');\n  });\n  document.body.appendChild(button);\n})();\n```\n\n별도의 외부 객체인 DOM의 메서드 (addEventListener)에 등록할 handler 함수 내부에서 지역변수를 참조합니다.\n\n<mark>두 상황 모두 두 지역변수를 참조하는 내부함수를 외부에 전달했기 때문에 클로저(closure)입니다.</mark>\n\n------\n<h2 id=\"closure_memory\">클로저와 메모리 관리</h2>\n\n* <mark>클로저는 객체지향과 함수형 모두를 아우르는 매우 중요한 개념입니다.</mark>\n\n* 메모리 누수:\n개발자의 의도와 달리 어떤 값의 참조 카운트가 0이 되지 않아 GC의 수거 대상이 되지 않는 경우 발생할 수 있습니다.\n(개발자가 의도적으로 참조 카운트가 0이 되지 않게 설계한 경우는 '누수'라는 표현은 맞지 않습니다.)\n\n* <mark>클로저는 의도대로 설계한 \"메모리 소모\"에 대한 관리법을 잘 파악해서 적용하는 것이 중요합니다.</mark>\n\n------\n### 메모리 관리 방법\n\n클로저는 필요에 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생합니다.\n그렇다면 <u>필요성이 사라진 시점</u>에는 더는 메모리를 소모하지 않게 해주면 됩니다.\n\n참조 카운트를 0으로 만들면(GC의 작동원리) GC가 수거해 갈것이고, 이때 소모됐던 메모리가 회수됩니다.\n\n* 참조 카운트를 0으로 만드는 방법 ?\n식별자에 참조형이 아닌 기본형 데이터(보통 `null`이나 `undefined`)를 할당하면 됩니다.\n\n```js 클로저의 메모리 관리 - return\n// (1) return에 의한 클로저의 메모리 해제\nvar outer = (function() {\n  var a = 1;\n  var inner = function() {\n    return ++a;\n  };\n  return inner;\n})();\nconsole.log(outer());\nconsole.log(outer());\nouter = null; // outer 식별자의 inner 함수 참조를 끊음\n```\n\n```js 클로저의 메모리 관리 - setInterval\n// (2) setInterval에 의한 클로저의 메모리 해제\n(function() {\n  var a = 0;\n  var intervalId = null;\n  var inner = function() {\n    if (++a >= 10) {\n      clearInterval(intervalId);\n      inner = null; // inner 식별자의 함수 참조를 끊음\n    }\n    console.log(a);\n  };\n  intervalId = setInterval(inner, 1000);\n})();\n```\n\n```js 클로저의 메모리 관리 - eventListener\n// (3) eventListener에 의한 클로저의 메모리 해제\n(function() {\n  var count = 0;\n  var button = document.createElement('button');\n  button.innerText = 'click';\n\n  var clickHandler = function() {\n    console.log(++count, 'times clicked');\n    if (count >= 10) {\n      button.removeEventListener('click', clickHandler);\n      clickHandler = null; // clickHandler 식별자의 함수 참조를 끊음\n    }\n  };\n  button.addEventListener('click', clickHandler);\n  document.body.appendChild(button);\n})();\n```\n\n------\n<h2 id=\"closure_ex\">클로저 활용 사례</h2>\n\n클로저가 실제로 등장하는 활용 사례\n\n### 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때\n\n대표적인 콜백 함수 중 하나인 이벤트 리스너에 관한 예시\n\n```js\nvar fruits = ['apple', 'banana', 'peach'];\nvar $ul = document.createElement('ul'); // (공통 코드)\n\nfruits.forEach(function(fruit) {\n  // (A)\n  var $li = document.createElement('li');\n  $li.innerText = fruit;\n  $li.addEventListener('click', function() {\n    // (B)\n    alert('your choice is ' + fruit);\n  });\n  $ul.appendChild($li);\n});\ndocument.body.appendChild($ul);\n```\n\n1. `fruits` 변수를 순회하며 `li`를 생성하고 각 `li`를 클릭하면 해당 리스너의 콜백 함수가 실행됩니다.\n\n\n2. `forEach`메서드에 넘겨준 익명의 콜백 함수(A)는 내부에서 외부 변수를 사용하지 않으므로 클로저가 없습니다.\n\n\n3. `addEventListener`에 넘겨준 콜백 함수(B)에는 함수내의 `fruit`라는 외부 변수를 참조하고 있으므로 클로저가 있습니다.\n\n\n4. (A)는 `fruits`의 개수만큼 실행되며, 그때마다 새로운 실행 컨텍스트가 생성됩니다.\n\n\n5. (A)의 실행 종료 여부와 무관하게 클릭 이벤트에 의해 각 컨텍스트의 (B)가 실행될 때는 (B)의 `outerEnvironmentReference`가 (A)의 `LexicalEnvironment`를 참조하게 됩니다.\n\n\n6. 따라서 (B)함수가 참조할 예정인 변수 `fruit`에 대해서는 (A)함수가 종료된 후에도 `CG` 대상에서 제외되어 계속 참조 가능하게 됩니다.\n\n그런데 (B)함수의 쓰임이 콜백 함수에 국한되지 않는 경우라면 반복을 줄이기 위해 (B)함수를 외부로 분리하는 편이 나을 수 있습니다.\n\n따라서 다음은 `fruit`을 인자로 받아 출력하는 형태입니다.\n\n```js 콜백 함수 외부로꺼내어 공통 함수로 사용\nvar fruits = ['apple', 'banana', 'peach'];\nvar $ul = document.createElement('ul');\n\nvar alertFruit = function(fruit) {\n  alert('your choice is ' + fruit);\n};\nfruits.forEach(function(fruit) {\n  var $li = document.createElement('li');\n  $li.innerText = fruit;\n  $li.addEventListener('click', alertFruit);\n  $ul.appendChild($li);\n});\ndocument.body.appendChild($ul);\nalertFruit(fruits[1]);\n```\n\n* 공통 함수로 사용하고자 콜백 함수를 외부로 꺼내어 `alertFruit`라는 변수에 담았습니다.\n`alertFruit`를 직접 실행할 수 있게 되었습니다.\n\n* 하지만 각 `li`를 클릭하면 클릭한 대상의 과일명이 아닌 `[object MouseEvent]`라는 값이 출력됩니다.\n이는 콜백 함수의 인자에 대한 제어권을 `addEventListener`가 가진 상태이며, `addEventListener`는 콜백 함수를 호출할 때 첫 번째 인자에 \"이벤트 객체\"를 주입하기 때문입니다.\n\n이 문제는 `bind`메서드를 활용하면 해결할 수 있습니다.\n\n```js bind 메서드 사용\nvar fruits = ['apple', 'banana', 'peach'];\nvar $ul = document.createElement('ul');\n\nvar alertFruit = function(fruit) {\n  alert('your choice is ' + fruit);\n};\nfruits.forEach(function(fruit) {\n  var $li = document.createElement('li');\n  $li.innerText = fruit;\n  $li.addEventListener('click', alertFruit.bind(null, fruit));\n  $ul.appendChild($li);\n});\ndocument.body.appendChild($ul);\n```\n\n* 하지만 `bind`를 활용하면 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점과,\n함수 내부에서 `this`가 참조하는 값이 달라지는점을 감안해야 합니다.\n\n* 이러한 변경사항 마저 발생하지 않게 만들려면 `bind`메서드가 아닌 다른 방식으로 만들어야 합니다.\n\n```js 고차함수를 사용하여 클로저를 적극적으로 활용\nvar fruits = ['apple', 'banana', 'peach'];\nvar $ul = document.createElement('ul');\n\nvar alertFruitBuilder = function(fruit) {\n  return function() {\n    alert('your choice is ' + fruit);\n  };\n};\nfruits.forEach(function(fruit) {\n  var $li = document.createElement('li');\n  $li.innerText = fruit;\n  $li.addEventListener('click', alertFruitBuilder(fruit));\n  $ul.appendChild($li);\n});\ndocument.body.appendChild($ul);\n```\n\n* 고차함수란 함수를 인자로 받거나 함수를 리턴하는 함수입니다.\n\n1. `alertFruit` 함수 대신 `alertFruitBuilder`라는 이름의 함수를 작성했습니다.\n`alertFruitBuilder` 함수 내부에서는 다시 익명함수를 반환합니다.\n\n\n2. 이 익명함수 내부의 코드가 기존의 `alertFruit` 함수의 코드입니다. \n\n\n3. `alertFruitBuilder` 함수를 실행하면서 `fruit` 값을 인자로 전달하면, 함수의 실행 결과가\n다시 함수(`return function`)가 되며, 이렇게 반환된 함수를 리스너의 콜백 함수로써 전달할 것입니다.\n\n\n4. 클릭 이벤트가 발생하면 이 함수의 실행 컨텍스트가 열리면서 `alertFruitBuilder`의 파라미터로 넘어온 `fruit`를 `outerEnvironmentReference`에 의해 참조할 수 있게됩니다. \n즉, `alertFruitBuilder`의 실행 결과로 반환된 함수에는 클로저가 존재합니다.\n\n------\n#### 콜백 함수 내부에서 외부변수를 참조하기 위한 방법 정리.\n\n1. 콜백 함수를 내부함수로 선언하여 외부변수를 직접 참조하는 방법.(`GC의 참조카운트` 이용)\n\n\n2. `bind`메서드를 활용하여 값을 직접넘겨주는 방법. 클로저는 발생하지 않지만 몇가지 제약이 생김\n\n\n3. 콜백 함수를 고차함수로 바꿔서 클로저를 적극적으로 활용하는 방법. \n\n------\n### 접근 권한 제어(은닉)\n\n정보은닉(information hiding)은 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈간의 결합도를 낮추고 유연성을 높이고자 하는 현대 프로그래밍 언어의 중요한 개념 중 하나입니다.\n\n흔히 접근 권한에는 `public`, `private`, `protected` 세 종류가 있습니다.\n\n* `public` : 외부에서 접근 가능한 것\n\n* `private` : 내부에서만 사용하며 외부에 노출되지 않는 것\n\n자바스크립트는 기본적으로 변수 자체에 이러한 접근 권한을 직접 부여하도록 설계돼 있지 않습니다. 하지만 접근 권한 제어가 불가능한 것은 아닙니다. 클로저를 이용하면 함수 차원에서 `public`한 값과 `private`한 값을 구분하는 것이 가능합니다.\n\n```js public/private -return\nvar outer = function() {\n  var a = 1;\n  var inner = function() {\n    return ++a;\n  };\n  return inner;\n};\nvar outer2 = outer();\nconsole.log(outer2());\nconsole.log(outer2());\n```\n\n이전에 본 클로저 예제 입니다.\n\n* `outer`함수를 종료할 때 `inner` 함수를 반환함으로써 `outer`함수의 지역변수 a의 값을 외부에서도 읽을 수 있게 되었습니다.\n\n\n* 이처럼 클로저를 활용하면 외부 스코프에서 함수 내부의 변수들 중 선택적으로 일부 변수에 대한 접근 권환을 부여할 수 있습니다. (`return`을 활용하여)\n\n\n* `outer`함수는 외부(전역 스코프)로 부터 철저하게 격리된 닫힌 공간입니다.\n외부에서는 외부 공간에 노출돼 있는 `outer`라는 변수를 통해 `outer`함수를 실행할 수는 있지만, `outer`함수 내부에는 어떠한 개입도 할 수 없습니다. \n외부에는 오직 `outer`함수가 `return`한 정보에만 접근할 수 있습니다.\n`return`값이 외부에 정보를 제공하는 유일한 수단이 됩니다.\n\n\n* 외부에 제공하고자 하는 정보들을 모아서 `return`하고, 내부에서만 사용할 정보들은 `return`하지 않는 것으로 접근 권한 제어가 가능한 것입니다.\n\n\n* `return`한 변수들은 공개 맴버(`public member`)가 되고, 그렇지 않은 변수들은 비공개 맴버(`private member`)가 되는 것입니다.\n\n\n------\n#### 접근 권한 제어를 통한 보드 게임 예시\n\n자동차 경주 보드 게임.\n\n규칙\n\n    1. 각 턴마다 주사위를 굴려 나온 숫자(km)만큼 이동.\n    \n    2. 차량별로 연료량(fuel)과 연비(power)는 무작위로 생성.\n    \n    3. 남은 연료가 이동할 거리에 필요한 연료보다 부족하면 이동 불가.\n    \n    4. 모든 유저가 이동할 수 없는 턴에 게임이 종료됨.\n    \n    5. 게임 종료 시 가장 멀리 이동해 있는 사람이 승리.\n\n```js 규칙에 따른 간단한 자동차 객체\nvar car = {\n  fuel: Math.ceil(Math.random() * 10 + 10), // 연료(L)\n  power: Math.ceil(Math.random() * 3 + 2), // 연비(km/L)\n  moved: 0, // 총 이동거리\n  run: function() {\n    var km = Math.ceil(Math.random() * 6);\n    var wasteFuel = km / this.power;\n    if (this.fuel < wasteFuel) {\n      console.log('이동불가');\n      return;\n    }\n    this.fuel -= wasteFuel;\n    this.moved += km;\n    console.log(km + 'km 이동 (총 ' + this.moved + 'km)');\n  },\n};\n```\n\n위 코드는 `run` 메서드를 실행할 때마다 `car`객체의 `fuel`, `moved` 값이 변합니다.\n\n하지만 자바스크립트를 아는사람이 `car`객체의 `fuel`, `power`, `moved`값을 직접 지정해 버린다면 공평한 게임이 되지 못합니다. \n* 이렇게 값을 바꾸지 못하도록 객체가 아닌 함수로 만들고, 필요한 맴버만을 `return`할 필요가 있습니다.\n\n```js 함수를 실행함으로써 객체 생성\nvar createCar = function() {\n  var fuel = Math.ceil(Math.random() * 10 + 10); // 연료(L)\n  var power = Math.ceil(Math.random() * 3 + 2); // 연비(km / L)\n  var moved = 0; // 총 이동거리\n  return {\n    get moved() {\n      return moved;\n    },\n    run: function() {\n      var km = Math.ceil(Math.random() * 6);\n      var wasteFuel = km / power;\n      if (fuel < wasteFuel) {\n        console.log('이동불가');\n        return;\n      }\n      fuel -= wasteFuel;\n      moved += km;\n      console.log(km + 'km 이동 (총 ' + moved + 'km). 남은 연료: ' + fuel);\n    },\n  };\n};\nvar car = createCar();\n```\n\n* `createCar`라는 함수를 실행함으로써 객체를 생성하게 했습니다. `fuel`, `power` 변수는 비공개 맴버로 지정해 외부에서의 접근을 제한했고, `moved`변수는 `getter`만을 부여함으로써 \"읽기전용\" 속성을 부여했습니다.\n\n* 이제 외부에서는 오직 `run`메서드를 실행하는 것과 현재의 `moved`값을 확인하는 두 가지 동작만 할 수 있습니다.\n\n* `run`메서드를 다른 내용으로 덮어씌우는 어뷰징은 여전히 가능한 상태이긴 하지만 앞서의 코드보다 훨씬 안전한 코드가 됐습니다. 이런 어뷰징까지 막기 위해서는 객체를 `return`하기 전에 미리 변경할 수 없게끔 조치를 취해야 합니다.\n\n```js Object.freeze\nvar createCar = function() {\n  var fuel = Math.ceil(Math.random() * 10 + 10); // 연료(L)\n  var power = Math.ceil(Math.random() * 3 + 2); // 연비(km / L)\n  var moved = 0; // 총 이동거리\n  var publicMembers = {\n    get moved() {\n      return moved;\n    },\n    run: function() {\n      var km = Math.ceil(Math.random() * 6);\n      var wasteFuel = km / power;\n      if (fuel < wasteFuel) {\n        console.log('이동불가');\n        return;\n      }\n      fuel -= wasteFuel;\n      moved += km;\n      console.log(km + 'km 이동 (총 ' + moved + 'km). 남은 연료: ' + fuel);\n    },\n  };\n  Object.freeze(publicMembers);\n  return publicMembers;\n};\nvar car = createCar();\n```\n\n* [Object.freeze](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)를 사용하여 `publicMembers`객체를 동결객체로 만들었습니다.\n\n\n* `Object.freeze`메서드는 호출된 객체의 직속 속성만 동결하며 내부의 속성 값이 객체라면 그 객체는 동결되지 않아 추가/제거/재할당의 대상이 될 수 있으므로 (얕은동결) 주의하여야 합니다.\n\n------\n#### 클로저를 활용해 접근권한 제어 방법 정리\n\n1. 함수에서 지역변수 및 내부함수 등을 생성\n\n2. 외부에 접근권한을 주고자 하는 대상들로 구성된 참조형 데이터(대상이 여럿일 경우 객체 또는 배열, 하나일 경우 함수)를 return 합니다.\n\n3. return한 변수들은 공개 맴버가 되고, 그렇지 않은 변수들은 비공개 맴버가 됩니다.\n\n------\n### 부분 적용 함수\n\n부분 적용 함수(`partially applied function`)란 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가. 나중에 나머지 인자를 넘길 때 원래 함수의 실행 결과를 얻을 수 있게 하는 함수입니다.\n\n`this`를 바인딩해야 하는 점을 제외하면 `bind`메서드의 실행 결과가 바로 부분 적용 함수입니다.\n\n```js bind - 부분 적용 함수\nvar add = function() {\n  var result = 0;\n  for (var i = 0; i < arguments.length; i++) {\n    result += arguments[i];\n  }\n  return result;\n};\nvar addPartial = add.bind(null, 1, 2, 3, 4, 5);\nconsole.log(addPartial(6, 7, 8, 9, 10)); // 55\n```\n\n`addPartial` 함수에 `this`값 `null`과 인자 5개를 미리 적용하고, 대기합니다.\n추후에 추가적으로 인자들을 전달하며 호출하면 대기중이던 인자들과 차례대로 적용되어 실행합니다.\n\n`add`함수는 `this`값을 사용하지 않지만, `bind`메서드는 `this`값을 변경할 수 밖에 없기 때문에 `this`에 관여하지 않는 다른 방법의 부분 적용 함수가 필요합니다.\n\n// p 135 ~ 137 보류\n\n디바운스(`debounce`)는 짧은 시간 동안 동일한 이벤트가 많이 발생한 경우 이를 전부 처리하지 않고 처음 또는 마지막에 발생한 이벤트에 대해 한 번만 처리하는 것으로, `scroll`, `wheel`, `mousemove`, `resize`등에 적용하기 좋습니다.\n\n```js 부분 적용 함수 - 디바운스\nvar debounce = function(eventName, func, wait) {\n  var timeoutId = null;\n  return function(event) {\n    var self = this;\n    console.log(eventName, 'event 발생');\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(func.bind(self, event), wait);\n  };\n};\nvar moveHandler = function(e) {\n  console.log('move event 처리'); };\nvar wheelHandler = function(e) {\n  console.log('wheel event 처리'); };\n\ndocument.body.addEventListener(\n  'mousemove',\n  debounce('move', moveHandler, 500));\ndocument.body.addEventListener(\n  'mousewheel',\n  debounce('wheel', wheelHandler, 700));\n```\n\n* `debounce` 함수는 출력 용도로 지정한 `eventName`과 실행할 함수(`func`),마지막으로 발생한 이벤트인지 여부를 판단하기 위한 대기시간 (`wait(`(ms))을 받습니다.\n\n\n* 내부에서는 `timeoutId` 변수를 생성하고, 클로저로 `EventListener`에 의해 호출될 함수를 반환합니다. 반환될 함수 내부에서는 `setTimeout`을 사용하기 위해 `this`를 별도의 변수에 담고 `clearTimeout`으로 대기큐를 초기화하게 했습니다.\n\n\n* 마지막으로 `setTimeout`으로 `wait` 시간만큼 지연시킨 다음, 원래의 `func`를 호출하는 형태입니다.\n\n\n* 최초의 event가 발생하면 `timeoutId = setTimeout(func,bind(self,event),wait)`에 의해 timeout의 대기열에 'wait 시간 뒤에 func를 실행 함'이라는 내용이 담깁니다. 그런데 `wait`시간이 경과하기 전에 동일한 event가 발생하게 되면 앞의 `clearTimeout(timeoutId)`에 의해 앞에 저장했던 대기열을 초기화하고, 다시 `timeoutId = setTimeout(func,bind(self,event),wait)`에서 새로운 대기열을 등록합니다.\n\n\n* 결국 각 동일한 이벤트가 이전 이벤트로 부터 `wait`시간 내에 다시 발생하는 한 마지막에 발생한 이벤트만이 초기화되지 않고 실행됩니다.\n\n\n* `debounce`함수에서 클로저로 처리되는 변수는 `eventName`, `func`, `wait`, `timeoutId`입니다.\n\n-------\n### 커링 함수\n\n------\n<h2 id=\"closure\">정리</h2>\n\n* 클로저란 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상입니다.\n\n\n* 내부 함수를 외부로 전달하는 방법에는 함수를 return하는 경우뿐아니라 콜백으로 전달하는 경우도 포함됩니다.\n\n\n* 클로저는 그 본질이 메모리를 계속 차지하는 개념이므로 더는 사용하지 않게 된 클로저에 대해서는 메모리를 차지하지 않도록 관리해줄 필요가 있습니다.\n","slug":"클로저-Core-JavaScript","published":1,"updated":"2020-05-04T13:40:42.819Z","_id":"ck9qpo7wd0000mkvq8i70awvc","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>클로저 (Closure)<ul>\n<li><a href=\"/2020/05/03/클로저-Core-JavaScript/#closure\">클로저의 의미 및 원리 이해</a></li>\n<li><a href=\"/2020/05/03/클로저-Core-JavaScript/#closure_memory\">클로저와 메모리 관리</a></li>\n<li><a href=\"/2020/05/03/클로저-Core-JavaScript/#closure_ex\">클로저 활용 사례</a><ul>\n<li>콜백 함수 내부에서 외부 데이터를 사용하고자 할 때</li>\n<li>접근 권한 제어 (정보 은닉)</li>\n<li>부분 적용 함수</li>\n<li>커링 함수</li>\n</ul>\n</li>\n<li><a href=\"/2020/05/03/클로저-Core-JavaScript/#\">정리</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"closure\">클로저의 의미 및 원리 이해</h2>\n\n<p>클로저(<code>Closure</code>)는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성입니다.<br>자바스크립트 고유의 개념이 아니라서 ECMAScript 명세에서도 클로저의 정의를 다루지 않고 있고, 다양한 문헌에서 제각각 클로저를 다르게 정의 또는 설명하고 있습니다.</p>\n<p>다양한 서적에서 클로저를 한 문장으로 요약해서 설명하는 부분들을 소개하면 다음과 같습니다.<br>    * 자신을 내포하는 함수의 컨텍스트에 접근할 수 있는 함수</p>\n<pre><code>* 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 것\n\n* 함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수\n\n* 이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수\n\n* 자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합\n\n* 로컬 변수를 참조하고 있는 함수 내의 함수\n\n* 자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수</code></pre><p><strong>MDN</strong> 에서는 클로저를 함수와 그 함수가 선언될 당시의 <code>LexicalEnvironment</code>의 조합이라고 소개하고,<br>다른 말로 클로저는 내부 함수에서 외부 함수의 범위로 접근할 수 있게 해주는 함수라고 합니다.</p>\n<p>선언될 당시의 <code>LexicalEnvironment</code>는 실행 컨텍스트의 구성 요소 중 하나인 <code>outerEnvironmentReference</code>에 해당합니다.<br><code>LexicalEnvironment</code>의 <code>environmentRecord</code>와 <code>outerEnvironmentReference</code>에 의해 변수의 유효범위인 스코프가 결정되고 스코프 체인이 가능해집니다.</p>\n<ul>\n<li><code>컨텍스트 A</code>에서 선언한 <code>내부 함수B</code>의 실행 컨텍스트가 활성화된 시점에서는 B의 <code>outerEnvironmentReference</code>가 참조하는 대상인 A의 <code>LexicalEnvironment</code>에도 접근이 가능해 집니다. A에서는 B에서 선언한 변수에 접근할 수 없지만 B에서는 A에 선언한 변수에 접근이 가능해집니다.</li>\n</ul>\n<ul>\n<li>이런 내부함수에서 외부 변수를 참조하게 되는 경우가, 선언될 당시의 <code>LexicalEnvironment</code>와의 상호관계(조합)의 의미가 됩니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>외부 함수의 변수를 참조하는 내부 함수 -1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(++a);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  inner();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">outer();</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>outer</code> 함수에 변수 a를 선언했고 1을 할당했습니다.</li>\n</ol>\n<ol start=\"2\">\n<li><code>outer</code>의 내부함수인 <code>inner</code> 함수에서 a의 값을 1 증가시키고 출력합니다.</li>\n</ol>\n<ul>\n<li><code>inner</code>함수 내부에서는 a를 선언하지 않았기 때문에 <code>environmentRecord</code>에서 값을 찾지 못하므로 <code>outerEnvironmentReference</code>에 지정된 상위 컨텍스트인 <code>outer</code>의 <code>LexicalEnvironment</code>에 접근하여 다시 a를 찾습니다.</li>\n</ul>\n<ul>\n<li><code>outer</code> 함수의 실행 컨텍스트가 종료되면 <code>LexicalEnvironment</code>에 저장된 식별자들(a,inner)에 대한 참조를 지웁니다. 그러면 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 <code>가비지컬렉터(GC)</code>의 수집 대상이 됩니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>외부 함수의 변수를 참조하는 내부 함수 -2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ++a;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> inner();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> outer2 = outer();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outer2); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>이 예제 역시 <code>inner</code>함수 내부에서 외부변수인 a를 사용했습니다.<br><code>inner</code> 함수를 실행한 결과를 <code>return</code> 하고 나면 <code>outer</code>함수의 실행 컨텍스트가 종료된 시점에는 a변수를 참조하는 대상이 없어집니다. 그러므로 예제1과 마찬가지로 식별자들의(a,inner) 값들은 <code>가비지컬렉터(GC)</code>에 의해 소멸됩니다.</li>\n</ul>\n<ul>\n<li>예제1과 예제2는 <code>outer</code>함수의 실행 컨텍스트가 종료되기 이전에 <code>inner</code> 함수의 실행 컨텍스트가 종료돼 있으며, 이후 별도로 <code>inner</code> 함수를 호출할 수 없다는 공통점을 가지고 있습니다.</li>\n</ul>\n<p><mark>그렇다면 outer의 실행 컨텍스트가 종료된 후에도 inner 함수를 호출할 수 있게 만들면 어떨까요?</mark></p>\n<figure class=\"highlight js\"><figcaption><span>외부 함수의 변수를 참조하는 내부 함수 -3</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ++a;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> inner;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> outer2 = outer();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outer2()); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outer2()); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>return inner()</code> 함수의 실행 결과가 아닌 <code>return inner</code> 함수 자체를 반환했습니다.</li>\n</ol>\n<ol start=\"2\">\n<li><code>outer2</code> 변수는 <code>outer</code>함수의 실행 결과인 <code>inner</code>함수 자체를 참조하게 됩니다.<br><code>outer2</code> 호출시 <code>inner</code> 함수가 실행됨.</li>\n</ol>\n<ol start=\"3\">\n<li><code>inner</code> 함수의 실행 컨텍스트의 <code>environmentRecord</code>에는 수집할 정보가 없습니다. <code>outerEnvironmentReference</code>에는 <code>inner</code> 함수가 선언된 위치의 <code>LexicalEnvironment</code>가 참조복사 됩니다. <code>inner</code>함수는 <code>outer</code> 함수 내부에서 선언됐으므로, <code>outer</code> 함수의 <code>LexicalEnvironment</code>가 담깁니다.</li>\n</ol>\n<ol start=\"4\">\n<li>스코프체이닝에 따라 <code>outer</code>에서 선언한 변수 a에 접근해 1만큼 증가시킨후 결과 값인 2를 반환하고, <code>inner</code>함수의 실행 컨텍스트가 종료됩니다.</li>\n</ol>\n<ol start=\"5\">\n<li><code>outer2</code><u>를 다시 호출하면 같은 방식으로 a의 값을 2에서 1만큼 증가시켜 그 결과 값인 3을 반환합니다.</u></li>\n</ol>\n<p><strong>중요 포인트</strong></p>\n<ul>\n<li><code>outer</code>함수의 실행 컨텍스트는 종료된 상태인데 어떻게 외부 함수의 변수(<code>outer</code> 함수의 <code>LexicalEnvironment</code>)에 접근할 수 있는 걸까?</li>\n</ul>\n<ul>\n<li>이는 가비지컬렉터의 동작 방식 때문입니다.</li>\n</ul>\n<ul>\n<li><mark>어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 가비지컬렉터(GC)의 대상이 되지 않습니다.</mark></li>\n</ul>\n<ul>\n<li><code>outer</code> 함수는 실행 종료 시점에 <code>inner</code> 함수를 반환했습니다. <code>outer</code> 함수는 <code>inner</code>함수를 참조하게 되고 외부함수인 <code>outer</code>의 실행이 종료되었지만 내부함수인 <code>inner</code>함수는 언젠가 <code>outer()</code>형식 (변수 outer2와 같은)으로 호출될 수 있습니다.</li>\n</ul>\n<ul>\n<li><code>inner</code> 함수 역시 <code>outer</code>의 변수를 참조하므로 실행 컨텍스트가 활성화 되면 <code>outerEnvironmentReference</code>가 <code>outer</code> 함수의 <code>LexicalEnvironment</code>를 필요로 하게되므로 <code>가비지컬렉터(GC)</code>의 대상에서 제외됩니다. 그 덕에 <code>inner</code>함수가 외부함수의 변수에 접근할 수 있는 것입니다.</li>\n</ul>\n<ul>\n<li>클로저란 :<br><mark>외부 함수에서 선언한 변수를 참조하는 내부 함수를 외부로 전달할 경우 외부 함수의 실행 컨텍스트가 종료된 이후에도 변수가 사라지지 않는 현상</mark></li>\n</ul>\n<ul>\n<li>“내부함수를 외부로 전달”이 return만을 의미하는 것은 아님. 다른 경우도 존재</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>return 없이 클로저가 발생하는 경우</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1) setInterval/setTimeout</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">0</span>; <span class=\"comment\">// 외부 함수의 변수를 내부 함수에서</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> intervalId = <span class=\"literal\">null</span>; <span class=\"comment\">// 참조하고 있으므로 GC의 대상이 되지 않음. </span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++a &gt;= <span class=\"number\">10</span>) &#123; <span class=\"comment\">// 외부 함수의 변수a 참조</span></span><br><span class=\"line\">      clearInterval(intervalId); <span class=\"comment\">// 외부 함수의 변수 intervalId 참조</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  intervalId = setInterval(inner, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>별도의 외부객체인 window의 메서드(setTimeout 또는 setInterval)에 전달할 콜백 함수 내부에서 지역변수를 참조합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>return 없이 클로저가 발생하는 경우</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (2) eventListener</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'button'</span>);</span><br><span class=\"line\">  button.innerText = <span class=\"string\">'click'</span>;</span><br><span class=\"line\">  button.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(++count, <span class=\"string\">'times clicked'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.appendChild(button);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>별도의 외부 객체인 DOM의 메서드 (addEventListener)에 등록할 handler 함수 내부에서 지역변수를 참조합니다.</p>\n<p><mark>두 상황 모두 두 지역변수를 참조하는 내부함수를 외부에 전달했기 때문에 클로저(closure)입니다.</mark></p>\n<hr>\n<h2 id=\"closure_memory\">클로저와 메모리 관리</h2>\n\n<ul>\n<li><p><mark>클로저는 객체지향과 함수형 모두를 아우르는 매우 중요한 개념입니다.</mark></p>\n</li>\n<li><p>메모리 누수:<br>개발자의 의도와 달리 어떤 값의 참조 카운트가 0이 되지 않아 GC의 수거 대상이 되지 않는 경우 발생할 수 있습니다.<br>(개발자가 의도적으로 참조 카운트가 0이 되지 않게 설계한 경우는 ‘누수’라는 표현은 맞지 않습니다.)</p>\n</li>\n<li><p><mark>클로저는 의도대로 설계한 “메모리 소모”에 대한 관리법을 잘 파악해서 적용하는 것이 중요합니다.</mark></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"메모리-관리-방법\"><a href=\"#메모리-관리-방법\" class=\"headerlink\" title=\"메모리 관리 방법\"></a>메모리 관리 방법</h3><p>클로저는 필요에 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생합니다.<br>그렇다면 <u>필요성이 사라진 시점</u>에는 더는 메모리를 소모하지 않게 해주면 됩니다.</p>\n<p>참조 카운트를 0으로 만들면(GC의 작동원리) GC가 수거해 갈것이고, 이때 소모됐던 메모리가 회수됩니다.</p>\n<ul>\n<li>참조 카운트를 0으로 만드는 방법 ?<br>식별자에 참조형이 아닌 기본형 데이터(보통 <code>null</code>이나 <code>undefined</code>)를 할당하면 됩니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>클로저의 메모리 관리 - return</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1) return에 의한 클로저의 메모리 해제</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> outer = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ++a;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> inner;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outer());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outer());</span><br><span class=\"line\">outer = <span class=\"literal\">null</span>; <span class=\"comment\">// outer 식별자의 inner 함수 참조를 끊음</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>클로저의 메모리 관리 - setInterval</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (2) setInterval에 의한 클로저의 메모리 해제</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> intervalId = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++a &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">      clearInterval(intervalId);</span><br><span class=\"line\">      inner = <span class=\"literal\">null</span>; <span class=\"comment\">// inner 식별자의 함수 참조를 끊음</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  intervalId = setInterval(inner, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>클로저의 메모리 관리 - eventListener</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (3) eventListener에 의한 클로저의 메모리 해제</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'button'</span>);</span><br><span class=\"line\">  button.innerText = <span class=\"string\">'click'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> clickHandler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(++count, <span class=\"string\">'times clicked'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">      button.removeEventListener(<span class=\"string\">'click'</span>, clickHandler);</span><br><span class=\"line\">      clickHandler = <span class=\"literal\">null</span>; <span class=\"comment\">// clickHandler 식별자의 함수 참조를 끊음</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  button.addEventListener(<span class=\"string\">'click'</span>, clickHandler);</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.appendChild(button);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"closure_ex\">클로저 활용 사례</h2>\n\n<p>클로저가 실제로 등장하는 활용 사례</p>\n<h3 id=\"콜백-함수-내부에서-외부-데이터를-사용하고자-할-때\"><a href=\"#콜백-함수-내부에서-외부-데이터를-사용하고자-할-때\" class=\"headerlink\" title=\"콜백 함수 내부에서 외부 데이터를 사용하고자 할 때\"></a>콜백 함수 내부에서 외부 데이터를 사용하고자 할 때</h3><p>대표적인 콜백 함수 중 하나인 이벤트 리스너에 관한 예시</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fruits = [<span class=\"string\">'apple'</span>, <span class=\"string\">'banana'</span>, <span class=\"string\">'peach'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> $ul = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'ul'</span>); <span class=\"comment\">// (공통 코드)</span></span><br><span class=\"line\"></span><br><span class=\"line\">fruits.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fruit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// (A)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> $li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">  $li.innerText = fruit;</span><br><span class=\"line\">  $li.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// (B)</span></span><br><span class=\"line\">    alert(<span class=\"string\">'your choice is '</span> + fruit);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  $ul.appendChild($li);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild($ul);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>fruits</code> 변수를 순회하며 <code>li</code>를 생성하고 각 <code>li</code>를 클릭하면 해당 리스너의 콜백 함수가 실행됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li><code>forEach</code>메서드에 넘겨준 익명의 콜백 함수(A)는 내부에서 외부 변수를 사용하지 않으므로 클로저가 없습니다.</li>\n</ol>\n<ol start=\"3\">\n<li><code>addEventListener</code>에 넘겨준 콜백 함수(B)에는 함수내의 <code>fruit</code>라는 외부 변수를 참조하고 있으므로 클로저가 있습니다.</li>\n</ol>\n<ol start=\"4\">\n<li>(A)는 <code>fruits</code>의 개수만큼 실행되며, 그때마다 새로운 실행 컨텍스트가 생성됩니다.</li>\n</ol>\n<ol start=\"5\">\n<li>(A)의 실행 종료 여부와 무관하게 클릭 이벤트에 의해 각 컨텍스트의 (B)가 실행될 때는 (B)의 <code>outerEnvironmentReference</code>가 (A)의 <code>LexicalEnvironment</code>를 참조하게 됩니다.</li>\n</ol>\n<ol start=\"6\">\n<li>따라서 (B)함수가 참조할 예정인 변수 <code>fruit</code>에 대해서는 (A)함수가 종료된 후에도 <code>CG</code> 대상에서 제외되어 계속 참조 가능하게 됩니다.</li>\n</ol>\n<p>그런데 (B)함수의 쓰임이 콜백 함수에 국한되지 않는 경우라면 반복을 줄이기 위해 (B)함수를 외부로 분리하는 편이 나을 수 있습니다.</p>\n<p>따라서 다음은 <code>fruit</code>을 인자로 받아 출력하는 형태입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>콜백 함수 외부로꺼내어 공통 함수로 사용</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fruits = [<span class=\"string\">'apple'</span>, <span class=\"string\">'banana'</span>, <span class=\"string\">'peach'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> $ul = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'ul'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> alertFruit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fruit</span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">'your choice is '</span> + fruit);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">fruits.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fruit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> $li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">  $li.innerText = fruit;</span><br><span class=\"line\">  $li.addEventListener(<span class=\"string\">'click'</span>, alertFruit);</span><br><span class=\"line\">  $ul.appendChild($li);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild($ul);</span><br><span class=\"line\">alertFruit(fruits[<span class=\"number\">1</span>]);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>공통 함수로 사용하고자 콜백 함수를 외부로 꺼내어 <code>alertFruit</code>라는 변수에 담았습니다.<br><code>alertFruit</code>를 직접 실행할 수 있게 되었습니다.</p>\n</li>\n<li><p>하지만 각 <code>li</code>를 클릭하면 클릭한 대상의 과일명이 아닌 <code>[object MouseEvent]</code>라는 값이 출력됩니다.<br>이는 콜백 함수의 인자에 대한 제어권을 <code>addEventListener</code>가 가진 상태이며, <code>addEventListener</code>는 콜백 함수를 호출할 때 첫 번째 인자에 “이벤트 객체”를 주입하기 때문입니다.</p>\n</li>\n</ul>\n<p>이 문제는 <code>bind</code>메서드를 활용하면 해결할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>bind 메서드 사용</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fruits = [<span class=\"string\">'apple'</span>, <span class=\"string\">'banana'</span>, <span class=\"string\">'peach'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> $ul = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'ul'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> alertFruit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fruit</span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">'your choice is '</span> + fruit);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">fruits.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fruit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> $li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">  $li.innerText = fruit;</span><br><span class=\"line\">  $li.addEventListener(<span class=\"string\">'click'</span>, alertFruit.bind(<span class=\"literal\">null</span>, fruit));</span><br><span class=\"line\">  $ul.appendChild($li);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild($ul);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>하지만 <code>bind</code>를 활용하면 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점과,<br>함수 내부에서 <code>this</code>가 참조하는 값이 달라지는점을 감안해야 합니다.</p>\n</li>\n<li><p>이러한 변경사항 마저 발생하지 않게 만들려면 <code>bind</code>메서드가 아닌 다른 방식으로 만들어야 합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>고차함수를 사용하여 클로저를 적극적으로 활용</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fruits = [<span class=\"string\">'apple'</span>, <span class=\"string\">'banana'</span>, <span class=\"string\">'peach'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> $ul = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'ul'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> alertFruitBuilder = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fruit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'your choice is '</span> + fruit);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">fruits.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fruit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> $li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">  $li.innerText = fruit;</span><br><span class=\"line\">  $li.addEventListener(<span class=\"string\">'click'</span>, alertFruitBuilder(fruit));</span><br><span class=\"line\">  $ul.appendChild($li);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild($ul);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>고차함수란 함수를 인자로 받거나 함수를 리턴하는 함수입니다.</li>\n</ul>\n<ol>\n<li><code>alertFruit</code> 함수 대신 <code>alertFruitBuilder</code>라는 이름의 함수를 작성했습니다.<br><code>alertFruitBuilder</code> 함수 내부에서는 다시 익명함수를 반환합니다.</li>\n</ol>\n<ol start=\"2\">\n<li>이 익명함수 내부의 코드가 기존의 <code>alertFruit</code> 함수의 코드입니다. </li>\n</ol>\n<ol start=\"3\">\n<li><code>alertFruitBuilder</code> 함수를 실행하면서 <code>fruit</code> 값을 인자로 전달하면, 함수의 실행 결과가<br>다시 함수(<code>return function</code>)가 되며, 이렇게 반환된 함수를 리스너의 콜백 함수로써 전달할 것입니다.</li>\n</ol>\n<ol start=\"4\">\n<li>클릭 이벤트가 발생하면 이 함수의 실행 컨텍스트가 열리면서 <code>alertFruitBuilder</code>의 파라미터로 넘어온 <code>fruit</code>를 <code>outerEnvironmentReference</code>에 의해 참조할 수 있게됩니다.<br>즉, <code>alertFruitBuilder</code>의 실행 결과로 반환된 함수에는 클로저가 존재합니다.</li>\n</ol>\n<hr>\n<h4 id=\"콜백-함수-내부에서-외부변수를-참조하기-위한-방법-정리\"><a href=\"#콜백-함수-내부에서-외부변수를-참조하기-위한-방법-정리\" class=\"headerlink\" title=\"콜백 함수 내부에서 외부변수를 참조하기 위한 방법 정리.\"></a>콜백 함수 내부에서 외부변수를 참조하기 위한 방법 정리.</h4><ol>\n<li>콜백 함수를 내부함수로 선언하여 외부변수를 직접 참조하는 방법.(<code>GC의 참조카운트</code> 이용)</li>\n</ol>\n<ol start=\"2\">\n<li><code>bind</code>메서드를 활용하여 값을 직접넘겨주는 방법. 클로저는 발생하지 않지만 몇가지 제약이 생김</li>\n</ol>\n<ol start=\"3\">\n<li>콜백 함수를 고차함수로 바꿔서 클로저를 적극적으로 활용하는 방법. </li>\n</ol>\n<hr>\n<h3 id=\"접근-권한-제어-은닉\"><a href=\"#접근-권한-제어-은닉\" class=\"headerlink\" title=\"접근 권한 제어(은닉)\"></a>접근 권한 제어(은닉)</h3><p>정보은닉(information hiding)은 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈간의 결합도를 낮추고 유연성을 높이고자 하는 현대 프로그래밍 언어의 중요한 개념 중 하나입니다.</p>\n<p>흔히 접근 권한에는 <code>public</code>, <code>private</code>, <code>protected</code> 세 종류가 있습니다.</p>\n<ul>\n<li><p><code>public</code> : 외부에서 접근 가능한 것</p>\n</li>\n<li><p><code>private</code> : 내부에서만 사용하며 외부에 노출되지 않는 것</p>\n</li>\n</ul>\n<p>자바스크립트는 기본적으로 변수 자체에 이러한 접근 권한을 직접 부여하도록 설계돼 있지 않습니다. 하지만 접근 권한 제어가 불가능한 것은 아닙니다. 클로저를 이용하면 함수 차원에서 <code>public</code>한 값과 <code>private</code>한 값을 구분하는 것이 가능합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>public/private -return</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ++a;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> inner;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> outer2 = outer();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outer2());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outer2());</span><br></pre></td></tr></table></figure>\n\n<p>이전에 본 클로저 예제 입니다.</p>\n<ul>\n<li><code>outer</code>함수를 종료할 때 <code>inner</code> 함수를 반환함으로써 <code>outer</code>함수의 지역변수 a의 값을 외부에서도 읽을 수 있게 되었습니다.</li>\n</ul>\n<ul>\n<li>이처럼 클로저를 활용하면 외부 스코프에서 함수 내부의 변수들 중 선택적으로 일부 변수에 대한 접근 권환을 부여할 수 있습니다. (<code>return</code>을 활용하여)</li>\n</ul>\n<ul>\n<li><code>outer</code>함수는 외부(전역 스코프)로 부터 철저하게 격리된 닫힌 공간입니다.<br>외부에서는 외부 공간에 노출돼 있는 <code>outer</code>라는 변수를 통해 <code>outer</code>함수를 실행할 수는 있지만, <code>outer</code>함수 내부에는 어떠한 개입도 할 수 없습니다.<br>외부에는 오직 <code>outer</code>함수가 <code>return</code>한 정보에만 접근할 수 있습니다.<br><code>return</code>값이 외부에 정보를 제공하는 유일한 수단이 됩니다.</li>\n</ul>\n<ul>\n<li>외부에 제공하고자 하는 정보들을 모아서 <code>return</code>하고, 내부에서만 사용할 정보들은 <code>return</code>하지 않는 것으로 접근 권한 제어가 가능한 것입니다.</li>\n</ul>\n<ul>\n<li><code>return</code>한 변수들은 공개 맴버(<code>public member</code>)가 되고, 그렇지 않은 변수들은 비공개 맴버(<code>private member</code>)가 되는 것입니다.</li>\n</ul>\n<hr>\n<h4 id=\"접근-권한-제어를-통한-보드-게임-예시\"><a href=\"#접근-권한-제어를-통한-보드-게임-예시\" class=\"headerlink\" title=\"접근 권한 제어를 통한 보드 게임 예시\"></a>접근 권한 제어를 통한 보드 게임 예시</h4><p>자동차 경주 보드 게임.</p>\n<p>규칙</p>\n<pre><code>1. 각 턴마다 주사위를 굴려 나온 숫자(km)만큼 이동.\n\n2. 차량별로 연료량(fuel)과 연비(power)는 무작위로 생성.\n\n3. 남은 연료가 이동할 거리에 필요한 연료보다 부족하면 이동 불가.\n\n4. 모든 유저가 이동할 수 없는 턴에 게임이 종료됨.\n\n5. 게임 종료 시 가장 멀리 이동해 있는 사람이 승리.</code></pre><figure class=\"highlight js\"><figcaption><span>규칙에 따른 간단한 자동차 객체</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> car = &#123;</span><br><span class=\"line\">  fuel: <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">10</span> + <span class=\"number\">10</span>), <span class=\"comment\">// 연료(L)</span></span><br><span class=\"line\">  power: <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">3</span> + <span class=\"number\">2</span>), <span class=\"comment\">// 연비(km/L)</span></span><br><span class=\"line\">  moved: <span class=\"number\">0</span>, <span class=\"comment\">// 총 이동거리</span></span><br><span class=\"line\">  run: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> km = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">6</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> wasteFuel = km / <span class=\"keyword\">this</span>.power;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.fuel &lt; wasteFuel) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'이동불가'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fuel -= wasteFuel;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.moved += km;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(km + <span class=\"string\">'km 이동 (총 '</span> + <span class=\"keyword\">this</span>.moved + <span class=\"string\">'km)'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>위 코드는 <code>run</code> 메서드를 실행할 때마다 <code>car</code>객체의 <code>fuel</code>, <code>moved</code> 값이 변합니다.</p>\n<p>하지만 자바스크립트를 아는사람이 <code>car</code>객체의 <code>fuel</code>, <code>power</code>, <code>moved</code>값을 직접 지정해 버린다면 공평한 게임이 되지 못합니다. </p>\n<ul>\n<li>이렇게 값을 바꾸지 못하도록 객체가 아닌 함수로 만들고, 필요한 맴버만을 <code>return</code>할 필요가 있습니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>함수를 실행함으로써 객체 생성</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createCar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fuel = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">10</span> + <span class=\"number\">10</span>); <span class=\"comment\">// 연료(L)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> power = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">3</span> + <span class=\"number\">2</span>); <span class=\"comment\">// 연비(km / L)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> moved = <span class=\"number\">0</span>; <span class=\"comment\">// 총 이동거리</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> moved() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> moved;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    run: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> km = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">6</span>);</span><br><span class=\"line\">      <span class=\"keyword\">var</span> wasteFuel = km / power;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (fuel &lt; wasteFuel) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'이동불가'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      fuel -= wasteFuel;</span><br><span class=\"line\">      moved += km;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(km + <span class=\"string\">'km 이동 (총 '</span> + moved + <span class=\"string\">'km). 남은 연료: '</span> + fuel);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> car = createCar();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>createCar</code>라는 함수를 실행함으로써 객체를 생성하게 했습니다. <code>fuel</code>, <code>power</code> 변수는 비공개 맴버로 지정해 외부에서의 접근을 제한했고, <code>moved</code>변수는 <code>getter</code>만을 부여함으로써 “읽기전용” 속성을 부여했습니다.</p>\n</li>\n<li><p>이제 외부에서는 오직 <code>run</code>메서드를 실행하는 것과 현재의 <code>moved</code>값을 확인하는 두 가지 동작만 할 수 있습니다.</p>\n</li>\n<li><p><code>run</code>메서드를 다른 내용으로 덮어씌우는 어뷰징은 여전히 가능한 상태이긴 하지만 앞서의 코드보다 훨씬 안전한 코드가 됐습니다. 이런 어뷰징까지 막기 위해서는 객체를 <code>return</code>하기 전에 미리 변경할 수 없게끔 조치를 취해야 합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>Object.freeze</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createCar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fuel = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">10</span> + <span class=\"number\">10</span>); <span class=\"comment\">// 연료(L)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> power = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">3</span> + <span class=\"number\">2</span>); <span class=\"comment\">// 연비(km / L)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> moved = <span class=\"number\">0</span>; <span class=\"comment\">// 총 이동거리</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> publicMembers = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> moved() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> moved;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    run: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> km = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">6</span>);</span><br><span class=\"line\">      <span class=\"keyword\">var</span> wasteFuel = km / power;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (fuel &lt; wasteFuel) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'이동불가'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      fuel -= wasteFuel;</span><br><span class=\"line\">      moved += km;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(km + <span class=\"string\">'km 이동 (총 '</span> + moved + <span class=\"string\">'km). 남은 연료: '</span> + fuel);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.freeze(publicMembers);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> publicMembers;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> car = createCar();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\">Object.freeze</a>를 사용하여 <code>publicMembers</code>객체를 동결객체로 만들었습니다.</li>\n</ul>\n<ul>\n<li><code>Object.freeze</code>메서드는 호출된 객체의 직속 속성만 동결하며 내부의 속성 값이 객체라면 그 객체는 동결되지 않아 추가/제거/재할당의 대상이 될 수 있으므로 (얕은동결) 주의하여야 합니다.</li>\n</ul>\n<hr>\n<h4 id=\"클로저를-활용해-접근권한-제어-방법-정리\"><a href=\"#클로저를-활용해-접근권한-제어-방법-정리\" class=\"headerlink\" title=\"클로저를 활용해 접근권한 제어 방법 정리\"></a>클로저를 활용해 접근권한 제어 방법 정리</h4><ol>\n<li><p>함수에서 지역변수 및 내부함수 등을 생성</p>\n</li>\n<li><p>외부에 접근권한을 주고자 하는 대상들로 구성된 참조형 데이터(대상이 여럿일 경우 객체 또는 배열, 하나일 경우 함수)를 return 합니다.</p>\n</li>\n<li><p>return한 변수들은 공개 맴버가 되고, 그렇지 않은 변수들은 비공개 맴버가 됩니다.</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"부분-적용-함수\"><a href=\"#부분-적용-함수\" class=\"headerlink\" title=\"부분 적용 함수\"></a>부분 적용 함수</h3><p>부분 적용 함수(<code>partially applied function</code>)란 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가. 나중에 나머지 인자를 넘길 때 원래 함수의 실행 결과를 얻을 수 있게 하는 함수입니다.</p>\n<p><code>this</code>를 바인딩해야 하는 점을 제외하면 <code>bind</code>메서드의 실행 결과가 바로 부분 적용 함수입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>bind - 부분 적용 함수</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">    result += <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> addPartial = add.bind(<span class=\"literal\">null</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(addPartial(<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>)); <span class=\"comment\">// 55</span></span><br></pre></td></tr></table></figure>\n\n<p><code>addPartial</code> 함수에 <code>this</code>값 <code>null</code>과 인자 5개를 미리 적용하고, 대기합니다.<br>추후에 추가적으로 인자들을 전달하며 호출하면 대기중이던 인자들과 차례대로 적용되어 실행합니다.</p>\n<p><code>add</code>함수는 <code>this</code>값을 사용하지 않지만, <code>bind</code>메서드는 <code>this</code>값을 변경할 수 밖에 없기 때문에 <code>this</code>에 관여하지 않는 다른 방법의 부분 적용 함수가 필요합니다.</p>\n<p>// p 135 ~ 137 보류</p>\n<p>디바운스(<code>debounce</code>)는 짧은 시간 동안 동일한 이벤트가 많이 발생한 경우 이를 전부 처리하지 않고 처음 또는 마지막에 발생한 이벤트에 대해 한 번만 처리하는 것으로, <code>scroll</code>, <code>wheel</code>, <code>mousemove</code>, <code>resize</code>등에 적용하기 좋습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>부분 적용 함수 - 디바운스</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> debounce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, func, wait</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timeoutId = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(eventName, <span class=\"string\">'event 발생'</span>);</span><br><span class=\"line\">    clearTimeout(timeoutId);</span><br><span class=\"line\">    timeoutId = setTimeout(func.bind(self, event), wait);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> moveHandler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'move event 처리'</span>); &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> wheelHandler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'wheel event 처리'</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">'mousemove'</span>,</span><br><span class=\"line\">  debounce(<span class=\"string\">'move'</span>, moveHandler, <span class=\"number\">500</span>));</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">'mousewheel'</span>,</span><br><span class=\"line\">  debounce(<span class=\"string\">'wheel'</span>, wheelHandler, <span class=\"number\">700</span>));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>debounce</code> 함수는 출력 용도로 지정한 <code>eventName</code>과 실행할 함수(<code>func</code>),마지막으로 발생한 이벤트인지 여부를 판단하기 위한 대기시간 (<code>wait(</code>(ms))을 받습니다.</li>\n</ul>\n<ul>\n<li>내부에서는 <code>timeoutId</code> 변수를 생성하고, 클로저로 <code>EventListener</code>에 의해 호출될 함수를 반환합니다. 반환될 함수 내부에서는 <code>setTimeout</code>을 사용하기 위해 <code>this</code>를 별도의 변수에 담고 <code>clearTimeout</code>으로 대기큐를 초기화하게 했습니다.</li>\n</ul>\n<ul>\n<li>마지막으로 <code>setTimeout</code>으로 <code>wait</code> 시간만큼 지연시킨 다음, 원래의 <code>func</code>를 호출하는 형태입니다.</li>\n</ul>\n<ul>\n<li>최초의 event가 발생하면 <code>timeoutId = setTimeout(func,bind(self,event),wait)</code>에 의해 timeout의 대기열에 ‘wait 시간 뒤에 func를 실행 함’이라는 내용이 담깁니다. 그런데 <code>wait</code>시간이 경과하기 전에 동일한 event가 발생하게 되면 앞의 <code>clearTimeout(timeoutId)</code>에 의해 앞에 저장했던 대기열을 초기화하고, 다시 <code>timeoutId = setTimeout(func,bind(self,event),wait)</code>에서 새로운 대기열을 등록합니다.</li>\n</ul>\n<ul>\n<li>결국 각 동일한 이벤트가 이전 이벤트로 부터 <code>wait</code>시간 내에 다시 발생하는 한 마지막에 발생한 이벤트만이 초기화되지 않고 실행됩니다.</li>\n</ul>\n<ul>\n<li><code>debounce</code>함수에서 클로저로 처리되는 변수는 <code>eventName</code>, <code>func</code>, <code>wait</code>, <code>timeoutId</code>입니다.</li>\n</ul>\n<hr>\n<h3 id=\"커링-함수\"><a href=\"#커링-함수\" class=\"headerlink\" title=\"커링 함수\"></a>커링 함수</h3><hr>\n<h2 id=\"closure\">정리</h2>\n\n<ul>\n<li>클로저란 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상입니다.</li>\n</ul>\n<ul>\n<li>내부 함수를 외부로 전달하는 방법에는 함수를 return하는 경우뿐아니라 콜백으로 전달하는 경우도 포함됩니다.</li>\n</ul>\n<ul>\n<li>클로저는 그 본질이 메모리를 계속 차지하는 개념이므로 더는 사용하지 않게 된 클로저에 대해서는 메모리를 차지하지 않도록 관리해줄 필요가 있습니다.</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li>클로저 (Closure)<ul>\n<li><a href=\"/2020/05/03/클로저-Core-JavaScript/#closure\">클로저의 의미 및 원리 이해</a></li>\n<li><a href=\"/2020/05/03/클로저-Core-JavaScript/#closure_memory\">클로저와 메모리 관리</a></li>\n<li><a href=\"/2020/05/03/클로저-Core-JavaScript/#closure_ex\">클로저 활용 사례</a><ul>\n<li>콜백 함수 내부에서 외부 데이터를 사용하고자 할 때</li>\n<li>접근 권한 제어 (정보 은닉)</li>\n<li>부분 적용 함수</li>\n<li>커링 함수</li>\n</ul>\n</li>\n<li><a href=\"/2020/05/03/클로저-Core-JavaScript/#\">정리</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"closure\">클로저의 의미 및 원리 이해</h2>\n\n<p>클로저(<code>Closure</code>)는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성입니다.<br>자바스크립트 고유의 개념이 아니라서 ECMAScript 명세에서도 클로저의 정의를 다루지 않고 있고, 다양한 문헌에서 제각각 클로저를 다르게 정의 또는 설명하고 있습니다.</p>\n<p>다양한 서적에서 클로저를 한 문장으로 요약해서 설명하는 부분들을 소개하면 다음과 같습니다.<br>    * 자신을 내포하는 함수의 컨텍스트에 접근할 수 있는 함수</p>\n<pre><code>* 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 것\n\n* 함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수\n\n* 이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수\n\n* 자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합\n\n* 로컬 변수를 참조하고 있는 함수 내의 함수\n\n* 자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수</code></pre><p><strong>MDN</strong> 에서는 클로저를 함수와 그 함수가 선언될 당시의 <code>LexicalEnvironment</code>의 조합이라고 소개하고,<br>다른 말로 클로저는 내부 함수에서 외부 함수의 범위로 접근할 수 있게 해주는 함수라고 합니다.</p>\n<p>선언될 당시의 <code>LexicalEnvironment</code>는 실행 컨텍스트의 구성 요소 중 하나인 <code>outerEnvironmentReference</code>에 해당합니다.<br><code>LexicalEnvironment</code>의 <code>environmentRecord</code>와 <code>outerEnvironmentReference</code>에 의해 변수의 유효범위인 스코프가 결정되고 스코프 체인이 가능해집니다.</p>\n<ul>\n<li><code>컨텍스트 A</code>에서 선언한 <code>내부 함수B</code>의 실행 컨텍스트가 활성화된 시점에서는 B의 <code>outerEnvironmentReference</code>가 참조하는 대상인 A의 <code>LexicalEnvironment</code>에도 접근이 가능해 집니다. A에서는 B에서 선언한 변수에 접근할 수 없지만 B에서는 A에 선언한 변수에 접근이 가능해집니다.</li>\n</ul>\n<ul>\n<li>이런 내부함수에서 외부 변수를 참조하게 되는 경우가, 선언될 당시의 <code>LexicalEnvironment</code>와의 상호관계(조합)의 의미가 됩니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>외부 함수의 변수를 참조하는 내부 함수 -1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(++a);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  inner();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">outer();</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>outer</code> 함수에 변수 a를 선언했고 1을 할당했습니다.</li>\n</ol>\n<ol start=\"2\">\n<li><code>outer</code>의 내부함수인 <code>inner</code> 함수에서 a의 값을 1 증가시키고 출력합니다.</li>\n</ol>\n<ul>\n<li><code>inner</code>함수 내부에서는 a를 선언하지 않았기 때문에 <code>environmentRecord</code>에서 값을 찾지 못하므로 <code>outerEnvironmentReference</code>에 지정된 상위 컨텍스트인 <code>outer</code>의 <code>LexicalEnvironment</code>에 접근하여 다시 a를 찾습니다.</li>\n</ul>\n<ul>\n<li><code>outer</code> 함수의 실행 컨텍스트가 종료되면 <code>LexicalEnvironment</code>에 저장된 식별자들(a,inner)에 대한 참조를 지웁니다. 그러면 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 <code>가비지컬렉터(GC)</code>의 수집 대상이 됩니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>외부 함수의 변수를 참조하는 내부 함수 -2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ++a;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> inner();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> outer2 = outer();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outer2); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>이 예제 역시 <code>inner</code>함수 내부에서 외부변수인 a를 사용했습니다.<br><code>inner</code> 함수를 실행한 결과를 <code>return</code> 하고 나면 <code>outer</code>함수의 실행 컨텍스트가 종료된 시점에는 a변수를 참조하는 대상이 없어집니다. 그러므로 예제1과 마찬가지로 식별자들의(a,inner) 값들은 <code>가비지컬렉터(GC)</code>에 의해 소멸됩니다.</li>\n</ul>\n<ul>\n<li>예제1과 예제2는 <code>outer</code>함수의 실행 컨텍스트가 종료되기 이전에 <code>inner</code> 함수의 실행 컨텍스트가 종료돼 있으며, 이후 별도로 <code>inner</code> 함수를 호출할 수 없다는 공통점을 가지고 있습니다.</li>\n</ul>\n<p><mark>그렇다면 outer의 실행 컨텍스트가 종료된 후에도 inner 함수를 호출할 수 있게 만들면 어떨까요?</mark></p>\n<figure class=\"highlight js\"><figcaption><span>외부 함수의 변수를 참조하는 내부 함수 -3</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ++a;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> inner;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> outer2 = outer();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outer2()); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outer2()); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>return inner()</code> 함수의 실행 결과가 아닌 <code>return inner</code> 함수 자체를 반환했습니다.</li>\n</ol>\n<ol start=\"2\">\n<li><code>outer2</code> 변수는 <code>outer</code>함수의 실행 결과인 <code>inner</code>함수 자체를 참조하게 됩니다.<br><code>outer2</code> 호출시 <code>inner</code> 함수가 실행됨.</li>\n</ol>\n<ol start=\"3\">\n<li><code>inner</code> 함수의 실행 컨텍스트의 <code>environmentRecord</code>에는 수집할 정보가 없습니다. <code>outerEnvironmentReference</code>에는 <code>inner</code> 함수가 선언된 위치의 <code>LexicalEnvironment</code>가 참조복사 됩니다. <code>inner</code>함수는 <code>outer</code> 함수 내부에서 선언됐으므로, <code>outer</code> 함수의 <code>LexicalEnvironment</code>가 담깁니다.</li>\n</ol>\n<ol start=\"4\">\n<li>스코프체이닝에 따라 <code>outer</code>에서 선언한 변수 a에 접근해 1만큼 증가시킨후 결과 값인 2를 반환하고, <code>inner</code>함수의 실행 컨텍스트가 종료됩니다.</li>\n</ol>\n<ol start=\"5\">\n<li><code>outer2</code><u>를 다시 호출하면 같은 방식으로 a의 값을 2에서 1만큼 증가시켜 그 결과 값인 3을 반환합니다.</u></li>\n</ol>\n<p><strong>중요 포인트</strong></p>\n<ul>\n<li><code>outer</code>함수의 실행 컨텍스트는 종료된 상태인데 어떻게 외부 함수의 변수(<code>outer</code> 함수의 <code>LexicalEnvironment</code>)에 접근할 수 있는 걸까?</li>\n</ul>\n<ul>\n<li>이는 가비지컬렉터의 동작 방식 때문입니다.</li>\n</ul>\n<ul>\n<li><mark>어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 가비지컬렉터(GC)의 대상이 되지 않습니다.</mark></li>\n</ul>\n<ul>\n<li><code>outer</code> 함수는 실행 종료 시점에 <code>inner</code> 함수를 반환했습니다. <code>outer</code> 함수는 <code>inner</code>함수를 참조하게 되고 외부함수인 <code>outer</code>의 실행이 종료되었지만 내부함수인 <code>inner</code>함수는 언젠가 <code>outer()</code>형식 (변수 outer2와 같은)으로 호출될 수 있습니다.</li>\n</ul>\n<ul>\n<li><code>inner</code> 함수 역시 <code>outer</code>의 변수를 참조하므로 실행 컨텍스트가 활성화 되면 <code>outerEnvironmentReference</code>가 <code>outer</code> 함수의 <code>LexicalEnvironment</code>를 필요로 하게되므로 <code>가비지컬렉터(GC)</code>의 대상에서 제외됩니다. 그 덕에 <code>inner</code>함수가 외부함수의 변수에 접근할 수 있는 것입니다.</li>\n</ul>\n<ul>\n<li>클로저란 :<br><mark>외부 함수에서 선언한 변수를 참조하는 내부 함수를 외부로 전달할 경우 외부 함수의 실행 컨텍스트가 종료된 이후에도 변수가 사라지지 않는 현상</mark></li>\n</ul>\n<ul>\n<li>“내부함수를 외부로 전달”이 return만을 의미하는 것은 아님. 다른 경우도 존재</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>return 없이 클로저가 발생하는 경우</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1) setInterval/setTimeout</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">0</span>; <span class=\"comment\">// 외부 함수의 변수를 내부 함수에서</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> intervalId = <span class=\"literal\">null</span>; <span class=\"comment\">// 참조하고 있으므로 GC의 대상이 되지 않음. </span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++a &gt;= <span class=\"number\">10</span>) &#123; <span class=\"comment\">// 외부 함수의 변수a 참조</span></span><br><span class=\"line\">      clearInterval(intervalId); <span class=\"comment\">// 외부 함수의 변수 intervalId 참조</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  intervalId = setInterval(inner, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>별도의 외부객체인 window의 메서드(setTimeout 또는 setInterval)에 전달할 콜백 함수 내부에서 지역변수를 참조합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>return 없이 클로저가 발생하는 경우</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (2) eventListener</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'button'</span>);</span><br><span class=\"line\">  button.innerText = <span class=\"string\">'click'</span>;</span><br><span class=\"line\">  button.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(++count, <span class=\"string\">'times clicked'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.appendChild(button);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>별도의 외부 객체인 DOM의 메서드 (addEventListener)에 등록할 handler 함수 내부에서 지역변수를 참조합니다.</p>\n<p><mark>두 상황 모두 두 지역변수를 참조하는 내부함수를 외부에 전달했기 때문에 클로저(closure)입니다.</mark></p>\n<hr>\n<h2 id=\"closure_memory\">클로저와 메모리 관리</h2>\n\n<ul>\n<li><p><mark>클로저는 객체지향과 함수형 모두를 아우르는 매우 중요한 개념입니다.</mark></p>\n</li>\n<li><p>메모리 누수:<br>개발자의 의도와 달리 어떤 값의 참조 카운트가 0이 되지 않아 GC의 수거 대상이 되지 않는 경우 발생할 수 있습니다.<br>(개발자가 의도적으로 참조 카운트가 0이 되지 않게 설계한 경우는 ‘누수’라는 표현은 맞지 않습니다.)</p>\n</li>\n<li><p><mark>클로저는 의도대로 설계한 “메모리 소모”에 대한 관리법을 잘 파악해서 적용하는 것이 중요합니다.</mark></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"메모리-관리-방법\"><a href=\"#메모리-관리-방법\" class=\"headerlink\" title=\"메모리 관리 방법\"></a>메모리 관리 방법</h3><p>클로저는 필요에 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생합니다.<br>그렇다면 <u>필요성이 사라진 시점</u>에는 더는 메모리를 소모하지 않게 해주면 됩니다.</p>\n<p>참조 카운트를 0으로 만들면(GC의 작동원리) GC가 수거해 갈것이고, 이때 소모됐던 메모리가 회수됩니다.</p>\n<ul>\n<li>참조 카운트를 0으로 만드는 방법 ?<br>식별자에 참조형이 아닌 기본형 데이터(보통 <code>null</code>이나 <code>undefined</code>)를 할당하면 됩니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>클로저의 메모리 관리 - return</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1) return에 의한 클로저의 메모리 해제</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> outer = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ++a;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> inner;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outer());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outer());</span><br><span class=\"line\">outer = <span class=\"literal\">null</span>; <span class=\"comment\">// outer 식별자의 inner 함수 참조를 끊음</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>클로저의 메모리 관리 - setInterval</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (2) setInterval에 의한 클로저의 메모리 해제</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> intervalId = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++a &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">      clearInterval(intervalId);</span><br><span class=\"line\">      inner = <span class=\"literal\">null</span>; <span class=\"comment\">// inner 식별자의 함수 참조를 끊음</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  intervalId = setInterval(inner, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><figcaption><span>클로저의 메모리 관리 - eventListener</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (3) eventListener에 의한 클로저의 메모리 해제</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'button'</span>);</span><br><span class=\"line\">  button.innerText = <span class=\"string\">'click'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> clickHandler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(++count, <span class=\"string\">'times clicked'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">      button.removeEventListener(<span class=\"string\">'click'</span>, clickHandler);</span><br><span class=\"line\">      clickHandler = <span class=\"literal\">null</span>; <span class=\"comment\">// clickHandler 식별자의 함수 참조를 끊음</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  button.addEventListener(<span class=\"string\">'click'</span>, clickHandler);</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.appendChild(button);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"closure_ex\">클로저 활용 사례</h2>\n\n<p>클로저가 실제로 등장하는 활용 사례</p>\n<h3 id=\"콜백-함수-내부에서-외부-데이터를-사용하고자-할-때\"><a href=\"#콜백-함수-내부에서-외부-데이터를-사용하고자-할-때\" class=\"headerlink\" title=\"콜백 함수 내부에서 외부 데이터를 사용하고자 할 때\"></a>콜백 함수 내부에서 외부 데이터를 사용하고자 할 때</h3><p>대표적인 콜백 함수 중 하나인 이벤트 리스너에 관한 예시</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fruits = [<span class=\"string\">'apple'</span>, <span class=\"string\">'banana'</span>, <span class=\"string\">'peach'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> $ul = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'ul'</span>); <span class=\"comment\">// (공통 코드)</span></span><br><span class=\"line\"></span><br><span class=\"line\">fruits.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fruit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// (A)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> $li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">  $li.innerText = fruit;</span><br><span class=\"line\">  $li.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// (B)</span></span><br><span class=\"line\">    alert(<span class=\"string\">'your choice is '</span> + fruit);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  $ul.appendChild($li);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild($ul);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>fruits</code> 변수를 순회하며 <code>li</code>를 생성하고 각 <code>li</code>를 클릭하면 해당 리스너의 콜백 함수가 실행됩니다.</li>\n</ol>\n<ol start=\"2\">\n<li><code>forEach</code>메서드에 넘겨준 익명의 콜백 함수(A)는 내부에서 외부 변수를 사용하지 않으므로 클로저가 없습니다.</li>\n</ol>\n<ol start=\"3\">\n<li><code>addEventListener</code>에 넘겨준 콜백 함수(B)에는 함수내의 <code>fruit</code>라는 외부 변수를 참조하고 있으므로 클로저가 있습니다.</li>\n</ol>\n<ol start=\"4\">\n<li>(A)는 <code>fruits</code>의 개수만큼 실행되며, 그때마다 새로운 실행 컨텍스트가 생성됩니다.</li>\n</ol>\n<ol start=\"5\">\n<li>(A)의 실행 종료 여부와 무관하게 클릭 이벤트에 의해 각 컨텍스트의 (B)가 실행될 때는 (B)의 <code>outerEnvironmentReference</code>가 (A)의 <code>LexicalEnvironment</code>를 참조하게 됩니다.</li>\n</ol>\n<ol start=\"6\">\n<li>따라서 (B)함수가 참조할 예정인 변수 <code>fruit</code>에 대해서는 (A)함수가 종료된 후에도 <code>CG</code> 대상에서 제외되어 계속 참조 가능하게 됩니다.</li>\n</ol>\n<p>그런데 (B)함수의 쓰임이 콜백 함수에 국한되지 않는 경우라면 반복을 줄이기 위해 (B)함수를 외부로 분리하는 편이 나을 수 있습니다.</p>\n<p>따라서 다음은 <code>fruit</code>을 인자로 받아 출력하는 형태입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>콜백 함수 외부로꺼내어 공통 함수로 사용</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fruits = [<span class=\"string\">'apple'</span>, <span class=\"string\">'banana'</span>, <span class=\"string\">'peach'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> $ul = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'ul'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> alertFruit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fruit</span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">'your choice is '</span> + fruit);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">fruits.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fruit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> $li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">  $li.innerText = fruit;</span><br><span class=\"line\">  $li.addEventListener(<span class=\"string\">'click'</span>, alertFruit);</span><br><span class=\"line\">  $ul.appendChild($li);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild($ul);</span><br><span class=\"line\">alertFruit(fruits[<span class=\"number\">1</span>]);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>공통 함수로 사용하고자 콜백 함수를 외부로 꺼내어 <code>alertFruit</code>라는 변수에 담았습니다.<br><code>alertFruit</code>를 직접 실행할 수 있게 되었습니다.</p>\n</li>\n<li><p>하지만 각 <code>li</code>를 클릭하면 클릭한 대상의 과일명이 아닌 <code>[object MouseEvent]</code>라는 값이 출력됩니다.<br>이는 콜백 함수의 인자에 대한 제어권을 <code>addEventListener</code>가 가진 상태이며, <code>addEventListener</code>는 콜백 함수를 호출할 때 첫 번째 인자에 “이벤트 객체”를 주입하기 때문입니다.</p>\n</li>\n</ul>\n<p>이 문제는 <code>bind</code>메서드를 활용하면 해결할 수 있습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>bind 메서드 사용</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fruits = [<span class=\"string\">'apple'</span>, <span class=\"string\">'banana'</span>, <span class=\"string\">'peach'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> $ul = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'ul'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> alertFruit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fruit</span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">'your choice is '</span> + fruit);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">fruits.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fruit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> $li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">  $li.innerText = fruit;</span><br><span class=\"line\">  $li.addEventListener(<span class=\"string\">'click'</span>, alertFruit.bind(<span class=\"literal\">null</span>, fruit));</span><br><span class=\"line\">  $ul.appendChild($li);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild($ul);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>하지만 <code>bind</code>를 활용하면 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점과,<br>함수 내부에서 <code>this</code>가 참조하는 값이 달라지는점을 감안해야 합니다.</p>\n</li>\n<li><p>이러한 변경사항 마저 발생하지 않게 만들려면 <code>bind</code>메서드가 아닌 다른 방식으로 만들어야 합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>고차함수를 사용하여 클로저를 적극적으로 활용</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fruits = [<span class=\"string\">'apple'</span>, <span class=\"string\">'banana'</span>, <span class=\"string\">'peach'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> $ul = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'ul'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> alertFruitBuilder = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fruit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'your choice is '</span> + fruit);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">fruits.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fruit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> $li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">  $li.innerText = fruit;</span><br><span class=\"line\">  $li.addEventListener(<span class=\"string\">'click'</span>, alertFruitBuilder(fruit));</span><br><span class=\"line\">  $ul.appendChild($li);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild($ul);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>고차함수란 함수를 인자로 받거나 함수를 리턴하는 함수입니다.</li>\n</ul>\n<ol>\n<li><code>alertFruit</code> 함수 대신 <code>alertFruitBuilder</code>라는 이름의 함수를 작성했습니다.<br><code>alertFruitBuilder</code> 함수 내부에서는 다시 익명함수를 반환합니다.</li>\n</ol>\n<ol start=\"2\">\n<li>이 익명함수 내부의 코드가 기존의 <code>alertFruit</code> 함수의 코드입니다. </li>\n</ol>\n<ol start=\"3\">\n<li><code>alertFruitBuilder</code> 함수를 실행하면서 <code>fruit</code> 값을 인자로 전달하면, 함수의 실행 결과가<br>다시 함수(<code>return function</code>)가 되며, 이렇게 반환된 함수를 리스너의 콜백 함수로써 전달할 것입니다.</li>\n</ol>\n<ol start=\"4\">\n<li>클릭 이벤트가 발생하면 이 함수의 실행 컨텍스트가 열리면서 <code>alertFruitBuilder</code>의 파라미터로 넘어온 <code>fruit</code>를 <code>outerEnvironmentReference</code>에 의해 참조할 수 있게됩니다.<br>즉, <code>alertFruitBuilder</code>의 실행 결과로 반환된 함수에는 클로저가 존재합니다.</li>\n</ol>\n<hr>\n<h4 id=\"콜백-함수-내부에서-외부변수를-참조하기-위한-방법-정리\"><a href=\"#콜백-함수-내부에서-외부변수를-참조하기-위한-방법-정리\" class=\"headerlink\" title=\"콜백 함수 내부에서 외부변수를 참조하기 위한 방법 정리.\"></a>콜백 함수 내부에서 외부변수를 참조하기 위한 방법 정리.</h4><ol>\n<li>콜백 함수를 내부함수로 선언하여 외부변수를 직접 참조하는 방법.(<code>GC의 참조카운트</code> 이용)</li>\n</ol>\n<ol start=\"2\">\n<li><code>bind</code>메서드를 활용하여 값을 직접넘겨주는 방법. 클로저는 발생하지 않지만 몇가지 제약이 생김</li>\n</ol>\n<ol start=\"3\">\n<li>콜백 함수를 고차함수로 바꿔서 클로저를 적극적으로 활용하는 방법. </li>\n</ol>\n<hr>\n<h3 id=\"접근-권한-제어-은닉\"><a href=\"#접근-권한-제어-은닉\" class=\"headerlink\" title=\"접근 권한 제어(은닉)\"></a>접근 권한 제어(은닉)</h3><p>정보은닉(information hiding)은 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈간의 결합도를 낮추고 유연성을 높이고자 하는 현대 프로그래밍 언어의 중요한 개념 중 하나입니다.</p>\n<p>흔히 접근 권한에는 <code>public</code>, <code>private</code>, <code>protected</code> 세 종류가 있습니다.</p>\n<ul>\n<li><p><code>public</code> : 외부에서 접근 가능한 것</p>\n</li>\n<li><p><code>private</code> : 내부에서만 사용하며 외부에 노출되지 않는 것</p>\n</li>\n</ul>\n<p>자바스크립트는 기본적으로 변수 자체에 이러한 접근 권한을 직접 부여하도록 설계돼 있지 않습니다. 하지만 접근 권한 제어가 불가능한 것은 아닙니다. 클로저를 이용하면 함수 차원에서 <code>public</code>한 값과 <code>private</code>한 값을 구분하는 것이 가능합니다.</p>\n<figure class=\"highlight js\"><figcaption><span>public/private -return</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> inner = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ++a;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> inner;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> outer2 = outer();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outer2());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outer2());</span><br></pre></td></tr></table></figure>\n\n<p>이전에 본 클로저 예제 입니다.</p>\n<ul>\n<li><code>outer</code>함수를 종료할 때 <code>inner</code> 함수를 반환함으로써 <code>outer</code>함수의 지역변수 a의 값을 외부에서도 읽을 수 있게 되었습니다.</li>\n</ul>\n<ul>\n<li>이처럼 클로저를 활용하면 외부 스코프에서 함수 내부의 변수들 중 선택적으로 일부 변수에 대한 접근 권환을 부여할 수 있습니다. (<code>return</code>을 활용하여)</li>\n</ul>\n<ul>\n<li><code>outer</code>함수는 외부(전역 스코프)로 부터 철저하게 격리된 닫힌 공간입니다.<br>외부에서는 외부 공간에 노출돼 있는 <code>outer</code>라는 변수를 통해 <code>outer</code>함수를 실행할 수는 있지만, <code>outer</code>함수 내부에는 어떠한 개입도 할 수 없습니다.<br>외부에는 오직 <code>outer</code>함수가 <code>return</code>한 정보에만 접근할 수 있습니다.<br><code>return</code>값이 외부에 정보를 제공하는 유일한 수단이 됩니다.</li>\n</ul>\n<ul>\n<li>외부에 제공하고자 하는 정보들을 모아서 <code>return</code>하고, 내부에서만 사용할 정보들은 <code>return</code>하지 않는 것으로 접근 권한 제어가 가능한 것입니다.</li>\n</ul>\n<ul>\n<li><code>return</code>한 변수들은 공개 맴버(<code>public member</code>)가 되고, 그렇지 않은 변수들은 비공개 맴버(<code>private member</code>)가 되는 것입니다.</li>\n</ul>\n<hr>\n<h4 id=\"접근-권한-제어를-통한-보드-게임-예시\"><a href=\"#접근-권한-제어를-통한-보드-게임-예시\" class=\"headerlink\" title=\"접근 권한 제어를 통한 보드 게임 예시\"></a>접근 권한 제어를 통한 보드 게임 예시</h4><p>자동차 경주 보드 게임.</p>\n<p>규칙</p>\n<pre><code>1. 각 턴마다 주사위를 굴려 나온 숫자(km)만큼 이동.\n\n2. 차량별로 연료량(fuel)과 연비(power)는 무작위로 생성.\n\n3. 남은 연료가 이동할 거리에 필요한 연료보다 부족하면 이동 불가.\n\n4. 모든 유저가 이동할 수 없는 턴에 게임이 종료됨.\n\n5. 게임 종료 시 가장 멀리 이동해 있는 사람이 승리.</code></pre><figure class=\"highlight js\"><figcaption><span>규칙에 따른 간단한 자동차 객체</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> car = &#123;</span><br><span class=\"line\">  fuel: <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">10</span> + <span class=\"number\">10</span>), <span class=\"comment\">// 연료(L)</span></span><br><span class=\"line\">  power: <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">3</span> + <span class=\"number\">2</span>), <span class=\"comment\">// 연비(km/L)</span></span><br><span class=\"line\">  moved: <span class=\"number\">0</span>, <span class=\"comment\">// 총 이동거리</span></span><br><span class=\"line\">  run: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> km = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">6</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> wasteFuel = km / <span class=\"keyword\">this</span>.power;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.fuel &lt; wasteFuel) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'이동불가'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fuel -= wasteFuel;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.moved += km;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(km + <span class=\"string\">'km 이동 (총 '</span> + <span class=\"keyword\">this</span>.moved + <span class=\"string\">'km)'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>위 코드는 <code>run</code> 메서드를 실행할 때마다 <code>car</code>객체의 <code>fuel</code>, <code>moved</code> 값이 변합니다.</p>\n<p>하지만 자바스크립트를 아는사람이 <code>car</code>객체의 <code>fuel</code>, <code>power</code>, <code>moved</code>값을 직접 지정해 버린다면 공평한 게임이 되지 못합니다. </p>\n<ul>\n<li>이렇게 값을 바꾸지 못하도록 객체가 아닌 함수로 만들고, 필요한 맴버만을 <code>return</code>할 필요가 있습니다.</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>함수를 실행함으로써 객체 생성</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createCar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fuel = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">10</span> + <span class=\"number\">10</span>); <span class=\"comment\">// 연료(L)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> power = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">3</span> + <span class=\"number\">2</span>); <span class=\"comment\">// 연비(km / L)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> moved = <span class=\"number\">0</span>; <span class=\"comment\">// 총 이동거리</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> moved() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> moved;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    run: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> km = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">6</span>);</span><br><span class=\"line\">      <span class=\"keyword\">var</span> wasteFuel = km / power;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (fuel &lt; wasteFuel) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'이동불가'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      fuel -= wasteFuel;</span><br><span class=\"line\">      moved += km;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(km + <span class=\"string\">'km 이동 (총 '</span> + moved + <span class=\"string\">'km). 남은 연료: '</span> + fuel);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> car = createCar();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>createCar</code>라는 함수를 실행함으로써 객체를 생성하게 했습니다. <code>fuel</code>, <code>power</code> 변수는 비공개 맴버로 지정해 외부에서의 접근을 제한했고, <code>moved</code>변수는 <code>getter</code>만을 부여함으로써 “읽기전용” 속성을 부여했습니다.</p>\n</li>\n<li><p>이제 외부에서는 오직 <code>run</code>메서드를 실행하는 것과 현재의 <code>moved</code>값을 확인하는 두 가지 동작만 할 수 있습니다.</p>\n</li>\n<li><p><code>run</code>메서드를 다른 내용으로 덮어씌우는 어뷰징은 여전히 가능한 상태이긴 하지만 앞서의 코드보다 훨씬 안전한 코드가 됐습니다. 이런 어뷰징까지 막기 위해서는 객체를 <code>return</code>하기 전에 미리 변경할 수 없게끔 조치를 취해야 합니다.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>Object.freeze</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createCar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fuel = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">10</span> + <span class=\"number\">10</span>); <span class=\"comment\">// 연료(L)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> power = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">3</span> + <span class=\"number\">2</span>); <span class=\"comment\">// 연비(km / L)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> moved = <span class=\"number\">0</span>; <span class=\"comment\">// 총 이동거리</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> publicMembers = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> moved() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> moved;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    run: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> km = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">6</span>);</span><br><span class=\"line\">      <span class=\"keyword\">var</span> wasteFuel = km / power;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (fuel &lt; wasteFuel) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'이동불가'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      fuel -= wasteFuel;</span><br><span class=\"line\">      moved += km;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(km + <span class=\"string\">'km 이동 (총 '</span> + moved + <span class=\"string\">'km). 남은 연료: '</span> + fuel);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.freeze(publicMembers);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> publicMembers;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> car = createCar();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\">Object.freeze</a>를 사용하여 <code>publicMembers</code>객체를 동결객체로 만들었습니다.</li>\n</ul>\n<ul>\n<li><code>Object.freeze</code>메서드는 호출된 객체의 직속 속성만 동결하며 내부의 속성 값이 객체라면 그 객체는 동결되지 않아 추가/제거/재할당의 대상이 될 수 있으므로 (얕은동결) 주의하여야 합니다.</li>\n</ul>\n<hr>\n<h4 id=\"클로저를-활용해-접근권한-제어-방법-정리\"><a href=\"#클로저를-활용해-접근권한-제어-방법-정리\" class=\"headerlink\" title=\"클로저를 활용해 접근권한 제어 방법 정리\"></a>클로저를 활용해 접근권한 제어 방법 정리</h4><ol>\n<li><p>함수에서 지역변수 및 내부함수 등을 생성</p>\n</li>\n<li><p>외부에 접근권한을 주고자 하는 대상들로 구성된 참조형 데이터(대상이 여럿일 경우 객체 또는 배열, 하나일 경우 함수)를 return 합니다.</p>\n</li>\n<li><p>return한 변수들은 공개 맴버가 되고, 그렇지 않은 변수들은 비공개 맴버가 됩니다.</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"부분-적용-함수\"><a href=\"#부분-적용-함수\" class=\"headerlink\" title=\"부분 적용 함수\"></a>부분 적용 함수</h3><p>부분 적용 함수(<code>partially applied function</code>)란 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가. 나중에 나머지 인자를 넘길 때 원래 함수의 실행 결과를 얻을 수 있게 하는 함수입니다.</p>\n<p><code>this</code>를 바인딩해야 하는 점을 제외하면 <code>bind</code>메서드의 실행 결과가 바로 부분 적용 함수입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>bind - 부분 적용 함수</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">    result += <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> addPartial = add.bind(<span class=\"literal\">null</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(addPartial(<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>)); <span class=\"comment\">// 55</span></span><br></pre></td></tr></table></figure>\n\n<p><code>addPartial</code> 함수에 <code>this</code>값 <code>null</code>과 인자 5개를 미리 적용하고, 대기합니다.<br>추후에 추가적으로 인자들을 전달하며 호출하면 대기중이던 인자들과 차례대로 적용되어 실행합니다.</p>\n<p><code>add</code>함수는 <code>this</code>값을 사용하지 않지만, <code>bind</code>메서드는 <code>this</code>값을 변경할 수 밖에 없기 때문에 <code>this</code>에 관여하지 않는 다른 방법의 부분 적용 함수가 필요합니다.</p>\n<p>// p 135 ~ 137 보류</p>\n<p>디바운스(<code>debounce</code>)는 짧은 시간 동안 동일한 이벤트가 많이 발생한 경우 이를 전부 처리하지 않고 처음 또는 마지막에 발생한 이벤트에 대해 한 번만 처리하는 것으로, <code>scroll</code>, <code>wheel</code>, <code>mousemove</code>, <code>resize</code>등에 적용하기 좋습니다.</p>\n<figure class=\"highlight js\"><figcaption><span>부분 적용 함수 - 디바운스</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> debounce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventName, func, wait</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timeoutId = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(eventName, <span class=\"string\">'event 발생'</span>);</span><br><span class=\"line\">    clearTimeout(timeoutId);</span><br><span class=\"line\">    timeoutId = setTimeout(func.bind(self, event), wait);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> moveHandler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'move event 처리'</span>); &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> wheelHandler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'wheel event 처리'</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">'mousemove'</span>,</span><br><span class=\"line\">  debounce(<span class=\"string\">'move'</span>, moveHandler, <span class=\"number\">500</span>));</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.addEventListener(</span><br><span class=\"line\">  <span class=\"string\">'mousewheel'</span>,</span><br><span class=\"line\">  debounce(<span class=\"string\">'wheel'</span>, wheelHandler, <span class=\"number\">700</span>));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>debounce</code> 함수는 출력 용도로 지정한 <code>eventName</code>과 실행할 함수(<code>func</code>),마지막으로 발생한 이벤트인지 여부를 판단하기 위한 대기시간 (<code>wait(</code>(ms))을 받습니다.</li>\n</ul>\n<ul>\n<li>내부에서는 <code>timeoutId</code> 변수를 생성하고, 클로저로 <code>EventListener</code>에 의해 호출될 함수를 반환합니다. 반환될 함수 내부에서는 <code>setTimeout</code>을 사용하기 위해 <code>this</code>를 별도의 변수에 담고 <code>clearTimeout</code>으로 대기큐를 초기화하게 했습니다.</li>\n</ul>\n<ul>\n<li>마지막으로 <code>setTimeout</code>으로 <code>wait</code> 시간만큼 지연시킨 다음, 원래의 <code>func</code>를 호출하는 형태입니다.</li>\n</ul>\n<ul>\n<li>최초의 event가 발생하면 <code>timeoutId = setTimeout(func,bind(self,event),wait)</code>에 의해 timeout의 대기열에 ‘wait 시간 뒤에 func를 실행 함’이라는 내용이 담깁니다. 그런데 <code>wait</code>시간이 경과하기 전에 동일한 event가 발생하게 되면 앞의 <code>clearTimeout(timeoutId)</code>에 의해 앞에 저장했던 대기열을 초기화하고, 다시 <code>timeoutId = setTimeout(func,bind(self,event),wait)</code>에서 새로운 대기열을 등록합니다.</li>\n</ul>\n<ul>\n<li>결국 각 동일한 이벤트가 이전 이벤트로 부터 <code>wait</code>시간 내에 다시 발생하는 한 마지막에 발생한 이벤트만이 초기화되지 않고 실행됩니다.</li>\n</ul>\n<ul>\n<li><code>debounce</code>함수에서 클로저로 처리되는 변수는 <code>eventName</code>, <code>func</code>, <code>wait</code>, <code>timeoutId</code>입니다.</li>\n</ul>\n<hr>\n<h3 id=\"커링-함수\"><a href=\"#커링-함수\" class=\"headerlink\" title=\"커링 함수\"></a>커링 함수</h3><hr>\n<h2 id=\"closure\">정리</h2>\n\n<ul>\n<li>클로저란 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상입니다.</li>\n</ul>\n<ul>\n<li>내부 함수를 외부로 전달하는 방법에는 함수를 return하는 경우뿐아니라 콜백으로 전달하는 경우도 포함됩니다.</li>\n</ul>\n<ul>\n<li>클로저는 그 본질이 메모리를 계속 차지하는 개념이므로 더는 사용하지 않게 된 클로저에 대해서는 메모리를 차지하지 않도록 관리해줄 필요가 있습니다.</li>\n</ul>"},{"title":"prototype -Core JavaScript","disqusId":"tunas-blog-1","date":"2020-05-05T08:57:53.000Z","toc":true,"widgets":[{"type":"toc","position":"right"},{"type":"categories","position":"right"},{"type":"tags","position":"right"},{"type":"adsense","position":"right"}],"sidebar":{"right":{"sticky":true}},"_content":"\n* 프로토타입 (prototype)\n  * [프로토타입의 개념 이해](/2020/05/05/prototype-Core-JavaScript/#프로토타입의-개념-이해)\n    * constructor, prototype, instance\n    * constructor 프로퍼티\n  * [프로토타입 체인](/2020/05/05/prototype-Core-JavaScript/#prototype_chain)\n    * 메서드 오버라이드\n    * 프로토타입 체인\n    * 객체 전용 메서드의 예외사항\n    * 다중 프로토타입 체인\n  * [정리](/2020/05/05/prototype-Core-JavaScript/#)\n\n<!-- more -->\n\n------\n<h2 id=\"프로포타입의-개념-이해\">프로토타입의 개념 이해</h2>\n\n### constructor, prototype, instance\n\n> var instance = new Constructor();\n\n위 코드를 추상화 하여 나타내면 다음과 같습니다.\n\n![prototype schematic](/images/prototype_schematic.png)\n\n윗변(실선)의 왼쪽 꼭지점에는 `Constructor`(생성자 함수)를, 오른쪽 꼭짓점에는 `Constructor.prototype`이라는 프로퍼티를 위치시켰습니다.\n왼쪽 꼭짓점부터 아래를 향한 화살표 중간에 `new`가 있고, 화살표의 종점에는 `instance`가 있습니다.\n오른쪽 꼭짓점으로부터 대각선 아래로 향하는 화살표의 종점에는 `instance.__proto__`이라는 프로퍼티를 위치시켰습니다. \n\n------\n\n* 어떤 생성자 함수(`Constructor`)를 `new` 연산자와 함께 호출하면\n\n* `Constructor`에서 정의된 내용을 바탕으로 새로운 인스턴스(`instance`)가 생성됩니다.\n\n* 이떄 `instance`에는 `__proto__`라는 프로퍼티가 자동으로 부여되는데,\n\n* 이 프로퍼티는 `Constructor`의 `prototype`이라는 프로퍼티를 참조합니다.\n\n`prototype`이라는 프로퍼티와 `__proto__` <mark>이 둘의 관계가 프로토타입 개념의 핵심입니다.</mark>\n\n`prototype`은 객체입니다. 이를 참조하는 `__proto__` 역시 객체입니다.\n\n`prototype` 객체 내부에는 `instance`가 사용할 메서드를 저장합니다. 그러면 `instance`에서도 숨겨진 프로퍼티인 `__proto__`를 통해 이 메서드들에 접근할 수 있게 됩니다.\n\n------\n\n```js Person이라는 생성자 함수의 prototype에 getName이라는 메서드를 지정한 예제\nvar Person = function(name) {\n  this._name = name;\n};\nPerson.prototype.getName = function() {\n  return this._name;\n};\n```\n이제 `Person`의 `instance`는 `__proto__`프로퍼티를 통해 `getName`을 호출할 수 있습니다.\n`instance`의 `__proto__`가 `Constructor`의 `prototype`프로퍼티를 참조하므로 결국 둘은 같은 객체를 바라보기 때문입니다.\n\n```js this 바인딩 값\nvar suzi = new Person('Suzi');\nsuzi.__proto__.getName(); //undefined\n\nPerson.prototype === suzi.__proto__ // true\n```\n\n* `suzi.__proto__.getName();`를 실행해 `undefined`가 나왔다는 것은 이 변수가 \"호출할 수 있는 함수\"에 해당한다는 것을 의미합니다. \n\n\n* 만약 함수가 아닌 다른 데이터 값이었다면 `TypeError`가 발생했을 것입니다. 에러가 아닌 `undefined`를 반환했으므로 `getName`이 실제로 실행됐고 `getName`이 함수라는 것이 입증됐습니다.\n\n\n* `undefined`를 반환한 이유는 `this`의 바인딩 값이 잘못됐음을 의미합니다.\n\n\n* `suzi.__proto__.getName();`에서 `getName` 함수 내부에서의 `this`는 `suzi`가 아니라 메서드명 바로앞의 객체 즉, `suzi.__proto__`를 참조하게 되는 것입니다. \n\n\n* `suzi.__proto__` 내부에 `name`프로퍼티가 없으므로 엔진이 \"데이터 영역에 지정되지 않은 식별자에 접근할 때\"를 뜻하는 `undefined`를 반환하게 됩니다. \n\n------\n\n`__proto__` 객체에 `name` 프로퍼티가 있다면 `undefined`가 아니라 프로퍼티 값이 출력 되겠죠?\n\n```js\nvar suzi = new Person('Suzi');\nsuzi.__proto__._name = 'SUZI__proto__';\nsuzi.__proto__.getName(); // SUZI__proto__\n```\n\n위 예제 코드들의 관건은 `this`가 어떤 값을 참조하게 되는가 였습니다.\n`this`가 `instance`를 참조하게 하는 방법은 간단합니다.\n`__proto__`를 생략하고 `instance`뒤에 바로 메서드를 작성하면 됩니다.\n\n```js __proto__ 생략\nvar suzi = new Person('Suzi', 28);\nsuzi.getName(); // Suzi\n```\n\n이런 코드가 실행되는 이유는 `__proto__`가 생략 가능한 프로퍼티이기 때문입니다.\n\n```js\nsuzi.__proto__.getName\n> suzi(.__proto__).getName\n== suzi.getName\n```\n\n* 정리하면 \n  * `__proto__`를 생략하지 않으면 `this`는 `suzi.__proto__`를 참조 (내부에 name프로퍼티 존재하지 않음)\n  * 생략하면 `suzi`를 참조 가능해짐. (suzi.getName 형태, name 프로퍼티 존재)\n\n  ![prototype schematic2](/images/prototype_schematic2.png)\n\n  * new 연산자로 `Constructor` 호출시 `instance` 생성되고 \n  `instance`의 생략가능한 프로퍼티인 `__proto__`는 \n  `Constructor`의 `prototype`을 참조\n\n```js prototype과 __proto__\nvar Constructor = function(name) {\n  this.name = name;\n};\nConstructor.prototype.method1 = function() {};\nConstructor.prototype.property1 = 'Constructor Prototype Property';\n\nvar instance = new Constructor('Instance');\nconsole.dir(Constructor); //Constructor의 디렉터리 구조 출력\nconsole.dir(instance); //instance의 디렉터리 구조 출력\n```\n* 위 예제를 크롬 개발자도구에서 실행한 결과\n\n![prototype Constructor](/images/prototype_Constructor.png)\n\n* `Constructor`의 디렉터리 구조를 출력한\n  * 첫 번째 줄에 함수라는 의미의 `f` 와 함수이름 `Constructor`, 인자 `name`이 출력되었습니다.\n  * 그 내부에는 <mark>옅은 색</mark>의 argument, caller, length, name, `prototype`, &#95;&#95;proto&#95;&#95;등의 프로퍼티들이 나타납니다.\n  * 내부 프로퍼티중 `prototype`을 열면 개발자가 직접 추가한 `metod1`, `property1`등의 값은 <mark>짙은 색</mark>으로 보이고, constructor, &#95;&#95;proto&#95;&#95; 등은 <mark>옅은 색</mark>으로 보입니다.\n        이런 색상의 차이는 { enumerable: false } 속성이 부여된 프로퍼티인지 여부에 따릅니다.\n        짙은 색은 enumerable, 즉 열거 가능한 프로퍼티임을 의미하고, \n        옅은 색은 innumerable, 즉 열거할 수 없는 프로퍼티입니다.\n        for in 문 등으로 객체의 프로퍼티 전체에 접근할 때 접근 가능 여부를 \n        색상으로 구분지어 표기하는 것입니다.\n\n<div align=\"center\">\n\n![prototype Instance](/images/prototype_Instance.png)\n</div>\n\n* `instance`의 디렉터리 구조를 출력한\n  * 첫 번째 줄에 `Constructor`가 출력됩니다.\n  생성자 함수의 `instance`는 해당 생성자 함수의 이름을 표기함으로 \n  해당 함수의 `instance`임을 나타냅니다.\n  * `Constructor`를 열어보면 `name`프로퍼티가 짙은 색으로 표기되고, `__proto__`프로퍼티가 옅은 색으로 표기됩니다.\n  * `__proto__`를 열어보면 `method1`, `property1`, `constructor`, `__proto__` 등이 있으므로,\n  `Constructor`의 `prototype`과 동일한 내용으로 구성돼 있음을 확인할 수 있습니다.\n\n------\n#### 내장(built-in) 생성자 함수 Array 구조\n\n```js Array\nvar arr = [1, 2];\nconsole.dir(arr);\nconsole.dir(Array);\n```\n\n![prototype arr and Array](/images/prototype_arr_Array.png)\n\n* arr\n  * 첫 줄에 `Array(2)`가 표기됩니다.\n  * `Array` 생성자 함수를 원본으로 생성됐고, `length` 값 2를 알 수 있습니다.\n  * `index 0, 1`은 짙은 색으로 length와 &#95;&#95;proto&#95;&#95;는 옅은 색으로 표기됩니다.\n  * &#95;&#95;proto&#95;&#95; 에는 Array 메서드 들이 포함되어 있습니다.\n\n* Array\n  * 첫 줄에 함수를 뜻하는 `f`가 표시됩니다.\n  * 함수의 프로퍼티인 `argument`, `caller`, `length`, `name`등이 표기됩니다.\n  * 또한 `Array` 함수의 정적 메서드 `from`, `isArray` `of` 등도 있습니다.\n  * `prototype`을 열어보면 왼쪽(arr)의 &#95;&#95;proto&#95;&#95;와 동일한 구성임을 확인할 수 있습니다.\n\n\n* 위 결과를 도식으로 나타면 다음과 같습니다.\n![prototype Array schematic](/images/prototype_Array_schematic.png)\n\n* Array를 new 연산자와 함께 호출하든, 배열 리터럴을 생성하든 `instance`인 [1, 2]가 만들어집니다.\n\n\n* `instance`의 `__proto__`은 Array.prototype을 참조함으로 `instance`가 push, pop, forEach 등 Array 메서드를 자신의 것처럼 호출할 수 있습니다.(`__proto__`가 생략 가능하도록 설계돼 있기 때문에)\n\n\n* **한편 `Array의 prototype 프로퍼티 내부`에 있지 않은 `from, isArray` 등의 메서드들은 `instance`가 직접 호출할 수 없습니다. 이들은 `Array 생성자 함수`에서 직접 접근해야 실행 가능합니다.**\n\n```js\n// Array 생성자 함수를 원본으로하는 instance인 arr\nvar arr = [1, 2];\n\n// __proto__ 생략 가능으로 인한 Array 메서드 직접 호출 \narr.forEach(function (){}); // (o)\n\n// Array의 prototype 프로퍼티 내부에 없는 메서드는\n// instance가 직접 호출 불가능\narr.isArray(); // (x) TypeError: arr.isArray is not a function\n\n// Array 생성자 함수에서 직접 접근하여 실행해야 됨\nArray.isArray(arr); // (o) true\n```\n\n------\n### constructor 프로퍼티\n\n`생성자 함수`의 프로퍼티인 `prototype` 객체 내부에는 `constructor` 프로퍼티가 있습니다.\n`instance`의 `__proto__` 객체 내부에도 마찬가지로 존재합니다.\n`constructor` 프로퍼티는 원래의 생성자 함수(자기 자신)를 참조하고, \n`instance`로부터 그 원형을 알 수 있는 수단으로 `instance`와의 관계에 있어 필요한 정보입니다.\n\n```js constructor 프로퍼티 \nvar arr = [1, 2];\nArray.prototype.constructor === Array; // true\narr.__proto__.constructor === Array; // true\narr.constructor === Array; // true\n\nvar arr2 = new arr.constructor(3, 4);\nconsole.log(arr2); // [3, 4]\n```\n\n------\n#### 다양한 constructor 접근 방법\n\n```js\nvar Person = function(name) {\n  this.name = name;\n};\nvar p1 = new Person('사람1'); // Person { name: \"사람1\" } true\nvar p1Proto = Object.getPrototypeOf(p1);\nvar p2 = new Person.prototype.constructor('사람2'); // Person { name: \"사람2\" } true\nvar p3 = new p1Proto.constructor('사람3'); // Person { name: \"사람3\" } true\nvar p4 = new p1.__proto__.constructor('사람4'); // Person { name: \"사람4\" } true\nvar p5 = new p1.constructor('사람5'); // Person { name: \"사람5\" } true\n\n[p1, p2, p3, p4, p5].forEach(function(p) {\n  console.log(p, p instanceof Person);\n});\n```\n\n* **다음은 모두 동일한 대상을 가리키게 됩니다.**\n\n        \n        1. [Constructor]\n\n        2. [instance].__proto__.constructor\n        \n        3. [instance].constructor\n        \n        4. Object.getPrototypeOf([instance]).constructor\n        \n        5. [Constructor].prototype.constructor\n\n\n* **다음은 모두 동일한 객체에 접근할 수 있습니다.**\n    \n\n      1. [Constructor].prototype\n    \n      2. [instance].__proto__\n    \n      3. [instance]\n    \n      4. Object.getPrototypeOf([instance])\n\n\n* 따라서 p1 부터 p5까지 모두 Person의 instance입니다.\n\n------\n<h2 id=\"prototype_chain\">프로토타입 체인</h2>\n\n------\n### 메서드 오버라이드\n\n`instance`가 동일한 이름의 프로퍼티 또는 메서드를 가지고 있는 상황이라면\n\n`instance.method()` 형태로 호출했을 때\n`instance.__proto__.method`가 아닌 `instance`객체에 있는 해당 `method`가 호출됩니다.\n여기서 일어난 현상을 메서드 위에 메서드를 덮어씌웠다고 하여 <mark>메서드 오버라이드</mark>라고합니다.\n\n* 자바스크립트 엔진은 프로퍼티(혹은 메서드)를 찾을 때 가장 가까운 대상인 자신의 프로퍼티를 먼저 검색하고, 없으면 그다음으로 가까운 대상인 &#95;&#95;proto&#95;&#95;를 검색합니다.\n그러므로 메서드 오버라이드 됐을 때 &#95;&#95;proto&#95;&#95;에 있는 메서드는 우선 순위에서 밀려 호출되지 않는 것입니다.\n\n------\n#### 메서드 오버라이드된 상태에서 prototype에 있는 메서드에 접근법\n\n> instance.&#95;&#95;proto&#95;&#95;.method()\n\n형태로 호출하면 정상적으로 `prototype`에 있는 `method`에 접근할 수 있습니다.\n하지만 `this`가 `instance`를 바라보지 않고 있습니다.\n\n`call`이나 `apply`를 사용하면\n> instance.&#95;&#95;proto&#95;&#95;.method.call(thisArg) 형태로 작성하여 `this` 대상을 지정합니다.\n\n------\n### 프로토타입 체인\n\n<mark>자바스크립트의 모든 객체의 최상위 객체에는 Object 객체가 존재합니다.</mark>\n\n따라서 모든 객체의 `__proto__`에는 `Object.prototype`이 연결됩니다.\n\n**Array 객체를 예시로 든 최상위 객체 Object와의 구조 도식(~~prototype 역시 객체입니다.~~)**\n\n![객체의 최상위 객체 Object](/images/객체의_최상위_객체_Object.png)\n\n\n* 앞에서 `__proto__`는 생략가능한 프로퍼티이므로 `배열[]`에서 `Array.prototype` 내부의 메서드를 직접 호출할 수 있었습니다. \n\n* 마찬가지로 `배열[]`의 `__proto__`를 계속 따라가다 보면 `Object.prototype`이 있으므로 `Object.prototype`의 내부 메서드도 직접 호출할 수 있습니다.\n\n------\n이러한 `__proto__` 프로퍼티 내부에 다시 `__proto__`프로퍼티가 연쇄적으로 이어진 것을 \n**프로토타입 체인**(`prototype chain`)이라 하고, \n\n이 체인을 따라 검색하는 것을 **프로토타입 체이닝**(`prototype chaining`)이라고 합니다.\n\n------\n### 객체 전용 메서드의 예외사항\n\n어떤 생성자 함수이든 `prototype`은 객체이기 때문에 `Object.prototype`이 언제나 프로토타입 체인의 최상단에 존재하게 됩니다.\n\n따라서 **객체에서만 사용할 메서드는 다른 데이터 타입처럼 프로토타입 객체 안에 정의할 수 없습니다.**\n\n**객체에서만 사용할 메서드를 `Object.prototype`내부에 정의한다면 다른 데이터 타입도 해당 메서드를 사용할 수 있게 되기 때문입니다.**","source":"_posts/prototype-Core-JavaScript.md","raw":"---\ntitle: prototype -Core JavaScript\ndisqusId: tunas-blog-1\ntags:\n  - Core JavaScript\n  - JavaScript\ndate: 2020-05-05 17:57:53\ncategories: Core JavaScript\ntoc: true\n\nwidgets:\n  - type: toc\n    position: right\n  - type: categories\n    position: right\n  - type: tags\n    position: right\n  - type: adsense\n    position: right\n      \nsidebar:\n  right:\n    sticky: true\n---\n\n* 프로토타입 (prototype)\n  * [프로토타입의 개념 이해](/2020/05/05/prototype-Core-JavaScript/#프로토타입의-개념-이해)\n    * constructor, prototype, instance\n    * constructor 프로퍼티\n  * [프로토타입 체인](/2020/05/05/prototype-Core-JavaScript/#prototype_chain)\n    * 메서드 오버라이드\n    * 프로토타입 체인\n    * 객체 전용 메서드의 예외사항\n    * 다중 프로토타입 체인\n  * [정리](/2020/05/05/prototype-Core-JavaScript/#)\n\n<!-- more -->\n\n------\n<h2 id=\"프로포타입의-개념-이해\">프로토타입의 개념 이해</h2>\n\n### constructor, prototype, instance\n\n> var instance = new Constructor();\n\n위 코드를 추상화 하여 나타내면 다음과 같습니다.\n\n![prototype schematic](/images/prototype_schematic.png)\n\n윗변(실선)의 왼쪽 꼭지점에는 `Constructor`(생성자 함수)를, 오른쪽 꼭짓점에는 `Constructor.prototype`이라는 프로퍼티를 위치시켰습니다.\n왼쪽 꼭짓점부터 아래를 향한 화살표 중간에 `new`가 있고, 화살표의 종점에는 `instance`가 있습니다.\n오른쪽 꼭짓점으로부터 대각선 아래로 향하는 화살표의 종점에는 `instance.__proto__`이라는 프로퍼티를 위치시켰습니다. \n\n------\n\n* 어떤 생성자 함수(`Constructor`)를 `new` 연산자와 함께 호출하면\n\n* `Constructor`에서 정의된 내용을 바탕으로 새로운 인스턴스(`instance`)가 생성됩니다.\n\n* 이떄 `instance`에는 `__proto__`라는 프로퍼티가 자동으로 부여되는데,\n\n* 이 프로퍼티는 `Constructor`의 `prototype`이라는 프로퍼티를 참조합니다.\n\n`prototype`이라는 프로퍼티와 `__proto__` <mark>이 둘의 관계가 프로토타입 개념의 핵심입니다.</mark>\n\n`prototype`은 객체입니다. 이를 참조하는 `__proto__` 역시 객체입니다.\n\n`prototype` 객체 내부에는 `instance`가 사용할 메서드를 저장합니다. 그러면 `instance`에서도 숨겨진 프로퍼티인 `__proto__`를 통해 이 메서드들에 접근할 수 있게 됩니다.\n\n------\n\n```js Person이라는 생성자 함수의 prototype에 getName이라는 메서드를 지정한 예제\nvar Person = function(name) {\n  this._name = name;\n};\nPerson.prototype.getName = function() {\n  return this._name;\n};\n```\n이제 `Person`의 `instance`는 `__proto__`프로퍼티를 통해 `getName`을 호출할 수 있습니다.\n`instance`의 `__proto__`가 `Constructor`의 `prototype`프로퍼티를 참조하므로 결국 둘은 같은 객체를 바라보기 때문입니다.\n\n```js this 바인딩 값\nvar suzi = new Person('Suzi');\nsuzi.__proto__.getName(); //undefined\n\nPerson.prototype === suzi.__proto__ // true\n```\n\n* `suzi.__proto__.getName();`를 실행해 `undefined`가 나왔다는 것은 이 변수가 \"호출할 수 있는 함수\"에 해당한다는 것을 의미합니다. \n\n\n* 만약 함수가 아닌 다른 데이터 값이었다면 `TypeError`가 발생했을 것입니다. 에러가 아닌 `undefined`를 반환했으므로 `getName`이 실제로 실행됐고 `getName`이 함수라는 것이 입증됐습니다.\n\n\n* `undefined`를 반환한 이유는 `this`의 바인딩 값이 잘못됐음을 의미합니다.\n\n\n* `suzi.__proto__.getName();`에서 `getName` 함수 내부에서의 `this`는 `suzi`가 아니라 메서드명 바로앞의 객체 즉, `suzi.__proto__`를 참조하게 되는 것입니다. \n\n\n* `suzi.__proto__` 내부에 `name`프로퍼티가 없으므로 엔진이 \"데이터 영역에 지정되지 않은 식별자에 접근할 때\"를 뜻하는 `undefined`를 반환하게 됩니다. \n\n------\n\n`__proto__` 객체에 `name` 프로퍼티가 있다면 `undefined`가 아니라 프로퍼티 값이 출력 되겠죠?\n\n```js\nvar suzi = new Person('Suzi');\nsuzi.__proto__._name = 'SUZI__proto__';\nsuzi.__proto__.getName(); // SUZI__proto__\n```\n\n위 예제 코드들의 관건은 `this`가 어떤 값을 참조하게 되는가 였습니다.\n`this`가 `instance`를 참조하게 하는 방법은 간단합니다.\n`__proto__`를 생략하고 `instance`뒤에 바로 메서드를 작성하면 됩니다.\n\n```js __proto__ 생략\nvar suzi = new Person('Suzi', 28);\nsuzi.getName(); // Suzi\n```\n\n이런 코드가 실행되는 이유는 `__proto__`가 생략 가능한 프로퍼티이기 때문입니다.\n\n```js\nsuzi.__proto__.getName\n> suzi(.__proto__).getName\n== suzi.getName\n```\n\n* 정리하면 \n  * `__proto__`를 생략하지 않으면 `this`는 `suzi.__proto__`를 참조 (내부에 name프로퍼티 존재하지 않음)\n  * 생략하면 `suzi`를 참조 가능해짐. (suzi.getName 형태, name 프로퍼티 존재)\n\n  ![prototype schematic2](/images/prototype_schematic2.png)\n\n  * new 연산자로 `Constructor` 호출시 `instance` 생성되고 \n  `instance`의 생략가능한 프로퍼티인 `__proto__`는 \n  `Constructor`의 `prototype`을 참조\n\n```js prototype과 __proto__\nvar Constructor = function(name) {\n  this.name = name;\n};\nConstructor.prototype.method1 = function() {};\nConstructor.prototype.property1 = 'Constructor Prototype Property';\n\nvar instance = new Constructor('Instance');\nconsole.dir(Constructor); //Constructor의 디렉터리 구조 출력\nconsole.dir(instance); //instance의 디렉터리 구조 출력\n```\n* 위 예제를 크롬 개발자도구에서 실행한 결과\n\n![prototype Constructor](/images/prototype_Constructor.png)\n\n* `Constructor`의 디렉터리 구조를 출력한\n  * 첫 번째 줄에 함수라는 의미의 `f` 와 함수이름 `Constructor`, 인자 `name`이 출력되었습니다.\n  * 그 내부에는 <mark>옅은 색</mark>의 argument, caller, length, name, `prototype`, &#95;&#95;proto&#95;&#95;등의 프로퍼티들이 나타납니다.\n  * 내부 프로퍼티중 `prototype`을 열면 개발자가 직접 추가한 `metod1`, `property1`등의 값은 <mark>짙은 색</mark>으로 보이고, constructor, &#95;&#95;proto&#95;&#95; 등은 <mark>옅은 색</mark>으로 보입니다.\n        이런 색상의 차이는 { enumerable: false } 속성이 부여된 프로퍼티인지 여부에 따릅니다.\n        짙은 색은 enumerable, 즉 열거 가능한 프로퍼티임을 의미하고, \n        옅은 색은 innumerable, 즉 열거할 수 없는 프로퍼티입니다.\n        for in 문 등으로 객체의 프로퍼티 전체에 접근할 때 접근 가능 여부를 \n        색상으로 구분지어 표기하는 것입니다.\n\n<div align=\"center\">\n\n![prototype Instance](/images/prototype_Instance.png)\n</div>\n\n* `instance`의 디렉터리 구조를 출력한\n  * 첫 번째 줄에 `Constructor`가 출력됩니다.\n  생성자 함수의 `instance`는 해당 생성자 함수의 이름을 표기함으로 \n  해당 함수의 `instance`임을 나타냅니다.\n  * `Constructor`를 열어보면 `name`프로퍼티가 짙은 색으로 표기되고, `__proto__`프로퍼티가 옅은 색으로 표기됩니다.\n  * `__proto__`를 열어보면 `method1`, `property1`, `constructor`, `__proto__` 등이 있으므로,\n  `Constructor`의 `prototype`과 동일한 내용으로 구성돼 있음을 확인할 수 있습니다.\n\n------\n#### 내장(built-in) 생성자 함수 Array 구조\n\n```js Array\nvar arr = [1, 2];\nconsole.dir(arr);\nconsole.dir(Array);\n```\n\n![prototype arr and Array](/images/prototype_arr_Array.png)\n\n* arr\n  * 첫 줄에 `Array(2)`가 표기됩니다.\n  * `Array` 생성자 함수를 원본으로 생성됐고, `length` 값 2를 알 수 있습니다.\n  * `index 0, 1`은 짙은 색으로 length와 &#95;&#95;proto&#95;&#95;는 옅은 색으로 표기됩니다.\n  * &#95;&#95;proto&#95;&#95; 에는 Array 메서드 들이 포함되어 있습니다.\n\n* Array\n  * 첫 줄에 함수를 뜻하는 `f`가 표시됩니다.\n  * 함수의 프로퍼티인 `argument`, `caller`, `length`, `name`등이 표기됩니다.\n  * 또한 `Array` 함수의 정적 메서드 `from`, `isArray` `of` 등도 있습니다.\n  * `prototype`을 열어보면 왼쪽(arr)의 &#95;&#95;proto&#95;&#95;와 동일한 구성임을 확인할 수 있습니다.\n\n\n* 위 결과를 도식으로 나타면 다음과 같습니다.\n![prototype Array schematic](/images/prototype_Array_schematic.png)\n\n* Array를 new 연산자와 함께 호출하든, 배열 리터럴을 생성하든 `instance`인 [1, 2]가 만들어집니다.\n\n\n* `instance`의 `__proto__`은 Array.prototype을 참조함으로 `instance`가 push, pop, forEach 등 Array 메서드를 자신의 것처럼 호출할 수 있습니다.(`__proto__`가 생략 가능하도록 설계돼 있기 때문에)\n\n\n* **한편 `Array의 prototype 프로퍼티 내부`에 있지 않은 `from, isArray` 등의 메서드들은 `instance`가 직접 호출할 수 없습니다. 이들은 `Array 생성자 함수`에서 직접 접근해야 실행 가능합니다.**\n\n```js\n// Array 생성자 함수를 원본으로하는 instance인 arr\nvar arr = [1, 2];\n\n// __proto__ 생략 가능으로 인한 Array 메서드 직접 호출 \narr.forEach(function (){}); // (o)\n\n// Array의 prototype 프로퍼티 내부에 없는 메서드는\n// instance가 직접 호출 불가능\narr.isArray(); // (x) TypeError: arr.isArray is not a function\n\n// Array 생성자 함수에서 직접 접근하여 실행해야 됨\nArray.isArray(arr); // (o) true\n```\n\n------\n### constructor 프로퍼티\n\n`생성자 함수`의 프로퍼티인 `prototype` 객체 내부에는 `constructor` 프로퍼티가 있습니다.\n`instance`의 `__proto__` 객체 내부에도 마찬가지로 존재합니다.\n`constructor` 프로퍼티는 원래의 생성자 함수(자기 자신)를 참조하고, \n`instance`로부터 그 원형을 알 수 있는 수단으로 `instance`와의 관계에 있어 필요한 정보입니다.\n\n```js constructor 프로퍼티 \nvar arr = [1, 2];\nArray.prototype.constructor === Array; // true\narr.__proto__.constructor === Array; // true\narr.constructor === Array; // true\n\nvar arr2 = new arr.constructor(3, 4);\nconsole.log(arr2); // [3, 4]\n```\n\n------\n#### 다양한 constructor 접근 방법\n\n```js\nvar Person = function(name) {\n  this.name = name;\n};\nvar p1 = new Person('사람1'); // Person { name: \"사람1\" } true\nvar p1Proto = Object.getPrototypeOf(p1);\nvar p2 = new Person.prototype.constructor('사람2'); // Person { name: \"사람2\" } true\nvar p3 = new p1Proto.constructor('사람3'); // Person { name: \"사람3\" } true\nvar p4 = new p1.__proto__.constructor('사람4'); // Person { name: \"사람4\" } true\nvar p5 = new p1.constructor('사람5'); // Person { name: \"사람5\" } true\n\n[p1, p2, p3, p4, p5].forEach(function(p) {\n  console.log(p, p instanceof Person);\n});\n```\n\n* **다음은 모두 동일한 대상을 가리키게 됩니다.**\n\n        \n        1. [Constructor]\n\n        2. [instance].__proto__.constructor\n        \n        3. [instance].constructor\n        \n        4. Object.getPrototypeOf([instance]).constructor\n        \n        5. [Constructor].prototype.constructor\n\n\n* **다음은 모두 동일한 객체에 접근할 수 있습니다.**\n    \n\n      1. [Constructor].prototype\n    \n      2. [instance].__proto__\n    \n      3. [instance]\n    \n      4. Object.getPrototypeOf([instance])\n\n\n* 따라서 p1 부터 p5까지 모두 Person의 instance입니다.\n\n------\n<h2 id=\"prototype_chain\">프로토타입 체인</h2>\n\n------\n### 메서드 오버라이드\n\n`instance`가 동일한 이름의 프로퍼티 또는 메서드를 가지고 있는 상황이라면\n\n`instance.method()` 형태로 호출했을 때\n`instance.__proto__.method`가 아닌 `instance`객체에 있는 해당 `method`가 호출됩니다.\n여기서 일어난 현상을 메서드 위에 메서드를 덮어씌웠다고 하여 <mark>메서드 오버라이드</mark>라고합니다.\n\n* 자바스크립트 엔진은 프로퍼티(혹은 메서드)를 찾을 때 가장 가까운 대상인 자신의 프로퍼티를 먼저 검색하고, 없으면 그다음으로 가까운 대상인 &#95;&#95;proto&#95;&#95;를 검색합니다.\n그러므로 메서드 오버라이드 됐을 때 &#95;&#95;proto&#95;&#95;에 있는 메서드는 우선 순위에서 밀려 호출되지 않는 것입니다.\n\n------\n#### 메서드 오버라이드된 상태에서 prototype에 있는 메서드에 접근법\n\n> instance.&#95;&#95;proto&#95;&#95;.method()\n\n형태로 호출하면 정상적으로 `prototype`에 있는 `method`에 접근할 수 있습니다.\n하지만 `this`가 `instance`를 바라보지 않고 있습니다.\n\n`call`이나 `apply`를 사용하면\n> instance.&#95;&#95;proto&#95;&#95;.method.call(thisArg) 형태로 작성하여 `this` 대상을 지정합니다.\n\n------\n### 프로토타입 체인\n\n<mark>자바스크립트의 모든 객체의 최상위 객체에는 Object 객체가 존재합니다.</mark>\n\n따라서 모든 객체의 `__proto__`에는 `Object.prototype`이 연결됩니다.\n\n**Array 객체를 예시로 든 최상위 객체 Object와의 구조 도식(~~prototype 역시 객체입니다.~~)**\n\n![객체의 최상위 객체 Object](/images/객체의_최상위_객체_Object.png)\n\n\n* 앞에서 `__proto__`는 생략가능한 프로퍼티이므로 `배열[]`에서 `Array.prototype` 내부의 메서드를 직접 호출할 수 있었습니다. \n\n* 마찬가지로 `배열[]`의 `__proto__`를 계속 따라가다 보면 `Object.prototype`이 있으므로 `Object.prototype`의 내부 메서드도 직접 호출할 수 있습니다.\n\n------\n이러한 `__proto__` 프로퍼티 내부에 다시 `__proto__`프로퍼티가 연쇄적으로 이어진 것을 \n**프로토타입 체인**(`prototype chain`)이라 하고, \n\n이 체인을 따라 검색하는 것을 **프로토타입 체이닝**(`prototype chaining`)이라고 합니다.\n\n------\n### 객체 전용 메서드의 예외사항\n\n어떤 생성자 함수이든 `prototype`은 객체이기 때문에 `Object.prototype`이 언제나 프로토타입 체인의 최상단에 존재하게 됩니다.\n\n따라서 **객체에서만 사용할 메서드는 다른 데이터 타입처럼 프로토타입 객체 안에 정의할 수 없습니다.**\n\n**객체에서만 사용할 메서드를 `Object.prototype`내부에 정의한다면 다른 데이터 타입도 해당 메서드를 사용할 수 있게 되기 때문입니다.**","slug":"prototype-Core-JavaScript","published":1,"updated":"2020-05-08T12:28:32.794Z","_id":"ck9tojqol0007mkvqaxvyhr8d","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>프로토타입 (prototype)<ul>\n<li><a href=\"/2020/05/05/prototype-Core-JavaScript/#프로토타입의-개념-이해\">프로토타입의 개념 이해</a><ul>\n<li>constructor, prototype, instance</li>\n<li>constructor 프로퍼티</li>\n</ul>\n</li>\n<li><a href=\"/2020/05/05/prototype-Core-JavaScript/#prototype_chain\">프로토타입 체인</a><ul>\n<li>메서드 오버라이드</li>\n<li>프로토타입 체인</li>\n<li>객체 전용 메서드의 예외사항</li>\n<li>다중 프로토타입 체인</li>\n</ul>\n</li>\n<li><a href=\"/2020/05/05/prototype-Core-JavaScript/#\">정리</a></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<hr>\n<h2 id=\"프로포타입의-개념-이해\">프로토타입의 개념 이해</h2>\n\n<h3 id=\"constructor-prototype-instance\"><a href=\"#constructor-prototype-instance\" class=\"headerlink\" title=\"constructor, prototype, instance\"></a>constructor, prototype, instance</h3><blockquote>\n<p>var instance = new Constructor();</p>\n</blockquote>\n<p>위 코드를 추상화 하여 나타내면 다음과 같습니다.</p>\n<p><img src=\"/images/prototype_schematic.png\" alt=\"prototype schematic\"></p>\n<p>윗변(실선)의 왼쪽 꼭지점에는 <code>Constructor</code>(생성자 함수)를, 오른쪽 꼭짓점에는 <code>Constructor.prototype</code>이라는 프로퍼티를 위치시켰습니다.<br>왼쪽 꼭짓점부터 아래를 향한 화살표 중간에 <code>new</code>가 있고, 화살표의 종점에는 <code>instance</code>가 있습니다.<br>오른쪽 꼭짓점으로부터 대각선 아래로 향하는 화살표의 종점에는 <code>instance.__proto__</code>이라는 프로퍼티를 위치시켰습니다. </p>\n<hr>\n<ul>\n<li><p>어떤 생성자 함수(<code>Constructor</code>)를 <code>new</code> 연산자와 함께 호출하면</p>\n</li>\n<li><p><code>Constructor</code>에서 정의된 내용을 바탕으로 새로운 인스턴스(<code>instance</code>)가 생성됩니다.</p>\n</li>\n<li><p>이떄 <code>instance</code>에는 <code>__proto__</code>라는 프로퍼티가 자동으로 부여되는데,</p>\n</li>\n<li><p>이 프로퍼티는 <code>Constructor</code>의 <code>prototype</code>이라는 프로퍼티를 참조합니다.</p>\n</li>\n</ul>\n<p><code>prototype</code>이라는 프로퍼티와 <code>__proto__</code> <mark>이 둘의 관계가 프로토타입 개념의 핵심입니다.</mark></p>\n<p><code>prototype</code>은 객체입니다. 이를 참조하는 <code>__proto__</code> 역시 객체입니다.</p>\n<p><code>prototype</code> 객체 내부에는 <code>instance</code>가 사용할 메서드를 저장합니다. 그러면 <code>instance</code>에서도 숨겨진 프로퍼티인 <code>__proto__</code>를 통해 이 메서드들에 접근할 수 있게 됩니다.</p>\n<hr>\n<figure class=\"highlight js\"><figcaption><span>Person이라는 생성자 함수의 prototype에 getName이라는 메서드를 지정한 예제</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Person.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._name;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>이제 <code>Person</code>의 <code>instance</code>는 <code>__proto__</code>프로퍼티를 통해 <code>getName</code>을 호출할 수 있습니다.<br><code>instance</code>의 <code>__proto__</code>가 <code>Constructor</code>의 <code>prototype</code>프로퍼티를 참조하므로 결국 둘은 같은 객체를 바라보기 때문입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>this 바인딩 값</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> suzi = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Suzi'</span>);</span><br><span class=\"line\">suzi.__proto__.getName(); <span class=\"comment\">//undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype === suzi.__proto__ <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>suzi.__proto__.getName();</code>를 실행해 <code>undefined</code>가 나왔다는 것은 이 변수가 “호출할 수 있는 함수”에 해당한다는 것을 의미합니다. </li>\n</ul>\n<ul>\n<li>만약 함수가 아닌 다른 데이터 값이었다면 <code>TypeError</code>가 발생했을 것입니다. 에러가 아닌 <code>undefined</code>를 반환했으므로 <code>getName</code>이 실제로 실행됐고 <code>getName</code>이 함수라는 것이 입증됐습니다.</li>\n</ul>\n<ul>\n<li><code>undefined</code>를 반환한 이유는 <code>this</code>의 바인딩 값이 잘못됐음을 의미합니다.</li>\n</ul>\n<ul>\n<li><code>suzi.__proto__.getName();</code>에서 <code>getName</code> 함수 내부에서의 <code>this</code>는 <code>suzi</code>가 아니라 메서드명 바로앞의 객체 즉, <code>suzi.__proto__</code>를 참조하게 되는 것입니다. </li>\n</ul>\n<ul>\n<li><code>suzi.__proto__</code> 내부에 <code>name</code>프로퍼티가 없으므로 엔진이 “데이터 영역에 지정되지 않은 식별자에 접근할 때”를 뜻하는 <code>undefined</code>를 반환하게 됩니다. </li>\n</ul>\n<hr>\n<p><code>__proto__</code> 객체에 <code>name</code> 프로퍼티가 있다면 <code>undefined</code>가 아니라 프로퍼티 값이 출력 되겠죠?</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> suzi = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Suzi'</span>);</span><br><span class=\"line\">suzi.__proto__._name = <span class=\"string\">'SUZI__proto__'</span>;</span><br><span class=\"line\">suzi.__proto__.getName(); <span class=\"comment\">// SUZI__proto__</span></span><br></pre></td></tr></table></figure>\n\n<p>위 예제 코드들의 관건은 <code>this</code>가 어떤 값을 참조하게 되는가 였습니다.<br><code>this</code>가 <code>instance</code>를 참조하게 하는 방법은 간단합니다.<br><code>__proto__</code>를 생략하고 <code>instance</code>뒤에 바로 메서드를 작성하면 됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>__proto__ 생략</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> suzi = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Suzi'</span>, <span class=\"number\">28</span>);</span><br><span class=\"line\">suzi.getName(); <span class=\"comment\">// Suzi</span></span><br></pre></td></tr></table></figure>\n\n<p>이런 코드가 실행되는 이유는 <code>__proto__</code>가 생략 가능한 프로퍼티이기 때문입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">suzi.__proto__.getName</span><br><span class=\"line\">&gt; suzi(.__proto__).getName</span><br><span class=\"line\">== suzi.getName</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>정리하면 </p>\n<ul>\n<li><code>__proto__</code>를 생략하지 않으면 <code>this</code>는 <code>suzi.__proto__</code>를 참조 (내부에 name프로퍼티 존재하지 않음)</li>\n<li>생략하면 <code>suzi</code>를 참조 가능해짐. (suzi.getName 형태, name 프로퍼티 존재)</li>\n</ul>\n<p><img src=\"/images/prototype_schematic2.png\" alt=\"prototype schematic2\"></p>\n<ul>\n<li>new 연산자로 <code>Constructor</code> 호출시 <code>instance</code> 생성되고<br><code>instance</code>의 생략가능한 프로퍼티인 <code>__proto__</code>는<br><code>Constructor</code>의 <code>prototype</code>을 참조</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>prototype과 __proto__</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Constructor = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Constructor.prototype.method1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">Constructor.prototype.property1 = <span class=\"string\">'Constructor Prototype Property'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> Constructor(<span class=\"string\">'Instance'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir(Constructor); <span class=\"comment\">//Constructor의 디렉터리 구조 출력</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir(instance); <span class=\"comment\">//instance의 디렉터리 구조 출력</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>위 예제를 크롬 개발자도구에서 실행한 결과</li>\n</ul>\n<p><img src=\"/images/prototype_Constructor.png\" alt=\"prototype Constructor\"></p>\n<ul>\n<li><code>Constructor</code>의 디렉터리 구조를 출력한<ul>\n<li>첫 번째 줄에 함수라는 의미의 <code>f</code> 와 함수이름 <code>Constructor</code>, 인자 <code>name</code>이 출력되었습니다.</li>\n<li>그 내부에는 <mark>옅은 색</mark>의 argument, caller, length, name, <code>prototype</code>, &#95;&#95;proto&#95;&#95;등의 프로퍼티들이 나타납니다.</li>\n<li>내부 프로퍼티중 <code>prototype</code>을 열면 개발자가 직접 추가한 <code>metod1</code>, <code>property1</code>등의 값은 <mark>짙은 색</mark>으로 보이고, constructor, &#95;&#95;proto&#95;&#95; 등은 <mark>옅은 색</mark>으로 보입니다.<pre><code>이런 색상의 차이는 { enumerable: false } 속성이 부여된 프로퍼티인지 여부에 따릅니다.\n짙은 색은 enumerable, 즉 열거 가능한 프로퍼티임을 의미하고, \n옅은 색은 innumerable, 즉 열거할 수 없는 프로퍼티입니다.\nfor in 문 등으로 객체의 프로퍼티 전체에 접근할 때 접근 가능 여부를 \n색상으로 구분지어 표기하는 것입니다.</code></pre></li>\n</ul>\n</li>\n</ul>\n<div align=\"center\">\n\n<p><img src=\"/images/prototype_Instance.png\" alt=\"prototype Instance\"></p>\n</div>\n\n<ul>\n<li><code>instance</code>의 디렉터리 구조를 출력한<ul>\n<li>첫 번째 줄에 <code>Constructor</code>가 출력됩니다.<br>생성자 함수의 <code>instance</code>는 해당 생성자 함수의 이름을 표기함으로<br>해당 함수의 <code>instance</code>임을 나타냅니다.</li>\n<li><code>Constructor</code>를 열어보면 <code>name</code>프로퍼티가 짙은 색으로 표기되고, <code>__proto__</code>프로퍼티가 옅은 색으로 표기됩니다.</li>\n<li><code>__proto__</code>를 열어보면 <code>method1</code>, <code>property1</code>, <code>constructor</code>, <code>__proto__</code> 등이 있으므로,<br><code>Constructor</code>의 <code>prototype</code>과 동일한 내용으로 구성돼 있음을 확인할 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id=\"내장-built-in-생성자-함수-Array-구조\"><a href=\"#내장-built-in-생성자-함수-Array-구조\" class=\"headerlink\" title=\"내장(built-in) 생성자 함수 Array 구조\"></a>내장(built-in) 생성자 함수 Array 구조</h4><figure class=\"highlight js\"><figcaption><span>Array</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir(arr);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir(<span class=\"built_in\">Array</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/prototype_arr_Array.png\" alt=\"prototype arr and Array\"></p>\n<ul>\n<li><p>arr</p>\n<ul>\n<li>첫 줄에 <code>Array(2)</code>가 표기됩니다.</li>\n<li><code>Array</code> 생성자 함수를 원본으로 생성됐고, <code>length</code> 값 2를 알 수 있습니다.</li>\n<li><code>index 0, 1</code>은 짙은 색으로 length와 &#95;&#95;proto&#95;&#95;는 옅은 색으로 표기됩니다.</li>\n<li>&#95;&#95;proto&#95;&#95; 에는 Array 메서드 들이 포함되어 있습니다.</li>\n</ul>\n</li>\n<li><p>Array</p>\n<ul>\n<li>첫 줄에 함수를 뜻하는 <code>f</code>가 표시됩니다.</li>\n<li>함수의 프로퍼티인 <code>argument</code>, <code>caller</code>, <code>length</code>, <code>name</code>등이 표기됩니다.</li>\n<li>또한 <code>Array</code> 함수의 정적 메서드 <code>from</code>, <code>isArray</code> <code>of</code> 등도 있습니다.</li>\n<li><code>prototype</code>을 열어보면 왼쪽(arr)의 &#95;&#95;proto&#95;&#95;와 동일한 구성임을 확인할 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>위 결과를 도식으로 나타면 다음과 같습니다.<br><img src=\"/images/prototype_Array_schematic.png\" alt=\"prototype Array schematic\"></p>\n</li>\n<li><p>Array를 new 연산자와 함께 호출하든, 배열 리터럴을 생성하든 <code>instance</code>인 [1, 2]가 만들어집니다.</p>\n</li>\n</ul>\n<ul>\n<li><code>instance</code>의 <code>__proto__</code>은 Array.prototype을 참조함으로 <code>instance</code>가 push, pop, forEach 등 Array 메서드를 자신의 것처럼 호출할 수 있습니다.(<code>__proto__</code>가 생략 가능하도록 설계돼 있기 때문에)</li>\n</ul>\n<ul>\n<li><strong>한편 <code>Array의 prototype 프로퍼티 내부</code>에 있지 않은 <code>from, isArray</code> 등의 메서드들은 <code>instance</code>가 직접 호출할 수 없습니다. 이들은 <code>Array 생성자 함수</code>에서 직접 접근해야 실행 가능합니다.</strong></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Array 생성자 함수를 원본으로하는 instance인 arr</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// __proto__ 생략 가능으로 인한 Array 메서드 직접 호출 </span></span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;&#125;); <span class=\"comment\">// (o)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array의 prototype 프로퍼티 내부에 없는 메서드는</span></span><br><span class=\"line\"><span class=\"comment\">// instance가 직접 호출 불가능</span></span><br><span class=\"line\">arr.isArray(); <span class=\"comment\">// (x) TypeError: arr.isArray is not a function</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array 생성자 함수에서 직접 접근하여 실행해야 됨</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.isArray(arr); <span class=\"comment\">// (o) true</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"constructor-프로퍼티\"><a href=\"#constructor-프로퍼티\" class=\"headerlink\" title=\"constructor 프로퍼티\"></a>constructor 프로퍼티</h3><p><code>생성자 함수</code>의 프로퍼티인 <code>prototype</code> 객체 내부에는 <code>constructor</code> 프로퍼티가 있습니다.<br><code>instance</code>의 <code>__proto__</code> 객체 내부에도 마찬가지로 존재합니다.<br><code>constructor</code> 프로퍼티는 원래의 생성자 함수(자기 자신)를 참조하고,<br><code>instance</code>로부터 그 원형을 알 수 있는 수단으로 <code>instance</code>와의 관계에 있어 필요한 정보입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>constructor 프로퍼티 </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.constructor === <span class=\"built_in\">Array</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\">arr.__proto__.constructor === <span class=\"built_in\">Array</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\">arr.constructor === <span class=\"built_in\">Array</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = <span class=\"keyword\">new</span> arr.constructor(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2); <span class=\"comment\">// [3, 4]</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"다양한-constructor-접근-방법\"><a href=\"#다양한-constructor-접근-방법\" class=\"headerlink\" title=\"다양한 constructor 접근 방법\"></a>다양한 constructor 접근 방법</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'사람1'</span>); <span class=\"comment\">// Person &#123; name: \"사람1\" &#125; true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1Proto = <span class=\"built_in\">Object</span>.getPrototypeOf(p1);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Person.prototype.constructor(<span class=\"string\">'사람2'</span>); <span class=\"comment\">// Person &#123; name: \"사람2\" &#125; true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = <span class=\"keyword\">new</span> p1Proto.constructor(<span class=\"string\">'사람3'</span>); <span class=\"comment\">// Person &#123; name: \"사람3\" &#125; true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p4 = <span class=\"keyword\">new</span> p1.__proto__.constructor(<span class=\"string\">'사람4'</span>); <span class=\"comment\">// Person &#123; name: \"사람4\" &#125; true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p5 = <span class=\"keyword\">new</span> p1.constructor(<span class=\"string\">'사람5'</span>); <span class=\"comment\">// Person &#123; name: \"사람5\" &#125; true</span></span><br><span class=\"line\"></span><br><span class=\"line\">[p1, p2, p3, p4, p5].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(p, p <span class=\"keyword\">instanceof</span> Person);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>다음은 모두 동일한 대상을 가리키게 됩니다.</strong></li>\n</ul>\n<pre><code>1. [Constructor]\n\n2. [instance].__proto__.constructor\n\n3. [instance].constructor\n\n4. Object.getPrototypeOf([instance]).constructor\n\n5. [Constructor].prototype.constructor</code></pre><ul>\n<li><strong>다음은 모두 동일한 객체에 접근할 수 있습니다.</strong></li>\n</ul>\n<pre><code>1. [Constructor].prototype\n\n2. [instance].__proto__\n\n3. [instance]\n\n4. Object.getPrototypeOf([instance])</code></pre><ul>\n<li>따라서 p1 부터 p5까지 모두 Person의 instance입니다.</li>\n</ul>\n<hr>\n<h2 id=\"prototype_chain\">프로토타입 체인</h2>\n\n<hr>\n<h3 id=\"메서드-오버라이드\"><a href=\"#메서드-오버라이드\" class=\"headerlink\" title=\"메서드 오버라이드\"></a>메서드 오버라이드</h3><p><code>instance</code>가 동일한 이름의 프로퍼티 또는 메서드를 가지고 있는 상황이라면</p>\n<p><code>instance.method()</code> 형태로 호출했을 때<br><code>instance.__proto__.method</code>가 아닌 <code>instance</code>객체에 있는 해당 <code>method</code>가 호출됩니다.<br>여기서 일어난 현상을 메서드 위에 메서드를 덮어씌웠다고 하여 <mark>메서드 오버라이드</mark>라고합니다.</p>\n<ul>\n<li>자바스크립트 엔진은 프로퍼티(혹은 메서드)를 찾을 때 가장 가까운 대상인 자신의 프로퍼티를 먼저 검색하고, 없으면 그다음으로 가까운 대상인 &#95;&#95;proto&#95;&#95;를 검색합니다.<br>그러므로 메서드 오버라이드 됐을 때 &#95;&#95;proto&#95;&#95;에 있는 메서드는 우선 순위에서 밀려 호출되지 않는 것입니다.</li>\n</ul>\n<hr>\n<h4 id=\"메서드-오버라이드된-상태에서-prototype에-있는-메서드에-접근법\"><a href=\"#메서드-오버라이드된-상태에서-prototype에-있는-메서드에-접근법\" class=\"headerlink\" title=\"메서드 오버라이드된 상태에서 prototype에 있는 메서드에 접근법\"></a>메서드 오버라이드된 상태에서 prototype에 있는 메서드에 접근법</h4><blockquote>\n<p>instance.&#95;&#95;proto&#95;&#95;.method()</p>\n</blockquote>\n<p>형태로 호출하면 정상적으로 <code>prototype</code>에 있는 <code>method</code>에 접근할 수 있습니다.<br>하지만 <code>this</code>가 <code>instance</code>를 바라보지 않고 있습니다.</p>\n<p><code>call</code>이나 <code>apply</code>를 사용하면</p>\n<blockquote>\n<p>instance.&#95;&#95;proto&#95;&#95;.method.call(thisArg) 형태로 작성하여 <code>this</code> 대상을 지정합니다.</p>\n</blockquote>\n<hr>\n<h3 id=\"프로토타입-체인\"><a href=\"#프로토타입-체인\" class=\"headerlink\" title=\"프로토타입 체인\"></a>프로토타입 체인</h3><p><mark>자바스크립트의 모든 객체의 최상위 객체에는 Object 객체가 존재합니다.</mark></p>\n<p>따라서 모든 객체의 <code>__proto__</code>에는 <code>Object.prototype</code>이 연결됩니다.</p>\n<p><strong>Array 객체를 예시로 든 최상위 객체 Object와의 구조 도식(<del>prototype 역시 객체입니다.</del>)</strong></p>\n<p><img src=\"/images/%EA%B0%9D%EC%B2%B4%EC%9D%98_%EC%B5%9C%EC%83%81%EC%9C%84_%EA%B0%9D%EC%B2%B4_Object.png\" alt=\"객체의 최상위 객체 Object\"></p>\n<ul>\n<li><p>앞에서 <code>__proto__</code>는 생략가능한 프로퍼티이므로 <code>배열[]</code>에서 <code>Array.prototype</code> 내부의 메서드를 직접 호출할 수 있었습니다. </p>\n</li>\n<li><p>마찬가지로 <code>배열[]</code>의 <code>__proto__</code>를 계속 따라가다 보면 <code>Object.prototype</code>이 있으므로 <code>Object.prototype</code>의 내부 메서드도 직접 호출할 수 있습니다.</p>\n</li>\n</ul>\n<hr>\n<p>이러한 <code>__proto__</code> 프로퍼티 내부에 다시 <code>__proto__</code>프로퍼티가 연쇄적으로 이어진 것을<br><strong>프로토타입 체인</strong>(<code>prototype chain</code>)이라 하고, </p>\n<p>이 체인을 따라 검색하는 것을 <strong>프로토타입 체이닝</strong>(<code>prototype chaining</code>)이라고 합니다.</p>\n<hr>\n<h3 id=\"객체-전용-메서드의-예외사항\"><a href=\"#객체-전용-메서드의-예외사항\" class=\"headerlink\" title=\"객체 전용 메서드의 예외사항\"></a>객체 전용 메서드의 예외사항</h3><p>어떤 생성자 함수이든 <code>prototype</code>은 객체이기 때문에 <code>Object.prototype</code>이 언제나 프로토타입 체인의 최상단에 존재하게 됩니다.</p>\n<p>따라서 <strong>객체에서만 사용할 메서드는 다른 데이터 타입처럼 프로토타입 객체 안에 정의할 수 없습니다.</strong></p>\n<p><strong>객체에서만 사용할 메서드를 <code>Object.prototype</code>내부에 정의한다면 다른 데이터 타입도 해당 메서드를 사용할 수 있게 되기 때문입니다.</strong></p>\n","site":{"data":{}},"excerpt":"<ul>\n<li>프로토타입 (prototype)<ul>\n<li><a href=\"/2020/05/05/prototype-Core-JavaScript/#프로토타입의-개념-이해\">프로토타입의 개념 이해</a><ul>\n<li>constructor, prototype, instance</li>\n<li>constructor 프로퍼티</li>\n</ul>\n</li>\n<li><a href=\"/2020/05/05/prototype-Core-JavaScript/#prototype_chain\">프로토타입 체인</a><ul>\n<li>메서드 오버라이드</li>\n<li>프로토타입 체인</li>\n<li>객체 전용 메서드의 예외사항</li>\n<li>다중 프로토타입 체인</li>\n</ul>\n</li>\n<li><a href=\"/2020/05/05/prototype-Core-JavaScript/#\">정리</a></li>\n</ul>\n</li>\n</ul>","more":"<hr>\n<h2 id=\"프로포타입의-개념-이해\">프로토타입의 개념 이해</h2>\n\n<h3 id=\"constructor-prototype-instance\"><a href=\"#constructor-prototype-instance\" class=\"headerlink\" title=\"constructor, prototype, instance\"></a>constructor, prototype, instance</h3><blockquote>\n<p>var instance = new Constructor();</p>\n</blockquote>\n<p>위 코드를 추상화 하여 나타내면 다음과 같습니다.</p>\n<p><img src=\"/images/prototype_schematic.png\" alt=\"prototype schematic\"></p>\n<p>윗변(실선)의 왼쪽 꼭지점에는 <code>Constructor</code>(생성자 함수)를, 오른쪽 꼭짓점에는 <code>Constructor.prototype</code>이라는 프로퍼티를 위치시켰습니다.<br>왼쪽 꼭짓점부터 아래를 향한 화살표 중간에 <code>new</code>가 있고, 화살표의 종점에는 <code>instance</code>가 있습니다.<br>오른쪽 꼭짓점으로부터 대각선 아래로 향하는 화살표의 종점에는 <code>instance.__proto__</code>이라는 프로퍼티를 위치시켰습니다. </p>\n<hr>\n<ul>\n<li><p>어떤 생성자 함수(<code>Constructor</code>)를 <code>new</code> 연산자와 함께 호출하면</p>\n</li>\n<li><p><code>Constructor</code>에서 정의된 내용을 바탕으로 새로운 인스턴스(<code>instance</code>)가 생성됩니다.</p>\n</li>\n<li><p>이떄 <code>instance</code>에는 <code>__proto__</code>라는 프로퍼티가 자동으로 부여되는데,</p>\n</li>\n<li><p>이 프로퍼티는 <code>Constructor</code>의 <code>prototype</code>이라는 프로퍼티를 참조합니다.</p>\n</li>\n</ul>\n<p><code>prototype</code>이라는 프로퍼티와 <code>__proto__</code> <mark>이 둘의 관계가 프로토타입 개념의 핵심입니다.</mark></p>\n<p><code>prototype</code>은 객체입니다. 이를 참조하는 <code>__proto__</code> 역시 객체입니다.</p>\n<p><code>prototype</code> 객체 내부에는 <code>instance</code>가 사용할 메서드를 저장합니다. 그러면 <code>instance</code>에서도 숨겨진 프로퍼티인 <code>__proto__</code>를 통해 이 메서드들에 접근할 수 있게 됩니다.</p>\n<hr>\n<figure class=\"highlight js\"><figcaption><span>Person이라는 생성자 함수의 prototype에 getName이라는 메서드를 지정한 예제</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Person.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._name;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>이제 <code>Person</code>의 <code>instance</code>는 <code>__proto__</code>프로퍼티를 통해 <code>getName</code>을 호출할 수 있습니다.<br><code>instance</code>의 <code>__proto__</code>가 <code>Constructor</code>의 <code>prototype</code>프로퍼티를 참조하므로 결국 둘은 같은 객체를 바라보기 때문입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>this 바인딩 값</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> suzi = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Suzi'</span>);</span><br><span class=\"line\">suzi.__proto__.getName(); <span class=\"comment\">//undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype === suzi.__proto__ <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>suzi.__proto__.getName();</code>를 실행해 <code>undefined</code>가 나왔다는 것은 이 변수가 “호출할 수 있는 함수”에 해당한다는 것을 의미합니다. </li>\n</ul>\n<ul>\n<li>만약 함수가 아닌 다른 데이터 값이었다면 <code>TypeError</code>가 발생했을 것입니다. 에러가 아닌 <code>undefined</code>를 반환했으므로 <code>getName</code>이 실제로 실행됐고 <code>getName</code>이 함수라는 것이 입증됐습니다.</li>\n</ul>\n<ul>\n<li><code>undefined</code>를 반환한 이유는 <code>this</code>의 바인딩 값이 잘못됐음을 의미합니다.</li>\n</ul>\n<ul>\n<li><code>suzi.__proto__.getName();</code>에서 <code>getName</code> 함수 내부에서의 <code>this</code>는 <code>suzi</code>가 아니라 메서드명 바로앞의 객체 즉, <code>suzi.__proto__</code>를 참조하게 되는 것입니다. </li>\n</ul>\n<ul>\n<li><code>suzi.__proto__</code> 내부에 <code>name</code>프로퍼티가 없으므로 엔진이 “데이터 영역에 지정되지 않은 식별자에 접근할 때”를 뜻하는 <code>undefined</code>를 반환하게 됩니다. </li>\n</ul>\n<hr>\n<p><code>__proto__</code> 객체에 <code>name</code> 프로퍼티가 있다면 <code>undefined</code>가 아니라 프로퍼티 값이 출력 되겠죠?</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> suzi = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Suzi'</span>);</span><br><span class=\"line\">suzi.__proto__._name = <span class=\"string\">'SUZI__proto__'</span>;</span><br><span class=\"line\">suzi.__proto__.getName(); <span class=\"comment\">// SUZI__proto__</span></span><br></pre></td></tr></table></figure>\n\n<p>위 예제 코드들의 관건은 <code>this</code>가 어떤 값을 참조하게 되는가 였습니다.<br><code>this</code>가 <code>instance</code>를 참조하게 하는 방법은 간단합니다.<br><code>__proto__</code>를 생략하고 <code>instance</code>뒤에 바로 메서드를 작성하면 됩니다.</p>\n<figure class=\"highlight js\"><figcaption><span>__proto__ 생략</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> suzi = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Suzi'</span>, <span class=\"number\">28</span>);</span><br><span class=\"line\">suzi.getName(); <span class=\"comment\">// Suzi</span></span><br></pre></td></tr></table></figure>\n\n<p>이런 코드가 실행되는 이유는 <code>__proto__</code>가 생략 가능한 프로퍼티이기 때문입니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">suzi.__proto__.getName</span><br><span class=\"line\">&gt; suzi(.__proto__).getName</span><br><span class=\"line\">== suzi.getName</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>정리하면 </p>\n<ul>\n<li><code>__proto__</code>를 생략하지 않으면 <code>this</code>는 <code>suzi.__proto__</code>를 참조 (내부에 name프로퍼티 존재하지 않음)</li>\n<li>생략하면 <code>suzi</code>를 참조 가능해짐. (suzi.getName 형태, name 프로퍼티 존재)</li>\n</ul>\n<p><img src=\"/images/prototype_schematic2.png\" alt=\"prototype schematic2\"></p>\n<ul>\n<li>new 연산자로 <code>Constructor</code> 호출시 <code>instance</code> 생성되고<br><code>instance</code>의 생략가능한 프로퍼티인 <code>__proto__</code>는<br><code>Constructor</code>의 <code>prototype</code>을 참조</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight js\"><figcaption><span>prototype과 __proto__</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Constructor = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Constructor.prototype.method1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">Constructor.prototype.property1 = <span class=\"string\">'Constructor Prototype Property'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> Constructor(<span class=\"string\">'Instance'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir(Constructor); <span class=\"comment\">//Constructor의 디렉터리 구조 출력</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir(instance); <span class=\"comment\">//instance의 디렉터리 구조 출력</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>위 예제를 크롬 개발자도구에서 실행한 결과</li>\n</ul>\n<p><img src=\"/images/prototype_Constructor.png\" alt=\"prototype Constructor\"></p>\n<ul>\n<li><code>Constructor</code>의 디렉터리 구조를 출력한<ul>\n<li>첫 번째 줄에 함수라는 의미의 <code>f</code> 와 함수이름 <code>Constructor</code>, 인자 <code>name</code>이 출력되었습니다.</li>\n<li>그 내부에는 <mark>옅은 색</mark>의 argument, caller, length, name, <code>prototype</code>, &#95;&#95;proto&#95;&#95;등의 프로퍼티들이 나타납니다.</li>\n<li>내부 프로퍼티중 <code>prototype</code>을 열면 개발자가 직접 추가한 <code>metod1</code>, <code>property1</code>등의 값은 <mark>짙은 색</mark>으로 보이고, constructor, &#95;&#95;proto&#95;&#95; 등은 <mark>옅은 색</mark>으로 보입니다.<pre><code>이런 색상의 차이는 { enumerable: false } 속성이 부여된 프로퍼티인지 여부에 따릅니다.\n짙은 색은 enumerable, 즉 열거 가능한 프로퍼티임을 의미하고, \n옅은 색은 innumerable, 즉 열거할 수 없는 프로퍼티입니다.\nfor in 문 등으로 객체의 프로퍼티 전체에 접근할 때 접근 가능 여부를 \n색상으로 구분지어 표기하는 것입니다.</code></pre></li>\n</ul>\n</li>\n</ul>\n<div align=\"center\">\n\n<p><img src=\"/images/prototype_Instance.png\" alt=\"prototype Instance\"></p>\n</div>\n\n<ul>\n<li><code>instance</code>의 디렉터리 구조를 출력한<ul>\n<li>첫 번째 줄에 <code>Constructor</code>가 출력됩니다.<br>생성자 함수의 <code>instance</code>는 해당 생성자 함수의 이름을 표기함으로<br>해당 함수의 <code>instance</code>임을 나타냅니다.</li>\n<li><code>Constructor</code>를 열어보면 <code>name</code>프로퍼티가 짙은 색으로 표기되고, <code>__proto__</code>프로퍼티가 옅은 색으로 표기됩니다.</li>\n<li><code>__proto__</code>를 열어보면 <code>method1</code>, <code>property1</code>, <code>constructor</code>, <code>__proto__</code> 등이 있으므로,<br><code>Constructor</code>의 <code>prototype</code>과 동일한 내용으로 구성돼 있음을 확인할 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id=\"내장-built-in-생성자-함수-Array-구조\"><a href=\"#내장-built-in-생성자-함수-Array-구조\" class=\"headerlink\" title=\"내장(built-in) 생성자 함수 Array 구조\"></a>내장(built-in) 생성자 함수 Array 구조</h4><figure class=\"highlight js\"><figcaption><span>Array</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir(arr);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir(<span class=\"built_in\">Array</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/prototype_arr_Array.png\" alt=\"prototype arr and Array\"></p>\n<ul>\n<li><p>arr</p>\n<ul>\n<li>첫 줄에 <code>Array(2)</code>가 표기됩니다.</li>\n<li><code>Array</code> 생성자 함수를 원본으로 생성됐고, <code>length</code> 값 2를 알 수 있습니다.</li>\n<li><code>index 0, 1</code>은 짙은 색으로 length와 &#95;&#95;proto&#95;&#95;는 옅은 색으로 표기됩니다.</li>\n<li>&#95;&#95;proto&#95;&#95; 에는 Array 메서드 들이 포함되어 있습니다.</li>\n</ul>\n</li>\n<li><p>Array</p>\n<ul>\n<li>첫 줄에 함수를 뜻하는 <code>f</code>가 표시됩니다.</li>\n<li>함수의 프로퍼티인 <code>argument</code>, <code>caller</code>, <code>length</code>, <code>name</code>등이 표기됩니다.</li>\n<li>또한 <code>Array</code> 함수의 정적 메서드 <code>from</code>, <code>isArray</code> <code>of</code> 등도 있습니다.</li>\n<li><code>prototype</code>을 열어보면 왼쪽(arr)의 &#95;&#95;proto&#95;&#95;와 동일한 구성임을 확인할 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>위 결과를 도식으로 나타면 다음과 같습니다.<br><img src=\"/images/prototype_Array_schematic.png\" alt=\"prototype Array schematic\"></p>\n</li>\n<li><p>Array를 new 연산자와 함께 호출하든, 배열 리터럴을 생성하든 <code>instance</code>인 [1, 2]가 만들어집니다.</p>\n</li>\n</ul>\n<ul>\n<li><code>instance</code>의 <code>__proto__</code>은 Array.prototype을 참조함으로 <code>instance</code>가 push, pop, forEach 등 Array 메서드를 자신의 것처럼 호출할 수 있습니다.(<code>__proto__</code>가 생략 가능하도록 설계돼 있기 때문에)</li>\n</ul>\n<ul>\n<li><strong>한편 <code>Array의 prototype 프로퍼티 내부</code>에 있지 않은 <code>from, isArray</code> 등의 메서드들은 <code>instance</code>가 직접 호출할 수 없습니다. 이들은 <code>Array 생성자 함수</code>에서 직접 접근해야 실행 가능합니다.</strong></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Array 생성자 함수를 원본으로하는 instance인 arr</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// __proto__ 생략 가능으로 인한 Array 메서드 직접 호출 </span></span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;&#125;); <span class=\"comment\">// (o)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array의 prototype 프로퍼티 내부에 없는 메서드는</span></span><br><span class=\"line\"><span class=\"comment\">// instance가 직접 호출 불가능</span></span><br><span class=\"line\">arr.isArray(); <span class=\"comment\">// (x) TypeError: arr.isArray is not a function</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array 생성자 함수에서 직접 접근하여 실행해야 됨</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.isArray(arr); <span class=\"comment\">// (o) true</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"constructor-프로퍼티\"><a href=\"#constructor-프로퍼티\" class=\"headerlink\" title=\"constructor 프로퍼티\"></a>constructor 프로퍼티</h3><p><code>생성자 함수</code>의 프로퍼티인 <code>prototype</code> 객체 내부에는 <code>constructor</code> 프로퍼티가 있습니다.<br><code>instance</code>의 <code>__proto__</code> 객체 내부에도 마찬가지로 존재합니다.<br><code>constructor</code> 프로퍼티는 원래의 생성자 함수(자기 자신)를 참조하고,<br><code>instance</code>로부터 그 원형을 알 수 있는 수단으로 <code>instance</code>와의 관계에 있어 필요한 정보입니다.</p>\n<figure class=\"highlight js\"><figcaption><span>constructor 프로퍼티 </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.constructor === <span class=\"built_in\">Array</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\">arr.__proto__.constructor === <span class=\"built_in\">Array</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\">arr.constructor === <span class=\"built_in\">Array</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = <span class=\"keyword\">new</span> arr.constructor(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2); <span class=\"comment\">// [3, 4]</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"다양한-constructor-접근-방법\"><a href=\"#다양한-constructor-접근-방법\" class=\"headerlink\" title=\"다양한 constructor 접근 방법\"></a>다양한 constructor 접근 방법</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'사람1'</span>); <span class=\"comment\">// Person &#123; name: \"사람1\" &#125; true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1Proto = <span class=\"built_in\">Object</span>.getPrototypeOf(p1);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Person.prototype.constructor(<span class=\"string\">'사람2'</span>); <span class=\"comment\">// Person &#123; name: \"사람2\" &#125; true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = <span class=\"keyword\">new</span> p1Proto.constructor(<span class=\"string\">'사람3'</span>); <span class=\"comment\">// Person &#123; name: \"사람3\" &#125; true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p4 = <span class=\"keyword\">new</span> p1.__proto__.constructor(<span class=\"string\">'사람4'</span>); <span class=\"comment\">// Person &#123; name: \"사람4\" &#125; true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p5 = <span class=\"keyword\">new</span> p1.constructor(<span class=\"string\">'사람5'</span>); <span class=\"comment\">// Person &#123; name: \"사람5\" &#125; true</span></span><br><span class=\"line\"></span><br><span class=\"line\">[p1, p2, p3, p4, p5].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(p, p <span class=\"keyword\">instanceof</span> Person);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>다음은 모두 동일한 대상을 가리키게 됩니다.</strong></li>\n</ul>\n<pre><code>1. [Constructor]\n\n2. [instance].__proto__.constructor\n\n3. [instance].constructor\n\n4. Object.getPrototypeOf([instance]).constructor\n\n5. [Constructor].prototype.constructor</code></pre><ul>\n<li><strong>다음은 모두 동일한 객체에 접근할 수 있습니다.</strong></li>\n</ul>\n<pre><code>1. [Constructor].prototype\n\n2. [instance].__proto__\n\n3. [instance]\n\n4. Object.getPrototypeOf([instance])</code></pre><ul>\n<li>따라서 p1 부터 p5까지 모두 Person의 instance입니다.</li>\n</ul>\n<hr>\n<h2 id=\"prototype_chain\">프로토타입 체인</h2>\n\n<hr>\n<h3 id=\"메서드-오버라이드\"><a href=\"#메서드-오버라이드\" class=\"headerlink\" title=\"메서드 오버라이드\"></a>메서드 오버라이드</h3><p><code>instance</code>가 동일한 이름의 프로퍼티 또는 메서드를 가지고 있는 상황이라면</p>\n<p><code>instance.method()</code> 형태로 호출했을 때<br><code>instance.__proto__.method</code>가 아닌 <code>instance</code>객체에 있는 해당 <code>method</code>가 호출됩니다.<br>여기서 일어난 현상을 메서드 위에 메서드를 덮어씌웠다고 하여 <mark>메서드 오버라이드</mark>라고합니다.</p>\n<ul>\n<li>자바스크립트 엔진은 프로퍼티(혹은 메서드)를 찾을 때 가장 가까운 대상인 자신의 프로퍼티를 먼저 검색하고, 없으면 그다음으로 가까운 대상인 &#95;&#95;proto&#95;&#95;를 검색합니다.<br>그러므로 메서드 오버라이드 됐을 때 &#95;&#95;proto&#95;&#95;에 있는 메서드는 우선 순위에서 밀려 호출되지 않는 것입니다.</li>\n</ul>\n<hr>\n<h4 id=\"메서드-오버라이드된-상태에서-prototype에-있는-메서드에-접근법\"><a href=\"#메서드-오버라이드된-상태에서-prototype에-있는-메서드에-접근법\" class=\"headerlink\" title=\"메서드 오버라이드된 상태에서 prototype에 있는 메서드에 접근법\"></a>메서드 오버라이드된 상태에서 prototype에 있는 메서드에 접근법</h4><blockquote>\n<p>instance.&#95;&#95;proto&#95;&#95;.method()</p>\n</blockquote>\n<p>형태로 호출하면 정상적으로 <code>prototype</code>에 있는 <code>method</code>에 접근할 수 있습니다.<br>하지만 <code>this</code>가 <code>instance</code>를 바라보지 않고 있습니다.</p>\n<p><code>call</code>이나 <code>apply</code>를 사용하면</p>\n<blockquote>\n<p>instance.&#95;&#95;proto&#95;&#95;.method.call(thisArg) 형태로 작성하여 <code>this</code> 대상을 지정합니다.</p>\n</blockquote>\n<hr>\n<h3 id=\"프로토타입-체인\"><a href=\"#프로토타입-체인\" class=\"headerlink\" title=\"프로토타입 체인\"></a>프로토타입 체인</h3><p><mark>자바스크립트의 모든 객체의 최상위 객체에는 Object 객체가 존재합니다.</mark></p>\n<p>따라서 모든 객체의 <code>__proto__</code>에는 <code>Object.prototype</code>이 연결됩니다.</p>\n<p><strong>Array 객체를 예시로 든 최상위 객체 Object와의 구조 도식(<del>prototype 역시 객체입니다.</del>)</strong></p>\n<p><img src=\"/images/%EA%B0%9D%EC%B2%B4%EC%9D%98_%EC%B5%9C%EC%83%81%EC%9C%84_%EA%B0%9D%EC%B2%B4_Object.png\" alt=\"객체의 최상위 객체 Object\"></p>\n<ul>\n<li><p>앞에서 <code>__proto__</code>는 생략가능한 프로퍼티이므로 <code>배열[]</code>에서 <code>Array.prototype</code> 내부의 메서드를 직접 호출할 수 있었습니다. </p>\n</li>\n<li><p>마찬가지로 <code>배열[]</code>의 <code>__proto__</code>를 계속 따라가다 보면 <code>Object.prototype</code>이 있으므로 <code>Object.prototype</code>의 내부 메서드도 직접 호출할 수 있습니다.</p>\n</li>\n</ul>\n<hr>\n<p>이러한 <code>__proto__</code> 프로퍼티 내부에 다시 <code>__proto__</code>프로퍼티가 연쇄적으로 이어진 것을<br><strong>프로토타입 체인</strong>(<code>prototype chain</code>)이라 하고, </p>\n<p>이 체인을 따라 검색하는 것을 <strong>프로토타입 체이닝</strong>(<code>prototype chaining</code>)이라고 합니다.</p>\n<hr>\n<h3 id=\"객체-전용-메서드의-예외사항\"><a href=\"#객체-전용-메서드의-예외사항\" class=\"headerlink\" title=\"객체 전용 메서드의 예외사항\"></a>객체 전용 메서드의 예외사항</h3><p>어떤 생성자 함수이든 <code>prototype</code>은 객체이기 때문에 <code>Object.prototype</code>이 언제나 프로토타입 체인의 최상단에 존재하게 됩니다.</p>\n<p>따라서 <strong>객체에서만 사용할 메서드는 다른 데이터 타입처럼 프로토타입 객체 안에 정의할 수 없습니다.</strong></p>\n<p><strong>객체에서만 사용할 메서드를 <code>Object.prototype</code>내부에 정의한다면 다른 데이터 타입도 해당 메서드를 사용할 수 있게 되기 때문입니다.</strong></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck9iqcrrr0005qgvqgkt43war","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrry000bqgvq2j4yd3fi"},{"post_id":"ck9iqcrri0000qgvqgkkn31ch","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrs5000gqgvqhvtl6c95"},{"post_id":"ck9iqcrru0009qgvq45hy772h","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrs9000jqgvqamradee3"},{"post_id":"ck9iqcrro0001qgvqa80b64ht","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrsf000oqgvq7y6qdev3"},{"post_id":"ck9iqcrrx000aqgvq5r8x8t67","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrsh000rqgvqeuem13px"},{"post_id":"ck9iqcrs4000fqgvqgc3n7csx","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrsj000vqgvqh0h1bxzt"},{"post_id":"ck9iqcrrr0004qgvq45qpc1qx","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrsk000yqgvqbbgoa69f"},{"post_id":"ck9iqcrs6000iqgvqelt3292j","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrsl0012qgvqf08odtwq"},{"post_id":"ck9iqcrse000nqgvqenfidki6","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrsm0015qgvqbpm0h3x1"},{"post_id":"ck9iqcrrs0006qgvqhg3whj7v","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrso0019qgvqeshx81g8"},{"post_id":"ck9iqcrsg000qqgvqf5z1dd20","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrso001cqgvqfkhogirn"},{"post_id":"ck9iqcrsi000uqgvqh2vjfrw3","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrsp001fqgvqarwqc6vt"},{"post_id":"ck9iqcrsj000xqgvqfm08eh04","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrsq001iqgvq5ynldk5t"},{"post_id":"ck9iqcrsl0011qgvq2oejfpwn","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrsr001lqgvqgk688ouh"},{"post_id":"ck9iqcrsm0014qgvqa9y8cnaz","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrss001oqgvq6z34e0hg"},{"post_id":"ck9iqcrsn0018qgvq8oenhqsx","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrsv001rqgvq9apc8zfc"},{"post_id":"ck9iqcrso001bqgvqaxh8brra","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrsw001uqgvqaj9ecf4q"},{"post_id":"ck9iqcrsp001eqgvqhy7gb432","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrsx001xqgvq8861h7b4"},{"post_id":"ck9iqcrsq001hqgvqegyw736o","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrsy0020qgvqfqbzgkhe"},{"post_id":"ck9iqcrsr001kqgvqas27bmwy","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrt10023qgvq1pg03idr"},{"post_id":"ck9iqcrss001nqgvqbhxu90nl","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrt30026qgvqes828y8z"},{"post_id":"ck9iqcrst001qqgvqevta0okr","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrt40029qgvq85se6xeb"},{"post_id":"ck9iqcrsw001tqgvqdev3c6gw","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrt5002cqgvq0xly7x4h"},{"post_id":"ck9iqcrsx001wqgvq8gighnno","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrt6002fqgvqdphog7r4"},{"post_id":"ck9iqcrsx001zqgvq7w4rbhvy","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrt7002iqgvqg497cqqc"},{"post_id":"ck9iqcrsz0022qgvq0iq440fl","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrt9002nqgvqgwq5aojs"},{"post_id":"ck9iqcrt20025qgvqe70m7uyv","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrta002qqgvqd5x83rbk"},{"post_id":"ck9iqcrt30028qgvqhqecfxum","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrtb002vqgvq4pa99007"},{"post_id":"ck9iqcrt4002bqgvq6jan5p5t","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrtc002yqgvq5112awop"},{"post_id":"ck9iqcrt7002hqgvqbigbbyld","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrtd0031qgvq8t8g9i0b"},{"post_id":"ck9iqcrt9002pqgvq49wk6rzw","category_id":"ck9iqcrt8002jqgvq5o088r4q","_id":"ck9iqcrte0034qgvq88ag7rlw"},{"post_id":"ck9iqcrt6002eqgvqfnvr1i8m","category_id":"ck9iqcrt8002jqgvq5o088r4q","_id":"ck9iqcrte0037qgvq3l9908x7"},{"post_id":"ck9iqcrta002sqgvqefwk1n1r","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrtf003aqgvqaz700xum"},{"post_id":"ck9iqcrtc002xqgvq23twhxba","category_id":"ck9iqcrtb002tqgvqd1rx4bt1","_id":"ck9iqcrtg003dqgvqfmi05cwr"},{"post_id":"ck9iqcrtc0030qgvq6gxo85k0","category_id":"ck9iqcrt8002jqgvq5o088r4q","_id":"ck9iqcrti003jqgvqfeuvhxx2"},{"post_id":"ck9iqcrtd0033qgvq2mdgb6q4","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrti003mqgvq5vgh5ew3"},{"post_id":"ck9iqcrte0036qgvq54uqcb2o","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrtj003pqgvqhxmsh9s4"},{"post_id":"ck9iqcrtf0039qgvq115a60v6","category_id":"ck9iqcrtb002tqgvqd1rx4bt1","_id":"ck9iqcrtk003sqgvqfazw9u5k"},{"post_id":"ck9iqcrtg003cqgvq3gv5a0g6","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrtl003vqgvqfndj8e1d"},{"post_id":"ck9iqcrtg003fqgvq35oofyh0","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrtm003yqgvqbu4v3zto"},{"post_id":"ck9iqcrth003iqgvqg393cxl9","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrtn0040qgvqfgc63lzu"},{"post_id":"ck9iqcrti003lqgvqhmf54wov","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrtn0042qgvqb0gmcz7m"},{"post_id":"ck9iqcrtj003oqgvqfhx2ff3l","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrtn0044qgvqad162miu"},{"post_id":"ck9iqcrtj003rqgvq01mc8t1s","category_id":"ck9iqcrrt0007qgvqbbuy2wju","_id":"ck9iqcrtn0046qgvq22ew2xn7"},{"post_id":"ck9iqcrtl003uqgvqe9r6ay45","category_id":"ck9iqcrrp0002qgvqc9ydcz9y","_id":"ck9iqcrtn0048qgvqh3mcbaqe"},{"post_id":"ck9iqcrtm003xqgvqcptg1syi","category_id":"ck9iqcrt8002jqgvq5o088r4q","_id":"ck9iqcrto004aqgvq8jn29cuc"},{"post_id":"ck9iqcrt8002mqgvq2wa9c5ob","category_id":"ck9iqcrtb002tqgvqd1rx4bt1","_id":"ck9mkhrs40005hkvq82xmc1mo"},{"post_id":"ck9mnug4x0006hkvq9p47ftcc","category_id":"ck9iqcrtb002tqgvqd1rx4bt1","_id":"ck9o58o3l0002rcvqe69f6she"},{"post_id":"ck9qpo7wd0000mkvq8i70awvc","category_id":"ck9iqcrtb002tqgvqd1rx4bt1","_id":"ck9sd7duo0006mkvqcsct749l"},{"post_id":"ck9tojqol0007mkvqaxvyhr8d","category_id":"ck9iqcrtb002tqgvqd1rx4bt1","_id":"ck9toklsg000amkvq4thhaopf"}],"PostTag":[{"post_id":"ck9iqcrru0009qgvq45hy772h","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrs3000eqgvq1pll9kzb"},{"post_id":"ck9iqcrru0009qgvq45hy772h","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrs6000hqgvqda1lbiar"},{"post_id":"ck9iqcrri0000qgvqgkkn31ch","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrse000mqgvq2atk1qxp"},{"post_id":"ck9iqcrri0000qgvqgkkn31ch","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrsg000pqgvq5c4z9sxp"},{"post_id":"ck9iqcrrx000aqgvq5r8x8t67","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrsi000tqgvq0k287m31"},{"post_id":"ck9iqcrs4000fqgvqgc3n7csx","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrsj000wqgvqa1o7hxwc"},{"post_id":"ck9iqcrs4000fqgvqgc3n7csx","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrsl0010qgvqg4c33qej"},{"post_id":"ck9iqcrro0001qgvqa80b64ht","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrsm0013qgvq72yx2hv1"},{"post_id":"ck9iqcrs6000iqgvqelt3292j","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrsn0017qgvqcc4s75am"},{"post_id":"ck9iqcrse000nqgvqenfidki6","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrso001aqgvqf0vg0uj1"},{"post_id":"ck9iqcrse000nqgvqenfidki6","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrsp001dqgvq1o634ftu"},{"post_id":"ck9iqcrsg000qqgvqf5z1dd20","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrsp001gqgvqdplebt16"},{"post_id":"ck9iqcrsg000qqgvqf5z1dd20","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrsr001jqgvq8j7h22op"},{"post_id":"ck9iqcrsi000uqgvqh2vjfrw3","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrss001mqgvqdrdl0tw9"},{"post_id":"ck9iqcrsi000uqgvqh2vjfrw3","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrst001pqgvqbgf75abb"},{"post_id":"ck9iqcrrr0004qgvq45qpc1qx","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrsw001sqgvqgfuz6fuu"},{"post_id":"ck9iqcrrr0004qgvq45qpc1qx","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrsw001vqgvqhqfq1ivj"},{"post_id":"ck9iqcrsj000xqgvqfm08eh04","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrsx001yqgvq9woz0en8"},{"post_id":"ck9iqcrsj000xqgvqfm08eh04","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrsz0021qgvq3xf0gbnb"},{"post_id":"ck9iqcrsl0011qgvq2oejfpwn","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrt10024qgvq94ci8ij1"},{"post_id":"ck9iqcrsl0011qgvq2oejfpwn","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrt30027qgvq3s0l9a58"},{"post_id":"ck9iqcrrr0005qgvqgkt43war","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrt4002aqgvqaz1g2e9s"},{"post_id":"ck9iqcrrr0005qgvqgkt43war","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrt6002dqgvqa2yra3rs"},{"post_id":"ck9iqcrsm0014qgvqa9y8cnaz","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrt7002gqgvqeqc2f7yt"},{"post_id":"ck9iqcrsm0014qgvqa9y8cnaz","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrt8002lqgvq45bdcuee"},{"post_id":"ck9iqcrsn0018qgvq8oenhqsx","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrt9002oqgvqhgkq44cu"},{"post_id":"ck9iqcrsn0018qgvq8oenhqsx","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrta002rqgvq7jlucjli"},{"post_id":"ck9iqcrrs0006qgvqhg3whj7v","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtb002wqgvq7hof5jzy"},{"post_id":"ck9iqcrso001bqgvqaxh8brra","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtc002zqgvq4l1281hg"},{"post_id":"ck9iqcrsp001eqgvqhy7gb432","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrtd0032qgvq54nhgvz3"},{"post_id":"ck9iqcrsp001eqgvqhy7gb432","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrte0035qgvqeo4m23vo"},{"post_id":"ck9iqcrsq001hqgvqegyw736o","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrtf0038qgvqh46rfrqy"},{"post_id":"ck9iqcrsq001hqgvqegyw736o","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtf003bqgvqebhz8m92"},{"post_id":"ck9iqcrsr001kqgvqas27bmwy","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtg003eqgvq2ifv6teo"},{"post_id":"ck9iqcrss001nqgvqbhxu90nl","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrth003hqgvqaop5e25t"},{"post_id":"ck9iqcrss001nqgvqbhxu90nl","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrti003kqgvq8ois9exl"},{"post_id":"ck9iqcrst001qqgvqevta0okr","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrtj003nqgvq8txuf550"},{"post_id":"ck9iqcrst001qqgvqevta0okr","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtj003qqgvqewww6ds6"},{"post_id":"ck9iqcrsw001tqgvqdev3c6gw","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrtl003tqgvqf3tsblh7"},{"post_id":"ck9iqcrsw001tqgvqdev3c6gw","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtm003wqgvqd9ur8y1p"},{"post_id":"ck9iqcrsx001wqgvq8gighnno","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrtn003zqgvq2da1b5ad"},{"post_id":"ck9iqcrsx001wqgvq8gighnno","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtn0041qgvqhy03hgx4"},{"post_id":"ck9iqcrsx001zqgvq7w4rbhvy","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrtn0043qgvqfwul4uvj"},{"post_id":"ck9iqcrsx001zqgvq7w4rbhvy","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtn0045qgvqcdqtevec"},{"post_id":"ck9iqcrsz0022qgvq0iq440fl","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrtn0047qgvqdbz0f5ae"},{"post_id":"ck9iqcrsz0022qgvq0iq440fl","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtn0049qgvqctd1a045"},{"post_id":"ck9iqcrt20025qgvqe70m7uyv","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrto004bqgvqc532axbf"},{"post_id":"ck9iqcrt20025qgvqe70m7uyv","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrto004cqgvqf4pxc2ax"},{"post_id":"ck9iqcrt30028qgvqhqecfxum","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrto004dqgvqhpog4mrn"},{"post_id":"ck9iqcrt4002bqgvq6jan5p5t","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrto004eqgvqc3v41eok"},{"post_id":"ck9iqcrt7002hqgvqbigbbyld","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrto004fqgvqbf9zfi2x"},{"post_id":"ck9iqcrt9002pqgvq49wk6rzw","tag_id":"ck9iqcrt8002kqgvq3arvb7em","_id":"ck9iqcrto004gqgvqhsse482f"},{"post_id":"ck9iqcrt9002pqgvq49wk6rzw","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrto004hqgvq5efr4sna"},{"post_id":"ck9iqcrt6002eqgvqfnvr1i8m","tag_id":"ck9iqcrt8002kqgvq3arvb7em","_id":"ck9iqcrto004iqgvqhbatc2qd"},{"post_id":"ck9iqcrt6002eqgvqfnvr1i8m","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrto004jqgvq3rcxbteo"},{"post_id":"ck9iqcrta002sqgvqefwk1n1r","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrto004kqgvqgiehdbvr"},{"post_id":"ck9iqcrtc002xqgvq23twhxba","tag_id":"ck9iqcrtb002uqgvq4frn8twu","_id":"ck9iqcrto004lqgvq4bws5p0b"},{"post_id":"ck9iqcrtc002xqgvq23twhxba","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrto004mqgvqf9xz8was"},{"post_id":"ck9iqcrtc0030qgvq6gxo85k0","tag_id":"ck9iqcrt8002kqgvq3arvb7em","_id":"ck9iqcrto004pqgvqbltles6v"},{"post_id":"ck9iqcrtc0030qgvq6gxo85k0","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrto004qqgvq7nucf9eu"},{"post_id":"ck9iqcrtd0033qgvq2mdgb6q4","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrto004rqgvqcu9kge3g"},{"post_id":"ck9iqcrte0036qgvq54uqcb2o","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtp004sqgvqdidk7qcl"},{"post_id":"ck9iqcrtf0039qgvq115a60v6","tag_id":"ck9iqcrtb002uqgvq4frn8twu","_id":"ck9iqcrtp004tqgvq6zk80pee"},{"post_id":"ck9iqcrtf0039qgvq115a60v6","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtp004uqgvqek5nbivf"},{"post_id":"ck9iqcrtg003cqgvq3gv5a0g6","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrtp004vqgvq80uj1phx"},{"post_id":"ck9iqcrtg003cqgvq3gv5a0g6","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtp004wqgvqfid06jv5"},{"post_id":"ck9iqcrtg003fqgvq35oofyh0","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtp004xqgvq1zrngahr"},{"post_id":"ck9iqcrth003iqgvqg393cxl9","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtp004yqgvq43tv40l4"},{"post_id":"ck9iqcrti003lqgvqhmf54wov","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtp004zqgvq3grrc3hl"},{"post_id":"ck9iqcrtj003oqgvqfhx2ff3l","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtp0050qgvqgmt81evs"},{"post_id":"ck9iqcrtj003rqgvq01mc8t1s","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtp0051qgvqffrgglkd"},{"post_id":"ck9iqcrtl003uqgvqe9r6ay45","tag_id":"ck9iqcrrq0003qgvqaw2o2q5o","_id":"ck9iqcrtp0052qgvq1fziajs9"},{"post_id":"ck9iqcrtl003uqgvqe9r6ay45","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtp0053qgvq329bdvyw"},{"post_id":"ck9iqcrtm003xqgvqcptg1syi","tag_id":"ck9iqcrt8002kqgvq3arvb7em","_id":"ck9iqcrtp0054qgvq1vfs2mxr"},{"post_id":"ck9iqcrtm003xqgvqcptg1syi","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9iqcrtp0055qgvqdmwf8b6r"},{"post_id":"ck9iqcrt8002mqgvq2wa9c5ob","tag_id":"ck9iqcrtb002uqgvq4frn8twu","_id":"ck9mkhrs20003hkvq9h7lgsen"},{"post_id":"ck9iqcrt8002mqgvq2wa9c5ob","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9mkhrs40004hkvq164jf2f0"},{"post_id":"ck9mnug4x0006hkvq9p47ftcc","tag_id":"ck9iqcrtb002uqgvq4frn8twu","_id":"ck9o58o3i0000rcvq680x3cpv"},{"post_id":"ck9mnug4x0006hkvq9p47ftcc","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9o58o3l0001rcvqbe1l1s1r"},{"post_id":"ck9qpo7wd0000mkvq8i70awvc","tag_id":"ck9iqcrtb002uqgvq4frn8twu","_id":"ck9sd7dug0004mkvq18cnhe1e"},{"post_id":"ck9qpo7wd0000mkvq8i70awvc","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9sd7dun0005mkvqh0vw0w9n"},{"post_id":"ck9tojqol0007mkvqaxvyhr8d","tag_id":"ck9iqcrtb002uqgvq4frn8twu","_id":"ck9tokgwy0008mkvq65ej8cvn"},{"post_id":"ck9tojqol0007mkvqaxvyhr8d","tag_id":"ck9iqcrrt0008qgvq2kopc1yj","_id":"ck9tokgwz0009mkvqan1cc2m4"}],"Tag":[{"name":"ECMAScript6","_id":"ck9iqcrrq0003qgvqaw2o2q5o"},{"name":"JavaScript","_id":"ck9iqcrrt0008qgvq2kopc1yj"},{"name":"jQuery","_id":"ck9iqcrt8002kqgvq3arvb7em"},{"name":"Core JavaScript","_id":"ck9iqcrtb002uqgvq4frn8twu"}]}}